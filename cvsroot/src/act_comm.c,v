head	1.206;
access;
symbols;
locks; strict;
comment	@ * @;


1.206
date	2004.09.03.02.24.40;	author boogums;	state Exp;
branches;
next	1.205;

1.205
date	2004.09.01.02.35.00;	author boogums;	state Exp;
branches;
next	1.204;

1.204
date	2004.08.29.22.50.13;	author boogums;	state Exp;
branches;
next	1.203;

1.203
date	2004.05.04.01.10.00;	author boogums;	state Exp;
branches;
next	1.202;

1.202
date	2003.12.17.03.59.41;	author boogums;	state Exp;
branches;
next	1.201;

1.201
date	2003.12.14.20.31.35;	author boogums;	state Exp;
branches;
next	1.200;

1.200
date	2003.12.09.21.50.09;	author mud;	state Exp;
branches;
next	1.199;

1.199
date	2003.12.09.21.35.08;	author mud;	state Exp;
branches;
next	1.198;

1.198
date	2003.12.09.21.33.31;	author rusty;	state Exp;
branches;
next	1.197;

1.197
date	2003.12.06.23.09.55;	author boogums;	state Exp;
branches;
next	1.196;

1.196
date	2003.12.06.22.14.33;	author boogums;	state Exp;
branches;
next	1.195;

1.195
date	2003.10.08.00.49.27;	author ndagger;	state Exp;
branches;
next	1.194;

1.194
date	2003.09.04.01.05.11;	author boogums;	state Exp;
branches;
next	1.193;

1.193
date	2003.09.02.13.26.47;	author boogums;	state Exp;
branches;
next	1.192;

1.192
date	2003.09.01.23.23.45;	author boogums;	state Exp;
branches;
next	1.191;

1.191
date	2003.09.01.23.16.09;	author boogums;	state Exp;
branches;
next	1.190;

1.190
date	2003.08.30.21.53.52;	author boogums;	state Exp;
branches;
next	1.189;

1.189
date	2003.05.25.14.32.21;	author boogums;	state Exp;
branches;
next	1.188;

1.188
date	2003.05.25.01.34.22;	author boogums;	state Exp;
branches;
next	1.187;

1.187
date	2003.03.23.00.06.55;	author boogums;	state Exp;
branches;
next	1.186;

1.186
date	2003.03.22.23.03.34;	author boogums;	state Exp;
branches;
next	1.185;

1.185
date	2002.12.05.05.16.56;	author boogums;	state Exp;
branches;
next	1.184;

1.184
date	2002.11.11.18.37.01;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2002.11.11.18.35.17;	author rusty;	state Exp;
branches;
next	1.182;

1.182
date	2002.10.29.01.32.33;	author ndagger;	state Exp;
branches;
next	1.181;

1.181
date	2002.10.28.05.43.52;	author boogums;	state Exp;
branches;
next	1.180;

1.180
date	2002.10.28.05.26.20;	author ndagger;	state Exp;
branches;
next	1.179;

1.179
date	2002.10.28.05.03.57;	author boogums;	state Exp;
branches;
next	1.178;

1.178
date	2002.10.28.04.57.18;	author boogums;	state Exp;
branches;
next	1.177;

1.177
date	2002.10.28.04.48.46;	author ndagger;	state Exp;
branches;
next	1.176;

1.176
date	2002.10.18.14.31.39;	author boogums;	state Exp;
branches;
next	1.175;

1.175
date	2002.10.18.04.07.26;	author boogums;	state Exp;
branches;
next	1.174;

1.174
date	2002.10.18.03.57.56;	author boogums;	state Exp;
branches;
next	1.173;

1.173
date	2002.10.18.03.47.32;	author boogums;	state Exp;
branches;
next	1.172;

1.172
date	2002.10.04.18.55.34;	author boogums;	state Exp;
branches;
next	1.171;

1.171
date	2002.10.04.18.50.58;	author boogums;	state Exp;
branches;
next	1.170;

1.170
date	2002.10.04.18.43.53;	author boogums;	state Exp;
branches;
next	1.169;

1.169
date	2002.09.22.21.43.24;	author boogums;	state Exp;
branches;
next	1.168;

1.168
date	2002.09.21.04.39.08;	author boogums;	state Exp;
branches;
next	1.167;

1.167
date	2002.06.14.18.51.19;	author rusty;	state Exp;
branches;
next	1.166;

1.166
date	2002.04.18.19.33.13;	author poquah;	state Exp;
branches;
next	1.165;

1.165
date	2002.04.03.15.56.18;	author rusty;	state Exp;
branches;
next	1.164;

1.164
date	2002.04.01.21.05.43;	author rusty;	state Exp;
branches;
next	1.163;

1.163
date	2002.03.12.03.01.07;	author rusty;	state Exp;
branches;
next	1.162;

1.162
date	2002.03.09.19.55.58;	author rusty;	state Exp;
branches;
next	1.161;

1.161
date	2002.03.09.19.14.26;	author rusty;	state Exp;
branches;
next	1.160;

1.160
date	2001.12.21.00.44.59;	author rage;	state Exp;
branches;
next	1.159;

1.159
date	2001.12.07.19.00.50;	author poquah;	state Exp;
branches;
next	1.158;

1.158
date	2001.12.05.18.47.44;	author poquah;	state Exp;
branches;
next	1.157;

1.157
date	2001.12.05.17.19.45;	author poquah;	state Exp;
branches;
next	1.156;

1.156
date	2001.12.05.17.07.03;	author poquah;	state Exp;
branches;
next	1.155;

1.155
date	2001.12.03.18.34.53;	author poquah;	state Exp;
branches;
next	1.154;

1.154
date	2001.12.03.15.13.33;	author poquah;	state Exp;
branches;
next	1.153;

1.153
date	2001.12.03.15.11.22;	author poquah;	state Exp;
branches;
next	1.152;

1.152
date	2001.12.03.14.43.29;	author poquah;	state Exp;
branches;
next	1.151;

1.151
date	2001.11.28.18.54.55;	author poquah;	state Exp;
branches;
next	1.150;

1.150
date	2001.11.28.18.54.11;	author poquah;	state Exp;
branches;
next	1.149;

1.149
date	2001.11.25.05.24.23;	author poquah;	state Exp;
branches;
next	1.148;

1.148
date	2001.10.13.02.11.58;	author rage;	state Exp;
branches;
next	1.147;

1.147
date	2001.09.22.17.53.00;	author rage;	state Exp;
branches;
next	1.146;

1.146
date	2001.09.22.15.20.44;	author boogums;	state Exp;
branches;
next	1.145;

1.145
date	2001.09.22.15.01.00;	author boogums;	state Exp;
branches;
next	1.144;

1.144
date	2001.09.22.00.10.48;	author boogums;	state Exp;
branches;
next	1.143;

1.143
date	2001.09.20.03.10.30;	author boogums;	state Exp;
branches;
next	1.142;

1.142
date	2001.08.30.03.34.12;	author guerrand;	state Exp;
branches;
next	1.141;

1.141
date	2001.08.30.03.22.10;	author guerrand;	state Exp;
branches;
next	1.140;

1.140
date	2001.08.30.01.45.44;	author guerrand;	state Exp;
branches;
next	1.139;

1.139
date	2001.08.30.01.16.21;	author guerrand;	state Exp;
branches;
next	1.138;

1.138
date	2001.08.30.01.03.22;	author guerrand;	state Exp;
branches;
next	1.137;

1.137
date	2001.03.21.20.33.57;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	2001.03.15.19.10.21;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	2001.03.15.18.58.50;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	2001.03.15.18.55.01;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	2001.01.23.19.59.00;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	2000.12.24.02.22.37;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	2000.12.16.04.47.02;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	2000.12.15.06.22.29;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	2000.10.16.19.16.58;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	2000.10.09.21.20.30;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	2000.09.19.20.47.11;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	2000.09.19.20.04.20;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	2000.09.18.05.16.18;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	2000.09.18.05.13.45;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	2000.08.29.16.44.00;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	2000.08.29.16.40.14;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	2000.08.29.16.28.24;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	2000.08.28.13.38.06;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	2000.08.26.03.26.13;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	2000.08.23.13.38.02;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	2000.08.23.13.26.22;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2000.08.20.00.13.17;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	2000.08.20.00.11.23;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	2000.08.19.20.17.54;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	2000.08.18.22.49.01;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	2000.08.17.18.14.41;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	2000.08.17.17.17.59;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	2000.08.17.15.41.16;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	2000.08.17.14.29.26;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	2000.07.25.19.43.45;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	2000.07.25.16.52.19;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	2000.07.21.17.34.20;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	2000.07.21.17.14.17;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	2000.07.18.17.06.27;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	2000.07.18.01.03.09;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2000.07.18.00.56.54;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2000.07.13.00.14.09;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2000.07.11.23.18.56;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2000.05.30.00.26.37;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2000.05.29.19.36.59;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	2000.05.26.02.34.25;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	2000.05.26.02.32.55;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	2000.05.26.01.46.23;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	2000.05.25.03.08.08;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	2000.05.25.03.06.05;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	2000.05.24.03.53.42;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	2000.05.24.03.38.29;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	2000.05.23.04.12.36;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	2000.05.21.05.16.19;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	2000.05.21.04.47.45;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	2000.05.21.00.28.51;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	2000.05.20.23.47.57;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	2000.05.20.01.12.18;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	2000.05.16.00.55.56;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	2000.05.14.00.48.40;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	2000.05.13.22.44.51;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	2000.05.13.22.37.21;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	2000.05.13.22.11.07;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	2000.05.13.22.06.45;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2000.05.13.21.57.49;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	2000.05.13.21.55.07;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	2000.04.18.19.50.49;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	2000.04.17.22.00.42;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	2000.03.06.16.50.17;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	2000.03.06.16.02.17;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	2000.03.06.15.59.18;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2000.02.29.01.25.24;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2000.02.29.01.05.14;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2000.02.20.07.50.33;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2000.02.20.07.45.13;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	2000.02.04.02.18.41;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	2000.02.03.00.51.32;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	2000.02.02.23.18.01;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	2000.02.01.02.55.31;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	2000.01.28.19.04.14;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	2000.01.10.23.40.06;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.12.15.00.56.52;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.11.05.08.19.10;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.10.31.02.23.18;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.10.25.00.21.11;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.10.20.18.02.54;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.10.20.18.00.20;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.10.20.17.56.43;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.10.02.00.09.04;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.08.23.03.34.38;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.08.13.21.35.49;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.07.14.18.13.24;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.06.20.20.29.17;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.06.11.23.40.41;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.05.19.18.25.44;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.05.18.23.01.50;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.05.18.23.00.41;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.05.17.05.31.06;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.04.28.08.09.29;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.04.24.03.22.14;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.04.23.23.43.35;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.04.23.22.33.12;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	99.04.23.03.37.20;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.04.22.20.37.25;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.04.16.16.17.05;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.04.14.18.57.25;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	99.04.14.07.16.49;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.04.12.21.57.46;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	99.03.24.21.12.38;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.03.24.20.02.36;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	99.01.11.19.23.11;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	99.01.11.16.55.42;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.12.16.20.42.37;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.12.15.22.17.19;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.12.13.03.05.34;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.12.09.08.32.14;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.12.07.12.58.15;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.12.02.09.06.35;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.11.29.22.26.18;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.11.22.08.21.09;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.11.22.00.04.29;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.11.19.09.05.59;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.11.14.07.15.48;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.10.17.07.12.09;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.10.13.05.55.58;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.10.13.05.50.19;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.10.13.00.02.58;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.10.12.21.04.43;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.10.12.19.49.12;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.10.11.20.46.00;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.10.06.23.32.01;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.10.01.22.23.11;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.10.01.05.32.07;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.09.29.18.51.38;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.30.03.33.31;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.21.14.21.06;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.20.21.05.24;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.10.19.41.18;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.10.05.32.13;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.10.00.08.22;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.05.09.14.30;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.12;	author mud;	state Exp;
branches;
next	;


desc
@@


1.206
log
@t no more cgoss when silenced
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: act_comm.c,v 1.205 2004/09/01 02:35:00 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "merc.h"
#include "recycle.h"
#include "tables.h"
#include "interp.h"
#include "lookup.h"
#include "gladiator.h"

/* command procedures needed */
DECLARE_DO_FUN(do_quit  );

/* Locals */
void reclass		args( ( CHAR_DATA *ch, int class, bool fPenalty ) );

/* Externals */
void remove_highlander  args (( CHAR_DATA *ch, CHAR_DATA *victim));

/* Given two chars, send the inviso message */
void channel_vis_status( CHAR_DATA *ch, CHAR_DATA *victim )
{ 
    char buf[MAX_STRING_LENGTH];    
    if ( !IS_IMMORTAL(ch) || 
       ( !ch->invis_level && !ch->incog_level ) ||	
         !can_see(victim,ch,TRUE) ||	
         victim == ch )
    		return;    

    sprintf(buf,"({W%s{x@@{W%d{x) ",
	ch->invis_level ? 
	  (IS_SET(victim->display,DISP_BRIEF_WHOLIST)?"W":"Wizi") : 
	  (IS_SET(victim->display,DISP_BRIEF_WHOLIST)?"I":"Incog"),
	ch->invis_level ? ch->invis_level : ch->incog_level);    

    send_to_char(buf,victim);    
    return;
}

/* RT code to delete yourself */

void do_delet( CHAR_DATA *ch, char *argument)
{
    send_to_char("You must type the full command to delete yourself.\n\r",ch);
    return;
}

void do_delete( CHAR_DATA *ch, char *argument)
{
   char strsave[MAX_INPUT_LENGTH];

   if (IS_NPC(ch))
  return;
  
   if (ch->pcdata->confirm_delete)
   {
  if (argument[0] != '\0')
  {
      send_to_char("{RDelete status removed.{x\n\r",ch);
      ch->pcdata->confirm_delete = FALSE;
      return;
  }
  else
  {
      sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( ch->name ) );
      wiznet("{R$N turns $Mself into line noise.{x",ch,NULL,0,0,0);
      do_quit(ch,"");
      unlink(strsave);
      return;
  }
    }

    if (argument[0] != '\0')
    {
  send_to_char("Just type delete. No argument.\n\r",ch);
  return;
    }

    send_to_char("Type delete again to confirm this command.\n\r",ch);
    send_to_char("{RWARNING:{x this command is irreversible.\n\r",ch);
    send_to_char("Typing delete with an argument will undo delete status.\n\r",
  ch);
    ch->pcdata->confirm_delete = TRUE;
    wiznet("$N is contemplating deletion.",ch,NULL,0,0,get_trust(ch));
}

void do_reclas( CHAR_DATA *ch, char *argument)
{
    send_to_char("You must type the full command to reclass.\n\r",ch);
    return;
}
      
void do_reclass( CHAR_DATA *ch, char *argument)
{
    char arg[MAX_STRING_LENGTH];
    int i, class;

    if ( class_table[ch->class].reclass )
    {
       send_to_char ("You are already a \"reclass\" class.  You cannot reclass again.\r\n", ch);
       return;
    }


    if ( !HAS_MHS(ch,MHS_OLD_RECLASS) 
	 && ch->level <= 50 && ch->class == class_lookup("elementalist") )
    {
	send_to_char("You must be at least level 51 to reclass.\n\r",ch);
	return;
    }

    if ( !HAS_MHS(ch,MHS_OLD_RECLASS) && ch->level <= 25 )
    {
	send_to_char("You must be at least level 26 to reclass.\n\r",ch);
	return;
    }

    one_argument(argument,arg);
    if( arg[0] == '\0' )
    {
	send_to_char("Syntax: reclass <class>\n\r",ch);
	send_to_char("        reclass check\n\r",ch);
        return;
    }

    if ( !str_cmp(arg,"check") )
    {
    /*
	int penalty;
	char buf[MAX_STRING_LENGTH];
	*/

	if ( class_table[ch->class].reclass )
	{
	    send_to_char("You already reclassed.\n\r",ch);
	    return;
	}

	send_to_char("Available reclasses: ",ch);
   	for ( i = 0 ; i< MAX_CLASS ; i++ )
	{
	    if ( !class_table[i].reclass )
		continue;

	   if( class_table[i].allowed[0] == ch->class ||
	       class_table[i].allowed[1] == ch->class )
	       send_to_char( class_table[i].name, ch );
	   else
	   if ( ch->class == class_lookup("elementalist") &&
		i != class_lookup("berzerker") )
	       send_to_char( class_table[i].name, ch );
	   else
	   continue;

	   send_to_char(" ", ch);
	}

/*
	sprintf(buf, "\n\rCreation Point Offset: %2d\n\r",  
                    UMAX(0, (int) (80-ch->pcdata->points) / 4 ) );
	send_to_char(buf,ch);
	penalty =  UMAX(0, (int) (51-ch->level) / 3 );
        penalty += UMAX(0, (int) (30-ch->level) );
	sprintf(buf, "Level Offset:          %2d\n\r", penalty);
	send_to_char(buf,ch);
	send_to_char("-------------         ----\n\r",ch);
        sprintf(buf, "Total Penalty:         %2d\n\r",
		penalty + UMAX(0, (int) (80-ch->pcdata->points) /4) );
	send_to_char(buf,ch);

	if ( !is_clan(ch) )
		send_to_char("You will -NOT- be able to join a clan.\n\r",ch);
	else
		send_to_char("You -WILL- be able to join a clan.\n\r",ch);
		*/
	return;
    }

    class = class_lookup(arg);
    
    if( class == -1 )
    {
	send_to_char("You want to be a WHAT?\n\r",ch);
	return;
    }

    if(IS_SET(ch->mhs,MHS_SHAPESHIFTED) || IS_SET(ch->mhs,MHS_SHAPEMORPHED))
    {
      send_to_char("You are not allowed to reclass while shapeshifted.\n\r",ch);
      return;
    }

    if ( HAS_MHS(ch,MHS_OLD_RECLASS) )
    {
	REMOVE_BIT(ch->mhs, MHS_OLD_RECLASS);
	reclass( ch, class, FALSE );
        return;
    }

    if( class_table[ch->class].reclass
	|| !class_table[class].reclass || IS_NPC(ch) )
    {
	send_to_char("You can not reclass to that.\n\r",ch);
	return;
    }

    if ( class_table[class].allowed[0] != ch->class &&
	 class_table[class].allowed[1] != ch->class &&
         ch->class != class_lookup("elementalist") )
    {
	send_to_char("You don't qualify for that reclass.\n\r",ch);
	return;
    }
    else
    if ( class == class_lookup("berzerker") && 
	 ch->class == class_lookup("elementalist") )
    {
	send_to_char("You don't qualify for that reclass.\n\r",ch);
	return;
    }

    if( ch->level < 26 || ch->level > 51 ) 
    {
	send_to_char("You must be between levels 26 and 51 to reclass.\n\r",ch);
	return;
    }

    reclass(ch, class, TRUE );
    return;
}

void reclass( CHAR_DATA *ch, int class, bool fPenalty  )
{
    int i, sn, gn;

    ch->pcdata->old_class = ch->class;
    ch->class = class;

  if(IS_SET(ch->act,PLR_WERE)) REMOVE_BIT(ch->act,PLR_WERE);
  if(IS_SET(ch->act,PLR_VAMP)) REMOVE_BIT(ch->act,PLR_VAMP);
  if(IS_SET(ch->act,PLR_MUMMY)) REMOVE_BIT(ch->act,PLR_MUMMY);
  /* initialize stats */
  for (i = 0; i < MAX_STATS; i++)
      ch->perm_stat[i] = pc_race_table[ch->race].stats[i];
  ch->affected_by = ch->affected_by|race_table[ch->race].aff;
  ch->imm_flags   = ch->imm_flags|race_table[ch->race].imm;
  ch->res_flags   = ch->res_flags|race_table[ch->race].res;
  ch->vuln_flags  = ch->vuln_flags|race_table[ch->race].vuln;
  ch->form        = race_table[ch->race].form;
  ch->parts       = race_table[ch->race].parts;

  /* Remove specialization if any */
  ch->pcdata->specialize = 0;
  ch->kit = 0;
  ch->species_enemy = 0;

  /* add skills */
  for (i = 0; i < 5; i++)
  {
      if (pc_race_table[ch->race].skills[i] == NULL)
    break;
      group_add(ch,pc_race_table[ch->race].skills[i],FALSE);
  }

/*
  if ( fPenalty )
  {
  ch->pcdata->points = UMAX(0, (int) (80 - ch->pcdata->points) / 4 );
  ch->pcdata->points += UMAX(0, (int) (51  - ch->level) / 3 );
  ch->pcdata->points += UMAX(0, (int) (30 - ch->level) );
  ch->pcdata->points += pc_race_table[ch->race].points;
  }
  else
  */

  ch->pcdata->points = pc_race_table[ch->race].points;

  ch->size = pc_race_table[ch->race].size;

    while ( ch->affected )
        affect_remove( ch, ch->affected,APPLY_BOTH );
    ch->affected_by = 0;

    ch->pcdata->perm_hit =20;
    ch->max_hit = 20;
    ch->wimpy = 5;
    ch->practice = 5;
    ch->train = 3;
    ch->pcdata->perm_mana = 100;
    ch->max_mana = 100;
    ch->pcdata->perm_move = 100;
    ch->max_move = 100;
    ch->level = 1;
/*
    ch->played = ch->pcdata->last_level * 1800;
    ch->redid = ch->played;
*/
    ch->played = 0;
    ch->exp = 0;
 /*
    if ( is_clan(ch) ) 
	 SET_BIT(ch->act,PLR_CANCLAN);
	 */
    ch->clan = 0;
    ch->kit = 0;
    ch->pcdata->rank = 0;
    ch->pcdata->sac = 0;
    for ( sn = 0; sn < MAX_SKILL; sn++ )
    {
        if(skill_table[sn].name != NULL)
        ch->pcdata->learned[sn] = 0;
    }

    for ( gn = 0; gn < MAX_GROUP; gn++ )
    {
	gn_remove(ch,gn);
    }
    raw_kill(ch,ch);
    send_to_char("You will now be forced to quit. Upon reconnecting you "
		 "will begin the character generation process in your new "
		 "class.  If you loose link during this process, see an "
		 "IMM as soon as possible.\n\r",ch);
    SET_BIT(ch->act,PLR_RECLASS);
    /*
    ch->perm_stat[class_table[ch->class].attr_prime] += 3; 
    ch->perm_stat[class_table[ch->class].attr_second] += 2;
    */
    ch->trumps = 0;
    REMOVE_BIT(ch->act,PLR_KILLER);
    REMOVE_BIT(ch->act,PLR_THIEF);
    REMOVE_BIT(ch->wiznet,PLR_RUFFIAN);
    do_quit(ch,"");

  return;
}


void do_color( CHAR_DATA *ch, char *argument)
{
    char arg[MAX_STRING_LENGTH];
    char arg2[MAX_STRING_LENGTH];
    bool acted = FALSE;

    argument = one_argument(argument,arg);
    one_argument(argument,arg2);
    if( arg[0] == '\0' )
    {
	send_to_char("You must specify ON or OFF.\n\r",ch);
	return;
    }

    if(!str_cmp(arg,"on"))
    {
	if(!IS_SET(ch->display,DISP_COLOR))
	    SET_BIT(ch->display,DISP_COLOR);
	send_to_char("Color {CENABLED{x.\n\r",ch);
	acted = TRUE;
    }

    if(!str_cmp(arg,"off"))
    {
	if(IS_SET(ch->display,DISP_COLOR))
	    REMOVE_BIT(ch->display,DISP_COLOR);
	send_to_char("Color {RDISABLED{x.\n\r",ch);
	acted = TRUE;
    }

    if(acted == FALSE)
	send_to_char("That's not a valid option for color.\n\r",ch);

    return;
}

/* RT code to display channel status */

void do_channels( CHAR_DATA *ch, char *argument)
{
    char buf[MAX_STRING_LENGTH];

    /* lists all channels and their status */
    send_to_char("{W   channel     status{x\n\r",ch);
    send_to_char("---------------------\n\r",ch);
 
    send_to_char("gossip         ",ch);
    if (!IS_SET(ch->comm,COMM_NOGOSSIP))
      send_to_char("{CON{x\n\r",ch);
    else
      send_to_char("{ROFF{x\n\r",ch);

    send_to_char("OOC            ",ch);
    if (!IS_SET(ch->comm,COMM_NOOOC))
	send_to_char("{CON{x\n\r",ch);
    else
	send_to_char("{ROFF{x\n\r",ch);

    send_to_char("clan gossip    ",ch);
    if (!IS_SET(ch->comm,COMM_NOAUCTION))
      send_to_char("{CON{x\n\r",ch);
    else
      send_to_char("{ROFF{x\n\r",ch);

    send_to_char("music          ",ch);
    if (!IS_SET(ch->comm,COMM_NOMUSIC))
      send_to_char("{CON{x\n\r",ch);
    else
      send_to_char("{ROFF{x\n\r",ch);

    send_to_char("Q/A            ",ch);
    if (!IS_SET(ch->comm,COMM_NOQUESTION))
      send_to_char("{CON{x\n\r",ch);
    else
      send_to_char("{ROFF{x\n\r",ch);

    send_to_char("Quest          ",ch);
    if (!IS_SET(ch->comm,COMM_NOQUOTE))
  send_to_char("{CON{x\n\r",ch);
    else
  send_to_char("{ROFF{x\n\r",ch);

    send_to_char("grats          ",ch);
    if (!IS_SET(ch->comm,COMM_NOGRATS))
      send_to_char("{CON{x\n\r",ch);
    else
      send_to_char("{ROFF{x\n\r",ch);

    send_to_char("gladiator      ",ch);
    if (!IS_SET(ch->comm,COMM_NOGLADIATOR))
      send_to_char("{CON{x\n\r",ch);
    else
      send_to_char("{ROFF{x\n\r",ch);

    if (IS_IMMORTAL(ch))
    {
      send_to_char("god channel    ",ch);
      if(!IS_SET(ch->comm,COMM_NOWIZ))
  send_to_char("{CON{x\n\r",ch);
      else
  send_to_char("{ROFF{x\n\r",ch);
    }

/*
    send_to_char("shouts         ",ch);
    if (!IS_SET(ch->comm,COMM_SHOUTSOFF))
      send_to_char("ON\n\r",ch);
    else
      send_to_char("OFF\n\r",ch);
*/

    send_to_char("deaf           ",ch);
    if (!IS_SET(ch->comm,COMM_DEAF))
  send_to_char("{ROFF{x\n\r",ch);
    else
  send_to_char("{CON{x\n\r",ch);

    send_to_char("quiet mode     ",ch);
    if (IS_SET(ch->comm,COMM_QUIET))
      send_to_char("{CON{x\n\r",ch);
    else
      send_to_char("{ROFF{x\n\r",ch);

    if (IS_SET(ch->comm,COMM_AFK))
  send_to_char("You are {CAFK{x.\n\r",ch);

    if (IS_SET(ch->comm,COMM_SNOOP_PROOF))
  send_to_char("You are immune to snooping.\n\r",ch);
   
    if (ch->ignoring != NULL)
    {
	sprintf(buf,"You are ignoring {W%s{x.\n\r",ch->ignoring->name);
	send_to_char(buf,ch);
    }
    else
    {
	send_to_char("You are not ignoring anyone.\n\r",ch);
    }

    if (ch->lines != PAGELEN)
    {
  if (ch->lines)
  {
      sprintf(buf,"You display %d lines of scroll.\n\r",ch->lines+2);
      send_to_char(buf,ch);
  }
  else
      send_to_char("Scroll buffering is off.\n\r",ch);
    }

    if (ch->prompt != NULL)
    {
  sprintf(buf,"Your current prompt is: %s\n\r",ch->prompt);
  send_to_char(buf,ch);
    }

    if (IS_SET(ch->comm,COMM_SILENCE))
      send_to_char("You are silenced to spam.\n\r",ch);
  
    if (IS_SET(ch->comm,COMM_NOTELL))
      send_to_char("You cannot use tell.\n\r",ch);
 
    if (IS_SET(ch->comm,COMM_NOCHANNELS))
     send_to_char("You cannot use channels.\n\r",ch);

    if (IS_SET(ch->comm,COMM_NOEMOTE))
      send_to_char("You cannot show emotions.\n\r",ch);

}

/* RT deaf blocks out all shouts */

void do_deaf( CHAR_DATA *ch, char *argument)
{
    
   if (IS_SET(ch->comm,COMM_DEAF))
   {
     send_to_char("You can now hear tells again.\n\r",ch);
     REMOVE_BIT(ch->comm,COMM_DEAF);
   }
   else 
   {
     send_to_char("From now on, you won't hear tells.\n\r",ch);
     SET_BIT(ch->comm,COMM_DEAF);
   }
}

/* RT quiet blocks out all communication */

void do_quiet ( CHAR_DATA *ch, char * argument)
{
    if (IS_SET(ch->comm,COMM_QUIET))
    {
      send_to_char("Quiet mode removed.\n\r",ch);
      REMOVE_BIT(ch->comm,COMM_QUIET);
    }
   else
   {
     send_to_char("From now on, you will only hear says and emotes.\n\r",ch);
     SET_BIT(ch->comm,COMM_QUIET);
   }
}

/* afk command */

void do_afk ( CHAR_DATA *ch, char * argument)
{
    char buf[MAX_STRING_LENGTH];

    if (IS_SET(ch->comm,COMM_AFK))
    {
      send_to_char("AFK mode removed. Type 'replay' to see tells.\n\r",ch);
	if(!IS_NPC(ch))
	{
	  if(ch->pcdata->afk_counter == 1)
	  {
      sprintf(buf,"You have %d message waiting.\n\r",ch->pcdata->afk_counter);
	  }else{
      sprintf(buf,"You have %d messages waiting.\n\r",ch->pcdata->afk_counter);
	  }
      send_to_char(buf,ch);
	}
      act("$n returns from {CAFK{x.",ch,NULL,NULL,TO_ROOM,TRUE);
      REMOVE_BIT(ch->comm,COMM_AFK);
    }
   else
   {
     send_to_char("You are now in AFK mode.\n\r",ch);
     act("$n goes {CAFK{x.",ch,NULL,NULL,TO_ROOM,TRUE);
     SET_BIT(ch->comm,COMM_AFK);
   }
}

void do_replay (CHAR_DATA *ch, char *argument)
{
    if (IS_NPC(ch))
    {
  send_to_char("You can't replay.\n\r",ch);
  return;
    }

    if ( ch->pcdata->buffer == NULL )
    {
	send_to_char("You have no tells buffered.\n\r",ch);
	return;
    }


    page_to_char(buf_string(ch->pcdata->buffer),ch);
    ch->pcdata->afk_counter = 0;
    clear_buf(ch->pcdata->buffer);
}

/* RT auction rewritten in ROM style */
void do_auction( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;


    if ( IS_SET(ch->affected_by, AFF_CHARM) )
  return;

    if (argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOAUCTION))
      {
  send_to_char("Clan Gossip channel is now ON.\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOAUCTION);
      }
      else
      {
  send_to_char("Clan Gossip channel is now OFF.\n\r",ch);
  SET_BIT(ch->comm,COMM_NOAUCTION);
      }
    }
    else  /* auction message sent, turn auction on if it is off */
    {
  if (IS_SET(ch->comm,COMM_QUIET))
  {
    send_to_char("You must turn off quiet mode first.\n\r",ch);
    return;
  }

  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
    send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;

      }

  REMOVE_BIT(ch->comm,COMM_NOAUCTION);

      sprintf( buf, "You {Rclan gossip{x '%s'\n\r", argument );
      send_to_char( buf, ch );
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
  CHAR_DATA *victim;

  victim = d->original ? d->original : d->character;

  if ( d->connected == CON_PLAYING &&
       d->character != ch &&
       !IS_SET(victim->comm,COMM_NOAUCTION) &&
       !IS_SET(victim->comm,COMM_QUIET) 
	&& (victim->ignoring != ch) )

  {
      channel_vis_status(ch,victim);
      act_new("$n {Rclan gossips{x '$t'",
        ch,argument,d->character,TO_VICT,POS_DEAD,TRUE);
  }
      }
    }
}

void do_bitch( CHAR_DATA *ch, char *argument )
{
   char buf [MAX_STRING_LENGTH];
   DESCRIPTOR_DATA *d;

   if ( IS_SET(ch->affected_by, AFF_CHARM) )
      return;

   if (argument[0] == '\0')
   {
      if (IS_SET(ch->comm, COMM_NOBITCH))
      {
         send_to_char("Bitch channel is now ON.\n\r",ch);
         REMOVE_BIT(ch->comm,COMM_NOBITCH);
      }
      else
      {
         send_to_char("Bitch channel is now OFF.\n\r",ch);
         SET_BIT(ch->comm, COMM_NOBITCH);
      }
   }
   else
   {
      if (IS_SET(ch->comm,COMM_QUIET))
      {
         send_to_char("You can't bitch quietly.  Turn quiet mode off first.\n\r",ch);
         return;
      }
      if (IS_SET(ch->comm,COMM_NOCHANNELS))
      {
         send_to_char("You've done enough bitching.  The gods won't let you bitch more.\n\r",ch);
         return;
      }

      REMOVE_BIT(ch->comm, COMM_NOBITCH);

      sprintf(buf, "You {Mbitch{x '%s'\n\r", argument);
      send_to_char(buf,ch);
      for (d=descriptor_list; d != NULL; d = d->next )
      {
         CHAR_DATA *victim;
         victim = d->original ? d->original : d->character;
      
         if (d->connected == CON_PLAYING && d->character != ch
          && !IS_SET(victim->comm,COMM_NOBITCH) && !IS_SET(victim->comm,COMM_QUIET)
          && (victim->ignoring != ch) )
         {
            channel_vis_status(ch,victim);
            act_new("$n {Mbitches{x '$t'",ch,argument,d->character,TO_VICT,POS_DEAD,TRUE);
         }
      }
   }
}
 
   



/* RT chat replaced with ROM gossip */
void do_gossip( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
 
    if ( IS_SET(ch->affected_by, AFF_CHARM) )
  return;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;

    if (argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOGOSSIP))
      {
  send_to_char("Gossip channel is now ON.\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOGOSSIP);
      }
      else
      {
  send_to_char("Gossip channel is now OFF.\n\r",ch);
  SET_BIT(ch->comm,COMM_NOGOSSIP);
      }
    }
    else  /* gossip message sent, turn gossip on if it isn't already */
    {
  if (IS_SET(ch->comm,COMM_QUIET))
  {
    send_to_char("You must turn off quiet mode first.\n\r",ch);
    return;
  }
 
  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
    send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;
 
  }

      REMOVE_BIT(ch->comm,COMM_NOGOSSIP);
 
      sprintf( buf, "You {Wgossip{x '%s'\n\r", argument );
      send_to_char( buf, ch );

      for ( d = descriptor_list; d != NULL; d = d->next )
      {
  CHAR_DATA *victim;
 
  victim = d->original ? d->original : d->character;
 
  if ( (d->connected == CON_PLAYING) &&
       (d->character != ch) &&
       (!IS_SET(victim->comm,COMM_NOGOSSIP)) &&
       (!IS_SET(victim->comm,COMM_QUIET))  &&
	(victim->ignoring != ch) )
  {
    channel_vis_status(ch,victim);
    act_new( "$n {Wgossips{x '$t'", 
       ch,argument, d->character, TO_VICT,POS_SLEEPING,TRUE );
  }
      }
    }
}

void do_ooc( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    if ( is_affected(ch, gsn_cone_of_silence ))
    return;


    if ( IS_SET(ch->affected_by, AFF_CHARM) )
  return;

    if (argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOOOC))
      {
  send_to_char("OOC channel is now ON.\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOOOC);
      }
      else
      {
  send_to_char("OOC channel is now OFF.\n\r",ch);
  SET_BIT(ch->comm,COMM_NOOOC);
      }
    }
    else  /* gossip message sent, turn gossip on if it isn't already */
    {
  if (IS_SET(ch->comm,COMM_QUIET))
  {
    send_to_char("You must turn off quiet mode first.\n\r",ch);
    return;
  }

  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
    send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;

  }

      REMOVE_BIT(ch->comm,COMM_NOOOC);

      sprintf( buf, "You {COOC{x '%s'\n\r", argument );
      send_to_char( buf, ch );
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
  CHAR_DATA *victim;

  victim = d->original ? d->original : d->character;

  if ( d->connected == CON_PLAYING &&
       d->character != ch &&
       !IS_SET(victim->comm,COMM_NOOOC) &&
       !IS_SET(victim->comm,COMM_QUIET) &&
        (victim->ignoring != ch) )
  {
    channel_vis_status(ch,victim);
    act_new( "$n {COOC's{x '$t'",
       ch,argument, d->character, TO_VICT,POS_SLEEPING,TRUE );
  }
      }
    }
}

void do_grats( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;

    if ( is_affected(ch, gsn_cone_of_silence ))
    return;

    if (argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOGRATS))
      {
  send_to_char("Grats channel is now ON.\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOGRATS);
      }
      else
      {
  send_to_char("Grats channel is now OFF.\n\r",ch);
  SET_BIT(ch->comm,COMM_NOGRATS);
      }
    }
    else  /* grats message sent, turn grats on if it isn't already */
    {
  if (IS_SET(ch->comm,COMM_QUIET))
  {
    send_to_char("You must turn off quiet mode first.\n\r",ch);
    return;
  }
 
  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
    send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;
 
  }
 
      REMOVE_BIT(ch->comm,COMM_NOGRATS);
 
      sprintf( buf, "You {Ygrats{x '%s'\n\r", argument );
      send_to_char( buf, ch );
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
  CHAR_DATA *victim;
 
  victim = d->original ? d->original : d->character;
 
  if ( d->connected == CON_PLAYING &&
       d->character != ch &&
       !IS_SET(victim->comm,COMM_NOGRATS) &&
       !IS_SET(victim->comm,COMM_QUIET) &&
        (victim->ignoring != ch) )
  {
    channel_vis_status(ch,victim);
    act_new( "$n {Ygrats{x '$t'",
       ch,argument, d->character, TO_VICT,POS_SLEEPING,TRUE );
  }
      }
    }
}

void do_quest( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;

 
    if ( IS_SET(ch->affected_by, AFF_CHARM) )
  return;

    if (argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOQUOTE))
      {
  send_to_char("Quest channel is now ON.\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOQUOTE);
      }
      else
      {
  send_to_char("Quest channel is now OFF.\n\r",ch);
  SET_BIT(ch->comm,COMM_NOQUOTE);
      }
    }
    else  /* quest message sent, turn quest on if it isn't already */
    {
  if (IS_SET(ch->comm,COMM_QUIET))
  {
    send_to_char("You must turn off quiet mode first.\n\r",ch);
    return;
  }
 
  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
    send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;
 
  }
 
      REMOVE_BIT(ch->comm,COMM_NOQUOTE);
 
      sprintf( buf, "You quest '%s'\n\r", argument );
      send_to_char( buf, ch );
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
  CHAR_DATA *victim;
 
  victim = d->original ? d->original : d->character;
 
  if ( d->connected == CON_PLAYING &&
       d->character != ch &&
       !IS_SET(victim->comm,COMM_NOQUOTE) &&
       !IS_SET(victim->comm,COMM_QUIET) &&
        (victim->ignoring != ch) )
  {
    channel_vis_status(ch,victim);
    act_new( "$n quests '$t'",
       ch,argument, d->character, TO_VICT,POS_SLEEPING,TRUE );
  }
      }
    }
}

/* RT question channel */
void do_question( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;

 
    if ( IS_SET(ch->affected_by, AFF_CHARM) )
  return;

    if (argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOQUESTION))
      {
  send_to_char("Q/A channel is now ON.\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOQUESTION);
      }
      else
      {
  send_to_char("Q/A channel is now OFF.\n\r",ch);
  SET_BIT(ch->comm,COMM_NOQUESTION);
      }
    }
    else  /* question sent, turn Q/A on if it isn't already */
    {
  if (IS_SET(ch->comm,COMM_QUIET))
  {
    send_to_char("You must turn off quiet mode first.\n\r",ch);
    return;
  }
 
  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
    send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;
  }
 
  REMOVE_BIT(ch->comm,COMM_NOQUESTION);
 
      sprintf( buf, "You {Bquestion{x '%s'\n\r", argument );
      send_to_char( buf, ch );
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
  CHAR_DATA *victim;
 
  victim = d->original ? d->original : d->character;
 
  if ( d->connected == CON_PLAYING &&
       d->character != ch &&
       !IS_SET(victim->comm,COMM_NOQUESTION) &&
       !IS_SET(victim->comm,COMM_QUIET) &&
        (victim->ignoring != ch) )
  {
    channel_vis_status(ch,victim);
    act_new("$n {Bquestions{x '$t'",
      ch,argument,d->character,TO_VICT,POS_SLEEPING,TRUE);
  }
      }
    }
}

/* RT answer channel - uses same line as questions */
void do_answer( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;

 
    if (argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOQUESTION))
      {
  send_to_char("Q/A channel is now ON.\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOQUESTION);
      }
      else
      {
  send_to_char("Q/A channel is now OFF.\n\r",ch);
  SET_BIT(ch->comm,COMM_NOQUESTION);
      }
    }
    else  /* answer sent, turn Q/A on if it isn't already */
    {
  if (IS_SET(ch->comm,COMM_QUIET))
  {
    send_to_char("You must turn off quiet mode first.\n\r",ch);
    return;
  }
 
  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
    send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;
  }
 
  REMOVE_BIT(ch->comm,COMM_NOQUESTION);
 
      sprintf( buf, "You {Banswer{x '%s'\n\r", argument );
      send_to_char( buf, ch );
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
  CHAR_DATA *victim;
 
  victim = d->original ? d->original : d->character;
 
  if ( d->connected == CON_PLAYING &&
       d->character != ch &&
       !IS_SET(victim->comm,COMM_NOQUESTION) &&
       !IS_SET(victim->comm,COMM_QUIET) &&
        (victim->ignoring != ch) )
  {
    channel_vis_status(ch,victim);
    act_new("$n {Banswers{x '$t'",
      ch,argument,d->character,TO_VICT,POS_SLEEPING,TRUE);
  }
      }
    }
}

/* RT music channel */
void do_music( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
 
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;

    if (argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOMUSIC))
      {
  send_to_char("Music channel is now ON.\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOMUSIC);
      }
      else
      {
  send_to_char("Music channel is now OFF.\n\r",ch);
  SET_BIT(ch->comm,COMM_NOMUSIC);
      }
    }
    else  /* music sent, turn music on if it isn't already */
    {
  if (IS_SET(ch->comm,COMM_QUIET))
  {
    send_to_char("You must turn off quiet mode first.\n\r",ch);
    return;
  }
 
  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
    send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;
  }
 
  REMOVE_BIT(ch->comm,COMM_NOMUSIC);
 
      sprintf( buf, "You MUSIC: '%s'\n\r", argument );
      send_to_char( buf, ch );
      sprintf( buf, "$n MUSIC: '%s'", argument );
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
  CHAR_DATA *victim;
 
  victim = d->original ? d->original : d->character;
 
  if ( d->connected == CON_PLAYING &&
       d->character != ch &&
       !IS_SET(victim->comm,COMM_NOMUSIC) &&
       !IS_SET(victim->comm,COMM_QUIET) &&
        (victim->ignoring != ch) )
  {
	channel_vis_status(ch,victim);
      act_new("$n MUSIC: '$t'",
        ch,argument,d->character,TO_VICT,POS_SLEEPING,TRUE);
  }
      }
    }
}


/* MM clan channels */
void do_clantalk( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;


    if ( IS_SET(ch->affected_by, AFF_CHARM) )
  return;

    if ( !ch->clan )
    {
  send_to_char("You aren't in a clan.\n\r",ch);
  return;
    }

    if ( clan_table[ch->clan].independent  && clan_table[ch->clan].true_clan )
    {
  send_to_char("No one is listening...\n\r",ch);
  return;
    }

    if( !IS_NPC(ch) && IS_SET(ch->pcdata->clan_flags, CLAN_NO_CHANNEL ))
     {
     send_to_char("You have been forbidden to use the clan channel.\n\r", ch);
     return;
     }
     
    if ( argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOCLAN))
      {
  send_to_char("Clan channel is now ON\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOCLAN);
      }
      else
      {
  send_to_char("Clan channel is now OFF\n\r",ch);
  SET_BIT(ch->comm,COMM_NOCLAN);
      }
      return;
    }

  if (IS_SET(ch->comm,COMM_NOCHANNELS))
  {
   send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
    return;
  }

  REMOVE_BIT(ch->comm,COMM_NOCLAN);

      sprintf( buf, "You {Gclan{x '%s'\n\r", argument );
      send_to_char( buf, ch );
      sprintf( buf, "$n {Gclans{x '%s'", argument );
    for ( d = descriptor_list; d != NULL; d = d->next )
    { 
	CHAR_DATA *victim;

	victim = d->original ? d->original : d->character;

     if( d->connected != CON_PLAYING ) continue;

      if ( (d->connected == CON_PLAYING) &&
           (d->character != ch) &&
           (is_same_clan(ch,victim) || IS_SET(victim->mhs,MHS_LISTEN) ) &&
           (!IS_SET(d->character->comm,COMM_NOCLAN)) &&
           (!IS_SET(d->character->comm,COMM_QUIET)) &&
        (d->character->ignoring != ch) )
  {
      if ( !is_same_clan(ch,victim) )
      {
	  sprintf(buf,"%s] ",clan_table[ch->clan].who_name);
	  send_to_char(buf,victim);
      } 

    channel_vis_status(ch,d->character);
    act_new("$n {Gclans{x '$t'",ch,argument,d->character,TO_VICT,POS_DEAD,TRUE);
  }
    }

    return;
}

void do_immtalk( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;

    if ( argument[0] == '\0' )
    {
      if (IS_SET(ch->comm,COMM_NOWIZ))
      {
  send_to_char("Immortal channel is now ON\n\r",ch);
  REMOVE_BIT(ch->comm,COMM_NOWIZ);
      }
      else
      {
  send_to_char("Immortal channel is now OFF\n\r",ch);
  SET_BIT(ch->comm,COMM_NOWIZ);
      } 
      return;
    }

    REMOVE_BIT(ch->comm,COMM_NOWIZ);

    sprintf( buf, "$n: %s", argument );
    act_new("$n: $t",ch,argument,NULL,TO_CHAR,POS_DEAD,TRUE);
    for ( d = descriptor_list; d != NULL; d = d->next )
    {
  if ( (d->connected == CON_PLAYING) && 
       (IS_IMMORTAL(d->character)) && 
       (!IS_SET(d->character->comm,COMM_NOWIZ)) )
  {
	channel_vis_status(ch,d->character);
      act_new("$n: $t",ch,argument,d->character,TO_VICT,POS_DEAD,TRUE);
  }
    }

    return;
}



void do_say( CHAR_DATA *ch, char *argument )
{
    if ( argument[0] == '\0' )
    {
  send_to_char( "Say what?\n\r", ch );
  return;
    }

    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;

    act( "$n says '$T'", ch, NULL, argument, TO_ROOM, FALSE );
    act( "You say '$T'", ch, NULL, argument, TO_CHAR, FALSE );
    return;
}


void do_silence( CHAR_DATA *ch, char *argument )
{

    if ( IS_SET( ch->comm, COMM_SILENCE ) )
    {
	send_to_char("Silence removed, brace for spam!\n\r",ch);
	REMOVE_BIT(ch->comm, COMM_SILENCE);
        return;
    }
    else
    {
	send_to_char("Ahhhhhhh, no more spam.\n\r",ch);
	SET_BIT(ch->comm,COMM_SILENCE);
	return;
    }
}

/* removed by Ben ... it's pointless ***
void do_shout( CHAR_DATA *ch, char *argument )
{
    DESCRIPTOR_DATA *d;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;

    if (argument[0] == '\0' )
    {
  if (IS_SET(ch->comm,COMM_SHOUTSOFF))
  {
      send_to_char("You can hear shouts again.\n\r",ch);
      REMOVE_BIT(ch->comm,COMM_SHOUTSOFF);
  }
  else
  {
      send_to_char("You will no longer hear shouts.\n\r",ch);
      SET_BIT(ch->comm,COMM_SHOUTSOFF);
  }
  return;
    }

    if ( IS_SET(ch->comm, COMM_NOSHOUT) )
    {
  send_to_char( "You can't shout.\n\r", ch );
  return;
    }
 
    REMOVE_BIT(ch->comm,COMM_SHOUTSOFF);

    WAIT_STATE( ch, 12 );

    act( "You shout '$T'", ch, NULL, argument, TO_CHAR, FALSE );
    for ( d = descriptor_list; d != NULL; d = d->next )
    {
  CHAR_DATA *victim;

  victim = d->original ? d->original : d->character;

  if ( d->connected == CON_PLAYING &&
       d->character != ch &&
       !IS_SET(victim->comm, COMM_SHOUTSOFF) &&
       !IS_SET(victim->comm, COMM_QUIET) &&
        (d->character->ignoring != ch) ) 
  {
      act("$n shouts '$t'",ch,argument,d->character,TO_VICT,FALSE);
  }
    }

    return;
}
***/


void do_tell( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH],buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    if ( IS_SET ( ch->comm, COMM_DEAF )) 
    {
  send_to_char ( "You must turn deaf off first.\n\r", ch );
  return;
    }
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;


    if ( IS_SET(ch->comm, COMM_NOTELL))
    {
  send_to_char( "Your message didn't get through.\n\r", ch );
  return;
    }

    if ( IS_SET(ch->comm, COMM_QUIET) )
    {
  send_to_char( "You must turn off quiet mode first.\n\r", ch);
  return;
    }

    if (IS_SET(ch->comm,COMM_DEAF))
    {
  send_to_char("You must turn off deaf mode first.\n\r",ch);
  return;
    }

    if (IS_AFFECTED(ch,AFF_SLEEP))
    {
  send_to_char("You're too tired.\n\r",ch);
  return;
    }

    argument = one_argument( argument, arg );

    if ( arg[0] == '\0' || argument[0] == '\0' )
    {
  send_to_char( "Tell whom what?\n\r", ch );
  return;
    }

    /*
     * Can tell to PC's anywhere, but NPC's only in same room.
     * -- Furey
     */
    if ( ( victim = get_char_world( ch, arg ) ) == NULL
    || ( IS_NPC(victim) && victim->in_room != ch->in_room ) )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( victim->desc == NULL && !IS_NPC(victim))
    {
  act("$N seems to have misplaced $S link...try again later.",
      ch,NULL,victim,TO_CHAR,TRUE);
  if(IS_SET(victim->display,DISP_COLOR))
    add_buf(victim->pcdata->buffer, BOLD);
  sprintf(buf,"%s tells you ",PERS(ch,victim,TRUE));
  buf[0] = UPPER(buf[0]);
  add_buf(victim->pcdata->buffer,buf);
  if(IS_SET(victim->display,DISP_COLOR))
    add_buf(victim->pcdata->buffer, NORMAL);
  sprintf(buf,"'%s'\n\r",argument);
  add_buf(victim->pcdata->buffer,buf);
  return;
    }

/*
    if ( !(IS_IMMORTAL(ch) && ch->level > LEVEL_IMMORTAL) && !IS_AWAKE(victim) )
    {
  act( "$E can't hear you.", ch, 0, victim, TO_CHAR, TRUE );
  return;
    }
 */ 
    if ((IS_SET(victim->comm,COMM_QUIET) || 
	IS_SET(victim->comm,COMM_DEAF) || (victim->ignoring == ch) )
    && !IS_IMMORTAL(ch))
    {
  act( "$E is not receiving tells.", ch, 0, victim, TO_CHAR, TRUE );
  return;
    }

    if (IS_SET(victim->comm,COMM_AFK))
    {
  if (IS_NPC(victim))
  {
      act("$E is AFK, and not receiving tells.",ch,NULL,victim,TO_CHAR,TRUE);
      return;
  }

  act("$E is AFK, but your tell will go through when $E returns.",
      ch,NULL,victim,TO_CHAR,TRUE);
  victim->pcdata->afk_counter = victim->pcdata->afk_counter + 1;
  if(IS_SET(victim->display,DISP_COLOR))
    add_buf(victim->pcdata->buffer, BOLD);
  sprintf(buf,"%s tells you ",PERS(ch,victim,TRUE));                 
  buf[0] = UPPER(buf[0]);
  add_buf(victim->pcdata->buffer,buf);
  if(IS_SET(victim->display,DISP_COLOR))
    add_buf(victim->pcdata->buffer, NORMAL);
  sprintf(buf,"'%s'\n\r",argument);
  add_buf(victim->pcdata->buffer,buf);
  return;
    }
    act( "You tell $N '$t'", ch, argument, victim, TO_CHAR, TRUE );
    if (IS_SET(victim->comm,COMM_TELL_BEEP))     
    {
      if(IS_SET(victim->display,DISP_COLOR))
        act_new(BOLD"\x07$n tells you"NORMAL" '$t'",
		ch,argument,victim,TO_VICT,POS_DEAD,TRUE);
      else
      act_new("\x07$n tells you '$t'",ch,argument,victim,TO_VICT,POS_DEAD,TRUE);
    }
    else
    {
      if(IS_SET(victim->display,DISP_COLOR))
        act_new(BOLD"$n tells you"NORMAL" '$t'",
		ch,argument,victim,TO_VICT,POS_DEAD,TRUE);
      else
      act_new("$n tells you '$t'",ch,argument,victim,TO_VICT,POS_DEAD,TRUE);
    }
    victim->reply       = ch;

    return;
}

void do_noreply( CHAR_DATA *ch, char *argument )
{
    DESCRIPTOR_DATA *d;

  for ( d = descriptor_list; d != NULL; d = d->next )
      {
	if ( d->connected == CON_PLAYING
	   &&  (d->character->reply == ch)
	   &&  (d->character->level <= ch->level) )
	d->character->reply = NULL;
       }
   return;
}


void do_reply( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char buf[MAX_STRING_LENGTH];
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;


    if ( IS_SET(ch->comm, COMM_NOTELL) )
    {
  send_to_char( "Your message didn't get through.\n\r", ch );
  return;
    }

    if ( ( victim = ch->reply ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( victim->desc == NULL && !IS_NPC(victim))
    {
  act("$N seems to have misplaced $S link...try again later.",
      ch,NULL,victim,TO_CHAR,TRUE);
  if(IS_SET(victim->display,DISP_COLOR))
    add_buf(victim->pcdata->buffer, BOLD);
  sprintf(buf,"%s tells you ",PERS(ch,victim,TRUE));
  buf[0] = UPPER(buf[0]);
  add_buf(victim->pcdata->buffer,buf);
  if(IS_SET(victim->display,DISP_COLOR))
    add_buf(victim->pcdata->buffer, NORMAL);
  sprintf(buf,"'%s'\n\r",argument);
  add_buf(victim->pcdata->buffer,buf);
  return;
    }

/**
    if ( !IS_IMMORTAL(ch) && !IS_AWAKE(victim) )
    {
  act( "$E can't hear you.", ch, 0, victim, TO_CHAR, TRUE );
  return;
    }
 **/
    if ((IS_SET(victim->comm,COMM_QUIET) || 
	IS_SET(victim->comm,COMM_DEAF) || (victim->ignoring == ch))
    &&  !IS_IMMORTAL(ch) && !IS_IMMORTAL(victim))
    {
  act_new( "$E is not receiving tells.", ch, 0, victim, TO_CHAR,POS_DEAD,TRUE);
  return;
    }

/**
    if (!IS_IMMORTAL(victim) && !IS_AWAKE(ch))
 **/
    if ( IS_AFFECTED( ch, AFF_SLEEP ) )
  {
  send_to_char( "In your dreams, or what?\n\r", ch );
  return;
    }

    if (IS_SET(victim->comm,COMM_AFK))
    {
  if (IS_NPC(victim))
  {
      act_new("$E is AFK, and not receiving tells.",
    ch,NULL,victim,TO_CHAR,POS_DEAD,TRUE);
      return;
  }
 
  act_new("$E is AFK, but your tell will go through when $E returns.",
      ch,NULL,victim,TO_CHAR,POS_DEAD,TRUE);
  if(IS_SET(victim->display,DISP_COLOR))
    add_buf(victim->pcdata->buffer, BOLD);
  sprintf(buf,"%s tells you ",PERS(ch,victim,TRUE));
  buf[0] = UPPER(buf[0]);
  add_buf(victim->pcdata->buffer,buf);
  if(IS_SET(victim->display,DISP_COLOR))
    add_buf(victim->pcdata->buffer, NORMAL);
  sprintf(buf,"'%s'\n\r",argument);
  add_buf(victim->pcdata->buffer,buf);
  return;
    }

    act_new("You tell $N '$t'",ch,argument,victim,TO_CHAR,POS_DEAD,TRUE);
    if (IS_SET(victim->comm,COMM_TELL_BEEP))     
      {
      if(IS_SET(victim->display,DISP_COLOR))
        act_new(BOLD"\x07$n tells you"NORMAL" '$t'",
		ch,argument,victim,TO_VICT,POS_DEAD,TRUE);
      else
      act_new("\x07$n tells you '$t'",ch,argument,victim,TO_VICT,POS_DEAD,TRUE);
      }
    else
      {
      if(IS_SET(victim->display,DISP_COLOR))
        act_new(BOLD"$n tells you"NORMAL" '$t'",
		ch,argument,victim,TO_VICT,POS_DEAD,TRUE);
      else
        act_new("$n tells you '$t'",ch,argument,victim,TO_VICT,POS_DEAD,TRUE);
      }
    victim->reply       = ch;

    return;
}



void do_yell( CHAR_DATA *ch, char *argument )
{
    DESCRIPTOR_DATA *d;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;


    if ( IS_SET(ch->comm, COMM_NOSHOUT) )
    {
  send_to_char( "You can't yell.\n\r", ch );
  return;
    }
 
    if ( argument[0] == '\0' )
    {
  send_to_char( "Yell what?\n\r", ch );
  return;
    }


    act("You yell '$t'",ch,argument,NULL,TO_CHAR,FALSE);
    for ( d = descriptor_list; d != NULL; d = d->next )
    {
  if ( d->connected == CON_PLAYING
  &&   d->character != ch
  &&   d->character->in_room != NULL
  &&   d->character->in_room->area == ch->in_room->area 
  &&   !IS_SET(d->character->comm,COMM_QUIET) 
  &&   (d->character->ignoring != ch) )
  {
      act("$n yells '$t'",ch,argument,d->character,TO_VICT,FALSE);
  }
    }

    return;
}


void do_emote( CHAR_DATA *ch, char *argument )
{
     if ( is_affected(ch, gsn_cone_of_silence ) )
    return;

    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
    {
  send_to_char( "You can't show your emotions.\n\r", ch );
  return;
    }
 
    if ( argument[0] == '\0' )
    {
  send_to_char( "Emote what?\n\r", ch );
  return;
    }
 
    act( "$n $T", ch, NULL, argument, TO_ROOM, FALSE );
    act( "$n $T", ch, NULL, argument, TO_CHAR, FALSE );
    return;
}


void do_pmote( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *vch;
    char *letter,*name;
    char last[MAX_INPUT_LENGTH], temp[MAX_STRING_LENGTH];
    int matches = 0;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;


    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
    {
  send_to_char( "You can't show your emotions.\n\r", ch );
  return;
    }
 
    if ( argument[0] == '\0' )
    {
  send_to_char( "Emote what?\n\r", ch );
  return;
    }
 
    act( "$n $t", ch, argument, NULL, TO_CHAR, FALSE );

    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
    {
  if (vch->desc == NULL || vch == ch)
      continue;

  if ((letter = strstr(argument,vch->name)) == NULL)
  {
      act("$N $t",vch,argument,ch,TO_CHAR, FALSE);
      continue;
  }

  strcpy(temp,argument);
  temp[strlen(argument) - strlen(letter)] = '\0';
  last[0] = '\0';
  name = vch->name;
  
  for (; *letter != '\0'; letter++)
  { 
      if (*letter == '\'' && matches == strlen(vch->name))
      {
    strcat(temp,"r");
    continue;
      }

      if (*letter == 's' && matches == strlen(vch->name))
      {
    matches = 0;
    continue;
      }
      
      if (matches == strlen(vch->name))
      {
    matches = 0;
      }

      if (*letter == *name)
      {
    matches++;
    name++;
    if (matches == strlen(vch->name))
    {
        strcat(temp,"you");
        last[0] = '\0';
        name = vch->name;
        continue;
    }
    strncat(last,letter,1);
    continue;
      }

      matches = 0;
      strcat(temp,last);
      strncat(temp,letter,1);
      last[0] = '\0';
      name = vch->name;
  }

  act("$N $t",vch,temp,ch,TO_CHAR, FALSE);
    }
  
    return;
}


/*
 * All the posing stuff.
 */
struct  pose_table_type
{
    char *      message[2*MAX_CLASS];
};

const   struct  pose_table_type pose_table      []      =
{
    {
  {
      "You sizzle with energy.",
      "$n sizzles with energy.",
      "You feel very holy.",
      "$n looks very holy.",
      "You perform a small card trick.",
      "$n performs a small card trick.",
      "You show your bulging muscles.",
      "$n shows $s bulging muscles."
  }
    },

    {
  {
      "You turn into a butterfly, then return to your normal shape.",
      "$n turns into a butterfly, then returns to $s normal shape.",
      "You nonchalantly turn wine into water.",
      "$n nonchalantly turns wine into water.",
      "You wiggle your ears alternately.",
      "$n wiggles $s ears alternately.",
      "You crack nuts between your fingers.",
      "$n cracks nuts between $s fingers."
  }
    },

    {
  {
      "Blue sparks fly from your fingers.",
      "Blue sparks fly from $n's fingers.",
      "A halo appears over your head.",
      "A halo appears over $n's head.",
      "You nimbly tie yourself into a knot.",
      "$n nimbly ties $mself into a knot.",
      "You grizzle your teeth and look mean.",
      "$n grizzles $s teeth and looks mean."
  }
    },

    {
  {
      "Little red lights dance in your eyes.",
      "Little red lights dance in $n's eyes.",
      "You recite words of wisdom.",
      "$n recites words of wisdom.",
      "You juggle with daggers, apples, and eyeballs.",
      "$n juggles with daggers, apples, and eyeballs.",
      "You hit your head, and your eyes roll.",
      "$n hits $s head, and $s eyes roll."
  }
    },

    {
  {
      "A slimy green monster appears before you and bows.",
      "A slimy green monster appears before $n and bows.",
      "Deep in prayer, you levitate.",
      "Deep in prayer, $n levitates.",
      "You steal the underwear off every person in the room.",
      "Your underwear is gone!  $n stole it!",
      "Crunch, crunch -- you munch a bottle.",
      "Crunch, crunch -- $n munches a bottle."
  }
    },

    {
  {
      "You turn everybody into a little pink elephant.",
      "You are turned into a little pink elephant by $n.",
      "An angel consults you.",
      "An angel consults $n.",
      "The dice roll ... and you win again.",
      "The dice roll ... and $n wins again.",
      "... 98, 99, 100 ... you do pushups.",
      "... 98, 99, 100 ... $n does pushups."
  }
    },

    {
  {
      "A small ball of light dances on your fingertips.",
      "A small ball of light dances on $n's fingertips.",
      "Your body glows with an unearthly light.",
      "$n's body glows with an unearthly light.",
      "You count the money in everyone's pockets.",
      "Check your money, $n is counting it.",
      "Arnold Schwarzenegger admires your physique.",
      "Arnold Schwarzenegger admires $n's physique."
  }
    },

    {
  {
      "Smoke and fumes leak from your nostrils.",
      "Smoke and fumes leak from $n's nostrils.",
      "A spot light hits you.",
      "A spot light hits $n.",
      "You balance a pocket knife on your tongue.",
      "$n balances a pocket knife on your tongue.",
      "Watch your feet, you are juggling granite boulders.",
      "Watch your feet, $n is juggling granite boulders."
  }
    },

    {
  {
      "The light flickers as you rap in magical languages.",
      "The light flickers as $n raps in magical languages.",
      "Everyone levitates as you pray.",
      "You levitate as $n prays.",
      "You produce a coin from everyone's ear.",
      "$n produces a coin from your ear.",
      "Oomph!  You squeeze water out of a granite boulder.",
      "Oomph!  $n squeezes water out of a granite boulder."
  }
    },

    {
  {
      "Your head disappears.",
      "$n's head disappears.",
      "A cool breeze refreshes you.",
      "A cool breeze refreshes $n.",
      "You step behind your shadow.",
      "$n steps behind $s shadow.",
      "You pick your teeth with a spear.",
      "$n picks $s teeth with a spear."
  }
    },

    {
  {
      "A fire elemental singes your hair.",
      "A fire elemental singes $n's hair.",
      "The sun pierces through the clouds to illuminate you.",
      "The sun pierces through the clouds to illuminate $n.",
      "Your eyes dance with greed.",
      "$n's eyes dance with greed.",
      "Everyone is swept off their foot by your hug.",
      "You are swept off your feet by $n's hug."
  }
    },

    {
  {
      "The sky changes color to match your eyes.",
      "The sky changes color to match $n's eyes.",
      "The ocean parts before you.",
      "The ocean parts before $n.",
      "You deftly steal everyone's weapon.",
      "$n deftly steals your weapon.",
      "Your karate chop splits a tree.",
      "$n's karate chop splits a tree."
  }
    },

    {
  {
      "The stones dance to your command.",
      "The stones dance to $n's command.",
      "A thunder cloud kneels to you.",
      "A thunder cloud kneels to $n.",
      "The Grey Mouser buys you a beer.",
      "The Grey Mouser buys $n a beer.",
      "A strap of your armor breaks over your mighty thews.",
      "A strap of $n's armor breaks over $s mighty thews."
  }
    },

    {
  {
      "The heavens and grass change colour as you smile.",
      "The heavens and grass change colour as $n smiles.",
      "The Burning Man speaks to you.",
      "The Burning Man speaks to $n.",
      "Everyone's pocket explodes with your fireworks.",
      "Your pocket explodes with $n's fireworks.",
      "A boulder cracks at your frown.",
      "A boulder cracks at $n's frown."
  }
    },

    {
  {
      "Everyone's clothes are transparent, and you are laughing.",
      "Your clothes are transparent, and $n is laughing.",
      "An eye in a pyramid winks at you.",
      "An eye in a pyramid winks at $n.",
      "Everyone discovers your dagger a centimeter from their eye.",
      "You discover $n's dagger a centimeter from your eye.",
      "Mercenaries arrive to do your bidding.",
      "Mercenaries arrive to do $n's bidding."
  }
    },

    {
  {
      "A black hole swallows you.",
      "A black hole swallows $n.",
      "Valentine Michael Smith offers you a glass of water.",
      "Valentine Michael Smith offers $n a glass of water.",
      "Where did you go?",
      "Where did $n go?",
      "Four matched Percherons bring in your chariot.",
      "Four matched Percherons bring in $n's chariot."
  }
    },

    {
  {
      "The world shimmers in time with your whistling.",
      "The world shimmers in time with $n's whistling.",
      "The great god Mojo gives you a staff.",
      "The great god Mojo gives $n a staff.",
      "Click.",
      "Click.",
      "Atlas asks you to relieve him.",
      "Atlas asks $n to relieve him."
  }
    }
};



void do_pose( CHAR_DATA *ch, char *argument )
{
    int level;
    int pose;
    int class;

    if ( IS_NPC(ch) )
  return;

    level = UMIN( ch->level, sizeof(pose_table) / sizeof(pose_table[0]) - 1 );
    pose  = number_range(0, level);
    if( ch->class <= 3 )
      class = ch->class;
    else
      {
	switch(ch->class)
	{
	case 4: class = number_range(1,2);
		break;
	case 5: class = number_range(2,3);
		if( class == 2) class--;
		break;
	case 6: class = number_range(2,3);
		break;
	case 7: class = number_range(0,1);
		break;
	case 8: class = number_range(1,2);
		if(class == 1) class--;
		break;
	case 9: class = number_range(0,1);
		if(class == 1) class += 2;
		break;
	case 10: class = number_range(0,1);
		break;
	case 11:
	case 12:
	case 13:
	case 14: class = ch->class - 11;
		break;
	default: class = 0;
	}
      }

    act( pose_table[pose].message[2*class+0], ch, NULL, NULL, TO_CHAR, FALSE );
    act( pose_table[pose].message[2*class+1], ch, NULL, NULL, TO_ROOM, FALSE );

    return;
}


/*
void do_bug( CHAR_DATA *ch, char *argument )
{
    append_file( ch, BUG_FILE, argument );
    send_to_char( "Bug logged.\n\r", ch );
    return;
}
*/

void do_typo( CHAR_DATA *ch, char *argument )
{
    append_file( ch, TYPO_FILE, argument );
    send_to_char( "Typo logged.\n\r", ch );
    return;
}



void do_rent( CHAR_DATA *ch, char *argument )
{
    send_to_char( "There is no rent here.  Just save and quit.\n\r", ch );
    return;
}



void do_qui( CHAR_DATA *ch, char *argument )
{
    send_to_char( "If you want to QUIT, you have to spell it out.\n\r", ch );
    return;
}

void do_quit_command ( CHAR_DATA *ch, char *argument )
{
  AFFECT_DATA *paf,*paf_next;
  bool can_quit=TRUE;

    if(IS_SET(ch->mhs,MHS_SHAPESHIFTED) )
    {
      send_to_char( "Unshape Shift First Please.\r\n", ch);
      return;
    }

    if ( is_affected(ch, gsn_cone_of_silence ) )
    {
      send_to_char("No way.  You're under the affect of Cone Of Silence",ch);
      return;
    }

    if( is_affected(ch, gsn_garotte) )
    {
      send_to_char("{CNo Way{x! You're {Ygarotted{x!!!",ch);
      return;
    }

    if ( ch->position == POS_FIGHTING )
    {
  send_to_char( "No way! You are fighting.\n\r", ch );
  return;
    }

/* Ron Down - Check if Character has note in progress */
    if ( ch->pnote != NULL )
    {
       send_to_char( "You have a note in progress, please post or clear before quiting.\n\r", ch );
       return;
    }
/* Ron Up */

/*
    if (IS_SET(ch->mhs,MHS_SHAPESHIFTED) && (ch->race != ch->save_race))
    {
       send_to_char(" You must return from a shapeshift before quiting.\n\r",ch);
       return;
    }
    */

    if ( ch->position  < POS_STUNNED  )
    {
  send_to_char( "You're not DEAD yet.\n\r", ch );
  return;
    }
    
	for ( paf = ch->affected ; paf != NULL ; paf = paf_next )
        {
            paf_next = paf->next;

            if ( paf->where == DAMAGE_OVER_TIME )
		can_quit=FALSE;
	}

    if (ch->pcdata && ch->pcdata->quit_time > 0 && !IS_IMMORTAL (ch) 
	&& (ch->in_room->clan != ch->clan || !can_quit ) ) {
      send_to_char ("Things are getting interesting.. wait a few ticks.\n\r",ch);
      return;
    }
    do_quit (ch, "");
}

void do_quit( CHAR_DATA *ch, char *argument )
{
    DESCRIPTOR_DATA *d, *d_next, *d_glad;
    int loss;
    long id;
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_STRING_LENGTH];
    char host[MAX_STRING_LENGTH];
    buf[0] = '\0'; 

    one_argument( argument, arg );
    if ( IS_NPC(ch) )
  return;

/*
    if (IS_SET(ch->mhs,MHS_SHAPESHIFTED) && (ch->race != ch->save_race))
       shapeshift_remove(ch);
*/
    if ( (ch->in_room->vnum < 3001 || ch->in_room->vnum >3383)
     && (ch->in_room->vnum < 9500 || ch->in_room->vnum >9799)
        && ch->in_room->vnum != 2 && !IS_IMMORTAL(ch) 
  && !IS_SET(ch->in_room->room_flags,ROOM_SAFE)
  && !IS_SET(ch->in_room->room_flags,ROOM_PRIVATE)
    )
       {
        loss = 2 * ch->level;
        gain_exp(ch, 0 - loss);
        send_to_char( 
  "You lost experience for quitting outside of town.\n\r", ch );
  if(ch->level >= 40 && number_percent() >50 
	&& (!IS_AFFECTED(ch,AFF_CURSE) || !IS_SET(ch->mhs,MHS_CURSE)) &&
	!ch->in_room->area->no_transport ) 
    {
	sprintf(buf,"%s sends you to visit Hassan.\n\r",
		deity_table[ch->pcdata->deity].pname);
      send_to_char(buf,ch);
       char_from_room (ch);
       clear_mount(ch);
       char_to_room (ch,get_room_index( ROOM_VNUM_TEMPLE ));          }
  }
    send_to_char( 
	"Alas, all good things must come to an end.\n\r",ch);
    act( "$n has left the game.", ch, NULL, NULL, TO_ROOM, FALSE );
    sprintf( log_buf, "%s has quit.", ch->name );
    log_string( log_buf );
    if (ch->desc == NULL)
    strcpy(host,"linkdead");
  else
  strcpy(host,ch->desc->host);
  wiznet("$N rejoins the real world.",ch,NULL,WIZ_LOGINS,WIZ_SITES,get_trust(ch));
  if( (!IS_IMMORTAL(ch) || (ch->incog_level == 0 && ch->invis_level == 0))
	&& !str_cmp(arg, "") )
  {
    pnet("$N leaves Boinga.",ch,NULL,PNET_LOGINS,NULL,get_trust(ch));
  }
         sprintf( buf, "%s@@%s has quit.", ch->name, host );
        wiznet(buf,NULL,NULL,WIZ_SITES,0,get_trust(ch));

/* Send Departure of a Highlander to all Highlanders(with certain kills) */
if (IS_SET(ch->mhs,MHS_HIGHLANDER))
{
   sprintf(buf, "The presence of a Highlander has left Boinga.\n\r");

   for ( d = descriptor_list; d != NULL; d = d->next )
   {
      CHAR_DATA *victm;

      victm = d->original ? d->original : d->character;

      if ( d->connected == CON_PLAYING &&
           d->character != ch &&
           IS_SET(victm->mhs,MHS_HIGHLANDER) &&
	   (victm->pcdata->highlander_data[ALL_KILLS] >= 6))
        send_to_char(buf, victm);
   }
   remove_highlander(ch,ch); 
}
	if (IS_SET(ch->mhs,MHS_GLADIATOR))
	{
           sprintf(buf, "%s got scared and quit the arena!", ch->name);
           gladiator_talk(buf); 
	   gladiator_left_arena(ch,TRUE);
	
           
	   for ( d_glad = descriptor_list; d_glad != NULL; d_glad = d_glad->next)
	   {
		if(d_glad->character != NULL && d_glad->character->pcdata->glad_bet_on == ch)
		{
	          sprintf(buf, "The bookie refunds your bet of %d on %s.", 
			  d_glad->character->pcdata->glad_bet_amt, ch->name);
		  send_to_char(buf, d_glad->character);
		  d_glad->character->pcdata->glad_bet_on = d_glad->character;
		  d_glad->character->pcdata->glad_bet_amt = 0;
		}
           }
	   REMOVE_BIT(ch->mhs,MHS_GLADIATOR);

	}

    /*
     * After extract_char the ch is no longer valid!
     */
    /* decrement logins allowed from pfresh */
    if ( !IS_NPC(ch))
    {
       if (ch->pcdata->logout_tracker > 0)
          ch->pcdata->logout_tracker -= 1;
       if (!IS_IMMORTAL(ch) && is_clan(ch))
       {
          if(ch->pcdata->combats_since_last_login == 0)
            ch->pcdata->logins_without_combat++;
          if(ch->pcdata->died_today == FALSE)
            ch->pcdata->logins_without_death++;
          if(ch->pcdata->killed_today == FALSE)
            ch->pcdata->logins_without_kill++;
       }
    }
    save_char_obj( ch );
    id = ch->id;
    d = ch->desc;
    extract_char( ch, TRUE );
    if ( d != NULL )
        close_socket( d );

    for (d = descriptor_list; d != NULL; d = d_next)
    {
        CHAR_DATA *tch;

        d_next = d->next;
        tch = d->original ? d->original : d->character;
        if (tch && tch->id == id )
        {
            extract_char(tch,TRUE);
            close_socket(d);
        }
    }

    return;
}

void do_save( CHAR_DATA *ch, char *argument )
{
    if ( IS_NPC(ch) )
  return;
    if ( IS_SET(ch->affected_by, AFF_CHARM) )
  return;

    save_char_obj( ch );
    send_to_char("Saving. Remember that MHS has automatic saving now\n\r", ch);
    if (!IS_IMMORTAL(ch))
      WAIT_STATE(ch,3 * PULSE_VIOLENCE);
    return;
}



void do_follow( CHAR_DATA *ch, char *argument )
{
/* RT changed to allow unlimited following and follow the NOFOLLOW rules */
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Follow whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_room( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL )
    {
  act( "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR, FALSE );
  return;
    }

    if ( victim == ch )
    {
  if ( ch->master == NULL )
  {
      send_to_char( "You already follow yourself.\n\r", ch );
      return;
  }
  stop_follower(ch);
  return;
    }

    if (!IS_NPC(victim) && IS_SET(victim->act,PLR_NOFOLLOW) && !IS_IMMORTAL(ch))
    {
  act("$N doesn't seem to want any followers.\n\r",
       ch,NULL,victim, TO_CHAR, FALSE);
  return;
    }

    REMOVE_BIT(ch->act,PLR_NOFOLLOW);
    
    if ( ch->master != NULL )
  stop_follower( ch );

    add_follower( ch, victim );
    return;
}

void add_follower( CHAR_DATA *ch, CHAR_DATA *master )
{
    CHAR_DATA *gch;

    if ( ch->master != NULL )
    {
  bug( "Add_follower: non-null master.", 0 );
  return;
    }

    /* There is late-minute checking in fight.c, as well, but this is
     * here to catch most of these right away so the spell is working
     * properly
     */
    if ( is_affected(ch,gsn_wound_transfer) )
    {

    if ( ( is_clan(ch) && !is_clan(master) ) ||
	 (!is_clan(ch) &&  is_clan(master) ) )
    {
	send_to_char("The boundries of magic forbid it.\n\r",ch);
	return;
    }

    if ( is_affected(master,gsn_wound_transfer) )
    {
       send_to_char("The boundries of magic forbid it.\n\r",ch);
       return;
    }

    /* Also make sure that njo one in master's GROUP has it */
    for ( gch = char_list ; gch != NULL ; gch = gch->next )
    {
       if ( is_same_group(gch,master) &&
	    is_affected(gch,gsn_wound_transfer) )
       {
       send_to_char("The boundries of magic forbid it.\n\r",ch);
       return;
       }

    }

    }



    ch->master        = master;
    ch->leader        = NULL;

    if ( can_see( master, ch, FALSE ) )
  act( "$n now follows you.", ch, NULL, master, TO_VICT, FALSE );

    act( "You now follow $N.",  ch, NULL, master, TO_CHAR, FALSE );

    return;
}



void stop_follower( CHAR_DATA *ch )
{
    if ( ch->master == NULL )
    {
  bug( "Stop_follower: null master.", 0 );
  return;
    }

    if ( IS_AFFECTED(ch, AFF_CHARM) )
    {
  REMOVE_BIT( ch->affected_by, AFF_CHARM );
  affect_strip( ch, gsn_charm_person );
    }

    if ( can_see( ch->master, ch, FALSE ) && ch->in_room != NULL)
    {
  act( "$n stops following you.",     ch, NULL, ch->master, TO_VICT, FALSE);
  act( "You stop following $N.",      ch, NULL, ch->master, TO_CHAR, FALSE);
    }
    if (ch->master->pet == ch)
  ch->master->pet = NULL;

    ch->master = NULL;
    ch->leader = NULL;
    return;
}

/* nukes charmed monsters and pets */
void nuke_pets( CHAR_DATA *ch )
{    
    CHAR_DATA *pet;

    if ((pet = ch->pet) != NULL)
    {
  stop_follower(pet);
  if (pet->in_room != NULL)
      act("$N slowly fades away.",ch,NULL,pet,TO_NOTVICT,FALSE);
  extract_char(pet,TRUE);
    }
    ch->pet = NULL;

    return;
}

void die_ignore( CHAR_DATA *ch )
{
    CHAR_DATA *fch;

    for ( fch = char_list; fch != NULL; fch = fch->next )
    {
  if ( fch->ignoring == ch )
	fch->ignoring = NULL;
    }

    return;
}


void die_follower( CHAR_DATA *ch )
{
    CHAR_DATA *fch;

    if ( ch->master != NULL )
    {
  if (ch->master->pet == ch)
      ch->master->pet = NULL;
  stop_follower( ch );
    }

    ch->leader = NULL;

    for ( fch = char_list; fch != NULL; fch = fch->next )
    {
  if ( fch->master == ch )
      stop_follower( fch );
  if ( fch->leader == ch )
      fch->leader = fch;
    }

    return;
}



void do_order( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *och;
    CHAR_DATA *och_next;
    bool found;
    bool fAll;
    int cmd;

    argument = one_argument( argument, arg );
    one_argument(argument,arg2);

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
       send_to_char("No ordering while in wraithform.\n\r",ch);
	return;
    }

   
    for ( cmd = 0; cmd_table[cmd].name[0] != '\0'; cmd++ )
    {
	if ( arg2[0] == cmd_table[cmd].name[0]
	    &&   !str_prefix( arg2, cmd_table[cmd].name ))
	{
	  if (cmd_table[cmd].order == 0 )
	  {
	  send_to_char("That will not be done.\n\r",ch);
	  return;
	  }
	  else
	  break;
	}
	
    }

    if ( arg[0] == '\0' || argument[0] == '\0' )
    {
  send_to_char( "Order whom to do what?\n\r", ch );
  return;
    }

    if ( IS_AFFECTED( ch, AFF_CHARM ) )
    {
  send_to_char( "You feel like taking, not giving, orders.\n\r", ch );
  return;
    }

    if ( !str_cmp( arg, "all" ) )
    {
  fAll   = TRUE;
  victim = NULL;
    }
    else
    {
  fAll   = FALSE;
  if ( ( victim = get_char_room( ch, arg ) ) == NULL )
  {
      send_to_char( "They aren't here.\n\r", ch );
      return;
  }

  if ( victim == ch )
  {
      send_to_char( "Aye aye, right away!\n\r", ch );
      return;
  }

  if (!IS_AFFECTED(victim, AFF_CHARM) || victim->master != ch 
  ||  (IS_IMMORTAL(victim) && victim->trust >= ch->trust))
  {
      send_to_char( "Do it yourself!\n\r", ch );
      return;
  }
    }

    found = FALSE;
    for ( och = ch->in_room->people; och != NULL; och = och_next )
    {
  och_next = och->next_in_room;

  if ( IS_AFFECTED(och, AFF_CHARM)
  &&   och->master == ch
  && ( fAll || och == victim ) )
  {
      found = TRUE;
      sprintf( buf, "$n orders you to '%s'.", argument );
      act( buf, ch, NULL, och, TO_VICT,FALSE );
      strcpy(kludge_string,"order");
      interpret( och, argument );
      strcpy(kludge_string,"");
  }
    }

    if ( found )
    {
  WAIT_STATE(ch,PULSE_VIOLENCE);
  send_to_char( "Ok.\n\r", ch );
    }
    else
  send_to_char( "You have no followers here.\n\r", ch );
    return;
}



void do_group( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char buf2[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  CHAR_DATA *gch;
  CHAR_DATA *leader;

  leader = (ch->leader != NULL) ? ch->leader : ch;
  sprintf( buf, "%s's group:\n\r", PERS(leader, ch, TRUE) );
  send_to_char( buf, ch );

  for ( gch = char_list; gch != NULL; gch = gch->next )
  {
      if ( is_same_group( gch, ch ) )
      {
    sprintf( buf,
    "[%2d %s] %-16s H:",
        gch->level,
        IS_NPC(gch) ? "Mob" : class_table[gch->class].who_name,
        capitalize( PERS(gch,ch,TRUE) )); 
	if ( is_affected(gch,gsn_rage) )
		strcat(buf,"{c???? {xM:");
	    else
	if ( gch->hit >= UMAX((9*gch->max_hit)/10,1) )
		strcat(buf,"{W**** {xM:");
	    else
	    if ( gch->hit * 100 / UMAX(gch->max_hit,1) > 75 )
		strcat(buf,"{W***- {xM:");
	    else
	    if ( gch->hit * 100 / UMAX(gch->max_hit,1) > 50 )
		strcat(buf,"{Y**-- {xM:");
	    else
	    if ( gch->hit * 100 / UMAX(gch->max_hit,1) > 25 )
		strcat(buf,"{R*--- {xM:");
	    else
		strcat(buf,"{r---- {xM:");

	    if ( gch->mana >= UMAX((9*gch->max_mana)/10,1) )
		strcat(buf,"{W**** {xV:");
	    else
	    if ( gch->mana * 100 / UMAX(gch->max_mana,1) > 75 )
		strcat(buf,"{W***- {xV:");
	    else
	    if ( gch->mana * 100 / UMAX(gch->max_mana,1) > 50 )
		strcat(buf,"{Y**-- {xV:");
	    else
	    if ( gch->mana * 100 / UMAX(gch->max_mana,1) > 25 )
		strcat(buf,"{R*--- {xV:");
	    else
		strcat(buf,"{r---- {xV:");

	    if ( gch->move >= UMAX((9*gch->max_move)/10,1) )
		strcat(buf,"{W****{x");
	    else
	    if ( gch->move * 100 / UMAX(gch->max_move,1) > 75 )
		strcat(buf,"{W***-{x");
	    else
	    if ( gch->move * 100 / UMAX(gch->max_move,1) > 50 )
		strcat(buf,"{Y**--{x");
	    else
	    if ( gch->move * 100 / UMAX(gch->max_move,1) > 25 )
		strcat(buf,"{R*---{x");
	    else
		strcat(buf,"{r----{x");
	    sprintf( buf2, "%6d xp\n\r", gch->exp    );
	    strcat(buf,buf2);
    send_to_char( buf, ch );
    }
  }
  return;
    }

    if ( ( victim = get_char_room( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if(IS_SET(victim->act,PLR_DWEEB) || IS_SET(ch->act,PLR_DWEEB))
    {
      send_to_char("No grouping with DWEEBs.\n\r",ch);
      return;
    }

    if(ch->clan == clan_lookup("demise") && is_clan(victim) && !is_same_clan(ch,victim)  )
    {
      send_to_char("You have been {YWARNED{x about grouping with others outside your clan!\r\n",ch);
      send_to_char("You are now ranked a 0.  Pray an Imm or a leader does not see you.\r\n",ch);
      set_title(ch,"Has a simple Clan Rule and broke it.");
      SET_BIT(ch->comm,COMM_NOTITLE);
      ch->pcdata->rank = 0;
      return;
    }
    if(is_clan(ch) && victim->clan == clan_lookup("demise") && !is_same_clan(ch,victim) )
    {
      send_to_char("The hand of {RCthon{x stops you from grouping with them.\r\n",ch);
      return;
    }

    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char("Sorry Gladiators do not group.\n\r",ch);
       return;
    }

    if ( ch->master != NULL || ( ch->leader != NULL && ch->leader != ch ) )
    {
  send_to_char( "But you are following someone else!\n\r", ch );
  return;
    }

    if ( victim->master != ch && ch != victim )
    {
  act( "$N isn't following you.", ch, NULL, victim, TO_CHAR,FALSE );
  return;
    }
    
    if (IS_AFFECTED(victim,AFF_CHARM))
    {
  send_to_char("You can't remove charmed mobs from your group.\n\r",ch);
  return;
    }
    
    if (IS_AFFECTED(ch,AFF_CHARM) && !IS_NPC(victim))
    {
 act("You like your master too much to leave $m!",ch,NULL,victim,TO_VICT,FALSE);
  return;
    }

    if (IS_SET(ch->mhs,MHS_HIGHLANDER) || IS_SET(victim->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Highlanders can not group. Honorable combat is one on one.\n\r",ch);
       return;
    }

    if (victim->level - ch->level > 8)
    {
  send_to_char("They are to high of a level for your group.\n\r",ch);
  return;
    }

    if (victim->level - ch->level < -8)
    {
  send_to_char("They are to low of a level for your group.\n\r",ch);
  return;
    }

    if ( is_same_group( victim, ch ) && ch != victim )
    {
  victim->leader = NULL;
  act( "$n removes $N from $s group.",   ch, NULL, victim, TO_NOTVICT,TRUE);
  if (!IS_NPC(victim))
  act( "$n removes you from $s group.",  ch, NULL, victim, TO_VICT,TRUE);
  act( "You remove $N from your group.", ch, NULL, victim, TO_CHAR,TRUE);
  return;
    }

    if(ch->position < POS_RESTING)
	{
	  send_to_char("Too late for that...",ch);
	  return;
	}
    victim->leader = ch;
    act( "$N joins $n's group.", ch, NULL, victim, TO_NOTVICT,FALSE);
    if(!IS_NPC(victim))
    act( "You join $n's group.", ch, NULL, victim, TO_VICT,FALSE);
    act( "$N joins your group.", ch, NULL, victim, TO_CHAR,FALSE);
    return;
}



/*
 * 'Split' originally by Gnort, God of Chaos.
 */
void do_split( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
    CHAR_DATA *gch;
    int members;
    int amount_gold = 0, amount_silver = 0;
    int share_gold, share_silver;
    int extra_gold, extra_silver;

    argument = one_argument( argument, arg1 );
         one_argument( argument, arg2 );

    if ( arg1[0] == '\0' )
    {
  send_to_char( "Split how much?\n\r", ch );
  return;
    }
    
    amount_silver = atoi( arg1 );

    if (arg2[0] != '\0')
  amount_gold = atoi(arg2);

    if ( amount_gold < 0 || amount_silver < 0)
    {
  send_to_char( "Your group wouldn't like that.\n\r", ch );
  return;
    }

    if ( amount_gold == 0 && amount_silver == 0 )
    {
  send_to_char( "You hand out zero coins, but no one notices.\n\r", ch );
  return;
    }

    if ( ch->gold <  amount_gold || ch->silver < amount_silver)
    {
  send_to_char( "You don't have that much to split.\n\r", ch );
  return;
    }
  
    members = 0;
    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
    {
  if ( is_same_group( gch, ch ) && !IS_AFFECTED(gch,AFF_CHARM))
      members++;
    }

    if ( members < 2 )
    {
  send_to_char( "Just keep it all.\n\r", ch );
  return;
    }
      
    share_silver = amount_silver / members;
    extra_silver = amount_silver % members;

    share_gold   = amount_gold / members;
    extra_gold   = amount_gold % members;

    if ( share_gold == 0 && share_silver == 0 )
    {
  send_to_char( "Don't even bother, cheapskate.\n\r", ch );
  return;
    }

    ch->silver  -= amount_silver;
    ch->silver  += share_silver + extra_silver;
    ch->gold    -= amount_gold;
    ch->gold    += share_gold + extra_gold;

    if (share_silver > 0)
    {
  sprintf(buf,
      "You split %d silver coins. Your share is %d silver.\n\r",
      amount_silver,share_silver + extra_silver);
  send_to_char(buf,ch);
    }

    if (share_gold > 0)
    {
  sprintf(buf,
      "You split %d gold coins. Your share is %d gold.\n\r",
       amount_gold,share_gold + extra_gold);
  send_to_char(buf,ch);
    }

    if (share_gold == 0)
    {
  sprintf(buf,"$n splits %d silver coins. Your share is %d silver.",
    amount_silver,share_silver);
    }
    else if (share_silver == 0)
    {
  sprintf(buf,"$n splits %d gold coins. Your share is %d gold.",
    amount_gold,share_gold);
    }
    else
    {
  sprintf(buf,
"$n splits %d silver and %d gold coins, giving you %d silver and %d gold.\n\r",
   amount_silver,amount_gold,share_silver,share_gold);
    }

    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
    {
  if ( gch != ch && is_same_group(gch,ch) && !IS_AFFECTED(gch,AFF_CHARM))
  {
   if ( (get_carry_weight(gch) + share_silver/10 + share_gold*2/5)
        > can_carry_w(gch) )
    {
      act( "$N can't carry that much weight.", ch, NULL, gch, TO_CHAR,FALSE);
      ch->gold += share_gold;
      ch->silver += share_silver;
    }
   else
    {
      act( buf, ch, NULL, gch, TO_VICT, FALSE );
      gch->gold += share_gold;
      gch->silver += share_silver;
    }
  }
    }

    return;
}



void do_gtell( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH],bufc[MAX_STRING_LENGTH];
    CHAR_DATA *gch;
    if ( is_affected(ch, gsn_cone_of_silence ) )
    return;


    if ( argument[0] == '\0' )
    {
  send_to_char( "Tell your group what?\n\r", ch );
  return;
    }

    if ( IS_SET( ch->comm, COMM_NOTELL ) )
    {
  send_to_char( "Your message didn't get through!\n\r", ch );
  return;
    }

    /*
     * Note use of send_to_char, so gtell works on sleepers.
     */
    sprintf( buf, "%s tells the group '%s'\n\r", ch->name, argument );
    sprintf( bufc, "%s%s%s tells the group%s '%s'\n\r",BOLD,ch->name,BLUE,NORMAL, argument );
    for ( gch = char_list; gch != NULL; gch = gch->next )
    {
  if ( is_same_group( gch, ch ) )
	{
	if(IS_SET(gch->display,DISP_COLOR))
      send_to_char( bufc, gch );
	else
      send_to_char( buf, gch );
	}
    }

    return;
}



/*
 * It is very important that this be an equivalence relation:
 * (1) A ~ A
 * (2) if A ~ B then B ~ A
 * (3) if A ~ B  and B ~ C, then A ~ C
 */
bool is_same_group( CHAR_DATA *ach, CHAR_DATA *bch )
{
    if ( ach == NULL || bch == NULL)
  return FALSE;

    if (!IS_NPC(ach) && !IS_NPC(bch))
    {
       if (IS_SET(ach->mhs,MHS_GLADIATOR) && IS_SET(bch->mhs,MHS_GLADIATOR)
	   && (gladiator_info.type == 2 || gladiator_info.type == 3)
           && gladiator_info.bet_counter == 0)
       {
          if(ach->pcdata->gladiator_team == bch->pcdata->gladiator_team)
             return TRUE;
       }
    }

    if ( ach->leader != NULL ) ach = ach->leader;
    if ( bch->leader != NULL ) bch = bch->leader;
    return ach == bch;
}


bool has_group_mates( CHAR_DATA *ch )
{

    DESCRIPTOR_DATA *d;
    CHAR_DATA *vch;

    if ( IS_NPC(ch) || ch == NULL)
	return FALSE;

    for ( d = descriptor_list ; d != NULL ; d= d->next )
    {
       if ( ( vch = d->character ) == NULL )
		continue;

	if ( vch == ch )
		continue;
/* this is where i check if someone has the current char as the leader 	
	or if the vch is the leader for the current char */
	if ( ch == vch->leader || vch == ch->leader )
	   return TRUE;

    }

    return FALSE;


}

bool group_has_crusader( CHAR_DATA *ch )
{
    DESCRIPTOR_DATA *d;
    CHAR_DATA *vch;

    if ( IS_NPC(ch) )
	return FALSE;

    for ( d = descriptor_list ; d != NULL ; d= d->next )
    {
       if ( ( vch = d->character ) == NULL )
		continue;

	if ( is_same_group( ch, vch ) && 
		vch->class == class_lookup("crusader") &&
                vch->in_room == ch->in_room  &&
		has_group_mates(ch) 
		)
	  return TRUE;
    }

    return FALSE;
}

bool group_has_cavalier( CHAR_DATA *ch )
{
    DESCRIPTOR_DATA *d;
    CHAR_DATA *vch;

    if ( IS_NPC(ch) )
        return FALSE;

    for ( d = descriptor_list ; d != NULL ; d= d->next )
    {
       if ( ( vch = d->character ) == NULL )
                continue;

        if ( is_same_group( ch, vch ) &&
                vch->kit == kit_lookup("cavalier") &&
		(is_mounted(vch) && IS_NPC(vch->riding) && vch->riding->pIndexData->vnum == MOB_VNUM_WARHORSE) &&
                vch->in_room == ch->in_room  &&
                has_group_mates(ch)
                )
          return TRUE;
    }

    return FALSE;
}


int group_has_how_many_crusader( CHAR_DATA *ch )
{
    DESCRIPTOR_DATA *d;
    CHAR_DATA *vch;
    int number_of =0;

    if ( IS_NPC(ch) )
	return 0;

    for ( d = descriptor_list ; d != NULL ; d= d->next )
    {
       if ( ( vch = d->character ) == NULL )
		continue;

	if ( is_same_group( ch, vch ) && 
		vch->class == class_lookup("crusader") &&
                vch->in_room == ch->in_room  &&
		has_group_mates(ch) 
		)
		number_of++;
    }

    return number_of;
}


void do_nogladiator(CHAR_DATA *ch, char *argument)
{
    if (IS_SET(ch->comm, COMM_NOGLADIATOR))
    {
       REMOVE_BIT(ch->comm, COMM_NOGLADIATOR);
       send_to_char("Gladiator channel ON.\n\r", ch);
    }
    else
    {
       SET_BIT(ch->comm, COMM_NOGLADIATOR);
       send_to_char("Gladiator channel OFF.\n\r", ch);
    }
}

void gladiator_talk(char *txt)
{
   DESCRIPTOR_DATA *d;
   char buf[MAX_STRING_LENGTH];

   sprintf(buf, "[Gladiator] %s\n\r", txt);
   for (d = descriptor_list; d != NULL; d = d->next)
   {
      CHAR_DATA *victim;

      victim = d->original ? d->original : d->character;

      if (d->connected == CON_PLAYING &&
          !IS_SET(victim->comm,COMM_NOGLADIATOR) &&
          !IS_SET(victim->comm,COMM_QUIET))
      {
         send_to_char(buf, victim);
      }
   }
   log_string(buf);
}

void do_die( CHAR_DATA *ch, char *argument )
{
    if(ch->position != POS_INCAP && ch->position != POS_MORTAL) 
    {
       send_to_char("As much as you'd like to die and we'd like to kill you, sorry you can't do that.",ch);
       return;
    }
    send_to_char("You head for the bright light!\n\r",ch);
    if ( ch->exp > exp_per_level(ch,ch->pcdata->points) * ch->level ) 
       gain_exp(ch,(exp_per_level(ch,ch->pcdata->points)*ch->level - ch->exp)*2/3); 

    raw_kill(ch,ch);
    return;
}


void do_sanction ( CHAR_DATA *ch, char *argument )
{
  CHAR_DATA *victim;
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char buf[MAX_STRING_LENGTH];

  argument = one_argument(argument, arg1);
  one_argument(argument, arg2);

  if( ch->pcdata->rank < MAX_RANK  && !IS_SET(ch->pcdata->clan_flags, CLAN_ALLOW_SANC) )
  {
  send_to_char("You cannot enforce sanctions.\n\r", ch);
  return;
  }

  if ( arg1[0] == '\0' || arg2[0] == '\0' )
  {
  send_to_char("Syntax: sanction <char> <option>\n\r", ch);
  send_to_char("Options are: allow show hall portal regen healer channel skill \n\r", ch);
  return;
  }

  if ( (victim = get_char_world(ch, arg1)) == NULL )
  {
  send_to_char("They aren't here.\n\r", ch);
  return;
  }

  if (IS_NPC(victim))
  {
  send_to_char("Don't be a fucknut.\n\r", ch);
  return;
  }

  if ( ch == victim )
  {
  send_to_char("You may not sanction yourself.\n\r", ch);
  return;
  }

  if( ch->clan != victim->clan )
  {
  send_to_char("You may only enforce sanctions on those in your own clan.\n\r", ch);
  return;
  }

  if ( victim->pcdata->rank == MAX_RANK )
  {
  send_to_char("You may not enforce sanctions on a clan Leader.\n\r", ch);
  return;
  }

  switch(UPPER(arg2[0]))
  {
  case 'A':
    if (victim->pcdata->rank < MAX_RANK -1 )
     {
     send_to_char("You may only grant sanctioning priveledges to /4's.\n\r", ch);
     return;
     }

     if ( !IS_SET(victim->pcdata->clan_flags, CLAN_ALLOW_SANC))
       {
      send_to_char("You now have sanctioning priveledges.\n\r", victim);
      SET_BIT(victim->pcdata->clan_flags, CLAN_ALLOW_SANC);
	sprintf(buf,"$N enables %s's sanctioning ability." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
       }
     else
      {
      send_to_char("Your sanctioning priveledges have been revoked.\n\r", victim);
      REMOVE_BIT(victim->pcdata->clan_flags, CLAN_ALLOW_SANC);
	sprintf(buf,"$N revokes %s's sanctioning ability." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
      }

      break;


  case 'C':
    if(!IS_SET(victim->pcdata->clan_flags, CLAN_NO_CHANNEL))
      {
      send_to_char("You have been forbidden to use the clan channel.\n\r", victim);
      SET_BIT(victim->pcdata->clan_flags, CLAN_NO_CHANNEL);
	sprintf(buf,"$N sanctions %s's with no clan channel." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
      }
      else
      {
      send_to_char("You are once more permitted to use the clan channel.\n\r", victim);
      REMOVE_BIT(victim->pcdata->clan_flags, CLAN_NO_CHANNEL);
	sprintf(buf,"$N removes %s's sanctions of no clan channel." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
      }
    break;

  case 'H':
    if( !str_prefix(arg2, "hall"))
    {
    if (!IS_SET(victim->pcdata->clan_flags, CLAN_NO_HALL))
    {
     send_to_char("You have been forbidden entrance to your clan hall.\n\r", victim);
     SET_BIT(victim->pcdata->clan_flags, CLAN_NO_HALL);
	sprintf(buf,"$N sanctions %s's with no clan hall." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
     if ( victim->in_room->clan && victim->in_room->clan == victim->clan)
     {
     send_to_char("You have been forcefully ejected from your clan hall.\n\r", victim);
     char_from_room(victim);
     char_to_room(victim,get_room_index( ROOM_VNUM_TEMPLE));
     do_look(victim, "auto");
     }

    }
    else
    {
     send_to_char("You are once more permitted to enter the clan hall.\n\r", victim);
     REMOVE_BIT(victim->pcdata->clan_flags, CLAN_NO_HALL);
	sprintf(buf,"$N removes %s's sanctions of no clan hall." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    }

    if ( !str_prefix(arg2, "healer"))
    {
    if (!IS_SET(victim->pcdata->clan_flags, CLAN_NO_HEALER))
    {
      send_to_char("The clan healer will no longer provide services for you.\n\r", victim);
      SET_BIT(victim->pcdata->clan_flags, CLAN_NO_HEALER);
	sprintf(buf,"$N sanctions %s's with no clan healer." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    { 
      send_to_char("The clan healer will once more provide his services to you.\n\r", victim);
      REMOVE_BIT(victim->pcdata->clan_flags, CLAN_NO_HEALER);
	sprintf(buf,"$N removes %s's sanctions of no clan healer." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    }

    break;

  case 'P':
    if(!IS_SET(victim->pcdata->clan_flags, CLAN_NO_PORTALS ))
    {
      send_to_char("You have been forbidden to use the clan portals.\n\r", victim);
      SET_BIT(victim->pcdata->clan_flags, CLAN_NO_PORTALS);
	sprintf(buf,"$N sanctions %s's with no clan portals." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    {
      send_to_char("You are once more permitted to use the clan portals.\n\r", victim);
      REMOVE_BIT(victim->pcdata->clan_flags, CLAN_NO_PORTALS);
	sprintf(buf,"$N removes %s's sanctions of no clan portals." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    break;
    
  case 'R':
    if (!IS_SET(victim->pcdata->clan_flags, CLAN_NO_REGEN))
    {
      send_to_char("You will receive no benefit from the clan regen room.\n\r", victim);
      SET_BIT(victim->pcdata->clan_flags, CLAN_NO_REGEN);
	sprintf(buf,"$N sanctions %s's with no clan regen." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    {
      send_to_char("You will once again receive the benefits of the clan regen room.\n\r", victim);
      REMOVE_BIT(victim->pcdata->clan_flags, CLAN_NO_REGEN);
	sprintf(buf,"$N removes %s's sanctions of no clan regen." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    break;

  case 'S':
    if (!str_prefix(arg2, "store"))
    {
     if (!IS_SET(victim->pcdata->clan_flags, CLAN_NO_STORE))
     {
      send_to_char("You may no longer purchase items at the clan store.\n\r", victim);
      SET_BIT(victim->pcdata->clan_flags, CLAN_NO_STORE);
	sprintf(buf,"$N sanctions %s's with no clan store." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
     }
     else
     {
      send_to_char("You may once more purchase items at the clan store.\n\r", victim);
      REMOVE_BIT(victim->pcdata->clan_flags, CLAN_NO_STORE);
	sprintf(buf,"$N removes %s's sanctions of no clan store." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
     }
    }

    if (!str_prefix(arg2, "skill"))
    {
     if(!IS_SET(victim->pcdata->clan_flags, CLAN_NO_SKILL_1))
     {
       send_to_char("You have been forbidden to use your clan skills.\n\r", victim);
       SET_BIT(victim->pcdata->clan_flags, CLAN_NO_SKILL_1);
	sprintf(buf,"$N sanctions %s's with no clan skill." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
     }
     else
     {
       send_to_char("You are once more permitted to use your clan skills.\n\r", victim);
       REMOVE_BIT(victim->pcdata->clan_flags, CLAN_NO_SKILL_1);
	sprintf(buf,"$N removes %s's sanctions of no clan skill." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
     }
    }
    if (!str_prefix(arg2, "show"))
    {
      sprintf(buf, "%s has the following sanctions:\n\r%s\n\r", victim->name, clan_bit_name(victim->pcdata->clan_flags));
      send_to_char(buf, ch);
    }
    break;

  default:
    send_to_char("That is not a valid sanction.\n\r", ch);
    return;
    break;

   }

   send_to_char("Ok.\n\r", ch);
   return;
}





void do_bounty( CHAR_DATA *ch, char *argument )
{ 
    CHAR_DATA *victim;
    char arg[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    long amt;

    argument = one_argument( argument, arg );
    argument = one_argument( argument, arg2 );

    if ( arg[0] == '\0' )
    {
	send_to_char("Usage: bounty <character> <amount in gold>\n\r",ch);
	return;
    }

    if ( !str_cmp(arg,"list") || !str_cmp(arg,"show") )
    {
	DESCRIPTOR_DATA *d;
	char buf[MAX_STRING_LENGTH];

 	sprintf(buf,"{W%-28s Amount{x\n\r\n\r","Character");
	send_to_char(buf,ch);

	for ( d = descriptor_list ; d != NULL ; d = d->next )
	{
	    if ( d->connected != CON_PLAYING || d->character == NULL )
		continue;

	    if ( d->character->pcdata == NULL )
		continue;

	    if ( d->character->pcdata->bounty <= 0 )
 		continue;

	    sprintf(buf,"%-28s %ld\n\r",d->character->name,d->character->pcdata->bounty);
	    send_to_char(buf,ch);
	}
	return;
    }
    victim = get_char_world(ch,arg);

    if (victim == NULL)
    {
        send_to_char("Nobody by that name to bounty.\n\r",ch);
        return;
    }

    if (ch == victim)
    {
     send_to_char("If you're that eager to die, go to Altirin unsanced.\n\r",ch);
        return;
    }

    if ( IS_IMMORTAL(victim) )
    {
        send_to_char("Don't be a dumb bunny.  Setting a bounty on an Imm, you have a death-wish.\r\n",ch);
	return;
    }
    if ( ch->clan == clan_lookup("hunter") )
    {
	send_to_char("You cannot set a bounty as a bounty hunter yourself!\n\r",ch);
	return;
    }
    if ( (victim = get_char_world(ch,arg) ) == NULL )
    {
	send_to_char("(S)he isn't here.\n\r",ch);
	return;
    }
    if ( IS_NPC(victim) )
    {
       send_to_char("Setting a bounty on a MOB? Don't be a dumb bunny.\r\n",ch);
       return;
    }

    if ( !is_clan(victim) || !is_clan(ch) )
    {
	send_to_char("Impossible.\n\r",ch);
	return;
    }

    if ( arg2 == NULL || *arg2 == '\0' || !is_number(arg2) )
    {
        send_to_char("Usage: bounty <character> <amount in gold>\n\r",ch); 	
 	return;
    }

    if ( (amt = atoi(arg2)) < 200 || amt > ch->gold )
    {	
	send_to_char("Bounties must be at least 200 gold and no more than what you have.\n\r",ch);
	return;
    }

    victim->pcdata->bounty += amt;
    ch->gold -= amt;

    act("You set a bounty on $N!",ch,NULL,victim,TO_CHAR,FALSE);
    if ( !IS_SET(victim->comm,COMM_SILENCE) )
        act("The bounty on your head has been raised.",ch,NULL,victim,TO_VICT,FALSE);
    sprintf(log_buf,"%s sets a bounty of %ld on %s.",ch->name,amt,victim->name);
    log_string(log_buf);
    wiznet(log_buf,NULL,NULL,WIZ_SECURE,0,0);
    sprintf(log_buf,"A bounty of %ld has been placed on %s.",amt,victim->name);
    pnet(log_buf,NULL,NULL,PNET_BOUNTY,0,0);
    return;
}
@


1.205
log
@t putting in cone of silence
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.204 2004/08/29 22:50:13 boogums Exp $";
d621 3
@


1.204
log
@putting cone of silence in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.203 2004/05/04 01:10:00 boogums Exp $";
d1334 2
@


1.203
log
@allowing demisers to group with nonclanners
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.202 2003/12/17 03:59:41 boogums Exp $";
d744 2
d804 3
d868 3
d927 3
d991 3
d1054 3
d1115 3
d1176 3
d1304 3
d1392 3
d1533 3
d1639 3
d1676 3
d1703 3
d2112 6
d2943 3
@


1.202
log
@gsn garotte
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.201 2003/12/14 20:31:35 boogums Exp $";
d2671 1
a2671 1
    if(ch->clan == clan_lookup("demise") && !is_same_clan(ch,victim) )
d2680 1
a2680 1
    if(victim->clan == clan_lookup("demise") && !is_same_clan(ch,victim) )
@


1.201
log
@no longer able to quit outta garotte
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.200 2003/12/09 21:50:09 mud Exp $";
d2071 1
a2071 1
    if( is_affected(ch, skill_lookup("garotte")) )
@


1.200
log
@str_cmp missing !
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.199 2003/12/09 21:35:08 mud Exp $";
d2068 6
@


1.199
log
@missing ;
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.198 2003/12/09 21:33:31 rusty Exp $";
d2166 1
a2166 1
	&& str_cmp(arg, "") )
@


1.198
log
@pnet logins doesn't show pload and punload
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.197 2003/12/06 23:09:55 boogums Exp $";
d2125 1
a2125 1
    one_argument( argument, arg )
@


1.197
log
@bug fixes
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.196 2003/12/06 22:14:33 boogums Exp $";
d2121 1
d2125 1
d2165 5
a2169 4
  //if(!IS_IMMORTAL(ch) || (ch->incog_level == 0 && ch->invis_level == 0))
  //{
  //  pnet("$N leaves Boinga.",ch,NULL,PNET_LOGINS,NULL,get_trust(ch));
  //}
@


1.196
log
@poison bug fix i think
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.195 2003/10/08 00:49:27 ndagger Exp $";
d2163 4
a2166 4
  if(!IS_IMMORTAL(ch) || (ch->incog_level == 0 && ch->invis_level == 0))
  {
    pnet("$N leaves Boinga.",ch,NULL,PNET_LOGINS,NULL,get_trust(ch));
  }
@


1.195
log
@10/07/03 Nightdager:  Implemented bitch channel.  FUN!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.194 2003/09/04 01:05:11 boogums Exp $";
d125 1
a125 1
       send_to_char ("The correct command sequence is delete;delete;recreate.\n\r", ch);
@


1.194
log
@ok putting the garbage check clearout thinkgie in again in do_quit
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.193 2003/09/02 13:26:47 boogums Exp $";
d677 58
@


1.193
log
@ok taking it out hmmmm
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.192 2003/09/01 23:23:45 boogums Exp $";
d2064 1
a2064 1
    /*buf[0] = '\0'; */
@


1.192
log
@ok was missing area
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.191 2003/09/01 23:16:09 boogums Exp $";
d2064 1
a2064 1
    buf[0] = '\0'; 
@


1.191
log
@t damn
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.190 2003/08/30 21:53:52 boogums Exp $";
d2064 1
a2064 1
/*    buf[0] = '\0'; */
@


1.190
log
@ok broke the hd descrptions down a bit and i think i got rid of that
annoying garbage when you quit with a buf[0] = '\0';
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.189 2003/05/25 14:32:21 boogums Exp $";
d2064 1
a2064 1
    buf[0] = '\0';
@


1.189
log
@DOH damn bitvecotrs :)
orey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.188 2003/05/25 01:34:22 boogums Exp $";
d2064 1
a2064 1

@


1.188
log
@ok adding MHS_CURSE
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.187 2003/03/23 00:06:55 boogums Exp $";
d2085 1
a2085 1
	&& (!IS_AFFECTED(ch,AFF_CURSE) || !IS_AFFECTED(ch,MHS_CURSE)) &&
@


1.187
log
@made it so demisers can't group annd can't be forced to group
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.186 2003/03/22 23:03:34 boogums Exp $";
d2085 1
a2085 1
	&& !IS_AFFECTED(ch,AFF_CURSE) &&
@


1.186
log
@putting in demise check group code
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.185 2002/12/05 05:16:56 boogums Exp $";
d2608 2
d2612 5
a2616 1

@


1.185
log
@ok here goes the wand maker kit
and removing damage from pof while in wraith
*gulp* i hate messing with merc.h
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.184 2002/11/11 18:37:01 mud Exp $";
d2602 9
@


1.184
log
@) missing typo fix
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.183 2002/11/11 18:35:17 rusty Exp $";
d2006 6
@


1.183
log
@DOT check in do_quit_command() to override if they made it back to
clan hall safely
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.182 2002/10/29 01:32:33 ndagger Exp $";
d2005 1
a2005 1
  boolean can_quit=TRUE;
d2044 1
a2044 1
	&& (ch->in_room->clan != ch->clan || !can_quit ) {
@


1.182
log
@10/28/02 Nightdagger:  Can't set a bounty on yourself anymore.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.181 2002/10/28 05:43:52 boogums Exp $";
d2004 2
d2035 10
a2044 1
    if (ch->pcdata && ch->pcdata->quit_time > 0 && !IS_IMMORTAL (ch) && ch->in_room->clan != ch->clan) {
@


1.181
log
@t got it coding shortcuts are bad
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.180 2002/10/28 05:26:20 ndagger Exp $";
d3296 6
@


1.180
log
@10/27/02 Nightdagger:  Final repair on bounty, removed a comment Boogums missed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.179 2002/10/28 05:03:57 boogums Exp $";
d3255 1
d3259 1
a3259 1
    one_argument(argument,arg);
d3326 1
a3326 1
    if ( argument == NULL || *argument == '\0' || !is_number(argument) )
d3332 1
a3332 1
    if ( (amt = atoi(argument)) < 200 || amt > ch->gold )
@


1.179
log
@doh
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.178 2002/10/28 04:57:18 boogums Exp $";
d3257 1
a3257 1
    //ssargument = one_argument( argument, arg );
@


1.178
log
@putting bounty back in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.177 2002/10/28 04:48:46 ndagger Exp $";
d3257 1
a3257 1
    argument = one_argument( argument, arg );
@


1.177
log
@10/27/02 Nightdagger:  Repaired bounty crash bug.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.176 2002/10/18 14:31:39 boogums Exp $";
d3257 2
a3258 4
    //argument = one_argument( argument, arg );
    //one_argument(argument,arg);
    send_to_char("Bounty code is currently out of Commission.  Sorry, try again later.  I've got bigger fish to fry right now.\r\n",ch);
   return;
a3289 1
    send_to_char("Before victim= line\r\n",ch);
a3290 1
    send_to_char("Before Immortal Chec\r\n",ch);
a3302 1
    send_to_char("Before hunter check \r \n",ch);
a3307 1
    send_to_char("Before getcharworld check\r\n",ch);
a3312 1
    send_to_char("Before NPC checkr\r\n",ch);
a3318 1
send_to_char("before clan nonclan check\r\n",ch);
a3323 1
send_to_char("Before null arg check\r\n",ch);
@


1.176
log
@turning bount offy again
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.175 2002/10/18 04:07:26 boogums Exp $";
d3295 7
@


1.175
log
@taking bonty back out
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.174 2002/10/18 03:57:56 boogums Exp $";
d3260 1
a3260 1
    //return;
@


1.174
log
@ok lret's try this
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.173 2002/10/18 03:47:32 boogums Exp $";
d3258 2
a3259 2
    one_argument(argument,arg);
    //send_to_char("Bounty code is currently under review.  Sorry, try again later.\r\n",ch);
@


1.173
log
@testing bounty
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.172 2002/10/04 18:55:34 boogums Exp $";
d3257 2
a3258 1
    argument = one_argument( argument, arg );
d3292 1
@


1.172
log
@grrr
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.171 2002/10/04 18:50:58 boogums Exp $";
d3258 2
a3259 2
    send_to_char("Bounty code is currently under review.  Sorry, try again later.\r\n",ch);
    return;
d3291 3
a3293 1
    if ( IS_IMMORTAL(victim = get_char_world(ch,arg)) )
d3298 1
a3298 1

d3304 1
a3304 1

d3310 1
a3310 1

d3317 1
a3317 1

d3323 1
@


1.171
log
@grrr dumb lazy G
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.170 2002/10/04 18:43:53 boogums Exp $";
d3258 2
a3259 2
   /* send_to_char("Bounty code is currently under review.  Sorry, try again later.\r\n",ch);
    return;*/
@


1.170
log
@putting bounty back in
move the ISNPC check up higher in the tree
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.169 2002/09/22 21:43:24 boogums Exp $";
d3324 1
a3324 1
	do_bounty(ch,"");
@


1.169
log
@disabling bounty code so i can figure out why it's crashing
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.168 2002/09/21 04:39:08 boogums Exp $";
d3258 2
a3259 2
    send_to_char("Bounty code is currently under review.  Sorry, try again later.\r\n",ch);
    return;
d3309 8
a3316 1
    if ( IS_NPC(victim) || !is_clan(victim) || !is_clan(ch) )
@


1.168
log
@made it so you can't bounty imms
dubmass G
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.167 2002/06/14 18:51:19 rusty Exp $";
d3258 2
@


1.167
log
@Elementalists can only reclass at 51
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.166 2002/04/18 19:33:13 poquah Exp $";
d3287 5
@


1.166
log
@more gladiator changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.165 2002/04/03 15:56:18 rusty Exp $";
d129 7
@


1.165
log
@Took out IMM dropping link from Pnet
Took out IMM login/logout if invis or incog from Pnet
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.164 2002/04/01 21:05:43 rusty Exp $";
d2838 1
a2838 1
	   && (gladiator_info.type == 3 || gladiator_info.type == 4)
@


1.164
log
@Added pnet, wiznet like info for mortals
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.163 2002/03/12 03:01:07 rusty Exp $";
d2081 4
a2084 1
  pnet("$N leaves Boinga.",ch,NULL,PNET_LOGINS,NULL,get_trust(ch));
@


1.163
log
@Yanked starting HMV as fixed values and put back in gains
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.162 2002/03/09 19:55:58 rusty Exp $";
d2081 1
d3319 2
@


1.162
log
@Info changes/fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.161 2002/03/09 19:14:26 rusty Exp $";
d302 2
a303 2
    ch->pcdata->perm_hit = pc_race_table[ch->race].starting_hmv[0];
    ch->max_hit = pc_race_table[ch->race].starting_hmv[0];
d307 4
a310 4
    ch->pcdata->perm_mana = pc_race_table[ch->race].starting_hmv[1];
    ch->max_mana = pc_race_table[ch->race].starting_hmv[1];
    ch->pcdata->perm_move = pc_race_table[ch->race].starting_hmv[2];
    ch->max_move = pc_race_table[ch->race].starting_hmv[2];
@


1.161
log
@Hiding information and reup_affect() additions. Initial
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.160 2001/12/21 00:44:59 rage Exp $";
a2557 1
	}
d2559 1
@


1.160
log
@change to allow you to quit once in your hall, even if timer is set
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.159 2001/12/07 19:00:50 poquah Exp $";
d302 2
a303 2
    ch->pcdata->perm_hit = 20;
    ch->max_hit = 20;
d307 4
a310 4
    ch->pcdata->perm_mana = 100;
    ch->max_mana = 100;
    ch->pcdata->perm_move = 100;
    ch->max_move = 100;
a2506 1
	 if ( is_affected(gch,gsn_rage) )
d2508 1
a2508 22
    "[%2d %s] %-16s ????/???? hp %4d/%4d mana %4d/%4d mv %6d xp\n\r",
	gch->level,
	IS_NPC(gch) ? "Mob" : class_table[gch->class].who_name,
	capitalize( PERS(gch,ch,TRUE) ),
	gch->mana,	gch->max_mana,
	gch->move,	gch->max_move,
	gch->exp	);
	else
	{
	/*
    sprintf( buf,
    "[%2d %s] %-16s %4d/%4d hp %4d/%4d mana %4d/%4d mv %6d xp\n\r",
        gch->level,
        IS_NPC(gch) ? "Mob" : class_table[gch->class].who_name,
        capitalize( PERS(gch,ch,TRUE) ),
        gch->hit,   gch->max_hit,
        gch->mana,  gch->max_mana,
        gch->move,  gch->max_move,
        gch->exp    );
       */
    sprintf( buf,
    "[%2d %s] %-16s ",
d2512 6
d2519 1
a2519 1
		strcat(buf,"{W");
d2522 1
a2522 1
		strcat(buf,"{Y");
d2525 6
a2530 1
		strcat(buf,"{R");
a2531 5
		strcat(buf,"{r");
    sprintf( buf2,
    "%4d{x/%4d hp ",
    gch->hit, gch->max_hit);
	    strcat(buf,buf2);
d2533 1
a2533 1
		strcat(buf,"{W");
d2536 1
a2536 1
		strcat(buf,"{Y");
d2539 6
a2544 1
		strcat(buf,"{R");
a2545 5
		strcat(buf,"{r");
    sprintf( buf2,
    "%4d{x/%4d mana ",
    gch->mana, gch->max_mana);
	    strcat(buf,buf2);
d2547 1
a2547 1
		strcat(buf,"{W");
d2550 1
a2550 1
		strcat(buf,"{Y");
d2553 1
a2553 1
		strcat(buf,"{R");
d2555 2
a2556 8
		strcat(buf,"{r");
    sprintf( buf2,
    "%4d{x/%4d mv ",
    gch->move, gch->max_move);
	    strcat(buf,buf2);
    sprintf( buf2,
    "%6d xp\n\r",
        gch->exp    );
a2559 1
      }
@


1.159
log
@make nonclanners immune to storage code for now
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.158 2001/12/05 18:47:44 poquah Exp $";
d2026 1
a2026 1
    if (ch->pcdata && ch->pcdata->quit_time > 0 && !IS_IMMORTAL (ch)) {
@


1.158
log
@do not increment login counters for Immortals
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.157 2001/12/05 17:19:45 poquah Exp $";
d2133 1
a2133 1
       if (!IS_IMMORTAL(ch))
@


1.157
log
@move glad_bet_on,glad_bet_amt, glad_tot_bet to pcdata
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.156 2001/12/05 17:07:03 poquah Exp $";
d2133 9
a2141 6
       if(ch->pcdata->combats_since_last_login == 0)
         ch->pcdata->logins_without_combat++;
       if(ch->pcdata->died_today == FALSE)
         ch->pcdata->logins_without_death++;
       if(ch->pcdata->killed_today == FALSE)
         ch->pcdata->logins_without_kill++;
@


1.156
log
@move gladiator_data and highlander_data to pcdata
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.155 2001/12/03 18:34:53 poquah Exp $";
d2112 1
a2112 1
		if(d_glad->character != NULL && d_glad->character->glad_bet_on == ch)
d2115 1
a2115 1
			  d_glad->character->glad_bet_amt, ch->name);
d2117 2
a2118 2
		  d_glad->character->glad_bet_on = d_glad->character;
		  d_glad->character->glad_bet_amt = 0;
@


1.155
log
@add some code to look for storage chars
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.154 2001/12/03 15:13:33 poquah Exp $";
d2098 1
a2098 1
	   (victm->highlander_data[ALL_KILLS] >= 6))
@


1.154
log
@missing - in do_die
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.153 2001/12/03 15:11:22 poquah Exp $";
d2131 8
a2138 2
    if (ch->pcdata->logout_tracker > 0)
       ch->pcdata->logout_tracker -= 1;
@


1.153
log
@fix die command, add back in last_death_timer
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.152 2001/12/03 14:43:29 poquah Exp $";
d3010 1
a3010 1
    if ( ch>exp > exp_per_level(ch,ch->pcdata->points) * ch->level ) 
@


1.152
log
@add death penalty to do_die so people dont avoid losing exp
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.151 2001/11/28 18:54:55 poquah Exp $";
d3010 2
a3011 3
    if ( victim->exp > exp_per_level(victim,victim->pcdata->points) 
           * victim->level ) 
       gain_exp(victim,(exp_per_level(victim,victim->pcdata->points)*victim->level - victim->exp)*2/3); 
@


1.151
log
@change message on die command
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.150 2001/11/28 18:54:11 poquah Exp $";
d3010 4
@


1.150
log
@change do_die from setintg hp and update_pos to raw_kill
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.149 2001/11/25 05:24:23 poquah Exp $";
d3009 1
a3009 1
    send_to_char("You head for the bright light and will be dead on the next tick.\n\r",ch);
@


1.149
log
@bump the do_die up to -19 to see if that kills people on tick
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.148 2001/10/13 02:11:58 rage Exp $";
d3010 1
a3010 2
    ch->hit = -19;
    update_pos(ch);
@


1.148
log
@Bug fixes as follow

can no longer drag furniture that's being used
steal/slice kr only increments on players
IMMs now immune to sector damage
die command should work now
spec_average now has an IS_AWAKE check
Cavalier attack is now given to groupmates
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.147 2001/09/22 17:53:00 rage Exp $";
d3010 1
a3010 1
    ch->hit = -9;
@


1.147
log
@more cavalier fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.146 2001/09/22 15:20:44 boogums Exp $";
d2929 1
a2929 1
		(is_mounted(ch) && IS_NPC(ch->riding) && ch->riding->pIndexData->vnum == MOB_VNUM_WARHORSE) &&
d3010 2
a3011 1
    ch->hit = -20;
@


1.146
log
@yanking cavalier code it's just commented
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.145 2001/09/22 15:01:00 boogums Exp $";
d2914 1
a2914 1
/*bool group_has_cavalier( CHAR_DATA *ch )
d2938 1
a2938 1
*/
@


1.145
log
@many thanks to Rage for help on getting the cavalier kit in
trying what he suggested
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.144 2001/09/22 00:10:48 boogums Exp $";
d2914 1
a2914 1
bool group_has_cavalier( CHAR_DATA *ch )
d2938 1
a2938 1

@


1.144
log
@yanked cavalier kit, don't know why it's crashing when they login
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.143 2001/09/20 03:10:30 boogums Exp $";
d2914 1
a2914 1
/*bool group_has_cavalier( CHAR_DATA *ch )
d2938 1
a2938 1
*/
@


1.143
log
@19SEP01
Putting the cavalier kit in going to try on OOC
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.142 2001/08/30 03:34:12 guerrand Exp $";
d2914 1
a2914 1
bool group_has_cavalier( CHAR_DATA *ch )
d2938 1
a2938 26

int group_has_how_many_cavalier( CHAR_DATA *ch )
{
    DESCRIPTOR_DATA *d;
    CHAR_DATA *vch;
    int number_of =0;

    if ( IS_NPC(ch) )
        return 0;

    for ( d = descriptor_list ; d != NULL ; d= d->next )
    {
       if ( ( vch = d->character ) == NULL )
                continue;

        if ( is_same_group( ch, vch ) &&
                vch->class == kit_lookup("cavalier") &&
                vch->in_room == ch->in_room  &&
                has_group_mates(ch)
                )
                number_of++;
    }

    return number_of;
}

@


1.142
log
@added hunter clan
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.141 2001/08/30 03:22:10 guerrand Exp $";
d2913 51
@


1.141
log
@Added a bounty minimum.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.140 2001/08/30 01:45:44 guerrand Exp $";
d3261 6
@


1.140
log
@Made it so 'silence' disables bounty messages.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.139 2001/08/30 01:16:21 guerrand Exp $";
d3282 1
a3282 1
    if ( (amt = atoi(argument)) < 1 || amt > ch->gold )
d3284 1
a3284 1
	send_to_char("You can't set a bounty in that amount.\n\r",ch);
@


1.139
log
@Some enhances to logging for bounty.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.138 2001/08/30 01:03:22 guerrand Exp $";
d3292 2
a3293 1
    act("The bounty on your head has been raised.",ch,NULL,victim,TO_VICT,FALSE);
@


1.138
log
@Added bounty command.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.137 2001/03/21 20:33:57 mud Exp $";
d3229 1
a3229 1
    int amt;
d3293 3
a3295 1

@


1.137
log
@Final few tweaks to do_afk() and when ch->pcdata->afk_counter is cleared.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.136 2001/03/15 19:10:21 mud Exp $";
d3225 21
d3247 49
@


1.136
log
@uncomment afk_counter, found structure prob
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.135 2001/03/15 18:58:50 mud Exp $";
d568 6
d575 1
d577 1
a584 1
     ch->pcdata->afk_counter = 0;
d605 1
@


1.135
log
@remove afk_counter for a minute, says not in structure
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.134 2001/03/15 18:55:01 mud Exp $";
a567 1
      /*
a569 1
      */
a576 1
     /*
a577 1
     */
a1377 1
      /*
a1378 1
  */
@


1.134
log
@afk counter , you have X messages waiting
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.133 2001/01/23 19:59:00 mud Exp $";
d568 1
d571 1
d579 1
d581 1
d1382 1
d1384 1
@


1.133
log
@add reclassing back in
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.132 2000/12/24 02:22:37 mud Exp $";
d563 2
d568 2
d577 1
d1378 1
@


1.132
log
@23dec00
i thought i did the order command, weird
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.131 2000/12/16 04:47:02 mud Exp $";
d123 6
a128 2
    send_to_char ("The correct command sequence is delete;delete;recreate.\n\r", ch);
    return;
a129 1
/*
a134 1
    */
@


1.131
log
@15DEC00
Allowing you to order charmies while wraithformed now.
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.130 2000/12/15 06:22:29 mud Exp $";
d2366 7
@


1.130
log
@14DEC00
autoassist is trickier than i thought
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.129 2000/10/16 19:16:58 mud Exp $";
a2362 6

    if (is_affected(ch, skill_lookup("wraithform")) )
    {
    send_to_char("No ordering while in wraithform.\r\n",ch);
    return;
    }
@


1.129
log
@ added in second avarice clan skill
 fixed bug in indulgence
 added in functionality for "sanction skill"
 -rage
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.128 2000/10/09 21:20:30 mud Exp $";
d2363 6
@


1.128
log
@anctions appear on wiznet
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.127 2000/09/19 20:47:11 mud Exp $";
d2486 1
d2496 1
a2496 1
	/*
d2502 1
a2502 1
	    if ( gch->hit * 100 / gch->max_hit > 75 )
d2505 1
a2505 1
	    if ( gch->hit * 100 / gch->max_hit > 50 )
d2508 1
a2508 1
	    if ( gch->hit * 100 / gch->max_hit > 25 )
d2516 1
a2516 1
	    if ( gch->mana * 100 / gch->max_mana > 75 )
d2519 1
a2519 1
	    if ( gch->mana * 100 / gch->max_mana > 50 )
d2522 1
a2522 1
	    if ( gch->mana * 100 / gch->max_mana > 25 )
d2530 1
a2530 1
	    if ( gch->move * 100 / gch->max_move > 75 )
d2533 1
a2533 1
	    if ( gch->move * 100 / gch->max_move > 50 )
d2536 1
a2536 1
	    if ( gch->move * 100 / gch->max_move > 25 )
a2547 1
       */
@


1.127
log
@ bug fix in do_group.  Commented out POq's code until I can spend time to fix
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.126 2000/09/19 20:04:20 mud Exp $";
d3032 2
d3039 2
d3051 2
d3058 2
d3070 2
d3085 2
d3096 2
d3103 2
d3115 2
d3122 2
d3132 2
d3139 2
d3151 2
d3158 2
d3169 2
d3176 2
@


1.126
log
@fix CR in group
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.125 2000/09/18 05:16:18 mud Exp $";
a2485 1
	/*
d2495 1
a2495 1
	*/
d2547 1
@


1.125
log
@opps two declares
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.124 2000/09/18 05:13:45 mud Exp $";
d2498 1
a2498 1
    "[%2d %s] %-16s \n\r",
@


1.124
log
@color codes in group
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.123 2000/08/29 16:44:00 mud Exp $";
a2456 1
    char arg[MAX_INPUT_LENGTH];
@


1.123
log
@ removed bug fix, wasn't really a bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.122 2000/08/29 16:40:14 mud Exp $";
d2456 2
d2486 2
d2497 53
@


1.122
log
@ tried different bug fix in do_die
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.121 2000/08/29 16:28:24 mud Exp $";
a2905 1
    bramage( ch, ch, 1, TYPE_UNDEFINED, DAM_NONE,FALSE); 
@


1.121
log
@ bug fix in do_die
 added update_pos() to fix
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.120 2000/08/28 13:38:06 mud Exp $";
d2906 1
a2906 1
    update_pos(ch);
@


1.120
log
@ saction hall moves victim to recall

 bug fix on communion allowing negative sac points

 bug fix on sneaking mobs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.119 2000/08/26 03:26:13 mud Exp $";
d2906 1
@


1.119
log
@ fixed major bug with saving of prevOwner field in pfiles
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.118 2000/08/23 13:38:02 mud Exp $";
d3006 8
@


1.118
log
@ fixed little bug in olist with multiple declaration of aconstants
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.116 2000/08/20 00:13:17 mud Exp $";
d123 1
a123 1
    send_to_char ("You are better off waiting for the pfresh.\n\r",ch);
@


1.117
log
@ another attempt to add in olist, also some general clean up
 -Rage
@
text
@@


1.116
log
@missing ;
poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.115 2000/08/20 00:11:23 mud Exp $";
d2928 2
a2929 1
  send_to_char("Syntax: sanction <char> <hall|channel|portal|healer|store|regen|skill|allow|show>\n\r", ch);
@


1.115
log
@highlander bugs and loggins some highlander stuff
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.114 2000/08/19 20:17:54 mud Exp $";
d2085 1
a2085 1
   remove_highlander(ch,ch)
@


1.114
log
@ added in sanction show
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.113 2000/08/18 22:49:01 mud Exp $";
d42 3
d2085 1
a2085 1
   REMOVE_BIT(ch->mhs,MHS_HIGHLANDER);
@


1.113
log
@Highlanders Abound
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.112 2000/08/17 18:14:41 mud Exp $";
d2912 1
d2925 1
a2925 1
  send_to_char("Syntax: sanction <char> <hall|channel|portal|healer|store|regen|skill>\n\r", ch);
d3079 5
@


1.112
log
@ small bug fix when a gladiator quits with bets on him
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.111 2000/08/17 17:17:59 mud Exp $";
d2082 1
@


1.111
log
@ added in sanction allow to allow clan leader to grant ability to /4's
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.110 2000/08/17 15:41:16 mud Exp $";
d2095 2
a2096 2
			  d_glad->character->glad_bet_amt, ch);
		  send_to_char(buf, d->character);
@


1.110
log
@ more implementation of sanction command
 finished all but no_clan_skill
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.109 2000/08/17 14:29:26 mud Exp $";
d2915 1
a2915 1
  if( ch->pcdata->rank < MAX_RANK )
d2917 1
a2917 1
  send_to_char("You cannot enforce sanctions\n\r", ch);
d2959 21
@


1.109
log
@ first implementation of "sanction" command for clan leaders
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.108 2000/07/25 19:43:45 mud Exp $";
d1088 6
d2923 1
a2923 1
  send_to_char("Syntax: sanction <char> <hall|portal|healer|store|regen|skill>\n\r", ch);
d2933 6
d2959 13
d2973 2
d2985 16
d3015 43
d3060 2
@


1.108
log
@new d-exp messages and rmeove rage joke
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.107 2000/07/25 16:52:19 mud Exp $";
d2898 89
@


1.107
log
@fix gladiator_talk
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.106 2000/07/21 17:34:20 mud Exp $";
a694 2
      if (!str_cmp(ch->name,"Rage")) 
	 strcpy(argument,"Poquah my Lord and Master, I bow down to you.");
@


1.106
log
@ fixed another bug with glads quitting and bet refunding
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.105 2000/07/21 17:14:17 mud Exp $";
d694 3
@


1.105
log
@Making sure d->character isn't NULL before refering to
values in it's struct.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.104 2000/07/18 17:06:27 mud Exp $";
d2009 1
a2009 1
    DESCRIPTOR_DATA *d, *d_next;
d2083 1
a2083 1
	   for ( d = descriptor_list; d != NULL; d = d->next)
d2085 1
a2085 1
		if(d->character != NULL && d->character->glad_bet_on == ch)
d2088 1
a2088 1
			  d->character->glad_bet_amt, ch);
d2090 2
a2091 2
		  d->character->glad_bet_on = d->character;
		  d->character->glad_bet_amt = 0;
@


1.104
log
@changed act_new() and get_char_room() to use HOLYLIGHT settings
for can/cannot see.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.103 2000/07/18 01:03:09 mud Exp $";
d2085 1
a2085 1
		if(d->character->glad_bet_on == ch)
@


1.103
log
@ missed a " - whoops
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.102 2000/07/18 00:56:54 mud Exp $";
d2085 1
a2085 1
		if(d->character->glad_bet_on = ch)
@


1.102
log
@ when a gladiator quits, bets on him are removed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.101 2000/07/13 00:14:09 mud Exp $";
d2087 1
a2087 1
	          sprintf(buf, "The bookie refunds your bet of %d on %s., 
@


1.101
log
@fix do_die command
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.100 2000/07/11 23:18:56 mud Exp $";
a2077 1
	   REMOVE_BIT(ch->mhs,MHS_GLADIATOR);
d2081 15
@


1.100
log
@added teh die command so you dont have to wait out death
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.99 2000/05/30 00:26:37 mud Exp $";
d2874 1
a2874 1
    if(ch->position != POS_INCAP || ch->position != POS_MORTAL) 
@


1.99
log
@add team stats to kr, score and stat
clean up bugs in team code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.98 2000/05/29 19:36:59 mud Exp $";
d2872 11
@


1.98
log
@adding new gladiator files and tteam gladiator code with gladitor code moved
out of old files.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.97 2000/05/26 02:34:25 mud Exp $";
d2744 2
a2745 1
	   && (gladiator_info.type == 3 || gladiator_info.type == 4))
@


1.97
log
@missing )
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.96 2000/05/26 02:32:55 mud Exp $";
d34 1
d2081 1
a2081 26
	   ch->clan = ch->pcdata->save_clan;
	   ch->pcdata->save_clan = 0;
           char_from_room(ch);
           char_to_room(ch, get_room_index(clan_table[ch->clan].hall));

	   /* Check if the gladiator has started and if so if the 
	      removal of this player leaves only 1 person */
	   if((gladiator_info.playing == 2) && gladiator_info.time_left == 0
	       && (gladiator_info.type == 1 || gladiator_info.type == 2))
	   {
	      DESCRIPTOR_DATA *d;

              for(d = descriptor_list; d != NULL; d = d->next)
              {
		 if (d->character != NULL)
		 {
                 if (IS_SET(d->character->mhs, MHS_GLADIATOR))
                 {
                    sprintf(buf, "%s is victorious in the arena!", d->character->name);
                    gladiator_talk(buf); 
		    gladiator_winner(d->character);
                 }
		 }
              }
           }
	   gladiator_info.playing--;
@


1.96
log
@fix all glads being grouped
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.95 2000/05/26 01:46:23 mud Exp $";
d2768 1
a2768 1
	   && (gladiator_info.type == 3 || gladiator_info.type == 4)
@


1.95
log
@team gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.94 2000/05/25 03:08:08 mud Exp $";
d2767 2
a2768 1
       if (IS_SET(ach->mhs,MHS_GLADIATOR) && IS_SET(bch->mhs,MHS_GLADIATOR))
@


1.94
log
@team gladiator
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.93 2000/05/25 03:06:05 mud Exp $";
d2084 1
d2087 2
a2088 1
	   if((gladiator_info.playing == 2) && gladiator_info.time_left == 0)
@


1.93
log
@working on team gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.92 2000/05/24 03:53:42 mud Exp $";
d2768 1
a2768 1
          RETURN TRUE;
@


1.92
log
@typo fix on how_many_crusaders
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.91 2000/05/24 03:38:29 mud Exp $";
d2762 9
@


1.91
log
@crusader mods, more attacks with more crusaders in group
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.90 2000/05/23 04:12:36 mud Exp $";
a2819 1
int group_has_how_many_crusaders( CHAR_DATA *ch )
d2821 1
@


1.90
log
@clean up some gladiator stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.89 2000/05/21 05:16:19 mud Exp $";
d2820 26
@


1.89
log
@log gladiators
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.88 2000/05/21 04:47:45 mud Exp $";
d2506 6
@


1.88
log
@add d->character != NULL checks on gladiator codes
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.87 2000/05/21 00:28:51 mud Exp $";
d2834 1
a2844 1
         sprintf(buf, "[Gladiator] %s\n\r", txt);
d2848 1
@


1.87
log
@fix gladiator update
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.86 2000/05/20 23:47:57 mud Exp $";
d2092 2
d2100 1
@


1.86
log
@clean up some gladiator stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.85 2000/05/20 01:12:18 mud Exp $";
a2074 1
#ifdef CODE_TEST
a2101 1
#endif
@


1.85
log
@working on Gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.84 2000/05/16 00:55:56 mud Exp $";
d438 1
a438 1
    send_to_char("gladiator          ",ch);
@


1.84
log
@add in all the #ifdef CODE_TEST for gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.83 2000/05/14 00:48:40 mud Exp $";
d2843 1
a2843 1
         sprintf(buf, "&c[&RGladiator&c] &R%s&w\n\r", txt);
@


1.83
log
@move char back to hall if quits as gladiator
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.82 2000/05/13 22:44:51 mud Exp $";
d2075 1
d2103 1
@


1.82
log
@clean up couple more syntax erros in gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.81 2000/05/13 22:37:21 mud Exp $";
d2082 2
a2083 1
	   ch->was_in_room = clan_table[ch->clan].hall;
@


1.81
log
@cleaning up the declarations for gladiator talk
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.80 2000/05/13 22:11:07 mud Exp $";
d2085 1
a2085 1
	   if((gladiator_info.playing -1) == 1 && gladiator_info.time_left = 0)
d2815 1
a2815 1
       REMOVE_BIT(ch->comm, COMM_NOGLADIATOR));
d2820 1
a2820 1
       SET_BIT(ch->comm, COMM_NOGLADIATOR));
@


1.80
log
@debugging gladiator - this could take a while
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.79 2000/05/13 22:06:45 mud Exp $";
a36 1
DECLARE_DO_FUN(do_gladiator_winner  );
a39 1
void do_gladiatortalk	args( ( char *txt ));
d2079 1
a2079 1
           do_gladiatortalk(buf); 
d2094 2
a2095 2
                    do_gladiatortalk(buf); 
		    do_gladiator_winner(d->character);
d2825 1
a2825 1
void do_gladiatortalk(char *txt)
@


1.79
log
@change decalration of gladtalk to use char instead of const char
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.78 2000/05/13 21:57:49 mud Exp $";
a36 1
DECLARE_DO_FUN(do_gladiatortalk  );
d41 1
@


1.78
log
@decalre functions not in this file
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.77 2000/05/13 21:55:07 mud Exp $";
d2827 1
a2827 1
void do_gladiatortalk(const char *txt)
@


1.77
log
@Gladiator Combat - Intense!
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.76 2000/04/18 19:50:49 mud Exp $";
d37 2
@


1.76
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.75 2000/04/17 22:00:42 mud Exp $";
d438 6
d2075 27
d2810 36
@


1.75
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.74 2000/03/06 16:50:17 mud Exp $";
d554 1
a554 1
      act("$n returns from {CAFK{x.",ch,NULL,NULL,TO_ROOM);
d560 1
a560 1
     act("$n goes {CAFK{x.",ch,NULL,NULL,TO_ROOM);
d640 1
a640 1
        ch,argument,d->character,TO_VICT,POS_DEAD);
d701 1
a701 1
       ch,argument, d->character, TO_VICT,POS_SLEEPING );
d761 1
a761 1
       ch,argument, d->character, TO_VICT,POS_SLEEPING );
d818 1
a818 1
       ch,argument, d->character, TO_VICT,POS_SLEEPING );
d878 1
a878 1
       ch,argument, d->character, TO_VICT,POS_SLEEPING );
d938 1
a938 1
      ch,argument,d->character,TO_VICT,POS_SLEEPING);
d995 1
a995 1
      ch,argument,d->character,TO_VICT,POS_SLEEPING);
d1053 1
a1053 1
        ch,argument,d->character,TO_VICT,POS_SLEEPING);
d1128 2
a1129 2
      channel_vis_status(ch,d->character);
      act_new("$n {Gclans{x '$t'",ch,argument,d->character,TO_VICT,POS_DEAD);
d1159 1
a1159 1
    act_new("$n: $t",ch,argument,NULL,TO_CHAR,POS_DEAD);
d1167 1
a1167 1
      act_new("$n: $t",ch,argument,d->character,TO_VICT,POS_DEAD);
d1184 2
a1185 2
    act( "$n says '$T'", ch, NULL, argument, TO_ROOM );
    act( "You say '$T'", ch, NULL, argument, TO_CHAR );
d1237 1
a1237 1
    act( "You shout '$T'", ch, NULL, argument, TO_CHAR );
d1250 1
a1250 1
      act("$n shouts '$t'",ch,argument,d->character,TO_VICT);
d1316 1
a1316 1
      ch,NULL,victim,TO_CHAR);
d1332 1
a1332 1
  act( "$E can't hear you.", ch, 0, victim, TO_CHAR );
d1340 1
a1340 1
  act( "$E is not receiving tells.", ch, 0, victim, TO_CHAR );
d1348 1
a1348 1
      act("$E is AFK, and not receiving tells.",ch,NULL,victim,TO_CHAR);
d1353 1
a1353 1
      ch,NULL,victim,TO_CHAR);
d1365 1
a1365 1
    act( "You tell $N '$t'", ch, argument, victim, TO_CHAR );
d1370 1
a1370 1
		ch,argument,victim,TO_VICT,POS_DEAD);      
d1372 1
a1372 1
        act_new("\x07$n tells you '$t'",ch,argument,victim,TO_VICT,POS_DEAD);
d1378 1
a1378 1
		ch,argument,victim,TO_VICT,POS_DEAD);    
d1380 1
a1380 1
      act_new("$n tells you '$t'",ch,argument,victim,TO_VICT,POS_DEAD);    
d1422 1
a1422 1
      ch,NULL,victim,TO_CHAR);
d1438 1
a1438 1
  act( "$E can't hear you.", ch, 0, victim, TO_CHAR );
d1446 1
a1446 1
  act_new( "$E is not receiving tells.", ch, 0, victim, TO_CHAR,POS_DEAD);
d1464 1
a1464 1
    ch,NULL,victim,TO_CHAR,POS_DEAD);
d1469 1
a1469 1
      ch,NULL,victim,TO_CHAR,POS_DEAD);
d1482 1
a1482 1
    act_new("You tell $N '$t'",ch,argument,victim,TO_CHAR,POS_DEAD);
d1487 1
a1487 1
		ch,argument,victim,TO_VICT,POS_DEAD);
d1489 1
a1489 1
        act_new("\x07$n tells you '$t'",ch,argument,victim,TO_VICT,POS_DEAD);
d1495 1
a1495 1
		ch,argument,victim,TO_VICT,POS_DEAD);
d1497 1
a1497 1
        act_new("$n tells you '$t'",ch,argument,victim,TO_VICT,POS_DEAD);    
d1523 1
a1523 1
    act("You yell '$t'",ch,argument,NULL,TO_CHAR);
d1533 1
a1533 1
      act("$n yells '$t'",ch,argument,d->character,TO_VICT);
d1555 2
a1556 2
    act( "$n $T", ch, NULL, argument, TO_ROOM );
    act( "$n $T", ch, NULL, argument, TO_CHAR );
d1580 1
a1580 1
    act( "$n $t", ch, argument, NULL, TO_CHAR );
d1589 1
a1589 1
      act("$N $t",vch,argument,ch,TO_CHAR);
d1639 1
a1639 1
  act("$N $t",vch,temp,ch,TO_CHAR);
d1923 2
a1924 2
    act( pose_table[pose].message[2*class+0], ch, NULL, NULL, TO_CHAR );
    act( pose_table[pose].message[2*class+1], ch, NULL, NULL, TO_ROOM );
d2040 1
a2040 1
    act( "$n has left the game.", ch, NULL, NULL, TO_ROOM );
d2139 1
a2139 1
  act( "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
d2157 1
a2157 1
       ch,NULL,victim, TO_CHAR);
d2220 1
a2220 1
  act( "$n now follows you.", ch, NULL, master, TO_VICT );
d2222 1
a2222 1
    act( "You now follow $N.",  ch, NULL, master, TO_CHAR );
d2245 2
a2246 2
  act( "$n stops following you.",     ch, NULL, ch->master, TO_VICT    );
  act( "You stop following $N.",      ch, NULL, ch->master, TO_CHAR    );
d2265 1
a2265 1
      act("$N slowly fades away.",ch,NULL,pet,TO_NOTVICT);
d2394 1
a2394 1
      act( buf, ch, NULL, och, TO_VICT );
d2479 1
a2479 1
  act( "$N isn't following you.", ch, NULL, victim, TO_CHAR );
d2491 1
a2491 1
  act("You like your master too much to leave $m!",ch,NULL,victim,TO_VICT);
d2516 1
a2516 1
  act( "$n removes $N from $s group.",   ch, NULL, victim, TO_NOTVICT );
d2518 2
a2519 2
  act( "$n removes you from $s group.",  ch, NULL, victim, TO_VICT    );
  act( "You remove $N from your group.", ch, NULL, victim, TO_CHAR    );
d2522 1
a2522 10
/*
    if ( ch->level - victim->level < -8
    ||   ch->level - victim->level >  8 )
    {
  act( "$N cannot join $n's group.",     ch, NULL, victim, TO_NOTVICT );
  act( "You cannot join $n's group.",    ch, NULL, victim, TO_VICT    );
  act( "$N cannot join your group.",     ch, NULL, victim, TO_CHAR    );
  return;
    }
*/
d2529 1
a2529 1
    act( "$N joins $n's group.", ch, NULL, victim, TO_NOTVICT );
d2531 2
a2532 2
    act( "You join $n's group.", ch, NULL, victim, TO_VICT    );
    act( "$N joins your group.", ch, NULL, victim, TO_CHAR    );
d2653 1
a2653 1
      act( "$N can't carry that much weight.", ch, NULL, gch, TO_CHAR );
d2659 1
a2659 1
      act( buf, ch, NULL, gch, TO_VICT );
@


1.74
log
@apply types and change affects to use them for scondary etc
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.73 2000/03/06 16:02:17 mud Exp $";
d47 1
a47 1
         !can_see(victim,ch) ||	
d1319 1
a1319 1
  sprintf(buf,"%s tells you ",PERS(ch,victim));
d1356 1
a1356 1
  sprintf(buf,"%s tells you ",PERS(ch,victim));                 
d1425 1
a1425 1
  sprintf(buf,"%s tells you ",PERS(ch,victim));
d1472 1
a1472 1
  sprintf(buf,"%s tells you ",PERS(ch,victim));
d2219 1
a2219 1
    if ( can_see( master, ch ) )
d2243 1
a2243 1
    if ( can_see( ch->master, ch ) && ch->in_room != NULL)
d2427 1
a2427 1
  sprintf( buf, "%s's group:\n\r", PERS(leader, ch) );
d2439 1
a2439 1
	capitalize( PERS(gch,ch) ),
d2448 1
a2448 1
        capitalize( PERS(gch, ch) ),
@


1.73
log
@misspelled true
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.72 2000/03/06 15:59:18 mud Exp $";
d293 1
a293 1
        affect_remove( ch, ch->affected,TRUE );
@


1.72
log
@adjust affects
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.71 2000/02/29 01:25:24 mud Exp $";
d293 1
a293 1
        affect_remove( ch, ch->affected,TURE );
@


1.71
log
@ added a has_group_mates function, so single non grouped crusaders
 do not get an extra attack unless gourped

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.70 2000/02/29 01:05:14 mud Exp $";
d293 1
a293 1
        affect_remove( ch, ch->affected );
@


1.70
log
@ crusader changes, 25% max instaead of 50% now
 sneak changes, removes bit unless thief or assassin
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.69 2000/02/20 07:50:33 mud Exp $";
d2734 29
a2775 4
/*
	if ( vch == ch )
		continue;
*/
d2778 2
a2779 1
                vch->in_room == ch->in_room  )
@


1.69
log
@ syntax error corrections
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.68 2000/02/20 07:45:13 mud Exp $";
d2752 3
a2754 1
		vch->class == class_lookup("crusader") )
@


1.68
log
@ FOUND the crash bug, can_carry_n and can_carry_w crashed teh game
 since it checked ch->pcdata for mobs....KABOOM
 Minister
 i removed my temp kludges in do_get and do_give and added some
 IS_NPC check before every logout_tracker
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.67 2000/02/04 02:18:41 mud Exp $";
d2073 1
a2073 1
    if ( !IS_NPC (ch))
@


1.67
log
@Pfresh code:
merc.h
save.c
act_comm.c
act_wiz.c
- logout_tracker code

comm.c
- everything inside the if MHS_PREFRESH
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.66 2000/02/03 00:51:32 mud Exp $";
d2073 2
d2077 1
@


1.66
log
@Fix an old cgos bug
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.65 2000/02/02 23:18:01 mud Exp $";
d2072 3
@


1.65
log
@remove unused variables buf and penalty from do_reclass
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.64 2000/02/01 02:55:31 mud Exp $";
d619 2
a621 1
      }
@


1.64
log
@clea up old reclassing style and canclan ability in loner
-POquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.63 2000/01/28 19:04:14 mud Exp $";
d140 1
d143 1
@


1.63
log
@adjust the cost of the defaults, and add all the new default packages
in.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.62 2000/01/10 23:40:06 mud Exp $";
d122 1
d128 1
d168 1
d185 1
d275 1
d284 3
a286 1
      ch->pcdata->points = pc_race_table[ch->race].points;
d310 1
d313 1
@


1.62
log
@Add a line to the char for skill points gained
and fix the double +prime and +sec for reclasses in act_comm.c
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.61 1999/12/15 00:56:52 mud Exp $";
d118 3
@


1.61
log
@Remove the Remort/Reclass wiping out hours Dont need it anymore with no hours code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.60 1999/11/05 08:19:10 mud Exp $";
d322 1
d325 1
@


1.60
log
@ Added brawler.
  Added some color to act_info.c and act_comm.c
  Added attack command to interp.c

  Ben
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.59 1999/10/31 02:23:18 mud Exp $";
d294 1
d297 1
@


1.59
log
@new remort 'mummy' with skill 'breathe'
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.58 1999/10/25 00:21:11 mud Exp $";
d51 1
a51 1
    sprintf(buf,"(%s@@%d) ",
d80 1
a80 1
      send_to_char("Delete status removed.\n\r",ch);
d87 1
a87 1
      wiznet("$N turns $Mself into line noise.",ch,NULL,0,0,0);
d101 1
a101 1
    send_to_char("WARNING: this command is irreversible.\n\r",ch);
d350 1
a350 1
	send_to_char("You will see color.\n\r",ch);
d358 1
a358 1
	send_to_char("You will no longer see color.\n\r",ch);
d375 1
a375 1
    send_to_char("   channel     status\n\r",ch);
d380 1
a380 1
      send_to_char("ON\n\r",ch);
d382 1
a382 1
      send_to_char("OFF\n\r",ch);
d386 1
a386 1
	send_to_char("ON\n\r",ch);
d388 1
a388 1
	send_to_char("OFF\n\r",ch);
d392 1
a392 1
      send_to_char("ON\n\r",ch);
d394 1
a394 1
      send_to_char("OFF\n\r",ch);
d398 1
a398 1
      send_to_char("ON\n\r",ch);
d400 1
a400 1
      send_to_char("OFF\n\r",ch);
d404 1
a404 1
      send_to_char("ON\n\r",ch);
d406 1
a406 1
      send_to_char("OFF\n\r",ch);
d410 1
a410 1
  send_to_char("ON\n\r",ch);
d412 1
a412 1
  send_to_char("OFF\n\r",ch);
d416 1
a416 1
      send_to_char("ON\n\r",ch);
d418 1
a418 1
      send_to_char("OFF\n\r",ch);
d424 1
a424 1
  send_to_char("ON\n\r",ch);
d426 1
a426 1
  send_to_char("OFF\n\r",ch);
d439 1
a439 1
  send_to_char("OFF\n\r",ch);
d441 1
a441 1
  send_to_char("ON\n\r",ch);
d445 1
a445 1
      send_to_char("ON\n\r",ch);
d447 1
a447 1
      send_to_char("OFF\n\r",ch);
d450 1
a450 1
  send_to_char("You are AFK.\n\r",ch);
d457 1
a457 1
	sprintf(buf,"You are ignoring %s.\n\r",ch->ignoring->name);
d536 1
d542 1
@


1.58
log
@Save - Load the save_race skills of a shapshifter not the race
Act_comm - allow shapeshifters to quit while shapeshifted again
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.57 1999/10/20 18:02:54 mud Exp $";
d244 1
@


1.57
log
@typoed msh = mhs
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.56 1999/10/20 18:00:20 mud Exp $";
d1957 1
d1963 1
d1990 1
d1993 1
a1993 1

@


1.56
log
@Tell the player they cant quit while shapeshifted, if they lose link, remove the shift
for them.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.55 1999/10/20 17:56:43 mud Exp $";
d1957 1
a1957 1
    if (IS_SET(ch->msh,MHS_SHAPESHIFTED) && (ch->race != ch->save_race))
@


1.55
log
@Remove Shapeshift on quit
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.54 1999/10/02 00:09:04 mud Exp $";
d1957 6
d1988 1
a1988 1
    if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
@


1.54
log
@New Shapeshifter Power - Shapemorph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.53 1999/08/23 03:34:38 mud Exp $";
d1981 3
@


1.53
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.52 1999/08/13 21:35:49 mud Exp $";
d190 1
a190 1
    if(IS_SET(ch->mhs,MHS_SHAPESHIFTED))
@


1.52
log
@Listen command
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.51 1999/07/14 18:13:24 mud Exp $";
d2001 1
@


1.51
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_comm.c,v 1.50 1999/06/20 20:29:17 mud Exp $";
d1095 1
a1095 1
           (is_same_clan(ch,victim)) &&
@


1.50
log
@Bladesinger
Battlerager
Done
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.49 1999/06/11 23:40:41 mud Exp $*/
@


1.49
log
@Added some savant stuff abck in, I wnat to give it a sedcond run
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.48 1999/05/19 18:25:44 mud Exp $*/
d2393 10
@


1.48
log
@G's species enemy change.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.47 1999/05/18 23:01:50 mud Exp $*/
a1036 80
void do_spy( CHAR_DATA *ch, char *argument )
{
    int clan, chance;
    CHAR_DATA *vch;
    bool found = FALSE;

    if ( IS_NPC(ch) )
	return;

    if ( get_skill(ch,gsn_espionage) < 2 )
    {
	send_to_char("You are not a good enough spy yet.\n\r",ch);
	return;
    }

    if ( argument[0] == '\0' )
    {
	do_help(ch,"espionage");
	return;
    }

    if ( !str_cmp(argument,"none") ||
	 !str_cmp(argument,"self") )
    {
	affect_strip(ch,gsn_espionage); 
	ch->pcdata->spying = -1;
	send_to_char("You cease your vigilence.\n\r",ch);
	return;
    }

    if ( ( clan = clan_lookup(argument) ) <= 0 )
    {
	send_to_char("No such clan.\n\r",ch);
	return;
    }

    if ( clan_table[clan].independent ||
	!clan_table[clan].true_clan )
    {
	send_to_char("Oh yeah ... real friggin exciting.\n\r",ch);
	return;
    }

    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room )
	if ( vch->clan == clan )
		found = TRUE;

    chance = get_skill(ch,gsn_espionage) / 4;
    if ( found ) chance *= 2;
    chance += get_curr_stat(ch,STAT_INT);

    if ( number_percent() < chance )
    {
	AFFECT_DATA af;
	char buf[MAX_STRING_LENGTH];

	af.where		= TO_AFFECTS;
	af.type			= gsn_espionage;
	af.duration		= ( found ? -1 : ch->level );
	af.location		= 0;
	af.modifier		= 0;
	af.level		= ch->level;
	af.bitvector		= 0;
	affect_to_char(ch,&af);

	ch->pcdata->spying = clan;

	sprintf(buf,"You are spying on %s].\n\r",
		clan_table[clan].who_name );
	send_to_char(buf,ch);
	check_improve(ch,gsn_espionage,TRUE,2);
	return;
    }
    else
    {
	send_to_char("You failed.\n\r",ch);
	check_improve(ch,gsn_espionage,FALSE,6);
	return;
    }
}
d1095 1
a1095 3
           (is_same_clan(ch,victim) ||
	     ( is_affected(victim,gsn_espionage) &&
	       victim->pcdata->spying == ch->clan ) ) &&
@


1.47
log
@Highlanders with more then 6 kills can see other highlanders enter and leave
game.
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.46 1999/05/18 23:00:41 mud Exp $*/
d257 1
@


1.46
log
@Highlanders with more then 3 Kills can see other Highlanders enter and leave
game.
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.45 1999/05/17 05:31:06 mud Exp $*/
d2111 1
a2111 1
	   (victm->highlander_data[ALL_KILLS] >= 3))
@


1.45
log
@Can not remort nor reclass while shapeshifted
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.44 1999/04/28 08:09:29 mud Exp $*/
d2097 18
@


1.44
log
@Last bit of Svant code before the big quest
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.43 1999/04/24 03:22:14 mud Exp $*/
d188 6
@


1.43
log
@Mattok clan channel fixed/added?
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.42 1999/04/23 23:43:35 mud Exp $*/
d742 1
a742 1
 
@


1.42
log
@Change all PLR_HIGHLANDER to MHS_HIGHLANDER and moved under MHS bit
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.41 1999/04/23 22:33:12 mud Exp $*/
d1126 1
a1126 1
    if ( clan_table[ch->clan].independent )
@


1.41
log
@Added Matook clan channel
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.40 1999/04/23 03:37:20 mud Exp $*/
d2501 1
a2501 1
    if (IS_SET(ch->act,PLR_HIGHLANDER) || IS_SET(victim->act,PLR_HIGHLANDER))
@


1.40
log
@Just added the spy kit, it was basicalyly done already anyway.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.39 1999/04/22 20:37:25 mud Exp $*/
d1120 1
a1120 1
    if (!is_clan(ch))
d1125 7
@


1.39
log
@Added some lines to do_replay -> MHS will now tell people if they have
no tells buffered.  I hope. :)
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.38 1999/04/16 16:17:05 mud Exp $*/
d1077 1
a1077 1
    chance = get_skill(ch,gsn_espionage) / 2;
@


1.38
log
@Yanked grouping range change, added anti "Pick on someone your own size."
spam if() checking for brief combat.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.37 1999/04/14 18:57:25 mud Exp $*/
d544 7
@


1.37
log
@Highlanders can not Group, Honorable Combat is one on one
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.36 1999/04/14 07:16:49 mud Exp $*/
d2455 6
@


1.36
log
@Add pass ch for raw_kill though only used for Highlanders check
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.35 1999/04/12 21:57:46 mud Exp $*/
d2479 6
@


1.35
log
@And can't group someone if already in combat.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.34 1999/03/24 21:12:38 mud Exp $*/
d306 1
a306 1
    raw_kill(ch);
@


1.34
log
@Fixed quit check for note
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.33 1999/03/24 20:02:36 mud Exp $*/
d2512 5
a2516 1

@


1.33
log
@Poquah - Added check in quit for note in progress
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.32 1999/01/11 19:23:11 mud Exp $*/
d2013 1
a2013 3
       sprintf(buf,"You have a note in progress, please post or clear the %s before quiting.\n\r",
       spool_table[d->character->pnote->type].name);
       send_to_char (buf,ch);
@


1.32
log
@Changes to take out cheap ways of escaping charm.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.31 1999/01/11 16:55:42 mud Exp $*/
d2009 10
@


1.31
log
@Added pose calcs for new reclasses and Elementalists.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.30 1998/12/16 20:42:37 mud Exp $*/
d2389 1
d2391 1
@


1.30
log
@i
Fix bug
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.29 1998/12/15 22:17:19 mud Exp $*/
d1950 7
@


1.29
log
@Spies/Wrymslayers
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.28 1998/12/13 03:05:34 mud Exp $*/
a258 2
  /* add cost */
  ch->pcdata->points = pc_race_table[ch->race].points;
d262 1
a262 1
  ch->pcdata->points += UMAX(0, (int) (80 - ch->pcdata->points) / 4);
d265 1
d267 2
@


1.28
log
@Bugs!
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.27 1998/12/09 08:32:14 mud Exp $*/
d1022 81
d1145 4
d1153 3
a1155 1
           (is_same_clan(ch,d->character)) &&
d1160 6
@


1.27
log
@Re-reclassing.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.26 1998/12/07 12:58:15 mud Exp $*/
d1868 1
a1868 1

d1875 1
@


1.26
log
@Save code for kitds
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.25 1998/12/02 09:06:35 mud Exp $*/
d38 3
d117 7
a123 1
    int gn,sn,i,class;
d190 7
d225 8
d250 1
d260 5
a264 1
  ch->pcdata->points = UMAX(0, (int) (80 - ch->pcdata->points) / 4);
d267 1
a268 1
  ch->pcdata->points += pc_race_table[ch->race].points;
d308 2
a309 1
		 "class.\n\r.",ch);
d313 4
@


1.25
log
@Fixed reclass bug and 'aid' bug
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.24 1998/11/29 22:26:18 mud Exp $*/
d263 1
@


1.24
log
@Neat crusader stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.23 1998/11/22 08:21:09 mud Exp $*/
d163 1
a163 1
		penalty + (int) (80-ch->pcdata->points) /4 );
@


1.23
log
@MOre stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.22 1998/11/22 00:04:29 mud Exp $*/
d2561 25
@


1.22
log
@Added Wizard/Crusader/Rogue/Blademaster
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.21 1998/11/19 09:05:59 mud Exp $*/
d129 6
d138 3
d142 1
a142 1
	       class_table[i].allowed[0] == ch->class )
d155 1
a155 1
                    (int) (80-ch->pcdata->points) / 4 );
d159 1
a159 1
	sprintf(buf,"Level Offset:           %2d\n\r", penalty);
@


1.21
log
@added color
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.20 1998/11/14 07:15:48 mud Exp $*/
d128 18
a145 2
	
	sprintf(buf, "Creation Point Offset: %2d\n\r",  
d176 15
@


1.20
log
@Finished the damn reclass changed finally.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.19 1998/10/17 07:12:09 mud Exp $*/
d511 1
a511 1
      sprintf( buf, "You clan gossip '%s'\n\r", argument );
d527 1
a527 1
      act_new("$n clan gossips '$t'",
d573 1
a573 1
      sprintf( buf, "You gossip '%s'\n\r", argument );
d588 1
a588 1
    act_new( "$n gossips '$t'", 
d633 1
a633 1
      sprintf( buf, "You OOC '%s'\n\r", argument );
d648 1
a648 1
    act_new( "$n OOC's '$t'",
d690 1
a690 1
      sprintf( buf, "You grats '%s'\n\r", argument );
d705 1
a705 1
    act_new( "$n grats '$t'",
d810 1
a810 1
      sprintf( buf, "You question '%s'\n\r", argument );
d825 1
a825 1
    act_new("$n questions '$t'",
d867 1
a867 1
      sprintf( buf, "You answer '%s'\n\r", argument );
d882 1
a882 1
    act_new("$n answers '$t'",
d984 1
a984 1
      sprintf( buf, "You clan '%s'\n\r", argument );
d986 1
a986 1
      sprintf( buf, "$n clans '%s'", argument );
d999 1
a999 1
      act_new("$n clans '$t'",ch,argument,d->character,TO_VICT,POS_DEAD);
@


1.19
log
@New reclass stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.18 1998/10/13 05:55:58 mud Exp $*/
a221 2
        sprintf(log_buf,"Clann = %d", (int)IS_SET(ch->act,PLR_CANCLAN) );
    log_string(log_buf);
d240 2
@


1.18
log
@Format fixing or reclass check
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.17 1998/10/13 05:50:19 mud Exp $*/
d149 1
d151 2
d154 1
d169 1
@


1.17
log
@Format changes
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.16 1998/10/13 00:02:58 mud Exp $*/
d129 1
a129 1
	sprintf(buf,"Creation Point Offset:  %d\n\r",
d134 1
a134 1
	sprintf(buf,"Level Offset:           %d\n\r", penalty);
d137 1
a137 1
        sprintf(buf, "Total Penalty:         %d\n\r",
@


1.16
log
@Garou berserk change
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.15 1998/10/12 21:04:43 mud Exp $*/
d128 5
a132 3

	penalty = UMAX(0, (int) (80-ch->pcdata->points) / 4 );
	penalty += UMAX(0, (int) (51-ch->level) / 3 );
d134 5
a138 3

	sprintf(buf,"Reclassing now would invoke a %d cp penalty.\n\r",
		penalty);
d143 2
a144 1

@


1.15
log
@working on a bug
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.14 1998/10/12 19:49:12 mud Exp $*/
d131 1
d186 3
a188 1
  ch->pcdata->points = UMAX(0, (int) (51  - ch->level) / 3 );
@


1.14
log
@a
REclass changes.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.13 1998/10/11 20:46:00 mud Exp $*/
d209 2
@


1.13
log
@Fixed reclass bug with speciaqlization.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.12 1998/10/06 23:32:01 mud Exp $*/
d119 2
a120 1
        send_to_char("You must specify a class.\n\r",ch);
d124 18
d145 1
d153 3
a155 2
    if( ch->level != 51 )    {
	send_to_char("You must be level 51 to reclass.\n\r",ch);
d185 1
d207 2
@


1.12
log
@Made it so quitting in no_transport areas doesn't take you to hassan
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.11 1998/10/01 22:23:11 mud Exp $*/
d151 3
@


1.11
log
@C fixed bugs in tells
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.10 1998/10/01 05:32:07 mud Exp $*/
d1828 2
a1829 1
	&& !IS_AFFECTED(ch,AFF_CURSE)) 
@


1.10
log
@Changes to sleep and experience
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.9 1998/09/29 18:51:38 mud Exp $*/
d1157 1
d1163 1
a1163 1
  
@


1.9
log
@swapped ch->display for victim->display in wizi info
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.8 1998/08/30 03:33:31 mud Exp $*/
d1116 6
d1262 1
d1268 1
a1268 1

d1277 1
d1279 3
a1281 1
    {
@


1.8
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.7 1998/08/21 14:21:06 mud Exp $*/
d51 1
a51 1
	  (IS_SET(ch->display,DISP_BRIEF_WHOLIST)?"I":"Incog"),
@


1.7
log
@I dunno
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.6 1998/08/20 21:05:24 mud Exp $*/
d50 2
a51 2
	  (IS_SET(victim->comm,COMM_BRIEF)?"W":"Wizi") : 
	  (IS_SET(ch->comm,COMM_BRIEF)?"I":"Incog"),
d222 2
a223 2
	if(!IS_SET(ch->act,PLR_COLOR))
	    SET_BIT(ch->act,PLR_COLOR);
d230 2
a231 2
	if(IS_SET(ch->act,PLR_COLOR))
	    REMOVE_BIT(ch->act,PLR_COLOR);
d1139 1
a1139 1
  if(IS_SET(victim->act,PLR_COLOR))
d1144 1
a1144 1
  if(IS_SET(victim->act,PLR_COLOR))
d1175 1
a1175 1
  if(IS_SET(victim->act,PLR_COLOR))
d1180 1
a1180 1
  if(IS_SET(victim->act,PLR_COLOR))
d1189 1
a1189 1
      if(IS_SET(victim->act,PLR_COLOR))
d1197 1
a1197 1
      if(IS_SET(victim->act,PLR_COLOR))
d1244 1
a1244 1
  if(IS_SET(victim->act,PLR_COLOR))
d1249 1
a1249 1
  if(IS_SET(victim->act,PLR_COLOR))
d1287 1
a1287 1
  if(IS_SET(victim->act,PLR_COLOR))
d1292 1
a1292 1
  if(IS_SET(victim->act,PLR_COLOR))
d1302 1
a1302 1
      if(IS_SET(victim->act,PLR_COLOR))
d1310 1
a1310 1
      if(IS_SET(victim->act,PLR_COLOR))
d2441 1
a2441 1
	if(IS_SET(gch->act,PLR_COLOR))	
@


1.6
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.5 1998/08/10 19:41:18 mud Exp $*/
d182 1
a182 1
    ch->pcdata->clan = 0;
@


1.5
log
@* Starter code for 'feign death'
* Protection neutral added
* Fixed bug with vampires
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.4 1998/08/10 05:32:13 mud Exp $*/
d38 20
d182 3
a184 3
    ch->clan = 0;
    ch->rank = 0;
    ch->sac = 0;
d484 1
d545 1
d605 1
d662 1
d722 1
d782 1
d839 1
d897 1
d956 1
d994 1
d1820 1
a1820 1
		deity_table[ch->deity].pname);
@


1.4
log
@* Added wound transfer spell
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.3 1998/08/10 00:08:22 mud Exp $*/
d1920 7
d1936 1
a1936 1
       if ( gch->leader == master &&
d1942 1
@


1.3
log
@* Some new wiznet stuff, changes to warp, mundane adjustments
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.2 1998/08/05 09:14:30 mud Exp $*/
a1902 1

d1905 2
d1912 28
@


1.2
log
@* Removes shout, added a 'silence' command to stiffle game spam
* Added saves to score
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_comm.c,v 1.1 1998/06/16 17:49:12 mud Exp $*/
d336 2
a337 2
    if (IS_SET(ch->comm,COMM_NOSHOUT))
      send_to_char("You cannot shout.\n\r",ch);
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$*/
d283 1
d289 1
d988 2
d991 15
d1054 1
a1054 1

@
