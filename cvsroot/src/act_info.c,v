head	1.423;
access;
symbols;
locks; strict;
comment	@ * @;


1.423
date	2004.04.02.04.42.07;	author boogums;	state Exp;
branches;
next	1.422;

1.422
date	2004.04.01.08.06.20;	author ndagger;	state Exp;
branches;
next	1.421;

1.421
date	2003.12.13.14.36.46;	author boogums;	state Exp;
branches;
next	1.420;

1.420
date	2003.12.10.03.15.59;	author boogums;	state Exp;
branches;
next	1.419;

1.419
date	2003.11.29.23.31.32;	author boogums;	state Exp;
branches;
next	1.418;

1.418
date	2003.11.29.21.43.29;	author boogums;	state Exp;
branches;
next	1.417;

1.417
date	2003.11.29.16.21.11;	author boogums;	state Exp;
branches;
next	1.416;

1.416
date	2003.11.29.02.06.11;	author boogums;	state Exp;
branches;
next	1.415;

1.415
date	2003.11.29.01.29.02;	author boogums;	state Exp;
branches;
next	1.414;

1.414
date	2003.08.30.21.53.53;	author boogums;	state Exp;
branches;
next	1.413;

1.413
date	2003.08.17.19.36.47;	author boogums;	state Exp;
branches;
next	1.412;

1.412
date	2003.08.17.19.29.35;	author boogums;	state Exp;
branches;
next	1.411;

1.411
date	2003.08.17.18.26.09;	author boogums;	state Exp;
branches;
next	1.410;

1.410
date	2003.08.17.18.22.03;	author boogums;	state Exp;
branches;
next	1.409;

1.409
date	2003.08.17.18.18.56;	author boogums;	state Exp;
branches;
next	1.408;

1.408
date	2003.08.17.18.11.14;	author boogums;	state Exp;
branches;
next	1.407;

1.407
date	2003.05.30.02.23.04;	author ndagger;	state Exp;
branches;
next	1.406;

1.406
date	2003.05.29.17.45.34;	author boogums;	state Exp;
branches;
next	1.405;

1.405
date	2003.04.25.05.15.38;	author ndagger;	state Exp;
branches;
next	1.404;

1.404
date	2003.02.22.05.04.50;	author boogums;	state Exp;
branches;
next	1.403;

1.403
date	2003.01.28.18.50.36;	author rusty;	state Exp;
branches;
next	1.402;

1.402
date	2003.01.03.19.41.51;	author boogums;	state Exp;
branches;
next	1.401;

1.401
date	2003.01.03.06.32.05;	author mud;	state Exp;
branches;
next	1.400;

1.400
date	2003.01.03.06.24.12;	author rusty;	state Exp;
branches;
next	1.399;

1.399
date	2003.01.01.17.15.10;	author mud;	state Exp;
branches;
next	1.398;

1.398
date	2003.01.01.17.04.26;	author rusty;	state Exp;
branches;
next	1.397;

1.397
date	2002.12.23.03.16.24;	author ndagger;	state Exp;
branches;
next	1.396;

1.396
date	2002.12.23.00.37.27;	author boogums;	state Exp;
branches;
next	1.395;

1.395
date	2002.12.09.18.47.35;	author boogums;	state Exp;
branches;
next	1.394;

1.394
date	2002.12.02.23.06.35;	author boogums;	state Exp;
branches;
next	1.393;

1.393
date	2002.12.02.05.35.58;	author boogums;	state Exp;
branches;
next	1.392;

1.392
date	2002.12.02.05.24.17;	author boogums;	state Exp;
branches;
next	1.391;

1.391
date	2002.12.01.06.08.19;	author boogums;	state Exp;
branches;
next	1.390;

1.390
date	2002.12.01.05.53.38;	author boogums;	state Exp;
branches;
next	1.389;

1.389
date	2002.12.01.05.49.30;	author boogums;	state Exp;
branches;
next	1.388;

1.388
date	2002.12.01.05.37.46;	author boogums;	state Exp;
branches;
next	1.387;

1.387
date	2002.10.26.03.09.46;	author ndagger;	state Exp;
branches;
next	1.386;

1.386
date	2002.10.14.06.13.32;	author ndagger;	state Exp;
branches;
next	1.385;

1.385
date	2002.10.14.06.09.34;	author ndagger;	state Exp;
branches;
next	1.384;

1.384
date	2002.10.14.05.58.18;	author ndagger;	state Exp;
branches;
next	1.383;

1.383
date	2002.10.14.05.49.08;	author ndagger;	state Exp;
branches;
next	1.382;

1.382
date	2002.10.14.05.21.23;	author ndagger;	state Exp;
branches;
next	1.381;

1.381
date	2002.06.14.19.33.26;	author rusty;	state Exp;
branches;
next	1.380;

1.380
date	2002.03.12.15.55.23;	author rusty;	state Exp;
branches;
next	1.379;

1.379
date	2002.03.11.07.44.04;	author rusty;	state Exp;
branches;
next	1.378;

1.378
date	2002.03.11.02.48.08;	author rusty;	state Exp;
branches;
next	1.377;

1.377
date	2002.03.11.02.23.57;	author rusty;	state Exp;
branches;
next	1.376;

1.376
date	2002.03.10.22.48.18;	author rusty;	state Exp;
branches;
next	1.375;

1.375
date	2002.03.10.22.39.08;	author rusty;	state Exp;
branches;
next	1.374;

1.374
date	2002.03.10.22.37.04;	author rusty;	state Exp;
branches;
next	1.373;

1.373
date	2002.03.09.20.16.02;	author mud;	state Exp;
branches;
next	1.372;

1.372
date	2002.03.09.20.02.13;	author rusty;	state Exp;
branches;
next	1.371;

1.371
date	2002.03.09.19.55.58;	author rusty;	state Exp;
branches;
next	1.370;

1.370
date	2002.03.09.19.14.26;	author rusty;	state Exp;
branches;
next	1.369;

1.369
date	2002.02.25.19.49.39;	author poquah;	state Exp;
branches;
next	1.368;

1.368
date	2002.02.11.19.38.22;	author poquah;	state Exp;
branches;
next	1.367;

1.367
date	2001.12.07.16.57.42;	author poquah;	state Exp;
branches;
next	1.366;

1.366
date	2001.12.05.17.07.03;	author poquah;	state Exp;
branches;
next	1.365;

1.365
date	2001.12.05.16.40.15;	author poquah;	state Exp;
branches;
next	1.364;

1.364
date	2001.12.05.16.39.00;	author poquah;	state Exp;
branches;
next	1.363;

1.363
date	2001.12.04.17.54.51;	author rage;	state Exp;
branches;
next	1.362;

1.362
date	2001.11.30.15.43.50;	author poquah;	state Exp;
branches;
next	1.361;

1.361
date	2001.11.29.17.24.10;	author poquah;	state Exp;
branches;
next	1.360;

1.360
date	2001.11.29.17.11.23;	author poquah;	state Exp;
branches;
next	1.359;

1.359
date	2001.11.29.17.05.23;	author poquah;	state Exp;
branches;
next	1.358;

1.358
date	2001.11.29.17.03.35;	author poquah;	state Exp;
branches;
next	1.357;

1.357
date	2001.11.29.16.58.54;	author poquah;	state Exp;
branches;
next	1.356;

1.356
date	2001.11.29.16.55.24;	author poquah;	state Exp;
branches;
next	1.355;

1.355
date	2001.11.29.16.51.46;	author poquah;	state Exp;
branches;
next	1.354;

1.354
date	2001.11.29.16.48.39;	author poquah;	state Exp;
branches;
next	1.353;

1.353
date	2001.11.29.16.42.32;	author poquah;	state Exp;
branches;
next	1.352;

1.352
date	2001.11.29.16.41.12;	author poquah;	state Exp;
branches;
next	1.351;

1.351
date	2001.11.29.16.27.56;	author poquah;	state Exp;
branches;
next	1.350;

1.350
date	2001.11.29.16.18.07;	author poquah;	state Exp;
branches;
next	1.349;

1.349
date	2001.11.29.16.12.57;	author poquah;	state Exp;
branches;
next	1.348;

1.348
date	2001.11.29.14.28.38;	author poquah;	state Exp;
branches;
next	1.347;

1.347
date	2001.11.29.09.53.40;	author poquah;	state Exp;
branches;
next	1.346;

1.346
date	2001.11.29.09.47.27;	author poquah;	state Exp;
branches;
next	1.345;

1.345
date	2001.11.29.09.38.58;	author poquah;	state Exp;
branches;
next	1.344;

1.344
date	2001.11.29.09.34.08;	author poquah;	state Exp;
branches;
next	1.343;

1.343
date	2001.11.29.09.32.57;	author poquah;	state Exp;
branches;
next	1.342;

1.342
date	2001.11.29.09.30.52;	author poquah;	state Exp;
branches;
next	1.341;

1.341
date	2001.11.29.09.23.01;	author poquah;	state Exp;
branches;
next	1.340;

1.340
date	2001.11.25.05.14.41;	author poquah;	state Exp;
branches;
next	1.339;

1.339
date	2001.11.23.16.17.14;	author poquah;	state Exp;
branches;
next	1.338;

1.338
date	2001.11.15.03.10.32;	author poquah;	state Exp;
branches;
next	1.337;

1.337
date	2001.11.13.22.28.07;	author poquah;	state Exp;
branches;
next	1.336;

1.336
date	2001.11.06.20.03.15;	author poquah;	state Exp;
branches;
next	1.335;

1.335
date	2001.09.11.06.37.37;	author poquah;	state Exp;
branches;
next	1.334;

1.334
date	2001.08.30.01.03.22;	author guerrand;	state Exp;
branches;
next	1.333;

1.333
date	2001.08.20.02.57.48;	author poquah;	state Exp;
branches;
next	1.332;

1.332
date	2001.08.14.03.10.38;	author guerrand;	state Exp;
branches;
next	1.331;

1.331
date	2001.08.08.05.45.50;	author poquah;	state Exp;
branches;
next	1.330;

1.330
date	2001.08.01.04.47.47;	author boogums;	state Exp;
branches;
next	1.329;

1.329
date	2001.07.29.17.36.06;	author rusty;	state Exp;
branches;
next	1.328;

1.328
date	2001.07.05.00.51.23;	author poquah;	state Exp;
branches;
next	1.327;

1.327
date	2001.07.05.00.48.24;	author poquah;	state Exp;
branches;
next	1.326;

1.326
date	2001.07.05.00.39.31;	author poquah;	state Exp;
branches;
next	1.325;

1.325
date	2001.07.05.00.34.29;	author poquah;	state Exp;
branches;
next	1.324;

1.324
date	2001.07.02.21.36.08;	author rage;	state Exp;
branches;
next	1.323;

1.323
date	2001.06.24.06.32.07;	author guerrand;	state Exp;
branches;
next	1.322;

1.322
date	2001.06.24.04.14.57;	author guerrand;	state Exp;
branches;
next	1.321;

1.321
date	2001.06.19.05.32.08;	author guerrand;	state Exp;
branches;
next	1.320;

1.320
date	2001.06.19.05.14.14;	author guerrand;	state Exp;
branches;
next	1.319;

1.319
date	2001.06.18.01.17.31;	author rage;	state Exp;
branches;
next	1.318;

1.318
date	2001.06.15.02.41.00;	author guerrand;	state Exp;
branches;
next	1.317;

1.317
date	2001.06.15.02.27.50;	author guerrand;	state Exp;
branches;
next	1.316;

1.316
date	2001.06.10.21.45.44;	author guerrand;	state Exp;
branches;
next	1.315;

1.315
date	2001.06.10.05.19.39;	author guerrand;	state Exp;
branches;
next	1.314;

1.314
date	2001.06.10.04.15.54;	author guerrand;	state Exp;
branches;
next	1.313;

1.313
date	2001.06.10.04.12.04;	author guerrand;	state Exp;
branches;
next	1.312;

1.312
date	2001.06.10.04.02.46;	author guerrand;	state Exp;
branches;
next	1.311;

1.311
date	2001.06.10.03.57.07;	author guerrand;	state Exp;
branches;
next	1.310;

1.310
date	2001.06.10.03.53.08;	author guerrand;	state Exp;
branches;
next	1.309;

1.309
date	2001.06.10.03.29.32;	author guerrand;	state Exp;
branches;
next	1.308;

1.308
date	2001.06.09.18.53.47;	author guerrand;	state Exp;
branches;
next	1.307;

1.307
date	2001.06.09.17.42.40;	author guerrand;	state Exp;
branches;
next	1.306;

1.306
date	2001.06.09.03.56.59;	author guerrand;	state Exp;
branches;
next	1.305;

1.305
date	2001.06.03.23.20.06;	author guerrand;	state Exp;
branches;
next	1.304;

1.304
date	2001.06.01.02.17.19;	author guerrand;	state Exp;
branches;
next	1.303;

1.303
date	2001.04.09.21.37.50;	author mud;	state Exp;
branches;
next	1.302;

1.302
date	2001.04.09.21.36.05;	author mud;	state Exp;
branches;
next	1.301;

1.301
date	2001.03.04.19.17.10;	author mud;	state Exp;
branches;
next	1.300;

1.300
date	2001.03.03.19.02.56;	author mud;	state Exp;
branches;
next	1.299;

1.299
date	2001.02.27.18.35.29;	author mud;	state Exp;
branches;
next	1.298;

1.298
date	2001.02.27.18.33.10;	author mud;	state Exp;
branches;
next	1.297;

1.297
date	2001.02.13.20.35.50;	author mud;	state Exp;
branches;
next	1.296;

1.296
date	2001.02.13.20.29.11;	author mud;	state Exp;
branches;
next	1.295;

1.295
date	2000.12.14.03.50.27;	author mud;	state Exp;
branches;
next	1.294;

1.294
date	2000.12.09.07.05.45;	author mud;	state Exp;
branches;
next	1.293;

1.293
date	2000.12.07.06.45.42;	author mud;	state Exp;
branches;
next	1.292;

1.292
date	2000.12.07.05.46.07;	author mud;	state Exp;
branches;
next	1.291;

1.291
date	2000.12.03.03.23.58;	author mud;	state Exp;
branches;
next	1.290;

1.290
date	2000.10.23.22.10.16;	author mud;	state Exp;
branches;
next	1.289;

1.289
date	2000.10.23.22.07.53;	author mud;	state Exp;
branches;
next	1.288;

1.288
date	2000.10.23.22.05.54;	author mud;	state Exp;
branches;
next	1.287;

1.287
date	2000.10.18.23.16.58;	author mud;	state Exp;
branches;
next	1.286;

1.286
date	2000.10.18.23.14.10;	author mud;	state Exp;
branches;
next	1.285;

1.285
date	2000.10.18.23.10.27;	author mud;	state Exp;
branches;
next	1.284;

1.284
date	2000.10.18.23.09.12;	author mud;	state Exp;
branches;
next	1.283;

1.283
date	2000.10.18.23.07.55;	author mud;	state Exp;
branches;
next	1.282;

1.282
date	2000.10.18.22.42.30;	author mud;	state Exp;
branches;
next	1.281;

1.281
date	2000.10.18.22.03.26;	author mud;	state Exp;
branches;
next	1.280;

1.280
date	2000.10.17.23.09.14;	author mud;	state Exp;
branches;
next	1.279;

1.279
date	2000.10.17.23.01.26;	author mud;	state Exp;
branches;
next	1.278;

1.278
date	2000.10.17.22.45.32;	author mud;	state Exp;
branches;
next	1.277;

1.277
date	2000.10.16.21.51.34;	author mud;	state Exp;
branches;
next	1.276;

1.276
date	2000.10.16.21.49.15;	author mud;	state Exp;
branches;
next	1.275;

1.275
date	2000.10.16.00.48.51;	author mud;	state Exp;
branches;
next	1.274;

1.274
date	2000.10.16.00.36.32;	author mud;	state Exp;
branches;
next	1.273;

1.273
date	2000.09.13.14.01.47;	author mud;	state Exp;
branches;
next	1.272;

1.272
date	2000.08.29.15.56.12;	author mud;	state Exp;
branches;
next	1.271;

1.271
date	2000.08.29.15.47.44;	author mud;	state Exp;
branches;
next	1.270;

1.270
date	2000.08.23.14.50.03;	author mud;	state Exp;
branches;
next	1.269;

1.269
date	2000.08.23.14.06.53;	author mud;	state Exp;
branches;
next	1.268;

1.268
date	2000.08.23.13.38.02;	author mud;	state Exp;
branches;
next	1.267;

1.267
date	2000.08.23.13.26.23;	author mud;	state Exp;
branches;
next	1.266;

1.266
date	2000.08.18.23.52.32;	author mud;	state Exp;
branches;
next	1.265;

1.265
date	2000.07.25.16.38.12;	author mud;	state Exp;
branches;
next	1.264;

1.264
date	2000.07.25.12.58.15;	author mud;	state Exp;
branches;
next	1.263;

1.263
date	2000.07.25.00.58.07;	author mud;	state Exp;
branches;
next	1.262;

1.262
date	2000.07.25.00.48.45;	author mud;	state Exp;
branches;
next	1.261;

1.261
date	2000.07.25.00.21.53;	author mud;	state Exp;
branches;
next	1.260;

1.260
date	2000.07.24.22.55.43;	author mud;	state Exp;
branches;
next	1.259;

1.259
date	2000.07.24.15.50.06;	author mud;	state Exp;
branches;
next	1.258;

1.258
date	2000.07.22.21.27.21;	author mud;	state Exp;
branches;
next	1.257;

1.257
date	2000.07.21.19.49.14;	author mud;	state Exp;
branches;
next	1.256;

1.256
date	2000.07.21.00.48.53;	author mud;	state Exp;
branches;
next	1.255;

1.255
date	2000.07.18.18.48.43;	author mud;	state Exp;
branches;
next	1.254;

1.254
date	2000.07.14.16.50.37;	author mud;	state Exp;
branches;
next	1.253;

1.253
date	2000.07.13.20.02.18;	author mud;	state Exp;
branches;
next	1.252;

1.252
date	2000.07.13.02.33.11;	author mud;	state Exp;
branches;
next	1.251;

1.251
date	2000.07.13.01.25.19;	author mud;	state Exp;
branches;
next	1.250;

1.250
date	2000.07.13.00.51.57;	author mud;	state Exp;
branches;
next	1.249;

1.249
date	2000.07.13.00.45.49;	author mud;	state Exp;
branches;
next	1.248;

1.248
date	2000.07.13.00.43.57;	author mud;	state Exp;
branches;
next	1.247;

1.247
date	2000.07.13.00.31.38;	author mud;	state Exp;
branches;
next	1.246;

1.246
date	2000.07.12.23.56.23;	author mud;	state Exp;
branches;
next	1.245;

1.245
date	2000.07.12.22.22.13;	author mud;	state Exp;
branches;
next	1.244;

1.244
date	2000.07.12.15.12.16;	author mud;	state Exp;
branches;
next	1.243;

1.243
date	2000.07.06.15.35.55;	author mud;	state Exp;
branches;
next	1.242;

1.242
date	2000.06.26.04.35.25;	author mud;	state Exp;
branches;
next	1.241;

1.241
date	2000.06.26.04.34.33;	author mud;	state Exp;
branches;
next	1.240;

1.240
date	2000.06.26.04.31.49;	author mud;	state Exp;
branches;
next	1.239;

1.239
date	2000.06.25.23.23.41;	author mud;	state Exp;
branches;
next	1.238;

1.238
date	2000.05.30.22.19.27;	author mud;	state Exp;
branches;
next	1.237;

1.237
date	2000.05.30.22.15.22;	author mud;	state Exp;
branches;
next	1.236;

1.236
date	2000.05.30.21.32.22;	author mud;	state Exp;
branches;
next	1.235;

1.235
date	2000.05.30.21.12.51;	author mud;	state Exp;
branches;
next	1.234;

1.234
date	2000.05.30.00.57.32;	author mud;	state Exp;
branches;
next	1.233;

1.233
date	2000.05.30.00.26.38;	author mud;	state Exp;
branches;
next	1.232;

1.232
date	2000.05.29.19.40.50;	author mud;	state Exp;
branches;
next	1.231;

1.231
date	2000.05.29.19.37.00;	author mud;	state Exp;
branches;
next	1.230;

1.230
date	2000.05.27.03.12.10;	author mud;	state Exp;
branches;
next	1.229;

1.229
date	2000.05.27.02.44.07;	author mud;	state Exp;
branches;
next	1.228;

1.228
date	2000.05.25.01.34.03;	author mud;	state Exp;
branches;
next	1.227;

1.227
date	2000.05.21.00.28.52;	author mud;	state Exp;
branches;
next	1.226;

1.226
date	2000.05.20.02.29.27;	author mud;	state Exp;
branches;
next	1.225;

1.225
date	2000.05.20.01.38.41;	author mud;	state Exp;
branches;
next	1.224;

1.224
date	2000.05.20.01.27.27;	author mud;	state Exp;
branches;
next	1.223;

1.223
date	2000.05.20.01.12.19;	author mud;	state Exp;
branches;
next	1.222;

1.222
date	2000.05.20.00.14.53;	author mud;	state Exp;
branches;
next	1.221;

1.221
date	2000.05.19.23.57.22;	author mud;	state Exp;
branches;
next	1.220;

1.220
date	2000.05.19.23.56.02;	author mud;	state Exp;
branches;
next	1.219;

1.219
date	2000.05.19.23.50.18;	author mud;	state Exp;
branches;
next	1.218;

1.218
date	2000.05.19.23.08.20;	author mud;	state Exp;
branches;
next	1.217;

1.217
date	2000.05.19.22.59.06;	author mud;	state Exp;
branches;
next	1.216;

1.216
date	2000.05.19.22.53.51;	author mud;	state Exp;
branches;
next	1.215;

1.215
date	2000.05.19.22.37.11;	author mud;	state Exp;
branches;
next	1.214;

1.214
date	2000.05.19.22.33.39;	author mud;	state Exp;
branches;
next	1.213;

1.213
date	2000.05.19.22.29.16;	author mud;	state Exp;
branches;
next	1.212;

1.212
date	2000.05.19.22.24.27;	author mud;	state Exp;
branches;
next	1.211;

1.211
date	2000.05.19.22.18.25;	author mud;	state Exp;
branches;
next	1.210;

1.210
date	2000.05.18.00.15.46;	author mud;	state Exp;
branches;
next	1.209;

1.209
date	2000.05.16.00.55.57;	author mud;	state Exp;
branches;
next	1.208;

1.208
date	2000.05.13.21.55.08;	author mud;	state Exp;
branches;
next	1.207;

1.207
date	2000.04.18.19.50.50;	author mud;	state Exp;
branches;
next	1.206;

1.206
date	2000.04.17.22.02.59;	author mud;	state Exp;
branches;
next	1.205;

1.205
date	2000.04.17.22.00.43;	author mud;	state Exp;
branches;
next	1.204;

1.204
date	2000.04.06.23.38.23;	author mud;	state Exp;
branches;
next	1.203;

1.203
date	2000.04.06.23.37.11;	author mud;	state Exp;
branches;
next	1.202;

1.202
date	2000.04.06.23.35.06;	author mud;	state Exp;
branches;
next	1.201;

1.201
date	2000.03.20.23.10.50;	author mud;	state Exp;
branches;
next	1.200;

1.200
date	2000.03.13.18.14.00;	author mud;	state Exp;
branches;
next	1.199;

1.199
date	2000.03.13.17.58.18;	author mud;	state Exp;
branches;
next	1.198;

1.198
date	2000.03.12.00.35.44;	author mud;	state Exp;
branches;
next	1.197;

1.197
date	2000.03.12.00.32.39;	author mud;	state Exp;
branches;
next	1.196;

1.196
date	2000.03.10.22.02.46;	author mud;	state Exp;
branches;
next	1.195;

1.195
date	2000.03.06.00.23.35;	author mud;	state Exp;
branches;
next	1.194;

1.194
date	2000.03.05.17.36.19;	author mud;	state Exp;
branches;
next	1.193;

1.193
date	2000.02.26.22.55.50;	author mud;	state Exp;
branches;
next	1.192;

1.192
date	2000.02.25.22.40.48;	author mud;	state Exp;
branches;
next	1.191;

1.191
date	2000.02.25.21.40.39;	author mud;	state Exp;
branches;
next	1.190;

1.190
date	2000.02.25.00.00.47;	author mud;	state Exp;
branches;
next	1.189;

1.189
date	2000.02.20.06.16.54;	author mud;	state Exp;
branches;
next	1.188;

1.188
date	2000.02.20.03.46.52;	author mud;	state Exp;
branches;
next	1.187;

1.187
date	2000.02.16.07.08.06;	author mud;	state Exp;
branches;
next	1.186;

1.186
date	2000.02.15.20.04.22;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	2000.02.09.21.47.20;	author mud;	state Exp;
branches;
next	1.184;

1.184
date	2000.02.09.21.38.19;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2000.02.09.21.36.24;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	2000.02.09.18.28.38;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	2000.02.09.18.23.38;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	2000.02.09.18.07.20;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	2000.02.09.18.05.46;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	2000.02.09.18.03.46;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	2000.02.09.17.54.28;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	2000.02.09.17.20.21;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	2000.02.09.17.17.12;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	2000.02.09.17.13.07;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	2000.02.09.17.10.53;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	2000.02.09.17.08.59;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	2000.02.09.17.02.28;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	2000.02.09.01.39.58;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	2000.02.09.01.34.04;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	2000.02.09.01.23.35;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	2000.02.09.00.55.55;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	2000.02.09.00.46.51;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	2000.02.08.23.49.00;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	2000.02.08.23.07.34;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	2000.02.08.23.05.41;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	2000.01.25.01.17.36;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	2000.01.25.01.11.22;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	99.12.17.23.13.39;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	99.12.17.00.02.12;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	99.11.05.08.19.11;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	99.10.31.02.23.19;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	99.10.18.05.42.39;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	99.10.17.23.22.48;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	99.10.17.22.56.41;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	99.10.15.22.40.53;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	99.10.15.01.17.28;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	99.10.15.00.48.30;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	99.10.10.17.20.51;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	99.10.08.20.45.55;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	99.10.02.02.16.41;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	99.10.01.18.46.31;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	99.10.01.18.36.34;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	99.09.30.17.28.20;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	99.09.30.17.26.04;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	99.09.30.17.09.07;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	99.09.30.17.03.39;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	99.09.30.05.12.32;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	99.09.30.04.22.58;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	99.09.30.04.18.14;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	99.09.28.23.20.30;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	99.09.18.08.44.07;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	99.09.18.08.07.01;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	99.09.14.04.21.41;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	99.09.06.20.31.40;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	99.09.06.03.37.31;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	99.09.06.02.31.42;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	99.09.03.19.26.01;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	99.09.02.03.15.37;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	99.08.26.22.42.40;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	99.08.26.16.57.34;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	99.08.12.02.22.33;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	99.08.12.01.03.53;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	99.07.24.05.49.03;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	99.07.24.05.08.19;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	99.07.24.05.06.34;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	99.07.24.04.59.55;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	99.07.23.20.40.57;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	99.07.23.20.01.07;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	99.07.14.18.13.25;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	99.07.13.03.53.11;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	99.07.10.00.11.34;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	99.07.03.23.35.07;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	99.07.03.23.25.29;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	99.07.03.23.14.29;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	99.07.03.23.06.57;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	99.06.28.06.34.15;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	99.06.21.21.13.00;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	99.06.21.21.03.36;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	99.06.21.20.59.29;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	99.06.20.20.29.18;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	99.06.17.15.36.07;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	99.05.25.06.43.19;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	99.05.25.06.24.54;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	99.05.25.06.22.23;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	99.05.22.22.11.03;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	99.05.22.21.49.54;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	99.05.22.16.09.32;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	99.05.18.00.04.22;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	99.05.15.17.12.08;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	99.05.15.17.01.04;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	99.05.15.16.38.59;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	99.05.05.12.46.11;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	99.05.04.10.43.21;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	99.04.28.08.09.30;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	99.04.26.08.08.08;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.04.26.05.30.58;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.04.23.23.43.36;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.04.14.23.41.06;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.04.13.00.50.40;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.04.12.22.42.00;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.04.12.03.54.16;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.04.12.03.50.30;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.04.12.03.43.40;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.04.12.03.36.48;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	99.03.30.15.23.43;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	99.01.18.22.12.16;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	99.01.18.16.56.46;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	99.01.05.18.31.56;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.01.02.18.12.08;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.01.02.17.41.28;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	98.12.29.23.54.24;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	98.12.23.16.51.28;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	98.12.13.22.54.56;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	98.12.13.22.06.23;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	98.12.09.08.32.15;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	98.12.09.01.23.21;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	98.12.09.01.20.36;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	98.12.08.22.38.11;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	98.12.08.06.03.37;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	98.12.08.03.40.29;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	98.12.08.03.19.41;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	98.12.08.01.54.09;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	98.12.07.12.58.16;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	98.12.06.07.40.40;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	98.12.05.22.32.20;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	98.12.05.22.05.58;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	98.12.05.21.44.02;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	98.12.05.10.16.51;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	98.12.05.10.10.48;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	98.12.05.09.50.17;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	98.11.29.22.26.19;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	98.11.29.05.19.23;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	98.11.24.05.29.00;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	98.11.22.08.04.40;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	98.11.21.00.13.42;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	98.11.20.04.01.17;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	98.11.20.03.59.51;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	98.11.19.22.31.19;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	98.11.19.09.06.00;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	98.11.18.02.17.47;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	98.11.18.02.07.34;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	98.11.18.01.41.22;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	98.11.17.23.30.41;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	98.11.17.23.20.08;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	98.11.15.09.40.26;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	98.11.15.09.29.33;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	98.11.15.02.24.46;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	98.11.15.02.04.07;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	98.10.17.07.12.10;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	98.10.17.02.56.08;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	98.10.13.04.13.27;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	98.10.12.23.29.05;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	98.10.12.22.05.20;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	98.10.12.21.46.07;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	98.10.12.20.41.01;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	98.10.12.07.28.52;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	98.10.11.05.22.23;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.10.08.14.14.23;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.10.06.22.18.53;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.10.05.05.05.57;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.10.05.04.56.43;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.10.05.04.18.49;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.09.10.23.27.07;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.08.30.03.59.56;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.08.30.03.33.32;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.08.30.01.19.51;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.08.21.14.21.07;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.08.21.00.52.13;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.08.20.21.05.25;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.08.12.08.20.13;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.08.10.19.41.19;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.08.05.09.52.29;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.08.05.09.14.31;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.08.05.08.46.15;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.08.05.08.14.33;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.08.05.07.30.29;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.08.05.06.59.12;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.08.04.17.21.34;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.08.02.14.31.30;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.02.14.30.34;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.01.13.46.04;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.07.29.06.23.37;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.07.29.06.06.05;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.07.29.06.04.58;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.06.18.14.18.30;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.06.17.15.18.52;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.13;	author mud;	state Exp;
branches;
next	;


desc
@@


1.423
log
@bye bye april fools
corey
@
text
@/***************************************************************************
  *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
  *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
  *                                                                         *
  *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
  *  Chastain, Michael Quan, and Mitchell Tse.                              *
  *                                                                         *
  *  In order to use any part of this Merc Diku Mud, you must comply with   *
  *  both the original Diku license in 'license.doc' as well the Merc       *
  *  license in 'license.txt'.  In particular, you may not remove either of *
  *  these copyright notices.                                               *
  *                                                                         *
  *  Much time and thought has gone into this software and you are          *
  *  benefitting.  We hope that you share your changes too.  What goes      *
  *  around, comes around.                                                  *
  ***************************************************************************/
 
static char rcsid[] = "$Id: act_info.c,v 1.422 2004/04/01 08:06:20 ndagger Exp $";
 #if defined(macintosh)
 #include <types.h>
 #else
 #include <sys/types.h>
 #include <unistd.h>
 #include <sys/time.h>
 #endif
 #include "gc.h"
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <ctype.h>
 #include <time.h>
 #include "merc.h"
 #include "magic.h"
 #include "recycle.h"
 #include "tables.h"
 #include "lookup.h"
 #include "gladiator.h"
 
 /* command procedures needed */
 DECLARE_DO_FUN( do_exits        );
 DECLARE_DO_FUN( do_look         );
 DECLARE_DO_FUN( do_help         );
 DECLARE_DO_FUN( do_affects      );
 DECLARE_DO_FUN( do_play         );
 DECLARE_DO_FUN( do_outfit       );
 DECLARE_DO_FUN( do_dismount     ); 
 
 char *  const  where_name      [] =
 {
     "<{Wused as light{x>     ",
     "<{Wworn on finger{x>    ",
     "<{Wworn on finger{x>    ",
     "<{Wworn around neck{x>  ",
     "<{Wworn around neck{x>  ",
     "<{Wworn on torso{x>     ",
     "<{Wworn on head{x>      ",
     "<{Wworn on legs{x>      ",
     "<{Wworn on feet{x>      ",
     "<{Wworn on hands{x>     ",
     "<{Wworn on arms{x>      ",
     "<{Wworn as shield{x>    ",
     "<{Wworn about body{x>   ",
     "<{Wworn about waist{x>  ",
     "<{Wworn around wrist{x> ",
     "<{Wworn around wrist{x> ",
     "<{Wwielded{x>           ",
     "<{Wheld{x>              ",
     "<{Wfloating nearby{x>   ",
     "<{Wsecondary weapon{x>  "
}; 
 
 
 /* for do_count */
 int max_on = 0;
 
 
/*
  * Local functions.
  */
 char *  format_obj_to_char      args( ( OBJ_DATA *obj, CHAR_DATA *ch,
             bool fShort ) );
 void    show_char_to_char_0     args( ( CHAR_DATA *victim, CHAR_DATA *ch ) );
 void    show_char_to_char_1     args( ( CHAR_DATA *victim, CHAR_DATA *ch ) );
 void    show_char_to_char       args( ( CHAR_DATA *list, CHAR_DATA *ch ) );
 bool    check_blind             args( ( CHAR_DATA *ch ) );
 bool    check_match             args( ( CHAR_DATA *ch, CHAR_DATA *victim) );


/** Ranger stuff **/
void do_species( CHAR_DATA *ch, char *argument )
{   
   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_INPUT_LENGTH];
   int race = 0;

   one_argument( argument, arg );

   if ( !HAS_KIT(ch,"ranger") )
   {
       send_to_char("Only rangers have a species enemy.\n\r",ch);
       return;
   }

   if ( ch->species_enemy ) 
   {
       send_to_char("You already selected one!\n\r",ch);
       return;
   }

   if ( ( race = race_lookup( arg ) ) == 0 ||
	!race_table[race].pc_race ||
	race == ch->race )
   {
       send_to_char("That isn't a valid species enemy.\n\r",ch);
       return;
   }

   ch->species_enemy = race_lookup( arg );
   sprintf(buf,"You have selected {C%s{x as your species enemy.",
	   race_table[race].name );
   send_to_char(buf, ch);
   return;
}

 char *format_obj_to_char( OBJ_DATA *obj, CHAR_DATA *ch, bool fShort )
 {
     static char buf[MAX_STRING_LENGTH];
 
     buf[0] = '\0';
 
     if ((fShort && (obj->short_descr == NULL || obj->short_descr[0] == '\0'))
     ||  (obj->description == NULL || obj->description[0] == '\0'))
   return buf;
 
     if ( IS_OBJ_STAT(obj, ITEM_INVIS)     )   strcat( buf, "(Invis) "     );
     if ( IS_AFFECTED(ch, AFF_DETECT_ALIGN)
    && IS_OBJ_STAT(obj, ITEM_EVIL)   )   
	strcat( buf, "({RRed Aura{x) "  );
     if (IS_AFFECTED(ch, AFF_DETECT_ALIGN)
     &&  IS_OBJ_STAT(obj,ITEM_BLESS))          
	strcat(buf,"({BBlue Aura{x) " );
     if ( obj->item_type == ITEM_WEAPON && IS_SET(obj->value[4], WEAPON_NETHER) )
	 strcat( buf, "({DBlack Aura{x) " );
     if ( IS_AFFECTED(ch, AFF_DETECT_MAGIC)
    && IS_OBJ_STAT(obj, ITEM_MAGIC)  )   strcat( buf, "(Magical) "   );
     if ( IS_OBJ_STAT(obj, ITEM_GLOW)      )   
	strcat( buf, "({WGlowing{x) " );
     if ( IS_OBJ_STAT(obj, ITEM_HUM)       )   strcat( buf, "(Humming) "   );
 
     if ( fShort )
     {
   if ( obj->short_descr != NULL )
       strcat( buf, obj->short_descr );
     }
     else
     {
   if ( obj->description != NULL)
       strcat( buf, obj->description );
     }
     
     if (IS_IMMORTAL (ch) && IS_SET (ch->display,DISP_DISP_VNUM)) {
       char temp_buf[50];
       
       sprintf (temp_buf," [%d]",obj->pIndexData->vnum);
       strcat (buf,temp_buf);
     }    
 
     return buf;
 }
 
 
 
 /*
  * Show a list to a character.
  * Can coalesce duplicated items.
  */
 void show_list_to_char( OBJ_DATA *list, CHAR_DATA *ch, bool fShort, bool fShowNothing, bool fExpand )
 {
     char buf[MAX_STRING_LENGTH];
     BUFFER *output;
     char **prgpstrShow;
     int *prgnShow;
     char *pstrShow;
     OBJ_DATA *obj;
     int nShow;
     int iShow;
     int count;
     bool fCombine;
 
     if ( ch->desc == NULL )
   return;
 
     /*
      * Alloc space for output lines.
      */
     output = new_buf();
 
     count = 0;
     for ( obj = list; obj != NULL; obj = obj->next_content )
   count++;
#ifdef OLC_VERSION
     prgpstrShow = alloc_mem( count * sizeof(char *) );
     prgnShow    = alloc_mem( count * sizeof(int)    );
#else
     prgpstrShow = GC_MALLOC( count * sizeof(char *) );
     prgnShow    = GC_MALLOC( count * sizeof(int)    );
#endif
     nShow       = 0;
 
     /*
      * Format the list of objects.
      */
     for ( obj = list; obj != NULL; obj = obj->next_content )
     {
  
   if ( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj )) 
   {
      if (obj->item_type == ITEM_CONTAINER && fExpand )
	 {
	 show_list_to_char(obj->contains, ch, TRUE, TRUE, TRUE);
         }
       pstrShow = format_obj_to_char( obj, ch, fShort );
 
       fCombine = FALSE;
 
       if ( IS_NPC(ch) || IS_SET(ch->display, DISP_COMBINE))
       {
     /*
      * Look for duplicates, case sensitive.
      * Matches tend to be near end so run loop backwords.
      */
     for ( iShow = nShow - 1; iShow >= 0; iShow-- )
     {
         if ( !strcmp( prgpstrShow[iShow], pstrShow ) )
         {
       prgnShow[iShow]++;
       fCombine = TRUE;
       break;
         }
     }
       }
 
       /*
        * Couldn't combine, or didn't want to.
        */
       if ( !fCombine )
       {
     prgpstrShow [nShow] = str_dup( pstrShow );
     prgnShow    [nShow] = 1;
     nShow++;
       }
   }
     }
 
     /*
      * Output the formatted list.
      */
     for ( iShow = 0; iShow < nShow; iShow++ )
     {
   if (prgpstrShow[iShow][0] == '\0')
   {
       free_string(prgpstrShow[iShow]);
       continue;
   }
 
   if ( IS_NPC(ch) || IS_SET(ch->display, DISP_COMBINE ))
   {
       if ( prgnShow[iShow] != 1 )
       {
     sprintf( buf, "(%2d) ", prgnShow[iShow] );
     add_buf(output,buf);
       }
       else
       {
     add_buf(output,"     ");
       }
   }
   add_buf(output,prgpstrShow[iShow]);
   add_buf(output,"\n\r");
   free_string( prgpstrShow[iShow] );
     }
 
     if ( fShowNothing && nShow == 0 )
     {
   if ( IS_NPC(ch) || IS_SET(ch->display, DISP_COMBINE))
       send_to_char( "     ", ch );
   send_to_char( "Nothing.\n\r", ch );
     }
     page_to_char(buf_string(output),ch);
 
     /*
      * Clean up.
      */
     free_buf(output);
     free_mem( prgpstrShow, count * sizeof(char *) );
     free_mem( prgnShow,    count * sizeof(int)    );
 
     return;
 }
 
 
 
 void show_char_to_char_0( CHAR_DATA *victim, CHAR_DATA *ch )
 {
     char buf[MAX_STRING_LENGTH],message[MAX_STRING_LENGTH];
 
     buf[0] = '\0';

     if ( !IS_NPC(victim) && victim->desc == NULL )	strcat( buf, "({YLinkdead{x) ");
     if ( IS_SET(victim->comm,COMM_AFK     )   ) strcat( buf, "[{CAFK{x] "    );
     if ( IS_AFFECTED(victim, AFF_INVISIBLE)   ) strcat( buf, "(Invis) "      );
     if ( victim->invis_level >= LEVEL_HERO    ) strcat( buf, "(Wizi) "       );
     if ( IS_AFFECTED(victim, AFF_HIDE)        ) strcat( buf, "(Hide) "       );
     if ( IS_AFFECTED(victim, AFF_CHARM)       ) strcat( buf, "(Charmed) "    );
     if ( IS_AFFECTED(victim, AFF_FAERIE_FIRE) ) 
	strcat( buf, "({MPink Aura{x) " );
     if ( IS_AFFECTED(victim, AFF_FAERIE_FOG) ) strcat( buf, "(Purple Aura) "  );
     if ( IS_EVIL(victim)
     &&   (IS_AFFECTED(ch, AFF_DETECT_ALIGN) || IS_SET(ch->act, PLR_HOLYLIGHT))     ) 
	strcat( buf, "({RRed Aura{x) " );
     if ( IS_GOOD(victim)
     &&   (IS_AFFECTED(ch, AFF_DETECT_ALIGN) || IS_SET(ch->act, PLR_HOLYLIGHT))     ) 
	strcat( buf, "({YGolden Aura{x) " );
     if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_DWEEB  ) )
             strcat( buf, "({CDWEEB{x) ");

     if (IS_NPC(victim))
     {
     if ( IS_AFFECTED(victim, AFF_PASS_DOOR)   ) strcat( buf, "(Translucent) ");
     if ( IS_AFFECTED(victim, AFF_SANCTUARY)   ) 
	strcat( buf, "({WWhite Aura{x) " );
     if ( is_affected(victim,skill_lookup("flame shield") ) )
	strcat( buf, "({rFire Shield{x} " );
     if ( is_affected(victim,skill_lookup("frost shield") ) )
	strcat( buf, "({cIce Shield{x} " );
     if ( is_affected(victim,skill_lookup("electric shield") ) )
	strcat( buf, "({yElectric Shield{x} " );
     }
     else
     {
	if(!IS_SET(victim->mhs,MHS_SHAPEMORPHED))
	{
     if ( IS_AFFECTED(victim, AFF_PASS_DOOR)   ) strcat( buf, "(Translucent) ");
     if ( is_affected(victim, skill_lookup("wraithform")) )
	strcat( buf, "({DBlack Aura{x) " );
     if ( IS_AFFECTED(victim, AFF_SANCTUARY)   ) 
	strcat( buf, "({WWhite Aura{x) " );
     if ( is_affected(victim,skill_lookup("flame shield") ) )
	strcat( buf, "({rFire Shield{x} " );
     if ( is_affected(victim,skill_lookup("frost shield") ) )
	strcat( buf, "({cIce Shield{x} " );
     if ( is_affected(victim,skill_lookup("electric shield") ) )
	strcat( buf, "({yElectric Shield{x} " );
     if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER ) )
             strcat( buf, "({RKILLER{x) "     );
     if ( !IS_NPC(victim) && !IS_SET(victim->act, PLR_KILLER ) 
	 && victim->trumps > 0)
             strcat( buf, "({rTHUG{x) "     );
     if ( !IS_NPC(victim) && IS_SET(victim->wiznet, PLR_RUFFIAN ) 
	&& !IS_SET(victim->act, PLR_KILLER) && victim->trumps == 0 )
             strcat( buf, "({rRUFFIAN{x) "     );
     if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF  ) )
             strcat( buf, "({RTHIEF{x) "      );
	}
     }
             
     if (IS_IMMORTAL (ch) && IS_SET (ch->display,DISP_DISP_VNUM)) {
       char temp_buf[50];
         
       if (IS_NPC(victim) && victim->pIndexData) {
         sprintf (temp_buf,"[%d] ",victim->pIndexData->vnum);
         strcat (buf,temp_buf);
       }
     }  
             
     if ( victim->position == victim->start_pos && victim->long_descr[0] != '\0' )
     {
   strcat( buf, victim->long_descr );
   send_to_char( buf, ch );
   return;
     }
 
     if (IS_SET(victim->mhs,MHS_SHAPEMORPHED)
	 || (IS_SET(victim->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE))
     {
	strcat ( buf, victim->long_descr);
     }
     else
     {
        strcat( buf, PERS( victim, ch, FALSE ) );
        if ( !IS_NPC(victim) && !IS_SET(ch->display,DISP_BRIEF_DESCR) 
        &&   victim->position == POS_STANDING && ch->on == NULL )
           strcat( buf, victim->pcdata->title );
     }
 
     switch ( victim->position )
     {
     case POS_DEAD:     strcat( buf, " is DEAD!!" );              break;
     case POS_MORTAL:   strcat( buf, " is mortally wounded." );   break;
     case POS_INCAP:    strcat( buf, " is incapacitated." );      break;
     case POS_STUNNED:  strcat( buf, " is lying here stunned." ); break;
     case POS_SLEEPING: 
   if (victim->on != NULL)
   {
       if (IS_SET(victim->on->value[2],SLEEP_AT))
       {
     sprintf(message," is sleeping at %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
       else if (IS_SET(victim->on->value[2],SLEEP_ON))
       {
     sprintf(message," is sleeping on %s.",
         victim->on->short_descr); 
     strcat(buf,message);
       }
       else
       {
     sprintf(message, " is sleeping in %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
   }
   else 
       strcat(buf," is sleeping here.");
   break;
     case POS_RESTING:  
   if (victim->on != NULL)
   {
       if (IS_SET(victim->on->value[2],REST_AT))
       {
     sprintf(message," is resting at %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
       else if (IS_SET(victim->on->value[2],REST_ON))
       {
     sprintf(message," is resting on %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
       else 
       {
     sprintf(message, " is resting in %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
   }
   else
       strcat( buf, " is resting here." );       
   break;
     case POS_SITTING:  
   if (victim->on != NULL)
   {
       if (IS_SET(victim->on->value[2],SIT_AT))
       {
     sprintf(message," is sitting at %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
       else if (IS_SET(victim->on->value[2],SIT_ON))
       {
     sprintf(message," is sitting on %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
       else
       {
     sprintf(message, " is sitting in %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
   }
   else
       strcat(buf, " is sitting here.");
   break;
     case POS_STANDING: 
   if (victim->on != NULL)
   {
       if (IS_SET(victim->on->value[2],STAND_AT))
       {
     sprintf(message," is standing at %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
       else if (IS_SET(victim->on->value[2],STAND_ON))
       {
     sprintf(message," is standing on %s.",
        victim->on->short_descr);
     strcat(buf,message);
       }
       else
       {
     sprintf(message," is standing in %s.",
         victim->on->short_descr);
     strcat(buf,message);
       }
   }
   else
       strcat( buf, " is here." );               
   break;
     case POS_FIGHTING:
   strcat( buf, " is here, fighting " );
   if ( victim->fighting == NULL )
       strcat( buf, "thin air??" );
   else if ( victim->fighting == ch )
       strcat( buf, "YOU!" );
   else if ( victim->in_room == victim->fighting->in_room )
   {
    /*   if (IS_SET(victim->fighting->mhs,MHS_GLADIATOR) 
	   && gladiator_info.blind == TRUE)
          strcat( buf, PERS( victim->fighting->long_descr, ch, FALSE ) );
       else */
          strcat( buf, PERS( victim->fighting, ch, FALSE ) ); 
       strcat( buf, "." );
   }
   else
       strcat( buf, "somone who left??" );
   break;
     }
 
     strcat( buf, "\n\r" );
     buf[0] = UPPER(buf[0]);
     send_to_char( buf, ch );
     return;
 }
 
 
 
 void show_char_to_char_1( CHAR_DATA *victim, CHAR_DATA *ch )
 {
     char buf[MAX_STRING_LENGTH];
     OBJ_DATA *obj;
     int iWear;
     int percent;
     bool found;
     AFFECT_DATA *paf, *paf_last = NULL;
 
     if ( can_see( victim, ch, FALSE ) )
     {
   if (ch == victim)
       if(IS_SET(ch->mhs,MHS_SHAPEMORPHED) ||
	  (IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE))
          act( "$l looks at $mself.",ch,NULL,NULL,TO_ROOM,FALSE);
       else
          act( "$n looks at $mself.",ch,NULL,NULL,TO_ROOM,FALSE);
   else
   {
       if(IS_SET(ch->mhs,MHS_SHAPEMORPHED) ||
	  (IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE))
       {
          act( "$l looks at you.", ch, NULL, victim, TO_VICT, FALSE  );
          act( "$l looks at $L.",  ch, NULL, victim, TO_NOTVICT,FALSE );
       }
       else
       {
          act( "$n looks at you.", ch, NULL, victim, TO_VICT, FALSE  );
          act( "$n looks at $N.",  ch, NULL, victim, TO_NOTVICT,FALSE );
       }
   }
     }
 
     if (IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind ==TRUE)
	strcpy( buf, ch->long_descr);
     else
     {
	if(!IS_SET(ch->display,DISP_BRIEF_CHAR_DESCR))
	{
        if ( victim->description[0] != '\0' )
           send_to_char( victim->description, ch );
        else
           act( "You see nothing special about $M.", ch, NULL, victim, TO_CHAR, FALSE);
	}
 
        if (IS_IMMORTAL (ch) && IS_SET (ch->display,DISP_DISP_VNUM))
	{
           char temp_buf[50];
       
           if (IS_NPC(victim) && victim->pIndexData)
           {
              sprintf (temp_buf,"[%d] ",victim->pIndexData->vnum);
              strcat (buf,temp_buf);
           }
        }
 
        strcpy( buf, PERS(victim, ch, FALSE) );
 
        strcat (buf, " the ");
        if( !IS_NPC(victim) )
        {
           if (IS_SET(victim->act,PLR_WERE))
              strcat (buf,"garou ");
           if (IS_SET (victim->act,PLR_VAMP))
              strcat (buf,"nosferatu ");
           if (IS_SET (victim->act,PLR_MUMMY))
              strcat (buf,"mummified ");
        }

        strcat (buf,race_table[victim->race].name);
     }

     if ( victim->max_hit > 0 )
        percent = ( 100 * victim->hit ) / victim->max_hit;
     else
        percent = -1;

     if (percent >= 100) 
   strcat( buf, " is in excellent condition.\n\r");
     else if (percent >= 90) 
   strcat( buf, " has a few scratches.\n\r");
     else if (percent >= 75) 
   strcat( buf," has some small wounds and bruises.\n\r");
     else if (percent >=  50) 
   strcat( buf, " has quite a few wounds.\n\r");
     else if (percent >= 30)
   strcat( buf, " has some big nasty wounds and scratches.\n\r");
     else if (percent >= 15)
   strcat ( buf, " looks pretty hurt.\n\r");
     else if (percent >= 0 )
   strcat (buf, " is in awful condition.\n\r");
     else
   strcat(buf, " is bleeding to death.\n\r");
 
     buf[0] = UPPER(buf[0]);
     send_to_char( buf, ch );
 
     if(!IS_SET(ch->mhs,MHS_GLADIATOR))
     {
        found = FALSE;
     for ( iWear = 0; iWear < MAX_WEAR; iWear++ )
     {

   if ( ( obj = get_eq_char( victim, iWear ) ) != NULL
   &&   can_see_obj( ch, obj ) )
   {
       if ( !found )
       {
     send_to_char( "\n\r", ch );
     act( "$N is using:", ch, NULL, victim, TO_CHAR, FALSE );
     found = TRUE;
       }
       send_to_char( where_name[iWear], ch );
       send_to_char( format_obj_to_char( obj, ch, TRUE ), ch );
       send_to_char( "\n\r", ch );
   }
     }
 
     if ( victim != ch
     &&   !IS_NPC(ch)
     &&   IS_SET(ch->act,PLR_AUTOPEEK)
     &&   number_percent( ) < get_skill(ch,gsn_peek))
     {
   send_to_char( "\n\rYou peek at the inventory:\n\r", ch );
   check_improve(ch,gsn_peek,TRUE,4);
   show_list_to_char( victim->carrying, ch, TRUE, TRUE, FALSE );
     }

     if ( IS_AFFECTED(ch,AFF_DETECT_MAGIC) ||  IS_SET(ch->act, PLR_HOLYLIGHT)) 
     {
  if ( victim->affected != NULL )
  {
     send_to_char( "\n\rAffected by the following spells:\n\r", ch );   
     for ( paf = victim->affected; paf != NULL; paf = paf->next )
     {
	if (paf_last != NULL)
	{
           if (paf->type != paf_last->type)
           {
              sprintf( buf, "Spell: %-15s\n\r", skill_table[paf->type].name );
              send_to_char( buf, ch );
	   }
	}
	else
	{
           sprintf( buf, "Spell: %-15s\n\r", skill_table[paf->type].name );
	   send_to_char( buf, ch );
	}
	paf_last = paf;
     }
  }
           else
           send_to_char("\n\rNot affected by any spells.\n\r",ch);
        }
     }
     return;
 }
 
 
 
 void show_char_to_char( CHAR_DATA *list, CHAR_DATA *ch )
 {
     CHAR_DATA *rch;
 
     for ( rch = list; rch != NULL; rch = rch->next_in_room )
     {
   if ( rch == ch )
       continue;
 
   if ( get_trust(ch) < rch->invis_level)
       continue;

   if ( can_see( ch, rch, FALSE ) )
   {
       show_char_to_char_0( rch, ch );
   }
   else if ( room_is_dark( ch->in_room )
   &&        IS_AFFECTED(rch, AFF_INFRARED ) )
   {
       send_to_char( "You see glowing red eyes watching YOU!\n\r", ch );
   }
     }
 
     return;
 } 
 
 
 
 bool check_blind( CHAR_DATA *ch )
 {
 
     if (!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT))
   return TRUE;
 
     if ( IS_AFFECTED(ch, AFF_BLIND) )
     { 
   send_to_char( "You can't see a thing!\n\r", ch ); 
   return FALSE; 
     }
 
     return TRUE;
 }

void do_kit( CHAR_DATA *ch, char *argument )
{
   char arg1[MAX_INPUT_LENGTH];
   char arg2[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   char cbuf[MAX_STRING_LENGTH];
   int kit;
   bool fAll = TRUE;

   argument = one_argument( argument, arg1 );
   one_argument( argument, arg2 );

   if ( arg1[0] == '\0' ||
	arg2[0] == '\0' )
   {
       send_to_char(" Syntax:  kit info <kit name>\n\r"
		    "          kit take <kit name>\n\r",ch);
       return;
   }

   if ( !str_cmp( arg1, "take" ) )
   {
	int i;

	if ( ch->level < 10 )
	{
	    send_to_char("You must be level 10 to take a kit.\n\r",ch);
	    return;
	}

	if ( ( kit = kit_lookup(arg2) ) < 0 )
	{
	    send_to_char("Invalid kit.\n\r",ch);
	    return;
	}

	if ( !kit_table[kit].flags )
	{
	    send_to_char("Can you not read?  This Kit isn't ready.\n\r",ch);
	    return;
	}

        if(IS_SET(ch->mhs,MHS_SHAPEMORPHED) ||
           IS_SET(ch->mhs,MHS_SHAPESHIFTED))
        {
	    send_to_char("You can not take a kit while shapeshifted or shapemorphed.\n\r",ch);
	    return;
        }

	/* Are you the right class? */
	if ( !kit_table[kit].class[ch->class] )
	{
	    send_to_char("You are not of the right class.\n\r",ch);
	    return;
	}

	if( !kit_table[kit].race[ch->race] )
	{
	    send_to_char("You are not of the right race.\n\r",ch);
	    return;
	}

	for ( i = 0 ; i < MAX_STATS ; i++ )
	    if ( kit_table[kit].min_stat[i] > 0 &&
		 ch->perm_stat[i] < kit_table[kit].min_stat[i] )
	    {
		send_to_char("Your attributes are not high enough.\n\r",ch);
		return;
	    }

	    if ( kit == kit_lookup("vampyre hunter") && 
		IS_SET(ch->act,PLR_VAMP)
	       )
            {
                send_to_char("What are you some kind of kin slayer?\n\r",ch);
                return;
            }
            if ( kit == kit_lookup("lycanthrope hunter") &&
                IS_SET(ch->act,PLR_WERE)
               )
            {
                send_to_char("What are you some kind of kin slayer?\n\r",ch);
                return;
            }
            if ( kit == kit_lookup("archeolgist") &&
                IS_SET(ch->act,PLR_MUMMY)
               )
            {
                send_to_char("What are you some kind of kin slayer?\n\r",ch);
                return;
            }

	    /* check buffy and remort status */
	    if ( kit == kit_lookup("buffy") &&
		 ( IS_SET(ch->act, PLR_VAMP) || 
		   IS_SET(ch->act, PLR_WERE) || 
		   IS_SET(ch->act, PLR_MUMMY) )
               )
	    {
		send_to_char("What are you some kind of kin slayer?\n\r",ch);
		return;
	    }

/*
	if ( ch->train < kit_table[kit].cost )
	*/
	if ( ch->practice < (kit_table[kit].cost * 10) )
	{
	    send_to_char("You don't have enough practices.\n\r",ch);
	    return;
	}

	/* WHEW!  All done. */
	/* Remove any existing kit */
	if ( ch->kit )
	{
	   for ( i = 0 ; i < 5 ; i++ )
	      if ( kit_table[ch->kit].skills[i] == NULL )
		  break;
	      else
		{
		  group_remove(ch,kit_table[ch->kit].skills[i]);
		}
		  /* remove any extra special bonuses */
		  if ( ch->kit == kit_lookup("ranger") )
                     ch->species_enemy = 0;
		  if ( ch->kit == kit_lookup("myrmidon") )
		     ch->pcdata->specialize = 0;
	}

	if ( kit == kit_lookup("myrmidon") &&
	     ch->pcdata->specialize != 0 )
ch->practice += (skill_table[ch->pcdata->specialize].rating[ch->class] * 10);
	/*
	ch->train += skill_table[ch->pcdata->specialize].rating[ch->class];
	*/

	ch->kit = kit;
	ch->practice -= (kit_table[kit].cost * 10);
	/*
	ch->train -= kit_table[kit].cost;
	*/
	for ( i = 0 ; i < 5 ; i++ )
	    if ( kit_table[kit].skills[i] == NULL )
		break;
	    else 
		group_add(ch,kit_table[kit].skills[i],FALSE);

	sprintf(buf,"You take the %s kit.\n\r",
		kit_table[kit].name );
	send_to_char(buf,ch);
	if ( kit == kit_lookup("nethermancer") )
	{
	/*
		OBJ_DATA *obj;

		for ( obj = ch->carrying ; obj ; obj = obj->next_content )
		{
		    if ( obj->item_type == ITEM_ARMOR )
			remove_obj( ch, obj, FALSE );
		}
		*/
/* Remove all EQ on the Player to avoid getting around armor restrictions */
		remove_all_objs(ch);

		do_outfit( ch, "nethermancer" );
	}

	return;
   }

   if ( !str_cmp( arg1, "info" ) )
   {
       int i;
       
       if ( ( kit = kit_lookup(arg2) ) < 0 )
       {
	   send_to_char("Invalid kit.  Type 'help kit list' for a list.\n\r",ch);
	   return;
       }
	      
	cbuf[0] = '\0';
       sprintf(buf,"{WKit: {x%s   {WCost: {G%d{x practices\n\r",
		kit_table[kit].name, (kit_table[kit].cost * 10));
		/*
       sprintf(buf,"{WKit: {x%s   {WCost: {G%d{x trains\n\r",
		kit_table[kit].name, kit_table[kit].cost);
		*/
	send_to_char(buf,ch);
	send_to_char("{WClasses{x:  ", ch ); 
	for ( i = 0 ; i < MAX_CLASS ; i++ )
	    if ( kit_table[kit].class[i] )
	    {
		strcat(cbuf, class_table[i].name );
		strcat(cbuf, " " );
 	    }
	    else
	    {
		fAll = FALSE;
	    }
	if ( fAll )
		send_to_char( "all", ch);
	else
		send_to_char( cbuf, ch );

	fAll = TRUE;
	cbuf[0] = '\0';

        send_to_char("\n\r{WRaces{x:  ",ch);
	for ( i = 1 ; i < MAX_PC_RACE ; i++ )
	   if ( kit_table[kit].race[i] )
	   {
	       strcat(cbuf, pc_race_table[i].name );
	       strcat(cbuf, " " );
	   }
	   else
	   {
	       fAll = FALSE;
	   }

	if (  fAll )
		send_to_char( "all", ch );
	else
		send_to_char( cbuf, ch );

	send_to_char("\n\r{WMinimum Attributes:{x  ",ch);
	for ( i = 0 ; i < MAX_STATS ; i++ )
	    if ( kit_table[kit].min_stat[i] > 0 )
	    {
		char buf2[10]; 

		buf[0] = '\0';
		switch( i )
		{
		case STAT_STR: strcat(buf,"STR "); break; 
		case STAT_DEX: strcat(buf,"DEX "); break;
		case STAT_INT: strcat(buf,"INT "); break;
		case STAT_WIS: strcat(buf,"WIS "); break;
		case STAT_CON: strcat(buf,"CON "); break;
		case STAT_AGT: strcat(buf,"AGT "); break;
 		case STAT_END: strcat(buf,"END "); break;
 		case STAT_SOC: strcat(buf,"SOC "); break;
		default:       strcat(buf,"??? "); break;
		};
		sprintf(buf2,"{G%d{x  ", kit_table[kit].min_stat[i] );
		strcat(buf,buf2);
		send_to_char(buf,ch);
	    }
	send_to_char("\n\r{WSkills/Groups:{x  ",ch);
    	for ( i = 0 ; i < 5 ; i++ )
	    if ( kit_table[kit].skills[i] != NULL )
	    {
		sprintf(buf,"'%s'  ",kit_table[kit].skills[i]);
		send_to_char(buf,ch);
	    }

	if ( !kit_table[kit].flags )
	    send_to_char("\n\r{RNOTICE:{x This kit is not complete.  "
			 "If you take it, you'll probably get screwed.",ch);
	    
	if ( !kit_table[kit].class[ch->class] ||
	     !kit_table[kit].race[ch->race] ||
	     !kit_table[kit].sex[ch->pcdata->true_sex] ) 
	    send_to_char("\n\r{RNOTICE:{x You do not qualify for this kit.",ch);
	else
	for ( i = 0 ; i < MAX_STATS ; i++ )
	    if ( kit_table[kit].min_stat[i] > 0 &&
	         ch->perm_stat[i] < kit_table[kit].min_stat[i] )
	    {
		send_to_char(
		"\n\r{RNOTICE:{x You do not qualify for this kit.",ch);
		break;
	    }

	    send_to_char("\n\r",ch);
	return;
    }

    send_to_char("Not yet.\n\r",ch);
    return;
}


void do_peek(CHAR_DATA *ch, char *argument)
{
  CHAR_DATA *victim;
  char arg[MAX_INPUT_LENGTH];
  char buf[100];

  one_argument(argument,arg);

  if (arg[0] == '\0')
   {
	send_to_char("Peek into who's inventory?\n\r.",ch);
	return;
   }

  if ( ( victim = get_char_room( ch, arg ) ) == NULL )
     {
	send_to_char("You can't seem to find them.\n\r",ch);
	return;
     }

  if( number_percent( ) < get_skill(ch,gsn_peek))
     {
   send_to_char( "\n\rYou peek at their inventory:\n\r", ch );
   check_improve(ch,gsn_peek,TRUE,4);
   show_list_to_char( victim->carrying, ch, TRUE, TRUE, FALSE );

   if ( ( ch->class == class_lookup("thief") || 
          ch->class == class_lookup("rogue") ||
          ch->kit == kit_lookup("fence")) && 
        (is_clan(ch) && number_percent() < 25)
      )
   {
      sprintf(buf,"They appear to have %ld {Ygold{x and %ld {Wsilver{x.\n\r",
              victim->gold,victim->silver);
      send_to_char(buf,ch);
       }



     }
  else
     {
	if(IS_AWAKE(victim) && can_see(victim,ch,FALSE))
 act("$N tried to peek at what you're carrying.", victim,NULL,ch,TO_CHAR,FALSE);
 }

  return;
}

 /* changes your scroll */
 void do_scroll(CHAR_DATA *ch, char *argument)
 {
     char arg[MAX_INPUT_LENGTH];
     char buf[100];
     int lines;
 
     one_argument(argument,arg);
     
     if (arg[0] == '\0')
     {
   if (ch->lines == 0)
       send_to_char("You do not page long messages.\n\r",ch);
   else
   {
       sprintf(buf,"You currently display %d lines per page.\n\r",
         ch->lines + 2);
       send_to_char(buf,ch);
   }
   return;
     }
 
     if (!is_number(arg))
     {
   send_to_char("You must provide a number.\n\r",ch);
   return;
     }
 
     lines = atoi(arg);
 
     if (lines == 0)
     {
   send_to_char("Paging disabled.\n\r",ch);
   ch->lines = 0;
   return;
     }
 
     if (lines < 10 || lines > 100)
     {
   send_to_char("You must provide a reasonable number.\n\r",ch);
   return;
     }
 
     sprintf(buf,"Scroll set to %d lines.\n\r",lines);
     send_to_char(buf,ch);
     ch->lines = lines - 2;
 }
 
 /* RT does socials */
 void do_socials(CHAR_DATA *ch, char *argument)
 {
     char buf[MAX_STRING_LENGTH];
     int iSocial;
     int col;
      
     col = 0;
    
     for (iSocial = 0; social_table[iSocial].name[0] != '\0'; iSocial++)
     {
   sprintf(buf,"%-12s",social_table[iSocial].name);
   send_to_char(buf,ch);
   if (++col % 6 == 0)
       send_to_char("\n\r",ch);
     }
 
     if ( col % 6 != 0)
   send_to_char("\n\r",ch);
     return;
 }
 
 
  
 /* RT Commands to replace news, motd, imotd, etc from ROM */
 
 void do_motd(CHAR_DATA *ch, char *argument)
 {
     do_help(ch,"motd");
 }
 
 void do_imotd(CHAR_DATA *ch, char *argument)
 {  
     do_help(ch,"imotd");
 }
 
 void do_rules(CHAR_DATA *ch, char *argument)
 {
     do_help(ch,"rules");
 }
 
 void do_story(CHAR_DATA *ch, char *argument)
 {
     do_help(ch,"story");
 }
 
 void do_wizlist(CHAR_DATA *ch, char *argument)
 {
     do_help(ch,"wizlist");
 }
 
 void do_roar( CHAR_DATA *ch)
 {
     CHAR_DATA *vch;
     CHAR_DATA *vch_next;
 
     if (!(ch->race == race_lookup("dragon")))
   {
   send_to_char("Grow some scales.\n\r",ch);
   return;
   }
     if (ch->move < 20 || ch->mana <2)
   {
   send_to_char("You just can't build up the energy to roar.\n\r",ch);
   return;
   }
     send_to_char( "You let out an earthshaking ROAR!\n\r", ch );
 act( "$n ROARS and makes your entire body quiver!",ch,NULL,NULL,TO_ROOM,FALSE);
 
     for ( vch = char_list; vch != NULL; vch = vch_next )
     {
   vch_next        = vch->next;
   if ( vch->in_room == NULL )
       continue;
 
   if ( vch->in_room->area == ch->in_room->area )
     send_to_char( "You hear the echoes of a dragon roar in the distance.\n\r"
     "The ground beneath your feet rumbles a bit.\n\r", vch );
     }
     ch->move -= apply_chi(ch,20);
     ch->mana -= 4;
     return;
 }


 /* BS */
 void do_display(CHAR_DATA *ch, char *argument )
 {
    char buf[MAX_STRING_LENGTH];

    send_to_char("-== Display Options ==-\n\r",ch);

    send_to_char("Brief Toggles:\n\r",ch);
    sprintf(buf,"   Descriptions   %s\n\r",
		IS_SET(ch->display,DISP_BRIEF_DESCR) ? "ON" : "OFF" );
    send_to_char(buf,ch);

    sprintf(buf,"   Combat         %s\n\r",
		IS_SET(ch->display,DISP_BRIEF_COMBAT) ? "ON" : "OFF" );
    send_to_char(buf,ch);

    sprintf(buf,"   Who List       %s\n\r",
		IS_SET(ch->display,DISP_BRIEF_WHOLIST) ? "ON" : "OFF" );
    send_to_char(buf,ch);

    sprintf(buf,"   Equipment      %s\n\r",  
		IS_SET(ch->display,DISP_BRIEF_EQLIST) ? "ON" : "OFF" );
    send_to_char(buf,ch);
 
    sprintf(buf,"   Scan           %s\n\r",
		IS_SET(ch->display,DISP_BRIEF_SCAN) ? "ON" : "OFF" );
    send_to_char(buf, ch);

    sprintf(buf,"   Surnames	   %s\n\r",
		IS_SET(ch->display,DISP_SURNAME) ? "ON" : "OFF" );
    send_to_char(buf,ch);

    sprintf(buf,"   Titles	   %s\n\r",
		IS_SET(ch->display,DISP_NOTITLES) ? "OFF" : "ON" );
    send_to_char(buf,ch);

    return;
}

 /* RT this following section holds all the auto commands from ROM, as well as
    replacements for config */
 
 void do_autolist(CHAR_DATA *ch, char *argument)
 {
     /* lists most player flags */
     if (IS_NPC(ch))
       return;
 
     send_to_char("   action     status\n\r",ch);
     send_to_char("---------------------\n\r",ch);
  
     send_to_char("autoassist     ",ch);
     if (IS_SET(ch->act,PLR_AUTOASSIST))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch); 
 
     send_to_char("autoexit       ",ch);
     if (IS_SET(ch->act,PLR_AUTOEXIT))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("autogold       ",ch);
     if (IS_SET(ch->act,PLR_AUTOGOLD))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("autoloot       ",ch);
     if (IS_SET(ch->act,PLR_AUTOLOOT))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("autosac        ",ch);
     if (IS_SET(ch->act,PLR_AUTOSAC))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("autosplit      ",ch);
     if (IS_SET(ch->act,PLR_AUTOSPLIT))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("autopeek       ",ch);
     if (IS_SET(ch->act,PLR_AUTOPEEK))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("autorecall     ",ch);
     if (IS_SET(ch->act,PLR_NOAUTORECALL))
   send_to_char("OFF\n\r",ch);
     else
   send_to_char("ON\n\r",ch);

     send_to_char("full-sacing    ",ch);
     if (IS_SET(ch->mhs,MHS_FULL_SAC))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("norescue       ",ch);
     if (IS_SET(ch->mhs,MHS_NORESCUE))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);

     send_to_char("nowake         ",ch);
     if (IS_SET(ch->act,PLR_NOWAKE))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("compact mode   ",ch);
     if (IS_SET(ch->display,DISP_COMPACT))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     send_to_char("prompt         ",ch);
     if (IS_SET(ch->display,DISP_PROMPT))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);

     send_to_char("beeptell       ",ch);
     if (IS_SET(ch->comm,COMM_TELL_BEEP))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);    
 
   if (IS_IMMORTAL (ch)) {
     send_to_char("dispvnum       ",ch);
     
     if (IS_SET (ch->display,DISP_DISP_VNUM)) 
       send_to_char("ON\n\r",ch);
     else
       send_to_char("OFF\n\r",ch);
   }  
 
     send_to_char("combine items  ",ch);
     if (IS_SET(ch->display,DISP_COMBINE))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
     if (!IS_SET(ch->act,PLR_CANLOOT))
   send_to_char("Your corpse is safe from thieves.\n\r",ch);
     else 
   send_to_char("Your corpse may be looted.\n\r",ch);
 
     if (IS_SET(ch->act,PLR_NOSUMMON))
   send_to_char("You cannot be summoned.\n\r",ch);
     else
   send_to_char("You can be summoned.\n\r",ch);
 
     if (IS_SET(ch->act,PLR_NOCANCEL))
   send_to_char("You cannot be cancelled.\n\r",ch);
     else
   send_to_char("You can be cancelled.\n\r",ch);
   
     if (is_clan(ch) && IS_SET(ch->act,PLR_NOOUTOFRANGE))
	send_to_char("You will not attack out of range.\n\r",ch);
     else
     {
       if(is_clan(ch) && !IS_SET(ch->act,PLR_NOOUTOFRANGE))
	 send_to_char("You may attack out of range.\n\r",ch);
     }
    
     if (IS_SET(ch->act,PLR_NOFOLLOW))
   send_to_char("You do not welcome followers.\n\r",ch);
     else
   send_to_char("You accept followers.\n\r",ch);
 }
 
 void do_autoassist(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
     
     if (IS_SET(ch->act,PLR_AUTOASSIST))
     {
       send_to_char("Autoassist removed.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_AUTOASSIST);
     }
     else
     {
       send_to_char("You will now assist when needed.\n\r",ch);
       SET_BIT(ch->act,PLR_AUTOASSIST);
     }
 }
 
 void do_autopeek(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
     
     if (IS_SET(ch->act,PLR_AUTOPEEK))
     {
       send_to_char("Autopeek removed.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_AUTOPEEK);
     }
     else
     {
       send_to_char("You will now peek automatically when looking.\n\r",ch);
       SET_BIT(ch->act,PLR_AUTOPEEK);
     }
     return;
 }

 void do_autoexit(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->act,PLR_AUTOEXIT))
     {
       send_to_char("Exits will no longer be displayed.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_AUTOEXIT);
     }
     else
     {
       send_to_char("Exits will now be displayed.\n\r",ch);
       SET_BIT(ch->act,PLR_AUTOEXIT);
     }
 }
 
 void do_autogold(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->act,PLR_AUTOGOLD))
     {
       send_to_char("Autogold removed.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_AUTOGOLD);
     }
     else
     {
       send_to_char("Automatic gold looting set.\n\r",ch);
       SET_BIT(ch->act,PLR_AUTOGOLD);
     }
 }
 
 void do_autoloot(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->act,PLR_AUTOLOOT))
     {
       send_to_char("Autolooting removed.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_AUTOLOOT);
     }
     else
     {
       send_to_char("Automatic corpse looting set.\n\r",ch);
       SET_BIT(ch->act,PLR_AUTOLOOT);
     }
 }
 
 void do_norescue(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->mhs,MHS_NORESCUE))
     {
       send_to_char("You can no longer be rescued.\n\r",ch);
       REMOVE_BIT(ch->mhs,MHS_NORESCUE);
     }
     else
     {
       send_to_char("You can now be rescued.\n\r",ch);
       SET_BIT(ch->mhs,MHS_NORESCUE);
     }
 }

 void do_full_sac(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->mhs,MHS_FULL_SAC))
     {
       send_to_char("You can no longer sac full containers.\n\r",ch);
       REMOVE_BIT(ch->mhs,MHS_FULL_SAC);
     }
     else
     {
       send_to_char("You can now sac full containers.\n\r",ch);
       SET_BIT(ch->mhs,MHS_FULL_SAC);
     }
 }


 void do_autosac(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->act,PLR_AUTOSAC))
     {
       send_to_char("Autosacrificing removed.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_AUTOSAC);
     }
     else
     {
       send_to_char("Automatic corpse sacrificing set.\n\r",ch);
       SET_BIT(ch->act,PLR_AUTOSAC);
     }
 }
 
 void do_autosplit(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->act,PLR_AUTOSPLIT))
     {
       send_to_char("Autosplitting removed.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_AUTOSPLIT);
     }
     else
     {
       send_to_char("Automatic gold splitting set.\n\r",ch);
       SET_BIT(ch->act,PLR_AUTOSPLIT);
     }
 }
 
 void do_beeptell (CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
 
     if (IS_SET(ch->comm,COMM_TELL_BEEP))     
     {
       send_to_char("Tells will no longer beep.\n\r",ch);
       REMOVE_BIT(ch->comm,COMM_TELL_BEEP); 
     }
     else
     {
       send_to_char("Tells will beep.\n\r",ch);
       SET_BIT(ch->comm,COMM_TELL_BEEP);
     }
 }
 
 void do_brief(CHAR_DATA *ch, char *argument)
 {
     char arg[MAX_INPUT_LENGTH];
     long	flag = DISP_BRIEF_DESCR;

     one_argument( argument, arg );

     if ( !str_prefix(arg,"room") )
        flag = DISP_BRIEF_DESCR;
     else
     if ( !str_prefix(arg,"combat") )
	flag = DISP_BRIEF_COMBAT;
     else
     if ( !str_prefix(arg,"wholist") )
	flag = DISP_BRIEF_WHOLIST;
     else
     if ( !str_prefix(arg,"longeq") )
	flag = DISP_BRIEF_EQLIST;
     else
     if ( !str_prefix(arg, "scan") )
	flag = DISP_BRIEF_SCAN;
     else
     if ( !str_prefix(arg, "chardesc") )
	flag = DISP_BRIEF_CHAR_DESCR;
     else
     if ( !str_prefix(arg, "titles") )
	flag = DISP_NOTITLES;
     else
     if ( !str_prefix(arg, "surname") )
	flag = DISP_SURNAME;
     else
      if( !str_prefix(arg,"olccolor") )
      {
 	flag = MHS_OLC;
 	if( IS_SET(ch->mhs,flag))
 	  REMOVE_BIT(ch->mhs,flag);
 	else
 	  SET_BIT(ch->mhs,flag);
        send_to_char("Ok.\n\r",ch);
	return;
      }
     else
     {
        send_to_char("usage: brief <combat|wholist|longeq|scan|chardesc|titles|surname|olccolor>\n\r",ch);
	return;
     }
     if ( IS_SET(ch->display,flag))
       REMOVE_BIT(ch->display,flag);
     else
       SET_BIT(ch->display,flag);

     send_to_char("Ok.\n\r",ch);

 }
 
 void do_compact(CHAR_DATA *ch, char *argument)
 {
     if (IS_SET(ch->display,DISP_COMPACT))
     {
       send_to_char("Compact mode removed.\n\r",ch);
       REMOVE_BIT(ch->display,DISP_COMPACT);
     }
     else
     {
       send_to_char("Compact mode set.\n\r",ch);
       SET_BIT(ch->display,DISP_COMPACT);
     }
 }
 
 void do_show(CHAR_DATA *ch, char *argument)
 {
     if (IS_SET(ch->display,DISP_SHOW_AFFECTS))
     {
       send_to_char("Affects will no longer be shown in score.\n\r",ch);
       REMOVE_BIT(ch->display,DISP_SHOW_AFFECTS);
     }
     else
     {
       send_to_char("Affects will now be shown in score.\n\r",ch);
       SET_BIT(ch->display,DISP_SHOW_AFFECTS);
     }
 }
 
 void do_prompt(CHAR_DATA *ch, char *argument)
 {
    char buf[MAX_STRING_LENGTH];
  
    if ( argument[0] == '\0' )
    {
   if (IS_SET(ch->display,DISP_PROMPT))
   {
       send_to_char("You will no longer see prompts.\n\r",ch);
       REMOVE_BIT(ch->display,DISP_PROMPT);
   }
   else
   {
       send_to_char("You will now see prompts.\n\r",ch);
       SET_BIT(ch->display,DISP_PROMPT);
   }
        return;
    }
  
    if( !strcmp( argument, "all" ) )
       strcpy( buf, "%h %m %v%c> ");
    else
    {
       if ( strlen(argument) > 50 )
    argument[50] = '\0';
       strcpy( buf, argument );
       smash_tilde( buf );
       if (str_suffix("%c",buf))
   strcat(buf," ");
   
    }
  
    free_string( ch->prompt );
    ch->prompt = str_dup( buf );
    sprintf(buf,"Prompt set to %s\n\r",ch->prompt );
    send_to_char(buf,ch);
    return;
 }
 
 void do_combine(CHAR_DATA *ch, char *argument)
 {
     if (IS_SET(ch->display,DISP_COMBINE))
     {
       send_to_char("Long inventory selected.\n\r",ch);
       REMOVE_BIT(ch->display,DISP_COMBINE);
     }
     else
     {
       send_to_char("Combined inventory selected.\n\r",ch);
       SET_BIT(ch->display,DISP_COMBINE);
     }
 }
 
 void do_noloot(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->act,PLR_CANLOOT))
     {
       send_to_char("Your corpse is now safe from thieves.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_CANLOOT);
     }
     else
     {
       send_to_char("Your corpse may now be looted.\n\r",ch);
       SET_BIT(ch->act,PLR_CANLOOT);
     }
 }
 
 void do_nofollow(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->act,PLR_NOFOLLOW))
     {
       send_to_char("You now accept followers.\n\r",ch);
       REMOVE_BIT(ch->act,PLR_NOFOLLOW);
     }
     else
     {
       send_to_char("You no longer accept followers.\n\r",ch);
       SET_BIT(ch->act,PLR_NOFOLLOW);
       //putting in dismounting
       if( is_mounted(ch) )
       {
         do_dismount(ch," ");
       }
       if(!IS_AFFECTED(ch,AFF_CHARM))
       die_follower( ch );
     }
 }
 
 void do_nosummon(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
     {
       if (IS_SET(ch->imm_flags,IMM_SUMMON))
       {
   send_to_char("You are no longer immune to summon.\n\r",ch);
   REMOVE_BIT(ch->imm_flags,IMM_SUMMON);
       }
       else
       {
   send_to_char("You are now immune to summoning.\n\r",ch);
   SET_BIT(ch->imm_flags,IMM_SUMMON);
       }
     }
     else
     {
       if (IS_SET(ch->act,PLR_NOSUMMON))
       {
   send_to_char("You are no longer immune to summon.\n\r",ch);
   REMOVE_BIT(ch->act,PLR_NOSUMMON);
       }
       else
       {
   send_to_char("You are now immune to summoning.\n\r",ch);
   SET_BIT(ch->act,PLR_NOSUMMON);
       }
     }
 }
 
 void do_nocancel (CHAR_DATA *ch, char *argument)
 {
       if (IS_SET(ch->act,PLR_NOCANCEL)) {
   send_to_char("You are no longer immune to canceling.\n\r",ch);
   REMOVE_BIT(ch->act,PLR_NOCANCEL);
       } else  {
   send_to_char("You are now immune to canceling.\n\r",ch);
   SET_BIT(ch->act,PLR_NOCANCEL);
       }
 }

 void do_nooutofrange (CHAR_DATA *ch, char *argument)
 {
       if (IS_SET(ch->act,PLR_NOOUTOFRANGE)) {
   send_to_char("You may now attack more than 8 levels above you.\n\r",ch);
   REMOVE_BIT(ch->act,PLR_NOOUTOFRANGE);
       } else  {
   send_to_char("You will no longer attack more than 8 levels above you.\n\r",ch);
   SET_BIT(ch->act,PLR_NOOUTOFRANGE);
       }
 }

void do_longeq (CHAR_DATA *ch, char *argument)
{
        if (!IS_SET(ch->display,DISP_BRIEF_EQLIST))
        {
         send_to_char("Short equipment info activated.\n\r",ch);
         SET_BIT(ch->display,DISP_BRIEF_EQLIST);
        }
        else
        {
         send_to_char("Long equipment info activated.\n\r",ch);
         REMOVE_BIT(ch->display, DISP_BRIEF_EQLIST);
	}
}

void do_norecall (CHAR_DATA *ch, char *argument)
{
        if (IS_SET(ch->act,PLR_NOAUTORECALL))
        {
         send_to_char("You will automatically recall if attacked "
                          "when link-dead.\n\r",ch);
         REMOVE_BIT(ch->act,PLR_NOAUTORECALL);
        }
        else
        {
         send_to_char("You will NOT recall if attacked when "
                        "link-dead.\n\r",ch);
         SET_BIT(ch->act,PLR_NOAUTORECALL);
	}
}

void do_nowake (CHAR_DATA *ch, char *argument)
{
        if (IS_SET(ch->act,PLR_NOWAKE))
        {
         send_to_char("You can now be awakened.\n\r",ch);
         REMOVE_BIT(ch->act,PLR_NOWAKE);
        }
        else
        {
         send_to_char("You can NOT be awakened.\n\r",ch);
         SET_BIT(ch->act,PLR_NOWAKE);
	}
}

void do_glance ( CHAR_DATA *ch, char *argument )
 {
     CHAR_DATA *victim;
     char buf  [MAX_STRING_LENGTH];
     char arg [MAX_INPUT_LENGTH];
     int percent;

     if ( ch->desc == NULL )
   return;

     if ( ch->position < POS_SLEEPING )
     {
   send_to_char( "You can't see anything but stars!\n\r", ch );
   return;
     }

     if ( ch->position == POS_SLEEPING )
     {
   send_to_char( "You can't see anything, you're sleeping!\n\r", ch );
   return;
     }

     if ( !check_blind( ch ) )
   return;

     one_argument( argument, arg );

     if ( arg[0] == '\0' )
     {
   send_to_char( "Glance at whom?\n\r", ch);
   return;
     }

     if ( ( victim = get_char_room( ch, arg ) ) != NULL )
   {
     if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE)
	strcpy (buf, victim->long_descr);
     else
     {
        strcpy( buf, PERS(victim, ch, FALSE) );


     strcat (buf, " the ");
     if( !IS_NPC(victim) )
     {
       if (IS_SET(victim->act,PLR_WERE))
  	strcat (buf,"garou ");
       if (IS_SET (victim->act,PLR_VAMP))
  	strcat (buf,"nosferatu ");
       if (IS_SET (victim->act,PLR_MUMMY))
  	strcat (buf,"mummified ");
     }
        strcat (buf,race_table[victim->race].name);
     }

     if ( victim->max_hit > 0 )
   percent = ( 100 * victim->hit ) / UMAX(1,victim->max_hit);
     else
   percent = -1;

     if (percent >= 100)
   strcat( buf, " is in excellent condition.\n\r");
     else if (percent >= 90)
   strcat( buf, " has a few scratches.\n\r");
     else if (percent >= 75)
   strcat( buf," has some small wounds and bruises.\n\r");
     else if (percent >=  50)
   strcat( buf, " has quite a few wounds.\n\r");
     else if (percent >= 30)
   strcat( buf, " has some big nasty wounds and scratches.\n\r");
     else if (percent >= 15)
   strcat ( buf, " looks pretty hurt.\n\r");
     else if (percent >= 0 )
   strcat (buf, " is in awful condition.\n\r");
     else
   strcat(buf, " is bleeding to death.\n\r");

     buf[0] = UPPER(buf[0]);
     send_to_char( buf, ch );
   }
     else
   {
   send_to_char( "You can't seem to find them.\n\r", ch);
   }

   return;
}

 
 void do_look( CHAR_DATA *ch, char *argument )
 {
     char buf  [MAX_STRING_LENGTH];
     char arg1 [MAX_INPUT_LENGTH];
     char arg2 [MAX_INPUT_LENGTH];
     char arg3 [MAX_INPUT_LENGTH];
     EXIT_DATA *pexit;
     CHAR_DATA *victim;
     OBJ_DATA *obj;
     char *pdesc;
     int door;
     int number,count;
 
     if ( ch->desc == NULL )
   return;
 
     if ( ch->position < POS_SLEEPING )
     {
   send_to_char( "You can't see anything but stars!\n\r", ch );
   return;
     }
 
     if ( ch->position == POS_SLEEPING )
     {
   send_to_char( "You can't see anything, you're sleeping!\n\r", ch );
   return;
     }
 
     if ( !check_blind( ch ) )
   return;
 
     if ( !IS_NPC(ch)
     &&   !IS_SET(ch->act, PLR_HOLYLIGHT)
     &&   room_is_dark( ch->in_room ) )
     {
   send_to_char( "It is pitch black ... \n\r", ch );
   show_char_to_char( ch->in_room->people, ch );
   return;
     }
 
     argument = one_argument( argument, arg1 );
     argument = one_argument( argument, arg2 );
     number = number_argument(arg1,arg3);
     count = 0;
 
     if ( arg1[0] == '\0' || !str_cmp( arg1, "auto" ) )
     {
   /* 'look' or 'look auto' */
   sprintf(buf,"{c%s{x", ch->in_room->name );
   send_to_char( buf, ch );
   
   if (IS_IMMORTAL (ch) && IS_SET (ch->display,DISP_DISP_VNUM)) {
     char temp_buf[50];      
     
     sprintf (temp_buf," [%d] ",ch->in_room->vnum);
     send_to_char (temp_buf,ch);
   }
   
   send_to_char( "\n\r", ch );
 
   if ( arg1[0] == '\0'
   || ( !IS_NPC(ch) && !IS_SET(ch->display, DISP_BRIEF_DESCR)))
   {
       send_to_char( "  ",ch);
       send_to_char( ch->in_room->description, ch );
   //}

     if ( IS_OUTSIDE(ch) && (number_range(0,100) < 10 ) )
     {
       switch(weather_info.sky)
	{
	case SKY_CLOUDLESS:
          if (weather_info.change >= 0)
	  {
          send_to_char("{bA warm southerly breeze warms your chilled bones.{x\r\n",ch);
	  } 
	  else
	  {
          send_to_char("{bA cold northerly wind howls around you.\r\n{x",ch);
	  }
          break;
	case SKY_CLOUDY:
	  if (weather_info.change >= 0)
	  {
	  send_to_char("{bThe clouds seem to be breaking up{x\r\n",ch);
          }
	  else
	  {
	  send_to_char("{bThe clouds seem to be thickening, looks like rains coming.{x\r\n",ch);
	  }
	  break;
	case SKY_RAINING:
          if( weather_info.change >= 0 )
	  {
          send_to_char("{bA warm tropical rain falls from the heavens.{x\r\n",ch);
	  }
	  else
	  {
          send_to_char("{bA cold northerly wind blows the rain into your face.{x\r\n",ch);
	  }
       	  break;
	case SKY_LIGHTNING:
          if (weather_info.change >= 0 )
	  {
          send_to_char("{YWHOA!{x{b That lightning looks dangerous.  Thankfully the worse has passed.{x\r\n",ch);
	  }
	  else
	  {
          send_to_char("{YWHOA!{x{b That lightning looks very dangerous.{x\r\n",ch);
	  }
          break;
	default:
	  break;
	}
     } //end of weather messages
   } //this was added when the room desc was added

         if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT) )
   {
       send_to_char("\n\r",ch);
             do_exits( ch, "auto" );
   }
 
   show_list_to_char( ch->in_room->contents, ch, FALSE, FALSE, FALSE );
   show_char_to_char( ch->in_room->people,   ch );
   return;
     }
 
     if ( !str_cmp( arg1, "i" ) || !str_cmp( arg1, "in" ) )
     {
   /* 'look in' */
   if ( arg2[0] == '\0' )
   {
       send_to_char( "Look in what?\n\r", ch );
       return;
   }
 
   if ( ( obj = get_obj_here( ch, arg2 ) ) == NULL )
   {
       send_to_char( "You do not see that here.\n\r", ch );
       return;
   }
 
   switch ( obj->item_type )
   {
   default:
       send_to_char( "That is not a container.\n\r", ch );
       break;
 
   case ITEM_DRINK_CON:
       if ( obj->value[1] <= 0 )
       {
     send_to_char( "It is empty.\n\r", ch );
     break;
       }
 
       sprintf( buf, "It's %s full of a %s liquid.\n\r",
     obj->value[1] <     obj->value[0] / 4
         ? "less than" :
     obj->value[1] < 3 * obj->value[0] / 4
         ? "about"     : "more than",
     liq_table[obj->value[2]].liq_color
     );
 
       send_to_char( buf, ch );
       break;
 
   case ITEM_CONTAINER:
   case ITEM_CORPSE_NPC:
   case ITEM_CORPSE_PC:
   case ITEM_FORGE:
       if ( IS_SET(obj->value[1], CONT_CLOSED) && obj->item_type != ITEM_FORGE )
       {
     send_to_char( "It is closed.\n\r", ch );
     break;
       }
 
       act( "$p contains:", ch, obj, NULL, TO_CHAR, FALSE );
       show_list_to_char( obj->contains, ch, TRUE, TRUE, FALSE );
       break;
   }
   return;
     }
 
     if ( ( victim = get_char_room( ch, arg1 ) ) != NULL )
     {
        show_char_to_char_1( victim, ch );
        return;
     }
 
     for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
     {

   if ( can_see_obj( ch, obj ) )
   {
       pdesc = get_extra_descr( arg3, obj->extra_descr );
       if ( pdesc != NULL )
         if (++count == number)
         {
         send_to_char( pdesc, ch );
         /* LORE */
         if (!IS_NPC(ch) &&
       number_percent( ) < get_skill(ch,gsn_lore))
           {
       if ( ( number_percent( ) * number_percent( ) ) < 40 
	    && !IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT))
         {
	   if(obj->pIndexData->cost == obj->cost)
	   {
            obj->cost += ( get_skill(ch,gsn_lore) * 
             0.001 * obj->cost);
           send_to_char( "Your understanding of the lore behind it increases its worth!\n\r",  ch );
	   }
         }
       if (ch->mana >= 20){
       spell_identify(gsn_lore,
           (4* obj->level)/3,ch,obj,TARGET_OBJ);
       ch->mana -= 20;
       check_improve(ch,gsn_lore,TRUE,4);}
           } 
         return;
         }
       else continue;
       pdesc = get_extra_descr( arg3, obj->pIndexData->extra_descr );
       if ( pdesc != NULL )
         if (++count == number)
         { 
         send_to_char( pdesc, ch );
         /* LORE */
         if (!IS_NPC(ch) &&
       number_percent( ) <= get_skill(ch,gsn_lore))
           {
       if ( ( number_percent( ) * number_percent( ) ) < 40 
	    && !IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT))
         {
           if(obj->pIndexData->cost == obj->cost)
           {
           obj->cost += ( get_skill(ch,gsn_lore) *
             0.001 * obj->cost);
           send_to_char( "Your understanding of the lore behind it increases its worth!\n\r",  ch );
	   }
         }
       if(ch->mana >= 20){
       spell_identify(gsn_lore,
           (4* obj->level)/3,ch,obj,TARGET_OBJ);
       ch->mana -= 20;
       check_improve(ch,gsn_lore,TRUE,4);}
           }         
         return;
         }
       else continue;
 
       if ( is_name( arg3, obj->name ) )
         if (++count == number)
         {
         
           if (IS_IMMORTAL (ch) && IS_SET(ch->display,DISP_DISP_VNUM)) {
             sprintf (buf,"%s [%d]\n\r",obj->description,obj->pIndexData->vnum);
           } else {
             sprintf (buf,"%s\n\r",obj->description);
           }        
           send_to_char( obj->description, ch );          
           send_to_char( "\n\r",ch);
         /* LORE */
         if (!IS_NPC(ch) &&
       number_percent( ) <= get_skill(ch,gsn_lore))
           {
       if ( ( number_percent( ) * number_percent( ) ) < 40 
	    && !IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT))
         {
           if(obj->pIndexData->cost == obj->cost)
           {

           obj->cost += ( get_skill(ch,gsn_lore) *
             0.001 * obj->cost);
           send_to_char( "Your understanding of the lore behind it increases its worth!\n\r",  ch );
	   }
         }
                         if(ch->mana >= 20){
       spell_identify(gsn_lore,
           (4* obj->level)/3,ch,obj,TARGET_OBJ);
       ch->mana -= 20;
       check_improve(ch,gsn_lore,TRUE,4);}
           }           
           return;
         }
   }
     }
 
     for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
     {
   if ( can_see_obj( ch, obj ) )
   {
       pdesc = get_extra_descr( arg3, obj->extra_descr );
       if ( pdesc != NULL )
         if (++count == number)
         {
         send_to_char( pdesc, ch );
         return;
         }
 
       pdesc = get_extra_descr( arg3, obj->pIndexData->extra_descr );
       if ( pdesc != NULL )
         if (++count == number)
         {
         send_to_char( pdesc, ch );
         return;
         }
   }
 
   if ( is_name( arg3, obj->name ) )
       if (++count == number)
       {
         send_to_char( obj->description, ch );
         send_to_char("\n\r",ch);
         return;
       }
     }
     
     if (count > 0 && count != number)
     {
       if (count == 1)
           sprintf(buf,"You only see one %s here.\n\r",arg3);
       else
           sprintf(buf,"You only see %d %s's here.\n\r",count,arg3);
       
       send_to_char(buf,ch);
       return;
     }
 
     pdesc = get_extra_descr( arg1, ch->in_room->extra_descr );
     if ( pdesc != NULL )
     {
   send_to_char( pdesc, ch );
   return;
     }
 
          if ( !str_cmp( arg1, "n" ) || !str_cmp( arg1, "north" ) ) door = 0;
     else if ( !str_cmp( arg1, "e" ) || !str_cmp( arg1, "east"  ) ) door = 1;
     else if ( !str_cmp( arg1, "s" ) || !str_cmp( arg1, "south" ) ) door = 2;
     else if ( !str_cmp( arg1, "w" ) || !str_cmp( arg1, "west"  ) ) door = 3;
     else if ( !str_cmp( arg1, "u" ) || !str_cmp( arg1, "up"    ) ) door = 4;
     else if ( !str_cmp( arg1, "d" ) || !str_cmp( arg1, "down"  ) ) door = 5;
     else
     {
   send_to_char( "You do not see that here.\n\r", ch );
   return;
     }
 
     /* 'look direction' */
     if ( ( pexit = ch->in_room->exit[door] ) == NULL )
     {
   send_to_char( "Nothing special there.\n\r", ch );
   return;
     }
  
     if ( IS_SET(pexit->exit_info,EX_SECRET)  )
     {
    send_to_char("Nothing special there.\n\r", ch );
	return;
     }

    /* send_to_char( "Nothing special there.\n\r", ch ); */
 
   if ( IS_SET(pexit->exit_info, EX_CLOSED) )
   {
     if ( pexit->keyword    != NULL
       &&   pexit->keyword[0] != '\0'
       &&   pexit->keyword[0] != ' ' )
       {
         act( "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR, FALSE );
       } else {
         act( "The exit is closed.", ch, NULL, pexit->keyword, TO_CHAR, FALSE );
       }
   } else {
      ROOM_INDEX_DATA *temp_room;
      int temp_brief;
      
      temp_brief = IS_SET(ch->display, DISP_BRIEF_DESCR);
      SET_BIT(ch->display, DISP_BRIEF_DESCR);
      temp_room = ch->in_room;
      ch->in_room = ch->in_room->exit[door]->u1.to_room;
      if (ch->in_room != NULL) {
        do_look (ch,"auto");
      } else {
        bug ("NULL in do_look.",0);
      }
      ch->in_room = temp_room;
      if (!temp_brief) REMOVE_BIT (ch->display, DISP_BRIEF_DESCR);
    } 
 
     return;
 }
 
 /* RT added back for the hell of it */
 void do_read (CHAR_DATA *ch, char *argument )
 {
     do_look(ch,argument);
 }
 
 void do_examine( CHAR_DATA *ch, char *argument )
 {
     char buf[MAX_STRING_LENGTH];
     char arg[MAX_INPUT_LENGTH];
     OBJ_DATA *obj;
 
     one_argument( argument, arg );
 
     if ( arg[0] == '\0' )
     {
   send_to_char( "Examine what?\n\r", ch );
   return;
     }
 
     do_look( ch, arg );
 
     if ( ( obj = get_obj_here( ch, arg ) ) != NULL )
     {
   switch ( obj->item_type )
   {
   default:
       break;
   
/*   case ITEM_JUKEBOX:
       do_play(ch,"list");
       break;
 */ 
   case ITEM_MONEY:
       if (obj->value[0] == 0)
       {
     if (obj->value[1] == 0)
         sprintf(buf,"Odd...there's no coins in the pile.\n\r");
     else if (obj->value[1] == 1)
         sprintf(buf,"Wow. One gold coin.\n\r");
     else
         sprintf(buf,"There are %d gold coins in the pile.\n\r",
       obj->value[1]);
       }
       else if (obj->value[1] == 0)
       {
     if (obj->value[0] == 1)
         sprintf(buf,"Wow. One silver coin.\n\r");
     else
         sprintf(buf,"There are %d silver coins in the pile.\n\r",
       obj->value[0]);
       }
       else
     sprintf(buf,
         "There are %d gold and %d silver coins in the pile.\n\r",
         obj->value[1],obj->value[0]);
       send_to_char(buf,ch);
       break;
 
   case ITEM_DRINK_CON:
   case ITEM_CONTAINER:
   case ITEM_CORPSE_NPC:
   case ITEM_CORPSE_PC:
   case ITEM_FORGE:
       sprintf(buf,"in %s",argument);
       do_look( ch, buf );
   }
     }
 
     return;
 }
 
 
 
 /*
  * Thanks to Zrin for auto-exit part.
  */
 void do_exits( CHAR_DATA *ch, char *argument )
 {
     extern char * const dir_name[];
     char buf[MAX_STRING_LENGTH];
     EXIT_DATA *pexit;
     bool found;
     bool fAuto;
     int door;
 
     fAuto  = !str_cmp( argument, "auto" );
 
     if ( !check_blind( ch ) )
   return;
 
     if (fAuto)
   sprintf(buf,"[{WExits{x: {g");
     else if (IS_IMMORTAL(ch))
   sprintf(buf,"Obvious exits from room %d: {g\n\r",ch->in_room->vnum);
     else
   sprintf(buf,"Obvious exits: {g\n\r");
     found = FALSE;
     for ( door = 0; door <= 5; door++ )
     {
   if ( ( pexit = ch->in_room->exit[door] ) != NULL
   &&   pexit->u1.to_room != NULL
   &&   can_see_room(ch,pexit->u1.to_room) 
   &&   is_room_clan(ch,pexit->u1.to_room)
   &&   !IS_SET(pexit->exit_info, EX_CLOSED)
   &&   !IS_SET(pexit->exit_info, EX_CONCEALED)
   &&	!IS_SET(pexit->exit_info, EX_SECRET) )
   {
       found = TRUE;
       if ( fAuto )
       {
     strcat( buf, " " );
     strcat( buf, dir_name[door] );
       }
       else
       {
     sprintf( buf + strlen(buf), "%-5s - %s",
         capitalize( dir_name[door] ),
         (room_is_dark( pexit->u1.to_room )  && !IS_SET(ch->act, PLR_HOLYLIGHT))
       ?  "Too dark to tell"
       : pexit->u1.to_room->name
         );
 
     if (IS_IMMORTAL (ch) && IS_SET (ch->display,DISP_DISP_VNUM)) {
       char temp_buf[50];
     
       sprintf (temp_buf," [%d] ",pexit->u1.to_room->vnum);
       strcat (buf,temp_buf);
     }                
     strcat (buf,"\n\r");
           
       }
   }
     }
 
     if ( !found )
   strcat( buf, fAuto ? " none" : "None.\n\r" );
 
     if ( fAuto )
   strcat( buf, "{x]\n\r" );
 
     send_to_char( buf, ch );
     send_to_char( "{x", ch );
     return;
 }
 
 void do_worth( CHAR_DATA *ch, char *argument )
 {
     char buf[MAX_STRING_LENGTH];
 
     if (IS_NPC(ch))
     {
   sprintf(buf,"You have %ld {Ygold{x and %ld {Wsilver{x.\n\r",
       ch->gold,ch->silver);
   send_to_char(buf,ch);
   return;
     }
 
    sprintf(buf, 
    "You have %ld gold, %ld silver, and %d experience (%d exp to level).\n\r",
   ch->gold, ch->silver,ch->exp,
   (ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp);
 
     send_to_char(buf,ch);
 
     return;
 }


void do_attributes( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_INPUT_LENGTH];

     sprintf( buf, "Str: %d/%d Int: %d/%d Wis: %d/%d Soc: %d/%d\n\r"
	"Dex: %d/%d Agt: %d/%d End: %d/%d Con: %d/%d\n\r",
   ch->perm_stat[STAT_STR],
   get_curr_stat(ch,STAT_STR),
   ch->perm_stat[STAT_INT],
   get_curr_stat(ch,STAT_INT),
   ch->perm_stat[STAT_WIS],
   get_curr_stat(ch,STAT_WIS),
   ch->perm_stat[STAT_SOC],
   get_curr_stat(ch,STAT_SOC),
   ch->perm_stat[STAT_DEX],
   get_curr_stat(ch,STAT_DEX),
   ch->perm_stat[STAT_AGT],
   get_curr_stat(ch,STAT_AGT),
   ch->perm_stat[STAT_END],    
   get_curr_stat(ch,STAT_END),
   ch->perm_stat[STAT_CON],
   get_curr_stat(ch,STAT_CON) );

   if ( argument[0] == '\0' )
   {
      send_to_char("Your attributes are:\n\r",ch);
      send_to_char(buf,ch);
      return;
   }
   else
   if ( !str_cmp(argument,"say") )
   {
      char buf2[MAX_STRING_LENGTH];

      sprintf(buf2,"$n says 'My stats:\n\r%s'",buf);
      act(buf2,ch,NULL,NULL,TO_ROOM,TRUE);

      sprintf(buf2,"You say 'My stats:\n\r%s'",buf);
      act(buf2,ch,NULL,NULL,TO_CHAR,TRUE);
      return;
   }
  return;
}

void do_cscore( CHAR_DATA *ch, char *argument )
{
  char buf[MAX_STRING_LENGTH];

     if(!IS_NPC(ch) && is_clan(ch))
	{
	sprintf( buf, "Kills: Lower: %d Equal: %d Greater: %d\n\r", 
		ch->pcdata->killer_data[PC_LOWER_KILLS],
		ch->pcdata->killer_data[PC_EQUAL_KILLS],
                ch->pcdata->killer_data[PC_GREATER_KILLS]);
	send_to_char(buf, ch);
	if (ch->pcdata->steal_data[PC_STOLEN_ITEMS] > 0
	    || ch->pcdata->steal_data[PC_STOLEN_GOLD] > 0) 
	{
	sprintf( buf, "Stolen: %ld items %ld gold",  
		ch->pcdata->steal_data[PC_STOLEN_ITEMS],
		ch->pcdata->steal_data[PC_STOLEN_GOLD]); 
	send_to_char(buf, ch);
	}
	if (ch->pcdata->steal_data[PC_SLICES] > 0)
	{
	sprintf( buf, "Slices: %ld  ", 
		ch->pcdata->steal_data[PC_SLICES]);
	send_to_char(buf, ch);
	}
	if( ch->pcdata->outcT > 0 || ch->pcdata->ruffT )
	{
	  sprintf( buf, "Outcast ticks: %d  Ruffian ticks: %d\n\r",
	  ch->pcdata->outcT,ch->pcdata->ruffT);
	  send_to_char(buf,ch);
	}
        else
        { send_to_char("\n\r",ch); }
      }
      else
       { send_to_char("You're not clanned.\n\r", ch); }
     return;
}

void do_score( CHAR_DATA *ch, char *argument )
{
     char buf[MAX_STRING_LENGTH];
     ROOM_INDEX_DATA *location; 
     int i,percent;
     char wound[100];
     char mental[100];
     char moves[100];

      if (ch->max_hit > 0)
    percent = ch->hit * 100 / ch->max_hit;
      else
    percent = -1;

      if (percent >= 100)
    sprintf(wound,"You are in excellent condition.\n\r");
      else if (percent >= 90)
    sprintf(wound,"You have a few scratches.\n\r");
      else if (percent >= 75)
    sprintf(wound,"You have some small wounds and bruises.\n\r");
      else if (percent >= 50)
    sprintf(wound,"You have quite a few wounds.\n\r");
      else if (percent >= 30)
    sprintf(wound,"You have some big nasty wounds and scratches.\n\r");
      else if (percent >= 15)
    sprintf(wound,"You are pretty hurt.\n\r");
      else if (percent >= 0)
    sprintf(wound,"You are in awful condition.\n\r");
      else
    sprintf(wound,"You are bleeding to death.\n\r");

      if (ch->max_mana > 0)
    percent = ch->mana * 100 / ch->max_mana;
      else
    percent = -1;

      if (is_affected(ch,gsn_rage))
    sprintf(mental,"You are in battle-rage.\n\r");
      else if (percent >= 100)
    sprintf(mental,"You are mentally fit.\n\r");
      else if (percent >= 90)
    sprintf(mental,"You are a bit slow.\n\r");
      else if (percent >= 75)
    sprintf(mental,"You have some mental lapses.\n\r");
      else if (percent >= 50)
    sprintf(mental,"You are quite drained.\n\r");
      else if (percent >= 30)
    sprintf(mental,"You feel dazed.\n\r");
      else if (percent >= 15)
    sprintf(mental,"You are nearly spent.\n\r");
      else if (percent >= 0)
    sprintf(mental,"You are brain dead.\n\r");
      else
    sprintf(mental,"You are helpless.\n\r");

      if (ch->max_move > 0)
    percent = ch->move * 100 / ch->max_move;
      else
    percent = -1;

      if (percent >= 100)
    sprintf(moves,"You are full of energy.\n\r");
      else if (percent >= 90)
    sprintf(moves,"You are energetic.\n\r");
      else if (percent >= 75)
    sprintf(moves,"You are breathing hard.\n\r");
      else if (percent >= 50)
    sprintf(moves,"Your heart is pounding.\n\r");
      else if (percent >= 30)
    sprintf(moves,"You feel winded.\n\r");
      else if (percent >= 15)
    sprintf(moves,"You are cramping up.\n\r");
      else if (percent >= 0)
    sprintf(moves,"You are exhausted.\n\r");
      else
    sprintf(moves,"You are motionless.\n\r");



 /*
     sprintf( buf,
   "You are %s%s%s, level %d(%d), %d years old (%d hours).\n\r",
   IS_SET(ch->mhs,MHS_SAVANT) ? "a Savant" : ch->name,
   ch->level, IS_NPC(ch) ? 0 : ch->pcdata->debit_level, get_age(ch),
   ( ch->played + (int) (current_time - ch->logon) ) / 3600 );
 */

     sprintf( buf,
   "You are %s %s, %d years old (%d hours).\n\r%s%s%s",
   ch->name, IS_NPC(ch) ? "" : ch->pcdata->surname,
   get_age(ch), ( ch->played + (int) (current_time - ch->logon) ) / 3600,
   wound, mental, moves );
     send_to_char( buf, ch );

   if ( ch->position == POS_FIGHTING )
   {
     send_to_char("{RStats not available during combat.{x\r\n",ch);
   }
   else
   {
     sprintf(buf, "Your have %d of %d {Yhit points{x, %d of %d {Gmana{x, %d of %d {Bmoves{x.\n\r",
      ch->hit,ch->max_hit,ch->mana,ch->max_mana,ch->move,ch->max_move);
     send_to_char(buf, ch);
   }

     if ( get_trust( ch ) != ch->level )
     {
   sprintf( buf, "You are trusted at level %d.\n\r",
       get_trust( ch ) );
   send_to_char( buf, ch );
     }
 
     sprintf(buf, "Race: %s  Sex: %s  Class: %s %s  Kit: %s\n\r",
   race_table[ch->race].name,
   ch->sex == 0 ? "sexless" : ch->sex == 1 ? "male" : "female",
   IS_NPC(ch) ? "" : 
      ( class_table[ch->class].reclass ?
       class_table[ch->pcdata->old_class].name : "" ),
   IS_NPC(ch) ? "mobile" : class_table[ch->class].name,
   !ch->kit ? "none" : kit_table[ch->kit].name );
     send_to_char(buf,ch);
  
   if ( !IS_NPC(ch) && ( ch->practice != 0 || ch->train != 0 || 
	ch->skill_points != 0 || ch->pcdata->bounty != 0 ) )
   {
     sprintf( buf,
   "Trains: %d  Practices: %d  Skill Points: %d  Bounty: %ld ",
   ch->train, ch->practice, ch->skill_points, ch->pcdata->bounty );
     send_to_char( buf, ch );
     send_to_char("\n\r",ch);
   }

     if(!IS_NPC(ch) && IS_SET(ch->mhs,MHS_HIGHLANDER))
     {
	sprintf(buf,"Highlander Kills: %d  By Your Hand: %d\n\r",
	       ch->pcdata->highlander_data[ALL_KILLS],
               ch->pcdata->highlander_data[REAL_KILLS]);
	send_to_char(buf,ch);
     }

     sprintf( buf,
   "You are carrying %d.%d/%d.%d items, %d%% weight capacity.\n\r",
   ch->carry_number / 10, ch->carry_number % 10,
   can_carry_n(ch) /10, can_carry_n(ch) % 10,
   (get_carry_weight(ch)*100)/can_carry_w(ch) );
     send_to_char( buf, ch );
 
     sprintf( buf,
"Str: %d/%d Int: %d/%d Wis: %d/%d Soc: %d/%d\n\r"
"Dex: %d/%d Agt: %d/%d End: %d/%d Con: %d/%d\n\r",
   ch->perm_stat[STAT_STR],      
   get_curr_stat(ch,STAT_STR),       
   ch->perm_stat[STAT_INT],
   get_curr_stat(ch,STAT_INT),
   ch->perm_stat[STAT_WIS],
   get_curr_stat(ch,STAT_WIS),
   ch->perm_stat[STAT_SOC],
   get_curr_stat(ch,STAT_SOC),
   ch->perm_stat[STAT_DEX],
   get_curr_stat(ch,STAT_DEX),
   ch->perm_stat[STAT_AGT],
   get_curr_stat(ch,STAT_AGT),
   ch->perm_stat[STAT_END],         
   get_curr_stat(ch,STAT_END),
   ch->perm_stat[STAT_CON],   
   get_curr_stat(ch,STAT_CON) );
     send_to_char( buf, ch );
 
     sprintf( buf,
   "You have %d exp, %ld gold, %ld silver.\n\r",
   ch->exp,  ch->gold, ch->silver );
     send_to_char( buf, ch );

     if ( ch->class == class_lookup("paladin") && !IS_NPC(ch) )
     {
	sprintf(buf,"Abolish Disease Status: %s (%d ticks)\n",
		 ch->pcdata->abolish_timer > 0 ? "unavailable" : "ready",
		ch->pcdata->abolish_timer );
	send_to_char(buf,ch);
    }

     /* RT shows exp to level */
     if (!IS_NPC(ch) && ch->level < LEVEL_HERO)
     {
       sprintf (buf, 
   "You need %d exp to level.\n\r",
   ((ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp));
       send_to_char( buf, ch );
      }
 
     sprintf( buf, "Wimpy set to %d percent.\n\r", ch->wimpy );
     send_to_char( buf, ch );

     if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10 )
	 send_to_char("You are drunk.\n\r",ch);

     if ( !IS_NPC(ch) && IS_SET(ch->act,PLR_VAMP) )
     {
	if ( ch->pcdata->condition[COND_THIRST] == 0 ||
	     ch->pcdata->condition[COND_HUNGER] == 0 )
		 send_to_char("Your throat aches for blood.\n\r",ch);
     }
     else
     {
     if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] ==  0 )
   send_to_char( "You are thirsty.\n\r", ch );
     if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HUNGER]   ==  0 )
   send_to_char( "You are hungry.\n\r",  ch );
     }

     switch ( ch->position )
     {
     case POS_DEAD:     
   send_to_char( "You are DEAD!!\n\r",             ch );
   break;
     case POS_MORTAL:
   send_to_char( "You are mortally wounded.\n\r",  ch );
   break;
     case POS_INCAP:
   send_to_char( "You are incapacitated.\n\r",     ch );
   break;
     case POS_STUNNED:
   send_to_char( "You are stunned.\n\r",           ch );
   break;
     case POS_SLEEPING:
   send_to_char( "You are sleeping.\n\r",          ch );
   break;
     case POS_RESTING:
   send_to_char( "You are resting.\n\r",           ch );
   break;
     case POS_STANDING:
   send_to_char( "You are standing.\n\r",          ch );
   break;
     case POS_FIGHTING:
   send_to_char( "You are fighting.\n\r",          ch );
   break;
     }

     if ( is_mounted(ch) )
	 send_to_char("You are mounted.\n\r",ch);
     if ( ch->passenger != NULL )
	 send_to_char("You are carrying a passenger.\n\r",ch);

  strcpy(buf,"Saving Throw Adjustment: ");
  if ( ch->saving_throw < -18 )
  { strcat(buf,"godlike\n\r"); }
  else if(ch->saving_throw < -15)
  { strcat(buf,"excellent\n\r"); }
  else if(ch->saving_throw < -12)
  { strcat(buf,"good\n\r"); }
  else if(ch->saving_throw < -9)
  { strcat(buf,"fair\n\r"); }
  else if(ch->saving_throw < -6)
  { strcat(buf,"poor\n\r"); }
  else if(ch->saving_throw < -3)
  { strcat(buf,"horrible\n\r"); }
  else
  { strcat(buf,"non existent\n\r"); }
  send_to_char(buf,ch);

     if ( ch->species_enemy )
     {
  sprintf(buf,"Species Enemy: %s\n\r", race_table[ch->species_enemy].name);
  send_to_char(buf,ch);
     }

/* Enemy lists killed by NIGHTDAGGER on 04/25/2003 */
/*
     if (!IS_NPC(ch) && is_clan(ch))
     {
	if(IS_SET(ch->mhs,MHS_WARLOCK_ENEMY) || 
	   IS_SET(ch->mhs,MHS_ZEALOT_ENEMY) ||
	   IS_SET(ch->mhs,MHS_HONOR_ENEMY) ||
	   IS_SET(ch->mhs,MHS_POSSE_ENEMY))
	{
           sprintf(buf,"Enemy of: ");
	   if (IS_SET(ch->mhs,MHS_POSSE_ENEMY))
	      strcat(buf,"Posse ");
	   if (IS_SET(ch->mhs,MHS_WARLOCK_ENEMY))
	      strcat(buf,"Warlock ");
	   if (IS_SET(ch->mhs,MHS_ZEALOT_ENEMY))
	      strcat(buf,"Zealot ");
	   if (IS_SET(ch->mhs,MHS_HONOR_ENEMY))
	      strcat(buf,"Honor");
	   strcat(buf,"\n\r");
           send_to_char(buf,ch);
	}
     }
*/
     for (i = 0; i < 4; i++)
     {
   char * temp;
 
   switch(i)
   {
       case(AC_PIERCE):    temp = "piercing";      break;
       case(AC_BASH):      temp = "bashing";       break;
       case(AC_SLASH):     temp = "slashing";      break;
       case(AC_EXOTIC):    temp = "magic";         break;
       default:            temp = "error";         break;
   }
   
   send_to_char("You are ", ch);
 
   if      (GET_AC(ch,i) >=  101 ) 
       sprintf(buf,"hopelessly vulnerable to %s.\n\r",temp);
   else if (GET_AC(ch,i) >= 75) 
       sprintf(buf,"defenseless against %s.\n\r",temp);
   else if (GET_AC(ch,i) >= 50)
       sprintf(buf,"barely protected from %s.\n\r",temp);
   else if (GET_AC(ch,i) >= 25)
       sprintf(buf,"slightly armored against %s.\n\r",temp);
   else if (GET_AC(ch,i) >= 0)
       sprintf(buf,"somewhat armored against %s.\n\r",temp);
   else if (GET_AC(ch,i) >= -25)
       sprintf(buf,"armored against %s.\n\r",temp);
   else if (GET_AC(ch,i) >= -50)
       sprintf(buf,"well-armored against %s.\n\r",temp);
   else if (GET_AC(ch,i) >= -75)
       sprintf(buf,"very well-armored against %s.\n\r",temp);
   else if (GET_AC(ch,i) >= -100)
       sprintf(buf,"heavily armored against %s.\n\r",temp);
   else if (GET_AC(ch,i) >= -125)
       sprintf(buf,"superbly armored against %s.\n\r",temp);
   else if (GET_AC(ch,i) >= -150)
       sprintf(buf,"almost invulnerable to %s.\n\r",temp);
   else
       sprintf(buf,"divinely armored against %s.\n\r",temp);
 
   send_to_char(buf,ch);
     }
 
 
     /* RT wizinvis and holy light */
     if ( IS_IMMORTAL(ch))
     {
       send_to_char("Holy Light: ",ch);
       if (IS_SET(ch->act,PLR_HOLYLIGHT))
   send_to_char("on",ch);
       else
   send_to_char("off",ch);
  
       if (ch->invis_level)
       {
   sprintf( buf, "  Invisible: level %d",ch->invis_level);
   send_to_char(buf,ch);
       }
 
       if (ch->incog_level)
       {
   sprintf(buf,"  Incognito: level %d",ch->incog_level);
   send_to_char(buf,ch);
       }
       send_to_char("\n\r",ch);
     }
/* 
     if ( ch->level >= 15 )
     {
	if (get_eq_char(ch,WEAR_SECOND) == NULL)
           sprintf( buf, "Hitroll: %d  Damroll: %d.\n\r",
                   GET_HITROLL(ch), GET_DAMROLL(ch) );
	else
           sprintf( buf, "Hitroll: %d/%d  Damroll: %d/%d.\n\r",
                   GET_HITROLL(ch),GET_SECOND_HITROLL(ch), 
		   GET_DAMROLL(ch),GET_SECOND_DAMROLL(ch) );
        send_to_char( buf, ch );
     }
 */    
     send_to_char( "You are ", ch );
    if ( ch->alignment >  900 ) send_to_char( "an angelic ",ch);
     else if ( ch->alignment >  700 ) send_to_char( "a saintly ",ch );
     else if ( ch->alignment >  350 ) send_to_char( "a good ",ch );
     else if ( ch->alignment >  150 ) send_to_char( "a kind ",ch );
     else if ( ch->alignment > -150 ) send_to_char( "a neutral ", ch );
     else if ( ch->alignment > -350 ) send_to_char( "a mean ", ch );
     else if ( ch->alignment > -700 ) send_to_char( "an evil ", ch );
     else if ( ch->alignment > -900 ) send_to_char( "a demonic ", ch );
     else                             send_to_char( "a satanic ", ch );


     sprintf(buf,"follower of %s.  ", IS_NPC(ch) ? "yourself." :
	deity_table[ch->pcdata->deity].name );
     send_to_char(buf,ch);

   sprintf( buf, "Sac Points: %d\n\r", IS_NPC(ch) ? 0 : ch->pcdata->sac );
   send_to_char( buf, ch );
 
     if ( ch->class == class_lookup("elementalist"))
     {
        if (ch->pcdata->node != 0)
        {
	   location = get_room_index(ch->pcdata->node);
           sprintf( buf, "Node Location: %s in %s\n\r",
              location->name,location->area->name );
           send_to_char( buf, ch );
        }
     }

     if (IS_SET(ch->mhs,MHS_SHAPEMORPHED))
     {
	sprintf( buf, "You are morphed into: %s\n\r",
	   ch->long_descr );
	send_to_char( buf,ch );
     }

     if (IS_SET(ch->display,DISP_SHOW_AFFECTS))
   do_affects(ch,"");
 }
 
 void do_affects(CHAR_DATA *ch, char *argument )
 {
     AFFECT_DATA *paf, *paf_last = NULL;
     char buf[MAX_STRING_LENGTH];
     
     if ( ch->affected != NULL )
     {
   send_to_char( "You are affected by the following spells:\n\r", ch );
   for ( paf = ch->affected; paf != NULL; paf = paf->next )
   {
       if (paf_last != NULL && paf->type == paf_last->type)
     if (ch->level >= 20)
         sprintf( buf, "                      ");
     else
         continue;
       else
     sprintf( buf, "Spell: %-15s", skill_table[paf->type].name );
 
       send_to_char( buf, ch );
 
       if ( ch->level >= 20 )
       {
     if ( paf->where == DAMAGE_OVER_TIME )
     {
	if ( paf->modifier < 0 || paf->location < 0 )
	 sprintf( buf, ": restoration ");
	else
         sprintf( buf, ": damage over time ");
     }
     else
     sprintf( buf,
         ": modifies %s by %d ",
         affect_loc_name( paf->location ),
         paf->modifier);
     send_to_char( buf, ch );
     if ( paf->duration == -1 )
         sprintf( buf, "permanently" );
     else	/* 10 DOT pulses per tick */
         sprintf( buf, "for %d hours", (paf->where == DAMAGE_OVER_TIME) ? paf->duration / 10 : paf->duration );
     send_to_char( buf, ch );
       }
 
       send_to_char( "\n\r", ch );
       paf_last = paf;
   }
     }
     else 
   send_to_char("You are not affected by any spells.\n\r",ch);
 
     return;
 }
 
 
 
 char *  const   day_name        [] =
 {
     "the Moon", "the Bull", "Deception", "Thunder", "Freedom",
     "the Great Gods", "the Sun"
 };
 
 char *  const   month_name      [] =
 {
     "Winter", "the Winter Wolf", "the Frost Giant", "the Old Forces",
     "the Grand Struggle", "the Spring", "Nature", "Futility", "the Dragon",
     "the Sun", "the Heat", "the Battle", "the Dark Shades", "the Shadows",
     "the Long Shadows", "the Ancient Darkness", "the Great Evil"
 };
 
 void do_time( CHAR_DATA *ch, char *argument )
 {
     extern char str_boot_time[];
     char buf[MAX_STRING_LENGTH];
     char *suf;
     int day;
 
     day     = time_info.day + 1;
 
    if ( day > 4 && day <  20 ) suf = "th";
     else if ( day % 10 ==  1       ) suf = "st";
     else if ( day % 10 ==  2       ) suf = "nd";
     else if ( day % 10 ==  3       ) suf = "rd";
     else                             suf = "th";
 
     sprintf( buf,
   "It is %d o'clock %s, Day of %s, %d%s the Month of %s.\n\r",
   (time_info.hour % 12 == 0) ? 12 : time_info.hour %12,
   time_info.hour >= 12 ? "pm" : "am",
   day_name[day % 7],
   day, suf,
   month_name[time_info.month]);
     send_to_char(buf,ch);
     sprintf(buf,"MHS started up at %s\n\rThe system time is %s.\n\r",
   str_boot_time,
   (char *) ctime( &current_time )
   );
 
     send_to_char( buf, ch );

     if (override)
         send_to_char("Double experience is currently ON.\n\r",ch);

     return;
 }
 
 
 
 void do_weather( CHAR_DATA *ch, char *argument )
 {
     char buf[MAX_STRING_LENGTH];
 
     static char * const sky_look[4] =
     {
   "cloudless",
   "cloudy",
   "rainy",
   "lit by flashes of lightning"
     };
 
     if ( !IS_OUTSIDE(ch) )
     {
   send_to_char( "You can't see the weather indoors.\n\r", ch );
   return;
     }
 
     sprintf( buf, "The sky is %s and %s.\n\r",
   sky_look[weather_info.sky],
   weather_info.change >= 0
   ? "a warm southerly breeze blows"
   : "a cold northern gust blows"
   );
     send_to_char( buf, ch );
     return;
 }
 
 
 
 void do_help( CHAR_DATA *ch, char *argument )
 {
     HELP_DATA *pHelp;
     char argall[MAX_INPUT_LENGTH],argone[MAX_INPUT_LENGTH];
     int col;
      
     col = 0;
    
     if ( argument[0] == '\0' )
        argument = "summary";
 
     /* this parts handles help a b so that it returns help 'a b' */
     argall[0] = '\0';
     while (argument[0] != '\0' )
     {
        argument = one_argument(argument,argone);
        if (argall[0] != '\0')
           strcat(argall," ");
        strcat(argall,argone);
     }
 
     for ( pHelp = help_first; pHelp != NULL; pHelp = pHelp->next )
     {
        if ( pHelp->level > get_trust( ch ) )
           continue;
 
        if ( is_name( argall, pHelp->keyword ) )
        {
           if ( pHelp->level >= 0 && str_cmp( argall, "imotd" ) )
           {
              send_to_char( pHelp->keyword, ch );
              send_to_char( "\n\r", ch );
           }
 
       /*
        * Strip leading '.' to allow initial blanks.
        */
           if ( pHelp->text[0] == '.' )
              page_to_char( pHelp->text+1, ch );
           else
              page_to_char( pHelp->text  , ch );
           return;
        }
     }
 
     send_to_char (argall,ch);
     send_to_char ("\n\r",ch);
/*
     if (str_cmp(capitalize(argall),"topics") && (!str_prefix("topics",argall)
        || !str_suffix("topics",argall)))
*/
     if (!str_suffix("topics",argall))
     {
        for ( pHelp = help_first; pHelp != NULL; pHelp = pHelp->next )
        {
           send_to_char( pHelp->keyword, ch );
           send_to_char( ", ", ch);

           if (++col % 6 == 0)
              send_to_char("\n\r",ch);
        }
 
        if ( col % 6 != 0)
           send_to_char("\n\r",ch);
        return;
     }

     send_to_char( "No help on that word.\n\r", ch );
     return;
 }
 
 
/* whois command */
void do_whois (CHAR_DATA *ch, char *argument)
{
    char arg[MAX_INPUT_LENGTH];
    BUFFER *output;
    char buf[MAX_STRING_LENGTH], cbuf[MAX_STRING_LENGTH], sbuf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    bool found = FALSE;    
    char wizi[50],  incog[50];
    char surname[15];

    one_argument(argument,arg);
  
    if (arg[0] == '\0')
    {
  send_to_char("You must provide a name.\n\r",ch);
  return;
    }

    output = new_buf();

    for (d = descriptor_list; d != NULL; d = d->next)
    {
  CHAR_DATA *wch;
  char const *class;
  char who_name[200];
  int len;
  char const *display_race;

  if (d->connected != CON_PLAYING || !can_see(ch,d->character,TRUE))
      continue;
  
  wch = ( d->original != NULL ) ? d->original : d->character;

  if (!can_see(ch,wch,TRUE))
      continue;

    cbuf[0] = '\0';
    sbuf[0] = '\0';
    if (!clan_table[wch->clan].independent &&
         clan_table[wch->clan].true_clan) 
       sprintf(sbuf, "/%d] ", wch->pcdata->rank);

    if (clan_table[wch->clan].independent 
	&& clan_table[wch->clan].true_clan) 
       sprintf(sbuf, "] ");

    if ( wch->clan && !is_clan(wch)) 
       sprintf(sbuf," ");

    sprintf(cbuf,clan_table[wch->clan].who_name);
    if ( clan_table[wch->clan].hidden && 
	( !is_same_clan(wch,ch) || (IS_IMMORTAL(ch) && get_trust(ch)<58)) )
	{
	sprintf(cbuf,"[ Loner ] ");
	sbuf[0] = '\0';
	}

  if (!str_prefix(arg,wch->name))
  {
      found = TRUE;
      
      /* work out the printing */
          class = class_table[wch->class].who_name;
      switch(wch->level)
      {
    case MAX_LEVEL - 0 : class = "IMPLEMENTOR ";   break;
    case MAX_LEVEL - 1 : class = "  CREATOR   "; break;
    case MAX_LEVEL - 2 : class = " SUPREMACY  "; break;
    case MAX_LEVEL - 3 : class = "   DEITY    "; break;
    case MAX_LEVEL - 4 : class = "    GOD     "; break;
    case MAX_LEVEL - 5 : class = "  IMMORTAL  "; break;
    case MAX_LEVEL - 6 : class = "  DEMIGOD   "; break;
    case MAX_LEVEL - 7 : class = "   ANGEL    "; break;
    case MAX_LEVEL - 8 : class = "   AVATAR   "; break;
      }

     /*
      * Figure out what to print for race.
      */
     if (IS_SET(wch->mhs,MHS_SHAPESHIFTED))
     {
        display_race = pc_race_table[wch->save_race].who_name;
     }
     else
     {
        display_race = pc_race_table[wch->race].who_name; 
     }
      
    surname[0] = '\0';
    if ( wch->pcdata->surname != NULL )
    	sprintf(surname," %s",wch->pcdata->surname);

      /* a little formatting */
  if (wch->level >= MAX_LEVEL - 8) {  
    if ( wch->pcdata->who_name && (wch->pcdata->who_name[0] != '\0')) {
      strcpy (who_name,"             ");
      len = strlen (wch->pcdata->who_name); 
      if (len > 11) {
        strncpy (who_name,wch->pcdata->who_name,12);
      } else {        
        strncpy (&who_name[(12-len)/2],wch->pcdata->who_name,len);        
      }
      who_name[12] = '\0';
      class = who_name;     
    }

    IS_SET(ch->display, DISP_BRIEF_WHOLIST) ?
    sprintf(incog,"(I%d) ", wch->incog_level) :
    sprintf(incog,"({WIncog{x@@{W%d{x) ", wch->incog_level);
    
    IS_SET(ch->display, DISP_BRIEF_WHOLIST) ?
    sprintf(wizi,"(W%d) ", wch->invis_level) :
    sprintf(wizi,"({WWizi{x@@{W%d{x) ", wch->invis_level);

    sprintf(buf, "[%s] %s%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
     class,
           wch->incog_level >= LEVEL_HERO ? incog : "",
           wch->invis_level >= LEVEL_HERO ? wizi   : "",
           cbuf[0] != '\0' ? cbuf : "",
	   sbuf[0] != '\0' ? sbuf : "",
           IS_SET(wch->comm, COMM_AFK) ? "[{CAFK{x] " : 
		(IS_SET(wch->pcdata->clan_flags, CLAN_PAB) ? "[{WPAB{x] " : ""),
           IS_SET(wch->comm, COMM_IN_OLC) ? "[OLC] " : "",
           IS_SET(wch->act, PLR_DWEEB) ? "(DWEEB) " : "",
	wch->trumps > 0 ?
           (IS_SET(wch->act,PLR_KILLER) ? "({RK{x) " : "({rTh{x) ") : 
		(IS_SET(wch->act,PLR_KILLER) ? "({RK{x) " : 
			(IS_SET(wch->wiznet,PLR_RUFFIAN) ? "({rR{x) ":"") ),
           IS_SET(wch->act,PLR_THIEF) ? "({RTf{x) " : "",
              wch->name, 
	 	IS_SET(ch->display,DISP_SURNAME) ? surname : "",
	      IS_NPC(wch) ? "" : (IS_SET(ch->display,DISP_NOTITLES) ? "" : wch->pcdata->title) );
          add_buf(output,buf);
  }
  else
  {
      sprintf(buf, "[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s%s\n\r{x",
       wch->level, display_race, class,
       wch->incog_level >= LEVEL_HERO ? "(I) ": "",
       wch->invis_level >= LEVEL_HERO ? "(W) " : "",
       cbuf[0] != '\0' ? cbuf : "",
       sbuf[0] != '\0' ? sbuf : "",
       IS_SET(wch->comm, COMM_AFK) ? "[{CAFK{x] " : 
		(IS_SET(wch->pcdata->clan_flags, CLAN_PAB) ? "[{WPAB{x] " : ""),
             IS_SET(wch->act, PLR_DWEEB) ? "(DWEEB) " : "",
	wch->trumps > 0 ?
           (IS_SET(wch->act,PLR_KILLER) ? "({RK{x) " : "({rTh{x) ") :
		(IS_SET(wch->act,PLR_KILLER) ? "({RK{x) " : 
			(IS_SET(wch->wiznet,PLR_RUFFIAN) ? "({rR{x) ":"") ),
             IS_SET(wch->act,PLR_THIEF) ? "({RTf{x) " : "",
    wch->name, 
    IS_SET(ch->display,DISP_SURNAME) ? surname : "", IS_NPC(wch) ? "" : (IS_SET(ch->display,DISP_NOTITLES) ? "" : wch->pcdata->title) );
      add_buf(output,buf);
  }
  }
    }

    if (!found)
    {
  send_to_char("No one of that name is playing.\n\r",ch);
  return;
    }

    page_to_char(buf_string(output),ch);
    free_buf(output);
}

void do_cstat(CHAR_DATA *ch)
{
    CSTAT_DATA *cstat;
    char buf[MAX_STRING_LENGTH];
    
    send_to_char("Are stats really that important?  Go PKill now.",ch);
    return;


    send_to_char("Clan    Kills\n\r",ch);
    send_to_char("----    -----\n\r",ch);
    sprintf(buf,"Avarice %d\n\r",avarice_kills);
    send_to_char(buf,ch);
    sprintf(buf,"Demise  %d\n\r",demise_kills);
    send_to_char(buf,ch);
    sprintf(buf,"Honor   %d (%d Demise Vanquished)\n\r",
            honor_kills,honor_demise_kills);
    send_to_char(buf,ch);
    sprintf(buf,"Posse   %d (%d Killers %d Thugs %d Ruffians %d Thieves\n\r",
            posse_kills,posse_killer_kills,posse_thug_kills,
            posse_ruffian_kills,posse_thief_kills);
    send_to_char(buf,ch);
    sprintf(buf,"Warlock %d\n\r",warlock_kills);
    send_to_char(buf,ch);
    sprintf(buf,"Zealot  %d\n\r",zealot_kills);
    send_to_char(buf,ch);
/*
    sprintf(buf,"Honor   %d\n\r",honor_kills);
    send_to_char(buf,ch);
    sprintf(buf,"Posse   %d\n\r",posse_kills);
    send_to_char(buf,ch);
    sprintf(buf,"Warlock %d\n\r",warlock_kills);
    send_to_char(buf,ch);
    sprintf(buf,"Zealot  %d\n\r",zealot_kills);
    send_to_char(buf,ch);
*/
/*
    for (cstat = cstat_first;cstat != NULL;cstat = cstat->next)
    {
       if (cstat->kills > 99)
sprintf(buf,"%d    %s\n\r",cstat->kills,clan_table[cstat->clan].name);
       if (cstat->kills > 9)
sprintf(buf,"%d     %s\n\r",cstat->kills,clan_table[cstat->clan].name);
       if (cstat->kills < 10)
sprintf(buf,"%d      %s\n\r",cstat->kills,clan_table[cstat->clan].name);
       send_to_char(buf,ch);
    }
*/
    return;
}

/*
 * New 'who' command originally by Alander of Rivers of Mud.
 */
void do_who( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char buf2[MAX_STRING_LENGTH];
    char sbuf[MAX_STRING_LENGTH], cbuf[MAX_STRING_LENGTH];
    BUFFER *output;
    DESCRIPTOR_DATA *d;
    int iClass;
    int iRace;
    int iClan;
    int iLevelLower;
    int iLevelUpper;
    int nNumber;
    int nMatch;
    int level;
    bool rgfClass[MAX_CLASS];
    bool rgfRace[MAX_PC_RACE];
    bool rgfClan[MAX_CLAN];
    bool fClassRestrict = FALSE;
    bool fClanRestrict = FALSE;
    bool fClan = FALSE;
    bool fNonClan = FALSE;
    bool fRaceRestrict = FALSE;
    bool fImmortalOnly = FALSE;
    bool shownCDR = FALSE;
    char incog[50], wizi[50];
    bool fHighlander = FALSE;
    bool fGladiator = FALSE;
    char surname[15];

    /*
     * Set default arguments.
     */
    iLevelLower    = 0;
    iLevelUpper    = MAX_LEVEL;
    for ( iClass = 0; iClass < MAX_CLASS; iClass++ )
        rgfClass[iClass] = FALSE;
    for ( iRace = 0; iRace < MAX_PC_RACE; iRace++ )
        rgfRace[iRace] = FALSE;
    for (iClan = 0; iClan < MAX_CLAN; iClan++)
  rgfClan[iClan] = FALSE;
 
    /*
     * Parse arguments.
     */
    nNumber = 0;
    for ( ;; )
    {
        char arg[MAX_STRING_LENGTH];
 
        argument = one_argument( argument, arg );
        if ( arg[0] == '\0' )
            break;
 
        if ( is_number( arg ) )
        {
            switch ( ++nNumber )
            {
            case 1: iLevelLower = atoi( arg ); break;
            case 2: iLevelUpper = atoi( arg ); break;
            default:
                send_to_char( "Only two level numbers allowed.\n\r", ch );
                return;
            }
        }
        else
        {
 
            /*
             * Look for classes to turn on.
             */
            if ( arg[0] == 'i' )
            {
                fImmortalOnly = TRUE;
            }
            else
            {
                iClass = class_lookup(arg);
                if (iClass == -1)
                {
                    iRace = race_lookup(arg);
                    if (iRace == 0 || iRace >= MAX_PC_RACE)
                    {
		       if (!str_prefix(arg,"gladiator"))
			  fGladiator = TRUE;
		       else
		       {
                          if (!str_prefix(arg,"clan"))
                             fClan = TRUE;
                          else
                          {
			     if (!str_prefix(arg,"nonclan"))
			     {
				fNonClan = TRUE;
			     }
			     else
			     {
                                iClan = clan_lookup(arg);
                                if  (iClan)
                                {
                                   fClanRestrict = TRUE;
                                   rgfClan[iClan] = TRUE;
                                }
                                else
                                {
                                   if (!str_prefix(arg,"highlander"))
                                      fHighlander = TRUE;
                                   else
                                   {
			              send_to_char("That's not a valid race, class or clan.\n\r",ch);
                                      return;
				   }
                                } 
                             }
                          }
                       }
		    }
                    else
                    {
                        fRaceRestrict = TRUE;
                        rgfRace[iRace] = TRUE;
                    }
                }
                else
                {
                    fClassRestrict = TRUE;
                    rgfClass[iClass] = TRUE;
                }
            }
        }
    }
    /*
     * Now show matching chars.
     */
    nMatch = 0;
    buf[0] = '\0';
    output = new_buf();

  for ( level = MAX_LEVEL+1; level > 0; level-- )
   {
    if( level == MAX_LEVEL - 1 && !fClan )
	{
	sprintf(buf,"\n\rIMMORTALS\n\r---------\n\r");
	add_buf(output,buf);
	}
    if( level == MAX_LEVEL - 9 )
	{
	if(fImmortalOnly) 
	  {
	   level = 0;
	   continue;
	  }
	else
	{
	sprintf(buf,"\n\rMORTALS\n\r-------\n\r");
	add_buf(output,buf);
	}
	}

    for ( d = descriptor_list; d != NULL; d = d->next )
    {
        CHAR_DATA *wch;
        char const *class;
        char who_name[200];
        int len;
	char const *display_race;
 
        /*
         * Check for match against restrictions.
         * Don't use trust as that exposes trusted mortals.
         */
        if ( d->connected != CON_PLAYING || !can_see( ch, d->character, TRUE) )
            continue;
 
        wch   = ( d->original != NULL ) ? d->original : d->character;

  if (!can_see(ch,wch,TRUE) 
           || (wch->level == level && IS_SET(wch->display,DISP_CODER))
      || (wch->level != level 
      && !(wch->level == level-1 && IS_SET(wch->display,DISP_CODER))))
      continue;

        if ( wch->level < iLevelLower
        ||   wch->level > iLevelUpper
        || ( fImmortalOnly  && wch->level < LEVEL_IMMORTAL )
        || ( fClassRestrict && !rgfClass[wch->class] )
        || ( fRaceRestrict && !rgfRace[wch->race])
  || ( fClan && !is_clan(wch))
  || ( fNonClan && is_clan(wch))
  || ( fHighlander && !IS_SET(wch->mhs,MHS_HIGHLANDER))
  || ( fGladiator && !IS_SET(wch->mhs,MHS_GLADIATOR))
  || ( fClanRestrict && !rgfClan[wch->clan] )
  || ( fClanRestrict && rgfClan[wch->clan] && clan_table[wch->clan].hidden
	&& !is_same_clan(wch,ch))
	 )
            continue;

	if ( fClanRestrict && rgfClan[wch->clan] &&
		clan_table[wch->clan].hidden )
			continue;

        nMatch++;
 
    if( level == MAX_LEVEL 
      && ((wch->level == level-1 && IS_SET(wch->display,DISP_CODER))
	  || wch->level == level)
      && nMatch > 0 && !fClan && !shownCDR )
	{
	sprintf(buf,"CODERS\n\r------\n\r");
	add_buf(output,buf);
	shownCDR = TRUE;
	}

        /*
         * Figure out what to print for class.
   */
  class = class_table[wch->class].who_name; 

  switch ( wch->level )
  {
  default: break;
            {
                case MAX_LEVEL - 0 : class = "IMPLEMENTOR ";    break;
                case MAX_LEVEL - 1 : class = "  CREATOR   ";    break;
                case MAX_LEVEL - 2 : class = " SUPREMACY  ";    break;
                case MAX_LEVEL - 3 : class = "   DEITY    ";    break;
                case MAX_LEVEL - 4 : class = "    GOD     ";    break;
                case MAX_LEVEL - 5 : class = "  IMMORTAL  ";    break;
                case MAX_LEVEL - 6 : class = "  DEMIGOD   ";    break;
                case MAX_LEVEL - 7 : class = "   ANGEL    ";    break;
                case MAX_LEVEL - 8 : class = "  AVATAR    ";    break;
            }
  }

    /*
     * Figure out what to print for race.
     */
 
   if (IS_SET(wch->mhs,MHS_SHAPESHIFTED))
    {
       display_race = pc_race_table[wch->save_race].who_name;
    }
    else
    {
       display_race = pc_race_table[wch->race].who_name; 
    }



    sbuf[0] = '\0';
    if (!clan_table[wch->clan].independent &&
	is_clan(wch)) sprintf(sbuf, "/%d] ", wch->pcdata->rank);
    if (clan_table[wch->clan].independent 
	&& is_clan(wch)) sprintf(sbuf, "] ");
    if (wch->clan && !is_clan(wch) ) sprintf(sbuf," ");

    sprintf(cbuf,clan_table[wch->clan].who_name);
    if(clan_table[wch->clan].hidden &&
       ( !is_same_clan(wch,ch) || (IS_IMMORTAL(ch) && get_trust(ch)<58) ) )
        {
	sprintf(cbuf,"[ Loner ] ");
	sbuf[0] = '\0';
	}

    if (IS_SET(wch->mhs,MHS_GLADIATOR) && gladiator_info.started)
    {
       if(wch->pcdata->gladiator_team == 2)
         sprintf(cbuf,"[ Barbarian ] ");
       else
         sprintf(cbuf,"[ Gladiator ] ");
       sbuf[0] = '\0';
    }

    surname[0] = '\0';
    if ( wch->pcdata->surname != NULL )
	sprintf(surname," %s",wch->pcdata->surname);

  /*
   * Format it up.
   */

  if (wch->level >= MAX_LEVEL - 8)
        {

    if ( wch->pcdata->who_name && (wch->pcdata->who_name[0] != '\0')) {
      strcpy (who_name,"             ");
      len = strlen (wch->pcdata->who_name); 
      if (len > 11) {
        strncpy (who_name,wch->pcdata->who_name,12);
      } else {        
        strncpy (&who_name[(12-len)/2],wch->pcdata->who_name,len);        
      }
      who_name[12] = '\0';
      class = who_name;
    }


    IS_SET(ch->display, DISP_BRIEF_WHOLIST) ?
    sprintf(incog,"(I%d) ", wch->incog_level ) :
    sprintf(incog,"({WIncog{x@@{W%d{x) ", wch->incog_level );

    IS_SET(ch->display, DISP_BRIEF_WHOLIST) ?
    sprintf(wizi,"(W%d) ", wch->invis_level ) :
    sprintf(wizi,"({WWizi{x@@{W%d{x) ", wch->invis_level );

    sprintf(buf,  "[%s] %s%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
     class,
           wch->incog_level >= LEVEL_HERO ? incog : "",
           wch->invis_level >= LEVEL_HERO ? wizi   : "",
   	   cbuf[0] != '\0' ? cbuf : "",
	   sbuf[0] != '\0' ? sbuf : "",
             IS_SET(wch->comm, COMM_AFK) ? "[{CAFK{x] " : 
		(IS_SET(wch->pcdata->clan_flags, CLAN_PAB) ? "[{WPAB{x] " : ""),
             IS_SET(wch->comm, COMM_IN_OLC) ? "[OLC] " : "",
             IS_SET(wch->act, PLR_DWEEB) ? "(DWEEB) " : "",
	wch->trumps > 0 ?
           (IS_SET(wch->act,PLR_KILLER) ? "({RK{x) " : "({rTh{x) ") :
		(IS_SET(wch->act,PLR_KILLER) ? "({RK{x) " : 
			(IS_SET(wch->wiznet,PLR_RUFFIAN) ? "({rR{x) ":"") ),
             IS_SET(wch->act,PLR_THIEF) ? "({RTf{x) " : "",
             wch->name, 
	     IS_SET(ch->display,DISP_SURNAME) ? surname : "",
             IS_NPC(wch) ? "" : (IS_SET(ch->display,DISP_NOTITLES) ? "" : wch->pcdata->title) );
            add_buf(output,buf);
        }
        else
  {
  sprintf( buf, "[%2d %6s %s]{x%s%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
      wch->level, 
      display_race, 
      class,
      (IS_SET(wch->act,PLR_CANCLAN) && wch->level < 25 &&
       !is_clan(wch) && IS_IMMORTAL(ch ) ) ? "*" : " ",
      wch->incog_level >= LEVEL_HERO ? "(I) " : "",
      wch->invis_level >= LEVEL_HERO ? "(W) " : "",
      cbuf[0] != '\0' ? cbuf : "",
      sbuf[0] != '\0' ? sbuf : "",
      IS_SET(wch->comm, COMM_AFK) ? "[{CAFK{x] " : 
		(IS_SET(wch->pcdata->clan_flags, CLAN_PAB) ? "[{WPAB{x] " : ""),
            IS_SET(wch->act, PLR_DWEEB) ? "(DWEEB) " : "",
	wch->trumps > 0 ?
           (IS_SET(wch->act,PLR_KILLER) ? "({RK{x) " : "({rTh{x) ") :
		(IS_SET(wch->act,PLR_KILLER) ? "({RK{x) " : 
			(IS_SET(wch->wiznet,PLR_RUFFIAN) ? "({rR{x) ":"") ),
            IS_SET(wch->act, PLR_THIEF)  ? "({RTf{x) "  : "",
      wch->name,
      IS_SET(ch->display,DISP_SURNAME) ? surname : "",
      IS_NPC(wch) ? "" : (IS_SET(ch->display,DISP_NOTITLES) ? "" : wch->pcdata->title) );
  add_buf(output,buf);
  }
    }
  }

    sprintf( buf2, "\n\rPlayers found: %d\n\r", nMatch );
    add_buf(output,buf2);
    page_to_char( buf_string(output), ch );
    free_buf(output);
    return;
}

 void do_count ( CHAR_DATA *ch, char *argument )
 {
     int count;
     DESCRIPTOR_DATA *d;
     char buf[MAX_STRING_LENGTH];
 
     count = 0;
 
     for ( d = descriptor_list; d != NULL; d = d->next )
   if ( d->connected == CON_PLAYING && can_see( ch, d->character, TRUE ) )
       count++;
 
     max_on = UMAX(count,max_on);
 
     if (max_on == count)
   sprintf(buf,"There are %d characters on, the most so far today.\n\r",
       count);
     else
   sprintf(buf,"There are %d characters on, the most on today was %d.\n\r",
       count,max_on);
 
     send_to_char(buf,ch);
 }
 
 void do_inventory( CHAR_DATA *ch, char *argument )
 {
     send_to_char( "You are carrying:\n\r", ch );
     show_list_to_char( ch->carrying, ch, TRUE, TRUE, FALSE );
     return;
 }
 
 
 
 void do_equipment( CHAR_DATA *ch, char *argument )
 {
     OBJ_DATA *obj;
     int iWear;
     bool found;
 
     send_to_char( "You are using:\n\r", ch );
     found = FALSE;
     for ( iWear = 0; iWear < MAX_WEAR; iWear++ )
     {
   if ( ( obj = get_eq_char( ch, iWear ) ) == NULL )
     {
	if(!IS_NPC(ch) && !IS_SET(ch->display, DISP_BRIEF_EQLIST) )
	 {
	  send_to_char( where_name[iWear], ch );
	  send_to_char( "- - -\n\r", ch );
	 }
       continue;
     }
 
   send_to_char( where_name[iWear], ch );

   if ( can_see_obj( ch, obj ) )
   {
       send_to_char( format_obj_to_char( obj, ch, TRUE ), ch );
       send_to_char( "\n\r", ch );
   }
   else
   {
       send_to_char( "something.\n\r", ch );
   }
   found = TRUE;
     }
 
     if ( !found )
   send_to_char( "Nothing.\n\r", ch );
 
     return;
 }
 
 
 
 void do_compare( CHAR_DATA *ch, char *argument )
 {
     char arg1[MAX_INPUT_LENGTH];
     char arg2[MAX_INPUT_LENGTH];
     OBJ_DATA *obj1;
     OBJ_DATA *obj2;
     int value1;
     int value2;
     char *msg;
 
     argument = one_argument( argument, arg1 );
     argument = one_argument( argument, arg2 );
     if ( arg1[0] == '\0' )
     {
   send_to_char( "Compare what to what?\n\r", ch );
   return;
     }
 
     if ( ( obj1 = get_obj_carry( ch, arg1 ) ) == NULL )
     {
   send_to_char( "You do not have that item.\n\r", ch );
   return;
     }
 
     if (arg2[0] == '\0')
     {
   for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content)
   {
       if (obj2->wear_loc != WEAR_NONE
       &&  can_see_obj(ch,obj2)
       &&  obj1->item_type == obj2->item_type
       &&  (obj1->wear_flags & obj2->wear_flags & ~ITEM_TAKE) != 0 )
     break;
   }
 
   if (obj2 == NULL)
   {
       send_to_char("You aren't wearing anything comparable.\n\r",ch);
       return;
   }
     } 
 
     else if ( (obj2 = get_obj_carry(ch,arg2) ) == NULL )
     {
   send_to_char("You do not have that item.\n\r",ch);
   return;
     }
 
     msg         = NULL;
     value1      = 0;
     value2      = 0;
 
     if ( obj1 == obj2 )
     {
   msg = "You compare $p to itself.  It looks about the same.";
     }
     else if ( obj1->item_type != obj2->item_type )
     {
   msg = "You can't compare $p and $P.";
     }
     else
     {
   switch ( obj1->item_type )
   {
   default:
       msg = "You can't compare $p and $P.";
       break;
 
   case ITEM_ARMOR:
       value1 = obj1->value[0] + obj1->value[1] + obj1->value[2];
       value2 = obj2->value[0] + obj2->value[1] + obj2->value[2];
       break;
 
   case ITEM_WEAPON:
       if (obj1->pIndexData->new_format)
     value1 = (1 + obj1->value[2]) * obj1->value[1];
       else
     value1 = obj1->value[1] + obj1->value[2];
 
       if (obj2->pIndexData->new_format)
     value2 = (1 + obj2->value[2]) * obj2->value[1];
       else
     value2 = obj2->value[1] + obj2->value[2];
       break;
   }
     }
 
     if ( msg == NULL )
     {
        if ( value1 == value2 ) msg = "$p and $P look about the same.";
   else if ( value1  > value2 ) msg = "$p looks better than $P.";
   else                         msg = "$p looks worse than $P.";
     }
 
     act( msg, ch, obj1, obj2, TO_CHAR,FALSE );
     return;
 }
 
 
 
 void do_credits( CHAR_DATA *ch, char *argument )
 {
     do_help( ch, "diku" );
     return;
 }
 
 
 
 void do_where( CHAR_DATA *ch, char *argument )
 {
     char buf[MAX_STRING_LENGTH];
     char arg[MAX_INPUT_LENGTH];
     CHAR_DATA *victim;
     DESCRIPTOR_DATA *d;
     ROOM_INDEX_DATA *scan_room;
     bool found;

   if(!IS_NPC(ch) && ch->move < 4)
   {
      send_to_char("You can't get up enough energy.\n\r",ch);
      return;
   }

   if(ch->in_room->sector_type == SECT_OBS_ROOM)
	scan_room = get_room_index(ch->in_room->obs_target);
   else
	scan_room = ch->in_room;

   ch->move = UMAX(ch->move - apply_chi(ch,4), 0);

   one_argument( argument, arg );
  
   if ( arg[0] == '\0' )
   {
      send_to_char( "Players near you:\n\r", ch );
      found = FALSE;
      for ( d = descriptor_list; d; d = d->next )
      {
         if ( (d->connected == CON_PLAYING)
         && ( (victim = d->character) != NULL )
         && ( !IS_NPC(victim) )
         && ( victim->in_room != NULL )
         && ( !IS_SET(victim->in_room->room_flags,ROOM_NOWHERE) )
         && ( (is_room_owner(ch,victim->in_room) )
         ||   (!room_is_private(ch,victim->in_room)) )
         && ( victim->in_room->area == scan_room->area )
         && ( can_see( ch, victim,FALSE)) 
         && ( !is_clan( ch ) || ( is_clan(ch) && !IS_AFFECTED(ch,AFF_BLIND)))
         && ( check_match(ch, victim) )
         && (get_skill(ch,gsn_scan) >= 
	    (number_percent() + (victim->level - ch->level)*2 ))) 

         {
            if(found == FALSE)
	    {
	       found = TRUE;
	       check_improve(ch,gsn_scan,TRUE,4);
	    }
	    if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE)
               sprintf( buf, "%-28s %s\n\r",
               victim->long_descr, victim->in_room->name );
	    else
               sprintf( buf, "%-28s %s\n\r",
               victim->name, victim->in_room->name );
            send_to_char( buf, ch );
         }
      }
      if ( !found )
      {
         send_to_char( "None\n\r", ch );
         check_improve(ch,gsn_scan,FALSE,7);
      }
   }
   else
   {
      found = FALSE;
      for ( victim = char_list; victim != NULL; victim = victim->next )
      {
         if ( victim->in_room != NULL
         &&   victim->in_room->area == scan_room->area
         &&   !IS_AFFECTED(victim, AFF_HIDE)
         &&   !IS_AFFECTED(victim, AFF_SNEAK)
         &&   !IS_SET(victim->in_room->room_flags,ROOM_NOWHERE) 
         &&   can_see( ch, victim, FALSE )
         &&   is_name( arg, victim->name ) 
	 && (get_skill(ch,gsn_scan) >=
            (number_percent() + victim->level - ch->level)))

         {
           if(found == FALSE)
	   {
	     found = TRUE;
	     check_improve(ch,gsn_scan,TRUE,4);
	   }
	   if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE)
              sprintf( buf, "%-28s %s\n\r",
              victim->long_descr, victim->in_room->name );
	   else
              sprintf( buf, "%-28s %s\n\r",
              PERS(victim, ch, FALSE), victim->in_room->name );
           send_to_char( buf, ch );
           break;
        }
     }
     if ( !found )
     {
       act( "You didn't find any $T.", ch, NULL, arg, TO_CHAR,FALSE );
       check_improve(ch,gsn_scan,FALSE,6);
     }
  }
 
  return;
}
 
 
 
 
 void do_consider( CHAR_DATA *ch, char *argument )
 {
     char arg[MAX_INPUT_LENGTH];
     CHAR_DATA *victim;
     char *msg;
     int diff;
 
     one_argument( argument, arg );
 
     if ( arg[0] == '\0' )
     {
   send_to_char( "Consider killing whom?\n\r", ch );
   return;
     }
 
     if ( ( victim = get_char_room( ch, arg ) ) == NULL )
     {
   send_to_char( "They're not here.\n\r", ch );
   return;
     }
 
     if (is_safe(ch,victim))
     {
   send_to_char("Don't even think about it.\n\r",ch);
   return;
     }
 
     diff = victim->level - ch->level;
 
   if (ch->pcdata->condition[COND_DRUNK] >6)
   {
      diff = number_range(1,60) - ch->level;
      if (ch->race == race_lookup("dwarf"))
      {
         diff -= 30;
      }
   }
 
    if ( diff <= -10 ) msg = "You can kill $N naked and weaponless.";
     else if ( diff <=  -5 ) msg = "$N is no match for you.";
     else if ( diff <=  -2 ) msg = "$N looks like an easy kill.";
     else if ( diff <=   1 ) msg = "The perfect match!";
     else if ( diff <=   4 ) msg = "$N says 'Do you feel lucky, punk?'.";
     else if ( diff <=   9 ) msg = "$N laughs at you mercilessly.";
     else                    msg = "Death will thank you for your gift.";
 
     act( msg, ch, NULL, victim, TO_CHAR,FALSE );
     return;
 }
 
 
 
 void set_title( CHAR_DATA *ch, char *title )
 {
     char buf[MAX_STRING_LENGTH];
 
     if ( IS_NPC(ch) )
     {
   bug( "Set_title: NPC.", 0 );
   return;
     }
     

     if ( title[0] != '.' && title[0] != ',' && title[0] != '!' && title[0] != '?' )
     {
   buf[0] = ' ';
   strcpy( buf+1, title );
     }
     else
     {
   strcpy( buf, title );
     }
 
     free_string( ch->pcdata->title );
     ch->pcdata->title = str_dup( buf );
     return;
 }
 
 
 
 void do_title( CHAR_DATA *ch, char *argument )
 {
     if ( IS_NPC(ch) )
   return;

     if ( IS_SET(ch->comm,COMM_NOTITLE) )
     {
   send_to_char( "Ok.\n\r",ch);
   return;
     }

     if ( argument[0] == '\0' )
     {
   send_to_char( "Change your title to what?\n\r", ch );
   return;
     }
 
     if ( strlen(argument) > 45 )
   argument[45] = '\0';
 
     smash_tilde( argument );
     set_title( ch, argument );
     send_to_char( "Ok.\n\r", ch );
 }
 
 
 
 void do_description( CHAR_DATA *ch, char *argument )
 {
     char buf[MAX_STRING_LENGTH];
 
     if ( argument[0] != '\0' )
     {
   buf[0] = '\0';
   smash_tilde( argument );
 
   if (argument[0] == '-')
   {
       int len;
       bool found = FALSE;
  
       if (ch->description == NULL || ch->description[0] == '\0')
       {
     send_to_char("No lines left to remove.\n\r",ch);
     return;
       }
   
       strcpy(buf,ch->description);
  
       for (len = strlen(buf); len > 0; len--)
       {
     if (buf[len] == '\r')
     {
         if (!found)  /* back it up */
         {
       if (len > 0)
           len--;
       found = TRUE;
         }
         else /* found the second one */
         {
       buf[len + 1] = '\0';
       free_string(ch->description);
       ch->description = str_dup(buf);
       send_to_char( "Your description is:\n\r", ch );
       send_to_char( ch->description ? ch->description : 
           "(None).\n\r", ch );
       return;
         }
     }
       }
       buf[0] = '\0';
       free_string(ch->description);
       ch->description = str_dup(buf);
       send_to_char("Description cleared.\n\r",ch);
       return;
   }
   if ( argument[0] == '+' )
   {
       if ( ch->description != NULL )
     strcat( buf, ch->description );
       argument++;
       while ( isspace(*argument) )
     argument++;
   }
 
   if ( strlen(buf) + strlen(argument) >= MAX_STRING_LENGTH - 2 )
   {
       send_to_char( "Description too long.\n\r", ch );
       return;
   }
 
   strcat( buf, argument );
   strcat( buf, "\n\r" );
   free_string( ch->description );
   ch->description = str_dup( buf );
     }
 
     send_to_char( "Your description is:\n\r", ch );
     send_to_char( ch->description ? ch->description : "(None).\n\r", ch );
     return;
 }
 
 
void do_kr( CHAR_DATA *ch, char *argument)
{
    char buf[MAX_STRING_LENGTH];
    char tbuf[MAX_INPUT_LENGTH];

  if( IS_SET(ch->mhs,MHS_HIGHLANDER))
  {
     sprintf(buf,"$n says 'I have claimed the souls of %d victims, %d of them by my own hand.'\n\r",
	    ch->pcdata->highlander_data[ALL_KILLS],
	    ch->pcdata->highlander_data[REAL_KILLS]);
     act(buf,ch,NULL,NULL,TO_ROOM,FALSE);
    
     sprintf(buf,"You have claimed the souls of %d victims, %d of them by your own hand.\n\r",
	    ch->pcdata->highlander_data[ALL_KILLS],
	    ch->pcdata->highlander_data[REAL_KILLS]);
     send_to_char( buf,ch);
     return;
  }

  if( IS_NPC(ch) || (!is_clan(ch) 
		     && !IS_IMMORTAL(ch)
		     && !IS_SET(ch->mhs,MHS_GLADIATOR)) )
	return;

  sprintf( buf, "You have %d lower kills, %d equal kills and %d greater kills.\n\r"
		"The last player you killed was %s.\n\r"
		"The last player to kill you was %s.\n\r"
		"You have %d Single Victories, %d Single Kills in %d events,\n\r"
		"%d Team Victories and %d Team Kills in %d events.\n\r",
		ch->pcdata->killer_data[PC_LOWER_KILLS],
		ch->pcdata->killer_data[PC_EQUAL_KILLS],
		ch->pcdata->killer_data[PC_GREATER_KILLS],
                ch->pcdata->last_kill,
		ch->pcdata->last_killed_by,
		ch->pcdata->gladiator_data[GLADIATOR_VICTORIES],
		ch->pcdata->gladiator_data[GLADIATOR_KILLS],
		ch->pcdata->gladiator_data[GLADIATOR_PLAYS],
		ch->pcdata->gladiator_data[GLADIATOR_TEAM_VICTORIES],
		ch->pcdata->gladiator_data[GLADIATOR_TEAM_KILLS],
		ch->pcdata->gladiator_data[GLADIATOR_TEAM_PLAYS]);
  send_to_char( buf, ch );
  if (ch->pcdata->steal_data[PC_STOLEN_ITEMS] > 0 ||
      ch->pcdata->steal_data[PC_STOLEN_GOLD] > 0 ) 
  {
     sprintf( buf,"You have stolen %ld items and %ld gold.\n\r",
	      ch->pcdata->steal_data[PC_STOLEN_ITEMS],  
	      ch->pcdata->steal_data[PC_STOLEN_GOLD]);
     send_to_char(buf,ch);
  }

  if (ch->pcdata->steal_data[PC_SLICES] > 0)
  {
     sprintf( buf,"You have sliced open  %ld items.\n\r",
	      ch->pcdata->steal_data[PC_SLICES]);
     send_to_char(buf,ch);
  }
  sprintf( buf, "To inform you, $n says 'I have %d lower kills," 
		"%d equal kills and %d greater kills.\n\r"
		"I last killed %s.  The last person to kill me was %s.\n\r"
		"In Single Arena I have %d victories having killed %d Gladiators in %d events.\n\r"
		"In Teams Arena I have %d victories having killed %d Gladiators in %d events.",
		ch->pcdata->killer_data[PC_LOWER_KILLS], 
                ch->pcdata->killer_data[PC_EQUAL_KILLS], 
                ch->pcdata->killer_data[PC_GREATER_KILLS],
		ch->pcdata->last_kill,ch->pcdata->last_killed_by,
		ch->pcdata->gladiator_data[GLADIATOR_VICTORIES],
		ch->pcdata->gladiator_data[GLADIATOR_KILLS],
		ch->pcdata->gladiator_data[GLADIATOR_PLAYS],
		ch->pcdata->gladiator_data[GLADIATOR_TEAM_VICTORIES],
		ch->pcdata->gladiator_data[GLADIATOR_TEAM_KILLS],
		ch->pcdata->gladiator_data[GLADIATOR_TEAM_PLAYS]); 

  if (ch->pcdata->steal_data[PC_STOLEN_ITEMS] > 0 ||
      ch->pcdata->steal_data[PC_STOLEN_GOLD] > 0 ) 
  {
     sprintf( tbuf, "\n\rI have stolen %ld items and %ld gold.",  
		ch->pcdata->steal_data[PC_STOLEN_ITEMS],
		ch->pcdata->steal_data[PC_STOLEN_GOLD]); 
     strcat(buf,tbuf);
  }

  if (ch->pcdata->steal_data[PC_SLICES] > 0)
  {
     sprintf( tbuf, "\n\rI have sliced open %ld items.", 
		ch->pcdata->steal_data[PC_SLICES]); 
     strcat(buf,tbuf);
  }

  strcat(buf,"'\n\r");
  act( buf, ch, NULL, NULL, TO_ROOM,FALSE );

  return;

}


 void do_report( CHAR_DATA *ch, char *argument )
 {
     char buf[MAX_INPUT_LENGTH];
     char wound[80];
     char mental[80];
     char moves[80];
     int percent = 0;

     if ( is_affected(ch, gsn_rage) )
     {
	 send_to_char("Report?  Report what?  You feel just FINE!\n\r",ch);
	 return;
     }

      if (ch->max_hit > 0)
    percent = ch->hit * 100 / ch->max_hit;
      else
    percent = -1;

      if (percent >= 100)
    strcpy(wound,"I am in excellent condition, ");
      else if (percent >= 90)
    strcpy(wound,"I have a few scratches, ");
      else if (percent >= 75)
    strcpy(wound,"I have some small wounds and bruises, ");
      else if (percent >= 50)
    strcpy(wound,"I have quite a few wounds, ");
      else if (percent >= 30)
    strcpy(wound,"I have some big nasty wounds and scratches, ");
      else if (percent >= 15)
    strcpy(wound,"I am pretty hurt, ");
      else if (percent >= 0)
    strcpy(wound,"I am in awful condition, ");
      else
    strcpy(wound,"I am bleeding to death, ");

      if (ch->max_mana > 0)
    percent = ch->mana * 100 / ch->max_mana;
      else
    percent = -1;

      if (percent >= 100)
    strcpy(mental,"am mentally fit ");
      else if (percent >= 90)
    strcpy(mental,"am a bit slow ");
      else if (percent >= 75)
    strcpy(mental,"have some mental lapses ");
      else if (percent >= 50)
    strcpy(mental,"am quite drained ");
      else if (percent >= 30)
    strcpy(mental,"feel dazed ");
      else if (percent >= 15)
    strcpy(mental,"am nearly spent ");
      else if (percent >= 0)
    strcpy(mental,"am brain dead ");
      else
    strcpy(mental,"am helpless ");

      if (ch->max_move > 0)
    percent = ch->move * 100 / ch->max_move;
      else
    percent = -1;

      if (percent >= 100)
    strcpy(moves,"and am full of energy.");
      else if (percent >= 90)
    strcpy(moves,"and am energetic.");
      else if (percent >= 75)
    strcpy(moves,"and am breathing hard.");
      else if (percent >= 50)
    strcpy(moves,"and my heart is pounding.");
      else if (percent >= 30)
    strcpy(moves,"and feel winded.");
      else if (percent >= 15)
    strcpy(moves,"and am cramping up.");
      else if (percent >= 0)
    strcpy(moves,"and am exhausted.");
      else
    strcpy(moves,"and am motionless.");
 
     sprintf( buf,
   "You say '%s%s%s %d xp.'\n\r",
   wound, mental, moves,
   ch->exp   );
 
     send_to_char( buf, ch );
 
     sprintf( buf, "$n says '%s%s%s %d xp.'",
   wound, mental, moves,
   ch->exp   );
 
     act( buf, ch, NULL, NULL, TO_ROOM, TRUE );
 
     return;
 }
 
 
 
 void do_practice( CHAR_DATA *ch, char *argument )
 {
     bool fNew = FALSE, fSkills = FALSE, fSpells = FALSE;
     bool fOld = FALSE, fSkip = FALSE;
     char buf[MAX_STRING_LENGTH * 3];
     char buf2[MAX_STRING_LENGTH * 3];
     char arg[MAX_INPUT_LENGTH];
     char arg2[MAX_INPUT_LENGTH];
     char *target_name;
     int sn;
 
     if ( IS_NPC(ch) )
   return;

/*
     if ( argument[0] == '-' )
     {
	argument = argument +1;
	if ( !str_cmp(argument,"skills") )
		fSkills = TRUE;
	else
	if ( !str_cmp(argument,"spells") )
		fSpells = TRUE;
	else
	if ( !str_cmp(argument,"new") )
		fNew = TRUE;
	else
	if ( !str_cmp(argument,"skip") )
		fSkip = TRUE;
	else
	if ( !str_cmp(argument,"old") )
		fOld = TRUE;
	else
		argument[0] = '\0';
     }
     */

     target_name = one_argument( argument, arg );
     one_argument( target_name, arg2 );

     if (!str_cmp(arg,"-old"))
	fOld = TRUE;
     else
     if (!str_cmp(arg,"-skip"))
	fSkip = TRUE;
     else
     if (!str_cmp(arg,"-new"))
	fNew = TRUE;
     else
     if (!str_cmp(arg,"-skills"))
	fSkills = TRUE;
     else
     if (!str_cmp(arg,"-spells"))
	fSpells = TRUE;

     if ( argument[0] == '\0' || fNew || fSkills || fSpells)
     {
        int col;
        buf2[0] = '\0';
 
        col    = 0;
        for ( sn = 0; sn < MAX_SKILL; sn++ )
        {
           if ( skill_table[sn].name == NULL )
              break;
           if ( ch->level < skill_level(ch,sn)
               || ch->pcdata->learned[sn] < 1)
              continue;

     	   if ( fNew && ch->pcdata->learned[sn] >= 75 )
              continue;

	   if ( fSpells && skill_table[sn].spell_fun == spell_null )
              continue;

	   if ( fSkills && skill_table[sn].spell_fun != spell_null )
	      continue;

           sprintf( buf, "{%c%-18s{x %3d%%  " , 
              ch->pcdata->learned[sn] != ch->pcdata->last_learned[sn] ? 'R' : 'x',
              skill_table[sn].name,
              ch->pcdata->learned[sn] );
              strcat( buf2, buf );

           if ( ++col % 3 == 0 )
              strcat( buf2, "\n\r" );
           ch->pcdata->last_learned[sn] = ch->pcdata->learned[sn];
        }
 
        if ( col % 3 != 0 )
           strcat( buf2, "\n\r" );

        sprintf( buf, "You have %d practice sessions left.\n\r",
           ch->practice );
        strcat( buf2, buf );
        page_to_char(buf2, ch);
     }
     else
     {
        CHAR_DATA *mob;
        int adept, blah;
 
        if ( !IS_AWAKE(ch) )
        {
           send_to_char( "In your dreams, or what?\n\r", ch );
           return;
        }
 
        for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
        {
           if ( IS_NPC(mob) && IS_SET(mob->act, ACT_PRACTICE) )
              break;
        }
 
        if ( mob == NULL )
        {
           send_to_char( "You can't do that here.\n\r", ch );
           return;
        }
 
        if ( ch->practice <= 0 )
        {
           send_to_char( "You have no practice sessions left.\n\r", ch );
           return;
        }

        if (arg2[0] != '\0')
	   strcpy(arg,arg2);

        if ( ( sn = find_spell( ch,arg ) ) < 0
               || ( !IS_NPC(ch)
               &&   (ch->level < skill_level(ch,sn)
               ||    ch->pcdata->learned[sn] < 1 
               ||    skill_table[sn].rating[ch->class] == 0)))
        {
           send_to_char( "You can't practice that.\n\r", ch );
           return;
        }

        if (ch->pcdata->learned[sn] < ch->pcdata->old_learned[sn]
            && !fOld && !fSkip)
        {
           sprintf(buf,"You had %s at %d prior to the Pfresh.\n\r",
	      skill_table[sn].name,ch->pcdata->old_learned[sn] ); 
	   send_to_char(buf,ch);
           send_to_char("If you would like to return to that %, use 'practice -old (name)'.\n\r", ch);
           send_to_char("If you would like to disregard your old %, use 'practice -skip (name)'.\n\r",ch);
           return;
        }

        adept = IS_NPC(ch) ? 100 : class_table[ch->class].skill_adept;


        if (fOld)
        {
           if (ch->pcdata->learned[sn] < ch->pcdata->old_learned[sn])
           {
              ch->practice--;
              ch->pcdata->learned[sn] = ch->pcdata->old_learned[sn]; 

              if ( ch->pcdata->learned[sn] < 100 )
              {
                 act( "You jump around yelling 'Pfresh my $T!'",
                    ch, NULL, skill_table[sn].name, TO_CHAR, TRUE );
                 act( "$n jumps around yelling 'Pfresh my $T!'",
                    ch, NULL, skill_table[sn].name, TO_ROOM, TRUE );
              }
              else
              {
                 act( "You head is bursting with all the knowledge of $T!",
                    ch, NULL, skill_table[sn].name, TO_CHAR, TRUE );
                 act( "$n grabs their head and screams 'Yikes my $T!'",
                    ch, NULL, skill_table[sn].name, TO_ROOM, TRUE);
              }
           }
           else
           {
      send_to_char("Your skill is already higher then your old skill.\n\r",ch);
           }
        }
        else
        {
           if ( ch->pcdata->learned[sn] >= adept )
           {
              sprintf( buf, "You are already learned at %s.\n\r",
                 skill_table[sn].name );
              send_to_char( buf, ch );
           }
	   else
	   {
              blah = abs(skill_table[sn].rating[ch->class]);
              ch->practice--;
	      if ( adept > 75 && ch->pcdata->learned[sn] > 75 )
		ch->pcdata->learned[sn]++;
	      else
              ch->pcdata->learned[sn] += 
                 int_app[get_curr_stat(ch,STAT_INT)].learn / blah ;

              if ( ch->pcdata->learned[sn] < adept )
              {
                 act( "You practice $T.",
                    ch, NULL, skill_table[sn].name, TO_CHAR, FALSE );
                 act( "$n practices $T.",
                    ch, NULL, skill_table[sn].name, TO_ROOM, FALSE );
              }
              else
              {
                 ch->pcdata->learned[sn] = adept;
                 act( "You are now learned at $T.",
                    ch, NULL, skill_table[sn].name, TO_CHAR, FALSE );
                 act( "$n is now learned at $T.",
                    ch, NULL, skill_table[sn].name, TO_ROOM, FALSE );
              }
	   }
        }
     }
     return;
 }
 
 
 
 /*
  * 'Wimpy' originally by Dionysos.
  */
 void do_wimpy( CHAR_DATA *ch, char *argument )
 {
     char buf[MAX_STRING_LENGTH];
     char arg[MAX_INPUT_LENGTH];
     int wimpy;
 
     one_argument( argument, arg );
 
     if ( arg[0] == '\0' )
   wimpy = 20;
     else
   wimpy = atoi( arg );
 
     if ( wimpy < 0 )
     {
   send_to_char( "Your courage exceeds your wisdom.\n\r", ch );
   return;
     }
 
     if ( wimpy > 50 )
     {
   send_to_char( "Such cowardice ill becomes you.\n\r", ch );
   return;
     }
 
     ch->wimpy   = wimpy;
     sprintf( buf, "Wimpy set to %d percent.\n\r", wimpy );
     send_to_char( buf, ch );
     return;
 }
 
 
 
 void do_password( CHAR_DATA *ch, char *argument )
 {
     char arg1[MAX_INPUT_LENGTH];
     char arg2[MAX_INPUT_LENGTH];
     char log_buf[MAX_INPUT_LENGTH];
     char *pArg;
     char *pwdnew;
     char *p;
     char cEnd;
 
     if ( IS_NPC(ch) )
   return;
 
     /*
      * Can't use one_argument here because it smashes case.
      * So we just steal all its code.  Bleagh.
      */
     pArg = arg1;
     while ( isspace(*argument) )
   argument++;
 
     cEnd = ' ';
     if ( *argument == '\'' || *argument == '"' )
   cEnd = *argument++;
 
     while ( *argument != '\0' )
     {
   if ( *argument == cEnd )
   {
       argument++;
       break;
   }
   *pArg++ = *argument++;
     }
     *pArg = '\0';
 
     pArg = arg2;
     while ( isspace(*argument) )
   argument++;
 
     cEnd = ' ';
     if ( *argument == '\'' || *argument == '"' )
   cEnd = *argument++;
 
     while ( *argument != '\0' )
     {
   if ( *argument == cEnd )
   {
       argument++;
       break;
   }
   *pArg++ = *argument++;
     }
     *pArg = '\0';
 
     sprintf( log_buf, "Log %s: password %s %s", ch->name, arg1, arg2 );
     log_string( log_buf ); 

     if ( arg1[0] == '\0' || arg2[0] == '\0' )
     {
   send_to_char( "Syntax: password <old> <new>.\n\r", ch );
   return;
     }

     if ( strcmp( crypt( arg1, ch->pcdata->pwd ), ch->pcdata->pwd ) )
     {
   WAIT_STATE( ch, 40 );
   send_to_char( "Wrong password.  Wait 10 seconds.\n\r", ch );
   return;
     }
 
     if ( strlen(arg2) < 5 )
     {
   send_to_char(
       "New password must be at least five characters long.\n\r", ch );
   return;
     }
 
     /*
      * No tilde allowed because of player file format.
      */
     pwdnew = crypt( arg2, ch->name );
     for ( p = pwdnew; *p != '\0'; p++ )
     {
   if ( *p == '~' )
   {
       send_to_char(
     "New password not acceptable, try again.\n\r", ch );
       return;
   }
     }
 
     free_string( ch->pcdata->pwd );
     ch->pcdata->pwd = str_dup( pwdnew );
     save_char_obj( ch );
     send_to_char( "Ok.\n\r", ch );
     return;
 }
 
 
void do_ignore( CHAR_DATA *ch, char *argument )
 {
     char arg[MAX_INPUT_LENGTH];
     CHAR_DATA *ignore;

  one_argument(argument,arg);
  if( arg[0] == '\0' )
	{
	 send_to_char("Ignore reset.\n\r",ch);
            ch->ignoring = NULL;
            return;
          }

  if ( (ignore = get_char_world(ch, arg) ) == NULL)
  {
     send_to_char("They aren't here.\n\r",ch);
     return;
  }

            
  if ( IS_IMMORTAL(ignore) )
  {
     send_to_char("You can't ignore Immortals, dumbass.\n\r",ch);
     return;
  }

  if ( ignore != NULL && !IS_NPC(ignore) )
	{ 
	ch->ignoring = ignore;
	if(ch->ignoring == ch) 
	  { 
	    send_to_char("Ignore reset.\n\r",ch);
	    ch->ignoring = NULL;
	    return;
	  }
	 send_to_char( "Ignoring.\n\r", ch);
	}
  else
	{
	 send_to_char( "Invalid target.\n\r", ch);
	}
 }

void do_hd( CHAR_DATA *ch, char *argument )
{
     char bufbuf[MAX_STRING_LENGTH];
     bufbuf[0] = '\0';

     if (IS_NPC(ch))
	return;

    strcat(bufbuf,"Naturally, you can hit ");
    if ( GET_HITROLL(ch) < 0 ) strcat(bufbuf, "the broad side of a barn.\r\n");
    if ( GET_HITROLL(ch) >= 0 && GET_HITROLL(ch) <= 2) strcat(bufbuf, "things pointed out to you.\r\n");
    if ( GET_HITROLL(ch) >= 3 && GET_HITROLL(ch) <= 5) strcat(bufbuf, "better than a kender warrior.\r\n");
    if ( GET_HITROLL(ch) >= 6 && GET_HITROLL(ch) <= 8 ) strcat(bufbuf, "things alright, but you could do better.\r\n");
    if ( GET_HITROLL(ch) >= 9 && GET_HITROLL(ch) <= 10 ) strcat(bufbuf, "pretty good.  That night class in melee really helped you out.\r\n");
    if ( GET_HITROLL(ch) >= 11 && GET_HITROLL(ch) <= 17 ) strcat(bufbuf, "things fairly well.\r\n");
    if ( GET_HITROLL(ch) >= 18 ) strcat(bufbuf, "things really really well.  Good job!\r\n");

    strcat(bufbuf,"With your magical bonuses, you can hit ");
    if ( GET_SECOND_HITROLL(ch) < 0 ) strcat(bufbuf, "the broad side of a barn.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 0 && GET_SECOND_HITROLL(ch)<= 5) strcat(bufbuf, "things affected by continual light.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 6 && GET_SECOND_HITROLL(ch)<= 10 ) strcat(bufbuf, "things alright, but you could do better.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 11 && GET_SECOND_HITROLL(ch)<= 17 ) strcat(bufbuf, "a black cat in a dark cellar at midnight.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 18 ) strcat(bufbuf, "anything.  You can't miss.  Nice weapons skills.\r\n");

    strcat(bufbuf,"Naturally, when you hit things ");
    if ( GET_DAMROLL(ch) < 0 ) strcat(bufbuf, "your oppoents look at you funny.\r\n");
    if ( GET_DAMROLL(ch) >= 0 && GET_DAMROLL(ch)<= 5) strcat(bufbuf, "your target says \"Ow.  That hurt.\"\r\n");
    if ( GET_DAMROLL(ch) >= 6 && GET_DAMROLL(ch)<= 10 ) strcat(bufbuf, "your victim calls their HMO to see if this wound is covered.\r\n");
    if ( GET_DAMROLL(ch) >= 11 && GET_DAMROLL(ch)<= 17 ) strcat(bufbuf, " people fall down and go {YBOOM{x!\r\n");
    if ( GET_DAMROLL(ch) >= 18 ) strcat(bufbuf, "shit happens.\r\n");

    strcat(bufbuf,"After factoring in your bonuses, when you hit things ");
    if ( GET_SECOND_DAMROLL(ch) < 0 ) strcat(bufbuf, "the whole SLED laughs at you.\r\n");
    if ( GET_SECOND_DAMROLL(ch) >= 0 && GET_SECOND_DAMROLL(ch)<= 5) strcat(bufbuf, "people sit up and pay attention.\r\n");
    if ( GET_SECOND_DAMROLL(ch) >= 6 && GET_SECOND_DAMROLL(ch)<= 10 ) strcat(bufbuf, "blood is drawn and body parts fall off.\r\n");
    if ( GET_SECOND_DAMROLL(ch) >= 11 && GET_SECOND_DAMROLL(ch)<= 17 ) strcat(bufbuf, "you do some serious damage.\r\n");
    if ( GET_SECOND_DAMROLL(ch) >= 18 ) strcat(bufbuf, "nothing is left except a pale pink mist.\r\n");


/*

     sprintf( buf, "Hitroll: %d/%d  Damroll: %d/%d.\n\r",
             GET_HITROLL(ch),GET_SECOND_HITROLL(ch), 
             GET_DAMROLL(ch),GET_SECOND_DAMROLL(ch) );
*/

     send_to_char( bufbuf, ch );
}

bool check_match( CHAR_DATA *ch, CHAR_DATA *victim)
{

  if (!IS_SET(ch->display, DISP_BRIEF_SCAN))
     return TRUE;

  if ( (is_clan(ch) && is_clan(victim)) ||
       (!is_clan(ch) && !is_clan(victim)) )
	 return TRUE;

  return FALSE;
}

void do_enemy( CHAR_DATA *ch, char *argument )
{
   char buf[MAX_STRING_LENGTH];
   DESCRIPTOR_DATA *d;
   CHAR_DATA *victim;
   char arg1[MAX_INPUT_LENGTH];

/* Enemy code killed by NIGHTDAGGER on 04/25/2003 */
   send_to_char("Enemy lists don't exist anymore.\n\r",ch);
   return;

   if (ch->clan != clan_lookup("warlock")
       && ch->clan != clan_lookup("zealot")
       && ch->clan != clan_lookup("honor")
       && ch->clan != clan_lookup("posse"))
      return;

   one_argument(argument, arg1);

   if( ch->pcdata->rank == MAX_RANK && arg1[0] != '\0' )
   {
      if ( (victim = get_char_world(ch, arg1)) == NULL )
      {
         send_to_char("They aren't here.\n\r", ch);
         return;
      }

      if (IS_NPC(victim))
      {
         send_to_char("Don't be a fucknut.\n\r", ch);
         return;
      }

      if (ch->clan == clan_lookup("warlock"))
         if (IS_SET(victim->mhs,MHS_WARLOCK_ENEMY))
	    REMOVE_BIT(victim->mhs,MHS_WARLOCK_ENEMY);

      if (ch->clan == clan_lookup("zealot"))
         if (IS_SET(victim->mhs,MHS_ZEALOT_ENEMY))
	    REMOVE_BIT(victim->mhs,MHS_ZEALOT_ENEMY);

      if (ch->clan == clan_lookup("posse"))
         if (IS_SET(victim->mhs,MHS_POSSE_ENEMY))
	    REMOVE_BIT(victim->mhs,MHS_POSSE_ENEMY);

      if (ch->clan == clan_lookup("honor"))
         if (IS_SET(victim->mhs,MHS_HONOR_ENEMY))
	    REMOVE_BIT(victim->mhs,MHS_HONOR_ENEMY);

      send_to_char("Enemy Removed.",ch);
   }
   else
   {
      if(ch->clan == clan_lookup("warlock"))
      {
         strcpy( buf, "WARLOCK ENEMIES:\n\r");
         for (d = descriptor_list; d != NULL; d = d->next)
         {
            if (d->character != NULL)
            {
               if (IS_SET(d->character->mhs, MHS_WARLOCK_ENEMY))
               {
                  strcat( buf, d->character->name);
                  strcat( buf, "\n\r");
	       }
            }
	 }
      }
      if(ch->clan == clan_lookup("posse"))
      {
         strcpy( buf, "POSSE ENEMIES:\n\r");
         for (d = descriptor_list; d != NULL; d = d->next)
         {
            if (d->character != NULL)
            {
               if (IS_SET(d->character->mhs, MHS_POSSE_ENEMY))
               {
                  strcat( buf, d->character->name);
                  strcat( buf, "\n\r");
	       }
            }
	 }
      }
      if(ch->clan == clan_lookup("zealot"))
      {
         strcpy( buf, "ZEALOT ENEMIES:\n\r");
         for (d = descriptor_list; d != NULL; d = d->next)
         {
            if (d->character != NULL)
            {
               if (IS_SET(d->character->mhs, MHS_ZEALOT_ENEMY))
               {
                  strcat( buf, d->character->name);
                  strcat( buf, "\n\r");
	       }
            }
	 }
      }
      if(ch->clan == clan_lookup("honor"))
      {
         strcpy( buf, "HONOR ENEMIES:\n\r");
         for (d = descriptor_list; d != NULL; d = d->next)
         {
            if (d->character != NULL)
            {
               if (IS_SET(d->character->mhs, MHS_HONOR_ENEMY))
               {
                  strcat( buf, d->character->name);
                  strcat( buf, "\n\r");
	       }
            }
	 }
      }
      send_to_char( buf, ch );
   }
   return;
}

void do_surname( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];

    argument = one_argument_cs( argument, arg );
    
    arg[0] = UPPER(arg[0]);

    if ( arg[0] == '\0' )
    {
	send_to_char("Syntax: surname <name>\n\r",ch);
	return;
    }

    if ( !str_cmp(arg,"show") )
    {
	send_to_char("The 'Show' family is plenty big already.\n\r",ch);
	return;
    }

    if ( !str_cmp(arg,"brief") )
    {
	send_to_char("Your really want to do 'brief surname' right? \n\r",ch);
	return;
    }

    if ( IS_NPC(ch) )
    {
	send_to_char("Your last name is Mob.\n\r",ch);
	return;
    }

    if ( ch->pcdata->surname != NULL )
    {
	send_to_char("You already picked a surname.\n\r",ch);
	return;
    }

    if ( strlen(arg) > 12 )
    {
	send_to_char("Surnames cannot be more than 12 characters long.\n\r",ch);
	return;
    }
 
    /* Same rules as first names */  
    if ( !check_parse_surname( arg ) )
    {
	send_to_char("That names contains invalid characters.\n\r",ch);
	return;
    }

    /* Whew!  I think that's all the snaity checking we need */
    ch->pcdata->surname = str_dup(arg);
    sprintf(buf,"Your surname is '%s'.\n\r",ch->pcdata->surname);
    send_to_char(buf,ch);
    return;
}

void do_newbie(CHAR_DATA *ch, char *argument)
{
    if (IS_NPC(ch))
      return;

    if (ch->clan == clan_lookup("newbie"))  
    {
       ch->clan = 0;
       send_to_char("You have turned off your newbie flag.",ch);
       return;
    }
    else
    {
     send_to_char("Your newbie flag is off and can not be turned back on.",ch); 
     return;
    }
    return;
}
@


1.422
log
@04/01/04 Nightdagger:  Modification to do_who for APRIL FOOLS!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.421 2003/12/13 14:36:46 boogums Exp $";
a3410 1
    int fakelevel;
d3612 1
a3612 5
  /* NIGHTDAGGER APRIL FOOLS!
  class = class_table[wch->class].who_name; */


  class = "War";   /* DELETE THIS LINE AFTER APRIL FOOLS! */
a3633 1
/*  NIGHTDAGGER APRIL FOOLS! 
a3641 1
*/
a3643 1
       display_race = "Human";   /* DELETE THIS LINE AFTER APRIL FOOLS! */ 
a3722 1
  fakelevel = 5;    /* DELETE THIS LINE AFTER APRIL FOOLS */
d3724 1
a3724 3
      /* NIGHTDAGGER APRIL FOOLS!
      wch->level, */
      fakelevel,  /* DELETE THIS LINE AFTER APRIL FOOLS */
@


1.421
log
@nofollow dismount message
1
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.420 2003/12/10 03:15:59 boogums Exp $";
d3411 1
d3574 1
a3574 1
      || (wch->level == level && IS_SET(wch->display,DISP_CODER))
d3613 6
a3618 1
  class = class_table[wch->class].who_name;
d3638 3
a3640 1
    if (IS_SET(wch->mhs,MHS_SHAPESHIFTED))
d3648 4
d3731 1
d3733 3
a3735 1
      wch->level,
@


1.420
log
@nofollow/mount bug fixed
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.419 2003/11/29 23:31:32 boogums Exp $";
d1717 4
a1720 1
       do_dismount(ch," ");
@


1.419
log
@taking out research skill
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.418 2003/11/29 21:43:29 boogums Exp $";
d46 1
a46 1
 
d1716 2
@


1.418
log
@added tuff to peek
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.417 2003/11/29 16:21:11 boogums Exp $";
a4568 2
	if ( sn == skill_lookup("research") )
		adept = 95; 
@


1.417
log
@slight tweakings
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.416 2003/11/29 02:06:11 boogums Exp $";
d1043 2
a1044 1
          ch->class == class_lookup("rogue")) && 
@


1.416
log
@adding some twists
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.415 2003/11/29 01:29:02 boogums Exp $";
d1042 8
a1049 14
       /*   This code killed by NIGHTDAGGER
       if (ch->clan == clan_lookup("avarice") 
	   && !IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1))
       {
          sprintf(buf,"They appear to have %ld gold and %ld silver.\n\r",
                  victim->gold,victim->silver);
          send_to_char(buf,ch);
       }
       End code nerf */
       if (is_clan(ch) && number_percent() < 25 )
       {
          sprintf(buf,"They appear to have %ld gold and %ld silver.\n\r",
                  victim->gold,victim->silver);
          send_to_char(buf,ch);
d2451 1
a2451 1
   sprintf(buf,"You have %ld gold and %ld silver.\n\r",
d2645 10
a2654 3
  sprintf(buf, "Your have %d of %d hit points, %d of %d mana, %d of %d moves.\n\r",
    ch->hit,ch->max_hit,ch->mana,ch->max_mana,ch->move,ch->max_move);
  send_to_char(buf, ch);
@


1.415
log
@testing some enw stuff
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.414 2003/08/30 21:53:53 boogums Exp $";
a2633 2
sprintf(buf, "Your have %d of %d hit points, %d of %d mana, %d of %d moves.\n\r",ch->hit, ch->max_hit,ch->mana,ch->max_mana,ch->move,ch->max_move );
send_to_char(buf, ch);
d2650 4
@


1.414
log
@ok broke the hd descrptions down a bit and i think i got rid of that
annoying garbage when you quit with a buf[0] = '\0';
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.413 2003/08/17 19:36:47 boogums Exp $";
d1051 8
d2097 2
a2098 2
   show_char_to_char_1( victim, ch );
   return;
d2633 5
a2637 1
 
@


1.413
log
@t lets see if this gets it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.412 2003/08/17 19:29:35 boogums Exp $";
d4813 4
a4816 2
    if ( GET_HITROLL(ch) >= 0 && GET_HITROLL(ch) <= 5) strcat(bufbuf, "things pointed out to you.\r\n");
    if ( GET_HITROLL(ch) >= 6 && GET_HITROLL(ch) <= 10 ) strcat(bufbuf, "things alright, but you could do better.\r\n");
@


1.412
log
@ok i think i got it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.411 2003/08/17 18:26:09 boogums Exp $";
d4806 1
@


1.411
log
@back into play it goes
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.410 2003/08/17 18:22:03 boogums Exp $";
d4805 1
a4805 1
     char buf[MAX_STRING_LENGTH];
d4810 27
a4836 27
    strcat(buf,"Naturally, you can hit ");
    if ( GET_HITROLL(ch) < 0 ) strcat(buf, "the broad side of a barn.\r\n");
    if ( GET_HITROLL(ch) >= 0 && GET_HITROLL(ch) <= 5) strcat(buf, "things pointed out to you.\r\n");
    if ( GET_HITROLL(ch) >= 6 && GET_HITROLL(ch) <= 10 ) strcat(buf, "things alright, but you could do better.\r\n");
    if ( GET_HITROLL(ch) >= 11 && GET_HITROLL(ch) <= 17 ) strcat(buf, "things fairly well.\r\n");
    if ( GET_HITROLL(ch) >= 18 ) strcat(buf, "things really really well.  Good job!\r\n");

    strcat(buf,"With your magical bonuses, you can hit ");
    if ( GET_SECOND_HITROLL(ch) < 0 ) strcat(buf, "the broad side of a barn.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 0 && GET_SECOND_HITROLL(ch)<= 5) strcat(buf, "things affected by continual light.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 6 && GET_SECOND_HITROLL(ch)<= 10 ) strcat(buf, "things alright, but you could do better.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 11 && GET_SECOND_HITROLL(ch)<= 17 ) strcat(buf, "a black cat in a dark cellar at midnight.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 18 ) strcat(buf, "anything.  You can't miss.  Nice weapons skills.\r\n");

    strcat(buf,"Naturally, when you hit things ");
    if ( GET_DAMROLL(ch) < 0 ) strcat(buf, "your oppoents look at you funny.\r\n");
    if ( GET_DAMROLL(ch) >= 0 && GET_DAMROLL(ch)<= 5) strcat(buf, "your target says \"Ow.  That hurt.\"\r\n");
    if ( GET_DAMROLL(ch) >= 6 && GET_DAMROLL(ch)<= 10 ) strcat(buf, "your victim calls their HMO to see if this wound is covered.\r\n");
    if ( GET_DAMROLL(ch) >= 11 && GET_DAMROLL(ch)<= 17 ) strcat(buf, " people fall down and go {YBOOM{x!\r\n");
    if ( GET_DAMROLL(ch) >= 18 ) strcat(buf, "shit happens.\r\n");

    strcat(buf,"After factoring in your bonuses, when you hit things ");
    if ( GET_SECOND_DAMROLL(ch) < 0 ) strcat(buf, "the whole SLED laughs at you.\r\n");
    if ( GET_SECOND_DAMROLL(ch) >= 0 && GET_SECOND_DAMROLL(ch)<= 5) strcat(buf, "people sit up and pay attention.\r\n");
    if ( GET_SECOND_DAMROLL(ch) >= 6 && GET_SECOND_DAMROLL(ch)<= 10 ) strcat(buf, "blood is drawn and body parts fall off.\r\n");
    if ( GET_SECOND_DAMROLL(ch) >= 11 && GET_SECOND_DAMROLL(ch)<= 17 ) strcat(buf, "you do some serious damage.\r\n");
    if ( GET_SECOND_DAMROLL(ch) >= 18 ) strcat(buf, "nothing is left except a pale pink mist.\r\n");
d4846 1
a4846 1
     send_to_char( buf, ch );
@


1.410
log
@typo
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.409 2003/08/17 18:18:56 boogums Exp $";
d4816 1
d4830 1
@


1.409
log
@doh i'm lazy and missted things
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.408 2003/08/17 18:11:14 boogums Exp $";
d4821 1
a4821 1
    if ( GET_SECOND_HITROLL(ch) >= 18 ) strcat(buf, "You can't miss.  Nice weapons skills.\r\n");
@


1.408
log
@putting back in hd command witha  twist
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.407 2003/05/30 02:23:04 ndagger Exp $";
d4818 3
a4820 3
    if ( GET_SECOND_HITROLL(ch) >= 0 && GET_HITROLL(ch)<= 5) strcat(buf, "things affected by continual light.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 6 && GET_HITROLL(ch)<= 10 ) strcat(buf, "things alright, but you could do better.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 11 && GET_HITROLL(ch)<= 17 ) strcat(buf, "a black cat in a dark cellar at midnight.\r\n");
d4824 5
a4828 5
    if ( GET_HITROLL(ch) < 0 ) strcat(buf, "your oppoents look at you funny.\r\n");
    if ( GET_HITROLL(ch) >= 0 && GET_HITROLL(ch)<= 5) strcat(buf, "your target says \"Ow.  That hurt.\"\r\n");
    if ( GET_HITROLL(ch) >= 6 && GET_HITROLL(ch)<= 10 ) strcat(buf, "your victim calls their HMO to see if this wound is covered.\r\n");
    if ( GET_HITROLL(ch) >= 11 && GET_HITROLL(ch)<= 17 ) strcat(buf, " people fall down and go {YBOOM{x!\r\n");
    if ( GET_HITROLL(ch) >= 18 ) strcat(buf, "shit happens.\r\n");
d4830 5
a4834 5
    if ( GET_SECOND_HITROLL(ch) < 0 ) strcat(buf, "the whole SLED laughs at you.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 0 && GET_HITROLL(ch)<= 5) strcat(buf, "people sit up and pay attention.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 6 && GET_HITROLL(ch)<= 10 ) strcat(buf, "blood is drawn and body parts fall off.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 11 && GET_HITROLL(ch)<= 17 ) strcat(buf, "you do some serious damage.\r\n");
    if ( GET_SECOND_HITROLL(ch) >= 18 ) strcat(buf, "nothing is left except a pale pink mist.\r\n");
@


1.407
log
@05/29/03 Nightdagger:  All clan skills nerfed to prepare for new ones.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.406 2003/05/29 17:45:34 boogums Exp $";
d4810 29
d4842 2
@


1.406
log
@yanking cstat for now
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.405 2003/04/25 05:15:38 ndagger Exp $";
d1041 2
d1050 2
@


1.405
log
@04/25/2003 Nightdagger:  Killed enemy command, and enemy display in score.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.404 2003/02/22 05:04:50 boogums Exp $";
d3321 4
@


1.404
log
@brief room fixed
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.403 2003/01/28 18:50:36 rusty Exp $";
d2798 2
d2820 1
a2820 1

d4827 4
@


1.403
log
@lint fixes and make brief command more verbose
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.402 2003/01/03 19:41:51 boogums Exp $";
d1549 3
@


1.402
log
@3jan02
making turn undead wands less effective
making dispel magic scrolls less effective
making precious pab flag white for the blind players we have
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.401 2003/01/03 06:32:05 mud Exp $";
d1569 1
d1577 2
d1580 5
@


1.401
log
@ch to wch in PAB flag thing
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.400 2003/01/03 06:24:12 rusty Exp $";
d1955 1
a1955 1
     if ( IS_OUTSIDE(ch) && (number_range(0,20) < 5 ) )
d3258 1
a3258 1
		(IS_SET(wch->pcdata->clan_flags, CLAN_PAB) ? "[{CPAB{x] " : ""),
d3280 1
a3280 1
		(IS_SET(wch->pcdata->clan_flags, CLAN_PAB) ? "[{CPAB{x] " : ""),
d3662 1
a3662 1
		(IS_SET(wch->pcdata->clan_flags, CLAN_PAB) ? "[{CPAB{x] " : ""),
d3688 1
a3688 1
		(IS_SET(wch->pcdata->clan_flags, CLAN_PAB) ? "[{CPAB{x] " : ""),
@


1.400
log
@Parens in the right place so everyone isn't in PAB
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.399 2003/01/01 17:15:10 mud Exp $";
d3258 1
a3258 1
		(IS_SET(ch->pcdata->clan_flags, CLAN_PAB) ? "[{CPAB{x] " : ""),
d3280 1
a3280 1
		(IS_SET(ch->pcdata->clan_flags, CLAN_PAB) ? "[{CPAB{x] " : ""),
d3662 1
a3662 1
		(IS_SET(ch->pcdata->clan_flags, CLAN_PAB) ? "[{CPAB{x] " : ""),
d3688 1
a3688 1
		(IS_SET(ch->pcdata->clan_flags, CLAN_PAB) ? "[{CPAB{x] " : ""),
@


1.399
log
@Missing space after PAB flag info
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.398 2003/01/01 17:04:26 rusty Exp $";
d3258 1
a3258 1
		IS_SET(ch->pcdata->clan_flags, CLAN_PAB)? "[{CPAB{x] " : "",
d3280 1
a3280 1
		IS_SET(ch->pcdata->clan_flags, CLAN_PAB)? "[{CPAB{x] " : "",
d3662 1
a3662 1
		IS_SET(ch->pcdata->clan_flags, CLAN_PAB)? "[{CPAB{x] " : "",
d3688 1
a3688 1
		IS_SET(ch->pcdata->clan_flags, CLAN_PAB)? "[{CPAB{x] " : "",
@


1.398
log
@Added CLAN_PAB flag and made it show in who/whois when they are not AFK
as well as letting them read "note to pab"
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.397 2002/12/23 03:16:24 ndagger Exp $";
d3258 1
a3258 1
		IS_SET(ch->pcdata->clan_flags, CLAN_PAB)? "[{CPAB{x]" : "",
d3280 1
a3280 1
		IS_SET(ch->pcdata->clan_flags, CLAN_PAB)? "[{CPAB{x]" : "",
d3662 1
a3662 1
		IS_SET(ch->pcdata->clan_flags, CLAN_PAB)? "[{CPAB{x]" : "",
d3688 1
a3688 1
		IS_SET(ch->pcdata->clan_flags, CLAN_PAB)? "[{CPAB{x]" : "",
@


1.397
log
@12/22/02 Nightdagger:  added message to time command for doublexp bonuses being on.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.396 2002/12/23 00:37:27 boogums Exp $";
d3257 2
a3258 1
           IS_SET(wch->comm, COMM_AFK) ? "[{CAFK{x] " : "",
d3279 2
a3280 1
       IS_SET(wch->comm, COMM_AFK) ? "[{CAFK{x] " : "",
d3661 2
a3662 1
             IS_SET(wch->comm, COMM_AFK) ? "[{CAFK{x] " : "",
d3687 2
a3688 1
      IS_SET(wch->comm, COMM_AFK) ? "[{CAFK{x] " : "",
@


1.396
log
@trying the buffy swap out thing on OLC
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.395 2002/12/09 18:47:35 boogums Exp $";
d3025 4
@


1.395
log
@damn waterbreathing bug
damn boolean logic
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.394 2002/12/02 23:06:35 boogums Exp $";
d802 22
@


1.394
log
@\r\n on the weather messages
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.393 2002/12/02 05:35:58 boogums Exp $";
d1933 1
a1933 1
     if ( IS_OUTSIDE(ch) && (number_range(0,10) < 4 ) )
@


1.393
log
@tweaked messages
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.392 2002/12/02 05:24:17 boogums Exp $";
d1940 1
a1940 1
          send_to_char("{bA warm southerly breeze warms your chilled bones.{x",ch);
d1944 1
a1944 1
          send_to_char("{bA cold northerly wind howls around you.{x",ch);
d1950 1
a1950 1
	  send_to_char("{bThe clouds seem to be breaking up{x",ch);
d1954 1
a1954 1
	  send_to_char("{bThe clouds seem to be thickening, looks like rains coming.{x",ch);
d1960 1
a1960 1
          send_to_char("{bA warm tropical rain falls from the heavens.{x",ch);
d1964 1
a1964 1
          send_to_char("{bA cold northerly wind blows the rain into your face.{x",ch);
d1970 1
a1970 1
          send_to_char("{YWHOA!{x{b That lightning looks dangerous.  Thankfully the worse has passed.{x",ch);
d1974 1
a1974 1
          send_to_char("{YWHOA!{x{b That lightning looks very dangerous.{x",ch);
@


1.392
log
@turning off weather messages if brief room is togled on
more code wrapped in the wand kit
spells adjusted to be wandable and not
luria's message added to fight.c
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.391 2002/12/01 06:08:19 boogums Exp $";
d1933 1
a1933 1
     if ( IS_OUTSIDE(ch) && (number_range(0,20) < 4 ) )
@


1.391
log
@ok weather messages goign in
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.390 2002/12/01 05:53:38 boogums Exp $";
d1931 1
a1931 1
   }
d1933 2
a1934 2
   if ( IS_OUTSIDE(ch) && (number_range(0,10) < 3 ) )
   {
d1940 1
a1940 1
          send_to_char("{bA warm southerly breeze warms your chilled bones.{x\r\n",ch);
d1944 1
a1944 1
          send_to_char("{bA cold northerly wind howls around you.{x\r\n",ch);
d1950 1
a1950 1
	  send_to_char("{bThe clouds seem to be breaking up{x\r\n",ch);
d1954 1
a1954 1
	  send_to_char("{bThe clouds seem to be thickening, looks like rains coming.{x\r\n",ch);
d1960 1
a1960 1
          send_to_char("{bA warm tropical rain falls from the heavens.{x\r\n",ch);
d1964 1
a1964 1
          send_to_char("{bA cold northerly wind blows the rain into your face.{x\r\n",ch);
d1970 1
a1970 1
          send_to_char("{YWHOA!{x{b That lightning looks dangerous.  Thankfully the worse has passed.{x\r\n",ch);
d1974 1
a1974 1
          send_to_char("{YWHOA!{x{b That lightning looks very dangerous.{x\r\n",ch);
d1980 3
a1982 2
   } //end of weather messages
 
@


1.390
log
@testing weather  messages
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.389 2002/12/01 05:49:30 boogums Exp $";
d1933 1
a1933 1
   if ( IS_OUTSIDE(ch) && (number_range(0,10) < 11 ) )
@


1.389
log
@ok coreycodeing all the weather stuff
corey
i figure we got he box with the processor, we might as well
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.388 2002/12/01 05:37:46 boogums Exp $";
d1932 2
a1933 2
#ifdef COREYTEST 
   if ( IS_OUTSIDE(ch) && (number_range(0,10) > 11 ) )
d1980 1
a1980 5

	

   }
#endif
@


1.388
log
@adding somew eather related code
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.387 2002/10/26 03:09:46 ndagger Exp $";
d1932 1
d1984 1
a1984 1

@


1.387
log
@10/25/02 Nightdagger:  Consider now lies to you if you're drunk, impaired judgement.  Dwarves think they're gods when drunk and using consider.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.386 2002/10/14 06:13:32 ndagger Exp $";
d1932 52
@


1.386
log
@10/14/02 Nightdagger-  *screams in frustration* Ok, there's no reason ignoring hidey people shouldn't work now, if it still messes with me I'll put it off for another time.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.385 2002/10/14 06:09:34 ndagger Exp $";
d3950 9
@


1.385
log
@10/14/02 Nightdagger-  ignore <non-player-name> crashing OLC on tests...trying to idiot proof it so you can't accidently try to ignore NULL.  If this doesn't work, I'll temporarily comment out the do_ignore function body.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.384 2002/10/14 05:58:18 ndagger Exp $";
d4676 1
a4676 1
  if ( ignore != NULL && can_see(ch, ignore, TRUE) && !IS_NPC(ignore) )
@


1.384
log
@10/14/02 Nightdagger-  removing can_see from do_ignore crashed OLC, so I put it back in for now.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.383 2002/10/14 05:49:08 ndagger Exp $";
d4663 5
a4667 1
  ignore = get_char_world( ch, arg );
d4669 1
@


1.383
log
@10/14/02 Nightdagger-  I'm on a roll, fixed ignore change, it should work now
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.382 2002/10/14 05:21:23 ndagger Exp $";
d4671 2
a4672 2
  if ( ignore != NULL && !IS_NPC(ignore) )
	{
@


1.382
log
@10/14/02 Nightdagger-  changed ignore so you can ignore hiding/sneaking/invis people.  Immortals are still invalid targets.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.381 2002/06/14 19:33:26 rusty Exp $";
d4665 7
a4671 1
  if ( ignore != NULL && !IS_IMMORTAL(ignore) && !IS_NPC(ignore) )
@


1.381
log
@Allow ' in Surname
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.380 2002/03/12 15:55:23 rusty Exp $";
d4665 1
a4665 1
  if ( ignore != NULL && can_see(ch,ignore,TRUE) && !IS_NPC(ignore) )
@


1.380
log
@Send level update buf
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.379 2002/03/11 07:44:04 rusty Exp $";
d4868 1
a4868 1
    if ( !check_parse_name( arg ) )
@


1.379
log
@Level 35 check out of surname
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.378 2002/03/11 02:48:08 rusty Exp $";
d2706 1
a2706 1
  { strcat(buf,"non existant\n\r"); }
@


1.378
log
@Took out stupid IMC stuff and fixed do-report() typos
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.377 2002/03/11 02:23:57 rusty Exp $";
a4846 6
    }

    if ( ch->level < 35 )
    {
 	send_to_char("You must be at least level 35 to pick a surname.\n\r",ch);
     	return;
@


1.377
log
@Took out numbers in do_report()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.376 2002/03/10 22:48:18 rusty Exp $";
d4199 1
d4213 1
a4213 1
    sprintf(wound,"I am in excellent condition, ");
d4215 3
a4217 3
    sprintf(wound,"I have a few scratches, ");
      else if (percent >= 75
    sprintf(wound,"I have some small wounds and bruises, ");
d4219 1
a4219 1
    sprintf(wound,"I have quite a few wounds, ");
d4221 1
a4221 1
    sprintf(wound,"I have some big nasty wounds and scratches, ");
d4223 1
a4223 1
    sprintf(wound,"I am pretty hurt, ");
d4225 1
a4225 1
    sprintf(wound,"I am in awful condition, ");
d4227 1
a4227 1
    sprintf(wound,"I am bleeding to death, ");
d4235 1
a4235 1
    sprintf(mental,"am mentally fit ");
d4237 1
a4237 1
    sprintf(mental,"am a bit slow ");
d4239 1
a4239 1
    sprintf(mental,"have some mental lapses ");
d4241 1
a4241 1
    sprintf(mental,"am quite drained ");
d4243 1
a4243 1
    sprintf(mental,"feel dazed ");
d4245 1
a4245 1
    sprintf(mental,"am nearly spent ");
d4247 1
a4247 1
    sprintf(mental,"am brain dead ");
d4249 1
a4249 1
    sprintf(mental,"am helpless ");
d4257 1
a4257 1
    sprintf(moves,"and am full of energy.");
d4259 1
a4259 1
    sprintf(moves,"and am energetic.");
d4261 1
a4261 1
    sprintf(moves,"and am breathing hard.");
d4263 1
a4263 1
    sprintf(moves,"and my heart is pounding.");
d4265 1
a4265 1
    sprintf(moves,"and feel winded.");
d4267 1
a4267 1
    sprintf(moves,"and am cramping up.");
d4269 1
a4269 1
    sprintf(moves,"and am exhausted.");
d4271 1
a4271 1
    sprintf(moves,"and am motionless.");
@


1.376
log
@Saves info fix
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.375 2002/03/10 22:39:08 rusty Exp $";
d4196 3
d4206 66
d4273 2
a4274 4
   "You say 'I have %d/%d hp %d/%d mana %d/%d mv %d xp.'\n\r",
   ch->hit,  ch->max_hit,
   ch->mana, ch->max_mana,
   ch->move, ch->max_move,
d4279 2
a4280 4
     sprintf( buf, "$n says 'I have %d/%d hp %d/%d mana %d/%d mv %d xp.'",
   ch->hit,  ch->max_hit,
   ch->mana, ch->max_mana,
   ch->move, ch->max_move,
@


1.375
log
@Took out HR and DR info
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.374 2002/03/10 22:37:04 rusty Exp $";
d2705 2
d2831 1
a2831 2
   sprintf( buf, "Sac Points: %d\n\r", ch->alignment, 
	IS_NPC(ch) ? 0 : ch->pcdata->sac );
@


1.374
log
@Yanked align number
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.373 2002/03/09 20:16:02 mud Exp $";
d2800 1
a2800 1
 
d2812 1
a2812 1
     
@


1.373
log
@Missing }
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.372 2002/03/09 20:02:13 rusty Exp $";
a2812 4
   sprintf( buf, "Alignment: %d   Sac Points: %d\n\r", ch->alignment, 
	IS_NPC(ch) ? 0 : ch->pcdata->sac );
   send_to_char( buf, ch );
 
d2817 2
a2818 2
     else if ( ch->alignment >  100 ) send_to_char( "a kind ",ch );
     else if ( ch->alignment > -100 ) send_to_char( "a neutral ", ch );
d2825 1
a2825 1
     sprintf(buf,"follower of %s.\n\r", IS_NPC(ch) ? "yourself." :
d2829 4
@


1.372
log
@gtscore() add moved gladiator stats out of score
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.371 2002/03/09 19:55:58 rusty Exp $";
d2454 3
a2456 4
	else
	{
	  send_to_char("\n\r",ch);
	}
@


1.371
log
@Info changes/fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.370 2002/03/09 19:14:26 rusty Exp $";
a2459 19
     return;
}

void do_gscore( CHAR_DATA *ch, char *argument )
{
     char buf[MAX_STRING_LENGTH];

     if(!IS_NPC(ch))
     {
	sprintf(buf,"Single Events Played: %d  Victories: %d  Kills: %d \n\r "
	"Team Events Played: %d  Victories: %d  Kills: %d\n\r",
	       ch->pcdata->gladiator_data[GLADIATOR_PLAYS],
	       ch->pcdata->gladiator_data[GLADIATOR_VICTORIES],
	       ch->pcdata->gladiator_data[GLADIATOR_KILLS],
	       ch->pcdata->gladiator_data[GLADIATOR_TEAM_PLAYS],
	       ch->pcdata->gladiator_data[GLADIATOR_TEAM_VICTORIES], 
	       ch->pcdata->gladiator_data[GLADIATOR_TEAM_KILLS]);
	send_to_char(buf,ch);
     }
@


1.370
log
@Hiding information and reup_affect() additions. Initial
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.369 2002/02/25 19:49:39 poquah Exp $";
d2422 62
a2483 3
 
 void do_score( CHAR_DATA *ch, char *argument )
 {
a2600 33
     if(!IS_NPC(ch) && is_clan(ch))
	{
	sprintf( buf, "Kills: Lower: %d Equal: %d Greater: %d\n\r", 
		ch->pcdata->killer_data[PC_LOWER_KILLS],
		ch->pcdata->killer_data[PC_EQUAL_KILLS],
                ch->pcdata->killer_data[PC_GREATER_KILLS]);
	send_to_char(buf, ch);
	if (ch->pcdata->steal_data[PC_STOLEN_ITEMS] > 0
	    || ch->pcdata->steal_data[PC_STOLEN_GOLD] > 0) 
	{
	sprintf( buf, "Stolen: %ld items %ld gold",  
		ch->pcdata->steal_data[PC_STOLEN_ITEMS],
		ch->pcdata->steal_data[PC_STOLEN_GOLD]); 
	send_to_char(buf, ch);
	}
	if (ch->pcdata->steal_data[PC_SLICES] > 0)
	{
	sprintf( buf, "Slices: %ld  ", 
		ch->pcdata->steal_data[PC_SLICES]);
	send_to_char(buf, ch);
	}
	if( ch->pcdata->outcT > 0 || ch->pcdata->ruffT )
	{
	  sprintf( buf, "Outcast ticks: %d  Ruffian ticks: %d\n\r",
	  ch->pcdata->outcT,ch->pcdata->ruffT);
	  send_to_char(buf,ch);
	}
	else
	{
	  send_to_char("\n\r",ch);
	}
	}

a2608 13
     if(!IS_NPC(ch))
     {
	sprintf(buf,"Single Events Played: %d  Victories: %d  Kills: %d \n\r "
	"Team Events Played: %d  Victories: %d  Kills: %d\n\r",
	       ch->pcdata->gladiator_data[GLADIATOR_PLAYS],
	       ch->pcdata->gladiator_data[GLADIATOR_VICTORIES],
	       ch->pcdata->gladiator_data[GLADIATOR_KILLS],
	       ch->pcdata->gladiator_data[GLADIATOR_TEAM_PLAYS],
	       ch->pcdata->gladiator_data[GLADIATOR_TEAM_VICTORIES], 
	       ch->pcdata->gladiator_data[GLADIATOR_TEAM_KILLS]);
	send_to_char(buf,ch);
     }

d2712 13
a2724 3
     if (ch->level >=30)
     {
  sprintf(buf,"Saving Throw Adjustment: %d\n\r",ch->saving_throw);
a2725 1
     }
@


1.369
log
@fixing spelling mistake in species enemy
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.368 2002/02/11 19:38:22 poquah Exp $";
d950 3
d1547 8
a1554 1

d1612 1
a1612 1
       strcpy( buf, "<%hhp %mm %vmv> ");
d2383 2
a2384 2
     sprintf( buf,
   "Str: %d(%d)  Int: %d(%d)  Wis: %d(%d)  Dex: %d(%d)  Con: %d(%d)\n\r",
d2391 2
d2395 4
d2404 1
a2404 1
      send_to_char("Your attributes are:\n\r  ",ch);
d2413 1
a2413 1
      sprintf(buf2,"$n says 'My stats:%s'\n\r",buf);
d2416 1
a2416 1
      sprintf(buf2,"You say 'My stats: %s'\n\r",buf);
d2427 72
a2498 1
     int i;
d2509 4
a2512 6
   "You are %s%s%s, level %d(%d), %d years old (%d hours).\n\r",
   ch->name,
   IS_NPC(ch) ? "" : ( ch->pcdata->surname == NULL ? "" : " " ),
   IS_NPC(ch) ? "" : ( ch->pcdata->surname == NULL ? "" : ch->pcdata->surname ),
   ch->level, IS_NPC(ch) ? 0 : ch->pcdata->debit_level, get_age(ch),
   ( ch->played + (int) (current_time - ch->logon) ) / 3600 );
a2531 13
     if ( is_affected(ch,gsn_rage) )
	 sprintf( buf, "You have ????/???? hit");
     else
     sprintf( buf,
   "You have %d/%d hit", ch->hit, ch->max_hit );

     send_to_char(buf,ch);

     sprintf(buf, ", %d/%d mana, %d/%d movement.\n\r",
   ch->mana, ch->max_mana,
   ch->move, ch->max_move);
     send_to_char( buf, ch );

d2597 1
a2597 1
   "You are carrying %d.%d/%d.%d items with weight %ld.%ld/%d.%d pounds.\n\r",
d2600 1
a2600 2
   get_carry_weight(ch) / 10,  get_carry_weight(ch) % 10,
   can_carry_w(ch) / 10, can_carry_w(ch) % 10 ); 
d2604 4
a2607 3
   "Str: %d(%d)  Int: %d(%d)  Wis: %d(%d)  Dex: %d(%d)  Con: %d(%d)\n\r",
   ch->perm_stat[STAT_STR],
   get_curr_stat(ch,STAT_STR),
d2612 2
d2616 5
a2620 1
   ch->perm_stat[STAT_CON],
d2646 1
a2646 1
     sprintf( buf, "Wimpy set to %d hit points.\n\r", ch->wimpy );
a2731 11
     /* print AC values */
     if (ch->level >= 25)
     {   
   sprintf( buf,"Armor: pierce: %d  bash: %d  slash: %d  magic: %d\n\r",
      GET_AC(ch,AC_PIERCE),
      GET_AC(ch,AC_BASH),
      GET_AC(ch,AC_SLASH),
      GET_AC(ch,AC_EXOTIC));
   send_to_char(buf,ch);
     }
 
d2749 1
a2749 1
   else if (GET_AC(ch,i) >= 80) 
d2751 1
a2751 1
   else if (GET_AC(ch,i) >= 60)
d2753 1
a2753 1
   else if (GET_AC(ch,i) >= 40)
d2755 1
a2755 1
   else if (GET_AC(ch,i) >= 20)
d2757 1
a2757 1
   else if (GET_AC(ch,i) >= 0)
d2759 1
a2759 1
   else if (GET_AC(ch,i) >= -20)
d2761 1
a2761 1
   else if (GET_AC(ch,i) >= -40)
d2763 1
a2763 1
   else if (GET_AC(ch,i) >= -60)
d2765 1
a2765 1
   else if (GET_AC(ch,i) >= -80)
d2767 1
a2767 1
   else if (GET_AC(ch,i) >= -100)
d4457 1
a4457 1
   wimpy = ch->max_hit / 5;
d4467 1
a4467 1
     if ( wimpy > ch->max_hit/2 )
d4474 1
a4474 1
     sprintf( buf, "Wimpy set to %d hit points.\n\r", wimpy );
@


1.368
log
@few new cstat stuffs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.367 2001/12/07 16:57:42 poquah Exp $";
d106 1
a106 1
       send_to_char("You already sleected one!\n\r",ch);
@


1.367
log
@add line after Kills showing in score, line is possible to be very long
with stolen/slices/outcast and ruffian
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.366 2001/12/05 17:07:03 poquah Exp $";
d3167 2
a3168 1
    sprintf(buf,"Honor   %d\n\r",honor_kills);
d3170 3
a3172 1
    sprintf(buf,"Posse   %d\n\r",posse_kills);
@


1.366
log
@move gladiator_data and highlander_data to pcdata
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.365 2001/12/05 16:40:15 poquah Exp $";
d2472 1
a2472 1
	sprintf( buf, "Kills: Lower: %d Equal: %d Greater: %d", 
@


1.365
log
@fixing spelling on PC_EQUAL_KLLS = KILLS
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.364 2001/12/05 16:39:00 poquah Exp $";
d2506 2
a2507 1
	       ch->highlander_data[ALL_KILLS],ch->highlander_data[REAL_KILLS]);
d2515 6
a2520 6
	       ch->gladiator_data[GLADIATOR_PLAYS],
	       ch->gladiator_data[GLADIATOR_VICTORIES],
	       ch->gladiator_data[GLADIATOR_KILLS],
	       ch->gladiator_data[GLADIATOR_TEAM_PLAYS],
	       ch->gladiator_data[GLADIATOR_TEAM_VICTORIES], 
	       ch->gladiator_data[GLADIATOR_TEAM_KILLS]);
d4032 2
a4033 2
	    ch->highlander_data[ALL_KILLS],
	    ch->highlander_data[REAL_KILLS]);
d4037 2
a4038 2
	    ch->highlander_data[ALL_KILLS],
	    ch->highlander_data[REAL_KILLS]);
d4058 6
a4063 6
		ch->gladiator_data[GLADIATOR_VICTORIES],
		ch->gladiator_data[GLADIATOR_KILLS],
		ch->gladiator_data[GLADIATOR_PLAYS],
		ch->gladiator_data[GLADIATOR_TEAM_VICTORIES],
		ch->gladiator_data[GLADIATOR_TEAM_KILLS],
		ch->gladiator_data[GLADIATOR_TEAM_PLAYS]);
d4089 6
a4094 6
		ch->gladiator_data[GLADIATOR_VICTORIES],
		ch->gladiator_data[GLADIATOR_KILLS],
		ch->gladiator_data[GLADIATOR_PLAYS],
		ch->gladiator_data[GLADIATOR_TEAM_VICTORIES],
		ch->gladiator_data[GLADIATOR_TEAM_KILLS],
		ch->gladiator_data[GLADIATOR_TEAM_PLAYS]); 
@


1.364
log
@new kr stats
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.363 2001/12/04 17:54:51 rage Exp $";
d2474 1
a2474 1
		ch->pcdata->killer_data[PC_EQUAL_KLLS],
@


1.363
log
@Added in functionality to have observation rooms be part of the clan hall area instead of the target area
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.362 2001/11/30 15:43:50 poquah Exp $";
d2472 4
a2475 2
	sprintf( buf, "Approx. Attempts: %d  Kills: %d  ", 
		ch->killer_data[PC_ATTACKS]/2, ch->killer_data[PC_KILLS]);
d2477 6
a2482 8
	if (ch->steal_data[PC_STOLEN_ITEMS] > 0
	    || ch->steal_data[PC_STOLEN_GOLD] > 0
	    || ch->steal_data[PC_STOLEN_SILVER] > 0)
	{
	sprintf( buf, "Stolen: %ld items %ld gold %ld silver ", 
		ch->steal_data[PC_STOLEN_ITEMS],
		ch->steal_data[PC_STOLEN_GOLD],
		ch->steal_data[PC_STOLEN_SILVER]);
d2485 1
a2485 1
	if (ch->steal_data[PC_SLICES] > 0)
d2488 1
a2488 1
		ch->steal_data[PC_SLICES]);
d4047 1
a4047 1
  sprintf( buf, "You have approximately %d attempts and %d kills.\n\r"
d4052 4
a4055 2
		ch->killer_data[PC_ATTACKS]/2,
		ch->killer_data[PC_KILLS], ch->pcdata->last_kill,
d4064 2
a4065 3
  if (ch->steal_data[PC_STOLEN_ITEMS] > 0 ||
      ch->steal_data[PC_STOLEN_GOLD] > 0 ||
      ch->steal_data[PC_STOLEN_SILVER] > 0)
d4067 3
a4069 4
     sprintf( buf,"You have stolen %ld items %ld gold and %ld silver.\n\r",
	      ch->steal_data[PC_STOLEN_ITEMS],  
	      ch->steal_data[PC_STOLEN_GOLD],
	      ch->steal_data[PC_STOLEN_SILVER]);
d4073 1
a4073 1
  if (ch->steal_data[PC_SLICES] > 0)
d4076 1
a4076 1
	      ch->steal_data[PC_SLICES]);
d4079 2
a4080 2
  sprintf( buf, "To inform you, $n says 'I have killed %d others in "
		"approximately %d attempts.\n\r"
d4084 3
a4086 1
		ch->killer_data[PC_KILLS], ch->killer_data[PC_ATTACKS]/2,
d4095 2
a4096 3
  if (ch->steal_data[PC_STOLEN_ITEMS] > 0 ||
      ch->steal_data[PC_STOLEN_GOLD] > 0 ||
      ch->steal_data[PC_STOLEN_SILVER] > 0)
d4098 3
a4100 4
     sprintf( tbuf, "\n\rI have stolen %ld items %ld gold and %ld silver.",  
		ch->steal_data[PC_STOLEN_ITEMS],
		ch->steal_data[PC_STOLEN_GOLD],
		ch->steal_data[PC_STOLEN_SILVER]); 
d4104 1
a4104 1
  if (ch->steal_data[PC_SLICES] > 0)
d4107 1
a4107 1
		ch->steal_data[PC_SLICES]); 
@


1.362
log
@change cstats and rewrite whole fight code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.361 2001/11/29 17:24:10 poquah Exp $";
d3745 1
d3754 5
d3776 1
a3776 1
         && ( victim->in_room->area == ch->in_room->area )
d3810 1
a3810 1
         &&   victim->in_room->area == ch->in_room->area
@


1.361
log
@finally got cstat all debugged
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.360 2001/11/29 17:11:23 poquah Exp $";
d3166 1
a3166 1
    sprintf(buf,"Honor  %d\n\r",honor_kills);
d3168 1
a3168 1
    sprintf(buf,"Posse  %d\n\r",posse_kills);
@


1.360
log
@working on why its error during compile just on honor_kills
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.359 2001/11/29 17:05:23 poquah Exp $";
a3158 9
/*
extern sh_int avarice_kills;
extern sh_int demise_kills;
extern sh_int posse_kills;
extern sh_int warlock_kills;
extern sh_int zealot_kills;
extern sh_int honor_kills;
*/

d3166 1
a3166 1
    sprintf(buf,"Honor  %d\n\r",honors_kills);
@


1.359
log
@add honor_kills which appeasr to crash compile
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.358 2001/11/29 17:03:35 poquah Exp $";
d3175 1
a3175 1
    sprintf(buf,"Honor  %d\n\r",honor_kills);
@


1.358
log
@continued with cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.357 2001/11/29 16:58:54 poquah Exp $";
d3174 2
@


1.357
log
@remove a bit of cstat to find bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.356 2001/11/29 16:55:24 poquah Exp $";
d3159 1
d3166 1
d3174 6
@


1.356
log
@hmm problem in cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.355 2001/11/29 16:51:46 poquah Exp $";
d3166 1
d3173 1
d3182 1
@


1.355
log
@think Ifound it!@@
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.354 2001/11/29 16:48:39 poquah Exp $";
a3158 1
/*
a3164 1
*/
@


1.354
log
@
I havent a clue why this wont compile
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.353 2001/11/29 16:42:32 poquah Exp $";
d77 1
d3159 1
d3166 1
a3166 1
/*
d3170 1
a3170 1
    sprintf(buf,"Avarice %d",avarice_kills);
d3172 1
a3172 1
    sprintf(buf,"Demise  %d",demise_kills);
d3174 1
a3174 1
    sprintf(buf,"Honor   %d",honor_kills);
d3176 1
a3176 1
    sprintf(buf,"Posse   %d",posse_kills);
d3178 1
a3178 1
    sprintf(buf,"Warlock %d",warlock_kills);
d3180 1
a3180 1
    sprintf(buf,"Zealot  %d",zealot_kills);
a3181 1
*/
@


1.353
log
@comment out cstat for now
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.352 2001/11/29 16:41:12 poquah Exp $";
a3157 1
/*
d3164 1
@


1.352
log
@one step further on cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.351 2001/11/29 16:27:56 poquah Exp $";
a3164 1
*/
d3180 1
@


1.351
log
@move declare of variables to top
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.350 2001/11/29 16:18:07 poquah Exp $";
a76 8
sh_int avarice_kills;
sh_int demise_kills;
sh_int posse_kills;
sh_int warlock_kills;
sh_int zealot_kills;
sh_int honor_kills;
 
 /*
@


1.350
log
@ugh bad compiles
:wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.349 2001/11/29 16:12:57 poquah Exp $";
d77 6
a3173 6
sh_int avarice_kills;
sh_int demise_kills;
sh_int posse_kills;
sh_int warlock_kills;
sh_int zealot_kills;
sh_int honor_kills;
@


1.349
log
@a new attempt at cstat
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.348 2001/11/29 14:28:38 poquah Exp $";
d3168 6
@


1.348
log
@remove cstat code see if game comes up
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.347 2001/11/29 09:53:40 poquah Exp $";
d3167 1
a3182 1
*/
@


1.347
log
@remove cstat stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.346 2001/11/29 09:47:27 poquah Exp $";
d3195 1
@


1.346
log
@error error will robisinson
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.345 2001/11/29 09:38:58 poquah Exp $";
d3160 1
d3182 1
@


1.345
log
@working on cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.344 2001/11/29 09:34:08 poquah Exp $";
d3160 6
@


1.344
log
@comment out cstat for minute
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.343 2001/11/29 09:32:57 poquah Exp $";
a3159 7
/*
    extern sh_int avarice_kills;
    extern sh_int demise_kills;
    extern sh_int honor_kills;
    extern sh_int posse_kills;
    extern sh_int warlock_kills;
    extern sh_int zealot_kills;
a3174 1
*/
@


1.343
log
@remove declares in cstat for a minute
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.342 2001/11/29 09:30:52 poquah Exp $";
a3166 1
*/
d3182 1
@


1.342
log
@change cstat a bit
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.341 2001/11/29 09:23:01 poquah Exp $";
d3160 1
d3167 1
@


1.341
log
@add a quick and dirty cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.340 2001/11/25 05:14:41 poquah Exp $";
d3160 6
@


1.340
log
@cant do surname brief anymore
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.339 2001/11/23 16:17:14 poquah Exp $";
d3161 15
a3175 3
    send_to_char("Kills  Clan\n\r",ch);
    send_to_char("-----  ----\n\r",ch);

d3186 1
@


1.339
log
@Newbie flag and code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.338 2001/11/15 03:10:32 poquah Exp $";
d4671 6
@


1.338
log
@add full sac, able to sac containers with things in them
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.337 2001/11/13 22:28:07 poquah Exp $";
d4712 18
@


1.337
log
@Removed NPC check on nowhere rooms
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.336 2001/11/06 20:03:15 poquah Exp $";
d1265 6
d1448 18
@


1.336
log
@can't find players in nowhere rooms anymore by specifying them as a target
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.335 2001/09/11 06:37:37 poquah Exp $";
d3760 1
a3760 2
         && ( !IS_NPC(victim) 
           && !IS_SET(victim->in_room->room_flags,ROOM_NOWHERE) )
@


1.335
log
@can not take a kit while morphed or shifted
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.334 2001/08/30 01:03:22 guerrand Exp $";
d3700 5
a3704 5
  if(!IS_NPC(ch) && ch->move < 4)
    {
	send_to_char("You can't get up enough energy.\n\r",ch);
	return;
    }
d3706 1
a3706 1
  ch->move = UMAX(ch->move - apply_chi(ch,4), 0);
d3710 18
a3727 18
     if ( arg[0] == '\0' )
     {
   send_to_char( "Players near you:\n\r", ch );
   found = FALSE;
   for ( d = descriptor_list; d; d = d->next )
   {
       if ( (d->connected == CON_PLAYING)
       && ( (victim = d->character) != NULL )
       && ( !IS_NPC(victim) )
       && ( victim->in_room != NULL )
       && ( !IS_SET(victim->in_room->room_flags,ROOM_NOWHERE) )
       && ( (is_room_owner(ch,victim->in_room) )
       ||   (!room_is_private(ch,victim->in_room)) )
       && ( victim->in_room->area == ch->in_room->area )
       && ( can_see( ch, victim,FALSE)) 
       && ( !is_clan( ch ) || ( is_clan(ch) && !IS_AFFECTED(ch,AFF_BLIND)))
       && ( check_match(ch, victim) )
       && (get_skill(ch,gsn_scan) >= 
d3730 8
a3737 8
       {
     if(found == FALSE)
	{
	found = TRUE;
	check_improve(ch,gsn_scan,TRUE,4);
	}
	if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE)
           sprintf( buf, "%-28s %s\n\r",
d3739 11
a3749 5
	else
           sprintf( buf, "%-28s %s\n\r",
              victim->name, victim->in_room->name );
     send_to_char( buf, ch );
       }
d3751 1
a3751 10
   if ( !found )
	{
       send_to_char( "None\n\r", ch );
	check_improve(ch,gsn_scan,FALSE,7);
	}
     }
     else
     {
   found = FALSE;
   for ( victim = char_list; victim != NULL; victim = victim->next )
d3753 12
a3764 7
       if ( victim->in_room != NULL
       &&   victim->in_room->area == ch->in_room->area
       &&   !IS_AFFECTED(victim, AFF_HIDE)
       &&   !IS_AFFECTED(victim, AFF_SNEAK)
       &&   can_see( ch, victim, FALSE )
       &&   is_name( arg, victim->name ) 
	&& (get_skill(ch,gsn_scan) >=
d3767 18
a3784 18
       {
	if(found == FALSE)
	{
	  found = TRUE;
	  check_improve(ch,gsn_scan,TRUE,4);
	}
	if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE)
           sprintf( buf, "%-28s %s\n\r",
             victim->long_descr, victim->in_room->name );
	else
           sprintf( buf, "%-28s %s\n\r",
               PERS(victim, ch, FALSE), victim->in_room->name );
     send_to_char( buf, ch );
     break;
       }
   }
   if ( !found )
	{
d3786 1
a3786 2
	check_improve(ch,gsn_scan,FALSE,6);
	}
d3788 1
d3790 2
a3791 2
     return;
 }
@


1.334
log
@Added bounty command.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.333 2001/08/20 02:57:48 poquah Exp $";
d775 7
@


1.333
log
@fix Honor's enemy list
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.332 2001/08/14 03:10:38 guerrand Exp $";
d2431 1
a2431 1
	ch->skill_points != 0 ) )
d2434 2
a2435 2
   "Trains: %d  Practices: %d  Skill Points: %d   ",
   ch->train, ch->practice, ch->skill_points );
@


1.332
log
@DOTs run every 6 seconds now.  Updated 'do_affect' to reflect it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.331 2001/08/08 05:45:50 poquah Exp $";
d2615 1
a2615 1
	      strcat(buf,"Zealot");
d4516 1
@


1.331
log
@Adding Honor's Enemy flag for Loner's and Outcasts
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.330 2001/08/01 04:47:47 boogums Exp $";
d2792 2
a2793 2
     else	/* 6 DOT pulses per tick */
         sprintf( buf, "for %d hours", (paf->where == DAMAGE_OVER_TIME) ? paf->duration / 6 : paf->duration );
@


1.330
log
@ok increased max_skills to 450 and do_practice max buff to *3
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.329 2001/07/29 17:36:06 rusty Exp $";
d2606 1
d2616 2
d4547 4
d4593 15
@


1.329
log
@Fixed Posse Enemy
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.328 2001/07/05 00:51:23 poquah Exp $";
d4091 2
a4092 2
     char buf[MAX_STRING_LENGTH * 2];
     char buf2[MAX_STRING_LENGTH * 2];
@


1.328
log
@put , between help keywords
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.327 2001/07/05 00:48:24 poquah Exp $";
d4542 1
a4542 1
	    REMOVE_BIT(victim->mhs,MHS_WARLOCK_ENEMY);
@


1.327
log
@put more then one keyword to a line
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.326 2001/07/05 00:39:31 poquah Exp $";
a2891 7
   if (++col % 6 == 0)
       send_to_char("\n\r",ch);
 
     if ( col % 6 != 0)
   send_to_char("\n\r",ch);
     return;
 
d2940 1
@


1.326
log
@working on help topics
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.325 2001/07/05 00:34:29 poquah Exp $";
d2888 10
d2942 1
a2942 1
     if (!str_prefix("topics",argall))
d2947 3
a2949 1
           send_to_char( "\n\r", ch );
d2951 3
@


1.325
log
@ability to display all helpfile keywords
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.324 2001/07/02 21:36:08 rage Exp $";
d2926 4
a2929 1
     if (str_cmp(capitalize(argall),"Topics") && (!str_prefix("topics",argall)
d2931 2
@


1.324
log
@initial attempt ant elemtal king special
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.323 2001/06/24 06:32:07 guerrand Exp $";
d2890 1
a2890 1
   argument = "summary";
d2896 4
a2899 4
   argument = one_argument(argument,argone);
   if (argall[0] != '\0')
       strcat(argall," ");
   strcat(argall,argone);
d2904 2
a2905 2
   if ( pHelp->level > get_trust( ch ) )
       continue;
d2907 7
a2913 7
   if ( is_name( argall, pHelp->keyword ) )
   {
       if ( pHelp->level >= 0 && str_cmp( argall, "imotd" ) )
       {
     send_to_char( pHelp->keyword, ch );
     send_to_char( "\n\r", ch );
       }
d2918 6
a2923 6
       if ( pHelp->text[0] == '.' )
     page_to_char( pHelp->text+1, ch );
       else
     page_to_char( pHelp->text  , ch );
       return;
   }
d2926 11
@


1.323
log
@Fixed a bug with practic
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.322 2001/06/24 04:14:57 guerrand Exp $";
d1947 1
a1947 1
       if ( IS_SET(obj->value[1], CONT_CLOSED) )
@


1.322
log
@Research adept is 95%, goes up1%per practice.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.321 2001/06/19 05:32:08 guerrand Exp $";
d4256 1
a4256 1
	      if ( adept > 75 )
@


1.321
log
@Improved size of area buffer to avoid crashes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.320 2001/06/19 05:14:14 guerrand Exp $";
d4213 4
a4216 1
 
d4256 3
@


1.320
log
@Can't pck the surname 'show'
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.319 2001/06/18 01:17:31 rage Exp $";
d2775 4
d2780 1
@


1.319
log
@ Initial insertion of forging items.  Added new item type ITEM_FORGE.
 One can create "recipes" for these forges.  Each recipe is a list of
 objects that once placed inside the forge will create a bigger/better
 object.  Basically a better implementation of item parts.

-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.318 2001/06/15 02:41:00 guerrand Exp $";
d4568 1
a4568 1

d4574 6
a4579 1
	send_to_char("        surname show\n\r",ch);
@


1.318
log
@Fixed a typo in the paladin abolish disease info in score.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.317 2001/06/15 02:27:50 guerrand Exp $";
d1946 1
d2233 1
@


1.317
log
@PAladin abolish disease ability.  Neat!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.316 2001/06/10 21:45:44 guerrand Exp $";
d2521 1
a2521 1
		 ch->pcdata->abolish_timer > 0 ? "unavilable" : "ready",
@


1.316
log
@New way to turn surnames on/off using brief.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.315 2001/06/10 05:19:39 guerrand Exp $";
d2517 9
a2525 1
 
@


1.315
log
@Added notitle feature for who list.
GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.314 2001/06/10 04:15:54 guerrand Exp $";
d1511 3
a4567 14
    if ( !str_cmp(arg,"show") )
    {
	if ( IS_SET(ch->display,DISP_SURNAME) )
	{
		REMOVE_BIT(ch->display,DISP_SURNAME);
	    send_to_char("Surnames will NOT show in who.\n\r",ch);
	} else
	{
		SET_BIT(ch->display,DISP_SURNAME);
	    send_to_char("Surnames WILL show in who.\n\r",ch);
	}
	return;
    }

a4572 1

@


1.314
log
@The lag surname fix, I PRAY TO FRIGGIN GOD
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.313 2001/06/10 04:12:04 guerrand Exp $";
d1191 5
d1508 3
d3044 1
a3044 1
	      IS_NPC(wch) ? "" : wch->pcdata->title);
d3063 1
a3063 1
    IS_SET(ch->display,DISP_SURNAME) ? surname : "", IS_NPC(wch) ? "" : wch->pcdata->title);
d3419 1
a3419 1
             IS_NPC(wch) ? "" : wch->pcdata->title);
d3443 1
a3443 1
      IS_NPC(wch) ? "" : wch->pcdata->title );
d4617 1
@


1.313
log
@Cripes I cna't quit screwing up.  More fixes to surname displays.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.312 2001/06/10 04:02:46 guerrand Exp $";
d2994 4
a3018 4

    surname[0] = '\0';
    if ( wch->pcdata->surname != NULL )
    	sprintf(surname," %s",wch->pcdata->surname);
@


1.312
log
@Another surname fix.  I suck.  Fixing bug with blank surnames repeating
the last one.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.311 2001/06/10 03:57:07 guerrand Exp $";
d3041 1
a3041 1
      sprintf(buf, "[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r{x",
d3054 2
a3055 1
    wch->name, IS_NPC(wch) ? "" : wch->pcdata->title);
d3416 1
a3416 1
  sprintf( buf, "[%2d %6s %s]{x%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
@


1.311
log
@Ilied, one more.  Characters under 35 can now use 'surname set'
properly.  Remind me never to code in a mad hurry again.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.310 2001/06/10 03:53:08 guerrand Exp $";
d3016 1
d3362 1
@


1.310
log
@OK!  Should be the last surname change.
Surnames report correctly in stat, and show correctly for mortals.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.309 2001/06/10 03:29:32 guerrand Exp $";
a4542 6
    if ( ch->level < 35 )
    {
	send_to_char("You must be at least level 35 to pick a surname.\n\r",ch);
	return;
    }

d4567 8
@


1.309
log
@Added some new features for surnames.
1. They show in who list but
2. you can toggle that off if you don'tlike it
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.308 2001/06/09 18:53:47 guerrand Exp $";
d3361 3
d3367 1
a3391 3
    if ( wch->pcdata->surname != NULL )
	sprintf(surname," %s",wch->pcdata->surname);

d3431 1
@


1.308
log
@GMAN
Added the command for mortals to set their surnames
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.307 2001/06/09 17:42:40 guerrand Exp $";
d1187 4
d2914 1
d3016 4
a3019 1
    sprintf(buf, "[%s] %s%s%s%s%s%s%s%s%s%s%s\n\r{x",
d3034 1
d3120 1
d3388 4
a3391 1
    sprintf(buf,  "[%s] %s%s%s%s%s%s%s%s%s%s%s\n\r{x",
d3406 1
d4547 1
a4547 1
    argument = one_argument( argument, arg );
d4554 1
d4558 13
@


1.307
log
@GMAN
Adde surnames, saving/reading functionality, ability for IMMs to set them, and
they show up in score only right noGMAN
Adde surnames, saving/reading functionality, ability for IMMs to set them, and
they show up in score only right noww
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.306 2001/06/09 03:56:59 guerrand Exp $";
d4534 2
@


1.306
log
@GMAN!
1. Changed 'affect' command to show duration for dots correctly.
2. Removed unused variable in mag2.c
3. Added a long field to affects called 'caster_id'
4. Added a lookup function called 'get_char_by_id' to handler.c
5. Added a call to get_char_by_id to dot in magic.c to find the caster
6. WE can now track the caster of a spell.

To do: check for a 0 ID and ignore it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.305 2001/06/03 23:20:06 guerrand Exp $";
d2368 1
a2368 1
   "You are %s, level %d(%d), %d years old (%d hours).\n\r",
d2375 1
a2375 1
   "You are %s, level %d(%d), %d years old (%d hours).\n\r",
d2377 2
d4522 50
@


1.305
log
@And, at least, the final stages of secret and concealed flags are done!
-GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.304 2001/06/01 02:17:19 guerrand Exp $";
d2747 3
d2757 2
a2758 2
     else
         sprintf( buf, "for %d hours", paf->duration );
@


1.304
log
@Added gargoyles to kit list.
GMan
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.303 2001/04/09 21:37:50 mud Exp $";
d2115 7
a2121 1
   
@


1.303
log
@Took annoying K an M out of do_whois(0 for IMM's
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.302 2001/04/09 21:36:05 mud Exp $";
a1982 1
 
@


1.302
log
@Removed the annoying K and M at the beginning of immortal 'who lists'
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.301 2001/03/04 19:17:10 mud Exp $";
d3021 2
a3022 6
      sprintf(buf, "%s%s[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r{x",
    !IS_IMMORTAL(ch) ? "" : ( wch->kit ? "K" : " " ),
    !IS_IMMORTAL(ch) ? "" : ( IS_SET(wch->mhs,MHS_MUTANT) ? "M" : " "),
    wch->level,
    display_race,
    class,
@


1.301
log
@Kicked out misplaced {}'s
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.300 2001/03/03 19:02:56 mud Exp $";
d3392 1
a3392 3
  sprintf( buf, "%s%s[%2d %6s %s]{x%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
      !IS_IMMORTAL(ch) ? "" : ( wch->kit ? "K" : " "),
      !IS_IMMORTAL(ch) ? "" : ( IS_SET(wch->mhs,MHS_MUTANT) ? "M" : " "),
@


1.300
log
@Fixed some formatting and removed an unused var
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.299 2001/02/27 18:35:29 mud Exp $";
a1956 1
       {
a1981 1
       }
a1985 1
       {
a2010 1
       }
@


1.299
log
@declare buf in peek
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.298 2001/02/27 18:33:10 mud Exp $";
d1957 1
a1980 1
         
d1983 2
a1984 1
         else continue;
d1988 1
d2014 2
a2015 1
     else continue;
a3618 1
     bool match;
@


1.298
log
@avarice clan skill to see worth in peek
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.297 2001/02/13 20:35:50 mud Exp $";
d989 1
@


1.297
log
@nooutofrange in info
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.296 2001/02/13 20:29:11 mud Exp $";
d1009 7
@


1.296
log
@added nooutofrange toggle
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.295 2000/12/14 03:50:27 mud Exp $";
d1302 7
@


1.295
log
@13DEC00
Ok, i added the unwraith skill in interp.*, put a {Black Aura) in
act_info.c and modified the fight message
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.294 2000/12/09 07:05:45 mud Exp $";
d1649 11
@


1.294
log
@08DEC00
DAMN this wraithform it's gone now :)
=Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.293 2000/12/07 06:45:42 mud Exp $";
d345 2
@


1.293
log
@ok got all the necromancer stuff out trying to restore order
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.292 2000/12/07 05:46:07 mud Exp $";
a314 2
     /*here goes the aura for wraithform
     if ( IS_AFFECTED(victim, skill_lookup("wraithform"))) strcat( buf, "({DBlack Aura{x) ");*/
@


1.292
log
@06DEC00
Ok no AFF_WRAITHFORM had to change those to skill_lookups
compiled clean testing now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.291 2000/12/03 03:23:58 mud Exp $";
d315 2
a316 2
     /*here goes the aura for wraithform*/
     if ( IS_AFFECTED(victim, skill_lookup("wraithform"))) strcat( buf, "({DBlack Aura{x) ");
@


1.291
log
@2DEC00 - Ok here goes teh necromancer kit.  changes in act_info.c act_move.c
         act_obj.c const.c figt.c mag2.c magic.c magic.h merc.h update.c
	 all sorts of cool stuff
	 -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.290 2000/10/23 22:10:16 mud Exp $";
d316 1
a316 1
     if ( IS_AFFECTED(victim, AFF_WRAITHFORM)  )strcat( buf, "({DBlack Aura{x) ");
@


1.290
log
@missing " in posse clan lookup
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.289 2000/10/23 22:07:53 mud Exp $";
d315 2
@


1.289
log
@typo in zealot enemy
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.288 2000/10/23 22:05:54 mud Exp $";
d4457 1
a4457 1
      if(ch->clan == clan_lookup("posse))
d4465 15
@


1.288
log
@zealot and posse enemies
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.287 2000/10/18 23:16:58 mud Exp $";
d2545 1
a2545 1
	if(IS_SET(ch->,mhs,MHS_WARLOCK_ENEMY) || 
@


1.287
log
@wrong " to '
=poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.286 2000/10/18 23:14:10 mud Exp $";
d2543 1
a2543 1
     if (!IS_NPC(ch) && IS_SET(ch->mhs,MHS_WARLOCK_ENEMY))
d2545 14
a2558 2
  sprintf(buf,"Enemy of: Warlock\n\r");
  send_to_char(buf,ch);
d4405 3
a4407 1
   if (ch->clan != clan_lookup("warlock"))
d4426 11
a4436 2
      if (IS_SET(victim->mhs,MHS_WARLOCK_ENEMY))
	 REMOVE_BIT(victim->mhs,MHS_WARLOCK_ENEMY);
d4442 1
a4442 2
      strcpy( buf, "WARLOCK ENEMIES:\n\r");
      for (d = descriptor_list; d != NULL; d = d->next)
d4444 2
a4445 1
         if (d->character != NULL)
d4447 22
a4468 4
            if (IS_SET(d->character->mhs, MHS_WARLOCK_ENEMY))
	    {
               strcat( buf, d->character->name);
               strcat( buf, "\n\r");
@


1.286
log
@missing a = in compare
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.285 2000/10/18 23:10:27 mud Exp $";
d4398 1
a4398 1
   if( ch->pcdata->rank == MAX_RANK && arg1[0] != "\0" )
@


1.285
log
@declare victim properly this time
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.284 2000/10/18 23:09:12 mud Exp $";
d4398 1
a4398 1
   if( ch->pcdata->rank = MAX_RANK && arg1[0] != "\0" )
@


1.284
log
@declare victim in enemy
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.283 2000/10/18 23:07:55 mud Exp $";
d4390 1
a4390 1
   DESCRIPTOR_DATA *victim;
@


1.283
log
@give /5's the ability to remove enemy
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.282 2000/10/18 22:42:30 mud Exp $";
d4390 1
@


1.282
log
@show enemy of warlock in score
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.281 2000/10/18 22:03:26 mud Exp $";
d4390 1
d4395 3
a4397 2
   strcpy( buf, "WARLOCK ENEMIES:\n\r");
   for (d = descriptor_list; d != NULL; d = d->next)
d4399 7
a4405 1
      if (d->character != NULL)
d4407 21
a4427 4
         if (IS_SET(d->character->mhs, MHS_WARLOCK_ENEMY))
	 {
            strcat( buf, d->character->name);
            strcat( buf, "\n\r");
d4430 1
a4431 1
   send_to_char( buf, ch );
@


1.281
log
@do_enemy giving garbage from buf
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.280 2000/10/17 23:09:14 mud Exp $";
d2545 1
a2545 1
  sprintf(buf,"Enemy of: Warlockn\r");
@


1.280
log
@remove extra return at end of file
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.279 2000/10/17 23:01:26 mud Exp $";
a4388 1
   bool fFirst;
a4389 1
   char enemy_check;
d4394 1
a4394 1
   fFirst = TRUE;
d4401 1
a4401 8
	    if(fFirst)
	    {
               strcpy( buf, d->character->name);
	       fFirst = FALSE;
	    }
	    else
               strcat( buf, d->character->name);

a4402 2
 
            buf[0] = UPPER(buf[0]);
@


1.279
log
@working on warlock enemey
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.278 2000/10/17 22:45:32 mud Exp $";
a4420 2
   return;
}
@


1.278
log
@enemies for clans , just warlock for now
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.277 2000/10/16 21:51:34 mud Exp $";
d4393 1
a4393 3
   if (ch->clan == clan_lookup("warlock"))
      enemy_check = MHS_WARLOCK_ENEMY;
   else
d4401 1
a4401 1
         if (IS_SET(d->character->mhs, enemy_check))
@


1.277
log
@brief char desc
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.276 2000/10/16 21:49:15 mud Exp $";
d2543 6
d4386 39
@


1.276
log
@make nodescriptions into brief toggle
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.275 2000/10/16 00:48:51 mud Exp $";
d1480 1
a1480 1
     if ( !str_prefix(arg, "scan") )
@


1.275
log
@nodescriptions code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.274 2000/10/16 00:36:32 mud Exp $";
d566 1
a566 1
	if(!IS_SET(ch->display,DISP_NODESCRIPTIONS))
a1263 6
     send_to_char("no descriptions   ",ch);
     if (IS_SET(ch->display,DISP_NODESCRIPTIONS))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);
 
d1479 3
a4378 17

void do_nodescriptions(CHAR_DATA *ch, char *argument)
 {
     if (IS_NPC(ch))
       return;
  
     if (IS_SET(ch->display,DISP_NODESCRIPTIONS))
     {
       send_to_char("You will now see descriptions.\n\r",ch);
       REMOVE_BIT(ch->display,DISP_NODESCRIPTIONS);
     }
     else
     {
       send_to_char("You will no longer see descriptions.\n\r",ch);
       SET_BIT(ch->display,DISP_NODESCRIPTIONS);
     }
 }
@


1.274
log
@nodescriptions code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.273 2000/09/13 14:01:47 mud Exp $";
d566 1
a566 1
	if(!IS_SET(ch->display,DISPLAY_NODESCRIPTIONS))
d4382 18
@


1.273
log
@
added check for holylight to detect good/evil and see spell effects like detect magic

slightly curved damage done by morphed chars

changed sneak again to make it less effective
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.272 2000/08/29 15:56:12 mud Exp $";
d566 2
d572 1
d1260 6
@


1.272
log
@ fixed minor bug with display whoing wrong flag status of brief scan
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.271 2000/08/29 15:47:44 mud Exp $";
d320 1
a320 1
     &&   IS_AFFECTED(ch, AFF_DETECT_ALIGN)     ) 
d323 1
a323 1
     &&   IS_AFFECTED(ch, AFF_DETECT_ALIGN)     ) 
d654 1
a654 1
     if ( IS_AFFECTED(ch,AFF_DETECT_MAGIC) ) 
d2425 1
a2425 1
	sprintf(buf,"Single Events Played: %d  Victories: %d  Kills: %d  "
@


1.271
log
@ added new display toggle brief scan, shows only clanners to clanners
 only nonclans to nonclans if toggled on

 -rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.270 2000/08/23 14:50:03 mud Exp $";
d1172 1
a1172 1
		IS_SET(ch->display,DISP_BRIEF_EQLIST) ? "ON" : "OFF" );
@


1.270
log
@ added olist to logged commands
 fixed bug with containers being shown twice if worn
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.269 2000/08/23 14:06:53 mud Exp $";
d87 2
a88 1
 
d1171 3
d1473 4
a1476 1
    
d3564 1
d3575 1
a3575 1
 
d3592 2
a3593 1
	&& (get_skill(ch,gsn_scan) >= 
d4359 13
@


1.269
log
@ another addition to olist, expand containers
 :
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.268 2000/08/23 13:38:02 mud Exp $";
d215 3
a219 1
	 send_to_char("\tcontaining:\n\r", ch);
a221 3
  
   if ( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj )) 
   {
@


1.268
log
@ fixed little bug in olist with multiple declaration of aconstants
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.266 2000/08/18 23:52:32 mud Exp $";
a82 2
 void    show_list_to_char       args( ( OBJ_DATA *list, CHAR_DATA *ch,
             bool fShort, bool fShowNothing ) );
d177 1
a177 1
 void show_list_to_char( OBJ_DATA *list, CHAR_DATA *ch, bool fShort, bool fShowNothing )
d215 6
d651 1
a651 1
   show_list_to_char( victim->carrying, ch, TRUE, TRUE );
d1003 1
a1003 1
   show_list_to_char( victim->carrying, ch, TRUE, TRUE );
d1844 1
a1844 1
   show_list_to_char( ch->in_room->contents, ch, FALSE, FALSE );
d1898 1
a1898 1
       show_list_to_char( obj->contains, ch, TRUE, TRUE );
d3395 1
a3395 1
     show_list_to_char( ch->carrying, ch, TRUE, TRUE );
@


1.267
log
@ another attempt to add in olist, also some general clean up
 -Rage
@
text
@d48 1
a48 2
/* MOved to merc.h 
 char *  const   where_name      [] =
d70 1
a70 1
}; */
@


1.266
log
@highlanders use temp clan, kr only shows highlandder info and fix levle limits
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.265 2000/07/25 16:38:12 mud Exp $";
d48 1
a48 1
 
d71 1
a71 1
};
@


1.265
log
@Remove Rages Who name code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.264 2000/07/25 12:58:15 mud Exp $";
d3840 1
@


1.264
log
@ removed Poq's wholist change
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.263 2000/07/25 00:58:07 mud Exp $";
a3297 4
      }
      if ( !str_cmp(wch->name, "Poquah"))
      {
      strcpy ( who_name, " MasterSimp" );
@


1.263
log
@ fixed wholist again
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.262 2000/07/25 00:48:45 mud Exp $";
d3301 1
a3301 1
      strcpy ( who_name, "MasterSimp" );
a3306 2
    if (fImmortalOnly && !str_cmp(wch->name,"Poquah"))
       do_gossip(ch,"Give it up Poquah, Rage is your superior!");
@


1.262
log
@ fixed Poq's attempt at fixing the wholist
 I hope I fixed div by 0 error
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.261 2000/07/25 00:21:53 mud Exp $";
a3291 6
      if ( !str_cmp(wch->name, "Poquah"))
      {
      strcpy ( who_name, "MasterSimp" );
      }
      else
      {
a3292 1
      }
d3298 4
@


1.261
log
@fixing who list
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.260 2000/07/24 22:55:43 mud Exp $";
d3292 6
d3299 1
d3307 1
a3307 1
      class = who_name;     
d3310 2
a3311 2
    if (fImmortalOnly && !str_cmp(wch->name,"Rage"))
       do_gossip(ch,"Give it up Rage, Poquah is your master!");
@


1.260
log
@remove the Simp joke code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.259 2000/07/24 15:50:06 mud Exp $";
d3303 3
a3703 6
     if ( !str_cmp ( ch->name, "Poquah"))
     {
       send_to_char("Title?!? You ain't got no stinking title.\n\r", ch);
       return;
     }

@


1.259
log
@ modified betting algorithm.  now use handicapping
 took out Poq's small modifiction to DWEEB flag
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.258 2000/07/22 21:27:21 mud Exp $";
d323 1
a323 1
             strcat( buf, "({CSIMP{x) ");
d2949 1
a2949 1
           IS_SET(wch->act, PLR_DWEEB) ? "(SIMP) " : "",
d2972 1
a2972 1
             IS_SET(wch->act, PLR_DWEEB) ? "(SIMP) " : "",
d3319 1
a3319 1
             IS_SET(wch->act, PLR_DWEEB) ? "(SIMP) " : "",
d3344 1
a3344 1
            IS_SET(wch->act, PLR_DWEEB) ? "(SIMP) " : "",
@


1.258
log
@fix bug in gladiators looking at each other when not a blind match
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.257 2000/07/21 19:49:14 mud Exp $";
d3700 8
a3707 1
 
@


1.257
log
@Simpified!

-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.256 2000/07/21 00:48:53 mud Exp $";
d559 3
a561 1
     if (!IS_SET(ch->mhs,MHS_GLADIATOR))
a593 2
     else
	strcpy( buf, ch->long_descr);
d1714 3
a1716 1
     if(!IS_SET(ch->mhs,MHS_GLADIATOR))
a1732 2
     else
	strcpy (buf, victim->long_descr);
@


1.256
log
@removed old bank line form score
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.255 2000/07/18 18:48:43 mud Exp $";
d323 1
a323 1
             strcat( buf, "({CDWEEB{x) ");
d2949 1
a2949 1
           IS_SET(wch->act, PLR_DWEEB) ? "(DWEEB) " : "",
d2972 1
a2972 1
             IS_SET(wch->act, PLR_DWEEB) ? "(DWEEB) " : "",
d3319 1
a3319 1
             IS_SET(wch->act, PLR_DWEEB) ? "(DWEEB) " : "",
d3344 1
a3344 1
            IS_SET(wch->act, PLR_DWEEB) ? "(DWEEB) " : "",
@


1.255
log
@splitting out gladiator plays
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.254 2000/07/14 16:50:37 mud Exp $";
d2450 2
a2451 2
   "You have %d exp, %ld gold, %ld silver, and %d eggs in the bank.\n\r",
   ch->exp,  ch->gold, ch->silver, ch->in_bank );
@


1.254
log
@ fixed bugs in blind glad code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.253 2000/07/13 20:02:18 mud Exp $";
d2416 2
a2417 1
	sprintf(buf,"Total Events: %d  Gladiator Victories: %d  Kills: %d  Team Victories: %d  Team Kills: %d\n\r",
d2421 1
d3848 2
a3849 2
		"You have %d Single Victories, %d Single Kills,\n\r"
		"%d Team Victories and %d Team Kills in %d Arena events.\n\r",
d3855 1
d3858 1
a3858 1
		ch->gladiator_data[GLADIATOR_PLAYS]);
d3880 2
a3881 3
                "I have participated in %d Arena Events.\n\r"
		"In Single Arena I have %d victories having killed %d Gladiators.\n\r"
		"In Teams Arena I have %d victories having killed %d Gladiators.",
a3883 1
		ch->gladiator_data[GLADIATOR_PLAYS],
d3886 1
d3888 2
a3889 1
		ch->gladiator_data[GLADIATOR_TEAM_KILLS]);
@


1.253
log
@fix a couple blind glad things
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.252 2000/07/13 02:33:11 mud Exp $";
d506 1
a506 1
       if (IS_SET(victim->fighting->mhs,MHS_GLADIATOR) 
d509 2
a510 2
       else
          strcat( buf, PERS( victim->fighting, ch, FALSE ) );
@


1.252
log
@scan/where doesnt show glads names-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.251 2000/07/13 01:25:19 mud Exp $";
d506 5
a510 1
       strcat( buf, PERS( victim->fighting, ch, FALSE ) );
@


1.251
log
@working on blind glads
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.250 2000/07/13 00:51:57 mud Exp $";
d3584 6
a3589 2
     sprintf( buf, "%-28s %s\n\r",
         victim->name, victim->in_room->name );
d3619 6
a3624 2
     sprintf( buf, "%-28s %s\n\r",
         PERS(victim, ch, FALSE), victim->in_room->name );
@


1.250
log
@gladiators dont see names in glance either
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.249 2000/07/13 00:45:49 mud Exp $";
a540 1
       act( "$n looks at you.", ch, NULL, victim, TO_VICT, FALSE  );
d613 3
d618 1
a618 4
        buf[0] = UPPER(buf[0]);
     send_to_char( buf, ch );
 
     found = FALSE;
@


1.249
log
@missing closing }
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.248 2000/07/13 00:43:57 mud Exp $";
a562 5
        if ( victim->max_hit > 0 )
           percent = ( 100 * victim->hit ) / victim->max_hit;
        else
           percent = -1;
 
d592 5
d1711 3
a1713 1
     strcpy( buf, PERS(victim, ch, FALSE) );
d1726 4
a1729 1
     strcat (buf,race_table[victim->race].name);
@


1.248
log
@glads can not look at each other
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.247 2000/07/13 00:31:38 mud Exp $";
d593 1
@


1.247
log
@gladiators cant look at each other
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.246 2000/07/12 23:56:23 mud Exp $";
d556 1
a556 1
     if (IS_SET(ch->mhs,MHS_GLADIATOR))
d558 33
a590 3
	do_glance(ch,victim->name);
	return;
     }
d592 1
a592 4
     if ( victim->description[0] != '\0' )
     {
   send_to_char( victim->description, ch );
     }
d594 1
a594 31
     {
   act( "You see nothing special about $M.", ch, NULL, victim, TO_CHAR, FALSE);
     }
 
     if ( victim->max_hit > 0 )
   percent = ( 100 * victim->hit ) / victim->max_hit;
     else
   percent = -1;
 
     if (IS_IMMORTAL (ch) && IS_SET (ch->display,DISP_DISP_VNUM)) {
       char temp_buf[50];
       
       if (IS_NPC(victim) && victim->pIndexData) {
         sprintf (temp_buf,"[%d] ",victim->pIndexData->vnum);
         strcat (buf,temp_buf);
       }
     }
 
     strcpy( buf, PERS(victim, ch, FALSE) );
 
     strcat (buf, " the ");
     if( !IS_NPC(victim) )
     {
     if (IS_SET(victim->act,PLR_WERE))
	strcat (buf,"garou ");
     if (IS_SET (victim->act,PLR_VAMP))
	strcat (buf,"nosferatu ");
     if (IS_SET (victim->act,PLR_MUMMY))
	strcat (buf,"mummified ");
     }
     strcat (buf,race_table[victim->race].name);
d613 3
a615 1
     buf[0] = UPPER(buf[0]);
d670 3
a672 2
  else
     send_to_char("\n\rNot affected by any spells.\n\r",ch);
@


1.246
log
@more on blind glads and shpemorphed
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.245 2000/07/12 22:22:13 mud Exp $";
d556 6
@


1.245
log
@working on blind glad matches
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.244 2000/07/12 15:12:16 mud Exp $";
d534 5
a538 1
       act( "$n looks at $mself.",ch,NULL,NULL,TO_ROOM,FALSE);
d542 11
a552 1
       act( "$n looks at $N.",  ch, NULL, victim, TO_NOTVICT,FALSE );
@


1.244
log
@ fixed bug with changing kits
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.243 2000/07/06 15:35:55 mud Exp $";
d379 2
a380 1
     if (IS_SET(victim->mhs,MHS_SHAPEMORPHED))
@


1.243
log
@ added in message to room for failed brew attempts
 changed min position for hide to POS_FIGHTING
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.242 2000/06/26 04:35:25 mud Exp $";
d789 1
a789 1
	      if ( kit_table[kit].skills[i] == NULL )
@


1.242
log
@typoed fNonclan
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.241 2000/06/26 04:34:33 mud Exp $";
d793 1
a793 1
		  group_remove(ch,kit_table[kit].skills[i]);
d849 1
a849 1
	   send_to_char("Invalid kit.  Type 'help kit' for a list.\n\r",ch);
@


1.241
log
@fix who nonclan
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.240 2000/06/26 04:31:49 mud Exp $";
d3172 1
a3172 1
  || ( fNonclan && is_clan(wch))
@


1.240
log
@putting in a who nonclan
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.239 2000/06/25 23:23:41 mud Exp $";
d3075 1
a3075 1
			     if (!str_prefix(arg,"nonclan")))
@


1.239
log
@allow nonclanners (gladiator) to do kr
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.238 2000/05/30 22:19:27 mud Exp $";
d3006 1
d3075 12
a3086 10
                             iClan = clan_lookup(arg);
                             if  (iClan)
                             {
                                fClanRestrict = TRUE;
                                rgfClan[iClan] = TRUE;
                             }
                             else
                             {
                                if (!str_prefix(arg,"highlander"))
                                   fHighlander = TRUE;
d3089 7
a3095 2
				   send_to_char("That's not a valid race, class or clan.\n\r",ch);
                                   return;
d3172 1
@


1.238
log
@crash bug in kr fixed
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.237 2000/05/30 22:15:22 mud Exp $";
d3791 3
a3793 1
  if( IS_NPC(ch) || (!is_clan(ch) && !IS_IMMORTAL(ch)) )
@


1.237
log
@fixing kr I hope
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.236 2000/05/30 21:32:22 mud Exp $";
a3824 1
  /*
d3828 2
a3829 2
                "I have participated in %d Arena Events.",
		"In Single Arena I have %d victories having killed %d Gladiators.",
a3858 1
  */
@


1.236
log
@touch to recompile
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.235 2000/05/30 21:12:51 mud Exp $";
d3797 1
a3797 1
		"You have %d Single Victories, %d Single Kills,\n\r",
@


1.235
log
@enlarge buf
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.234 2000/05/30 00:57:32 mud Exp $";
d3778 1
a3778 1
  if(IS_SET(ch->mhs,MHS_HIGHLANDER))
@


1.234
log
@remove kr its crashing
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.233 2000/05/30 00:26:38 mud Exp $";
d3775 1
a3775 1
    char buf[2*MAX_INPUT_LENGTH];
a3790 1
/*
a3807 1
  */
@


1.233
log
@add team stats to kr, score and stat
clean up bugs in team code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.232 2000/05/29 19:40:50 mud Exp $";
d3791 1
d3809 1
d3827 1
d3862 1
@


1.232
log
@include gladiator.h
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.231 2000/05/29 19:37:00 mud Exp $";
d2386 2
a2387 1
	sprintf(buf,"Gladiator Victories: %d  Kills: %d\n\r",
d2389 3
a2391 1
	       ch->gladiator_data[GLADIATOR_KILLS]);
d3797 2
a3798 1
		"You have %d Arena Victories and you have killed %d Gladiators.\n\r",
d3803 4
a3806 1
		ch->gladiator_data[GLADIATOR_KILLS]);
d3828 3
a3830 1
		"I have %d victories in the Arena having killed %d Gladiators.",
d3833 1
d3835 3
a3837 1
		ch->gladiator_data[GLADIATOR_KILLS]);
@


1.231
log
@adding new gladiator files and tteam gladiator code with gladitor code moved
out of old files.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.230 2000/05/27 03:12:10 mud Exp $";
d37 1
@


1.230
log
@ Put the removing special stuff from a kit when you change kits at the wrong place.....
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.229 2000/05/27 02:44:07 mud Exp $";
d3233 4
a3236 1
       sprintf(cbuf,"[ Gladiator ] ");
@


1.229
log
@Kit Changing: REmove sepcial effects ( ennemy, spec)
Float: swim skill helps you vs floating away
Hold: casting level capped similar to sleep
Position for zap, brandish, quaff, recite set to Fighting
Check on eating pills for position at least of fighting
Snare: duration similar to hold

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.228 2000/05/25 01:34:03 mud Exp $";
d793 1
a798 1
		}
@


1.228
log
@shapemorphers dont show some flags
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.227 2000/05/21 00:28:52 mud Exp $";
d791 8
a798 1
		group_remove(ch,kit_table[kit].skills[i]);
@


1.227
log
@fix gladiator update
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.226 2000/05/20 02:29:27 mud Exp $";
a311 1
     if ( IS_AFFECTED(victim, AFF_PASS_DOOR)   ) strcat( buf, "(Translucent) ");
d321 20
d359 2
a360 2
     if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_DWEEB  ) )
             strcat( buf, "({CDWEEB{x) ");
@


1.226
log
@space out Gladiator properly
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.225 2000/05/20 01:38:41 mud Exp $";
a2356 1
#ifdef CODE_TEST
a2363 1
#endif
a3204 1
#ifdef CODE_TEST
a3209 1
#endif
a3760 1
#ifdef CODE_TEST
a3770 9
#else
  sprintf( buf, "You have approximately %d attempts and %d kills.\n\r"
		"The last player you killed was %s.\n\r"
		"The last player to kill you was %s.\n\r",
		ch->killer_data[PC_ATTACKS]/2,
		ch->killer_data[PC_KILLS], ch->pcdata->last_kill,
		ch->pcdata->last_killed_by);   
  send_to_char( buf, ch );
#endif
a3787 1
#ifdef CODE_TEST
a3795 7
#else
  sprintf( buf, "To inform you, $n says 'I have killed %d others in "
		"approximately %d attempts.\n\r"
		"I last killed %s.  The last person to kill me was %s.",
		ch->killer_data[PC_KILLS], ch->killer_data[PC_ATTACKS]/2,
		ch->pcdata->last_kill,ch->pcdata->last_killed_by); 
#endif
@


1.225
log
@umm I dont remember but I bet its gladiator stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.224 2000/05/20 01:27:27 mud Exp $";
d3210 1
a3210 1
       sprintf(cbuf,"[ Gladiator ]");
@


1.224
log
@make do_who show gladiators not do_whois
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.223 2000/05/20 01:12:19 mud Exp $";
d3210 1
a3210 1
       sprintf(cbuf,"[Gladiator]");
@


1.223
log
@working on Gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.222 2000/05/20 00:14:53 mud Exp $";
a2827 8
#ifdef CODE_TEST
    if (IS_SET(wch->mhs,MHS_GLADIATOR) && gladiator_info.started)
    {
       sprintf(cbuf,"[Gladiator]");
       sbuf[0] = '\0';
    }
#endif

d3206 8
@


1.222
log
@increase buf in do_kr
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.221 2000/05/19 23:57:22 mud Exp $";
a3802 5
sprintf(buf,"%s t1 %d",ch->name,ch->killer_data[PC_KILLS]);
log_string(buf);
sprintf(buf,"%s t2 %d",ch->name,ch->gladiator_data[GLADIATOR_KILLS]);
log_string(buf);
/*
a3804 8
		"I last killed %s.  The last person to kill me was %s.\n\r"
		"I have %d victories in the Arena having killed %d Gladiators.\n\r",
		ch->killer_data[PC_KILLS], ch->killer_data[PC_ATTACKS]/2,
		ch->pcdata->last_kill,ch->pcdata->last_killed_by,
		ch->gladiator_data[GLADIATOR_VICTORIES],
		ch->gladiator_data[GLADIATOR_KILLS]);
		*/
                sprintf( buf, "To inform you, $n says 'I have killed %d others in approximately %d atttempts.\n\r"
@


1.221
log
@boom boom
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.220 2000/05/19 23:56:02 mud Exp $";
d3746 1
a3746 1
    char buf[MAX_INPUT_LENGTH];
@


1.220
log
@boom
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.219 2000/05/19 23:50:18 mud Exp $";
d3820 1
@


1.219
log
@expand it a bit more
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.218 2000/05/19 23:08:20 mud Exp $";
d3817 1
a3817 1
		sprintf(buf,
d3819 1
a3819 1
		"I have %d victories in the Arena having killed %d Gladiators.\n\r",
@


1.218
log
@test length of string problem?
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.217 2000/05/19 22:59:06 mud Exp $";
d3817 4
a3820 1
		sprintf(buf,"Vic %d Kills %d\n\r",
@


1.217
log
@blah
-po
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.216 2000/05/19 22:53:51 mud Exp $";
d3807 1
d3810 1
a3810 1
		"I last killed %s.  The last person to kill me was %s."
d3816 4
a3819 1
  act( buf, ch, NULL, NULL, TO_ROOM,FALSE );
@


1.216
log
@one step closer
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.215 2000/05/19 22:37:11 mud Exp $";
d3815 1
@


1.215
log
@1234567890 trying not to lose my cool here
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.214 2000/05/19 22:33:39 mud Exp $";
a3765 4
sprintf(buf,"%s t1 %d",ch->name,ch->killer_data[PC_KILLS]);
log_string(buf);
sprintf(buf,"%s t2 %d",ch->name,ch->gladiator_data[GLADIATOR_KILLS]);
log_string(buf);
d3803 4
a3806 1
/*
a3814 6
		*/
  sprintf( buf, "To inform you, $n says 'I have killed %d others in "
		"approximately %d attempts.\n\r"
		"I last killed %s.  The last person to kill me was %s.",
		ch->killer_data[PC_KILLS], ch->killer_data[PC_ATTACKS]/2,
		ch->pcdata->last_kill,ch->pcdata->last_killed_by); 
@


1.214
log
@bloody hell
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.213 2000/05/19 22:29:16 mud Exp $";
d3779 1
@


1.213
log
@debugging kr
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.212 2000/05/19 22:24:27 mud Exp $";
a3769 1
/*
a3778 1
		*/
@


1.212
log
@log debug to actually trap string
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.211 2000/05/19 22:18:25 mud Exp $";
d3770 1
d3780 1
d3788 1
a3789 1
  send_to_char( buf, ch );
d3808 1
d3817 6
@


1.211
log
@debug crash in kr
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.210 2000/05/18 00:15:46 mud Exp $";
d3766 4
a3769 4
sprintf(buf,"t1 %d",ch->killer_data[PC_KILLS]);
send_to_char(buf,ch);
sprintf(buf,"t2 %d",ch->gladiator_data[GLADIATOR_KILLS]);
send_to_char(buf,ch);
@


1.210
log
@remove ccomma in do_kr I think is crashing
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.209 2000/05/16 00:55:57 mud Exp $";
d3766 4
@


1.209
log
@add in all the #ifdef CODE_TEST for gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.208 2000/05/13 21:55:08 mud Exp $";
d3768 1
a3768 1
		"The last player to kill you was %s.\n\r",
d3804 1
a3804 1
		"I last killed %s.  The last person to kill me was %s.",
@


1.208
log
@Gladiator Combat - Intense!
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.207 2000/04/18 19:50:50 mud Exp $";
d2357 1
d2365 1
d2828 1
d2834 1
d3765 1
d3775 8
d3801 1
a3801 1

d3810 7
@


1.207
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.206 2000/04/17 22:02:59 mud Exp $";
d2357 8
d2808 3
a2810 1
	clan_table[wch->clan].true_clan) sprintf(sbuf, "/%d] ", wch->pcdata->rank);
d2812 5
a2816 2
	&& clan_table[wch->clan].true_clan)  sprintf(sbuf, "] ");
    if ( wch->clan && !is_clan(wch)) sprintf(sbuf," ");
d2826 6
d2987 1
a3039 1
 
d3041 28
a3068 25
        {
      if (!str_prefix(arg,"clan"))
          fClan = TRUE;
      else
            {
          iClan = clan_lookup(arg);
          if  (iClan)
          {
        fClanRestrict = TRUE;
          rgfClan[iClan] = TRUE;
          }
          else
          {
   if (!str_prefix(arg,"highlander"))
      fHighlander = TRUE;
   else
   {
                          send_to_char(
                              "That's not a valid race, class, or clan.\n\r",
           ch);
                              return;
   } 
          }
                        }
        }
d3141 1
d3764 1
d3767 3
a3769 1
		ch->pcdata->last_killed_by);
d3792 1
d3794 3
a3796 1
		ch->pcdata->last_kill,ch->pcdata->last_killed_by);
@


1.206
log
@can_see() change typo fix
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.205 2000/04/17 22:00:43 mud Exp $";
d513 1
a513 1
       act( "$n looks at $mself.",ch,NULL,NULL,TO_ROOM);
d516 2
a517 2
       act( "$n looks at you.", ch, NULL, victim, TO_VICT    );
       act( "$n looks at $N.",  ch, NULL, victim, TO_NOTVICT );
d527 1
a527 1
   act( "You see nothing special about $M.", ch, NULL, victim, TO_CHAR );
d588 1
a588 1
     act( "$N is using:", ch, NULL, victim, TO_CHAR );
d953 2
a954 1
  act( "$N tried to peek at what you're carrying.", victim, NULL, ch, TO_CHAR );     }
d1074 1
a1074 1
     act( "$n ROARS and makes your entire body quiver!",ch,NULL,NULL,TO_ROOM );
d1837 1
a1837 1
       act( "$p contains:", ch, obj, NULL, TO_CHAR );
d2026 1
a2026 1
         act( "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
d2028 1
a2028 1
         act( "The exit is closed.", ch, NULL, pexit->keyword, TO_CHAR );
d2247 1
a2247 1
      act(buf2,ch,NULL,NULL,TO_ROOM);
d2250 1
a2250 1
      act(buf2,ch,NULL,NULL,TO_CHAR);
d3436 1
a3436 1
     act( msg, ch, obj1, obj2, TO_CHAR );
d3532 1
a3532 1
       act( "You didn't find any $T.", ch, NULL, arg, TO_CHAR );
d3580 1
a3580 1
     act( msg, ch, NULL, victim, TO_CHAR );
d3727 1
a3727 1
     act(buf,ch,NULL,NULL,TO_ROOM);
d3788 1
a3788 1
  act( buf, ch, NULL, NULL, TO_ROOM );
d3820 1
a3820 1
     act( buf, ch, NULL, NULL, TO_ROOM );
d3989 1
a3989 1
                    ch, NULL, skill_table[sn].name, TO_CHAR );
d3991 1
a3991 1
                    ch, NULL, skill_table[sn].name, TO_ROOM );
d3996 1
a3996 1
                    ch, NULL, skill_table[sn].name, TO_CHAR );
d3998 1
a3998 1
                    ch, NULL, skill_table[sn].name, TO_ROOM );
d4024 1
a4024 1
                    ch, NULL, skill_table[sn].name, TO_CHAR );
d4026 1
a4026 1
                    ch, NULL, skill_table[sn].name, TO_ROOM );
d4032 1
a4032 1
                    ch, NULL, skill_table[sn].name, TO_CHAR );
d4034 1
a4034 1
                    ch, NULL, skill_table[sn].name, TO_ROOM );
@


1.205
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.204 2000/04/06 23:38:23 mud Exp $";
d2793 1
a2793 1
  if (!can_see(ch,wch),TRUE)
@


1.204
log
@mispelled cstat
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.203 2000/04/06 23:37:11 mud Exp $";
d365 1
a365 1
        strcat( buf, PERS( victim, ch ) );
d485 1
a485 1
       strcat( buf, PERS( victim->fighting, ch ) );
d510 1
a510 1
     if ( can_see( victim, ch ) )
d544 1
a544 1
     strcpy( buf, PERS(victim, ch) );
d547 2
d555 1
d650 1
a650 1
   if ( can_see( ch, rch ) )
d952 1
a952 1
	if(IS_AWAKE(victim) && can_see(victim,ch))
d1661 1
a1661 1
     strcpy( buf, PERS(victim, ch) );
d1665 9
a1673 6
     if (IS_SET(victim->act,PLR_WERE))
	strcat (buf,"garou ");
     if (IS_SET (victim->act,PLR_VAMP))
	strcat (buf,"nosferatu ");
     if (IS_SET (victim->act,PLR_MUMMY))
	strcat (buf,"mummified ");
d2788 1
a2788 1
  if (d->connected != CON_PLAYING || !can_see(ch,d->character))
d2793 1
a2793 1
  if (!can_see(ch,wch))
d3100 1
a3100 1
        if ( d->connected != CON_PLAYING || !can_see( ch, d->character ) )
d3105 1
a3105 1
  if (!can_see(ch,wch) 
d3275 1
a3275 1
   if ( d->connected == CON_PLAYING && can_see( ch, d->character ) )
d3481 1
a3481 1
       && ( can_see( ch, victim)) 
d3512 1
a3512 1
       &&   can_see( ch, victim )
d3524 1
a3524 1
         PERS(victim, ch), victim->in_room->name );
d4194 1
a4194 1
  if ( ignore != NULL && can_see(ch,ignore) && !IS_NPC(ignore) )
@


1.203
log
@working on cstat
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.202 2000/04/06 23:35:06 mud Exp $";
d2924 1
a2924 1
       if (ctat->kills > 9)
@


1.202
log
@Working on CSTAT
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.201 2000/03/20 23:10:50 mud Exp $";
d2924 1
a2924 1
       if (clanstat->kills > 9)
d2926 1
a2926 1
       if (clanstat->kills < 10)
@


1.201
log
@move the stolen data into a steal_data with long int
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.200 2000/03/13 18:14:00 mud Exp $";
d2914 1
a2914 1
    CSTAT_DATA *clanstat;
d2920 1
a2920 1
    for (clanstat = cstat_first;clanstat != NULL;clanstat = clanstat->next)
d2922 2
a2923 2
       if (clanstat->kills > 99)
sprintf(buf,"%d    %s\n\r",clanstat->kills,clan_table[clanstat->clan].name);
d2925 1
a2925 1
sprintf(buf,"%d     %s\n\r",clanstat->kills,clan_table[clanstat->clan].name);
d2927 1
a2927 1
sprintf(buf,"%d      %s\n\r",clanstat->kills,clan_table[clanstat->clan].name);
@


1.200
log
@kr display adjustment on stolens
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.199 2000/03/13 17:58:18 mud Exp $";
d2315 8
a2322 6
	if (ch->killer_data[PC_STOLEN_ITEMS] > 0)
	{
	sprintf( buf, "Stolen: %d items %d gold %d silver ", 
		ch->killer_data[PC_STOLEN_ITEMS],
		ch->killer_data[PC_STOLEN_GOLD],
		ch->killer_data[PC_STOLEN_SILVER]);
d2325 1
a2325 1
	if (ch->killer_data[PC_SLICES] > 0)
d2327 2
a2328 2
	sprintf( buf, "Slices: %d  ", 
		ch->killer_data[PC_SLICES]);
d3738 3
a3740 3
  if (ch->killer_data[PC_STOLEN_ITEMS] > 0 ||
      ch->killer_data[PC_STOLEN_GOLD] > 0 ||
      ch->killer_data[PC_STOLEN_SILVER] > 0)
d3742 4
a3745 4
     sprintf( buf,"You have stolen %d items %d gold and %d silver.\n\r",
	      ch->killer_data[PC_STOLEN_ITEMS],  
	      ch->killer_data[PC_STOLEN_GOLD],
	      ch->killer_data[PC_STOLEN_SILVER]);
d3749 1
a3749 1
  if (ch->killer_data[PC_SLICES] > 0)
d3751 2
a3752 2
     sprintf( buf,"You have sliced open  %d items.\n\r",
	      ch->killer_data[PC_SLICES]);
d3762 3
a3764 3
  if (ch->killer_data[PC_STOLEN_ITEMS] > 0 ||
      ch->killer_data[PC_STOLEN_GOLD] > 0 ||
      ch->killer_data[PC_STOLEN_SILVER] > 0)
d3766 4
a3769 4
     sprintf( tbuf, "\n\rI have stolen %d items %d gold and %d silver.",  
		ch->killer_data[PC_STOLEN_ITEMS],
		ch->killer_data[PC_STOLEN_GOLD],
		ch->killer_data[PC_STOLEN_SILVER]); 
d3773 1
a3773 1
  if (ch->killer_data[PC_SLICES] > 0)
d3775 2
a3776 2
     sprintf( tbuf, "\n\rI have sliced open %d items.", 
		ch->killer_data[PC_SLICES]); 
@


1.199
log
@stolen adjustments
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.198 2000/03/12 00:35:44 mud Exp $";
d3711 1
d3756 1
a3756 1
		"I last killed %s.  The last person to kill me was %s'\n\r",
d3764 1
a3764 2
     sprintf( buf, buf
		   "'I have stolen %d items %d gold and %d silver.'\n\r ",  
d3768 1
d3773 1
a3773 2
     sprintf( buf, buf
		   "'I have sliced open %d items.'\n\r", 
d3775 1
d3778 1
@


1.198
log
@missing commas
poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.197 2000/03/12 00:32:39 mud Exp $";
d3729 2
a3730 1
		"The last player you killed was %s.\n\r",
d3732 2
a3733 1
		ch->killer_data[PC_KILLS], ch->pcdata->last_kill);
d3735 17
d3755 1
a3755 1
		"I last killed %s.The last person to kill me was %s'\n\r",
a3757 1
  act( buf, ch, NULL, NULL, TO_ROOM );
d3759 3
a3761 1
  if (ch->killer_data[PC_STOLEN_ITEMS] > 0)
d3763 2
a3764 6
     sprintf( buf,"You have stolen %d items %d gold and %d silver.\n\r",
	      ch->killer_data[PC_STOLEN_ITEMS],  
	      ch->killer_data[PC_STOLEN_GOLD],
	      ch->killer_data[PC_STOLEN_SILVER]);
     send_to_char(buf,ch);
  sprintf( buf, "'To inform you, $n says 'I have stolen %d items %d gold and %d silver.'\n\r ",  
a3767 1
  act( buf, ch, NULL, NULL, TO_ROOM );
d3772 2
a3773 4
     sprintf( buf,"You have sliced open  %d items.\n\r",
	      ch->killer_data[PC_SLICES]);
     send_to_char(buf,ch);
  sprintf( buf, "'To inform you, $n says 'I have sliced open %d items.'\n\r ", 
d3775 2
a3777 1
  }
d3780 1
@


1.197
log
@new thieving data
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.196 2000/03/10 22:02:46 mud Exp $";
d3748 1
a3748 1
  sprintf( buf, "'To inform you, $n says 'I have stolen %d items %d gold and %d silver.'\n\r "
d3760 1
a3760 1
  sprintf( buf, "'To inform you, $n says 'I have sliced open %d items.'\n\r "
@


1.196
log
@do_hd for dual wield debugging
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.195 2000/03/06 00:23:35 mud Exp $";
d2312 1
a2312 1
	sprintf( buf, "Approx. Attempts: %d  Kills: %d ", 
d2315 14
d3735 2
a3736 1
		"approximately %d attempts.  I last killed %s.'\n\r",
d3738 24
a3761 1
		ch->pcdata->last_kill);
d3763 1
@


1.195
log
@Dual Wield changes, second_hitroll,second_damroll and increase skill points to 2 for spells
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.194 2000/03/05 17:36:19 mud Exp $";
d4146 13
@


1.194
log
@ adjusted lore chances in do_look, so that people with no lore skill can't ID stuff by accident


 -Rage.
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.193 2000/02/26 22:55:50 mud Exp $";
d2515 8
a2522 3
   sprintf( buf, "Hitroll: %d  Damroll: %d.\n\r",
       GET_HITROLL(ch), GET_DAMROLL(ch) );
   send_to_char( buf, ch );
@


1.193
log
@ addedd a buffy kit, similar towyrmslayer but for killing remorts

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.192 2000/02/25 22:40:48 mud Exp $";
d1855 1
a1855 1
       number_percent( ) <= get_skill(ch,gsn_lore))
@


1.192
log
@fix prac to let you prac above 75 after remorting
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.191 2000/02/25 21:40:39 mud Exp $";
d738 11
@


1.191
log
@change grabs head to be gender neutral
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.190 2000/02/25 00:00:47 mud Exp $";
d3898 1
a3898 1
        if ( ch->pcdata->learned[sn] >= adept )
d3900 24
a3923 3
           sprintf( buf, "You are already learned at %s.\n\r",
              skill_table[sn].name );
           send_to_char( buf, ch );
d3926 2
a3927 2
        { 
           if (fOld)
d3929 3
a3931 24
	      if (ch->pcdata->learned[sn] < ch->pcdata->old_learned[sn])
	      {
                 ch->practice--;
                 ch->pcdata->learned[sn] = ch->pcdata->old_learned[sn]; 

                 if ( ch->pcdata->learned[sn] < 100 )
                 {
                    act( "You jump around yelling 'Pfresh my $T!'",
                       ch, NULL, skill_table[sn].name, TO_CHAR );
                    act( "$n jumps around yelling 'Pfresh my $T!'",
                       ch, NULL, skill_table[sn].name, TO_ROOM );
                 }
                 else
                 {
                    act( "You head is bursting with all the knowledge of $T!",
                       ch, NULL, skill_table[sn].name, TO_CHAR );
                    act( "$n grabs their head and screams 'Yikes my $T!'",
                       ch, NULL, skill_table[sn].name, TO_ROOM );
                 }
	      }
	      else
	      {
	         send_to_char("Your skill is already higher then your old skill.\n\r",ch);
	      }
d3933 2
a3934 2
           else
           {
d3955 1
a3955 1
           }
@


1.190
log
@Turn on the Pfresh
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.189 2000/02/20 06:16:54 mud Exp $";
d3924 1
a3924 1
                    act( "$n grabs $e head and screams 'Yikes my $T!'",
@


1.189
log
@ removed debug msg in act_info, added more in act_obj

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.188 2000/02/20 03:46:52 mud Exp $";
d742 2
a744 2
	*/
	if ( ch->train < kit_table[kit].cost )
a745 1
	/*
a746 2
	    */
	    send_to_char("You don't have enough trains.\n\r",ch);
d763 2
d766 1
d769 1
d771 1
a771 1
	ch->practice -= (kit_table[kit].cost * 10);
a772 1
	ch->train -= kit_table[kit].cost;
a812 1
	/*
d815 1
a815 1
		*/
d818 1
d2290 1
a2290 1
	ch->skill_points != 0 || ch->pcdata->savant != 0 ) )
@


1.188
log
@ bug hunt search
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.187 2000/02/16 07:08:06 mud Exp $";
a216 2
     sprintf(log_buf, "M1 %s ", ch->name);
     bug(log_buf,0);
a577 2
sprintf(log_buf, "M2 %s", ch->name);
bug(log_buf,0);
a1834 2
sprintf(log_buf, "M3 %s", ch->name);
bug(log_buf,0);
a1934 2
sprintf(log_buf, "M4 %s", ch->name);
bug(log_buf,0);
a3282 2
     sprintf(log_buf, "M5 %s", ch->name);
     bug(log_buf,0);
a3330 2
sprintf(log_buf, "M6 %s ", ch->name);
bug(log_buf, 0);
@


1.187
log
@remove pfresh beta code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.186 2000/02/15 20:04:22 mud Exp $";
d216 3
a218 1
     { 
d580 3
d1838 3
d1941 2
d3290 3
d3341 2
@


1.186
log
@Beta Test Time
_poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.185 2000/02/09 21:47:20 mud Exp $";
d741 2
a743 2
	*/
	if ( ch->practice < (kit_table[kit].cost * 10) )
d745 1
d747 2
d769 2
a771 2
	*/
	ch->practice -= (kit_table[kit].cost * 10);
d812 1
d815 3
@


1.185
log
@ctrcpy not strcat you bonehead poq
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.184 2000/02/09 21:38:19 mud Exp $";
d740 1
d742 2
d745 1
a745 1
	    send_to_char("You don't have enough trains.\n\r",ch);
d765 1
d767 2
d809 2
a810 2
       sprintf(buf,"{WKit: {x%s   {WCost: {G%d{x trains\n\r",
		kit_table[kit].name, kit_table[kit].cost);
@


1.184
log
@strcat not = :P
poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.183 2000/02/09 21:36:24 mud Exp $";
d3857 1
a3857 1
	   strcat(arg,arg2);
@


1.183
log
@fix bug in do_practice wheeee
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.182 2000/02/09 18:28:38 mud Exp $";
d3857 1
a3857 1
	   arg = arg2;
@


1.182
log
@do_practice done for pfresh
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.181 2000/02/09 18:23:38 mud Exp $";
d3856 4
a3859 1
        if ( ( sn = find_spell( ch,arg2 ) ) < 0
d3897 1
a3897 1
                 if ( ch->pcdata->learned[sn] < adept )
a3905 1
                    ch->pcdata->learned[sn] = adept;
@


1.181
log
@do do do prac
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.180 2000/02/09 18:07:20 mud Exp $";
a3854 3

        sprintf(buf, "argument = %s arg = %s arg2= %s\n\r",argument,arg,arg2);
	send_to_char(buf,ch);
@


1.180
log
@debugging do_prac
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.179 2000/02/09 18:05:46 mud Exp $";
d3737 2
d3767 2
a3768 1
     one_argument( argument, arg );
d3856 1
a3856 1
        sprintf(buf, "argument = %s arg = %s\n\r",argument,arg);
d3859 1
a3859 6
        one_argument( argument, arg );

        sprintf(buf, "argument = %s arg = %s\n\r",argument,arg);
	send_to_char(buf,ch);
 
        if ( ( sn = find_spell( ch,argument ) ) < 0
@


1.179
log
@damn mispelling
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.178 2000/02/09 18:03:46 mud Exp $";
d3853 1
a3853 1
        sprintf(buf, "argument = %s arg = %s\n\r",ch);
d3858 1
a3858 1
        sprintf(buf, "argument = %s arg = %s\n\r",ch);
@


1.178
log
@finishing up do_prac, one more debug time
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.177 2000/02/09 17:54:28 mud Exp $";
d3782 1
a3782 1
     if ( argument[0] == '\0' || fNew || fSkills || fspells)
@


1.177
log
@ put back in -new, -spells, -skills to do_prac
 -poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.176 2000/02/09 17:20:21 mud Exp $";
d3782 1
a3782 1
     if ( argument[0] == '\0' )
d3852 8
@


1.176
log
@missing " in a send_to_char
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.175 2000/02/09 17:17:12 mud Exp $";
a3766 3
     sprintf(buf,"argument = %s arg = %s\n\r",argument,arg);
     send_to_char(buf,ch);

d3772 9
a3780 2
     sprintf(buf," fOld = %d fSkip = %d\n\r",fOld,fSkip);
     send_to_char(buf,ch);
@


1.175
log
@Think I got that do_prac bug squashed
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.174 2000/02/09 17:13:07 mud Exp $";
d3905 1
a3905 1
	         send_to_char("Your skill is already higher then your old skill.\n\r,ch);
@


1.174
log
@declare arg in do_prac
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.173 2000/02/09 17:10:53 mud Exp $";
a3766 1
/*
a3768 1
     */
a3774 1
/*
a3776 1
     */
a3879 1
	/*
a3930 1
	   */
@


1.173
log
@Rip a section od do_prac out
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.172 2000/02/09 17:08:59 mud Exp $";
d3736 1
a3764 1
/*
a3765 1
     */
@


1.172
log
@comment out another line in do_prac
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.171 2000/02/09 17:02:28 mud Exp $";
d3885 1
d3937 1
@


1.171
log
@debugging do_prac
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.170 2000/02/09 01:39:58 mud Exp $";
d3764 1
d3766 1
@


1.170
log
@put do_prac back in watch it fail
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.169 2000/02/09 01:34:04 mud Exp $";
d3766 1
d3769 1
d3776 1
a3776 1

d3779 2
@


1.169
log
@commenting out do_practice see if this fixes it
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.168 2000/02/09 01:23:35 mud Exp $";
d3762 1
d3788 1
a3788 1
               || ch->pcdata->learned[sn] < 1 * skill is not known *)
d3851 1
a3851 1
               ||    ch->pcdata->learned[sn] < 1 * skill is not known *
a3857 2
        * If they did 'practice' without specifiing 'skip' or 'old'
           and they have skill % from pfresh, then tell them how to do it *
a3932 1
     */
@


1.168
log
@syntax error in compiling, dman it
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.167 2000/02/09 00:55:55 mud Exp $";
d3762 1
a3762 1
     */
a3775 3
/*
     if ( argument[0] == '\0' || fSkills || fSpells || fNew )
     */
d3787 1
a3787 1
               || ch->pcdata->learned[sn] < 1 /* skill is not known */)
d3850 1
a3850 1
               ||    ch->pcdata->learned[sn] < 1 /* skill is not known */
d3857 2
a3858 2
        /* If they did 'practice' without specifiing 'skip' or 'old'
           and they have skill % from pfresh, then tell them how to do it */
d3864 1
d3934 1
@


1.167
log
@blah practice toast
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.166 2000/02/09 00:46:51 mud Exp $";
d3781 2
a3782 2
   int col;
   buf2[0] = '\0';
d3784 28
a3811 27
   col    = 0;
   for ( sn = 0; sn < MAX_SKILL; sn++ )
   {
       if ( skill_table[sn].name == NULL )
     break;
       if ( ch->level < skill_level(ch,sn)
         || ch->pcdata->learned[sn] < 1 /* skill is not known */)
     continue;

     	if ( fNew && ch->pcdata->learned[sn] >= 75 )
		continue;

	if ( fSpells && skill_table[sn].spell_fun == spell_null )
		continue;

	if ( fSkills && skill_table[sn].spell_fun != spell_null )
		continue;

  sprintf( buf, "{%c%-18s{x %3d%%  " , 
     ch->pcdata->learned[sn] != ch->pcdata->last_learned[sn] ? 'R' : 'x',
     skill_table[sn].name,
     ch->pcdata->learned[sn] );
       strcat( buf2, buf );
       if ( ++col % 3 == 0 )
     strcat( buf2, "\n\r" );
     ch->pcdata->last_learned[sn] = ch->pcdata->learned[sn];
   }
d3813 2
a3814 2
   if ( col % 3 != 0 )
       strcat( buf2, "\n\r" );
d3816 4
a3819 4
   sprintf( buf, "You have %d practice sessions left.\n\r",
       ch->practice );
   strcat( buf2, buf );
   page_to_char(buf2, ch);
d3823 2
a3824 2
   CHAR_DATA *mob;
   int adept, blah;
d3826 5
a3830 5
   if ( !IS_AWAKE(ch) )
   {
       send_to_char( "In your dreams, or what?\n\r", ch );
       return;
   }
d3832 5
a3836 5
   for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
   {
       if ( IS_NPC(mob) && IS_SET(mob->act, ACT_PRACTICE) )
     break;
   }
d3838 5
a3842 5
   if ( mob == NULL )
   {
       send_to_char( "You can't do that here.\n\r", ch );
       return;
   }
d3844 5
a3848 5
   if ( ch->practice <= 0 )
   {
       send_to_char( "You have no practice sessions left.\n\r", ch );
       return;
   }
d3850 9
a3858 9
   if ( ( sn = find_spell( ch,argument ) ) < 0
   || ( !IS_NPC(ch)
   &&   (ch->level < skill_level(ch,sn)
   ||    ch->pcdata->learned[sn] < 1 /* skill is not known */
   ||    skill_table[sn].rating[ch->class] == 0)))
   {
       send_to_char( "You can't practice that.\n\r", ch );
       return;
   }
d3860 6
a3865 6
   /* If they did 'practice' without specifiing 'skip' or 'old'
      and they have skill % from pfresh, then tell them how to do it */
   if (ch->pcdata->learned[sn] < ch->pcdata->old_learned[sn]
       && !fOld && !fSkip)
   {
      sprintf(buf,"You had %s at %d prior to the Pfresh.\n\r",
d3867 4
a3870 4
      send_to_char("If you would like to return to that %, use 'practice -old (name)'.\n\r", ch);
      send_to_char("If you would like to disregard your old %, use 'practice -skip (name)'.\n\r",ch);
      return;
   }
d3872 1
a3872 1
   adept = IS_NPC(ch) ? 100 : class_table[ch->class].skill_adept;
d3874 60
a3933 61
   if ( ch->pcdata->learned[sn] >= adept )
   {
       sprintf( buf, "You are already learned at %s.\n\r",
     skill_table[sn].name );
       send_to_char( buf, ch );
   }
   else
   { 
       if (fOld)
       {
	  if (ch->pcdata->learned[sn] < ch->pcdata->old_learned[sn])
	  {
             ch->practice--;
             ch->pcdata->learned[sn] = ch->pcdata->old_learned[sn]; 

             if ( ch->pcdata->learned[sn] < adept )
             {
                act( "You jump around yelling 'Pfresh my $T!'",
                   ch, NULL, skill_table[sn].name, TO_CHAR );
                act( "$n jumps around yelling 'Pfresh my $T!'",
                   ch, NULL, skill_table[sn].name, TO_ROOM );
             }
             else
             {
                ch->pcdata->learned[sn] = adept;
                act( "You head is bursting with all the knowledge of $T!",
                   ch, NULL, skill_table[sn].name, TO_CHAR );
                act( "$n grabs $e head and screams 'Yikes my $T!'",
                   ch, NULL, skill_table[sn].name, TO_ROOM );
             }
	  }
	  else
	  {
	     send_to_char("Your skill is already higher then your old skill.\n\r,ch);
	  }

       }
       else
       {
          blah = abs(skill_table[sn].rating[ch->class]);
          ch->practice--;
          ch->pcdata->learned[sn] += 
             int_app[get_curr_stat(ch,STAT_INT)].learn / blah ;

          if ( ch->pcdata->learned[sn] < adept )
          {
             act( "You practice $T.",
                ch, NULL, skill_table[sn].name, TO_CHAR );
             act( "$n practices $T.",
                ch, NULL, skill_table[sn].name, TO_ROOM );
          }
          else
          {
             ch->pcdata->learned[sn] = adept;
             act( "You are now learned at $T.",
                ch, NULL, skill_table[sn].name, TO_CHAR );
             act( "$n is now learned at $T.",
                ch, NULL, skill_table[sn].name, TO_ROOM );
          }
       }
   }
@


1.166
log
@working on practice for pfresh
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.165 2000/02/08 23:49:00 mud Exp $";
d3774 1
a3774 1
     sprintf(buf,"fOld = %d fSkip = %d\n\r",fOld,fSkip);
@


1.165
log
@fix do_pracitce for fOld
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.164 2000/02/08 23:07:34 mud Exp $";
d3741 1
d3762 5
d3768 9
d3778 2
d3883 4
a3886 2
          ch->practice--;
          ch->pcdata->learned[sn] = ch->pcdata->old_learned[sn]; 
d3888 20
a3907 15
          if ( ch->pcdata->learned[sn] < adept )
          {
             act( "You jump around yelling 'Pfresh my $T!'",
                ch, NULL, skill_table[sn].name, TO_CHAR );
             act( "$n jumps around yelling 'Pfresh my $T!'",
                ch, NULL, skill_table[sn].name, TO_ROOM );
          }
          else
          {
             ch->pcdata->learned[sn] = adept;
             act( "You head is bursting with all the knowledge of $T!",
                ch, NULL, skill_table[sn].name, TO_CHAR );
             act( "$n grabs $e head and screams 'Yikes my $T!'",
                ch, NULL, skill_table[sn].name, TO_ROOM );
          }
@


1.164
log
@typoed pcdatat
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.163 2000/02/08 23:05:41 mud Exp $";
d3864 1
a3864 1
       if (fSkip)
a3865 1
          blah = abs(skill_table[sn].rating[ch->class]);
d3867 1
a3867 2
          ch->pcdata->learned[sn] += 
             int_app[get_curr_stat(ch,STAT_INT)].learn / blah ;
d3871 1
a3871 1
             act( "You practice $T.",
d3873 1
a3873 1
             act( "$n practices $T.",
d3879 1
a3879 1
             act( "You are now learned at $T.",
d3881 1
a3881 1
             act( "$n is now learned at $T.",
d3884 1
a3886 1
       if (fOld)
d3888 1
d3890 2
a3891 1
          ch->pcdata->learned[sn] = ch->pcdata->old_learned[sn]; 
d3895 1
a3895 1
             act( "You jump around yelling 'Pfresh my $T!'",
d3897 1
a3897 1
             act( "$n jumps around yelling 'Pfresh my $T!'",
d3903 1
a3903 1
             act( "You head is bursting with all the knowledge of $T!",
d3905 1
a3905 1
             act( "$n grabs $e head and screams 'Yikes my $T!'",
a3907 5

       }
       else
       {
	  send_to_char("Boom-Chak-a-Laka!\n\r",ch);
@


1.163
log
@old Skill %'s for pfresh.
act_info: change do_practice to be able to use old %
comm.c: have pfresh reset the learned and store them in old_learned
merc.h: define old_learned
save.c: load up default old_learned and save in pfiles, and read
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.162 2000/01/25 01:17:36 mud Exp $";
d3891 1
a3891 1
          ch->pcdata->learned[sn] = ch->pcdatat->old_learned[sn]; 
@


1.162
log
@Tweak linkdead in look
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.161 2000/01/25 01:11:22 mud Exp $";
d3733 1
d3753 6
d3842 12
d3864 45
a3908 11
       blah = abs(skill_table[sn].rating[ch->class]);
       ch->practice--;
       ch->pcdata->learned[sn] += 
     int_app[get_curr_stat(ch,STAT_INT)].learn / blah ;

       if ( ch->pcdata->learned[sn] < adept )
       {
     act( "You practice $T.",
         ch, NULL, skill_table[sn].name, TO_CHAR );
     act( "$n practices $T.",
         ch, NULL, skill_table[sn].name, TO_ROOM );
d3912 1
a3912 5
     ch->pcdata->learned[sn] = adept;
     act( "You are now learned at $T.",
         ch, NULL, skill_table[sn].name, TO_CHAR );
     act( "$n is now learned at $T.",
         ch, NULL, skill_table[sn].name, TO_ROOM );
@


1.161
log
@fix a really old linkdead bug on showing on look
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.160 1999/12/17 23:13:39 mud Exp $";
d306 1
a306 1
     if ( !IS_NPC(victim) && !victim->desc )	strcat( buf, "({YLinkdead{x) ");
@


1.160
log
@Removed Savant added   Pfresh flag
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.159 1999/12/17 00:02:12 mud Exp $";
d306 1
a306 1
     if ( ch->desc == NULL )		strcat( buf, "({YLinkdead{x) ");
@


1.159
log
@Remove Savant and Scion stuff
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.158 1999/11/05 08:19:11 mud Exp $";
a2280 5
     if ( ch->pcdata->savant != 0 )
     { 
	 sprintf(buf,"Savant: %d",ch->pcdata->savant);
	 send_to_char(buf,ch);
     }
@


1.158
log
@ Added brawler.
  Added some color to act_info.c and act_comm.c
  Added attack command to interp.c

  Ben
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.157 1999/10/31 02:23:19 mud Exp $";
d2229 1
d2235 7
d2837 1
a2837 2
      sprintf(buf, "%s%s%s%s[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r{x",
    IS_SET(ch->mhs,MHS_ADVISORY_BOARD) ? "A" : " ",
a2839 1
    !IS_IMMORTAL(ch) ? "" : ( IS_SET(wch->mhs,MHS_SAVANT) ? "S" : " "),
d3185 1
a3185 2
  sprintf( buf, "%s%s%s%s[%2d %6s %s]{x%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
      IS_SET(ch->mhs,MHS_ADVISORY_BOARD) ? "A" : " ",
a3187 1
      !IS_IMMORTAL(ch) ? "" : ( IS_SET(wch->mhs,MHS_SAVANT) ? "S" : " "),
@


1.157
log
@new remort 'mummy' with skill 'breathe'
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.156 1999/10/18 05:42:39 mud Exp $";
d50 20
a69 20
     "<used as light>     ",
     "<worn on finger>    ",
     "<worn on finger>    ",
     "<worn around neck>  ",
     "<worn around neck>  ",
     "<worn on torso>     ",
     "<worn on head>      ",
     "<worn on legs>      ",
     "<worn on feet>      ",
     "<worn on hands>     ",
     "<worn on arms>      ",
     "<worn as shield>    ",
     "<worn about body>   ",
     "<worn about waist>  ",
     "<worn around wrist> ",
     "<worn around wrist> ",
     "<wielded>           ",
     "<held>              ",
     "<floating nearby>   ",
     "<secondary weapon>  "
@


1.156
log
@Fixed typo in do_rescue and moved it down the auto list
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.155 1999/10/17 23:22:48 mud Exp $";
d551 2
d1641 2
@


1.155
log
@Changes autorescue to norescue, made more sense
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.154 1999/10/17 22:56:41 mud Exp $";
a1123 6
     send_to_char("norescue       ",ch);
     if (IS_SET(ch->mhs,MHS_NORESCUE))
   send_to_char("ON\n\r",ch);
     else
   send_to_char("OFF\n\r",ch);

d1148 6
d1313 1
a1313 1
       send_to_char("You can be now be rescued.\n\r",ch);
@


1.154
log
@Fight.c - Changed do_rescue to check for MHS_AUTORESCUE
act_info.c - Displays of AUTORESCUE
handler.c - do_autorescue created
interp.c and interp.h - defined new do_autorescue
merc.h - defined MHS_AUTORESCUE
tables.c - added autorescue
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.153 1999/10/15 22:40:53 mud Exp $";
d1124 2
a1125 2
     send_to_char("autorescue       ",ch);
     if (IS_SET(ch->mhs,MHS_AUTORESCUE))
d1301 1
a1301 1
 void do_autorescue(CHAR_DATA *ch, char *argument)
d1306 1
a1306 1
     if (IS_SET(ch->mhs,MHS_AUTORESCUE))
d1309 1
a1309 1
       REMOVE_BIT(ch->mhs,MHS_AUTORESCUE);
d1314 1
a1314 1
       SET_BIT(ch->mhs,MHS_AUTORESCUE);
@


1.153
log
@Remove Save_Name (not needed) from all files.
Make it remove the Shapemorph on quiting.
Show in Score what you are morphed into.
Adjust Morph so you cant morph into other players online or via pfile
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.152 1999/10/15 01:17:28 mud Exp $";
d1124 6
d1301 17
@


1.152
log
@Changed char_in_room to check for is_name (name) and (save_name) to avoid having
to change ch->name, cause that can get messy.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.151 1999/10/15 00:48:30 mud Exp $";
d2493 7
@


1.151
log
@who and whois should show actually save_name of morphed shifters
Added a " " to name when it appends description in mag2.c
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.150 1999/10/10 17:20:51 mud Exp $";
d2789 1
a2789 1
              IS_SET(wch->mhs,MHS_SHAPEMORPHED) ? wch->save_name : wch->name, 
d3139 1
a3139 1
             IS_SET(wch->mhs,MHS_SHAPEMORPHED) ? wch->save_name : wch->name, 
@


1.150
log
@declared remove_all_obj() in act_obj.c section of merc.h and added
the DECLARE_DO_FUN for do_outfit() in act_info.c
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.149 1999/10/08 20:45:55 mud Exp $";
d2789 2
a2790 1
              wch->name, IS_NPC(wch) ? "" : wch->pcdata->title);
d3139 2
a3140 1
             wch->name, IS_NPC(wch) ? "" : wch->pcdata->title);
@


1.149
log
@Added debit levels to scorfe
G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.148 1999/10/02 02:16:41 mud Exp $";
d44 1
@


1.148
log
@Shapemorphed shows long_descr
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.147 1999/10/01 18:46:31 mud Exp $";
d2202 1
a2202 1
   "You are %s, level %d, %d years old (%d hours).\n\r",
d2204 1
a2204 1
   ch->level, get_age(ch),
@


1.147
log
@Glance and Look for Remorts
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.146 1999/10/01 18:36:34 mud Exp $";
d358 11
a368 4
     strcat( buf, PERS( victim, ch ) );
     if ( !IS_NPC(victim) && !IS_SET(ch->display,DISP_BRIEF_DESCR) 
     &&   victim->position == POS_STANDING && ch->on == NULL )
   strcat( buf, victim->pcdata->title );
@


1.146
log
@More Look and Glance Features
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.145 1999/09/30 17:28:20 mud Exp $";
d538 1
a538 1
     strcat (buf, " the");
d540 1
a540 1
	strcat (buf," garou");
d542 1
a542 1
	strcat (buf," nosferatu");
d1603 1
a1603 1
     strcat (buf, " the");
d1605 1
a1605 1
	strcat (buf," garou");
d1607 1
a1607 1
	strcat (buf," nosferatu");
@


1.145
log
@Syntax error in race showing in look and glance
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.144 1999/09/30 17:26:04 mud Exp $";
a495 1
     char temp_race[50];
d538 6
a543 2
     sprintf(temp_race," the %s",race_table[victim->race].name);
     strcat (buf,temp_race);
a1570 1
     char temp_race[50];
d1603 6
a1608 2
     sprintf(temp_race," the %s",race_table[victim->race].name);
     strcat (buf,temp_race);
@


1.144
log
@Glance and Look show Victims Race
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.143 1999/09/30 17:09:07 mud Exp $";
d539 1
a539 1
     sprintf(temp_race" the %s",race_table[victim->race].name);
@


1.143
log
@Shapeshifter
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.142 1999/09/30 17:03:39 mud Exp $";
d539 1
a539 2
 /*
     sprintf(temp_race" the %s",race_table[ch->race].name);
a540 1
     */
d1601 1
a1601 2
/*
     sprintf(temp_race," the %s",race_table[ch->race].name);
a1602 1
     */
@


1.142
log
@Shapeshifters save race showing on who and whois
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.141 1999/09/30 05:12:32 mud Exp $";
d2686 1
a2686 1
  char const *race;
d2736 1
a2736 1
        race = pc_race_table[wch->save_race].who_name
d2740 1
a2740 1
        race = pc_race_table[wch->race].who_name 
d2790 1
a2790 1
    race,
d3066 1
a3066 1
       race = pc_race_table[wch->save_race].who_name
d3070 1
a3070 1
       race = pc_race_table[wch->race].who_name 
d3139 1
a3139 1
      race, 
@


1.141
log
@Kit bug fixed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.140 1999/09/30 04:22:58 mud Exp $";
d2686 1
d2730 12
d2790 1
a2790 2
    wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name
          : "     ",
d2995 1
d3061 12
d3139 1
a3139 2
      wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name 
            : "     ",
@


1.140
log
@Comment out Shapeshifter Race thing I was working on in here
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.139 1999/09/30 04:18:14 mud Exp $";
d746 1
a746 1
	if ( kit = kit_lookup("myrmidon") &&
@


1.139
log
@Fixing the Wands bug Rage just put in
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.138 1999/09/28 23:20:30 mud Exp $";
d539 1
d542 1
d1602 2
d1606 1
@


1.138
log
@Myrmidon
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.137 1999/09/18 08:44:07 mud Exp $";
d496 1
d539 3
d1568 1
d1599 3
@


1.137
log
@Elementalist Electric Shield
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.136 1999/09/18 08:07:01 mud Exp $";
d739 4
@


1.136
log
@Elementalists Frost Shield
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.135 1999/09/14 04:21:41 mud Exp $";
d327 2
@


1.135
log
@skill points apply
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.134 1999/09/06 20:31:40 mud Exp $";
d325 2
@


1.134
log
@Remove all EQ when taking Nethermancer
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.133 1999/09/06 03:37:31 mud Exp $";
d2212 1
a2212 1
   "Trains: %d    Practices: %d   Skill Points: %d   ",
@


1.133
log
@Savant stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.132 1999/09/06 02:31:42 mud Exp $";
d749 1
d757 4
@


1.132
log
@fixed trains/practice juxtaposition
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.131 1999/09/03 19:26:01 mud Exp $";
d2745 1
a2745 1
      sprintf(buf, "%s%s%s[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r{x",
d2749 1
d3082 1
a3082 1
  sprintf( buf, "%s%s%s[%2d %6s %s]{x%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
d3086 1
@


1.131
log
@Added skill points, will implement that later.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.130 1999/09/02 03:15:37 mud Exp $";
d2208 1
a2208 1
   ch->practice, ch->train, ch->skill_points );
@


1.130
log
@Mounted code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.129 1999/08/26 22:42:40 mud Exp $";
d2203 2
a2204 1
   if ( ch->practice != 0 || ch->train != 0 )
d2207 2
a2208 2
   "You have %d practices and %d training sessions.\n\r",
   ch->practice, ch->train);
d2210 6
@


1.129
log
@Link death stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.128 1999/08/26 16:57:34 mud Exp $";
d2318 6
a2323 1
 
@


1.128
log
@Added lack aura for nether flags
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.127 1999/08/12 02:22:33 mud Exp $";
d304 2
a305 1
 
@


1.127
log
@Last changes to nethermancer
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.126 1999/08/12 01:03:53 mud Exp $";
d143 2
@


1.126
log
@Nethermancers are in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.125 1999/07/24 05:49:03 mud Exp $";
d745 8
d754 2
@


1.125
log
@Debug loading of cstat to see whats loading
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.124 1999/07/24 05:08:19 mud Exp $";
d744 2
@


1.124
log
@This one is going to be buggy I can see it coming
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.123 1999/07/24 05:06:34 mud Exp $";
d2758 2
a2759 2
    send_to_char("Kills  Clan",ch);
    send_to_char("-----  ----",ch);
d2764 1
a2764 1
sprintf(buf,"%d    %s\n",clanstat->kills,clan_table[clanstat->clan].name);
d2766 1
a2766 1
sprintf(buf,"%d     %s\n",clanstat->kills,clan_table[clanstat->clan].name);
d2768 1
a2768 1
sprintf(buf,"%d      %s\n",clanstat->kills,clan_table[clanstat->clan].name);
@


1.123
log
@Clanstat declare
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.122 1999/07/24 04:59:55 mud Exp $";
a38 1
 DECLARE_DO_FUN( do_cstat        );
d2761 1
a2761 1
    for (clanstat = cstat_first;cstat != NULL;clanstat = clanstat->next)
@


1.122
log
@Cstat Adding
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.121 1999/07/23 20:40:57 mud Exp $";
d2756 1
a2756 1
    CSTAT_DATA *cstat;
d2762 1
a2762 1
    for (cstat = cstat_first;cstat != NULL;cstat = cstat->next)
d2764 6
a2769 6
       if (cstat->kills > 99)
sprintf(buf,"%d    %s\n",cstat->kills,clan_table[cstat->clan].name);
       if (cstat->kills > 9)
sprintf(buf,"%d     %s\n",cstat->kills,clan_table[cstat->clan].name);
       if (cstat->kills < 10)
sprintf(buf,"%d      %s\n",cstat->kills,clan_table[cstat->clan].name);
@


1.121
log
@Remove Approval Code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.120 1999/07/23 20:01:07 mud Exp $";
d39 1
d2754 19
@


1.120
log
@Removing Approval Code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.119 1999/07/14 18:13:25 mud Exp $";
d3035 1
a3035 1
  sprintf( buf, "%s%s%s%s[%2d %6s %s]{x%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
@


1.119
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_info.c,v 1.117 1999/07/10 00:11:34 mud Exp $";
a3038 1
      !IS_IMMORTAL(ch) ? "" : ( IS_SET(wch->mhs,MHS_UNAPPROVED) ? "{CU" : " "),
@


1.118
log
@Spiffied up pratice a bit
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.117 1999/07/10 00:11:34 mud Exp $ */
@


1.117
log
@Name approval
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.116 1999/07/03 23:35:07 mud Exp $ */
d3590 1
a3596 1
 
d3598 16
a3613 1
     if ( argument[0] == '\0' )
d3626 9
@


1.116
log
@Detect Magic now shows victims spells in affect
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.115 1999/07/03 23:25:29 mud Exp $ */
d3035 1
a3035 1
  sprintf( buf, "%s%s%s[%2d %6s %s]%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
d3039 1
@


1.115
log
@Detect Magic shows spells worn by others
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.114 1999/07/03 23:14:29 mud Exp $ */
d583 1
a583 1
     send_to_char( "Affected by the following spells:\n\r", ch );   
d596 1
a596 1
           sprintf( buf, "\n\rSpell: %-15s\n\r", skill_table[paf->type].name );
d603 1
a603 1
     send_to_char("Not affected by any spells.\n\r",ch);
@


1.114
log
@Detect Magic view spells is skipping 1 spell
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.113 1999/07/03 23:06:57 mud Exp $ */
d586 12
a597 4
        if (paf->type != paf_last->type)
        {
           sprintf( buf, "Spell: %-15s\n\r", skill_table[paf->type].name );
           send_to_char( buf, ch );
@


1.113
log
@Detect magic can see spells when you look at a victim
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.112 1999/06/28 06:34:15 mud Exp $ */
d586 1
a586 1
        if (paf_last != NULL && paf->type != paf_last->type)
@


1.112
log
@Fixed skill levels
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.111 1999/06/21 21:13:00 mud Exp $ */
d493 1
d578 19
a596 1
 
@


1.111
log
@Elementalist Nodes Displayed in Score cleaning up warnings
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.110 1999/06/21 21:03:36 mud Exp $ */
d3580 1
a3580 1
       if ( ch->level < skill_table[sn].skill_level[ch->class] 
d3633 1
a3633 1
   &&   (ch->level < skill_table[sn].skill_level[ch->class] 
@


1.110
log
@Oppsie missed a bracket in Elementalist Nodes in Score
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.109 1999/06/21 20:59:29 mud Exp $ */
d2396 1
a2396 3
        location = ch->pcdata->node;
       
        if (location != 0)
d2398 1
a2398 1
           get_room_index( atoi( location ) );
@


1.109
log
@Display Node location in score for elementalists
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.108 1999/06/20 20:29:18 mud Exp $ */
d2394 1
a2394 1
     if ( ch->class == class_lookup("elementalist")
@


1.108
log
@Bladesinger
Battlerager
Done
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.107 1999/06/17 15:36:07 mud Exp $ */
d2121 1
d2393 13
@


1.107
log
@Addded NOCLAN room flag not allowing clanners in rooms
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.106 1999/05/25 06:43:19 mud Exp $ */
d2146 4
a2149 2
   
 
d2151 5
a2155 2
   "You have %d/%d hit, %d/%d mana, %d/%d movement.\n\r",
   ch->hit,  ch->max_hit,
d2679 2
a2680 1
      sprintf(buf, "%s%s[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r{x",
d2996 2
a2997 1
  sprintf( buf, "%s%s[%2d %6s %s]%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
d3519 7
a3525 1
 
@


1.106
log
@Shapeshifters can once again practice
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.105 1999/05/25 06:24:54 mud Exp $ */
d3236 1
a3236 1
       ||   (!room_is_private(victim->in_room)) )
@


1.105
log
@debugging shapers
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.104 1999/05/25 06:22:23 mud Exp $ */
a3539 1
     int i;
a3615 14
   if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
   {
      /* check racial skills */
      for (i = 0; i < 5; i++)
      {
         if (pc_race_table[ch->race].skills[i] == NULL)
         break;
         sprintf(buf,"racial= %s\n\r",pc_race_table[ch->race].skills[i]);
	 send_to_char(buf,ch);
      }
  /*    return;
  */
   }
 
@


1.104
log
@Testing shapers practicing
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.103 1999/05/22 22:11:03 mud Exp $ */
d3540 1
@


1.103
log
@Fixed a typo
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.102 1999/05/22 21:49:54 mud Exp $ */
a3543 5
     if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
     {
	send_to_char("You are not allowed to practice while shapeshifted, for now.\n\r",ch);
	return;
     }
d3614 14
@


1.102
log
@-Added some cosmetic changes
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.101 1999/05/22 16:09:32 mud Exp $ */
d321 1
a321 1
	strcat( buf, "{{rFire Shield{x} " );
@


1.101
log
@Stop shapeshifters from practicing for now
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.100 1999/05/18 00:04:22 mud Exp $ */
d320 2
@


1.100
log
@A
dded mutant status to who list so I can tell what the hell is going on
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.99 1999/05/15 17:12:08 mud Exp $ */
d3542 6
@


1.99
log
@cannot retain skills from old kits anymore
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.98 1999/05/15 17:01:04 mud Exp $ */
d2672 1
a2672 1
      sprintf(buf, "%s[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r{x",
d2674 1
d2988 1
a2988 1
  sprintf( buf, "%s[%2d %6s %s]%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
d2990 1
@


1.98
log
@Fixed o ne bug with rangers.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.97 1999/05/15 16:38:59 mud Exp $ */
d694 10
@


1.97
log
@Rangers.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.96 1999/05/05 12:46:11 mud Exp $ */
d112 2
a113 1
	!race_table[race].pc_race )
@


1.96
log
@Added carriage return/line feed to score
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.95 1999/05/04 10:43:21 mud Exp $ */
d89 36
a124 2
 
 
d2261 6
@


1.95
log
@Yanked savant code, minor adjustment todbite
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.94 1999/04/28 08:09:30 mud Exp $ */
d2163 1
a2163 1
   "You have %d exp, %ld gold, %ld silver, and %d eggs in the bank.",
@


1.94
log
@Last bit of Svant code before the big quest
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.93 1999/04/26 08:08:08 mud Exp $ */
d2163 2
a2164 2
   "You have scored %d exp, and have %ld gold and %ld silver coins.\n\r",
   ch->exp,  ch->gold, ch->silver );
@


1.93
log
@Added a a few moer savant things... cosmetic changes
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.92 1999/04/26 05:30:58 mud Exp $ */
a2565 3
      if ( IS_SET(wch->mhs,MHS_SAVANT) )
	  class = "Sav";
      else
a2858 3
   if ( IS_SET(wch->mhs,MHS_SAVANT) )
       class = "Sav";
   else
@


1.92
log
@Stuff for the Savant quest
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.91 1999/04/23 23:43:36 mud Exp $ */
d2566 4
a2569 1
      class = class_table[wch->class].who_name;
d2862 3
@


1.91
log
@Change all PLR_HIGHLANDER to MHS_HIGHLANDER and moved under MHS bit
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.90 1999/04/14 23:41:06 mud Exp $ */
d2078 1
a2078 1
   ch->name,
@


1.90
log
@Highlander ocunts added to KR and to Score
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.89 1999/04/13 00:50:40 mud Exp $ */
d2133 1
a2133 1
     if(!IS_NPC(ch) && IS_SET(ch->act,PLR_HIGHLANDER))
d2833 1
a2833 1
  || ( fHighlander && !IS_SET(wch->act,PLR_HIGHLANDER))
d3422 1
a3422 1
  if(IS_SET(ch->act,PLR_HIGHLANDER))
@


1.89
log
@Change do_who for highlander to check wch->act not ch->act
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.88 1999/04/12 22:42:00 mud Exp $ */
d2133 7
d3421 13
@


1.88
log
@password command now logs silently instead of over wiznet
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.87 1999/04/12 03:54:16 mud Exp $ */
a2769 1

d2826 1
a2826 1
  || ( fHighlander && !IS_SET(ch->act,PLR_HIGHLANDER))
@


1.87
log
@Extra bracket left over, removed
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.86 1999/04/12 03:50:30 mud Exp $ */
d3618 1
d3669 3
d3677 1
a3677 1
 
@


1.86
log
@Remove debug messages
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.85 1999/04/12 03:43:40 mud Exp $ */
a2767 1
   }
@


1.85
log
@Oh oh got alot of syntax errors, bet my If check is toast
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.84 1999/04/12 03:36:48 mud Exp $ */
d2771 1
a2771 2
sprintf(buf,"high = \n\r");
send_to_char(buf,ch);
@


1.84
log
@Able to do who highlander
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.83 1999/03/30 15:23:43 mud Exp $ */
d2771 1
a2771 1
sprintf(buf,"high = %s\n\r",fHighlander);
@


1.83
log
@Added a RUFFIAN flag timer so they eventually wear off.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.82 1999/01/18 22:12:16 mud Exp $ */
d2676 1
d2744 4
d2752 1
d2768 1
d2771 2
a2772 1
 
d2829 1
@


1.82
log
@Added kr for non-clan IMM's.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.81 1999/01/18 16:56:46 mud Exp $ */
d2118 1
a2118 1
	sprintf( buf, "Approximate Attempts: %d  Kills: %d ", 
d2121 1
a2121 1
	if( ch->pcdata->outcT > 0 )
d2123 2
a2124 1
	  sprintf( buf, "Outcast Ticks Left: %d\n\r", ch->pcdata->outcT);
@


1.81
log
@Added last_kill to pcdata to keep from getting a KILLER by spam
killing the same person.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.80 1999/01/05 18:31:56 mud Exp $ */
d3408 1
a3408 1
  if(IS_NPC(ch) || !is_clan(ch))
@


1.80
log
@No more double CODER lines in who lists.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.79 1999/01/02 18:12:08 mud Exp $ */
d3411 2
a3412 1
  sprintf( buf, "You have approximately %d attempts and %d kills.\n\r",
d3414 1
a3414 1
		ch->killer_data[PC_KILLS]);
d3418 3
a3420 2
		"approximately %d attempts.'\n\r",
		ch->killer_data[PC_KILLS], ch->killer_data[PC_ATTACKS]/2);
@


1.79
log
@Fixed CODER line not showing up in do_who()
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.78 1999/01/02 17:41:28 mud Exp $ */
d2673 1
d2835 1
a2835 1
      && nMatch > 0 && !fClan )
d2839 1
@


1.78
log
@DISP_CODER to move those with the CODER bit set up in the who list.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.77 1998/12/29 23:54:24 mud Exp $ */
d2832 2
a2833 1
      && (wch->level == level-1 && IS_SET(wch->display,DISP_CODER))
@


1.77
log
@Made some mod's to rogues.
Rremoved check in do_where
changed is_safe_steal to is_safe in do_steal and do_slice
removed wait_state reduction for rogues in steal and slice
added check to give infiltrating rogues a THIEF flag if attacked in a foreign clan hall

Rob.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.76 1998/12/23 16:51:28 mud Exp $ */
d2807 4
a2810 1
  if (!can_see(ch,wch) || wch->level != level)
d2831 3
a2833 1
    if( level == MAX_LEVEL && nMatch > 0 && !fClan )
@


1.76
log
@Bunch of changes for rogues, including new skill and pther improvements
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.75 1998/12/13 22:54:56 mud Exp $ */
d3164 1
a3164 2
	    (number_percent() + (victim->level - ch->level)*2 )) 
       && ( victim->class != class_lookup("rogue") ) )
d3195 1
a3195 2
            (number_percent() + victim->level - ch->level)) 
       && (victim->class != class_lookup("rogue")) )
@


1.75
log
@ Lowbies can see kit info list
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.74 1998/12/13 22:06:23 mud Exp $ */
d3164 3
a3166 1
	    (number_percent() + (victim->level - ch->level)*2 )) )
d3196 3
a3198 1
            (number_percent() + victim->level - ch->level)) )
@


1.74
log
@SOme changed
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.73 1998/12/09 08:32:15 mud Exp $ */
a600 6
   if ( ch->level < 10 )
   {
       send_to_char("You must reach level 10 to take a kit.\n\r",ch);
       return;
   }

d612 6
@


1.73
log
@Re-reclassing.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.72 1998/12/09 01:23:21 mud Exp $ */
a2306 2
     if ( ch->level >= 10 )
     {
a2309 1
     }
@


1.72
log
@More bug fixes
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.71 1998/12/09 01:20:36 mud Exp $ */
d600 6
@


1.71
log
@Bug fixes
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.70 1998/12/08 22:38:11 mud Exp $ */
d2309 1
a2309 1
    if ( ch->alignment >  900 ) send_to_char( "an angelic.\n\r", ch );
@


1.70
log
@Fixed some bugs
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.69 1998/12/08 06:03:37 mud Exp $ */
d619 6
d2309 1
a2309 1
    if ( ch->alignment >  900 ) send_to_char( "angelic.\n\r", ch );
@


1.69
log
@Fixed all bug
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.68 1998/12/08 03:40:29 mud Exp $ */
d663 1
a663 1
       int i, fQualify = FALSE;
a683 1
		if ( ch->class == i ) fQualify = FALSE;
a702 1
	       if ( ch->race == i ) fQualify = FALSE;
d742 4
a745 1
	if ( !fQualify )
d747 9
@


1.68
log
@*** empty log message ***
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.67 1998/12/08 03:19:41 mud Exp $ */
a695 3
	if ( kit_table[kit].race[0] )
	    send_to_char("all",ch);
	else
@


1.67
log
@Bug fixes
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.66 1998/12/08 01:54:09 mud Exp $ */
d696 4
a699 1
	for ( i = 0 ; i < MAX_PC_RACE ; i++ )
d710 1
@


1.66
log
@barbarians are done
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.65 1998/12/07 12:58:16 mud Exp $ */
d670 2
a671 1
	       
d675 1
a675 1
	send_to_char("{WClasses{x  ", ch ); 
d693 1
a698 1
	       cbuf[0] = '\0';
@


1.65
log
@Save code for kitds
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.64 1998/12/06 07:40:40 mud Exp $ */
d626 6
d674 1
a674 1
	send_to_char("{WAvailable to:{x ",ch);
d693 1
@


1.64
log
@STUFF!
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.63 1998/12/05 22:32:20 mud Exp $ */
d594 1
d596 1
d672 2
a673 3
		if ( i == ch->class ) fQualify = TRUE;
		send_to_char( class_table[i].name, ch );
		send_to_char( " ", ch );
d675 29
d736 1
a736 1
	    send_to_char("\n\r{RNOTICE:{x Your class cannot take this kit.",ch);
@


1.63
log
@handful of changes
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.62 1998/12/05 22:05:58 mud Exp $ */
d2248 1
a2248 1
   sprintf( buf, "Alignment: %d   Sac Points: %d", ch->alignment, 
d2265 1
a2265 1
     sprintf(buf,"follower of %s.", IS_NPC(ch) ? "yourself." :
@


1.62
log
@More stuff
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.61 1998/12/05 21:44:02 mud Exp $ */
d2029 1
a2029 1
     sprintf(buf, "Race: %s  Sex: %s  Class: %s %s  Deity: %s (%d)\n\r",
d2036 1
a2036 1
   IS_NPC(ch) ? "none" : deity_table[ch->pcdata->deity].pname, ch->pcdata->sac);
d2248 2
a2249 1
   sprintf( buf, "Alignment: %d.  ", ch->alignment );
d2255 14
a2268 9
     else if ( ch->alignment >  700 ) send_to_char( "saintly.\n\r", ch );
     else if ( ch->alignment >  350 ) send_to_char( "good.\n\r",    ch );
     else if ( ch->alignment >  100 ) send_to_char( "kind.\n\r",    ch );
     else if ( ch->alignment > -100 ) send_to_char( "neutral.\n\r", ch );
     else if ( ch->alignment > -350 ) send_to_char( "mean.\n\r",    ch );
     else if ( ch->alignment > -700 ) send_to_char( "evil.\n\r",    ch );
     else if ( ch->alignment > -900 ) send_to_char( "demonic.\n\r", ch );
     else                             send_to_char( "satanic.\n\r", ch );
 
d2555 2
a2556 1
      sprintf(buf, "[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r{x",
d2856 2
a2857 1
  sprintf( buf, "[%2d %6s %s]%s%s%s%s%s%s%s%s%s%s%s\n\r{x",
@


1.61
log
@Kits!
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.60 1998/12/05 10:16:51 mud Exp $ */
d697 4
a700 1
		send_to_char(kit_table[kit].skills[i], ch );
d703 1
a703 1
	    send_to_char("\n\r{RNOTICE:{x This kit is not complete."
@


1.60
log
@MORE BUG FIXES!!
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.59 1998/12/05 10:10:48 mud Exp $ */
d607 46
d699 3
d703 3
a705 1
	    send_to_char("\n\r{RNOTICE:{x Your class cannot take this kit.\n\r",ch);
@


1.59
log
@Fixing bugs
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.58 1998/12/05 09:50:17 mud Exp $ */
d626 1
d644 1
a644 1
		sprintf(buf2,"{G%d{x", kit_table[kit].min_stat[i] );
@


1.58
log
@Kit stuff
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.57 1998/11/29 22:26:19 mud Exp $ */
d611 1
a611 1
       if ( ( kit = kit_lookup("arg2") ) < 0 )
@


1.57
log
@Neat crusader stuff
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.56 1998/11/29 05:19:23 mud Exp $ */
d588 73
@


1.56
log
@Fixed stuff
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.55 1998/11/24 05:29:00 mud Exp $ */
d3270 2
a3271 2
  sprintf( buf, "%s%-18s%s %3d%%  ",
     ch->pcdata->learned[sn] != ch->pcdata->last_learned[sn] ? BOLD RED :  "",
a3272 1
     NORMAL,
@


1.55
log
@Dual wield
startof it anyway
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.54 1998/11/22 08:04:40 mud Exp $ */
d275 1
a275 1
	strcat( buf, "({MPInk Aura{x) " );
@


1.54
log
@Infiltrate coded.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.53 1998/11/21 00:13:42 mud Exp $ */
d68 2
a69 1
 };
@


1.53
log
@bug fix vor {
:
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.52 1998/11/20 04:01:17 mud Exp $ */
d1777 1
@


1.52
log
@extra quote removed
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.51 1998/11/20 03:59:51 mud Exp $ */
d2400 1
a2400 1
    sprintf(buf, "[%s] %s%s%s%s%s%s%s%s%s%s%s\n\r",
d2419 1
a2419 1
      sprintf(buf, "[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r",
d2700 1
a2700 1
    sprintf(buf,  "[%s] %s%s%s%s%s%s%s%s%s%s%s\n\r",
d2719 1
a2719 1
  sprintf( buf, "[%2d %6s %s]%s%s%s%s%s%s%s%s%s%s%s\n\r",
@


1.51
log
@Fixed RED for color off in Red Aura on obj.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.50 1998/11/19 22:31:19 mud Exp $ */
d103 1
a103 1
	strcat( buf, "({RRed Aura{x") "  );
d2539 1
a2539 1
          if (iClan)
d2626 5
a2630 1
 
@


1.50
log
@Fixed some color problems
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.49 1998/11/19 09:06:00 mud Exp $ */
d103 1
a103 1
	strcat( buf, "(" RED "Red Aura" NORMAL ") "  );
@


1.49
log
@added color
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.48 1998/11/18 02:17:47 mud Exp $ */
d283 1
a283 1
	strcat( buf, "{WWhite Aura{x) " );
d1385 1
a1385 1
   sprintf(buf,"%s%s%s",   BOLD CYAN,  ch->in_room->name, NORMAL);
d1766 1
a1766 1
   sprintf(buf,"[%sExits:" NORMAL,BOLD WHITE);
d1768 1
a1768 1
   sprintf(buf,"Obvious exits from room %d:\n\r",ch->in_room->vnum);
d1770 1
a1770 2
   sprintf(buf,"Obvious exits:\n\r");
   strcat( buf, GREEN );
d1812 1
a1812 1
   strcat( buf, NORMAL "]\n\r" );
d1815 1
a1815 1
     send_to_char( NORMAL, ch );
d2394 1
a2394 1
    sprintf(incog,"(Incog@@%d) ", wch->incog_level);
d2398 1
a2398 1
    sprintf(wizi,"(Wizi@@%d) ", wch->invis_level);
d2690 1
a2690 1
    sprintf(incog,"(Incog@@%d) ", wch->incog_level );
d2694 1
a2694 1
    sprintf(wizi,"(Wizi@@%d) ", wch->invis_level );
@


1.48
log
@wound transfer and more color
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.47 1998/11/18 02:07:34 mud Exp $ */
d106 1
a106 1
	strcat(buf,"(" BOLD BLUE "Blue Aura" NORMAL ") " );
d110 1
a110 1
	strcat( buf, "(" BOLD WHITE "Glowing" NORMAL ") "   );
d267 1
a267 1
     if ( IS_SET(victim->comm,COMM_AFK     )   ) strcat( buf, "[AFK] "        );
d274 1
a274 1
	strcat( buf, "(" MAGENTA "Pink Aura" NORMAL ") "  );
d278 1
a278 1
	strcat( buf, "(" RED "Red Aura" NORMAL ") "   );
d281 1
a281 1
	strcat( buf, "(" BOLD YELLOW "Golden Aura" NORMAL ") ");
d283 1
a283 1
	strcat( buf, "(" BOLD WHITE "White Aura" NORMAL ") " );
d285 1
a285 1
             strcat( buf, "(KILLER) "     );
d288 1
a288 1
             strcat( buf, "(THUG) "     );
d291 1
a291 1
             strcat( buf, "(RUFFIAN) "     );
d293 1
a293 1
             strcat( buf, "(THIEF) "      );
d295 1
a295 1
             strcat( buf, "(DWEEB) ");
d2407 1
a2407 1
           IS_SET(wch->comm, COMM_AFK) ? "[AFK] " : "",
d2411 4
a2414 4
           (IS_SET(wch->act,PLR_KILLER) ? "(K) " : "(Th) ") : 
		(IS_SET(wch->act,PLR_KILLER) ? "(K) " : 
			(IS_SET(wch->wiznet,PLR_RUFFIAN) ? "(R) ":"") ),
           IS_SET(wch->act,PLR_THIEF) ? "(Tf) " : "",
d2429 1
a2429 1
       IS_SET(wch->comm, COMM_AFK) ? "[AFK] " : "",
d2432 4
a2435 4
           (IS_SET(wch->act,PLR_KILLER) ? "(K) " : "(Th) ") :
		(IS_SET(wch->act,PLR_KILLER) ? "(K) " : 
			(IS_SET(wch->wiznet,PLR_RUFFIAN) ? "(R) ":"") ),
             IS_SET(wch->act,PLR_THIEF) ? "(Tf) " : "",
d2703 1
a2703 1
             IS_SET(wch->comm, COMM_AFK) ? "[AFK] " : "",
d2707 4
a2710 4
           (IS_SET(wch->act,PLR_KILLER) ? "(K) " : "(Th) ") :
		(IS_SET(wch->act,PLR_KILLER) ? "(K) " : 
			(IS_SET(wch->wiznet,PLR_RUFFIAN) ? "(R) ":"") ),
             IS_SET(wch->act,PLR_THIEF) ? "(Tf) " : "",
d2727 1
a2727 1
      IS_SET(wch->comm, COMM_AFK) ? "[AFK] " : "",
d2730 4
a2733 4
           (IS_SET(wch->act,PLR_KILLER) ? "(K) " : "(Th) ") :
		(IS_SET(wch->act,PLR_KILLER) ? "(K) " : 
			(IS_SET(wch->wiznet,PLR_RUFFIAN) ? "(R) ":"") ),
            IS_SET(wch->act, PLR_THIEF)  ? "(Tf) "  : "",
@


1.47
log
@Color added
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.46 1998/11/18 01:41:22 mud Exp $ */
d1771 1
a1771 1
   send_to_char( GREEN, ch ); 
@


1.46
log
@added some color
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.45 1998/11/17 23:30:41 mud Exp $ */
d102 2
a103 1
    && IS_OBJ_STAT(obj, ITEM_EVIL)   )   strcat( buf, "(Red Aura) "  );
d105 2
a106 1
     &&  IS_OBJ_STAT(obj,ITEM_BLESS))          strcat(buf,"(Blue Aura) " );
d109 2
a110 1
     if ( IS_OBJ_STAT(obj, ITEM_GLOW)      )   strcat( buf, "(Glowing) "   );
d273 2
a274 1
     if ( IS_AFFECTED(victim, AFF_FAERIE_FIRE) ) strcat( buf, "(Pink Aura) "  );
d277 2
a278 1
     &&   IS_AFFECTED(ch, AFF_DETECT_ALIGN)     ) strcat( buf, "(Red Aura) "   );
d280 4
a283 2
     &&   IS_AFFECTED(ch, AFF_DETECT_ALIGN)     ) strcat( buf, "(Golden Aura) ");
     if ( IS_AFFECTED(victim, AFF_SANCTUARY)   ) strcat( buf, "(White Aura) " );
d1766 1
a1766 1
   sprintf(buf,"[Exits:");
d1771 1
a1771 1
 
d1813 1
a1813 1
   strcat( buf, "]\n\r" );
d1816 1
@


1.45
log
@More bugs fixing
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.44 1998/11/17 23:20:08 mud Exp $ */
d1378 2
a1379 1
   send_to_char( ch->in_room->name, ch );
@


1.44
log
@Hopefully fixed the wholist and also added outcast changes
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.43 1998/11/15 09:40:26 mud Exp $ */
d2613 1
a2613 1
  || ( fClanRestrict && !rgfClan[wch->clan])
a2615 2
  || !( fClanRestrict && rgfClan[clan_lookup("loner")] &&
       clan_table[wch->clan].hidden && !is_same_clan(wch,ch))
@


1.43
log
@Final avarice/hidden clan change done
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.42 1998/11/15 09:29:33 mud Exp $ */
d2613 6
a2618 1
  || ( fClanRestrict && !rgfClan[wch->clan]))
@


1.42
log
@minor bug fix.  aeshteic thing
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.41 1998/11/15 02:24:46 mud Exp $ */
d2346 4
a2349 1
	sprintf(cbuf,"[ Loner ");
d2654 4
a2657 1
        sprintf(cbuf,"[ Loner ");
@


1.41
log
@more hidden clan flag stuff
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.40 1998/11/15 02:04:07 mud Exp $ */
d2343 1
a2343 1
    sprintf(cbuf,clan_table[wch->clan].name);
d2648 1
a2648 1
    sprintf(cbuf,clan_table[wch->clan].name);
@


1.40
log
@Avarice stuff
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.39 1998/10/17 07:12:10 mud Exp $ */
d2344 2
a2345 1
    if ( clan_table[wch->clan].hidden && !is_same_clan(wch,ch) )
d2649 2
a2650 1
    if(clan_table[wch->clan].hidden&&!is_same_clan(wch,ch))
@


1.39
log
@New reclass stuff
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.38 1998/10/17 02:56:08 mud Exp $ */
d2305 1
a2305 1
    char buf[MAX_STRING_LENGTH], sbuf[MAX_STRING_LENGTH];
d2335 1
d2343 4
d2392 1
a2392 1
           clan_table[wch->clan].who_name,
d2414 1
a2414 1
       clan_table[wch->clan].who_name,
d2447 1
a2447 1
    char sbuf[MAX_STRING_LENGTH];
d2647 4
d2681 2
a2682 2
           clan_table[wch->clan].who_name,
           sbuf[0] != '\0' ? sbuf : "",
d2705 1
a2705 1
      clan_table[wch->clan].who_name,
@


1.38
log
@Attribute say
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.37 1998/10/13 04:13:27 mud Exp $ */
d1878 1
a1878 1
   "You are %s%s, level %d, %d years old (%d hours).\n\r",
a1879 1
   IS_NPC(ch) ? "" : ch->pcdata->title,
d1883 1
a1883 1
 
d1891 1
a1891 1
     sprintf(buf, "Race: %s  Sex: %s  Class: %s  Deity: %s (%d)\n\r",
d1894 3
d1908 3
a1910 1
 
d1915 2
a1916 1
 
@


1.37
log
@Few changes
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.36 1998/10/12 23:29:05 mud Exp $ */
a1837 1
    send_to_char("Your attributes are:\n\r",ch);
a1849 1
     send_to_char( buf, ch );
d1851 18
@


1.36
log
@All bugs cleard.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.35 1998/10/12 22:05:20 mud Exp $ */
d2671 2
a2672 1
      (IS_SET(wch->act,PLR_CANCLAN) && IS_IMMORTAL(ch) ) ? "*" : " ", 
@


1.35
log
@More bug fixing
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.34 1998/10/12 21:46:07 mud Exp $ */
d2647 1
a2647 1
    sprintf(buf, "[%s]%s%s%s%s%s%s%s%s%s%s%s%s\n\r",
a2648 1
      (IS_SET(wch->act,PLR_CANCLAN) && IS_IMMORTAL(ch) ) ? "*" : " ",
d2666 1
a2666 1
  sprintf( buf, "[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r",
d2671 1
@


1.34
log
@Fixed bugs
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.33 1998/10/12 20:41:01 mud Exp $ */
d2649 1
a2649 3
      (IS_SET(wch->act,PLR_CANCLAN)&&
       IS_IMMORTAL(ch)&&
       wch->level < 25) ? "*" : " ",
@


1.33
log
@AAdded wholist *
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.32 1998/10/12 07:28:52 mud Exp $ */
d2649 1
a2649 2
      (IS_SET(wch->act,PLR_RECLASS)&&
       IS_SET(wch->act,PLR_CANCLAN)&&
@


1.32
log
@Nottil imped
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.31 1998/10/11 05:22:23 mud Exp $ */
d2647 1
a2647 1
    sprintf(buf, "[%s] %s%s%s%s%s%s%s%s%s%s%s\n\r",
d2649 4
@


1.31
log
@Added concealed and secret doors.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.30 1998/10/08 14:14:23 mud Exp $ */
d3043 7
a3049 1
 
@


1.30
log
@Added timers to being an Outcast.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.29 1998/10/06 22:18:53 mud Exp $ */
d1770 3
a1772 1
   &&   !IS_SET(pexit->exit_info, EX_CLOSED) )
@


1.29
log
@Fixed a lost carriage return in score.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.28 1998/10/05 05:05:57 mud Exp $ */
d1896 1
a1896 1
	sprintf( buf, "Approximate Attempts: %d  Kills: %d\n\r", 
d1899 9
@


1.28
log
@C

Dbite changed to 2 rounds
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.27 1998/10/05 04:56:43 mud Exp $ */
d1896 1
a1896 1
	sprintf( buf, "Approximate Attempts: %d  Kills: %d  ",
@


1.27
log
@C

Replaced healing with communion in cleric default
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.26 1998/10/05 04:18:49 mud Exp $ */
d3133 1
a3133 2
  sprintf( buf, "You have approximately %d attempts, %d kills and have died %d"
		" times at the hands of others.\n\n", 
d3135 1
a3135 1
		ch->killer_data[PC_KILLS], ch->killer_data[PC_DEATHS]);
d3139 2
a3140 3
		"approximately %d attempts and died %d times to others.'",
		ch->killer_data[PC_KILLS], ch->killer_data[PC_ATTACKS]/2,
		ch->killer_data[PC_DEATHS]);
@


1.26
log
@C

Changes to 'where'
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.25 1998/09/10 23:27:07 mud Exp $ */
d1896 2
a1897 3
	sprintf( buf, "Approximate Attempts: %d  Kills: %d  Deaths: %d\n\r",
		ch->killer_data[PC_ATTACKS]/2, ch->killer_data[PC_KILLS],
		ch->killer_data[PC_DEATHS]);
@


1.25
log
@changed brief toggle checks to use str_prefix instead of str_cmp
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.24 1998/08/30 03:59:56 mud Exp $ */
d2901 1
@


1.24
log
@Fixed a bug with longeq, fixed the log type for the 'display' comomand.

-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.23 1998/08/30 03:33:32 mud Exp $ */
d1039 1
a1039 1
     if ( !str_cmp(arg,"combat") )
d1042 1
a1042 1
     if ( !str_cmp(arg,"wholist") )
d1045 1
a1045 1
     if ( !str_cmp(arg,"longeq") )
@


1.23
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.22 1998/08/30 01:19:51 mud Exp $ */
d1217 1
a1217 1
        if (IS_SET(ch->display,DISP_BRIEF_EQLIST))
@


1.22
log
@Just made the red thing bold for skill improvement.  Mostly to see
if I've got CVS down pat yet.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.21 1998/08/21 14:21:07 mud Exp $ */
d121 1
a121 1
     if (IS_IMMORTAL (ch) && IS_SET (ch->comm,COMM_DISP_VNUM)) {
d181 1
a181 1
       if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
d221 1
a221 1
   if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
d240 1
a240 1
   if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
d290 1
a290 1
     if (IS_IMMORTAL (ch) && IS_SET (ch->comm,COMM_DISP_VNUM)) {
d307 1
a307 1
     if ( !IS_NPC(victim) && !IS_SET(ch->comm, COMM_BRIEF) 
d474 1
a474 1
     if (IS_IMMORTAL (ch) && IS_SET (ch->comm,COMM_DISP_VNUM)) {
d745 25
d771 3
d841 1
a841 1
     if (IS_SET(ch->comm,COMM_COMPACT))
d847 1
a847 1
     if (IS_SET(ch->comm,COMM_PROMPT))
d861 1
a861 1
     if (IS_SET (ch->comm,COMM_DISP_VNUM)) 
d868 1
a868 1
     if (IS_SET(ch->comm,COMM_COMBINE))
d1034 16
a1049 5
     if (IS_SET(ch->comm,COMM_BRIEF))
     {
       send_to_char("Full descriptions activated.\n\r",ch);
       REMOVE_BIT(ch->comm,COMM_BRIEF);
     }
d1051 4
a1054 4
     {
       send_to_char("Short descriptions activated.\n\r",ch);
       SET_BIT(ch->comm,COMM_BRIEF);
     }
d1059 1
a1059 1
     if (IS_SET(ch->comm,COMM_COMPACT))
d1062 1
a1062 1
       REMOVE_BIT(ch->comm,COMM_COMPACT);
d1067 1
a1067 1
       SET_BIT(ch->comm,COMM_COMPACT);
d1073 1
a1073 1
     if (IS_SET(ch->comm,COMM_SHOW_AFFECTS))
d1076 1
a1076 1
       REMOVE_BIT(ch->comm,COMM_SHOW_AFFECTS);
d1081 1
a1081 1
       SET_BIT(ch->comm,COMM_SHOW_AFFECTS);
d1091 1
a1091 1
   if (IS_SET(ch->comm,COMM_PROMPT))
d1094 1
a1094 1
       REMOVE_BIT(ch->comm,COMM_PROMPT);
d1099 1
a1099 1
       SET_BIT(ch->comm,COMM_PROMPT);
d1126 1
a1126 1
     if (IS_SET(ch->comm,COMM_COMBINE))
d1129 1
a1129 1
       REMOVE_BIT(ch->comm,COMM_COMBINE);
d1134 1
a1134 1
       SET_BIT(ch->comm,COMM_COMBINE);
d1217 1
a1217 1
        if (IS_SET(ch->act,PLR_LONGEQ))
d1220 1
a1220 1
         REMOVE_BIT(ch->act,PLR_LONGEQ);
d1225 1
a1225 1
         SET_BIT(ch->act,PLR_LONGEQ);
d1380 1
a1380 1
   if (IS_IMMORTAL (ch) && IS_SET (ch->comm,COMM_DISP_VNUM)) {
d1390 1
a1390 1
   || ( !IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF) ) )
d1535 1
a1535 1
           if (IS_IMMORTAL (ch) && IS_SET(ch->comm,COMM_DISP_VNUM)) {
d1651 2
a1652 2
      temp_brief = IS_SET(ch->comm, COMM_BRIEF);
      SET_BIT(ch->comm,COMM_BRIEF);
d1661 1
a1661 1
      if (!temp_brief) REMOVE_BIT (ch->comm,COMM_BRIEF);
d1787 1
a1787 1
     if (IS_IMMORTAL (ch) && IS_SET (ch->comm,COMM_DISP_VNUM)) {
d2094 1
a2094 1
     if (IS_SET(ch->comm,COMM_SHOW_AFFECTS))
d2344 1
a2344 1
    IS_SET(ch->comm,COMM_BRIEF) ?
d2348 1
a2348 1
    IS_SET(ch->comm,COMM_BRIEF) ?
d2629 1
a2629 1
    IS_SET(ch->comm,COMM_BRIEF) ?
d2633 1
a2633 1
    IS_SET(ch->comm,COMM_BRIEF) ?
d2731 1
a2731 1
	if(!IS_NPC(ch) && IS_SET(ch->act,PLR_LONGEQ))
@


1.21
log
@I dunno
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.20 1998/08/21 00:52:13 mud Exp $ */
d3160 1
a3160 1
     ch->pcdata->learned[sn] != ch->pcdata->last_learned[sn] ? RED : "",
@


1.20
log
@* Added a color thing to prac and skill  .. fluff.
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.19 1998/08/20 21:05:25 mud Exp $ */
d280 1
a280 1
	 && victim->pcdata->trumps > 0)
d283 1
a283 1
	&& !IS_SET(victim->act, PLR_KILLER) && victim->pcdata->trumps == 0 )
d2266 5
a2270 5
    if (!clan_table[wch->pcdata->clan].independent &&
	clan_table[wch->pcdata->clan].true_clan) sprintf(sbuf, "/%d] ", wch->pcdata->rank);
    if (clan_table[wch->pcdata->clan].independent 
	&& clan_table[wch->pcdata->clan].true_clan)  sprintf(sbuf, "] ");
    if ( wch->pcdata->clan && !is_clan(wch)) sprintf(sbuf," ");
d2317 1
a2317 1
           clan_table[wch->pcdata->clan].who_name,
d2322 1
a2322 1
	wch->pcdata->trumps > 0 ?
d2339 1
a2339 1
       clan_table[wch->pcdata->clan].who_name,
d2343 1
a2343 1
	wch->pcdata->trumps > 0 ?
d2534 1
a2534 1
  || ( fClanRestrict && !rgfClan[wch->pcdata->clan]))
d2566 1
a2566 1
    if (!clan_table[wch->pcdata->clan].independent &&
d2568 1
a2568 1
    if (clan_table[wch->pcdata->clan].independent 
d2570 1
a2570 1
    if (wch->pcdata->clan && !is_clan(wch) ) sprintf(sbuf," ");
d2602 1
a2602 1
           clan_table[wch->pcdata->clan].who_name,
d2607 1
a2607 1
	wch->pcdata->trumps > 0 ?
d2624 1
a2624 1
      clan_table[wch->pcdata->clan].who_name,
d2628 1
a2628 1
	wch->pcdata->trumps > 0 ?
@


1.19
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.18 1998/08/12 08:20:13 mud Exp $ */
d3159 5
a3163 2
  sprintf( buf, "%-18s %3d%%  ",
     skill_table[sn].name, ch->pcdata->learned[sn] );
d3167 1
@


1.18
log
@* Finished traps
* Rockbiters added
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.17 1998/08/10 19:41:19 mud Exp $ */
d280 1
a280 1
	 && victim->trumps > 0)
d283 1
a283 1
	&& !IS_SET(victim->act, PLR_KILLER) && victim->trumps == 0 )
d1839 1
a1839 1
   IS_NPC(ch) ? "none" : deity_table[ch->deity].pname, ch->sac);
d2238 1
d2266 5
a2270 5
    if (!clan_table[wch->clan].independent &&
	clan_table[wch->clan].true_clan) sprintf(sbuf, "/%d] ", wch->rank);
    if (clan_table[wch->clan].independent 
	&& clan_table[wch->clan].true_clan)  sprintf(sbuf, "] ");
    if ( wch->clan && !is_clan(wch)) sprintf(sbuf," ");
d2303 10
a2312 1
    }             
d2315 3
a2317 3
           wch->incog_level >= LEVEL_HERO ? "(I) ": "",
           wch->invis_level >= LEVEL_HERO ? "(W) " : "",
           clan_table[wch->clan].who_name,
d2322 1
a2322 1
	wch->trumps > 0 ?
d2339 1
a2339 1
       clan_table[wch->clan].who_name,
d2343 1
a2343 1
	wch->trumps > 0 ?
d2391 2
a2392 1
 
d2534 1
a2534 1
  || ( fClanRestrict && !rgfClan[wch->clan]))
d2566 3
a2568 3
    if (!clan_table[wch->clan].independent &&
	is_clan(wch)) sprintf(sbuf, "/%d] ", wch->rank);
    if (clan_table[wch->clan].independent 
d2570 1
a2570 1
    if (wch->clan && !is_clan(wch) ) sprintf(sbuf," ");
d2588 10
a2597 1
    }             
d2600 3
a2602 3
           wch->incog_level >= LEVEL_HERO ? "(I) ": "",
           wch->invis_level >= LEVEL_HERO ? "(W) " : "",
           clan_table[wch->clan].who_name,
d2607 1
a2607 1
	wch->trumps > 0 ?
d2624 1
a2624 1
      clan_table[wch->clan].who_name,
d2628 1
a2628 1
	wch->trumps > 0 ?
d3138 2
a3139 2
     char buf[MAX_STRING_LENGTH];
     char buf2[MAX_STRING_LENGTH];
d3158 2
a3159 2
 
       sprintf( buf, "%-18s %3d%%  ",
d3168 1
a3168 1
 
@


1.17
log
@* Starter code for 'feign death'
* Protection neutral added
* Fixed bug with vampires
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.16 1998/08/05 09:52:29 mud Exp $ */
d1791 23
a1813 1
 
@


1.16
log
@* minor bug with practice fixed.
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.15 1998/08/05 09:14:31 mud Exp $ */
d549 1
a549 1
 
@


1.15
log
@* Removes shout, added a 'silence' command to stiffle game spam
* Added saves to score
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.14 1998/08/05 08:46:15 mud Exp $ */
d3181 1
a3181 3
       blah = (IS_SET(ch->act,PLR_WERE) || IS_SET(ch->act,PLR_VAMP)) 
	? abs(skill_table[sn].rating[ch->class])
	:skill_table[sn].rating[ch->class];
@


1.14
log
@* Few superficial changes, added decimal part of weight to ident
  spell

  -BEn
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.13 1998/08/05 08:14:33 mud Exp $ */
d1846 1
a1846 1
   can_carry_w(ch) / 10, get_carry_weight(ch) % 10  );
d1925 6
a1930 1
 
@


1.13
log
@* Added changing weights for warp
* Also added a ->warps field to objects ... the more you warp
  something the greater the chances of blowing it up.
  -Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.12 1998/08/05 07:30:29 mud Exp $ */
d1842 1
a1842 1
   "You are carrying %d.%d/%d.%d items with weight %ld.ld/%d.%d pounds.\n\r",
@


1.12
log
@* Gems are now 1/2 of an itme instead of a full item
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.11 1998/08/05 06:59:12 mud Exp $ */
d1842 5
a1846 6
   "You are carrying %d.%d/%d.%d items with weight %ld/%d pounds.\n\r",
   ch->carry_number / 10,
   ch->carry_number % 10,
   can_carry_n(ch) /10,
   can_carry_n(ch) %10,
   get_carry_weight(ch) / 10, can_carry_w(ch) /10 );
@


1.11
log
@* Fire breath blind effect lowered to 0 ticks from 1
* Few minor aesthetic fixes in spells and eating code

-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.10 1998/08/04 17:21:34 mud Exp $ */
d1842 5
a1846 2
   "You are carrying %d/%d items with weight %ld/%d pounds.\n\r",
   ch->carry_number, can_carry_n(ch),
@


1.10
log
@* Changed level field to 2 spaces instead of 3
* Added nonote command
* Added a 'set hours' ability
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.9 1998/08/02 14:31:30 mud Exp $ */
d1877 12
a1888 3
 
     if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]   > 10 )
   send_to_char( "You are drunk.\n\r",   ch );
d1893 2
a1894 1
 
@


1.9
log
@typo fix
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.8 1998/08/02 14:30:34 mud Exp $ */
d2283 1
a2283 1
      sprintf(buf, "[%3d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r",
d2558 1
a2558 1
  sprintf( buf, "[%3d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r",
@


1.8
log
@Druid dodge, parry and shield block reductions
removal of nofollow cancelling charm and spell_charm_person() tweeked
to accomodate PC charmings.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.7 1998/08/01 13:46:04 mud Exp $ */
d1130 1
a1130 1
       if(!IS_AFFECTED(ch,AFF_CHARM)
@


1.7
log
@Added RUFFIAN flag logic
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.6 1998/07/29 06:23:37 mud Exp $ */
d1130 1
@


1.6
log
@used 'ch' instead of 'wch' in do_whois() and do_who().  Been a while since I had to work with this stuff.  -Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.5 1998/07/29 06:06:05 mud Exp $ */
d282 3
d2274 2
a2275 1
		(IS_SET(wch->act,PLR_KILLER) ? "(K) " : ""),
d2295 2
a2296 1
               (IS_SET(wch->act,PLR_KILLER) ? "(K) " : ""),
d2549 2
a2550 1
               (IS_SET(wch->act,PLR_KILLER) ? "(K) " : ""),
d2570 2
a2571 1
               (IS_SET(wch->act,PLR_KILLER) ? "(K) " : ""),
@


1.5
log
@Forgot to change whois AND who.  I'll be more thorough in the future, promise. -Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.4 1998/07/29 06:04:58 mud Exp $ */
d2226 1
a2226 1
    if ( ch->clan && !is_clan(ch)) sprintf(sbuf," ");
d2514 1
a2514 1
    if (ch->clan && !is_clan(ch) ) sprintf(sbuf," ");
@


1.4
log
@Few Aestheic things.  Due to the issue of ranks and the new flag, a bunch of rigged code needed to be slapped in to make it look all purty.  -Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.3 1998/06/18 14:18:30 mud Exp $ */
d2514 1
@


1.3
log
@Took out the double level for reclasses.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.2 1998/06/17 15:18:52 mud Exp $ */
d2222 2
a2223 1
    if (!clan_table[wch->clan].independent) sprintf(sbuf, "/%d] ", wch->rank);
d2225 2
a2226 1
	&& is_clan(wch)) sprintf(sbuf, "] ");
d2510 2
a2511 1
    if (!clan_table[wch->clan].independent) sprintf(sbuf, "/%d] ", wch->rank);
@


1.2
log
@Changed who and whois to have short () flags and Reclass levels.
@
text
@d18 1
a18 1
 /* @@(#)$Id: act_info.c,v 1.1 1998/06/16 17:49:13 mud Exp $ */
d2277 1
a2277 1
    wch->class < 4 ? wch->level : wch->level+51,
d2548 1
a2548 1
      wch->class < 4 ? wch->level : wch->level + 51,
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
 /* @@(#)$Id$ */
d2260 2
a2261 2
           wch->incog_level >= LEVEL_HERO ? "(Incog) ": "",
           wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
d2268 3
a2270 3
           (IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : "(THUG) ") : 
		(IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : ""),
           IS_SET(wch->act,PLR_THIEF) ? "(THIEF) " : "",
d2276 2
a2277 2
      sprintf(buf, "[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r",
    wch->level,
d2281 2
a2282 2
       wch->incog_level >= LEVEL_HERO ? "(Incog) ": "",
       wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
d2288 3
a2290 3
           (IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : "(THUG) ") :
               (IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : ""),
             IS_SET(wch->act,PLR_THIEF) ? "(THIEF) " : "",
d2531 2
a2532 2
           wch->incog_level >= LEVEL_HERO ? "(Incog) ": "",
           wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
d2539 3
a2541 3
           (IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : "(THUG) ") :
               (IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : ""),
             IS_SET(wch->act,PLR_THIEF) ? "(THIEF) " : "",
d2547 2
a2548 2
  sprintf( buf, "[%2d %6s %s] %s%s%s%s%s%s%s%s%s%s\n\r",
      wch->level,
d2552 2
a2553 2
      wch->incog_level >= LEVEL_HERO ? "(Incog) " : "",
      wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
d2559 3
a2561 3
           (IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : "(THUG) ") :
               (IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : ""),
            IS_SET(wch->act, PLR_THIEF)  ? "(THIEF) "  : "",
@
