head	1.190;
access;
symbols;
locks; strict;
comment	@ * @;


1.190
date	2004.10.31.03.32.07;	author boogums;	state Exp;
branches;
next	1.189;

1.189
date	2004.09.28.01.00.45;	author boogums;	state Exp;
branches;
next	1.188;

1.188
date	2003.05.25.17.41.44;	author boogums;	state Exp;
branches;
next	1.187;

1.187
date	2003.05.25.14.32.21;	author boogums;	state Exp;
branches;
next	1.186;

1.186
date	2003.05.25.01.34.22;	author boogums;	state Exp;
branches;
next	1.185;

1.185
date	2003.03.27.16.18.52;	author rusty;	state Exp;
branches;
next	1.184;

1.184
date	2003.03.09.21.44.27;	author boogums;	state Exp;
branches;
next	1.183;

1.183
date	2003.01.04.17.55.43;	author boogums;	state Exp;
branches;
next	1.182;

1.182
date	2003.01.03.19.41.52;	author boogums;	state Exp;
branches;
next	1.181;

1.181
date	2002.11.19.04.42.15;	author boogums;	state Exp;
branches;
next	1.180;

1.180
date	2002.11.12.03.04.59;	author boogums;	state Exp;
branches;
next	1.179;

1.179
date	2002.10.28.03.55.27;	author ndagger;	state Exp;
branches;
next	1.178;

1.178
date	2002.10.06.22.49.42;	author boogums;	state Exp;
branches;
next	1.177;

1.177
date	2002.10.05.16.23.55;	author boogums;	state Exp;
branches;
next	1.176;

1.176
date	2002.10.05.16.02.31;	author boogums;	state Exp;
branches;
next	1.175;

1.175
date	2002.05.21.20.20.58;	author rage;	state Exp;
branches;
next	1.174;

1.174
date	2002.04.17.15.11.53;	author poquah;	state Exp;
branches;
next	1.173;

1.173
date	2002.03.12.03.06.29;	author rusty;	state Exp;
branches;
next	1.172;

1.172
date	2002.03.11.04.38.40;	author rusty;	state Exp;
branches;
next	1.171;

1.171
date	2002.03.11.02.27.19;	author rusty;	state Exp;
branches;
next	1.170;

1.170
date	2002.03.09.19.14.26;	author rusty;	state Exp;
branches;
next	1.169;

1.169
date	2002.01.26.16.25.26;	author rage;	state Exp;
branches;
next	1.168;

1.168
date	2001.11.11.02.04.40;	author rage;	state Exp;
branches;
next	1.167;

1.167
date	2001.11.11.01.25.15;	author rage;	state Exp;
branches;
next	1.166;

1.166
date	2001.10.13.02.11.59;	author rage;	state Exp;
branches;
next	1.165;

1.165
date	2001.09.23.20.25.04;	author rage;	state Exp;
branches;
next	1.164;

1.164
date	2001.09.22.17.41.18;	author rage;	state Exp;
branches;
next	1.163;

1.163
date	2001.09.21.01.40.51;	author rage;	state Exp;
branches;
next	1.162;

1.162
date	2001.07.27.02.14.10;	author guerrand;	state Exp;
branches;
next	1.161;

1.161
date	2001.07.25.04.10.46;	author guerrand;	state Exp;
branches;
next	1.160;

1.160
date	2001.07.24.02.14.24;	author guerrand;	state Exp;
branches;
next	1.159;

1.159
date	2001.07.24.02.07.25;	author guerrand;	state Exp;
branches;
next	1.158;

1.158
date	2001.07.23.03.51.41;	author guerrand;	state Exp;
branches;
next	1.157;

1.157
date	2001.07.19.01.41.25;	author rage;	state Exp;
branches;
next	1.156;

1.156
date	2001.07.15.19.57.20;	author rage;	state Exp;
branches;
next	1.155;

1.155
date	2001.07.12.00.14.26;	author rage;	state Exp;
branches;
next	1.154;

1.154
date	2001.07.08.17.14.10;	author guerrand;	state Exp;
branches;
next	1.153;

1.153
date	2001.07.04.03.10.41;	author guerrand;	state Exp;
branches;
next	1.152;

1.152
date	2001.07.04.02.29.28;	author guerrand;	state Exp;
branches;
next	1.151;

1.151
date	2001.07.04.01.21.55;	author guerrand;	state Exp;
branches;
next	1.150;

1.150
date	2001.06.15.02.27.51;	author guerrand;	state Exp;
branches;
next	1.149;

1.149
date	2001.06.03.23.20.06;	author guerrand;	state Exp;
branches;
next	1.148;

1.148
date	2001.03.03.18.53.56;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	2001.02.10.03.25.21;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	2000.12.15.06.09.58;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	2000.12.14.04.49.09;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	2000.12.14.03.50.28;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	2000.12.12.20.43.20;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	2000.12.09.07.05.46;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	2000.12.07.06.45.43;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	2000.12.07.05.46.08;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	2000.12.03.19.12.07;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	2000.12.03.18.47.44;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	2000.12.03.17.50.29;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	2000.12.03.03.23.59;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	2000.10.12.23.12.37;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	2000.10.12.23.00.23;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	2000.10.12.22.58.46;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	2000.09.09.03.51.31;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	2000.09.04.05.40.45;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	2000.08.28.03.58.37;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	2000.08.27.23.23.05;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	2000.08.18.00.06.55;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	2000.08.17.14.29.27;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	2000.08.12.18.26.01;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	2000.07.12.23.31.30;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	2000.07.12.23.23.08;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	2000.07.11.23.26.43;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	2000.05.26.01.50.45;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	2000.05.26.01.46.24;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	2000.05.26.01.04.19;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	2000.05.25.23.47.28;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	2000.05.24.02.53.24;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	2000.05.23.04.55.40;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2000.05.23.04.12.37;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	2000.05.13.22.53.15;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	2000.04.21.23.08.25;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	2000.04.18.20.24.25;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	2000.04.18.19.50.51;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	2000.04.17.22.00.44;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	2000.04.17.20.15.24;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	2000.04.16.15.31.36;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	2000.04.03.20.19.55;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	2000.03.08.14.28.33;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	2000.03.07.15.40.12;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	2000.03.07.15.32.29;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	2000.02.28.05.34.37;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	2000.02.28.05.17.34;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2000.02.27.17.21.28;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2000.02.27.00.20.16;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2000.02.26.23.39.43;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2000.02.23.05.11.59;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2000.02.23.00.22.44;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	2000.02.22.23.45.57;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	2000.02.06.20.15.35;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	2000.01.21.01.06.13;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	2000.01.21.00.53.13;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	2000.01.08.08.05.12;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.12.19.22.02.29;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.12.19.21.57.02;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.11.30.22.32.19;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.11.30.01.32.38;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.11.30.01.12.55;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.11.26.19.56.12;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.11.25.04.12.24;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.11.25.04.11.43;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.11.25.04.02.01;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	99.11.25.01.58.33;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	99.11.25.01.57.27;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	99.11.25.01.28.05;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	99.11.24.07.37.14;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.11.24.07.20.45;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.11.24.07.19.18;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	99.11.24.07.10.30;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	99.11.24.07.01.57;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	99.11.24.06.29.40;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	99.11.24.06.00.13;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	99.11.24.05.43.47;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	99.11.24.05.39.39;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	99.11.24.05.05.31;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	99.11.24.05.03.13;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	99.11.24.01.31.01;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	99.11.24.01.25.24;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	99.11.19.05.41.16;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	99.10.07.01.48.00;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	99.10.05.20.06.54;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	99.10.02.00.09.05;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	99.09.21.22.49.35;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	99.09.18.21.46.39;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.09.06.20.40.33;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.09.02.03.43.10;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.09.02.03.18.50;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.09.01.22.12.14;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.08.28.16.34.25;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.08.23.03.34.40;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.08.12.01.03.54;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.08.11.05.38.44;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.08.11.04.55.48;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.08.11.02.29.37;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.08.10.23.02.58;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.08.10.23.00.54;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.08.09.22.08.25;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.07.21.01.13.25;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.07.14.18.13.26;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.06.28.06.34.16;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.06.17.15.36.08;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.06.12.18.51.41;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.05.28.12.07.03;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.05.28.10.14.31;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.05.27.12.21.07;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	99.05.16.21.36.43;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.05.15.16.39.00;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.04.25.17.25.49;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.04.23.23.43.37;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	99.04.18.02.38.29;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.04.18.00.12.41;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	99.04.17.23.20.07;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.04.17.22.46.22;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	99.04.17.09.27.12;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	99.04.13.02.27.33;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	99.04.13.02.20.09;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	99.04.08.22.48.08;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	99.01.11.19.37.32;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	99.01.11.19.31.03;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	99.01.11.19.28.08;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	99.01.11.19.23.12;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	99.01.07.18.51.17;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	99.01.03.01.19.06;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	99.01.02.17.39.52;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	99.01.01.19.00.05;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	99.01.01.17.27.08;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	99.01.01.17.20.56;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	99.01.01.17.18.17;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.12.31.21.25.53;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.12.31.18.26.00;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.12.28.19.55.58;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.12.23.16.51.29;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.12.09.08.32.15;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.11.22.10.36.33;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.11.22.08.04.40;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.11.22.02.05.11;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.10.23.14.07.27;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.10.11.05.22.24;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.10.05.09.10.24;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.20.21.05.26;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.17.20.04.57;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.13.05.24.07;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.12.08.20.14;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.07.20.19.53;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.13;	author mud;	state Exp;
branches;
next	;


desc
@@


1.190
log
@matooks can guild other matooks
dodrag now stops hall guards
corey
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: act_move.c,v 1.189 2004/09/28 01:00:45 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <stdio.h>
#include <string.h>
#include "merc.h"
#include "tables.h"
#include "gladiator.h"

/* command procedures needed */
DECLARE_DO_FUN(do_look    );
DECLARE_DO_FUN(do_recall  );
DECLARE_DO_FUN(do_stand   );

int clan_lookup   args( ( const char *name ) );
void recall args( (CHAR_DATA *ch, char *argument, bool fPray ) );
bool  has_boat args( ( CHAR_DATA *ch ) );
char	kludge_string[MAX_STRING_LENGTH];

char *  const dir_name  []    =
{
    "north", "east", "south", "west", "up", "down"
};

const sh_int  rev_dir   []    =
{
    2, 3, 0, 1, 5, 4
};

const sh_int  movement_loss [SECT_MAX]  =
{
    1, 2, 2, 3, 4, 6, 4, 1, 6, 10, 6
};



/*
 * Local functions.
 */
int find_door args( ( CHAR_DATA *ch, char *arg ) );
int find_exit args( ( CHAR_DATA *ch, char *arg ) );
bool  has_key   args( ( CHAR_DATA *ch, int key ) );

void do_fade( CHAR_DATA *ch, char *argument )
{
    if ( get_skill(ch,skill_lookup("fade")) < 25 ||
	!HAS_KIT(ch,"nethermancer") )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if ( ch->mana < 100 ) {
	send_to_char("You don't have enough mana.\n\r",ch);
	return;
    }

    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char("Gladiator's can not fade.\n\r",ch);
       return;
    }

    WAIT_STATE(ch,PULSE_VIOLENCE);
    if ( number_percent() < get_skill(ch,skill_lookup("fade")) / 2 )
    {
        if ( IS_SET( ch->mhs, MHS_FADE ) )
	{
	    REMOVE_BIT( ch->mhs, MHS_FADE );
	    act("$n fades into existence.",ch,NULL,NULL,TO_ROOM,FALSE);
	    act("You fade into existence.",ch,NULL,NULL,TO_CHAR,FALSE);
	}
	else
	{
	    SET_BIT(ch->mhs,MHS_FADE );
	    act("$n shimmers and fades away.",ch,NULL,NULL,TO_ROOM,FALSE);
	    act("You shimmer and fade away.",ch,NULL,NULL,TO_CHAR,FALSE);
  	}
	return;
    }

    send_to_char("You failed.\n\r",ch);
    return;
}


/* Mount code */
void do_mount( CHAR_DATA *ch, char *argument )
{
	CHAR_DATA *mount;
	char arg[MAX_INPUT_LENGTH];

	one_argument(argument,arg);

	if( is_affected(ch,skill_lookup("wraithform")) )
	{
	send_to_char("Not while in wraithform.\r\n",ch);
	return;
	}

        

	if(arg[0] == '\0')
	{
	    send_to_char("Ride what?\n\r",ch);
	    return;
	}


	if( ( mount = get_char_room(ch,arg) ) == NULL )
	{
	    send_to_char("They're not here.\n\r",ch);
	    return;
    	}

	if (mount->master != ch && !IS_IMMORTAL(ch))
	{
	  send_to_char("That's not your horse, and we hang horse thieves.\n\r",ch);
	  return;
	}

	if( (IS_NPC(mount) && !IS_SET(mount->act,ACT_MOUNT) ) ||
	    (!IS_NPC(mount) && !IS_SET(mount->mhs,MHS_MOUNT) ) )
	{
	    send_to_char("You can't ride that.\n\r",ch);
	    return;
	}

	if( !IS_NPC(mount) && IS_SET(mount->mhs,MHS_NOMOUNT) )
	{
	    act("$N isn't accepting riders.",ch,NULL,mount,TO_CHAR,FALSE);
	    return;
   	}

	if(mount->passenger != NULL)
	{
	    act("$N already has a rider.",ch,NULL,mount,TO_CHAR,FALSE);
	    return;
	}

	if(mount->riding != NULL)
	{
	    act("$N is occupied.",ch,NULL,mount,TO_CHAR,FALSE);
	    return;
	}

	if(ch->size > mount->size)
	{
	    send_to_char("You are too big to ride that.\n\r",ch);
	    return;
   	}

	ch->riding = mount;
	mount->passenger = ch;
	
	act("$n mounts $N.",ch,NULL,mount,TO_NOTVICT,FALSE);
	act("You mount $N.",ch,NULL,mount,TO_CHAR,FALSE);
	act("$n mounts you.",ch,NULL,mount,TO_VICT,FALSE);
	
	return;
}

void do_dismount( CHAR_DATA *ch, char *argument )
{
	CHAR_DATA *mount;

	if ( ( mount = ch->riding ) == NULL )
	{
	    send_to_char("You aren't riding anything.\n\r",ch);
	    return;
	}

	ch->riding = NULL;
	mount->passenger = NULL;

	act("You dismount.",ch,NULL,mount,TO_CHAR,FALSE);
	act("$n dismounts you.",ch,NULL,mount,TO_VICT,FALSE);
	act("$n dismounts from $N.",ch,NULL,mount,TO_NOTVICT,FALSE);

	return;
}


void move_char( CHAR_DATA *ch, int door, bool follow )
{
    CHAR_DATA *mount;
    CHAR_DATA *fch;
    CHAR_DATA *fch_next;
    ROOM_INDEX_DATA *in_room;
    ROOM_INDEX_DATA *to_room;
    EXIT_DATA *pexit;
    AFFECT_DATA *paf, *paf_next;
    OBJ_DATA *obj;
    bool found = FALSE;
    int swim = 0;
    int cost = 0;
    bool fHighlander = FALSE;
    bool slipsafe = TRUE;

    if ( is_affected(ch,gsn_trap) )
    {
	send_to_char("You are held fast by a snare trap.\n\r",ch);
	return;
    }
//COREY PUT THE WEATHER CHECK HERE
//#ifdef COREYTEST
    if ( !IS_IMMORTAL(ch) && !IS_NPC(ch) && IS_OUTSIDE(ch) )
	slipsafe = FALSE; 

    if ( ch->race != race_lookup("elf") 
    ||   ch->kit  != kit_lookup("ranger")
    ||   !IS_AFFECTED(ch, AFF_FLYING) 
       )
	slipsafe = TRUE;

    if ( slipsafe == FALSE && number_range(1,100) < 10 
       &&  weather_info.sky == SKY_RAINING )
    {
	if ( number_range(1,55) > get_curr_stat(ch,STAT_AGT) + get_curr_stat(ch,STAT_DEX) )
        {
	send_to_char("You slip and fall.  Damn Weather!",ch);
	return;
	}
    }

    if ( slipsafe == FALSE && number_range(1,100) < 15 
       &&  weather_info.sky == SKY_LIGHTNING )
    {
        if ( number_range(1,65) > get_curr_stat(ch,STAT_AGT) + get_curr_stat(ch,STAT_DEX) )
        {
        send_to_char("You slip and fall.  Damn Weather!",ch);
        return;
        }
    }


//#endif

    if ( is_affected(ch,skill_lookup("hold person")))
    {
	send_to_char("Your muscles are frozen!\n\r",ch);
	return;
    }
/*
    if ( is_affected(ch,gsn_earthbind) )
    {
	send_to_char("Your feet are bound to the earth.\n\r",ch);
	return;
    }
    */

  if ( is_affected(ch,gsn_hamstring) && number_percent() >
        ((get_curr_stat(ch,STAT_CON)*2)+(get_curr_stat(ch,STAT_STR*2))))
  {
	act("You try to move but your legs give out!",ch,NULL,NULL,TO_CHAR,FALSE);
	act("$n tries to move but $s legs give out!",ch,NULL,NULL,TO_ROOM,FALSE);
	return;
  }

  if(is_room_affected(ch->in_room, gsn_wall_ice))
	{
	AFFECT_DATA *paf;

        for(paf=ch->in_room->affected; paf != NULL; paf = paf->next)
	   if (paf->type == gsn_wall_ice)
              break;
        if(paf->location == door)
           {
           send_to_char("A wall of ice blocks that exit.\n\r", ch);
           return;
           }
        }

    mount = ch->riding;

    if ( door < 0 || door > 5 )
    {
  bug( "Do_move: bad door %d.", door );
  return;
    }

    in_room = ch->in_room;
   if ( ( pexit = in_room->exit[door] ) == NULL
      && !IS_NPC(ch) && IS_IMMORTAL(ch) &&
      IS_SET (ch->pcdata->edit.per_flags,EDIT_AUTO_CREATE) ) 
   {      
        if (create_room (ch,ch->in_room,door,TRUE))
          do_look( ch, "auto" );
        return;
   }
    

    in_room = ch->in_room;
    if ( ( pexit   = in_room->exit[door] ) == NULL
    ||   ( to_room = pexit->u1.to_room   ) == NULL 
    ||   ( !can_see_room(ch,to_room) ) )
    {    
  send_to_char( "Alas, you cannot go that way.\n\r", ch );
  return;
    }

   if (IS_SET(ch->mhs,MHS_HIGHLANDER))  
   {
      if (to_room->clan || is_room_owner(ch,to_room)
      || room_is_private(ch,to_room))
      {
         send_to_char("You are a Highlander, go out and fight, There can be only one!\n\r",ch);
         return;
      }
   }

   if (to_room->clan && ch->clan != to_room->clan && !IS_IMMORTAL(ch) )
   {
   /*
    if ( ch->move < 5 )
    {
        send_to_char( "You are too exhausted.\n\r", ch );
        return;
    }
       if ( is_clan(ch) && number_percent() < get_skill(ch, gsn_infiltrate)
       && (ch->pcdata && ch->pcdata->quit_time == 0) && !IS_IMMORTAL (ch))
       {
           if ( ch->move < 10 )
           {
              send_to_char( "You are too exhausted.\n\r", ch );
              return;
           }
	   cost += 5;
	   check_improve(ch,gsn_infiltrate,TRUE,2);
	   send_to_char("You infiltrate the clan hall.\n\r",ch);
       }
       else
       {
	   check_improve(ch,gsn_infiltrate,FALSE,4);
	   send_to_char("Alas, you cannot go that way.\n\r",ch);
	   return;
       }
     */ /* can't infiltrate clan halls */

	   send_to_char("Alas, you cannot go that way.\n\r",ch);
	   return;
   }

    /* Banishment gift from almighty */
     if ( ch->clan && IS_SET(ch->mhs, MHS_BANISH) &&
	 to_room->clan == ch->clan )
	 {
	 send_to_char("The force of the Almighty prevents you from entering your clan hall \n\r", ch);
	 return;
	 }

     /* Banished from clan hall by use of sanctions */
     if (!IS_NPC(ch) && ch->clan && IS_SET(ch->pcdata->clan_flags, CLAN_NO_HALL) &&
	to_room->clan == ch->clan)
	{
	send_to_char("You have been forbidden entrance to the clan hall.\n\r", ch);
	return;
	}


    if (IS_SET(pexit->exit_info, EX_CLOSED)
    &&  (!IS_AFFECTED(ch, AFF_PASS_DOOR) || IS_SET(pexit->exit_info,EX_NOPASS))
    &&   !IS_TRUSTED(ch,ANGEL) )
    {
  if ( IS_SET(pexit->exit_info, EX_SECRET) )
  	send_to_char( "Alas, you cannot go that way.\n\r", ch);
  else
  	act( "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR ,FALSE);
  return;
    }

    if ( IS_AFFECTED(ch, AFF_CHARM)
    &&   ch->master != NULL
    &&   in_room == ch->master->in_room )
    {
  send_to_char( "What?  And leave your beloved master?\n\r", ch );
  return;
    }


    if ( !is_room_owner(ch,to_room) && room_is_private(ch, to_room ) )
    {
        if ( ch->move < 10 )
        {
           send_to_char( "You are too exhausted.\n\r", ch );
           return;
        }
        if ( number_percent() < get_skill(ch,gsn_infiltrate)
	&& (ch->pcdata && ch->pcdata->quit_time == 0) && !IS_IMMORTAL (ch))
	{
	    cost += 5;
	    check_improve(ch,gsn_infiltrate,TRUE,2);
	    send_to_char("You infiltrate the room.\n\r",ch);
	}
        else
        {
  check_improve(ch,gsn_infiltrate,FALSE,4);
  send_to_char( "That room is private right now.\n\r", ch );
  return;
        }
    }

    if ( !IS_NPC(ch) )
    {
  int iClass, iGuild;
  int move, ok=FALSE, fRoom=FALSE;

  for ( iClass = 0; iClass < MAX_CLASS; iClass++ )
  {
      for ( iGuild = 0; iGuild < MAX_GUILD; iGuild ++)  
      {
	if ( (iClass == ch->class 
		|| (!IS_NPC(ch) && iClass == ch->pcdata->old_class))
	&& to_room->vnum == class_table[iClass].guild[iGuild] )
	{
	  ok = TRUE;
	  break;
	}
	if ( iClass != ch->class
	&& to_room->vnum == class_table[iClass].guild[iGuild] )
	{
	fRoom = TRUE;
        }
      }
  }

    /*    if ( number_percent() < get_skill(ch,gsn_infiltrate)
           &&  ( ok == FALSE  && fRoom == TRUE )
	   )
	{
	    cost += 5;
	    check_improve(ch,gsn_infiltrate,TRUE,2);
	    send_to_char("You infiltrate the guild. \n\r",ch);
	}
        else
        {
  check_improve(ch,gsn_infiltrate,FALSE,4);
   send_to_char( "You aren't allowed in there.\n\r", ch );
  return;
        } */


           if  ( ok == FALSE  && fRoom == TRUE )
	   {
           if ( ch->move < 10 )
           {
              send_to_char( "You are too exhausted.\n\r", ch );
              return;
           }
             if ( number_percent() < get_skill(ch,gsn_infiltrate) )
		{
		    cost += 5;
		    check_improve(ch,gsn_infiltrate,TRUE,2);
		    send_to_char("You infiltrate the guild. \n\r",ch);
		}
		else
		{
		  check_improve(ch,gsn_infiltrate,FALSE,4);
		   send_to_char( "You aren't allowed in there.\n\r", ch );
		  return;
		} 
            }

  if ( in_room->sector_type == SECT_AIR
  ||   to_room->sector_type == SECT_AIR )
  {
      if ( !IS_AFFECTED(ch, AFF_FLYING) && !IS_IMMORTAL(ch))
      {
    send_to_char( "You can't fly.\n\r", ch );
    return;
      }
  }

  if (( in_room->sector_type == SECT_WATER_NOSWIM
  ||    to_room->sector_type == SECT_WATER_NOSWIM )
    &&    !IS_AFFECTED(ch,AFF_FLYING))
  {
      found = has_boat(ch);

      if ( !found )
      {
    send_to_char( "You need a boat to go there.\n\r", ch );
    return;
      }
  }

  if ( get_carry_weight(ch) > can_carry_w(ch) )
	{
	found = FALSE;
	for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
	 {
	  if ( obj->item_type != ITEM_FOOD && can_drop_obj(ch,obj) 
		&& obj->wear_loc == WEAR_NONE )
		{
		act("{GYou drop $p to move unhindered.{x",ch,obj,NULL,TO_CHAR,FALSE);
		act("$n drops $p.",ch,obj,NULL,TO_ROOM,FALSE);
		obj_from_char(obj);
		obj_to_room(obj,ch->in_room);
		found = TRUE;
		}
	   if ( found ) break;
	  }
	}

  move = movement_loss[UMIN(SECT_MAX-1, in_room->sector_type)]
       + movement_loss[UMIN(SECT_MAX-1, to_room->sector_type)]
       ;

        move /= 2;  /* i.e. the average */

  /* conditional effects */
  if (IS_AFFECTED(ch,AFF_FLYING) || IS_AFFECTED(ch,AFF_HASTE))
      move /= 2;

  if (IS_AFFECTED(ch,AFF_SLOW))
      move *= 2;
     
    if ( is_affected(ch,gsn_earthbind) )
    {
	move +=  (ch->level /2)   ;
    }

  move += cost;

  if ( HAS_KIT(ch,"ranger") )
      move = UMIN(move,1);

  if ( !is_mounted(ch) && ch->move < move )
  {
      send_to_char( "You are too exhausted.\n\r", ch );
      return;
  }

  if ( is_mounted(ch) && ch->riding->move < move )
  {
      send_to_char("Your mount is exhausted.\n\r",ch);
      send_to_char("Your rider wishes you to move, but you are too tired.\n\r",ch->riding);
      return;
  }

  if (  in_room->sector_type == SECT_WATER_SWIM
     || to_room->sector_type == SECT_WATER_SWIM)
    {
	found = has_boat(ch);

        if (IS_SET(ch->mhs,MHS_HIGHLANDER))
	{
	   found = TRUE;
	}

	if( !found && !is_affected(ch,gsn_water_breathing) )
	{
	
	  swim = get_skill(ch,gsn_swim);

	 /*check swim skill % and do damage as necessary*/
         switch(check_immune(ch,DAM_DROWNING))
         {
	   case(IS_IMMUNE): swim = 102; break;
	   case(IS_RESISTANT): swim += swim/5; break;
	   case(IS_VULNERABLE): swim /= 2; break;
         }

	  if(number_percent() > swim-2)
	    {
	     send_to_char("You suck down some water while trying to swim.\n\r",
			  ch);
	     damage(ch,ch,(110 - swim)/6 + ch->level/3,gsn_swim,
			DAM_DROWNING,FALSE,TRUE);
	     check_improve(ch,gsn_swim,FALSE,8);
	    }
	  else
	    check_improve(ch,gsn_swim,TRUE,7);
	 }
     }

  WAIT_STATE( ch, IS_AFFECTED(ch,AFF_SLOW) ? 2 : 1 );
  if ( mount )
      mount->move -= apply_chi(mount,move);
  else
      ch->move -= apply_chi(ch,move);


  if ( IS_AFFECTED(ch,AFF_POISON) )
  { 
      send_to_char("The {gpoison{x courses through your blood.\n\r",ch);
      damage(ch,ch,UMAX(1,move * 3),gsn_poison,DAM_POISON,FALSE,TRUE);
  }

  if ( IS_AFFECTED(ch,AFF_PLAGUE) )
  {
      send_to_char("The {Gplague{x courses through your blood.\n\r",ch);
      ch->mana--; ch->move--;
  }

    }
    if ( !IS_AFFECTED(ch, AFF_SNEAK)
    &&   ch->invis_level < LEVEL_HERO)
    {
      if( swim == 0 )
      {
	 if ( is_mounted(ch) )
	 {
  act("$n leaves $t riding $N.",ch,dir_name[door],mount,TO_NOTVICT,FALSE);
	 }
	 else
	 if(IS_SET(ch->mhs,MHS_SHAPEMORPHED) || (IS_SET(ch->mhs,MHS_GLADIATOR)
	       && gladiator_info.blind == TRUE))
            act( "$l leaves $T.", ch, NULL, dir_name[door], TO_ROOM ,FALSE);
	 else
            act( "$n leaves $T.", ch, NULL, dir_name[door], TO_ROOM ,FALSE);
      }
         else
	 if(IS_SET(ch->mhs,MHS_SHAPEMORPHED) || (IS_SET(ch->mhs,MHS_GLADIATOR)
	       && gladiator_info.blind == TRUE))
            act( "$l swims $T.", ch, NULL, dir_name[door], TO_ROOM ,FALSE);
	 else
            act( "$n swims $T.", ch, NULL, dir_name[door], TO_ROOM ,FALSE);
    }

    if( IS_AFFECTED(ch, AFF_SNEAK) )
    {
      for ( fch = ch->in_room->people; fch != NULL; fch = fch_next )
      {
	fch_next = fch->next_in_room;

	if(IS_IMMORTAL(fch) && IS_SET(fch->act,PLR_HOLYLIGHT)
	   && can_see(fch,ch,FALSE))
	   act("$n sneaks $t.",ch, dir_name[door], fch, TO_VICT,FALSE);
      }
    }

    if (IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
       {
	  fch_next = fch->next_in_room;
	  if (IS_SET(fch->mhs,MHS_HIGHLANDER) && fch != ch)
	  {
	  fHighlander = TRUE;
	  send_to_char("The tingle in your neck stops and the presence of the other Highlander is gone.\n\r",fch);
	  }
       }
    }

    /*Ogre's Smell Remorts Leaving The Room */
    if (!IS_NPC(ch) && (IS_SET(ch->act,PLR_VAMP) ||
	                IS_SET(ch->act,PLR_MUMMY) ||
	                IS_SET(ch->act,PLR_WERE) ) )  
    {
       for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
       {
	  fch_next = fch->next_in_room;
	  if (fch->race == race_lookup("ogre") && fch != ch ) 
	  {
	     if (number_percent() < (fch->level + get_curr_stat(fch,STAT_CON))) 
	     {
	        if(IS_SET(ch->act,PLR_VAMP))
	           send_to_char("The strange odor of blood is gone.\n\r",fch);
	        if(IS_SET(ch->act,PLR_MUMMY))
	           send_to_char("The scent of decay is gone.\n\r",fch);
	        if(IS_SET(ch->act,PLR_WERE))
	           send_to_char("The smell of filthy fur is gone.\n\r",fch);
	     }
	  }
       }
    }


    if ( is_mounted(ch) )
    {
    char_from_room( mount );
    char_to_room( mount, to_room );
    do_look( mount, "auto" );
    }

    if (is_room_affected(in_room, gsn_wall_fire))
    {
	for ( paf = in_room->affected ; paf != NULL ; paf = paf_next )
   	{
          paf_next = paf->next;
	  if (paf->type == gsn_wall_fire) break;
        }
	
	if ( paf->level < ch->level + 8 )
	{
	  damage(ch,ch,dice(12,paf->level),0, DAM_FIRE, FALSE, FALSE);
	  act("$n is scorched by a wall of fire!", ch, NULL, NULL,TO_ROOM, FALSE);
	  act("You are scorched running through a wall of fire!", ch, NULL, NULL, TO_CHAR, FALSE);
	} 
    }
    char_from_room( ch );
    char_to_room( ch, to_room );

    if ( !IS_AFFECTED(ch, AFF_SNEAK)
    &&   ch->invis_level < LEVEL_HERO)
    {
       if ( is_mounted(ch) )
  act( "$n arrives riding $N.",ch,NULL,mount,TO_NOTVICT,FALSE);
	else
           if(IS_SET(ch->mhs,MHS_SHAPEMORPHED)
	      || (IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE))
              act( "$l has arrived.", ch, NULL, NULL, TO_ROOM ,FALSE);
	   else
              act( "$n has arrived.", ch, NULL, NULL, TO_ROOM ,FALSE);
    }

    if( IS_AFFECTED(ch, AFF_SNEAK) )
    {
      for ( fch = ch->in_room->people; fch != NULL; fch = fch_next )
      {
	fch_next = fch->next_in_room;

	if(IS_IMMORTAL(fch) && IS_SET(fch->act,PLR_HOLYLIGHT)
	   && can_see(fch,ch,FALSE))
	   act("$n sneaks into the room.",ch, NULL, fch, TO_VICT,FALSE);
      }
    }

   if ( is_affected(ch,gsn_fumble) )
      if ( number_percent() > (get_curr_stat(ch,STAT_DEX)*5) ) 
      {
	 act("$n trips and falls over!",ch,NULL,NULL,TO_ROOM,FALSE);
	 act("You trip and fall over.",ch,NULL,NULL,TO_CHAR,FALSE);
	 DAZE_STATE(ch,PULSE_PER_SECOND);
	 ch->position = POS_RESTING;
	 ch->move  = (UMAX(0,ch->move  - 5));
      }

   for ( fch = ch->in_room->people; fch != NULL; fch = fch_next )
    {
      fch_next = fch->next_in_room;

      if( is_affected(fch,skill_lookup("orb of awakening")) && !IS_AWAKE(fch) 
	  && !IS_AFFECTED(fch,AFF_SLEEP) && !IS_SET(fch->act,PLR_NOWAKE) )
       {
     act_new("$n sets off your orb.", ch,NULL,fch,TO_VICT,POS_SLEEPING,FALSE);
     do_stand(fch,"");
     blow_orb(fch,skill_lookup("orb of awakening"));
	}

      /*Ogre's Smell Remorts Entering The Room */
      if (fch->race == race_lookup("ogre") && fch != ch ) 
      {
	 if (number_percent() < (fch->level + get_curr_stat(fch,STAT_CON))) 
	 {
            if(IS_SET(ch->act,PLR_VAMP))
               send_to_char("The strange odor of blood makes you feel uncomfortable.\n\r",fch);
            if(IS_SET(ch->act,PLR_MUMMY))
               send_to_char("The scent of decay makes your head dizzy.\n\r",fch);
            if(IS_SET(ch->act,PLR_WERE))
               send_to_char("The smell of filthy fur fills up the air.\n\r",fch);
	 }
      }
     }

    do_look( ch, "auto" );

    if (in_room == to_room) /* no circular follows */
  return;

    if (IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       if (fHighlander)
       {
         send_to_char("The tingle in your neck stops and the presence of the other Highlander is gone.\n\r",ch);
         fHighlander = FALSE;
       }
       for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
       {
          fch_next = fch->next_in_room;
	  if (IS_SET(fch->mhs,MHS_HIGHLANDER) && ch != fch)
	  {
	     send_to_char("Your neck tingles as you feel the presence of another Highlander.\n\r",fch);
             fHighlander = TRUE;
	  }
       }
       if (fHighlander)
       {
          send_to_char("Your neck tingles as you feel the presence of another Highlander.\n\r",ch);
       }
    }

    for ( fch = in_room->people; fch != NULL; fch = fch_next )
    {
  fch_next = fch->next_in_room;

  if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM) 
  &&   fch->position < POS_STANDING)
      do_stand(fch,"");

  if ( fch->master == ch && fch->position == POS_STANDING 
  &&   can_see_room(fch,to_room)
  &&   is_room_clan(fch,to_room))
  {

      if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
      &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
      {
    act("You can't bring $N into the city.",
        ch,NULL,fch,TO_CHAR,FALSE);
    act("You aren't allowed in the city.",
        fch,NULL,NULL,TO_CHAR,FALSE);
    continue;
      }

    if ( IS_NPC(fch) && IS_SET(ch->in_room->room_flags,ROOM_NO_MOB) 
	&& IS_SET(ch->in_room->room_flags,ROOM_SAFE) )
        continue;
      act( "You follow $N.", fch, NULL, ch, TO_CHAR ,FALSE);
      move_char( fch, door, TRUE );
  }
    }

    return;
}

/*
 * Setting traps 
 *
 * Snares, Alarms, and Damage traps
 */
void do_trap( CHAR_DATA *ch, char *argument )
{
    AFFECT_DATA af;
    int chance, trap;
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;

    one_argument ( argument, arg );

    if ( ( chance = get_skill(ch,gsn_trap) ) == 0 
	|| ch->level < skill_level(ch,gsn_trap) )
    {
	send_to_char("You're trapped!\n\r",ch);
	return;
    }

    if ( ( obj = get_eq_char(ch,WEAR_HOLD) )   == NULL ||
	   obj->item_type != ITEM_TRAP )
    {
	send_to_char("You need something to make the trap with.\n\r",ch);
	return; 
    }

    if ( !IS_NPC(ch) && ch->pcdata->trap_timer > 0 )
    {
	send_to_char("You don't have time.\n\r",ch);
	return;
    }

    if ( ch->move - ( ch->level / 5 ) < 0 )
    {
	send_to_char("You are too exhausted.\n\r",ch);
	return;
    }

    /* a mob or a non clanner may not create traps */
    if ( IS_NPC(ch) || !is_clan(ch) )
      {
	send_to_char("You can't lay traps as a non-clanner.\n\r",ch);
	return;

      }

    if ( !str_cmp( arg, "snare" ) )
       trap = TRAP_SNARE;
    else
    if ( !str_cmp( arg, "alarm" ) )
       trap = TRAP_ALARM;
    else
    if ( !str_cmp( arg, "claw" ) )
       trap = TRAP_CLAW;
    else
    {
       send_to_char("Valid traps are: snare alarm claw\n\r",ch);
       return;
    }

    if ( check_trap( ch->in_room, trap ) )
    {
	send_to_char("That trap has already been set here.\n\r",ch);
	return;
    }

    af.where = TO_AFFECTS;
    af.type = gsn_trap;
    af.level = ch->level;
    af.location = trap; /* What kind of trap is it? */
    af.duration = number_range(ch->level/10, ch->level);
    af.modifier = obj->level;  /* level of trap */
    af.bitvector = 0;

    affect_to_room( ch->in_room, &af );
    ch->pcdata->trap_timer = number_percent( ) % 3;

    WAIT_STATE(ch,60);

    check_improve(ch,gsn_trap,TRUE,5);
    ch->move -= apply_chi( ch,ch->level /5);
    extract_obj( obj );
    send_to_char("Trap set.\n\r",ch);
    return;
}

void do_north( CHAR_DATA *ch, char *argument )
{
   if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 15) )
   {
   switch (number_range(0,9))
    {
    case 0:
    move_char ( ch, DIR_WEST, FALSE);
    break;
    case 1:
    move_char (ch, DIR_EAST, FALSE);
    break;
    case 2:
    move_char (ch, DIR_SOUTH, FALSE);
    break;
    case 3:
    move_char (ch, DIR_UP, FALSE);
    break;
    case 4: 
    move_char (ch, DIR_DOWN, FALSE);
    break;
    default:
    move_char( ch, DIR_NORTH, FALSE );
    }
  }
   else
    move_char( ch, DIR_NORTH, FALSE );
    
   return;
}



void do_east( CHAR_DATA *ch, char *argument )
{
    
  if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 15) )
   {
      switch (number_range(0,9))
      {
      case 0:
      move_char ( ch, DIR_WEST, FALSE);
      break;
      case 1:
      move_char (ch, DIR_NORTH, FALSE);
      break;
      case 2:
      move_char (ch, DIR_SOUTH, FALSE);
      break;
      case 3:
      move_char (ch, DIR_UP, FALSE);
      break;
      case 4:
      move_char (ch, DIR_DOWN, FALSE);
      break;
      default:
      move_char( ch, DIR_EAST, FALSE );
      }
   }
  else
    move_char( ch, DIR_EAST, FALSE );
    return;
}



void do_south( CHAR_DATA *ch, char *argument )
{
     if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 15) )
	{
	 switch (number_range(0,9))
	 {
	  case 0:
          move_char ( ch, DIR_WEST, FALSE);
	  break;
	  case 1:
	  move_char (ch, DIR_EAST, FALSE);
	  break;
	  case 2:
	  move_char (ch, DIR_NORTH, FALSE);
	  break;
	  case 3:
	  move_char (ch, DIR_UP, FALSE);
	  break;
	  case 4:
	  move_char (ch, DIR_DOWN, FALSE);
	  break;
	  default:
	  move_char( ch, DIR_SOUTH, FALSE );
	 }
        }
     else

        move_char( ch, DIR_SOUTH, FALSE );
        return;
}



void do_west( CHAR_DATA *ch, char *argument )
{
    if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 15) )
    {
     switch (number_range(0,9))
      {
	case 0:
        move_char ( ch, DIR_SOUTH, FALSE);
        break;
        case 1:
	move_char (ch, DIR_EAST, FALSE);
        break;
        case 2:
        move_char (ch, DIR_NORTH, FALSE);
	break;
        case 3:
        move_char (ch, DIR_UP, FALSE);
        break;
	case 4:
        move_char (ch, DIR_DOWN, FALSE);
        break;
        default:
	move_char( ch, DIR_WEST, FALSE );
       }
       }
    else
      move_char( ch, DIR_WEST, FALSE );
    
    return;
}



void do_up( CHAR_DATA *ch, char *argument )
{
    if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 15) )
       {
	 switch (number_range(0,9))
	 {
	  case 0:
	  move_char ( ch, DIR_WEST, FALSE);
	  break;
	  case 1:
	  move_char (ch, DIR_EAST, FALSE);
	  break;
	  case 2:
	  move_char (ch, DIR_SOUTH, FALSE);
	  break;
	  case 3:
	  move_char (ch, DIR_NORTH, FALSE);
	  break;
	  case 4:
	  move_char (ch, DIR_DOWN, FALSE);
	  break;
	  default:
	  move_char( ch, DIR_UP, FALSE );
	  }
	  }
   else
    move_char( ch, DIR_UP, FALSE );
    
    return;
}



void do_down( CHAR_DATA *ch, char *argument )
{
    if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 15) )
     {
      switch (number_range(0,9))
       {
	  case 0:
          move_char ( ch, DIR_WEST, FALSE);
	  break;
          case 1:
          move_char (ch, DIR_EAST, FALSE);
          break;
          case 2:
          move_char (ch, DIR_SOUTH, FALSE);
	  break;
          case 3:
	  move_char (ch, DIR_UP, FALSE);
          break;
	  case 4:
          move_char (ch, DIR_NORTH, FALSE);
	  break;
          default:
          move_char( ch, DIR_DOWN, FALSE );
       }
       }
     else
       move_char( ch, DIR_DOWN, FALSE );
    
    return;
}


int find_exit( CHAR_DATA *ch, char *arg )
{
    int door;

    if ( !str_cmp( arg, "n" ) || !str_cmp( arg, "north" ) ) door = 0;
    else if ( !str_cmp( arg, "e" ) || !str_cmp( arg, "east"  ) ) door = 1;
    else if ( !str_cmp( arg, "s" ) || !str_cmp( arg, "south" ) ) door = 2;
    else if ( !str_cmp( arg, "w" ) || !str_cmp( arg, "west"  ) ) door = 3;
    else if ( !str_cmp( arg, "u" ) || !str_cmp( arg, "up"    ) ) door = 4;
    else if ( !str_cmp( arg, "d" ) || !str_cmp( arg, "down"  ) ) door = 5;
    else door = -1; 

    return door;
}

int find_door( CHAR_DATA *ch, char *arg )
{
    EXIT_DATA *pexit;
    int door, fDir = TRUE;

   if ( !str_cmp( arg, "n" ) || !str_cmp( arg, "north" ) ) door = 0;
    else if ( !str_cmp( arg, "e" ) || !str_cmp( arg, "east"  ) ) door = 1;
    else if ( !str_cmp( arg, "s" ) || !str_cmp( arg, "south" ) ) door = 2;
    else if ( !str_cmp( arg, "w" ) || !str_cmp( arg, "west"  ) ) door = 3;
    else if ( !str_cmp( arg, "u" ) || !str_cmp( arg, "up"    ) ) door = 4;
    else if ( !str_cmp( arg, "d" ) || !str_cmp( arg, "down"  ) ) door = 5;
    else
    {
   /* Type in at least 2 letters of the door's name, you can find secret doors */
  if ( strlen(arg) >= 2 ) 
	fDir = FALSE; 
  for ( door = 0; door <= 5; door++ )
  {
      if ( ( pexit = ch->in_room->exit[door] ) != NULL
      &&   IS_SET(pexit->exit_info, EX_ISDOOR)
      &&   pexit->keyword != NULL
      &&   is_name( arg, pexit->keyword ) )
    return door;
  }
  act( "I see no $T here.", ch, NULL, arg, TO_CHAR ,FALSE);
  return -1;
    }

    if ( ( pexit = ch->in_room->exit[door] ) == NULL )
    {
  act( "I see no $T here.", ch, NULL, arg, TO_CHAR ,FALSE);
  return -1;
    }

    if ( !IS_SET(pexit->exit_info, EX_ISDOOR) )
    {
  send_to_char( "You can't do that.\n\r", ch );
  return -1;
    }

    if ( IS_SET(pexit->exit_info,EX_SECRET) && fDir )
    {
  act("I see no $T here.",ch,NULL,arg,TO_CHAR,FALSE);
	return -1;
    }
    return door;
}



void do_open( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int door;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg[0] == '\0' )
    {
  send_to_char( "Open what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_here( ch, arg ) ) != NULL )
    {
  /* open portal */
  if (obj->item_type == ITEM_PORTAL)
  {
      if (!IS_SET(obj->value[1], EX_ISDOOR))
      {
    send_to_char("You can't do that.\n\r",ch);
    return;
      }

      if (!IS_SET(obj->value[1], EX_CLOSED))
      {
    send_to_char("It's already open.\n\r",ch);
    return;
      }

      if (IS_SET(obj->value[1], EX_LOCKED))
      {
    send_to_char("It's locked.\n\r",ch);
    return;
      }

      REMOVE_BIT(obj->value[1], EX_CLOSED);
      act("You open $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n opens $p.",ch,obj,NULL,TO_ROOM,FALSE);
      return;
  }

  /* 'open object' */
  if ( obj->item_type != ITEM_CONTAINER)
      { send_to_char( "That's not a container.\n\r", ch ); return; }
  if ( !IS_SET(obj->value[1], CONT_CLOSED) )
      { send_to_char( "It's already open.\n\r",      ch ); return; }
  if ( !IS_SET(obj->value[1], CONT_CLOSEABLE) )
      { send_to_char( "You can't do that.\n\r",      ch ); return; }
  if ( IS_SET(obj->value[1], CONT_LOCKED) )
      { send_to_char( "It's locked.\n\r",            ch ); return; }

  REMOVE_BIT(obj->value[1], CONT_CLOSED);
  act("You open $p.",ch,obj,NULL,TO_CHAR,FALSE);
  act( "$n opens $p.", ch, obj, NULL, TO_ROOM ,FALSE);
  return;
    }

    if ( ( door = find_door( ch, arg ) ) >= 0 )
    {
  /* 'open door' */
  ROOM_INDEX_DATA *to_room;
  EXIT_DATA *pexit;
  EXIT_DATA *pexit_rev;

  pexit = ch->in_room->exit[door];
  if ( !IS_SET(pexit->exit_info, EX_CLOSED) )
      { send_to_char( "It's already open.\n\r",      ch ); return; }
  if (  IS_SET(pexit->exit_info, EX_LOCKED) )
      { send_to_char( "It's locked.\n\r",            ch ); return; }

  REMOVE_BIT(pexit->exit_info, EX_CLOSED);
  act( "$n opens the $d.", ch, NULL, pexit->keyword, TO_ROOM ,FALSE);
  send_to_char( "Ok.\n\r", ch );

  /* open the other side */
  if ( ( to_room   = pexit->u1.to_room            ) != NULL
  &&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
  &&   pexit_rev->u1.to_room == ch->in_room )
  {
      CHAR_DATA *rch;

      REMOVE_BIT( pexit_rev->exit_info, EX_CLOSED );
      for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
    act( "The $d opens.", rch, NULL, pexit_rev->keyword, TO_CHAR ,FALSE);
  }
    }

    return;
}



void do_close( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int door;

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Close what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_here( ch, arg ) ) != NULL )
    {
  /* portal stuff */
  if (obj->item_type == ITEM_PORTAL)
  {

      if (!IS_SET(obj->value[1],EX_ISDOOR)
      ||   IS_SET(obj->value[1],EX_NOCLOSE))
      {
    send_to_char("You can't do that.\n\r",ch);
    return;
      }

      if (IS_SET(obj->value[1],EX_CLOSED))
      {
    send_to_char("It's already closed.\n\r",ch);
    return;
      }

      SET_BIT(obj->value[1],EX_CLOSED);
      act("You close $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n closes $p.",ch,obj,NULL,TO_ROOM,FALSE);
      return;
  }

  /* 'close object' */
  if ( obj->item_type != ITEM_CONTAINER )
      { send_to_char( "That's not a container.\n\r", ch ); return; }
  if ( IS_SET(obj->value[1], CONT_CLOSED) )
      { send_to_char( "It's already closed.\n\r",    ch ); return; }
  if ( !IS_SET(obj->value[1], CONT_CLOSEABLE) )
      { send_to_char( "You can't do that.\n\r",      ch ); return; }

  SET_BIT(obj->value[1], CONT_CLOSED);
  act("You close $p.",ch,obj,NULL,TO_CHAR,FALSE);
  act( "$n closes $p.", ch, obj, NULL, TO_ROOM ,FALSE);
  return;
    }

    if ( ( door = find_door( ch, arg ) ) >= 0 )
    {
  /* 'close door' */
  ROOM_INDEX_DATA *to_room;
  EXIT_DATA *pexit;
  EXIT_DATA *pexit_rev;

  pexit = ch->in_room->exit[door];
  if ( IS_SET(pexit->exit_info, EX_CLOSED) )
      { send_to_char( "It's already closed.\n\r",    ch ); return; }

  SET_BIT(pexit->exit_info, EX_CLOSED);
  act( "$n closes the $d.", ch, NULL, pexit->keyword, TO_ROOM ,FALSE);
  send_to_char( "Ok.\n\r", ch );

  /* close the other side */
  if ( ( to_room   = pexit->u1.to_room            ) != NULL
  &&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != 0
  &&   pexit_rev->u1.to_room == ch->in_room )
  {
      CHAR_DATA *rch;

      SET_BIT( pexit_rev->exit_info, EX_CLOSED );
      for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
    act( "The $d closes.", rch, NULL, pexit_rev->keyword, TO_CHAR ,FALSE);
  }
    }

    return;
}



bool has_key( CHAR_DATA *ch, int key )
{
    OBJ_DATA *obj;

    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
    {
  if ( obj->pIndexData->vnum == key )
      return TRUE;
    }

    return FALSE;
}



void do_lock( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int door;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg[0] == '\0' )
    {
  send_to_char( "Lock what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_here( ch, arg ) ) != NULL )
    {
  /* portal stuff */
  if (obj->item_type == ITEM_PORTAL)
  {
      if (!IS_SET(obj->value[1],EX_ISDOOR)
      ||  IS_SET(obj->value[1],EX_NOCLOSE))
      {
    send_to_char("You can't do that.\n\r",ch);
    return;
      }
      if (!IS_SET(obj->value[1],EX_CLOSED))
      {
    send_to_char("It's not closed.\n\r",ch);
    return;
      }

      if (obj->value[4] < 0 || IS_SET(obj->value[1],EX_NOLOCK))
      {
    send_to_char("It can't be locked.\n\r",ch);
    return;
      }

      if (!has_key(ch,obj->value[4]))
      {
    send_to_char("You lack the key.\n\r",ch);
    return;
      }

      if (IS_SET(obj->value[1],EX_LOCKED))
      {
    send_to_char("It's already locked.\n\r",ch);
    return;
      }

      SET_BIT(obj->value[1],EX_LOCKED);
      act("You lock $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n locks $p.",ch,obj,NULL,TO_ROOM,FALSE);
      return;
  }

  /* 'lock object' */
  if ( obj->item_type != ITEM_CONTAINER )
      { send_to_char( "That's not a container.\n\r", ch ); return; }
  if ( !IS_SET(obj->value[1], CONT_CLOSED) )
      { send_to_char( "It's not closed.\n\r",        ch ); return; }
  if ( obj->value[2] < 0 )
      { send_to_char( "It can't be locked.\n\r",     ch ); return; }
  if ( !has_key( ch, obj->value[2] ) )
      { send_to_char( "You lack the key.\n\r",       ch ); return; }
  if ( IS_SET(obj->value[1], CONT_LOCKED) )
      { send_to_char( "It's already locked.\n\r",    ch ); return; }

  SET_BIT(obj->value[1], CONT_LOCKED);
  act("You lock $p.",ch,obj,NULL,TO_CHAR,FALSE);
  act( "$n locks $p.", ch, obj, NULL, TO_ROOM ,FALSE);
  return;
    }

    if ( ( door = find_door( ch, arg ) ) >= 0 )
    {
  /* 'lock door' */
  ROOM_INDEX_DATA *to_room;
  EXIT_DATA *pexit;
  EXIT_DATA *pexit_rev;

  pexit = ch->in_room->exit[door];
  if ( !IS_SET(pexit->exit_info, EX_CLOSED) )
      { send_to_char( "It's not closed.\n\r",        ch ); return; }
  if ( pexit->key < 0 )
      { send_to_char( "It can't be locked.\n\r",     ch ); return; }
  if ( !has_key( ch, pexit->key) )
      { send_to_char( "You lack the key.\n\r",       ch ); return; }
  if ( IS_SET(pexit->exit_info, EX_LOCKED) )
      { send_to_char( "It's already locked.\n\r",    ch ); return; }

  SET_BIT(pexit->exit_info, EX_LOCKED);
  send_to_char( "*Click*\n\r", ch );
  act( "$n locks the $d.", ch, NULL, pexit->keyword, TO_ROOM ,FALSE);

  /* lock the other side */
  if ( ( to_room   = pexit->u1.to_room            ) != NULL
  &&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != 0
  &&   pexit_rev->u1.to_room == ch->in_room )
  {
      SET_BIT( pexit_rev->exit_info, EX_LOCKED );
  }
    }

    return;
}



void do_unlock( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int door;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }



    if ( arg[0] == '\0' )
    {
  send_to_char( "Unlock what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_here( ch, arg ) ) != NULL )
    {
  /* portal stuff */
  if (obj->item_type == ITEM_PORTAL)
  {
      if (IS_SET(obj->value[1],EX_ISDOOR))
      {
    send_to_char("You can't do that.\n\r",ch);
    return;
      }

      if (!IS_SET(obj->value[1],EX_CLOSED))
      {
    send_to_char("It's not closed.\n\r",ch);
    return;
      }

      if (obj->value[4] < 0)
      {
    send_to_char("It can't be unlocked.\n\r",ch);
    return;
      }

      if (!has_key(ch,obj->value[4]))
      {
    send_to_char("You lack the key.\n\r",ch);
    return;
      }

      if (!IS_SET(obj->value[1],EX_LOCKED))
      {
    send_to_char("It's already unlocked.\n\r",ch);
    return;
      }

      REMOVE_BIT(obj->value[1],EX_LOCKED);
      act("You unlock $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n unlocks $p.",ch,obj,NULL,TO_ROOM,FALSE);
      return;
  }

  /* 'unlock object' */
  if ( obj->item_type != ITEM_CONTAINER )
      { send_to_char( "That's not a container.\n\r", ch ); return; }
  if ( !IS_SET(obj->value[1], CONT_CLOSED) )
      { send_to_char( "It's not closed.\n\r",        ch ); return; }
  if ( obj->value[2] < 0 )
      { send_to_char( "It can't be unlocked.\n\r",   ch ); return; }
  if ( !has_key( ch, obj->value[2] ) )
      { send_to_char( "You lack the key.\n\r",       ch ); return; }
  if ( !IS_SET(obj->value[1], CONT_LOCKED) )
      { send_to_char( "It's already unlocked.\n\r",  ch ); return; }

  REMOVE_BIT(obj->value[1], CONT_LOCKED);
  act("You unlock $p.",ch,obj,NULL,TO_CHAR,FALSE);
  act( "$n unlocks $p.", ch, obj, NULL, TO_ROOM ,FALSE);
  return;
    }

    if ( ( door = find_door( ch, arg ) ) >= 0 )
    {
  /* 'unlock door' */
  ROOM_INDEX_DATA *to_room;
  EXIT_DATA *pexit;
  EXIT_DATA *pexit_rev;

  pexit = ch->in_room->exit[door];
  if ( !IS_SET(pexit->exit_info, EX_CLOSED) )
      { send_to_char( "It's not closed.\n\r",        ch ); return; }
  if ( pexit->key < 0 )
      { send_to_char( "It can't be unlocked.\n\r",   ch ); return; }
  if ( !has_key( ch, pexit->key) )
      { send_to_char( "You lack the key.\n\r",       ch ); return; }
  if ( !IS_SET(pexit->exit_info, EX_LOCKED) )
      { send_to_char( "It's already unlocked.\n\r",  ch ); return; }

  REMOVE_BIT(pexit->exit_info, EX_LOCKED);
  send_to_char( "*Click*\n\r", ch );
  act( "$n unlocks the $d.", ch, NULL, pexit->keyword, TO_ROOM ,FALSE);

  /* unlock the other side */
  if ( ( to_room   = pexit->u1.to_room            ) != NULL
  &&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
  &&   pexit_rev->u1.to_room == ch->in_room )
  {
      REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
  }
    }

    return;
}



void do_pick( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *gch;
    OBJ_DATA *obj;
    int door;

    if ( IS_NPC(ch) && ch->desc == NULL)
    return;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Pick what?\n\r", ch );
  return;
    }

    if ( ch->move < (ch->level/15) )
    {   
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

    WAIT_STATE( ch, skill_table[gsn_pick_lock].beats );

    /* look for guards */
    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
    {
  if ( IS_NPC(gch) && IS_AWAKE(gch) && ch->level + 5 < gch->level )
  {
      act( "$N is standing too close to the lock.",
    ch, NULL, gch, TO_CHAR ,FALSE);
      return;
  }
    }

    if ( !IS_NPC(ch) && number_percent( ) > get_skill(ch,gsn_pick_lock))
    {
  send_to_char( "You failed.\n\r", ch);
  check_improve(ch,gsn_pick_lock,FALSE,2);
  return;
    }

    if ( ( obj = get_obj_here( ch, arg ) ) != NULL )
    {
  /* portal stuff */
  if (obj->item_type == ITEM_PORTAL)
  {
      if (!IS_SET(obj->value[1],EX_ISDOOR))
      { 
    send_to_char("You can't do that.\n\r",ch);
    return;
      }

      if (!IS_SET(obj->value[1],EX_CLOSED))
      {
    send_to_char("It's not closed.\n\r",ch);
    return;
      }

      if (obj->value[4] < 0)
      {
    send_to_char("It can't be unlocked.\n\r",ch);
    return;
      }

      if (IS_SET(obj->value[1],EX_PICKPROOF))
      {
    send_to_char("You failed.\n\r",ch);
    return;
      }

      REMOVE_BIT(obj->value[1],EX_LOCKED);
      act("You pick the lock on $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n picks the lock on $p.",ch,obj,NULL,TO_ROOM,FALSE);
      check_improve(ch,gsn_pick_lock,TRUE,2);
      return;
  }

      


  
  /* 'pick object' */
  if ( obj->item_type != ITEM_CONTAINER )
      { send_to_char( "That's not a container.\n\r", ch ); return; }
  if ( !IS_SET(obj->value[1], CONT_CLOSED) )
      { send_to_char( "It's not closed.\n\r",        ch ); return; }
  if ( obj->value[2] < 0 )
      { send_to_char( "It can't be unlocked.\n\r",   ch ); return; }
  if ( !IS_SET(obj->value[1], CONT_LOCKED) )
      { send_to_char( "It's already unlocked.\n\r",  ch ); return; }
  if ( IS_SET(obj->value[1], CONT_PICKPROOF) )
      { send_to_char( "You failed.\n\r",             ch ); return; }

  REMOVE_BIT(obj->value[1], CONT_LOCKED);
        act("You pick the lock on $p.",ch,obj,NULL,TO_CHAR,FALSE);
        act("$n picks the lock on $p.",ch,obj,NULL,TO_ROOM,FALSE);
  check_improve(ch,gsn_pick_lock,TRUE,2);
  return;
    }

    if ( ( door = find_door( ch, arg ) ) >= 0 )
    {
  /* 'pick door' */
  ROOM_INDEX_DATA *to_room;
  EXIT_DATA *pexit;
  EXIT_DATA *pexit_rev;

  pexit = ch->in_room->exit[door];
  if ( !IS_SET(pexit->exit_info, EX_CLOSED) && !IS_IMMORTAL(ch))
      { send_to_char( "It's not closed.\n\r",        ch ); return; }
  if ( pexit->key < 0 && !IS_IMMORTAL(ch))
      { send_to_char( "It can't be picked.\n\r",     ch ); return; }
  if ( !IS_SET(pexit->exit_info, EX_LOCKED) )
      { send_to_char( "It's already unlocked.\n\r",  ch ); return; }
  if ( IS_SET(pexit->exit_info, EX_PICKPROOF) && !IS_IMMORTAL(ch))
      { send_to_char( "You failed.\n\r",             ch ); return; }

  REMOVE_BIT(pexit->exit_info, EX_LOCKED);
  send_to_char( "*Click*\n\r", ch );
  act( "$n picks the $d.", ch, NULL, pexit->keyword, TO_ROOM ,FALSE);
  check_improve(ch,gsn_pick_lock,TRUE,2);

  /* pick the other side */
  if ( ( to_room   = pexit->u1.to_room            ) != NULL
  &&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
  &&   pexit_rev->u1.to_room == ch->in_room )
  {
      REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
  }
    }

    return;
}




void do_stand( CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *obj = NULL;
    OBJ_DATA *obj_on = ch->on;

    if ( is_affected(ch,gsn_trap) )
    {
	send_to_char("You are held fast by a snare trap.\n\r",ch);
	return;
    }
  if ( is_affected(ch,skill_lookup("hold person")))
    {
        send_to_char("Your muscles are frozen!\n\r",ch);
        return;
    }

    if (argument[0] != '\0')
    {
  if (ch->position == POS_FIGHTING)
  {
      send_to_char("Maybe you should finish fighting first?\n\r",ch);
      return;
  }
  obj = get_obj_list(ch,argument,ch->in_room->contents);
  if (obj == NULL)
  {
      send_to_char("You don't see that here.\n\r",ch);
      return;
  }
  if (obj->item_type != ITEM_FURNITURE
  ||  (!IS_SET(obj->value[2],STAND_AT)
  &&   !IS_SET(obj->value[2],STAND_ON)
  &&   !IS_SET(obj->value[2],STAND_IN)))
  {
      send_to_char("You can't seem to find a place to stand.\n\r",ch);
      return;
  }
  if (ch->on != obj && count_users(obj) >= obj->value[0])
  {
      act_new("There's no room to stand on $p.",
    ch,obj,NULL,TO_ROOM,POS_DEAD,FALSE);
      return;
  }
    }
    
    switch ( ch->position )
    {
    case POS_SLEEPING:
  if ( IS_AFFECTED(ch, AFF_SLEEP) )
      { send_to_char( "You can't wake up!\n\r", ch ); return; }
  
  if (obj == NULL)
  {
      send_to_char( "You wake and stand up.\n\r", ch );
      act( "$n wakes and stands up.", ch, NULL, NULL, TO_ROOM ,FALSE);
      ch->on = NULL;
  }
  else if (IS_SET(obj->value[2],STAND_AT))
  {
     act_new("You wake and stand at $p.",ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
     act("$n wakes and stands at $p.",ch,obj,NULL,TO_ROOM,FALSE);
  }
  else if (IS_SET(obj->value[2],STAND_ON))
  {
      act_new("You wake and stand on $p.",ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
      act("$n wakes and stands on $p.",ch,obj,NULL,TO_ROOM,FALSE);
  }
  else 
  {
      act_new("You wake and stand in $p.",ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
      act("$n wakes and stands in $p.",ch,obj,NULL,TO_ROOM,FALSE);
  }
  ch->position = POS_STANDING;
  do_look(ch,"auto");
  break;

    case POS_RESTING: case POS_SITTING:
  if (obj == NULL)
  {
      send_to_char( "You stand up.\n\r", ch );
      act( "$n stands up.", ch, NULL, NULL, TO_ROOM ,FALSE);
      ch->on = NULL;
  }
  else if (IS_SET(obj->value[2],STAND_AT))
  {
      act("You stand at $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n stands at $p.",ch,obj,NULL,TO_ROOM,FALSE);
  }
  else if (IS_SET(obj->value[2],STAND_ON))
  {
      act("You stand on $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n stands on $p.",ch,obj,NULL,TO_ROOM,FALSE);
  }
  else
  {
      act("You stand in $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n stands on $p.",ch,obj,NULL,TO_ROOM,FALSE);
  }
  ch->position = POS_STANDING;
  break;

    case POS_STANDING:
  send_to_char( "You are already standing.\n\r", ch );
  break;

    case POS_FIGHTING:
  send_to_char( "You are already fighting!\n\r", ch );
  break;
    }

    if (obj_on !=NULL && CAN_WEAR(obj_on,ITEM_TAKE) && !is_clan(ch))
       get_obj(ch,obj_on,NULL);

    return;
}



void do_rest( CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *obj = NULL;
    
    if ( IS_AFFECTED(ch, AFF_SLEEP) ) {
      send_to_char ("You can't wake up!\n\r",ch);
      return;
    }

    if ( is_mounted(ch) ) {
	send_to_char("Dismount first.\n\r",ch);
	return;
    }

    if (ch->position == POS_FIGHTING)
    {
  send_to_char("You are already fighting!\n\r",ch);
  return;
    }

      if (IS_AFFECTED(ch,AFF_CHARM) && str_cmp(kludge_string,"order"))
	  {
	    send_to_char("Did you master tell you to do that?\n\r",ch);
	    return;
	  }

    /* okay, now that we know we can rest, find an object to rest on */
    if (argument[0] != '\0')
    {
  obj = get_obj_list(ch,argument,ch->in_room->contents);
  if (obj == NULL)
  {
      send_to_char("You don't see that here.\n\r",ch);
      return;
  }
    }
    else obj = ch->on;

    if (obj != NULL)
    {
        if (!IS_SET(obj->item_type,ITEM_FURNITURE) 
      ||  (!IS_SET(obj->value[2],REST_ON)
      &&   !IS_SET(obj->value[2],REST_IN)
      &&   !IS_SET(obj->value[2],REST_AT)))
      {
      send_to_char("You can't rest on that.\n\r",ch);
      return;
      }

        if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
        {
      act_new("There's no more room on $p.",ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
      return;
      }
  
  ch->on = obj;
    }

    switch ( ch->position )
    {
    case POS_SLEEPING:
  if (obj == NULL)
  {
      send_to_char( "You wake up and start resting.\n\r", ch );
      act("$n wakes up and starts resting.",ch,NULL,NULL,TO_ROOM,FALSE);
  }
  else if (IS_SET(obj->value[2],REST_AT))
  {
      act_new("You wake up and rest at $p.",
        ch,obj,NULL,TO_CHAR,POS_SLEEPING,FALSE);
      act("$n wakes up and rests at $p.",ch,obj,NULL,TO_ROOM,FALSE);
  }
        else if (IS_SET(obj->value[2],REST_ON))
        {
            act_new("You wake up and rest on $p.",
                    ch,obj,NULL,TO_CHAR,POS_SLEEPING,FALSE);
            act("$n wakes up and rests on $p.",ch,obj,NULL,TO_ROOM,FALSE);
        }
        else
        {
            act_new("You wake up and rest in $p.",
                    ch,obj,NULL,TO_CHAR,POS_SLEEPING,FALSE);
            act("$n wakes up and rests in $p.",ch,obj,NULL,TO_ROOM,FALSE);
        }
  ch->position = POS_RESTING;
  break;

    case POS_RESTING:
  send_to_char( "You are already resting.\n\r", ch );
  break;

    case POS_STANDING:
  if (obj == NULL)
  {
      send_to_char( "You rest.\n\r", ch );
      act( "$n sits down and rests.", ch, NULL, NULL, TO_ROOM ,FALSE);
  }
        else if (IS_SET(obj->value[2],REST_AT))
        {
      act("You sit down at $p and rest.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n sits down at $p and rests.",ch,obj,NULL,TO_ROOM,FALSE);
        }
        else if (IS_SET(obj->value[2],REST_ON))
        {
      act("You sit on $p and rest.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n sits on $p and rests.",ch,obj,NULL,TO_ROOM,FALSE);
        }
        else
        {
      act("You rest in $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n rests in $p.",ch,obj,NULL,TO_ROOM,FALSE);
        }
  ch->position = POS_RESTING;
  break;

    case POS_SITTING:
  if (obj == NULL)
  {
      send_to_char("You rest.\n\r",ch);
      act("$n rests.",ch,NULL,NULL,TO_ROOM,FALSE);
  }
        else if (IS_SET(obj->value[2],REST_AT))
        {
      act("You rest at $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n rests at $p.",ch,obj,NULL,TO_ROOM,FALSE);
        }
        else if (IS_SET(obj->value[2],REST_ON))
        {
      act("You rest on $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n rests on $p.",ch,obj,NULL,TO_ROOM,FALSE);
        }
        else
        {
      act("You rest in $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("$n rests in $p.",ch,obj,NULL,TO_ROOM,FALSE);
  }
  ch->position = POS_RESTING;
  break;
    }


    return;
}


void do_sit (CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *obj = NULL;
   
    if ( is_mounted(ch) ) {
	send_to_char("Dismount first.\n\r",ch);
	return;
    }

    if ( IS_AFFECTED(ch, AFF_SLEEP) ) {
      send_to_char ("You can't wake up!\n\r",ch);
      return;                          
    }

    if (ch->position == POS_FIGHTING)
    {
  send_to_char("Maybe you should finish this fight first?\n\r",ch);
  return;
    }

      if (IS_AFFECTED(ch,AFF_CHARM) && str_cmp(kludge_string,"order"))
	  {
	    send_to_char("Did you master tell you to do that?\n\r",ch);
	    return;
	  }

    /* okay, now that we know we can sit, find an object to sit on */
    if (argument[0] != '\0')
    {
  obj = get_obj_list(ch,argument,ch->in_room->contents);
  if (obj == NULL)
  {
      send_to_char("You don't see that here.\n\r",ch);
      return;
  }
    }
    else obj = ch->on;

    if (obj != NULL)                                                              
    {
  if (!IS_SET(obj->item_type,ITEM_FURNITURE)
  ||  (!IS_SET(obj->value[2],SIT_ON)
  &&   !IS_SET(obj->value[2],SIT_IN)
  &&   !IS_SET(obj->value[2],SIT_AT)))
  {
      send_to_char("You can't sit on that.\n\r",ch);
      return;
  }

  if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
  {
      act_new("There's no more room on $p.",ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
      return;
  }

  ch->on = obj;
    }
    switch (ch->position)
    {
  case POS_SLEEPING:
            if (obj == NULL)
            {
              send_to_char( "You wake and sit up.\n\r", ch );
              act( "$n wakes and sits up.", ch, NULL, NULL, TO_ROOM ,FALSE);
            }
            else if (IS_SET(obj->value[2],SIT_AT))
            {
              act_new("You wake and sit at $p.",
		ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
              act("$n wakes and sits at $p.",ch,obj,NULL,TO_ROOM,FALSE);
            }
            else if (IS_SET(obj->value[2],SIT_ON))
            {
              act_new("You wake and sit on $p.",
		ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
              act("$n wakes and sits at $p.",ch,obj,NULL,TO_ROOM,FALSE);
            }
            else
            {
              act_new("You wake and sit in $p.",
		ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
              act("$n wakes and sits in $p.",ch,obj,NULL,TO_ROOM,FALSE);
            }

      ch->position = POS_SITTING;
      break;
  case POS_RESTING:
      if (obj == NULL)
    send_to_char("You stop resting.\n\r",ch);
      else if (IS_SET(obj->value[2],SIT_AT))
      {
    act("You sit at $p.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$n sits at $p.",ch,obj,NULL,TO_ROOM,FALSE);
      }

      else if (IS_SET(obj->value[2],SIT_ON))
      {
    act("You sit on $p.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$n sits on $p.",ch,obj,NULL,TO_ROOM,FALSE);
      }
      ch->position = POS_SITTING;
      break;
  case POS_SITTING:
      send_to_char("You are already sitting down.\n\r",ch);
      break;
  case POS_STANDING:
      if (obj == NULL)
          {
    send_to_char("You sit down.\n\r",ch);
              act("$n sits down on the ground.",ch,NULL,NULL,TO_ROOM,FALSE);
      }
      else if (IS_SET(obj->value[2],SIT_AT))
      {
    act("You sit down at $p.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$n sits down at $p.",ch,obj,NULL,TO_ROOM,FALSE);
      }
      else if (IS_SET(obj->value[2],SIT_ON))
      {
    act("You sit on $p.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$n sits on $p.",ch,obj,NULL,TO_ROOM,FALSE);
      }
      else
      {
    act("You sit down in $p.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$n sits down in $p.",ch,obj,NULL,TO_ROOM,FALSE);
      }
          ch->position = POS_SITTING;
          break;
    }
    return;
}


void do_sleep( CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *obj = NULL;

    if ( is_mounted(ch) ) {
	send_to_char("Dismount first.\n\r",ch);
	return;
    }

    switch ( ch->position )
    {
    case POS_SLEEPING:
  send_to_char( "You are already sleeping.\n\r", ch );
  break;

    case POS_RESTING:
    case POS_SITTING:
    case POS_STANDING: 
      if (IS_AFFECTED(ch,AFF_CHARM) && str_cmp(kludge_string,"order"))
	  {
	    send_to_char("Did you master tell you to do that?\n\r",ch);
	    return;
	  }

  if (argument[0] == '\0' && ch->on == NULL)
  {
      send_to_char( "You go to sleep.\n\r", ch );
      act( "$n goes to sleep.", ch, NULL, NULL, TO_ROOM ,FALSE);
      ch->position = POS_SLEEPING;
  }
  else  /* find an object and sleep on it */
  {
      if (argument[0] == '\0')
    obj = ch->on;
      else
        obj = get_obj_list( ch, argument,  ch->in_room->contents );

      if (obj == NULL)
      {
    send_to_char("You don't see that here.\n\r",ch);
    return;
      }
      if (obj->item_type != ITEM_FURNITURE
      ||  (!IS_SET(obj->value[2],SLEEP_ON) 
      &&   !IS_SET(obj->value[2],SLEEP_IN)
      &&   !IS_SET(obj->value[2],SLEEP_AT)))
      {
    send_to_char("You can't sleep on that!\n\r",ch);
    return;
      }

      if (ch->on != obj && count_users(obj) >= obj->value[0])
      {
    act_new("There is no room on $p for you.",
        ch,obj,NULL,TO_CHAR,POS_DEAD,FALSE);
    return;
      }

      ch->on = obj;
      if (IS_SET(obj->value[2],SLEEP_AT))
      {
    act("You go to sleep at $p.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$n goes to sleep at $p.",ch,obj,NULL,TO_ROOM,FALSE);
      }
      else if (IS_SET(obj->value[2],SLEEP_ON))
      {
          act("You go to sleep on $p.",ch,obj,NULL,TO_CHAR,FALSE);
          act("$n goes to sleep on $p.",ch,obj,NULL,TO_ROOM,FALSE);
      }
      else
      {
    act("You go to sleep in $p.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$n goes to sleep in $p.",ch,obj,NULL,TO_ROOM,FALSE);
      }
      ch->position = POS_SLEEPING;
  }
  break;

    case POS_FIGHTING:
  send_to_char( "You are already fighting!\n\r", ch );
  break;
    }

    return;
}



void do_wake( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );
    if ( arg[0] == '\0' )
  { do_stand( ch, argument ); return; }

    if ( !IS_AWAKE(ch) )
  { send_to_char( "You are asleep yourself!\n\r",       ch ); return; }

    if ( ( victim = get_char_room( ch, arg ) ) == NULL )
  { send_to_char( "They aren't here.\n\r",              ch ); return; }

    if ( IS_AWAKE(victim) )
  { act( "$N is already awake.", ch, NULL, victim, TO_CHAR ,FALSE); return; }

    if ( IS_AFFECTED(victim, AFF_SLEEP) 
	|| (IS_SET(victim->act,PLR_NOWAKE) && !IS_IMMORTAL(ch)))
  { act( "You can't wake $M!",   ch, NULL, victim, TO_CHAR ,FALSE);  return; }

    act_new( "$n wakes you.", ch, NULL, victim, TO_VICT,POS_SLEEPING,FALSE );
    do_stand(victim,"");
    return;
}



void do_sneak( CHAR_DATA *ch, char *argument )
{
    AFFECT_DATA af;

    if ( IS_AFFECTED(ch,AFF_FAERIE_FOG)){
	send_to_char("You're too easy to see!\n\r",ch);
		return;
    }

    if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char("Everyone is too alert in the Arena.\n\r",ch);
       return;
    }

    if ( ch->move < (ch->level/15) )
    {   
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

    if (IS_AFFECTED(ch,AFF_SNEAK))
	{
	send_to_char( "You attempt to move silently.\n\r", ch );
  	return;
	}

    send_to_char( "You attempt to move silently.\n\r", ch );
    affect_strip( ch, gsn_sneak );

    if ( number_percent( ) < get_skill(ch,gsn_sneak))
    {
  check_improve(ch,gsn_sneak,TRUE,3);
  check_improve(ch,gsn_ninjitsu,TRUE,3);
  af.where     = TO_AFFECTS;
  af.type      = gsn_sneak;
  af.level     = ch->level; 
  af.duration  = ch->level;
  af.location  = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = AFF_SNEAK;
  affect_to_char( ch, &af );
    }
/*    else
  check_improve(ch,gsn_sneak,FALSE,3);
*/

    return;
}



void do_hide( CHAR_DATA *ch, char *argument )
{
    if ( IS_AFFECTED(ch,AFF_FAERIE_FOG)){
	send_to_char("You're too easy to see!\n\r",ch);
		return;
    }

    if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char("Nothing to hide behind in the Arena.\n\r",ch);
       return;
    }

    if ( ch->move < (ch->level/10) )
    {
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/10));

    send_to_char( "You attempt to hide.\n\r", ch );

    if ( IS_AFFECTED(ch, AFF_FAERIE_FOG) )
	return;

    if ( IS_AFFECTED(ch, AFF_HIDE) )
	return;

    if ( number_percent( ) < get_skill(ch,gsn_hide)/
    HAS_KIT(ch,"ninja") ? 2 : 3)
    {
  SET_BIT(ch->affected_by, AFF_HIDE);
  check_improve(ch,gsn_hide,TRUE,3);
  check_improve(ch,gsn_ninjitsu,TRUE,3);
    WAIT_STATE(ch,skill_table[gsn_hide].beats);
    }
    else
  {
  check_improve(ch,gsn_hide,FALSE,3);
  check_improve(ch,gsn_ninjitsu,FALSE,3);
  WAIT_STATE(ch,skill_table[gsn_hide].beats);
  }

    return;
}



/*
 * Contributed by Alander.
 */
void do_visible( CHAR_DATA *ch, char *argument )
{
    affect_strip ( ch, gsn_invis      );
    affect_strip ( ch, gsn_mass_invis     );
    affect_strip ( ch, gsn_sneak      );
    affect_strip ( ch, gsn_hide      );
    REMOVE_BIT   ( ch->affected_by, AFF_HIDE    );
    REMOVE_BIT   ( ch->affected_by, AFF_INVISIBLE );
    REMOVE_BIT   ( ch->affected_by, AFF_SNEAK   );
    send_to_char( "Ok.\n\r", ch );
    return;
}


void do_recall( CHAR_DATA *ch, char *argument )
{
    recall ( ch, argument, FALSE );
    return;
}

void recall( CHAR_DATA *ch, char *argument, bool fPray )
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    ROOM_INDEX_DATA *location;
    int loc_hold;

    if (IS_NPC(ch) && !IS_SET(ch->act,ACT_PET))
    {
  send_to_char("Only players can recall.\n\r",ch);
  return;
    }

    if (( ch->in_room->area->no_transport ) || ( ch->in_room->clan && ch->in_room->clan != ch->clan))

    {
	send_to_char("Your deity cannot hear your plea from here.\n\r",ch);
	return;
    }

    if( !IS_NPC(ch) 
	&& ch->level > 10 
	&& !fPray 
	&& !IS_IMMORTAL(ch))
    {
	send_to_char("Sorry, no free recalls anymore.\n\r",ch);
	return;
    }

    act( "$n prays for transportation!", ch, 0, 0, TO_ROOM ,FALSE);

  /*
    if( ch->level < 6 )
	loc_hold = ROOM_VNUM_TEMPLE;
    else
	loc_hold = (pc_race_table[ch->race].color ? ROOM_VNUM_TEMPLE 
			: ROOM_VNUM_NTFOUNTAIN);
   */
    loc_hold = ROOM_VNUM_TEMPLE;

    location = get_room_index( loc_hold );
    if ( location  == NULL )
    {
  send_to_char( "You are completely lost.\n\r", ch );
  return;
    }

    if ( ch->in_room == location )
  return;

    if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
    ||   IS_AFFECTED(ch, AFF_CURSE) 
    ||   is_affected(ch,gsn_morph)
    ||   IS_SET(ch->act, PLR_DWEEB) )
    {
  if(!IS_NPC(ch))
  {
    sprintf(buf,"%s has forsaken you.\n\r",
	deity_table[ch->pcdata->deity].pname);
    send_to_char(buf,ch);
  }
  return;
    }

    if ( ( victim = ch->fighting ) != NULL )
    {
  int lose,skill;

  skill = get_skill(ch,gsn_recall);

  if ( number_percent() > 80 * skill / 100 )
  {
      check_improve(ch,gsn_recall,FALSE,6);
      WAIT_STATE( ch, 4 );
      sprintf( buf, "You failed!.\n\r");
      send_to_char( buf, ch );
      return;
  }

  lose = (ch->desc != NULL) ? 25 : 50;
  gain_exp( ch, 0 - lose );
  check_improve(ch,gsn_recall,TRUE,4);
  sprintf( buf, "You recall from combat!  You lose %d exps.\n\r", lose );
  send_to_char( buf, ch );
  stop_fighting( ch, TRUE );
  
    }

   // ch->move *= 50;
   // ch->move /= apply_chi(ch,100);
      ch->move -= apply_chi(ch, ch->move/2);
    act( "$n disappears.", ch, NULL, NULL, TO_ROOM ,FALSE);
    char_from_room( ch );
    char_to_room( ch, location );
    clear_mount( ch );
    act( "$n appears in the room.", ch, NULL, NULL, TO_ROOM ,FALSE);
    do_look( ch, "auto" );
    
    if (ch->pet != NULL)
  do_recall(ch->pet,"");

    return;
}



void do_train( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *mob;
    sh_int stat = - 1;
    char *pOutput = NULL;
    int cost;

    if ( IS_NPC(ch) )
  return;

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    /*
     * Check for trainer.
     */
    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
    {
  if ( IS_NPC(mob) && IS_SET(mob->act, ACT_TRAIN) )
      break;
    }

    if ( mob == NULL )
    {
  send_to_char( "You can't do that here.\n\r", ch );
  return;
    }

    if ( argument[0] == '\0' )
    {
  sprintf( buf, "You have %d training sessions.\n\r", ch->train );
  send_to_char( buf, ch );
  argument = "foo";
    }

    if (IS_SET(ch->mhs,MHS_SHAPESHIFTED) || IS_SET(ch->mhs,MHS_SHAPEMORPHED))
    {
  sprintf( buf, "You are not allowed to train while shapeshifted.\n\r");
  send_to_char( buf,ch);
  return;
    }

    cost = 1;

    if ( !str_cmp( argument, "str" ) )
    {
  if ( class_table[ch->class].attr_prime == STAT_STR )
      cost    = 1;
  stat        = STAT_STR;
  pOutput     = "strength";
    }

    else if ( !str_cmp( argument, "int" ) )
    {
  if ( class_table[ch->class].attr_prime == STAT_INT )
      cost    = 1;
  stat      = STAT_INT;
  pOutput     = "intelligence";
    }

    else if ( !str_cmp( argument, "wis" ) )
    {
  if ( class_table[ch->class].attr_prime == STAT_WIS )
      cost    = 1;
  stat      = STAT_WIS;
  pOutput     = "wisdom";
    }

    else if ( !str_cmp( argument, "dex" ) )
    {
  if ( class_table[ch->class].attr_prime == STAT_DEX )
      cost    = 1;
  stat        = STAT_DEX;
  pOutput     = "dexterity";
    }

    else if ( !str_cmp( argument, "con" ) )
    {
  if ( class_table[ch->class].attr_prime == STAT_CON )
      cost    = 1;
  stat      = STAT_CON;
  pOutput     = "constitution";
    }
        else if ( !str_cmp( argument, "agt" ) )
    {
  if ( class_table[ch->class].attr_prime == STAT_AGT )
      cost    = 1;
  stat        = STAT_AGT;
  pOutput     = "agility";
    }

    else if ( !str_cmp( argument, "end" ) )
    {
  if ( class_table[ch->class].attr_prime == STAT_END )
      cost    = 1;
  stat        = STAT_END;
  pOutput     = "endurance";
    }

    else if ( !str_cmp( argument, "soc" ) )
    {
  if ( class_table[ch->class].attr_prime == STAT_SOC )
      cost    = 1;
  stat        = STAT_SOC;
  pOutput     = "social";
    }
    else if ( !str_cmp(argument, "practice" ) )
  cost = 1;
    else if ( !str_cmp(argument, "hp" ) )
  cost = 1;

    else if ( !str_cmp(argument, "mana" ) )
  cost = 1;

    else if ( !str_cmp(argument, "moves" ) )
  cost = 1;
    else
    {
  strcpy( buf, "You can train:" );
  if ( ch->perm_stat[STAT_STR] < get_max_train(ch,STAT_STR)) 
      strcat( buf, " str" );
  if ( ch->perm_stat[STAT_INT] < get_max_train(ch,STAT_INT))  
      strcat( buf, " int" );
  if ( ch->perm_stat[STAT_WIS] < get_max_train(ch,STAT_WIS)) 
      strcat( buf, " wis" );
  if ( ch->perm_stat[STAT_DEX] < get_max_train(ch,STAT_DEX))  
      strcat( buf, " dex" );
  if ( ch->perm_stat[STAT_CON] < get_max_train(ch,STAT_CON))  
      strcat( buf, " con" );
  if ( ch->perm_stat[STAT_AGT] < get_max_train(ch,STAT_AGT)) 
      strcat( buf, " agt" );
  if ( ch->perm_stat[STAT_END] < get_max_train(ch,STAT_END)) 
      strcat( buf, " end" );
  if ( ch->perm_stat[STAT_SOC] < get_max_train(ch,STAT_SOC)) 
      strcat( buf, " soc" );
  strcat( buf, " practice");
  strcat( buf, " hp mana moves");

  if ( buf[strlen(buf)-1] != ':' )
  {
      strcat( buf, ".\n\r" );
      send_to_char( buf, ch );
  }
  else
  {
      /*
       * This message dedicated to Jordan ... you big stud!
       */
      act( "You have nothing left to train, you $T!",
    ch, NULL,
    ch->sex == SEX_MALE   ? "big stud" :
    ch->sex == SEX_FEMALE ? "hot babe" :
          "wild thing",
    TO_CHAR ,TRUE);
  }

  return;
    }

    if (!str_cmp("hp",argument))
    {
      if ( cost > ch->train )
      {
            send_to_char( "You don't have enough training sessions.\n\r", ch );
            return;
        }
 
  ch->train -= cost;
        ch->pcdata->perm_hit += 10;
        ch->max_hit += 10;
        ch->hit +=10;
        act( "Your durability increases!",ch,NULL,NULL,TO_CHAR,FALSE);
        act( "$n's durability increases!",ch,NULL,NULL,TO_ROOM,FALSE);
        return;
    }
 
    if (!str_cmp("mana",argument))
    {
        if ( cost > ch->train )
        {
            send_to_char( "You don't have enough training sessions.\n\r", ch );
            return;
        }

  ch->train -= cost;
        ch->pcdata->perm_mana += 10;
        ch->max_mana += 10;
        ch->mana += 10;
        act( "Your power increases!",ch,NULL,NULL,TO_CHAR,FALSE);
        act( "$n's power increases!",ch,NULL,NULL,TO_ROOM,FALSE);
        return;
    }

    if (!str_cmp("moves",argument))
    {
        if ( cost > ch->train )
        {
            send_to_char( "You don't have enough training sessions.\n\r", ch );
            return;
        }

  ch->train -= cost;
        ch->pcdata->perm_move += 10;
        ch->max_move += 10;
        ch->move += 10;
        act( "Your feet shuffle about!",ch,NULL,NULL,TO_CHAR,FALSE);
        act( "$n's feet shuffle about!",ch,NULL,NULL,TO_ROOM,FALSE);
        return;
    }

    if (!str_cmp("practice",argument))
    {
        if ( cost > ch->train )
        {
            send_to_char( "You don't have enough training sessions.\n\r", ch );
            return;
        }

	ch->train -= cost;
        ch->practice += 10;
        act( "You convert 1 train to 10 practices.",ch,NULL,NULL,TO_CHAR,FALSE);
        act( "$n converts trains to practices.",ch,NULL,NULL,TO_ROOM,FALSE);
	return;
    }

    if ( ch->perm_stat[stat]  >= get_max_train(ch,stat) )
    {
  act( "Your $T is already at maximum.", ch, NULL, pOutput, TO_CHAR ,FALSE);
  return;
    }

    if ( cost > ch->train )
    {
  send_to_char( "You don't have enough training sessions.\n\r", ch );
  return;
    }

    ch->train   -= cost;
  
    ch->perm_stat[stat]   += 1;
    act( "Your $T increases!", ch, NULL, pOutput, TO_CHAR ,FALSE);
    act( "$n's $T increases!", ch, NULL, pOutput, TO_ROOM ,FALSE);
    return;
}

void fade( CHAR_DATA *ch, char *argument )
{
   int skill;

   if (IS_SET(ch->mhs,MHS_GLADIATOR))
      return;

   skill = get_skill(ch,gsn_fade);

   if ( number_percent() * number_percent() < 6 &&
	number_percent() > skill )
   {
	if ( IS_SET(ch->mhs, MHS_FADE ) )
	{
    act("$n shimmers into existance before you.",ch,NULL,NULL,TO_ROOM,FALSE);
    act("You shimmer into existance.",ch,NULL,NULL,TO_CHAR,FALSE);
	    REMOVE_BIT(ch->mhs, MHS_FADE );
	}
	else
	{
	    act("$n vanishes!",ch,NULL,NULL,TO_ROOM,FALSE);
	    act("You vanish abruptly.",ch,NULL,NULL,TO_CHAR,FALSE);
	    SET_BIT(ch->mhs, MHS_FADE );
	}
	check_improve( ch, gsn_fade, TRUE, 10 );
   }

    return;
}


/* Original Drag by  "Artur 'Revinor' Biesiadowski" <abies@@pg.gda.pl> */
/* Modified by Poquah */
void do_drag( CHAR_DATA * ch, char * argument )
{
   char arg1[MAX_INPUT_LENGTH];
   char arg2[MAX_INPUT_LENGTH];
   OBJ_DATA  *obj;
   ROOM_INDEX_DATA *was_in;
   ROOM_INDEX_DATA *now_in;
   CHAR_DATA *vch;
   CHAR_DATA *victim; 
   bool found;
   int door;

   argument = one_argument (argument, arg1);
   one_argument (argument, arg2);

   if( is_affected(ch,skill_lookup("wraithform")) )
   {
   send_to_char("Not while in wraithform.\r\n",ch);
   return;
   }
   

   if (ch->fighting != NULL)
   {
      send_to_char("No way! You are still fighting.\n\r",ch);
      return;
   }

   /* Assume its Drag a Player */
   if ( ( victim = get_char_room( ch, arg1 ) ) != NULL )  
   {
      if(!IS_NPC(victim))
      {
         if (!is_clan(victim) || !is_clan(ch) ) 
         {
	    send_to_char("You can't drag them.\n\r",ch);
	    return;
	 }
      }

      if( is_affected(victim,skill_lookup("wraithform")) )
      {
      send_to_char("They're made of mist.\r\n",ch);
      return;
      }

    if ( is_clan_guard(victim) == TRUE )
    {
       send_to_char("You may not drag clan hall guards.\r\n",ch);
       return;
    }


      if ( victim->position > POS_SLEEPING )
      {
         act( "You try to drag $N out, but they are not co-operating.", 
	       ch,NULL,victim, TO_CHAR,FALSE);
         act( "$N tries to drag you out of the room.", 
	       victim,NULL,ch, TO_CHAR,FALSE);
         act( "$n tries to move $N, but they are not co-operating.",
	       ch,NULL,victim, TO_ROOM,FALSE);
         return;
      }
      if (IS_NPC(victim) && IS_SET(victim->act,ACT_AGGRESSIVE))
      {
	 send_to_char("No way, you might wake them!\n\r",ch);
	 return;
      }

      if (!IS_NPC(victim))
      {
	 if(ch->clan != victim->clan ||
	    ch->clan == clan_lookup("loner"))
	 {
	    if((is_same_group(ch,victim) &&
                IS_AFFECTED(victim, AFF_CHARM)) ||
		!is_same_group(ch,victim))
  send_to_char("They don't like you enough to let you drag them.\n\r",ch);
	    return;
	 }
      }

	    
      if ( ch->move < (victim->carry_weight/5) )
      {
         send_to_char("You are too exhausted to drag them.\n\r",ch);
         return;
      }

      if ( victim->carry_weight >  (2 * can_carry_w (ch)) )
      {
         act( "You try, but $N is too heavy.", ch, NULL, victim,TO_CHAR,FALSE);
         act( "$n tries to move $N, but fails.", ch, NULL, victim,TO_ROOM,FALSE);
         return;
      }

      if ( arg2[0] == '\0' )
      {
         send_to_char ( "Where do you want to drag them ?\n\r", ch);
         return;
      }

      was_in = ch->in_room;

      if( was_in->clan && is_same_clan(ch,victim) )
      {
	send_to_char( "They can move around the hall by themselves.\n\r",ch);
	return;
      }

      if ( ( door = find_exit( ch, arg2 ) ) < 0 )
         return;

      if (door < 0)
      {
	 send_to_char("You can not go that direction.\n\r",ch);
	 return;
      }

      move_char( ch, door, FALSE);

      if (ch->in_room == was_in)
         return;                      /* For some reason player didn't move */

      /* Dont move the victim if is they do not belong to that clan
	or the room is not ownered to them or the room is private */
      if ((ch->in_room->clan && (victim->clan != ch->in_room->clan ||
			 (!IS_NPC(victim) && IS_SET(victim->pcdata->clan_flags, CLAN_NO_HALL)  ) ) )
         || (!is_room_owner(victim,ch->in_room) 
	     && room_is_private(victim,ch->in_room)))  
         return;

      char_from_room(victim);
      char_to_room(victim,ch->in_room);

      ch->move -= apply_chi(ch,(victim->carry_weight/5));  

      act( "You dragged $N with you.", ch, NULL,victim,TO_CHAR,FALSE );
      act( "$n dragged $N into the room.", ch, NULL,victim, TO_ROOM,FALSE );

      if ( !(vch = was_in->people) )
         return;
      
      now_in = ch->in_room;
      ch->in_room = was_in;

      act( "$n dragged $N out of the room.", ch, NULL,victim, TO_ROOM,FALSE );
      ch->in_room = now_in;

   }
   else
   {
   /* Has to be drag an object then */
      obj = get_obj_list( ch, arg1, ch->in_room->contents );
      if ( !obj )
      {
         send_to_char ( "I do not see anything like that here.\n\r", ch);
         return;
      }
  
      /* ITEM_DRAGGABLE is flag which I added for items which I want to be dragged
         but not to be taken ( for example wagon in mine ).
         If you dislike this idea comment it out */

      if ( (!IS_SET( obj->wear_flags, ITEM_TAKE ) && 
           (!IS_SET( obj->wear_flags, ITEM_DRAGGABLE ) ) ) )
      {
 act( "You try to drag $p, but without success.", ch,obj, NULL, TO_CHAR,FALSE);
 act( "$n tries to move $p, but it doesn't budge.",ch,obj, NULL, TO_ROOM,FALSE);
         return;
      }

      /* Only Clanmates and Groupmates or Yourself can drag your corpse */
      if (obj->item_type == ITEM_CORPSE_PC && !IS_IMMORTAL(ch))
      {
	 found = FALSE;
         for ( victim = char_list; victim != NULL; victim = vch)
         {
            vch  = victim->next;
            if (is_name(obj->owner,victim->name))
            {
               found = TRUE;
               break;
            }
         }

         if(found && victim != ch) 
	 {
            if (!is_same_group( victim, ch ))
	    {
	       if(ch->clan != victim->clan || ch->clan == clan_lookup("loner"))
	       {
	      send_to_char("You are not allowed to drag the corpse.\n\r",ch);
	          return;
	       }
	    }
	 }
      }

      if ( ch->move < (obj->weight/10) )
      {
         send_to_char("You are too exhausted to drag it.\n\r",ch);
         return;
      }

      if (count_users(obj) > 0 )
      {
      send_to_char("Someone is using that right now!", ch);
      return;
      }

      if ( obj->weight >  (2 * can_carry_w (ch)) )
      {
         act( "You try, but $p is too heavy.", ch, obj, NULL, TO_CHAR,FALSE);
         act( "$n tries to move $p, but fails.", ch, obj, NULL, TO_CHAR,FALSE);
         return;
      }

      if ( arg2[0] == '\0' )
      {
         send_to_char ( "Where do you want to drag it ?\n\r", ch);
         return;
      }

      was_in = ch->in_room;

      if ( ( door = find_exit( ch, arg2 ) ) < 0 )
         return;

      if (door < 0 )
      {
	 send_to_char("You can not go in that direction.\n\r",ch); 
	 return;
      }

      move_char( ch, door, FALSE);

      if (ch->in_room == was_in )
         return;                      /* For some reason player didn't move */

      obj_from_room (obj);
      obj_to_room (obj, ch->in_room);

      ch->move -= apply_chi(ch,(obj->weight/10));  

      act( "You dragged $p with you.", ch, obj, NULL, TO_CHAR,FALSE );
      act( "$n dragged $p into the room.", ch, obj, NULL, TO_ROOM,FALSE );

      if ( !(vch = was_in->people) )
         return;
      
      now_in = ch->in_room;
      ch->in_room = was_in;

      act( "$n dragged $p out of the room.", ch, obj,NULL, TO_ROOM,FALSE );
      ch->in_room = now_in;
   }
   
   return;
}

void do_wraithform_return(CHAR_DATA *ch)
{ /*start brace for wraithform_return*/

  if( !is_affected(ch,skill_lookup("wraithform")) )
  {
    send_to_char( "But you aren't in wraithform.\r\n",ch);
    return;
  }
  WAIT_STATE(ch,48);
  act( "$n becomes less shadowy.\r\n", ch, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( "You regain your material body.\n\r", ch );
  affect_strip(ch,skill_lookup("wraithform"));
  return;
}/*endbrace for wraithform_return*/

void do_abolish( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char arg[MAX_INPUT_LENGTH];
    bool found = FALSE;
    AFFECT_DATA *paf, *paf_next;

    one_argument( argument, arg );

    if ( ch->class != class_lookup("paladin") )
    {
	send_to_char("You aren't a paladin.\n\r",ch);
	return;
    }

    if ( (victim=get_char_room(ch,arg)) == NULL )
    {
	send_to_char("You can't find that person.\n\r",ch);
	return;
    }

    if ( !IS_NPC(ch) && ch->pcdata->abolish_timer > 0 )
    {
	send_to_char("Your deity will not grant your request.\n\r",ch);
	return;
    }
    
    if ( IS_NPC(victim) )
    {
        send_to_char("Abolish a mob? Yeah right.\r\n",ch);
	return;
    }
    if ( !is_clan(ch) && (victim->pcdata && victim->pcdata->quit_time > 0) )
    {
        send_to_char("They've just come from a pfight, are you sure you want to violate the Big Rule?\r\n",ch);
        return;
    }

    ch->pcdata->abolish_timer = 60 - (ch->level/2);
   
    /* Remove any of these affects that are poison/plague related */ 
   for ( paf = victim->affected ; paf != NULL ; paf = paf_next )
   {
	paf_next = paf->next;
 
	if ( is_abolishable( paf ) )
	{
	    found = TRUE;
	    affect_remove( victim, paf, APPLY_BOTH );
            victim->hit = UMIN( victim->hit + (number_range(ch->level,ch->level*2)), victim->max_hit );
	}
   }

    if ( found )
    {
	 ch->pcdata->abolish_timer = 200 - (ch->level*3);
	 act("$n regains $s health as the sickness leaves $m.",victim,NULL,NULL,TO_ROOM,FALSE);
	 act("You regain your health as the sickness leaves you and a warm sensation flows through your body.",victim,NULL,NULL,TO_CHAR,FALSE);
    }
    else
	send_to_char("That person isn't sick.\n\r",ch);
	
    return;
}

bool is_abolishable( AFFECT_DATA *af )
{
     int sn = af->type;

     if ( 	sn == skill_lookup("poison")
 ||             sn == skill_lookup("dust storm")
 ||		sn == skill_lookup("plague")
 ||	af->where == DAMAGE_OVER_TIME )
	return TRUE;

	return FALSE;
}

void action_ambush( CHAR_DATA *ch, char *argument )
{
	/* STUB to be filled in */
}

void do_knock(CHAR_DATA *ch, char *argument)
{
  /* Constructs taken from do_open().  */
  int door;
  char arg[MAX_INPUT_LENGTH];

  one_argument(argument,arg);

  if (arg[0] == '\0')
    {
      send_to_char("Knock on what?\n\r",ch);
      return;
    }

  if ( ( door = find_door( ch, arg ) ) >= 0 )
    {
      ROOM_INDEX_DATA *to_room;
      EXIT_DATA *pexit;
      EXIT_DATA *pexit_rev;

      pexit = ch->in_room->exit[door];
      act( "$n knocks on the $d.", ch, NULL, pexit->keyword, TO_ROOM,FALSE);
      act( "You knock on the $d.", ch, NULL, pexit->keyword, TO_CHAR,FALSE);

      /* Notify the other side.  */
      if (   ( to_room   = pexit->u1.to_room            ) != NULL
          && ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
          && pexit_rev->u1.to_room == ch->in_room )
        {
          CHAR_DATA *rch;
          for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
            act( "You hear someone knocking.", rch, NULL, pexit_rev->keyword, TO_CHAR,FALSE);
        }
    }

  return;
}
@


1.189
log
@making it so you cannot drag mobs
added a !clan check to the guard mob specs
did somethign in update.c but can't remember, oh yeah i thin i remember
now somethign with outcasts...
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.188 2003/05/25 17:41:44 boogums Exp $";
d2843 6
a2859 6
      if ( IS_NPC(victim) )
      {
         send_to_char("Drag a mob?  Why?  Just beat them up instead.\r\n",ch);
         return;
      }
/*
a2864 1
*/
@


1.188
log
@damn bit vectors
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.187 2003/05/25 14:32:21 boogums Exp $";
d2854 6
a2859 1

d2865 1
@


1.187
log
@DOH damn bitvecotrs :)
orey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.186 2003/05/25 01:34:22 boogums Exp $";
d2460 1
a2460 1
    ||   IS_SET(ch->mhs,MHS_CURSE)
@


1.186
log
@ok adding MHS_CURSE
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.185 2003/03/27 16:18:52 rusty Exp $";
d2460 1
a2460 1
    ||   IS_AFFECTED(ch, MHS_CURSE)
@


1.185
log
@Ogres not smelling themselves as remorts when they walk around or gate.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.184 2003/03/09 21:44:27 boogums Exp $";
d2460 1
@


1.184
log
@t adding some stuff to abolish
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.183 2003/01/04 17:55:43 boogums Exp $";
d676 1
a676 1
	  if (fch->race == race_lookup("ogre")) 
d765 1
a765 1
      if (fch->race == race_lookup("ogre")) 
@


1.183
log
@putting some slipfall when the weather's bad
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.182 2003/01/03 19:41:52 boogums Exp $";
d3099 5
a3103 1

d3137 1
@


1.182
log
@3jan02
making turn undead wands less effective
making dispel magic scrolls less effective
making precious pab flag white for the blind players we have
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.181 2002/11/19 04:42:15 boogums Exp $";
d220 1
d228 7
a234 6
#ifdef COREYTEST
    if ( !IS_IMMORTAL(ch) && !IS_NPC(ch) && IS_OUTSIDE(ch) 
    &&
    (  ch->race != race_lookup("elf") 
    || ch->kit  != kit_lookup("ranger")
    || !IS_AFFECTED(ch, AFF_FLYING) 
d236 1
a236 2
      weather_info.sky = SKY_LIGHTNING
      weather_info.sky = SKY_LIGHTNING
d238 22
a259 1
#endif
@


1.181
log
@added a timer to traps
user feedback for the aura of cthon spell
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.180 2002/11/12 03:04:59 boogums Exp $";
d226 12
@


1.180
log
@adding the perk to the abolish ability
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.179 2002/10/28 03:55:27 ndagger Exp $";
d878 1
a878 1
    af.duration = -1;
@


1.179
log
@10/27/02 Nightdagger:  Changed abolish reset timer, old timer was nasty.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.178 2002/10/06 22:49:42 boogums Exp $";
d3059 7
d3078 1
d3086 1
a3086 1
	 act("You regain your health as the sickness leaves you.",victim,NULL,NULL,TO_CHAR,FALSE);
@


1.178
log
@added the knock command
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.177 2002/10/05 16:23:55 boogums Exp $";
d3060 1
a3060 1
    ch->pcdata->abolish_timer = 200 - (ch->level*3);
@


1.177
log
@tweaking walking drunk
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.176 2002/10/05 16:02:31 boogums Exp $";
d3101 38
@


1.176
log
@making them act like confusion when drunk oh the RP oh the RP
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.175 2002/05/21 20:20:58 rage Exp $";
d896 1
a896 1
   if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10) )
d930 1
a930 1
  if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10) )
d962 1
a962 1
     if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10) )
d995 1
a995 1
    if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10) )
d1028 1
a1028 1
    if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10) )
d1061 1
a1061 1
    if (is_affected(ch, gsn_confusion) || (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10) )
@


1.175
log
@dropped potion costs for alchemy
added randomly teleporting portal for Slodhain area
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.174 2002/04/17 15:11:53 poquah Exp $";
d896 1
a896 1
   if (is_affected(ch, gsn_confusion))
d930 1
a930 1
  if (is_affected(ch, gsn_confusion))
d962 1
a962 1
     if (is_affected(ch, gsn_confusion))
d995 1
a995 1
    if (is_affected(ch, gsn_confusion))
d1028 1
a1028 1
    if (is_affected(ch, gsn_confusion))
d1061 1
a1061 1
    if (is_affected(ch, gsn_confusion))
@


1.174
log
@fixed spelling mistake in dismount
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.173 2002/03/12 03:06:29 rusty Exp $";
d2461 3
a2463 2
    ch->move *= 50;
    ch->move /= apply_chi(ch,100);
@


1.173
log
@Training HMV back in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.172 2002/03/11 04:38:40 rusty Exp $";
d200 1
a200 1
	act("$n dismouts from $N.",ch,NULL,mount,TO_NOTVICT,FALSE);
@


1.172
log
@Train into 10 practices
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.171 2002/03/11 02:27:19 rusty Exp $";
a2590 1
/*
a2598 1
*/
d2619 1
a2619 1
// strcat( buf, " hp mana moves");
d2641 1
a2641 1
/*
d2692 1
a2692 1
*/
@


1.171
log
@Took out training HMV
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.170 2002/03/09 19:14:26 rusty Exp $";
d2589 2
d2620 1
d2695 15
@


1.170
log
@Hiding information and reup_affect() additions. Initial
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.169 2002/01/26 16:25:26 rage Exp $";
d2589 1
a2589 1

d2598 1
a2598 1

d2618 1
a2618 1
  strcat( buf, " hp mana moves");
d2640 1
a2640 1

d2691 1
a2691 1

@


1.169
log
@whole mess of bug fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.168 2001/11/11 02:04:40 rage Exp $";
d2566 23
d2612 6
@


1.168
log
@final version of wall of ice
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.167 2001/11/11 01:25:15 rage Exp $";
d2837 2
a2838 1
      if ((ch->in_room->clan && victim->clan != ch->in_room->clan)
@


1.167
log
@second try at wall of ice
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.166 2001/10/13 02:11:59 rage Exp $";
d256 1
d258 2
@


1.166
log
@Bug fixes as follow

can no longer drag furniture that's being used
steal/slice kr only increments on players
IMMs now immune to sector damage
die command should work now
spec_average now has an IS_AWAKE check
Cavalier attack is now given to groupmates
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.165 2001/09/23 20:25:04 rage Exp $";
d247 11
@


1.165
log
@some changes to spec_elemental stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.164 2001/09/22 17:41:18 rage Exp $";
d2899 6
@


1.164
log
@Upped level of rename command to 59
Fixed bug with cavalier
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.163 2001/09/21 01:40:51 rage Exp $";
a210 1
    CHAR_DATA *caster;
@


1.163
log
@some changes to new sector type, and fixed wall of fire
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.162 2001/07/27 02:14:10 guerrand Exp $";
d662 1
a662 1
	  damage(ch,ch,dice(12,paf->level),gsn_wall_fire, DAM_FIRE, FALSE, FALSE);
@


1.162
log
@Added spirit caller kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.161 2001/07/25 04:10:46 guerrand Exp $";
d659 7
a665 2
	 caster = get_char_by_id( paf->caster_id );
	 damage(caster, ch,dice(12,paf->level),gsn_wall_fire, DAM_FIRE, FALSE, TRUE);
@


1.161
log
@Fixed traps.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.160 2001/07/24 02:14:24 guerrand Exp $";
d497 1
@


1.160
log
@Nother fix to sassins
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.159 2001/07/24 02:07:25 guerrand Exp $";
d815 1
a815 1
    if ( !IS_NPC(ch) || ch->pcdata->trap_timer > 0 )
@


1.159
log
@Fixed traps again - adjusted to 0-1 tick delay.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.158 2001/07/23 03:51:41 guerrand Exp $";
d864 1
a864 1
    ch->pcdata->trap_timer = number_percent( ) % 2;
@


1.158
log
@
Adjustments for traps.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.157 2001/07/19 01:41:25 rage Exp $";
d864 1
a864 1
    ch->pcdata->trap_timer = 5;
@


1.157
log
@first attempt at spec_elemental_fire
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.156 2001/07/15 19:57:20 rage Exp $";
d815 6
d826 1
d864 1
d866 1
a866 1
    WAIT_STATE(ch,36);
@


1.156
log
@fix to room_update
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.155 2001/07/12 00:14:26 rage Exp $";
d659 1
a659 1
	 damage(caster, ch,dice(12,paf->level),gsn_wall_fire, DAM_FIRE, TRUE, TRUE);
@


1.155
log
@changes to wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.154 2001/07/08 17:14:10 guerrand Exp $";
d659 1
a659 1
	 damage(caster, ch,dice(12,paf->level),gsn_wall_fire, DAM_FIRE, FALSE, FALSE);
@


1.154
log
@MOre XP drop.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.153 2001/07/04 03:10:41 guerrand Exp $";
d211 1
d215 1
d643 1
d651 10
@


1.153
log
@FIxed a minor bug with hamstring movement.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.152 2001/07/04 02:29:28 guerrand Exp $";
d847 1
@


1.152
log
@Hamstring done.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.151 2001/07/04 01:21:55 guerrand Exp $";
d244 1
@


1.151
log
@Extensive changes to wraithform to have it proc after the timer expires.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.150 2001/06/15 02:27:51 guerrand Exp $";
d238 8
@


1.150
log
@PAladin abolish disease ability.  Neat!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.149 2001/06/03 23:20:06 guerrand Exp $";
d2993 5
@


1.149
log
@And, at least, the final stages of secret and concealed flags are done!
-GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.148 2001/03/03 18:53:56 mud Exp $";
d2930 64
@


1.148
log
@Took out all references to damage_old() and used iOld var in damage()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.147 2001/02/10 03:25:21 mud Exp $";
d1059 1
a1059 1
    int door;
d1069 3
d1086 1
a1086 1
  act( "I see no door $T here.", ch, NULL, arg, TO_CHAR ,FALSE);
d1096 5
@


1.147
log
@Removed unused buf var
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.146 2000/12/15 06:09:58 mud Exp $";
d531 2
a532 2
	     damage_old(ch,ch,(110 - swim)/6 + ch->level/3,gsn_swim,
			DAM_DROWNING,FALSE);
d550 1
a550 1
      damage_old(ch,ch,UMAX(1,move * 3),gsn_poison,DAM_POISON,FALSE);
@


1.146
log
@14DEC00
Ok forgot the lag when they cast, it lags em before the affect takes
hold.  also had to put a check in autoassist
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.145 2000/12/14 04:49:09 mud Exp $";
a218 1
    char buf[MAX_STRING_LENGTH];
@


1.145
log
@13DEC00
Yippie another clean compile.  Added checks for put, get, sacrifice,
open close, movement related commands
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.144 2000/12/14 03:50:28 mud Exp $";
d2916 1
a2916 1

a2919 1
  WAIT_STATE(ch,48);
@


1.144
log
@13DEC00
Ok, i added the unwraith skill in interp.*, put a {Black Aura) in
act_info.c and modified the fight message
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.143 2000/12/12 20:43:20 mud Exp $";
d116 7
d1107 7
d1206 7
d1316 7
d1431 7
d2432 7
d2674 7
d2698 7
@


1.143
log
@No dragging your clanmates around if they are inside clan
hall.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.142 2000/12/09 07:05:46 mud Exp $";
d2851 16
@


1.142
log
@08DEC00
DAMN this wraithform it's gone now :)
=Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.141 2000/12/07 06:45:43 mud Exp $";
d2701 6
@


1.141
log
@ok got all the necromancer stuff out trying to restore order
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.140 2000/12/07 05:46:08 mud Exp $";
a116 6
	/*if(IS_AFFECTED(ch,skill_lookup("wraithform")))
	{
	  send_to_char("Ghost riders in the sky?  I don't think so.\n\r",ch);
	  return;
	}
        */
a1294 7
    /*Wraithform check -Boogums*/
    /*if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
    {
      send_to_char("You are a mist, you can not unlock the door.\r\n",ch);
      return;
    }
    */
a1402 6
   /*if( IS_AFFECTED(ch,skill_lookup("wraithform")) ) 
    {
      send_to_char("You can not unlock doors while in wraith form.\r\n",ch);
      return;
    }
    */
a2844 16
/*void do_wraithform_return(CHAR_DATA *ch)
{

  if(!IS_AFFECTED(ch,skill_lookup("wraithform")))
    {
      send_to_char( "But you aren't in wraithform.\r\n",ch);
      return;
    }

  act( "$n becomes less shadowy.\r\n", ch, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( "You regain your material body.\n\r", ch );
  affect_strip(ch,skill_lookup("wraithform"));
  WAIT_STATE(ch,48);
  return;

}*/
@


1.140
log
@06DEC00
Ok no AFF_WRAITHFORM had to change those to skill_lookups
compiled clean testing now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.139 2000/12/03 19:12:07 mud Exp $";
d117 1
a117 1
	if(IS_AFFECTED(ch,skill_lookup("wraithform")))
d122 1
d1302 1
a1302 1
    if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
d1307 1
a1307 1

d1416 1
a1416 1
   if( IS_AFFECTED(ch,skill_lookup("wraithform")) ) 
d1421 1
a1421 1

d2864 2
a2865 2
void do_wraithform_return(CHAR_DATA *ch)
{ /*start brace for wraithform_return*/
d2879 1
a2879 1
} /*endbrace for wraithform_return*/
@


1.139
log
@03DEC00
Ok let's see if this strips the affect
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.138 2000/12/03 18:47:44 mud Exp $";
d117 1
a117 1
	if(IS_AFFECTED(ch,AFF_WRAITHFORM))
d1301 1
a1301 1
    if( IS_AFFECTED(ch,AFF_WRAITHFORM) )
d1415 1
a1415 1
   if( IS_AFFECTED(ch,AFF_WRAITHFORM) ) 
d2866 1
a2866 1
  if(!IS_AFFECTED(ch,AFF_WRAITHFORM))
@


1.138
log
@03DEC00
Ok i think i fixd the crashbug in wraithform remove
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.137 2000/12/03 17:50:29 mud Exp $";
d2874 1
a2874 1
  affect_strip(ch,AFF_WRAITHFORM);
@


1.137
log
@03DEC00
Ok I have added teh unwraith and am going to check the logic with a player
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.136 2000/12/03 03:23:59 mud Exp $";
d2874 1
a2874 1
  affect_remove(ch,AFF_WRAITHFORM,APPLY_BOTH);
@


1.136
log
@2DEC00 - Ok here goes teh necromancer kit.  changes in act_info.c act_move.c
         act_obj.c const.c figt.c mag2.c magic.c magic.h merc.h update.c
	 all sorts of cool stuff
	 -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.135 2000/10/12 23:12:37 mud Exp $";
d116 6
d2863 17
@


1.135
log
@rewriting drag routing
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.134 2000/10/12 23:00:23 mud Exp $";
d1294 7
d1408 7
@


1.134
log
@missing bracket
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.133 2000/10/12 22:58:46 mud Exp $";
d2667 2
a2668 9
	 if (ch->clan != clan_lookup("loner"))
	 {
	    if(ch->clan != victim->clan)
	    {
  send_to_char("They don't like you enough to let you drag them.\n\r",ch);
	       return;
	    }
	 }
	 else
a2672 1
	    {
d2674 1
a2674 3
	       return;
	    }

@


1.133
log
@cant circumvent dragging people not in your clan
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.132 2000/09/09 03:51:31 mud Exp $";
d2678 1
a2678 1
                IS_AFFECTED(victim, AFF_CHARM) ||
@


1.132
log
@08SEP00 - DOH! did fix in act_move.c so that Imms can now mount any mount
          -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.131 2000/09/04 05:40:45 mud Exp $";
d2667 1
a2667 1
         if (!is_same_group( victim, ch ))
d2669 1
a2669 1
	    if(ch->clan != victim->clan || ch->clan == clan_lookup("loner"))
d2674 11
@


1.131
log
@03SEP00 - Many thanks to Rage for pointin out why it wasn't working :)
          clean compile.  changes made to fight.c and do_mount
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.130 2000/08/28 03:58:37 mud Exp $";
d130 1
a130 1
	if (mount->master != ch)
@


1.130
log
@27AUG00- Taking out thae addition to mount code, seems to crash
the game - Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.129 2000/08/27 23:23:05 mud Exp $";
d122 1
a122 8
/* 26-AUG-00 by Boogums - Check to see if the mount belongs to the person only
   checks on warhorses 
	if( (mount->mhs,MHS_WARHORSE && mount->leader != ch))
	{
	    send_to_char("That warhorse does not belong to you.\n\r",ch);
	    return;
	}
*/
d129 6
@


1.129
log
@27-Aug-00 Making skill point tracker work in skills.c - Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.128 2000/08/18 00:06:55 mud Exp $";
d123 1
a123 1
   checks on warhorses */
d129 1
@


1.128
log
@so clan sanctions dont crash us on mobs
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.127 2000/08/17 14:29:27 mud Exp $";
d120 7
@


1.127
log
@ first implementation of "sanction" command for clan leaders
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.126 2000/08/12 18:26:01 mud Exp $";
d303 1
a303 1
     if (ch->clan && IS_SET(ch->pcdata->clan_flags, CLAN_NO_HALL) &&
@


1.126
log
@ added second deity gift for almighty, "banishment"
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.125 2000/07/12 23:31:30 mud Exp $";
d301 8
@


1.125
log
@add gladiator.h include
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.124 2000/07/12 23:23:08 mud Exp $";
d293 9
@


1.124
log
@added a new act 'l' to handle shapemorphed/glads descriptions in stead of names
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.123 2000/07/11 23:26:43 mud Exp $";
d30 1
@


1.123
log
@gladiators can not shapemorph and will not fade by accident
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.122 2000/05/26 01:50:45 mud Exp $";
d538 5
a542 1
  act( "$n leaves $T.", ch, NULL, dir_name[door], TO_ROOM ,FALSE);
d545 5
a549 1
  act( "$n swims $T.", ch, NULL, dir_name[door], TO_ROOM ,FALSE);
d616 3
a618 9
           if (IS_SET(ch->mhs,MHS_SHAPEMORPHED))
           {
              for ( fch = ch->in_room->people; fch != NULL; fch = fch_next )
              {
                 fch_next = fch->next_in_room;
		 sprintf(buf,"%s has arrived.",ch->long_descr);
		 send_to_char(buf,fch);
	      }
           }
@


1.122
log
@missing buf
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.121 2000/05/26 01:46:24 mud Exp $";
d2558 3
@


1.121
log
@team gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.120 2000/05/26 01:04:19 mud Exp $";
d203 1
@


1.120
log
@increaded movement loss (based on ch level now)
added a half move pen if earthbind
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.119 2000/05/25 23:47:28 mud Exp $";
d607 11
a617 1
  act( "$n has arrived.", ch, NULL, NULL, TO_ROOM ,FALSE);
@


1.119
log
@ Mods to earthbind ( can flee now, but cost you 10 extra moves per square)
 Can't reanimate into a corpse whihc is in a clan hall
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.118 2000/05/24 02:53:24 mud Exp $";
d451 1
a451 1
	move +=10;
@


1.118
log
@trap fixes, non clanners can't use it
similar to hold person now, snare puts yuou in resting position
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.117 2000/05/23 04:55:40 mud Exp $";
d215 1
a215 1

d221 1
d449 4
@


1.117
log
@more gladiator stuff
-poqa
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.116 2000/05/23 04:12:37 mud Exp $";
d748 7
d781 1
a781 1
    af.modifier = is_clan(ch);  /* Clan/nonclanner traps */
d1605 5
@


1.116
log
@clean up some gladiator stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.115 2000/05/13 22:53:15 mud Exp $";
d2110 6
d2159 6
@


1.115
log
@Cleaning up warnings, declared clan_lookup
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.114 2000/04/21 23:08:25 mud Exp $";
d77 6
@


1.114
log
@ changed the level on trap affect, trap level is now = ch level
 instead of ch + obj level
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.113 2000/04/18 20:24:25 mud Exp $";
d36 1
@


1.113
log
@act ( fixes
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.112 2000/04/18 19:50:51 mud Exp $";
d764 1
a764 1
    af.level = ch->level + obj->level;
@


1.112
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.111 2000/04/17 22:00:44 mud Exp $";
d1763 1
a1763 1
      act ("$n wakes up and starts resting.",ch,NULL,NULL,TO_ROOM);
d1913 1
a1913 1
              act("$n wakes and sits at $p.",ch,obj,NULL,TO_ROOM,FALSE,FALSE);
d1919 1
a1919 1
              act("$n wakes and sits at $p.",ch,obj,NULL,TO_ROOM,FALSE,FALSE);
d1925 1
a1925 1
              act("$n wakes and sits in $p.",ch,obj,NULL,TO_ROOM,FALSE,FALSE);
d2648 2
a2649 2
      act ( "You dragged $N with you.", ch, NULL,victim,TO_CHAR );
      act ( "$n dragged $N into the room.", ch, NULL,victim, TO_ROOM );
d2657 1
a2657 1
      act ( "$n dragged $N out of the room.", ch, NULL,victim, TO_ROOM );
d2750 2
a2751 2
      act ( "You dragged $p with you.", ch, obj, NULL, TO_CHAR );
      act ( "$n dragged $p into the room.", ch, obj, NULL, TO_ROOM );
d2759 1
a2759 1
      act ( "$n dragged $p out of the room.", ch, obj,NULL, TO_ROOM );
@


1.111
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.110 2000/04/17 20:15:24 mud Exp $";
d84 2
a85 2
	    act("$n fades into existence.",ch,NULL,NULL,TO_ROOM);
	    act("You fade into existence.",ch,NULL,NULL,TO_CHAR);
d90 2
a91 2
	    act("$n shimmers and fades away.",ch,NULL,NULL,TO_ROOM);
	    act("You shimmer and fade away.",ch,NULL,NULL,TO_CHAR);
d130 1
a130 1
	    act("$N isn't accepting riders.",ch,NULL,mount,TO_CHAR);
d136 1
a136 1
	    act("$N already has a rider.",ch,NULL,mount,TO_CHAR);
d142 1
a142 1
	    act("$N is occupied.",ch,NULL,mount,TO_CHAR);
d155 3
a157 3
	act("$n mounts $N.",ch,NULL,mount,TO_NOTVICT);
	act("You mount $N.",ch,NULL,mount,TO_CHAR);
	act("$n mounts you.",ch,NULL,mount,TO_VICT);
d175 3
a177 3
	act("You dismount.",ch,NULL,mount,TO_CHAR);
	act("$n dismounts you.",ch,NULL,mount,TO_VICT);
	act("$n dismouts from $N.",ch,NULL,mount,TO_NOTVICT);
d291 1
a291 1
  	act( "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
d418 2
a419 2
		act("{GYou drop $p to move unhindered.{x",ch,obj,NULL,TO_CHAR);
		act("$n drops $p.",ch,obj,NULL,TO_ROOM);
d522 1
a522 1
  act("$n leaves $t riding $N.",ch,dir_name[door],mount,TO_NOTVICT);
d525 1
a525 1
  act( "$n leaves $T.", ch, NULL, dir_name[door], TO_ROOM );
d528 1
a528 1
  act( "$n swims $T.", ch, NULL, dir_name[door], TO_ROOM );
d539 1
a539 1
	   act("$n sneaks $t.",ch, dir_name[door], fch, TO_VICT);
d593 1
a593 1
  act( "$n arrives riding $N.",ch,NULL,mount,TO_NOTVICT);
d595 1
a595 1
  act( "$n has arrived.", ch, NULL, NULL, TO_ROOM );
d606 1
a606 1
	   act("$n sneaks into the room.",ch, NULL, fch, TO_VICT);
d613 2
a614 2
	 act("$n trips and falls over!",ch,NULL,NULL,TO_ROOM);
	 act("You trip and fall over.",ch,NULL,NULL,TO_CHAR);
d627 1
a627 1
     act_new( "$n sets off your orb.", ch, NULL, fch, TO_VICT,POS_SLEEPING );
d691 1
a691 1
        ch,NULL,fch,TO_CHAR);
d693 1
a693 1
        fch,NULL,NULL,TO_CHAR);
d700 1
a700 1
      act( "You follow $N.", fch, NULL, ch, TO_CHAR );
d1013 1
a1013 1
  act( "I see no $T here.", ch, NULL, arg, TO_CHAR );
d1019 1
a1019 1
  act( "I see no door $T here.", ch, NULL, arg, TO_CHAR );
d1072 2
a1073 2
      act("You open $p.",ch,obj,NULL,TO_CHAR);
      act("$n opens $p.",ch,obj,NULL,TO_ROOM);
d1088 2
a1089 2
  act("You open $p.",ch,obj,NULL,TO_CHAR);
  act( "$n opens $p.", ch, obj, NULL, TO_ROOM );
d1107 1
a1107 1
  act( "$n opens the $d.", ch, NULL, pexit->keyword, TO_ROOM );
d1119 1
a1119 1
    act( "The $d opens.", rch, NULL, pexit_rev->keyword, TO_CHAR );
d1162 2
a1163 2
      act("You close $p.",ch,obj,NULL,TO_CHAR);
      act("$n closes $p.",ch,obj,NULL,TO_ROOM);
d1176 2
a1177 2
  act("You close $p.",ch,obj,NULL,TO_CHAR);
  act( "$n closes $p.", ch, obj, NULL, TO_ROOM );
d1193 1
a1193 1
  act( "$n closes the $d.", ch, NULL, pexit->keyword, TO_ROOM );
d1205 1
a1205 1
    act( "The $d closes.", rch, NULL, pexit_rev->keyword, TO_CHAR );
d1279 2
a1280 2
      act("You lock $p.",ch,obj,NULL,TO_CHAR);
      act("$n locks $p.",ch,obj,NULL,TO_ROOM);
d1297 2
a1298 2
  act("You lock $p.",ch,obj,NULL,TO_CHAR);
  act( "$n locks $p.", ch, obj, NULL, TO_ROOM );
d1321 1
a1321 1
  act( "$n locks the $d.", ch, NULL, pexit->keyword, TO_ROOM );
d1387 2
a1388 2
      act("You unlock $p.",ch,obj,NULL,TO_CHAR);
      act("$n unlocks $p.",ch,obj,NULL,TO_ROOM);
d1405 2
a1406 2
  act("You unlock $p.",ch,obj,NULL,TO_CHAR);
  act( "$n unlocks $p.", ch, obj, NULL, TO_ROOM );
d1429 1
a1429 1
  act( "$n unlocks the $d.", ch, NULL, pexit->keyword, TO_ROOM );
d1478 1
a1478 1
    ch, NULL, gch, TO_CHAR );
d1520 2
a1521 2
      act("You pick the lock on $p.",ch,obj,NULL,TO_CHAR);
      act("$n picks the lock on $p.",ch,obj,NULL,TO_ROOM);
d1543 2
a1544 2
        act("You pick the lock on $p.",ch,obj,NULL,TO_CHAR);
        act("$n picks the lock on $p.",ch,obj,NULL,TO_ROOM);
d1568 1
a1568 1
  act( "$n picks the $d.", ch, NULL, pexit->keyword, TO_ROOM );
d1621 1
a1621 1
    ch,obj,NULL,TO_ROOM,POS_DEAD);
d1635 1
a1635 1
      act( "$n wakes and stands up.", ch, NULL, NULL, TO_ROOM );
d1640 2
a1641 2
     act_new("You wake and stand at $p.",ch,obj,NULL,TO_CHAR,POS_DEAD);
     act("$n wakes and stands at $p.",ch,obj,NULL,TO_ROOM);
d1645 2
a1646 2
      act_new("You wake and stand on $p.",ch,obj,NULL,TO_CHAR,POS_DEAD);
      act("$n wakes and stands on $p.",ch,obj,NULL,TO_ROOM);
d1650 2
a1651 2
      act_new("You wake and stand in $p.",ch,obj,NULL,TO_CHAR,POS_DEAD);
      act("$n wakes and stands in $p.",ch,obj,NULL,TO_ROOM);
d1661 1
a1661 1
      act( "$n stands up.", ch, NULL, NULL, TO_ROOM );
d1666 2
a1667 2
      act("You stand at $p.",ch,obj,NULL,TO_CHAR);
      act("$n stands at $p.",ch,obj,NULL,TO_ROOM);
d1671 2
a1672 2
      act("You stand on $p.",ch,obj,NULL,TO_CHAR);
      act("$n stands on $p.",ch,obj,NULL,TO_ROOM);
d1676 2
a1677 2
      act("You stand in $p.",ch,obj,NULL,TO_CHAR);
      act("$n stands on $p.",ch,obj,NULL,TO_ROOM);
d1750 1
a1750 1
      act_new("There's no more room on $p.",ch,obj,NULL,TO_CHAR,POS_DEAD);
d1768 2
a1769 2
        ch,obj,NULL,TO_CHAR,POS_SLEEPING);
      act("$n wakes up and rests at $p.",ch,obj,NULL,TO_ROOM);
d1774 2
a1775 2
                    ch,obj,NULL,TO_CHAR,POS_SLEEPING);
            act("$n wakes up and rests on $p.",ch,obj,NULL,TO_ROOM);
d1780 2
a1781 2
                    ch,obj,NULL,TO_CHAR,POS_SLEEPING);
            act("$n wakes up and rests in $p.",ch,obj,NULL,TO_ROOM);
d1794 1
a1794 1
      act( "$n sits down and rests.", ch, NULL, NULL, TO_ROOM );
d1798 2
a1799 2
      act("You sit down at $p and rest.",ch,obj,NULL,TO_CHAR);
      act("$n sits down at $p and rests.",ch,obj,NULL,TO_ROOM);
d1803 2
a1804 2
      act("You sit on $p and rest.",ch,obj,NULL,TO_CHAR);
      act("$n sits on $p and rests.",ch,obj,NULL,TO_ROOM);
d1808 2
a1809 2
      act("You rest in $p.",ch,obj,NULL,TO_CHAR);
      act("$n rests in $p.",ch,obj,NULL,TO_ROOM);
d1818 1
a1818 1
      act("$n rests.",ch,NULL,NULL,TO_ROOM);
d1822 2
a1823 2
      act("You rest at $p.",ch,obj,NULL,TO_CHAR);
      act("$n rests at $p.",ch,obj,NULL,TO_ROOM);
d1827 2
a1828 2
      act("You rest on $p.",ch,obj,NULL,TO_CHAR);
      act("$n rests on $p.",ch,obj,NULL,TO_ROOM);
d1832 2
a1833 2
      act("You rest in $p.",ch,obj,NULL,TO_CHAR);
      act("$n rests in $p.",ch,obj,NULL,TO_ROOM);
d1895 1
a1895 1
      act_new("There's no more room on $p.",ch,obj,NULL,TO_CHAR,POS_DEAD);
d1907 1
a1907 1
              act( "$n wakes and sits up.", ch, NULL, NULL, TO_ROOM );
d1911 3
a1913 2
              act_new("You wake and sit at $p.",ch,obj,NULL,TO_CHAR,POS_DEAD);
              act("$n wakes and sits at $p.",ch,obj,NULL,TO_ROOM);
d1917 3
a1919 2
              act_new("You wake and sit on $p.",ch,obj,NULL,TO_CHAR,POS_DEAD);
              act("$n wakes and sits at $p.",ch,obj,NULL,TO_ROOM);
d1923 3
a1925 2
              act_new("You wake and sit in $p.",ch,obj,NULL,TO_CHAR,POS_DEAD);
              act("$n wakes and sits in $p.",ch,obj,NULL,TO_ROOM);
d1935 2
a1936 2
    act("You sit at $p.",ch,obj,NULL,TO_CHAR);
    act("$n sits at $p.",ch,obj,NULL,TO_ROOM);
d1941 2
a1942 2
    act("You sit on $p.",ch,obj,NULL,TO_CHAR);
    act("$n sits on $p.",ch,obj,NULL,TO_ROOM);
d1953 1
a1953 1
              act("$n sits down on the ground.",ch,NULL,NULL,TO_ROOM);
d1957 2
a1958 2
    act("You sit down at $p.",ch,obj,NULL,TO_CHAR);
    act("$n sits down at $p.",ch,obj,NULL,TO_ROOM);
d1962 2
a1963 2
    act("You sit on $p.",ch,obj,NULL,TO_CHAR);
    act("$n sits on $p.",ch,obj,NULL,TO_ROOM);
d1967 2
a1968 2
    act("You sit down in $p.",ch,obj,NULL,TO_CHAR);
    act("$n sits down in $p.",ch,obj,NULL,TO_ROOM);
d2004 1
a2004 1
      act( "$n goes to sleep.", ch, NULL, NULL, TO_ROOM );
d2031 1
a2031 1
        ch,obj,NULL,TO_CHAR,POS_DEAD);
d2038 2
a2039 2
    act("You go to sleep at $p.",ch,obj,NULL,TO_CHAR);
    act("$n goes to sleep at $p.",ch,obj,NULL,TO_ROOM);
d2043 2
a2044 2
          act("You go to sleep on $p.",ch,obj,NULL,TO_CHAR);
          act("$n goes to sleep on $p.",ch,obj,NULL,TO_ROOM);
d2048 2
a2049 2
    act("You go to sleep in $p.",ch,obj,NULL,TO_CHAR);
    act("$n goes to sleep in $p.",ch,obj,NULL,TO_ROOM);
d2081 1
a2081 1
  { act( "$N is already awake.", ch, NULL, victim, TO_CHAR ); return; }
d2085 1
a2085 1
  { act( "You can't wake $M!",   ch, NULL, victim, TO_CHAR );  return; }
d2087 1
a2087 1
    act_new( "$n wakes you.", ch, NULL, victim, TO_VICT,POS_SLEEPING );
d2235 1
a2235 1
    act( "$n prays for transportation!", ch, 0, 0, TO_ROOM );
d2295 1
a2295 1
    act( "$n disappears.", ch, NULL, NULL, TO_ROOM );
d2299 1
a2299 1
    act( "$n appears in the room.", ch, NULL, NULL, TO_ROOM );
d2431 1
a2431 1
    TO_CHAR );
d2449 2
a2450 2
        act( "Your durability increases!",ch,NULL,NULL,TO_CHAR);
        act( "$n's durability increases!",ch,NULL,NULL,TO_ROOM);
d2466 2
a2467 2
        act( "Your power increases!",ch,NULL,NULL,TO_CHAR);
        act( "$n's power increases!",ch,NULL,NULL,TO_ROOM);
d2483 2
a2484 2
        act( "Your feet shuffle about!",ch,NULL,NULL,TO_CHAR);
        act( "$n's feet shuffle about!",ch,NULL,NULL,TO_ROOM);
d2490 1
a2490 1
  act( "Your $T is already at maximum.", ch, NULL, pOutput, TO_CHAR );
d2503 2
a2504 2
    act( "Your $T increases!", ch, NULL, pOutput, TO_CHAR );
    act( "$n's $T increases!", ch, NULL, pOutput, TO_ROOM );
d2519 2
a2520 2
	    act("$n shimmers into existance before you.",ch,NULL,NULL,TO_ROOM);
	    act("You shimmer into existance.",ch,NULL,NULL,TO_CHAR);
d2525 2
a2526 2
	    act("$n vanishes!",ch,NULL,NULL,TO_ROOM);
	    act("You vanish abruptly.",ch,NULL,NULL,TO_CHAR);
d2574 1
a2574 1
	       ch,NULL,victim, TO_CHAR);
d2576 1
a2576 1
	       victim,NULL,ch, TO_CHAR);
d2578 1
a2578 1
	       ch,NULL,victim, TO_ROOM);
d2609 2
a2610 2
         act( "You try, but $N is too heavy.", ch, NULL, victim,TO_CHAR);
         act( "$n tries to move $N, but fails.", ch, NULL, victim,TO_ROOM);
d2678 2
a2679 2
         act( "You try to drag $p, but without success.", ch,obj, NULL, TO_CHAR);
         act( "$n tries to move $p, but it doesn't budge.",ch,obj, NULL, TO_ROOM);
d2718 2
a2719 2
         act( "You try, but $p is too heavy.", ch, obj, NULL, TO_CHAR);
         act( "$n tries to move $p, but fails.", ch, obj, NULL, TO_CHAR);
@


1.110
log
@ Added delay to hide.
 If hidden, attmpting a slice unhides you.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.109 2000/04/16 15:31:36 mud Exp $";
d538 1
a538 1
	   && can_see(fch,ch))
d605 1
a605 1
	   && can_see(fch,ch))
@


1.109
log
@earthbind mods, immune if not flying
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.108 2000/04/03 20:19:55 mud Exp $";
d2160 2
a2161 1
    if ( number_percent( ) < get_skill(ch,gsn_hide))
d2166 1
d2172 1
@


1.108
log
@infiltrate/moves check
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.107 2000/03/08 14:28:33 mud Exp $";
a213 1

d500 2
@


1.107
log
@cant drag while fighting
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.106 2000/03/07 15:40:12 mud Exp $";
d264 5
d307 5
d369 5
@


1.106
log
@-dont try to pick up bags not pickables
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.105 2000/03/07 15:32:29 mud Exp $";
d2530 6
@


1.105
log
@get your bags when you stand
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.104 2000/02/28 05:34:37 mud Exp $";
d1675 1
a1675 1
    if (obj_on !=NULL && !is_clan(ch))
@


1.104
log
@ ok, try this again, you can now infiltrate guilds
 without preventing everyone from movign :(

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.103 2000/02/28 05:17:34 mud Exp $";
d1573 1
d1674 3
@


1.103
log
@ fixed movement bug
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.102 2000/02/27 17:21:28 mud Exp $";
d358 14
a371 1
            send_to_char( "You aren't allowed in there.\n\r", ch );
@


1.102
log
@ added guilds in possible rooms types for rogues

 added checks in can_see_obj for pills and potions spells types
 if potion/pill has cure blind or cancel on it, you can see it when blind

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.101 2000/02/27 00:20:16 mud Exp $";
d341 1
a341 1
        if ( number_percent() < get_skill(ch,gsn_infiltrate)
d354 5
a358 1
        }
@


1.101
log
@ doh, messed  up, could walk into any clan hall..all good now :(
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.100 2000/02/26 23:39:43 mud Exp $";
d341 14
a354 5
  if ( ok == FALSE  && fRoom == TRUE )
  {
    send_to_char( "You aren't allowed in there.\n\r", ch );
    return;
  }
@


1.100
log
@ infiltrate back in, can't infiltrate clan halls

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.99 2000/02/23 05:11:59 mud Exp $";
d255 1
d261 1
a261 1
     /*  if ( is_clan(ch) && number_percent() < get_skill(ch, gsn_infiltrate)
d275 3
@


1.99
log
@cant drag corpse either
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.98 2000/02/23 00:22:44 mud Exp $";
d260 1
a260 1
       if ( is_clan(ch) && number_percent() < get_skill(ch, gsn_infiltrate)
d273 1
@


1.98
log
@loners must be in same grouup to drag
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.97 2000/02/22 23:45:57 mud Exp $";
d2490 1
d2618 27
@


1.97
log
@can only drag clanmates/groupmates
only canmates/groupmates can get your corpse
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.96 2000/02/06 20:15:35 mud Exp $";
d2526 1
a2526 1
         if (!is_same_group( victim, ch ) && ch->clan != victim->clan)
d2528 2
d2531 2
a2532 1
	    return;
@


1.96
log
@ fixed bug with ogre smelling wrong kinds of remoprts


 -Rage.
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.95 2000/01/21 01:06:13 mud Exp $";
d2526 1
a2526 1
	 if (victim->clan != ch->clan || !is_same_group (victim,ch) )
d2528 2
a2529 22
            if (IS_SET(victim->act,PLR_KILLER) 
	       || IS_SET(victim->act,PLR_THIEF))
	    {
               if (victim->level + 12 < ch->level &&
	  	 str_cmp(ch->pcdata->last_attacked_by,victim->name))
               {
                  if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                     send_to_char("Pick on someone your own size.\n\r",ch);
                  return;
	       }
            }
            else
            {
	     /* Victim is a Thug or Ruffian */
               if (ch->level > victim->level + (victim->trumps > 0 ? 10 : 8) &&  
	  	 str_cmp(ch->pcdata->last_attacked_by,victim->name))
	       {
                  if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                     send_to_char("Pick on someone your own size.\n\r",ch);
                  return;
               }
            }
d2532 1
@


1.95
log
@ fixed a missing bracket, whoops
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.94 2000/01/21 00:53:13 mud Exp $";
d523 2
a525 2
	           send_to_char("The scent of decay is gone.\n\r",fch);
	        if(IS_SET(ch->act,PLR_MUMMY))
d592 2
a594 2
               send_to_char("The scent of decay makes your head dizzy.\n\r",fch);
            if(IS_SET(ch->act,PLR_MUMMY))
@


1.94
log
@Added new spelll confusion.
Confuses victims sense of direction
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.93 2000/01/08 08:05:12 mud Exp $";
d757 1
d791 1
d823 1
d856 1
d889 1
d921 1
@


1.93
log
@can now train moves
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.92 1999/12/19 22:02:29 mud Exp $";
d735 23
d759 2
a760 1
    return;
d767 24
d799 26
a824 2
    move_char( ch, DIR_SOUTH, FALSE );
    return;
d831 25
a855 1
    move_char( ch, DIR_WEST, FALSE );
d863 23
d887 1
d895 25
a919 1
    move_char( ch, DIR_DOWN, FALSE );
@


1.92
log
@Drag changes
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.91 1999/12/19 21:57:02 mud Exp $";
d2191 3
d2207 1
a2207 1
  strcat( buf, " hp mana");
d2261 17
@


1.91
log
@Double move cost of drag and put levle limits on drag
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.90 1999/11/30 22:32:19 mud Exp $";
d2356 1
a2356 1
	 if (victim->clan != ch->clan)
@


1.90
log
@lower the movement costs for dragging things
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.89 1999/11/30 01:32:38 mud Exp $";
d2354 30
a2383 1
      if ( ch->move < (victim->carry_weight/10) )
d2428 1
a2428 1
      ch->move -= apply_chi(ch,(victim->carry_weight/10));  
@


1.89
log
@Add chanace of Ogre smell not working
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.88 1999/11/30 01:12:55 mud Exp $";
d2354 1
a2354 1
      if ( ch->move < (victim->carry_weight/5) )
d2399 1
a2399 1
      ch->move -= apply_chi(ch,(victim->carry_weight/5));  
d2436 1
a2436 1
      if ( ch->move < obj->weight/5 )
d2474 1
a2474 1
      ch->move -= apply_chi(ch,(obj->weight/5));  
@


1.88
log
@Something fun for Ogre's, ability to smell Remorts
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.87 1999/11/26 19:56:12 mud Exp $";
d519 9
a527 6
	     if(IS_SET(ch->act,PLR_VAMP))
	        send_to_char("The strange odor of blood is gone.\n\r",fch);
	     if(IS_SET(ch->act,PLR_WERE))
	        send_to_char("The scent of decay is gone.\n\r",fch);
	     if(IS_SET(ch->act,PLR_MUMMY))
	        send_to_char("The smell of filthy fur is gone.\n\r",fch);
d588 9
a596 6
         if(IS_SET(ch->act,PLR_VAMP))
            send_to_char("The strange odor of blood makes you feel uncomfortable.\n\r",fch);
         if(IS_SET(ch->act,PLR_WERE))
            send_to_char("The scent of decay makes your head dizzy.\n\r",fch);
         if(IS_SET(ch->act,PLR_MUMMY))
            send_to_char("The smell of filthy fur fills up the air.\n\r",fch);
@


1.87
log
@Dont allow dragging people into your clan hall unless they are in clan
same with private rooms
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.86 1999/11/25 04:12:24 mud Exp $";
d509 20
d581 11
@


1.86
log
@drag clanners
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.85 1999/11/25 04:11:43 mud Exp $";
a2346 2
      char_from_room(victim);
      char_to_room(victim,ch->in_room);
d2349 1
a2349 4
      if (ch->in_room == was_in || victim->in_room == was_in)
      {
	 char_from_room(victim);
	 char_to_room(victim,ch->in_room);
d2351 10
a2360 1
      }
d2399 1
a2399 1
      if ( ch->move < obj->weight )
d2437 1
a2437 1
      ch->move -= apply_chi(ch,obj->weight);  
@


1.85
log
@Only drag NPC's or clanners, if you are  a clanners
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.84 1999/11/25 04:02:01 mud Exp $";
d2293 1
a2293 1
         if (!is_clan(victim) ) 
@


1.84
log
@Add loss of moves for drag object
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.83 1999/11/25 01:58:33 mud Exp $";
d2291 1
a2291 1
      if (!is_clan(ch) || (is_clan(ch) && (!IS_NPC(victim) && !is_clan(victim))))
d2293 5
a2297 2
	 send_to_char("You can't drag them.\n\r",ch);
	 return;
@


1.83
log
@Syntax error missing ;
-pOuqha
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.82 1999/11/25 01:57:27 mud Exp $";
d2392 6
d2429 2
@


1.82
log
@Subtract moves for dragigng the victim
-Poqiah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.81 1999/11/25 01:28:05 mud Exp $";
d2355 1
a2355 1
      ch->move -= apply_chi(ch,(victim->carry_weight/5))
@


1.81
log
@Can not drag aggies, and cant drag into private room if it would over limit the room
-POquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.80 1999/11/24 07:37:14 mud Exp $";
a2284 3
   send_to_char ("Drag - Under Construction.\n\r",ch);
   return;

d2314 6
d2354 2
@


1.80
log
@Remove Drag for now
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.79 1999/11/24 07:20:45 mud Exp $";
d2311 6
a2340 1
      move_char( ch, door, FALSE);
d2343 1
d2346 3
d2350 1
@


1.79
log
@Fixed a syntax error in drag
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.78 1999/11/24 07:19:18 mud Exp $";
d2284 3
@


1.78
log
@Drag people and things
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.77 1999/11/24 07:10:30 mud Exp $";
d2304 1
a2304 1
	       ch,NULL,victim TO_ROOM);
@


1.77
log
@Drag man drag
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.76 1999/11/24 07:01:57 mud Exp $";
d2299 6
a2304 6
         act( "You try to drag $N out, but they are not co-operating.\n\r", 
	       ch,victim, NULL, TO_CHAR);
         act( "$N tries to drag you out of the room.\n\r", 
	       victim,ch, NULL, TO_CHAR);
         act( "$N tries to move $N, but they are not co-operating.\n\r",
	       ch,victim, NULL, TO_ROOM);
d2310 2
a2311 2
         act( "You try, but $N is too heavy.\n\r", ch, victim, NULL, TO_CHAR);
         act( "$n tries to move $N, but fails.\n\r", ch, victim, NULL, TO_ROOM);
d2339 2
a2340 2
      act ( "You dragged $n with you.\n\r", ch, victim,NULL,TO_CHAR );
      act ( "$n dragged $N into the room.\n\r", ch, NULL,victim, TO_ROOM );
d2348 1
a2348 1
      act ( "$n dragged $N out of the room.\n\r", ch, NULL,victim, TO_ROOM );
d2369 2
a2370 2
         act( "You try to drag $p, but without success.\n\r", ch,obj, NULL, TO_CHAR);
         act( "$n tries to move $p, but it doesn't budge.\n\r",ch,obj, NULL, TO_ROOM);
d2376 2
a2377 2
         act( "You try, but $p is too heavy.\n\r", ch, obj, NULL, TO_CHAR);
         act( "$n tries to move $p, but fails.\n\r", ch, obj, NULL, TO_CHAR);
d2406 2
a2407 2
      act ( "You dragged $p with you.\n\r", ch, obj, NULL, TO_CHAR );
      act ( "$n dragged $p into the room.\n\r", ch, obj, NULL, TO_ROOM );
d2415 1
a2415 1
      act ( "$n dragged $p out of the room.\n\r", ch, obj,NULL, TO_ROOM );
@


1.76
log
@Drag messaings.. what a pain in the ass
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.75 1999/11/24 06:29:40 mud Exp $";
d2339 1
a2339 1
      act ( "You dragged $N with you.\n\r", ch, victim, NULL, TO_CHAR );
d2348 1
a2348 1
      act ( "$n dragged $N out of the room.\n\r", ch, victim,NULL, TO_ROOM );
d2369 1
a2369 1
         act( "You try to drag $p, but without succes.\n\r", ch,obj, NULL, TO_CHAR);
@


1.75
log
@Tweak the drag 'acts' so the messages are correct, I think
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.74 1999/11/24 06:00:13 mud Exp $";
d2279 2
a2280 1
   ROOM_INDEX_DATA *rvnum;
a2283 1
   char buf[MAX_INPUT_LENGTH];
d2321 1
a2321 1
      rvnum = ch->in_room;
d2336 1
a2336 1
      if (ch->in_room == rvnum || victim->in_room == rvnum)
d2339 2
a2340 2
      act ( "You dragged $n with you.\n\r", ch, victim, NULL, TO_CHAR );
      act ( "$n dragged $n into the room.\n\r", ch, victim, NULL, TO_ROOM );
d2342 1
a2342 1
      if ( !(vch = rvnum->people) )
d2344 3
d2348 2
a2349 2
      act ( "$n dragged $n out of the room.\n\r", vch, ch, victim, TO_CHAR );
      act ( "$n dragged $n out of the room.\n\r", vch, ch, victim, TO_ROOM );
d2387 1
a2387 1
      rvnum = ch->in_room;
d2400 1
a2400 1
      if (ch->in_room == rvnum )
d2409 1
a2409 1
      if ( !(vch = rvnum->people) )
d2411 3
d2415 2
a2416 2
      act ( "$n dragged $p out of the room.\n\r", vch, ch, obj, TO_CHAR );
      act ( "$n dragged $p out of the room.\n\r", vch, ch, obj, TO_ROOM );
@


1.74
log
@Drag people and things
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.73 1999/11/24 05:43:47 mud Exp $";
d2291 6
d2339 2
a2340 2
      act ( "You dragged $N with you.\n\r", ch, victim, NULL, TO_CHAR );
      act ( "$N dragged $N into the room.\n\r", ch, victim, NULL, TO_ROOM );
d2345 2
a2346 2
      act ( "$N dragged $N out.\n\r", vch, victim, ch, TO_CHAR );
      act ( "$N dragged $N out.\n\r", vch, victim, ch, TO_ROOM );
d2404 1
a2404 1
      act ( "$n dragged $p with $?.\n\r", ch, obj, NULL, TO_ROOM );
d2409 2
a2410 2
      act ( "$N dragged $p out.\n\r", vch, obj, ch, TO_CHAR );
      act ( "$N dragged $p out.\n\r", vch, obj, ch, TO_ROOM );
@


1.73
log
@debugging drag
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.72 1999/11/24 05:39:39 mud Exp $";
a2287 3
      sprintf (buf, "a1= %s a2= %s\n\r",arg1,arg2);
      send_to_char(buf,ch);

d2327 2
a2332 2
      move_char (victim, door, FALSE);

a2345 1
   send_to_char("a1",ch);
a2377 1
   send_to_char("a2",ch);
d2379 1
a2379 1
send_to_char ("2",ch);
a2388 1
send_to_char ("3",ch);
a2390 1
send_to_char ("4",ch);
a2396 1
send_to_char ("5",ch);
@


1.72
log
@Drag me out and beat me silly
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.71 1999/11/24 05:05:31 mud Exp $";
d2349 1
d2382 1
@


1.71
log
@Moved Drag to after drink
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.70 1999/11/24 05:03:13 mud Exp $";
d61 1
d743 14
d2320 1
a2320 1
      if ( ( door = find_door( ch, arg2 ) ) < 0 )
d2323 6
d2383 1
a2383 1
      if ( ( door = find_door( ch, arg2 ) ) < 0 )
d2385 6
@


1.70
log
@Drag code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.69 1999/11/24 01:31:01 mud Exp $";
d2268 1
@


1.69
log
@Drag players as well as object
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.68 1999/11/24 01:25:24 mud Exp $";
d2272 3
d2360 1
a2360 1

d2364 1
d2367 1
d2374 1
@


1.68
log
@Drag command
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.67 1999/11/19 05:41:16 mud Exp $";
d2286 1
a2286 1
      if ( victim->weight >  (2 * can_carry_w (ch)) )
d2301 1
a2301 1
      if ( ( door = find_door( ch, arg ) ) < 0 )
d2358 1
a2358 1
      if ( ( door = find_door( ch, arg ) ) < 0 )
@


1.67
log
@Varioety of changes.   faerie fog stuff mostly
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.66 1999/10/07 01:48:00 mud Exp $";
d2254 126
@


1.66
log
@Changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.65 1999/10/05 20:06:54 mud Exp $";
d1842 5
d1887 5
@


1.65
log
@Added return statements for do_rest and do_sleep and dismount
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.64 1999/10/02 00:09:05 mud Exp $";
d457 7
a463 1
      damage_old(ch,ch,move * 5,gsn_poison,DAM_POISON,FALSE);
@


1.64
log
@New Shapeshifter Power - Shapemorph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.63 1999/09/21 22:49:35 mud Exp $";
d1451 1
d1721 1
@


1.63
log
@Fade changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.62 1999/09/18 21:46:39 mud Exp $";
d2066 1
a2066 1
    if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
@


1.62
log
@Crahs bug fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.61 1999/09/06 20:40:33 mud Exp $";
d72 6
@


1.61
log
@Fix typo in fading
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.60 1999/09/02 03:43:10 mud Exp $";
d1443 4
d1581 6
a1586 1
    
d1711 4
@


1.60
log
@Some basic bug fixes to mounted code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.59 1999/09/02 03:18:50 mud Exp $";
d78 1
a78 1
	    act("You fade itno existence.",ch,NULL,NULL,TO_CHAR);
@


1.59
log
@More mouted code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.58 1999/09/01 22:12:14 mud Exp $";
d462 1
a462 1
  act("$n leaves $T riding $N.",ch,dir_name[door],mount,TO_NOTVICT);
@


1.58
log
@Fixed last mount bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.57 1999/08/28 16:34:25 mud Exp $";
d462 1
a462 1
  act("$n leaves $T riding $N.",ch,NULL,mount,TO_NOTVICT);
@


1.57
log
@Variety of changes
-spellcraft change
-added color to hindered dropping stuff
-poison damage when moving
-chain lightning is 2 rounds
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.56 1999/08/23 03:34:40 mud Exp $";
d444 4
a447 1
  ch->move -= apply_chi(ch,move);
@


1.56
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.55 1999/08/12 01:03:54 mud Exp $";
d366 1
a366 1
		act("You drop $p to move unhindered.",ch,obj,NULL,TO_CHAR);
d392 1
a392 1
      move = 1;
d445 6
@


1.55
log
@Nethermancers are in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.54 1999/08/11 05:38:44 mud Exp $";
d63 1
a63 2

void do_mount( CHAR_DATA *ch, char *argument )
d65 2
a66 9
    CHAR_DATA *mount;
    char arg[MAX_INPUT_LENGTH];

    if ( IS_NPC(ch) )
	return;

    one_argument( argument, arg );

    if ( ch->mount != NULL )
d68 1
a68 1
	send_to_char("You are already mounted.\n\r",ch);
d72 1
a72 1
    if ( arg[0] == '\0' )
d74 12
a85 1
	send_to_char("What do you want to ride?\n\r",ch);
d89 63
a151 3
    if ( ( mount = get_char_room(ch,arg) ) == NULL )
    {
	send_to_char("You cannot find that target.\n\r",ch);
d153 18
a170 1
    }
d172 1
d178 1
d208 2
a381 1

d394 1
a394 1
  if ( ch->move < move )
d400 7
d450 6
d457 2
a458 1
      else
d487 7
d499 4
d504 1
d1993 1
@


1.54
log
@fixed another recall error
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.53 1999/08/11 04:55:48 mud Exp $";
d2070 27
@


1.53
log
@Many many changes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.52 1999/08/11 02:29:37 mud Exp $";
d1814 1
a1814 1
	&& fPray 
@


1.52
log
@Fixed the mysterious crash bug :)
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.51 1999/08/10 23:02:58 mud Exp $";
d410 1
a410 1
      if ( number_percent() > (get_curr_stat(ch,STAT_DEX)*6) ) 
@


1.51
log
@Fixed an ineffectual 'bug' that produced a lot of warnings but didn't hurt anything.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.50 1999/08/10 23:00:54 mud Exp $";
a1794 1
    char arg[MAX_STRING_LENGTH];
a1811 1
    one_argument(argument, arg);
@


1.50
log
@Added a bit to hassan's special
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.49 1999/08/09 22:08:25 mud Exp $";
d36 1
@


1.49
log
@Removed all of Rusty's cheat codes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.48 1999/07/21 01:13:25 mud Exp $";
d1785 5
d1791 1
a1791 1
void do_recall( CHAR_DATA *ch, char *argument )
d1815 1
a1815 1
	&& str_cmp(arg,"x2y2z2g3v4kk5") 
@


1.48
log
@Fixed some stuff with fumble so everybody shuts the fuck upo
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.47 1999/07/14 18:13:26 mud Exp $";
d185 1
a185 1
    &&   !IS_TRUSTED(ch,ANGEL) && !IS_SET(ch->act,PLR_OLD))
@


1.47
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_move.c,v 1.46 1999/06/28 06:34:16 mud Exp $";
d409 1
a409 1
      if ( number_percent() > (get_curr_stat(ch,STAT_DEX)*4) ) 
@


1.46
log
@Fixed skill levels
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.45 1999/06/17 15:36:08 mud Exp $ */
@


1.45
log
@Addded NOCLAN room flag not allowing clanners in rooms
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.44 1999/06/12 18:51:41 mud Exp $ */
d507 1
a507 1
	|| ch->level < skill_table[gsn_trap].skill_level[ch->class] )
@


1.44
log
@Fixed typo's to exhausted too exhausted
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.43 1999/05/28 12:07:03 mud Exp $ */
d154 1
a154 1
      || room_is_private(to_room))
d203 1
a203 1
    if ( !is_room_owner(ch,to_room) && room_is_private( to_room ) )
@


1.43
log
@Put hold person back in do_stand
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.42 1999/05/28 10:14:31 mud Exp $ */
d1085 1
a1085 1
        send_to_char("You're to exhausted.\n\r",ch);
d1698 1
a1698 1
        send_to_char("You're to exhausted.\n\r",ch);
d1738 1
a1738 1
        send_to_char("You're to exhausted.\n\r",ch);
@


1.42
log
@Test Hold Person bug
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.41 1999/05/27 12:21:07 mud Exp $ */
d1209 1
a1209 1
/*
a1214 1
    */
@


1.41
log
@Proper check for sneak and hide affects for garotte.
Added hide affect strip to visible() command.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.40 1999/05/16 21:36:43 mud Exp $ */
d1209 1
a1209 1

d1215 1
@


1.40
log
@Can not train while shapeshifted
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.39 1999/05/15 16:39:00 mud Exp $ */
d1776 1
@


1.39
log
@Rangers.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.38 1999/04/25 17:25:49 mud Exp $ */
d1921 7
@


1.38
log
@Hold person smackdown
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.37 1999/04/23 23:43:37 mud Exp $ */
d306 3
@


1.37
log
@Change all PLR_HIGHLANDER to MHS_HIGHLANDER and moved under MHS bit
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.36 1999/04/18 02:38:29 mud Exp $ */
d1206 6
@


1.36
log
@Highlanders can breathe underwater.
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.35 1999/04/18 00:12:41 mud Exp $ */
d151 1
a151 1
   if (IS_SET(ch->act,PLR_HIGHLANDER))  
d318 1
a318 1
        if (IS_SET(ch->act,PLR_HIGHLANDER))
d373 1
a373 1
    if (IS_SET(ch->act,PLR_HIGHLANDER))
d378 1
a378 1
	  if (IS_SET(fch->act,PLR_HIGHLANDER) && fch != ch)
d433 1
a433 1
    if (IS_SET(ch->act,PLR_HIGHLANDER))
d443 1
a443 1
	  if (IS_SET(fch->act,PLR_HIGHLANDER) && ch != fch)
@


1.35
log
@Move Highlander Sense Messages to after do_look
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.34 1999/04/17 23:20:07 mud Exp $ */
d317 5
@


1.34
log
@Send message to Highlander entering room as well as those in room
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.33 1999/04/17 22:46:22 mud Exp $ */
a383 21
    if (IS_SET(ch->act,PLR_HIGHLANDER))
    {
       if (fHighlander)
       {
	  send_to_char("The tingle in your neck stops and the presence of the other Highlander is gone.\n\r",ch);
	  fHighlander = FALSE;
       }
       for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
       {
	  fch_next = fch->next_in_room;
	  if (IS_SET(fch->act,PLR_HIGHLANDER) && ch != fch)
	  {
	     send_to_char("Your neck tingles as you feel the presence of another Highlander.\n\r",fch);
	     fHighlander = TRUE;
	  }
       }
       if (fHighlander)
       {
	  send_to_char("Your neck tingles as you feel the presence of another Highlander.\n\r",ch);
       }
    }
d427 22
@


1.33
log
@Highlanders dont need to sense themselves
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.32 1999/04/17 09:27:12 mud Exp $ */
d105 1
d375 1
d386 5
d397 1
d399 4
@


1.32
log
@Highlanders sense to other Highlanders in room
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.31 1999/04/13 02:27:33 mud Exp $ */
d372 1
a372 1
	  if (IS_SET(fch->act,PLR_HIGHLANDER))
d387 1
a387 1
	  if (IS_SET(fch->act,PLR_HIGHLANDER))
@


1.31
log
@Error with Highlanders entering rooms
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.30 1999/04/13 02:20:09 mud Exp $ */
d367 12
d381 12
@


1.30
log
@Highlanders can not enter private rooms, townhomes or clan halls
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.29 1999/04/08 22:48:08 mud Exp $ */
d150 1
a150 2
   if (IS_SET(act,PLR_HIGHLANDER) && (to_room->clan || is_room_owner(ch,to_room)
      || room_is_private(to_room)))
d152 6
a157 2
      send_to_char("You are a Highlander, go out and fight, There can be only one!\n\r",ch);
      return;
@


1.29
log
@No more spamming up infiltrate when you're out of moves.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.28 1999/01/11 19:37:32 mud Exp $ */
d149 7
@


1.28
log
@Added kludge_string[] definition.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.27 1999/01/11 19:31:03 mud Exp $ */
d152 5
@


1.27
log
@() typo fix.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.26 1999/01/11 19:28:08 mud Exp $ */
d37 1
@


1.26
log
@More stuff to prevent cheese ways of getting out of charm.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.25 1999/01/11 19:23:12 mud Exp $ */
d1263 1
a1263 1
      if (IS_AFFECTED(ch,AFF_CHARM) && str_cmp(kludge_string,"order")
d1403 1
a1403 1
      if (IS_AFFECTED(ch,AFF_CHARM) && str_cmp(kludge_string,"order")
d1526 1
a1526 1
      if (IS_AFFECTED(ch,AFF_CHARM) && str_cmp(kludge_string,"order")
@


1.25
log
@Changes to take out cheap ways of escaping charm.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.24 1999/01/07 18:51:17 mud Exp $ */
d1263 6
d1403 6
d1528 1
a1528 1
	    act("$N is your beloved master.",ch,NULL,victim,TO_CHAR);
@


1.24
log
@Added ninjitsu check_improve() if sneak successful.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.23 1999/01/03 01:19:06 mud Exp $ */
d1514 6
@


1.23
log
@Infiltrating rogues, can no longer recall, or use healers while in an eney clan hall.  Slice moidified to limit the number of objects that fall out on a successful slice.

Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.22 1999/01/02 17:39:52 mud Exp $ */
d1630 1
@


1.22
log
@Sneaking players leaving and arriving show to IMM's with HOLYLIGHT.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.21 1999/01/01 19:00:05 mud Exp $ */
d1713 2
a1714 1
    if ( ch->in_room->area->no_transport )
@


1.21
log
@Fnail try to get this bug out of infiltrate, removed infiltrating into guild
halls temporarily.

R.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.20 1999/01/01 17:27:08 mud Exp $ */
d339 12
d356 12
@


1.20
log
@Last try at finally fixing the bug in infiltrate
r.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.19 1999/01/01 17:20:56 mud Exp $ */
a224 16
        if (ch->class == class_lookup("rogue")
	&& (number_percent() <= get_skill(ch,gsn_infiltrate) ))
	 {
	   ok = TRUE;
           cost += 5;
	   check_improve(ch,gsn_infiltrate,TRUE,2);
	   send_to_char("You infiltrate the guild hall\n\r",ch);
	   break;
         }
        else
       	{
	check_improve(ch,gsn_infiltrate,FALSE,4);
	   break;
        }
	    
      
@


1.19
log
@Another bug fix in infiltrate
rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.18 1999/01/01 17:18:17 mud Exp $ */
d152 1
a152 1
       && (ch->pcdata && ch->pcdata->quit_time == 0 && !IS_IMMORTAL (ch)))
d189 1
a189 1
	&& (ch->pcdata && ch->pcdata->quit_time == 0 && !IS_IMMORTAL (ch)))
@


1.18
log
@Bug fix in infiltrate

Rage
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.17 1998/12/31 21:25:53 mud Exp $ */
d189 1
a189 1
	(ch->pcdata && ch->pcdata->quit_time == 0 && !IS_IMMORTAL (ch)))
@


1.17
log
@Adding Rage's changes.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.16 1998/12/31 18:26:00 mud Exp $ */
d152 1
a152 1
       && (ch->pcdata && ch->pcdata->quit_time > 0 && !IS_IMMORTAL (ch)))
d189 1
a189 1
	(ch->pcdata && ch->pcdata->quit_time > 0 && !IS_IMMORTAL (ch)))
d224 1
a224 1

d240 1
a240 1
      }
@


1.16
log
@old_class allows you into a guild hall.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.15 1998/12/28 19:55:58 mud Exp $ */
d151 2
a152 1
       if ( is_clan(ch) && number_percent() < get_skill(ch, gsn_infiltrate) )
d188 2
a189 1
        if ( number_percent() < get_skill(ch,gsn_infiltrate) )
d223 2
a224 1
	
d228 1
a228 1
	   fRoom = FALSE;
d232 1
d235 5
a239 2
       	   check_improve(ch,gsn_infiltrate,FALSE,4);
        }    
@


1.15
log
@i
Ninjisu ceck
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.14 1998/12/23 16:51:29 mud Exp $ */
d210 2
a211 1
	if ( iClass == ch->class 
@


1.14
log
@Bunch of changes for rogues, including new skill and pther improvements
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.13 1998/12/09 08:32:15 mud Exp $ */
d1653 1
d1656 1
d1658 2
@


1.13
log
@Re-reclassing.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.12 1998/11/22 10:36:33 mud Exp $ */
d218 14
a231 1
	  fRoom = TRUE;
@


1.12
log
@Added wizards
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.11 1998/11/22 08:04:40 mud Exp $ */
d62 30
d341 1
a341 1
      if ( number_percent() > (get_curr_stat(ch,STAT_DEX * 5 ) ) )
@


1.11
log
@Infiltrate coded.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.10 1998/11/22 02:05:11 mud Exp $ */
d309 10
@


1.10
log
@Crusader spells
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.9 1998/10/23 14:07:27 mud Exp $ */
d73 1
a73 1

d113 1
a113 1
    ||   !can_see_room(ch,pexit->u1.to_room))
d119 16
d154 1
d157 9
d168 1
d252 2
d337 2
a338 1
  &&   can_see_room(fch,to_room))
@


1.9
log
@Fixed crash bug with recalling cursed NPC's.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.8 1998/10/11 05:22:24 mud Exp $ */
d78 6
@


1.8
log
@Added concealed and secret doors.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.7 1998/10/05 09:10:24 mud Exp $ */
d1645 6
a1650 2
  sprintf(buf,"%s has forsaken you.\n\r",deity_table[ch->pcdata->deity].pname);
  send_to_char(buf,ch);
@


1.7
log
@C

Added ability to flag an entrei area as no-transport.
Set any mob in the area to act_notrans and it's automatic from there.
Saves us the annoyance of converting area files formats.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.6 1998/08/20 21:05:26 mud Exp $ */
a111 1
    
d117 4
a120 1
  act( "The $d is closed.", ch, NULL, pexit->keyword, TO_CHAR );
@


1.6
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.5 1998/08/17 20:04:57 mud Exp $ */
d1601 7
a1607 1
 
@


1.5
log
@Elementalists and some of their spells added.
Material table begun.

-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.4 1998/08/13 05:24:07 mud Exp $ */
d1637 1
a1637 1
  sprintf(buf,"%s has forsaken you.\n\r",deity_table[ch->deity].pname);
@


1.4
log
@* Various bug fixes, mostly
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.3 1998/08/12 08:20:14 mud Exp $ */
d81 6
d229 1
a229 1
	if( !found )
@


1.3
log
@* Finished traps
* Rockbiters added
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.2 1998/08/07 20:19:53 mud Exp $ */
d381 2
@


1.2
log
@Room affects stuff for traps.
Bleed/vampire changes.
swim/scan start at 50% and 50%up for free for existing characters.
moved trap to after trip in interp list for grandfathered use
- Both of Us
@
text
@d18 1
a18 1
/* @@(#)$Id: act_move.c,v 1.1 1998/06/16 17:49:13 mud Exp $ */
d328 1
d339 13
d366 6
d374 1
a374 1
    af.level = ch->level;
d382 2
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d75 6
d249 1
a249 1
  WAIT_STATE( ch, 1 );
d318 12
d331 34
@
