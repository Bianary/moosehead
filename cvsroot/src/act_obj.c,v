head	1.414;
access;
symbols;
locks; strict;
comment	@ * @;


1.414
date	2005.02.08.20.33.53;	author rusty;	state Exp;
branches;
next	1.413;

1.413
date	2005.02.08.20.30.14;	author rusty;	state Exp;
branches;
next	1.412;

1.412
date	2004.06.21.20.06.55;	author boogums;	state Exp;
branches;
next	1.411;

1.411
date	2004.06.19.14.22.45;	author boogums;	state Exp;
branches;
next	1.410;

1.410
date	2004.06.19.03.52.16;	author boogums;	state Exp;
branches;
next	1.409;

1.409
date	2004.06.19.03.50.30;	author boogums;	state Exp;
branches;
next	1.408;

1.408
date	2004.04.27.00.30.25;	author boogums;	state Exp;
branches;
next	1.407;

1.407
date	2004.04.26.02.25.09;	author boogums;	state Exp;
branches;
next	1.406;

1.406
date	2004.04.25.01.28.24;	author boogums;	state Exp;
branches;
next	1.405;

1.405
date	2004.04.25.01.09.44;	author boogums;	state Exp;
branches;
next	1.404;

1.404
date	2004.04.25.00.57.47;	author boogums;	state Exp;
branches;
next	1.403;

1.403
date	2004.04.25.00.32.04;	author boogums;	state Exp;
branches;
next	1.402;

1.402
date	2004.04.22.03.41.43;	author boogums;	state Exp;
branches;
next	1.401;

1.401
date	2004.04.22.03.35.30;	author boogums;	state Exp;
branches;
next	1.400;

1.400
date	2004.01.26.00.00.21;	author boogums;	state Exp;
branches;
next	1.399;

1.399
date	2004.01.12.02.34.34;	author boogums;	state Exp;
branches;
next	1.398;

1.398
date	2004.01.11.22.20.52;	author boogums;	state Exp;
branches;
next	1.397;

1.397
date	2004.01.11.22.07.29;	author boogums;	state Exp;
branches;
next	1.396;

1.396
date	2003.12.01.01.51.44;	author boogums;	state Exp;
branches;
next	1.395;

1.395
date	2003.11.29.23.15.36;	author boogums;	state Exp;
branches;
next	1.394;

1.394
date	2003.11.28.00.43.27;	author boogums;	state Exp;
branches;
next	1.393;

1.393
date	2003.11.28.00.41.25;	author boogums;	state Exp;
branches;
next	1.392;

1.392
date	2003.11.28.00.37.11;	author boogums;	state Exp;
branches;
next	1.391;

1.391
date	2003.11.28.00.13.52;	author boogums;	state Exp;
branches;
next	1.390;

1.390
date	2003.11.27.23.09.07;	author boogums;	state Exp;
branches;
next	1.389;

1.389
date	2003.11.22.15.29.40;	author boogums;	state Exp;
branches;
next	1.388;

1.388
date	2003.11.22.03.34.19;	author boogums;	state Exp;
branches;
next	1.387;

1.387
date	2003.09.20.22.23.58;	author boogums;	state Exp;
branches;
next	1.386;

1.386
date	2003.09.20.18.18.58;	author boogums;	state Exp;
branches;
next	1.385;

1.385
date	2003.08.16.02.56.26;	author boogums;	state Exp;
branches;
next	1.384;

1.384
date	2003.08.09.18.31.47;	author boogums;	state Exp;
branches;
next	1.383;

1.383
date	2003.07.08.15.04.17;	author rusty;	state Exp;
branches;
next	1.382;

1.382
date	2003.06.14.19.53.09;	author boogums;	state Exp;
branches;
next	1.381;

1.381
date	2003.06.03.03.13.07;	author boogums;	state Exp;
branches;
next	1.380;

1.380
date	2003.05.30.02.23.04;	author ndagger;	state Exp;
branches;
next	1.379;

1.379
date	2003.05.24.00.55.25;	author boogums;	state Exp;
branches;
next	1.378;

1.378
date	2003.05.24.00.48.19;	author boogums;	state Exp;
branches;
next	1.377;

1.377
date	2003.05.19.03.32.09;	author ndagger;	state Exp;
branches;
next	1.376;

1.376
date	2003.05.19.03.20.34;	author ndagger;	state Exp;
branches;
next	1.375;

1.375
date	2003.05.08.03.13.39;	author boogums;	state Exp;
branches;
next	1.374;

1.374
date	2003.05.06.00.48.00;	author boogums;	state Exp;
branches;
next	1.373;

1.373
date	2003.04.08.01.29.45;	author ndagger;	state Exp;
branches;
next	1.372;

1.372
date	2003.03.23.21.09.46;	author boogums;	state Exp;
branches;
next	1.371;

1.371
date	2003.03.23.18.43.57;	author boogums;	state Exp;
branches;
next	1.370;

1.370
date	2003.01.03.19.41.52;	author boogums;	state Exp;
branches;
next	1.369;

1.369
date	2002.12.05.16.21.46;	author boogums;	state Exp;
branches;
next	1.368;

1.368
date	2002.12.05.16.12.25;	author boogums;	state Exp;
branches;
next	1.367;

1.367
date	2002.12.05.15.44.51;	author boogums;	state Exp;
branches;
next	1.366;

1.366
date	2002.12.05.06.33.33;	author boogums;	state Exp;
branches;
next	1.365;

1.365
date	2002.12.05.06.20.36;	author boogums;	state Exp;
branches;
next	1.364;

1.364
date	2002.12.05.06.12.23;	author boogums;	state Exp;
branches;
next	1.363;

1.363
date	2002.12.05.06.06.01;	author boogums;	state Exp;
branches;
next	1.362;

1.362
date	2002.12.05.05.52.06;	author boogums;	state Exp;
branches;
next	1.361;

1.361
date	2002.12.05.05.16.56;	author boogums;	state Exp;
branches;
next	1.360;

1.360
date	2002.12.02.18.49.36;	author boogums;	state Exp;
branches;
next	1.359;

1.359
date	2002.12.02.18.36.17;	author boogums;	state Exp;
branches;
next	1.358;

1.358
date	2002.12.02.05.24.17;	author boogums;	state Exp;
branches;
next	1.357;

1.357
date	2002.11.26.09.01.45;	author ndagger;	state Exp;
branches;
next	1.356;

1.356
date	2002.11.22.06.29.16;	author ndagger;	state Exp;
branches;
next	1.355;

1.355
date	2002.10.21.04.31.23;	author boogums;	state Exp;
branches;
next	1.354;

1.354
date	2002.10.21.03.55.22;	author boogums;	state Exp;
branches;
next	1.353;

1.353
date	2002.10.21.02.55.35;	author boogums;	state Exp;
branches;
next	1.352;

1.352
date	2002.10.21.02.47.20;	author boogums;	state Exp;
branches;
next	1.351;

1.351
date	2002.10.21.02.40.27;	author boogums;	state Exp;
branches;
next	1.350;

1.350
date	2002.10.21.02.24.54;	author boogums;	state Exp;
branches;
next	1.349;

1.349
date	2002.10.21.02.18.00;	author boogums;	state Exp;
branches;
next	1.348;

1.348
date	2002.10.21.01.52.04;	author boogums;	state Exp;
branches;
next	1.347;

1.347
date	2002.10.21.01.38.46;	author boogums;	state Exp;
branches;
next	1.346;

1.346
date	2002.10.21.01.08.38;	author boogums;	state Exp;
branches;
next	1.345;

1.345
date	2002.10.21.00.24.51;	author boogums;	state Exp;
branches;
next	1.344;

1.344
date	2002.10.21.00.04.51;	author boogums;	state Exp;
branches;
next	1.343;

1.343
date	2002.10.20.23.43.30;	author boogums;	state Exp;
branches;
next	1.342;

1.342
date	2002.10.20.00.46.27;	author boogums;	state Exp;
branches;
next	1.341;

1.341
date	2002.10.18.14.31.39;	author boogums;	state Exp;
branches;
next	1.340;

1.340
date	2002.10.13.21.22.40;	author boogums;	state Exp;
branches;
next	1.339;

1.339
date	2002.10.13.03.28.49;	author boogums;	state Exp;
branches;
next	1.338;

1.338
date	2002.10.13.02.55.43;	author boogums;	state Exp;
branches;
next	1.337;

1.337
date	2002.10.10.03.13.19;	author boogums;	state Exp;
branches;
next	1.336;

1.336
date	2002.09.26.22.29.49;	author boogums;	state Exp;
branches;
next	1.335;

1.335
date	2002.09.26.22.23.37;	author boogums;	state Exp;
branches;
next	1.334;

1.334
date	2002.09.26.04.24.02;	author boogums;	state Exp;
branches;
next	1.333;

1.333
date	2002.09.10.16.55.49;	author mud;	state Exp;
branches;
next	1.332;

1.332
date	2002.06.20.15.54.59;	author rusty;	state Exp;
branches;
next	1.331;

1.331
date	2002.05.22.19.20.57;	author mud;	state Exp;
branches;
next	1.330;

1.330
date	2002.05.22.19.10.27;	author rusty;	state Exp;
branches;
next	1.329;

1.329
date	2002.05.22.18.00.40;	author rusty;	state Exp;
branches;
next	1.328;

1.328
date	2002.05.21.20.20.58;	author rage;	state Exp;
branches;
next	1.327;

1.327
date	2002.05.04.16.50.53;	author boogums;	state Exp;
branches;
next	1.326;

1.326
date	2002.05.04.16.40.53;	author boogums;	state Exp;
branches;
next	1.325;

1.325
date	2002.05.04.16.37.06;	author boogums;	state Exp;
branches;
next	1.324;

1.324
date	2002.05.04.16.33.13;	author boogums;	state Exp;
branches;
next	1.323;

1.323
date	2002.05.04.16.30.35;	author boogums;	state Exp;
branches;
next	1.322;

1.322
date	2002.05.04.16.26.51;	author boogums;	state Exp;
branches;
next	1.321;

1.321
date	2002.05.04.16.23.06;	author boogums;	state Exp;
branches;
next	1.320;

1.320
date	2002.05.04.16.16.44;	author boogums;	state Exp;
branches;
next	1.319;

1.319
date	2002.05.03.03.17.12;	author boogums;	state Exp;
branches;
next	1.318;

1.318
date	2002.05.03.03.13.46;	author boogums;	state Exp;
branches;
next	1.317;

1.317
date	2002.05.03.02.58.58;	author boogums;	state Exp;
branches;
next	1.316;

1.316
date	2002.04.24.02.38.08;	author boogums;	state Exp;
branches;
next	1.315;

1.315
date	2002.04.05.15.24.27;	author boogums;	state Exp;
branches;
next	1.314;

1.314
date	2002.04.01.21.48.06;	author rusty;	state Exp;
branches;
next	1.313;

1.313
date	2002.04.01.21.05.43;	author rusty;	state Exp;
branches;
next	1.312;

1.312
date	2002.01.26.16.25.27;	author rage;	state Exp;
branches;
next	1.311;

1.311
date	2001.12.13.17.52.42;	author poquah;	state Exp;
branches;
next	1.310;

1.310
date	2001.12.09.15.10.39;	author poquah;	state Exp;
branches;
next	1.309;

1.309
date	2001.12.05.16.39.00;	author poquah;	state Exp;
branches;
next	1.308;

1.308
date	2001.11.23.16.18.38;	author poquah;	state Exp;
branches;
next	1.307;

1.307
date	2001.11.23.16.17.15;	author poquah;	state Exp;
branches;
next	1.306;

1.306
date	2001.11.15.03.10.32;	author poquah;	state Exp;
branches;
next	1.305;

1.305
date	2001.11.10.19.13.42;	author rage;	state Exp;
branches;
next	1.304;

1.304
date	2001.11.10.18.38.24;	author rage;	state Exp;
branches;
next	1.303;

1.303
date	2001.10.21.20.35.43;	author rage;	state Exp;
branches;
next	1.302;

1.302
date	2001.10.13.02.11.59;	author rage;	state Exp;
branches;
next	1.301;

1.301
date	2001.08.20.20.14.55;	author boogums;	state Exp;
branches;
next	1.300;

1.300
date	2001.08.13.22.17.58;	author boogums;	state Exp;
branches;
next	1.299;

1.299
date	2001.08.08.05.45.51;	author poquah;	state Exp;
branches;
next	1.298;

1.298
date	2001.08.04.19.29.22;	author guerrand;	state Exp;
branches;
next	1.297;

1.297
date	2001.08.03.02.24.29;	author boogums;	state Exp;
branches;
next	1.296;

1.296
date	2001.08.01.21.44.56;	author mud;	state Exp;
branches;
next	1.295;

1.295
date	2001.08.01.21.43.40;	author rusty;	state Exp;
branches;
next	1.294;

1.294
date	2001.08.01.04.02.50;	author boogums;	state Exp;
branches;
next	1.293;

1.293
date	2001.07.31.02.59.42;	author boogums;	state Exp;
branches;
next	1.292;

1.292
date	2001.07.31.02.52.55;	author boogums;	state Exp;
branches;
next	1.291;

1.291
date	2001.07.31.02.48.15;	author boogums;	state Exp;
branches;
next	1.290;

1.290
date	2001.07.31.01.48.59;	author boogums;	state Exp;
branches;
next	1.289;

1.289
date	2001.07.31.01.28.08;	author boogums;	state Exp;
branches;
next	1.288;

1.288
date	2001.07.31.01.23.39;	author boogums;	state Exp;
branches;
next	1.287;

1.287
date	2001.07.31.01.11.37;	author boogums;	state Exp;
branches;
next	1.286;

1.286
date	2001.07.30.22.44.34;	author guerrand;	state Exp;
branches;
next	1.285;

1.285
date	2001.07.24.02.01.39;	author boogums;	state Exp;
branches;
next	1.284;

1.284
date	2001.07.20.23.50.08;	author boogums;	state Exp;
branches;
next	1.283;

1.283
date	2001.07.20.20.40.25;	author boogums;	state Exp;
branches;
next	1.282;

1.282
date	2001.07.20.20.10.39;	author boogums;	state Exp;
branches;
next	1.281;

1.281
date	2001.07.20.19.59.24;	author boogums;	state Exp;
branches;
next	1.280;

1.280
date	2001.07.20.18.47.08;	author boogums;	state Exp;
branches;
next	1.279;

1.279
date	2001.07.20.18.30.07;	author boogums;	state Exp;
branches;
next	1.278;

1.278
date	2001.07.20.18.21.16;	author boogums;	state Exp;
branches;
next	1.277;

1.277
date	2001.07.20.18.07.38;	author boogums;	state Exp;
branches;
next	1.276;

1.276
date	2001.07.20.18.05.40;	author boogums;	state Exp;
branches;
next	1.275;

1.275
date	2001.07.18.04.05.29;	author boogums;	state Exp;
branches;
next	1.274;

1.274
date	2001.07.17.14.48.00;	author boogums;	state Exp;
branches;
next	1.273;

1.273
date	2001.07.17.14.32.20;	author boogums;	state Exp;
branches;
next	1.272;

1.272
date	2001.07.17.04.13.13;	author boogums;	state Exp;
branches;
next	1.271;

1.271
date	2001.07.17.03.58.28;	author boogums;	state Exp;
branches;
next	1.270;

1.270
date	2001.07.17.03.07.44;	author boogums;	state Exp;
branches;
next	1.269;

1.269
date	2001.07.17.02.56.42;	author boogums;	state Exp;
branches;
next	1.268;

1.268
date	2001.07.17.02.46.14;	author boogums;	state Exp;
branches;
next	1.267;

1.267
date	2001.07.17.02.02.57;	author boogums;	state Exp;
branches;
next	1.266;

1.266
date	2001.07.16.19.37.55;	author boogums;	state Exp;
branches;
next	1.265;

1.265
date	2001.07.16.04.56.27;	author boogums;	state Exp;
branches;
next	1.264;

1.264
date	2001.07.16.04.51.25;	author boogums;	state Exp;
branches;
next	1.263;

1.263
date	2001.07.16.04.33.38;	author boogums;	state Exp;
branches;
next	1.262;

1.262
date	2001.07.16.04.28.36;	author boogums;	state Exp;
branches;
next	1.261;

1.261
date	2001.07.16.04.16.49;	author boogums;	state Exp;
branches;
next	1.260;

1.260
date	2001.07.16.03.47.07;	author boogums;	state Exp;
branches;
next	1.259;

1.259
date	2001.07.16.03.28.44;	author boogums;	state Exp;
branches;
next	1.258;

1.258
date	2001.07.16.03.20.48;	author boogums;	state Exp;
branches;
next	1.257;

1.257
date	2001.07.16.01.44.57;	author boogums;	state Exp;
branches;
next	1.256;

1.256
date	2001.07.16.00.14.40;	author boogums;	state Exp;
branches;
next	1.255;

1.255
date	2001.07.16.00.10.01;	author boogums;	state Exp;
branches;
next	1.254;

1.254
date	2001.07.15.23.50.20;	author boogums;	state Exp;
branches;
next	1.253;

1.253
date	2001.07.15.23.00.53;	author boogums;	state Exp;
branches;
next	1.252;

1.252
date	2001.07.15.22.48.20;	author boogums;	state Exp;
branches;
next	1.251;

1.251
date	2001.07.15.22.24.21;	author boogums;	state Exp;
branches;
next	1.250;

1.250
date	2001.07.15.22.03.20;	author boogums;	state Exp;
branches;
next	1.249;

1.249
date	2001.07.15.21.49.49;	author boogums;	state Exp;
branches;
next	1.248;

1.248
date	2001.07.15.21.29.51;	author boogums;	state Exp;
branches;
next	1.247;

1.247
date	2001.07.15.21.25.26;	author boogums;	state Exp;
branches;
next	1.246;

1.246
date	2001.07.15.21.21.26;	author boogums;	state Exp;
branches;
next	1.245;

1.245
date	2001.07.15.21.13.35;	author boogums;	state Exp;
branches;
next	1.244;

1.244
date	2001.07.15.21.09.09;	author boogums;	state Exp;
branches;
next	1.243;

1.243
date	2001.07.15.20.01.19;	author boogums;	state Exp;
branches;
next	1.242;

1.242
date	2001.07.02.17.12.40;	author mud;	state Exp;
branches;
next	1.241;

1.241
date	2001.06.26.01.21.51;	author guerrand;	state Exp;
branches;
next	1.240;

1.240
date	2001.06.24.06.00.25;	author guerrand;	state Exp;
branches;
next	1.239;

1.239
date	2001.06.23.18.48.41;	author guerrand;	state Exp;
branches;
next	1.238;

1.238
date	2001.06.23.07.04.24;	author guerrand;	state Exp;
branches;
next	1.237;

1.237
date	2001.06.19.02.11.32;	author guerrand;	state Exp;
branches;
next	1.236;

1.236
date	2001.06.19.00.52.23;	author rage;	state Exp;
branches;
next	1.235;

1.235
date	2001.06.19.00.33.08;	author rage;	state Exp;
branches;
next	1.234;

1.234
date	2001.06.19.00.08.17;	author rage;	state Exp;
branches;
next	1.233;

1.233
date	2001.06.18.23.13.01;	author rage;	state Exp;
branches;
next	1.232;

1.232
date	2001.06.18.22.55.34;	author rage;	state Exp;
branches;
next	1.231;

1.231
date	2001.06.18.01.43.00;	author rage;	state Exp;
branches;
next	1.230;

1.230
date	2001.06.18.01.24.11;	author rage;	state Exp;
branches;
next	1.229;

1.229
date	2001.06.18.01.17.32;	author rage;	state Exp;
branches;
next	1.228;

1.228
date	2001.06.17.18.35.35;	author guerrand;	state Exp;
branches;
next	1.227;

1.227
date	2001.06.17.06.30.17;	author guerrand;	state Exp;
branches;
next	1.226;

1.226
date	2001.06.17.06.21.37;	author guerrand;	state Exp;
branches;
next	1.225;

1.225
date	2001.06.17.05.58.51;	author guerrand;	state Exp;
branches;
next	1.224;

1.224
date	2001.06.17.05.31.07;	author guerrand;	state Exp;
branches;
next	1.223;

1.223
date	2001.06.17.05.26.57;	author guerrand;	state Exp;
branches;
next	1.222;

1.222
date	2001.06.17.05.18.02;	author guerrand;	state Exp;
branches;
next	1.221;

1.221
date	2001.06.09.01.10.51;	author guerrand;	state Exp;
branches;
next	1.220;

1.220
date	2001.06.07.22.29.59;	author rage;	state Exp;
branches;
next	1.219;

1.219
date	2001.06.05.00.39.40;	author rage;	state Exp;
branches;
next	1.218;

1.218
date	2001.06.03.23.28.37;	author guerrand;	state Exp;
branches;
next	1.217;

1.217
date	2001.06.03.23.20.06;	author guerrand;	state Exp;
branches;
next	1.216;

1.216
date	2001.05.25.01.35.13;	author guerrand;	state Exp;
branches;
next	1.215;

1.215
date	2001.05.24.14.35.22;	author poquah;	state Exp;
branches;
next	1.214;

1.214
date	2001.05.24.01.33.26;	author poquah;	state Exp;
branches;
next	1.213;

1.213
date	2001.05.22.02.14.31;	author boogums;	state Exp;
branches;
next	1.212;

1.212
date	2001.05.22.02.07.28;	author boogums;	state Exp;
branches;
next	1.211;

1.211
date	2001.05.20.21.25.43;	author rusty;	state Exp;
branches;
next	1.210;

1.210
date	2001.04.09.18.30.39;	author mud;	state Exp;
branches;
next	1.209;

1.209
date	2001.04.09.03.14.18;	author mud;	state Exp;
branches;
next	1.208;

1.208
date	2001.04.09.03.08.03;	author mud;	state Exp;
branches;
next	1.207;

1.207
date	2001.04.09.01.34.14;	author mud;	state Exp;
branches;
next	1.206;

1.206
date	2001.04.09.01.30.26;	author mud;	state Exp;
branches;
next	1.205;

1.205
date	2001.03.10.16.42.32;	author mud;	state Exp;
branches;
next	1.204;

1.204
date	2001.03.03.19.05.25;	author mud;	state Exp;
branches;
next	1.203;

1.203
date	2001.03.03.18.53.56;	author mud;	state Exp;
branches;
next	1.202;

1.202
date	2000.12.14.04.59.01;	author mud;	state Exp;
branches;
next	1.201;

1.201
date	2000.12.14.04.49.10;	author mud;	state Exp;
branches;
next	1.200;

1.200
date	2000.12.09.07.05.46;	author mud;	state Exp;
branches;
next	1.199;

1.199
date	2000.12.07.06.45.43;	author mud;	state Exp;
branches;
next	1.198;

1.198
date	2000.12.07.05.46.10;	author mud;	state Exp;
branches;
next	1.197;

1.197
date	2000.12.06.04.47.39;	author mud;	state Exp;
branches;
next	1.196;

1.196
date	2000.12.06.04.40.39;	author mud;	state Exp;
branches;
next	1.195;

1.195
date	2000.12.03.19.22.56;	author mud;	state Exp;
branches;
next	1.194;

1.194
date	2000.12.03.03.24.00;	author mud;	state Exp;
branches;
next	1.193;

1.193
date	2000.10.23.22.05.55;	author mud;	state Exp;
branches;
next	1.192;

1.192
date	2000.10.18.21.39.09;	author mud;	state Exp;
branches;
next	1.191;

1.191
date	2000.10.17.22.45.32;	author mud;	state Exp;
branches;
next	1.190;

1.190
date	2000.10.16.19.16.59;	author mud;	state Exp;
branches;
next	1.189;

1.189
date	2000.09.20.23.03.31;	author mud;	state Exp;
branches;
next	1.188;

1.188
date	2000.09.20.22.54.18;	author mud;	state Exp;
branches;
next	1.187;

1.187
date	2000.09.20.03.35.42;	author mud;	state Exp;
branches;
next	1.186;

1.186
date	2000.09.13.14.01.48;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	2000.08.23.13.38.03;	author mud;	state Exp;
branches;
next	1.184;

1.184
date	2000.08.23.13.26.24;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2000.08.18.22.52.07;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	2000.08.18.01.46.13;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	2000.08.18.01.43.24;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	2000.08.18.01.28.09;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	2000.08.17.15.41.17;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	2000.08.11.22.53.43;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	2000.07.21.23.51.38;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	2000.07.21.23.45.26;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	2000.07.12.21.24.56;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	2000.07.06.15.35.56;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	2000.07.04.17.50.16;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	2000.06.27.23.30.17;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	2000.06.19.22.45.07;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	2000.06.17.21.33.11;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	2000.06.17.19.06.03;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	2000.05.28.22.35.46;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	2000.05.27.02.44.08;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	2000.05.21.02.54.08;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	2000.05.19.13.43.58;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	2000.05.18.14.27.18;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	2000.05.18.14.22.48;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	2000.05.18.14.17.00;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	2000.05.18.14.14.16;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	2000.05.17.03.14.49;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	2000.05.17.03.02.26;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	2000.05.17.02.49.55;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	2000.05.17.02.36.12;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	2000.05.16.20.35.34;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	2000.05.16.15.22.05;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	2000.05.16.15.17.59;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	2000.05.16.15.01.27;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	2000.05.13.22.57.03;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	2000.05.13.22.55.10;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	2000.04.22.06.45.07;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	2000.04.22.06.37.08;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	2000.04.22.04.54.25;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	2000.04.22.03.40.28;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	2000.04.18.20.33.46;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	2000.04.18.19.50.52;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	2000.04.17.22.00.45;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	2000.04.17.21.04.00;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	2000.04.17.20.15.25;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	2000.04.15.17.00.33;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	2000.04.06.01.45.45;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	2000.03.28.01.20.16;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	2000.03.20.23.10.51;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	2000.03.14.21.39.08;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	2000.03.14.21.34.39;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	2000.03.14.21.29.50;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	2000.03.14.01.43.22;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	2000.03.13.17.58.19;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	2000.03.12.02.02.31;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	2000.03.12.01.55.20;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	2000.03.12.01.50.47;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	2000.03.12.01.48.12;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	2000.03.12.01.40.13;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	2000.03.12.01.36.04;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	2000.03.12.01.31.53;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	2000.03.12.01.26.25;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	2000.03.12.01.18.39;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	2000.03.12.01.09.02;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	2000.03.12.00.32.40;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	2000.03.10.00.24.23;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	2000.03.06.22.44.48;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	2000.02.25.00.00.48;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	2000.02.23.03.34.07;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	2000.02.23.02.15.53;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2000.02.23.01.03.47;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	2000.02.23.00.59.04;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	2000.02.23.00.33.26;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	2000.02.22.23.45.58;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	2000.02.20.08.30.06;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	2000.02.20.07.45.14;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	2000.02.20.06.49.29;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	2000.02.20.06.40.14;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	2000.02.20.06.37.18;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	2000.02.20.06.31.30;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	2000.02.20.06.16.55;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	2000.02.20.06.05.49;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	2000.02.20.05.24.01;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	2000.02.20.04.52.53;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2000.02.20.04.19.32;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2000.02.20.03.46.18;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2000.02.20.03.13.19;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2000.02.20.02.38.58;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2000.02.16.07.08.07;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	2000.02.11.20.20.39;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	2000.01.26.19.14.00;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	2000.01.26.18.35.02;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	2000.01.26.18.32.30;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	99.11.26.20.51.34;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.11.19.19.45.25;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.11.19.19.35.01;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.11.18.17.38.27;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.11.11.18.26.03;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.11.08.21.32.05;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.11.08.20.02.01;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.11.06.18.56.36;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.11.05.21.03.54;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.11.05.20.58.39;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	99.11.05.20.57.08;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	99.10.10.17.20.52;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	99.10.09.17.16.40;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	99.10.06.23.10.43;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.09.30.04.18.15;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.09.30.00.35.50;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	99.09.28.23.20.31;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	99.09.14.23.03.05;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	99.09.14.22.59.35;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	99.08.23.19.19.22;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	99.08.23.02.04.24;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	99.08.13.19.02.17;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	99.08.12.01.23.01;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	99.07.14.18.13.27;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	99.07.11.19.09.19;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	99.07.02.23.57.54;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	99.07.02.23.53.58;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	99.07.02.20.21.08;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	99.07.02.03.17.48;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	99.07.02.03.14.33;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	99.07.02.03.12.50;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	99.07.02.02.14.59;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.07.02.02.10.39;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.06.24.02.33.57;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.06.11.23.21.50;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.05.15.22.07.38;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.05.15.22.04.20;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.05.15.21.08.06;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.05.15.16.39.01;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.05.03.08.00.16;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.04.17.02.30.21;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.04.17.02.05.40;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.04.17.01.58.59;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.04.16.16.59.15;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.04.06.21.36.43;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.04.06.21.31.44;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.04.06.21.24.25;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.04.06.21.11.24;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.04.06.21.07.30;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.04.06.20.58.37;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.04.06.20.41.49;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.04.06.20.36.31;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.04.06.20.29.29;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	99.04.06.20.24.39;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.04.06.18.34.38;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.01.03.01.19.07;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.01.02.19.55.19;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	99.01.02.19.53.23;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.01.02.19.10.06;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	99.01.02.00.48.29;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.01.02.00.40.44;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	99.01.01.19.00.06;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	98.12.31.21.25.54;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.12.31.21.16.33;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.12.29.23.54.25;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.12.23.16.51.29;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.12.16.21.06.59;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.12.16.20.42.38;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.12.12.01.20.51;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.11.30.02.20.06;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.11.28.07.49.29;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.11.24.05.48.01;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.11.24.05.29.00;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.11.22.08.04.41;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.11.17.23.20.09;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.11.14.07.15.49;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.10.21.23.46.36;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.10.20.02.05.14;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.10.19.07.19.04;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.10.19.06.47.09;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.10.18.16.28.54;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.10.17.05.31.56;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.10.15.23.05.59;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.10.11.06.52.41;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.10.11.00.13.32;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.10.06.14.11.27;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.30.03.51.25;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.20.21.05.26;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.15.18.45.48;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.13.21.42.34;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.06.04.24.49;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.05.06.59.12;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.14;	author mud;	state Exp;
branches;
next	;


desc
@@


1.414
log
@Ooops, opposite case
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/


static char rcsid[] = "$Id: act_obj.c,v 1.413 2005/02/08 20:30:14 rusty Exp $";
#if defined(macintosh)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "merc.h"
#include "tables.h"
#include "gladiator.h"

/* command procedures needed */
DECLARE_DO_FUN(do_split   );
DECLARE_DO_FUN(do_yell    );
DECLARE_DO_FUN(do_say   );
DECLARE_DO_FUN(do_help   );
DECLARE_SPELL_FUN(  spell_null    );
/* Imported */
int clan_lookup	args( ( const char *name ) );

/*
 * Local functions.
 */
#define CD CHAR_DATA
#define OD OBJ_DATA
bool  remove_obj  args( (CHAR_DATA *ch, int iWear, bool fReplace ) );
void  wear_obj  args( (CHAR_DATA *ch, OBJ_DATA *obj, bool fReplace ) );
CD *  find_keeper args( (CHAR_DATA *ch ) );
int get_cost  args( (CHAR_DATA *keeper, OBJ_DATA *obj, bool fBuy ) );
void  obj_to_keeper args( (OBJ_DATA *obj, CHAR_DATA *ch ) );
OD *  get_obj_keeper  args( (CHAR_DATA *ch,CHAR_DATA *keeper,char *argument));

#undef OD
#undef  CD

#define COST_ACCURACY	100
#define COST_SPEED	300
#define COST_MAGIC_RESISTANCE 	250
#define COST_VISION	50
#define COST_RESTORATION	25	
#define COST_MOLOTOV	25 


void do_brew( CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *potion;
    int chance, num;
    int vnum, cost;
    /* This array contains values of appropriate dam types from attack_table */
    int attack[11] = { 6,12,18,19,20,35,36,38,39,40,41};
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    char colour[11][20] = { "red", "black", "gold", "silver", "blue", 
			  "green", "yellow", "pink", "bronze", "magenta",
			  "transparent"};

    if ( ( chance = get_skill(ch,gsn_alchemy) ) < 5 ||
	( !IS_IMMORTAL(ch) && !HAS_KIT(ch,"alchemist") ) )
    {
	send_to_char("H2O, NaCl, augh this is too hard!\n\r",ch);
	return;
    }

    chance /= 2;

    switch ( ch->in_room->sector_type )
    {
    case SECT_MAGELAB_SIMPLE: chance += 10; break;
    case SECT_MAGELAB_INTERMEDIATE: chance += 20; break;
    case SECT_MAGELAB_ADVANCED: chance += 40; break;
    case SECT_MAGELAB_SUPERIOR: chance += 60; break;
    default:
	send_to_char("You must be in a magelab.\n\r",ch);
	return;
    }

    one_argument ( argument, arg );


    if ( !str_cmp( arg, "accuracy" ) )
    {
	cost = COST_ACCURACY;
	vnum = OBJ_VNUM_POTION_ACCURACY;
    }
    else
    if ( !str_cmp( arg, "speed") )
    {
	cost = COST_SPEED;
	vnum = OBJ_VNUM_POTION_SPEED;
    }
    else
    if ( !str_cmp( arg, "resist") )
    {
	cost = COST_MAGIC_RESISTANCE;
	vnum = OBJ_VNUM_POTION_MAGIC_RESISTANCE;
    }
    else
    if ( !str_cmp( arg, "vision") )
    {
	cost = COST_VISION;
	vnum = OBJ_VNUM_POTION_VISION;
    }
    else
    if ( !str_cmp( arg, "mana") )
    {
	cost = COST_RESTORATION;
	vnum = OBJ_VNUM_POTION_RESTORATION;
    }
    else 
    if ( !str_cmp( arg, "molotov") )
    {
	cost = COST_MOLOTOV;
	vnum = OBJ_VNUM_POTION_MOLOTOV;
    }
    else
    {
	send_to_char("That isn't a brewable potion.\n\r",ch);
	return;
    }
    
    if ( ch->gold < cost )
    {
	send_to_char("You don't have enough gold on hand.\n\r",ch);
	return;
    }

    ch->gold -= cost;
    WAIT_STATE( ch, PULSE_PER_SECOND * 5 );

    if ( number_percent() >= chance )
    {
	send_to_char("You failed.\n\r",ch);
        act("$n mixes ingredients together.......and nothing happens. ",ch,NULL,NULL,TO_ROOM,FALSE);
        check_improve(ch,gsn_alchemy,FALSE,4);
	return;
    }
    check_improve(ch,gsn_alchemy,TRUE,4);
   
    potion = create_object( get_obj_index(vnum), 0, FALSE );
    obj_to_char( potion, ch );

    switch( vnum )
    {
    case OBJ_VNUM_POTION_MOLOTOV:
       num = number_range(0,10);
       sprintf(buf, potion->short_descr, colour[num]);
       free_string(potion->short_descr);
       potion->short_descr = str_dup(buf);
       sprintf(buf, potion->description, colour[num]);
       free_string(potion->description);
       potion->description = str_dup(buf);
       sprintf(buf, potion->name, colour[num]);
       free_string(potion->name);
       potion->name = str_dup(buf);
       /* v4 is used to determine the damage type in do_greande() */       
        potion->value[4] = attack[num];
        potion->value[1] = ch->level;       

	switch ( ch->in_room->sector_type )
        {
            case SECT_MAGELAB_SIMPLE: potion->value[0] = 6; break;
            case SECT_MAGELAB_INTERMEDIATE: potion->value[0] = 9; break;
	    case SECT_MAGELAB_ADVANCED: potion->value[0] = 12; break;
	    case SECT_MAGELAB_SUPERIOR: potion->value[0] = 15; break;
	}
	break;
   default:
	potion->value[0] = ch->level;
	break;

    }

    act("$n has created $p!",ch,potion,NULL,TO_ROOM,FALSE);
    act("You create $p!",ch,potion,NULL,TO_CHAR,FALSE);
    return;
}  
//#ifdef COREY_TEST
void do_endow (CHAR_DATA *ch, char *argument )
{
  char arg1[MAX_INPUT_LENGTH];
  char arg2[MAX_INPUT_LENGTH];
  char staffName[MAX_INPUT_LENGTH];
  OBJ_DATA *staff;
  int sn;
  int charges;
  int staffLevel;
  int spellLevel;
  int percent;
  argument = one_argument(argument, arg1); 
  argument = one_argument(argument, arg2);

  if( get_skill(ch,gsn_endow) == 0 )
  { 
    send_to_char ("Yes, yes, yes, we all know you are well endowed.  Now quit being silly.\r\n",ch);
    return;
  }
  if ( arg1[0] == '\0' || arg2[0] == '\0' )
  {
    send_to_char("Syntax for endow is:  endow spellname staffname \r\n",ch);
    return;
  }
  switch ( ch->in_room->sector_type )
  {
    case SECT_ALTAR_BASIC:  
      break;
    case SECT_ALTAR_BLESSED: 
      break;
    case SECT_ALTAR_ANNOINTED:
      break;
    case SECT_ALTAR_HOLY_GROUND:
      break;
    default:
      send_to_char("You must be on consecrated ground to endow a staff.\r\n",ch);
      return;
  }
   if ( ( sn = find_spell( ch,arg1 ) ) < 0
    || ( !IS_NPC(ch) && (ch->level < skill_level(ch,sn)
    ||       ch->pcdata->learned[sn] == 0)))
  {
      send_to_char( "You don't know any spells of that name.\n\r", ch );
      return;
  }
  if (skill_table[sn].spell_fun == spell_null)
  {
    send_to_char( "That's not a spell!\n\r", ch );
    return;
  }
  if ( skill_table[sn].bitvector & SS_STAFF )
  {
      //do nothing
  }
  else
  {
      send_to_char("You may not put that spell on a staff.\r\n",ch);
      return;
  }
  if ( ( staff = get_obj_carry( ch, arg2 ) ) == NULL )
  {
      send_to_char( "You do not have that staff.\n\r", ch );
      return;
  }
  if (  staff->value[0] != 0 )
  {
      send_to_char( "That staff already has been endowed.\n\r", ch );
      return;
  }
  if ( ch->pcdata->sac < number_range(175,225))
  {
    send_to_char("You have not given enough sacrifice to your god.\r\n",ch);
    return;
  }
  percent = ( (get_skill(ch,gsn_endow)*8) / 10 ) ;
  switch (staff->pIndexData->vnum )
  {
    case OBJ_VNUM_POOR_STAFF:
      percent += 0;
      charges = 1;
      break;
    case  OBJ_VNUM_MEDIUM_STAFF:
      percent += 5;
      charges = number_range(1,3);
      break;
    case OBJ_VNUM_HIGH_STAFF:
      percent += 10;
      charges = number_range(2,4);
      break;
    default:
      send_to_char("That is not a valid staff.\r\n",ch);
      return;
      break;
  }
  if ( percent >= number_percent() )
  {
    spellLevel= compute_casting_level( ch, sn );
    if (spellLevel > 54)
    {
       spellLevel = 54 ;
    }
    staffLevel = skill_level(ch,sn);
    check_improve(ch,gsn_endow,TRUE,2);
    sprintf (staffName, "a staff of ");
    strcat (staffName, skill_table[sn].name);
    free_string( staff -> name );
    staff->name = str_dup(staffName);
    free_string( staff->short_descr );
    staff->short_descr = str_dup(staffName);
    free_string( staff->description );
    sprintf (staffName, "A staff of ");
    strcat (staffName, skill_table[sn].name);
    strcat (staffName, " lies here.\r\n");
    staff->description = str_dup(staffName);
    staff->cost = 0;
    staff->level = staffLevel;
    staff->value[0] = spellLevel;
    staff->value[1] = 0;
    staff->value[2] = charges;
    staff->value[3] = sn;
    staff->value[4] = -1;
    SET_BIT(staff->extra_flags,ITEM_NOIDENTIFY);
    SET_BIT(staff->extra_flags,ITEM_GLOW);
    send_to_char("{YCRACK{x!  You endow the staff with your god's mojo!\r\n",ch);
    act("$n looks rather pios as the staff glows with a holy aura.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
  }
  else
  {
  //they fail
    check_improve(ch,gsn_endow,FALSE,4);
    send_to_char("{YCRACK{x!  You snap the staff in two!\r\n",ch);
    act("$n curses the gods as the staff breaks in two.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
    extract_obj(staff);
    return;
  }


}
void do_infuse (CHAR_DATA *ch, char *argument )
{ //start do_wmake
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    char wand_name[MAX_INPUT_LENGTH];
    OBJ_DATA *wand;
        int sn;
	int charges;
        int spell_level1;
        int spell_level;
        int spell_level2;
        int percent;
    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    if( get_skill(ch,gsn_infuse) == 0 )
   { send_to_char ("You do not know how to infuse things.  Do not be a dumb-bunny.\r\n",ch);
	return;
	}
    if ( ( arg1[0] == '\0' ) || ( arg2[0] == '\0' ) )
    {
  send_to_char( "Syntax for infuse is: infuse spellname wandname \n\r", ch );
  return;
    }

   /*Begin the sanity checks*/
    switch ( ch->in_room->sector_type )
    {
    case SECT_MAGELAB_SIMPLE:  break;
    case SECT_MAGELAB_INTERMEDIATE:  break;
    case SECT_MAGELAB_ADVANCED:  break;
    case SECT_MAGELAB_SUPERIOR:  break;
    default:
        send_to_char("You must be in a magelab to infuse.\n\r",ch);
        return;
    }
    if ( ( sn = find_spell( ch,arg1 ) ) < 0
    || ( !IS_NPC(ch) && (ch->level < skill_level(ch,sn)
    ||       ch->pcdata->learned[sn] == 0)))
    {
        send_to_char( "You don't know any spells of that name.\n\r", ch );
        return;
    }
    if (skill_table[sn].spell_fun == spell_null)
    {
        send_to_char( "That's not a spell!\n\r", ch );
        return;
    }

    if ( skill_table[sn].bitvector & SS_WAND )
    {
        //do nothing
    }
    else
    {
        send_to_char("You may not put that spell on a wand.\r\n",ch);
        return;
    }

    if ( ( wand = get_obj_carry( ch, arg2 ) ) == NULL )
    {
        send_to_char( "You do not have that wand.\n\r", ch );
        return;
    }
    if (  wand->value[0] != 0 )
    {
        send_to_char( "That wand already has been infused.\n\r", ch );
        return;
    }

        switch ( wand->pIndexData->vnum )
        {
                case OBJ_VNUM_WAND_PINE:
			charges = number_range(1,3);
                        percent -= 25;
                        break;
                case OBJ_VNUM_WAND_APPLE:
			charges = number_range(2,4);
                        percent -= 15 ;
                        break;
                case OBJ_VNUM_WAND_OAK:
			charges = number_range(3,5);
                        percent -= 5;
                        break;
                case OBJ_VNUM_WAND_WILLOW:
			charges = number_range(4,6);
                        percent += 5;
                        break;
                case OBJ_VNUM_WAND_YEW:
			charges = number_range(5,7);
                        percent += 10;
                        break;
		default:
			send_to_char("That's not a valid wand.\r\n",ch);
			return;
			break;
	}

        percent = ( (get_skill(ch,gsn_infuse)*8) / 10 ) ;
	
	if ( percent >= number_percent() )
	{
   		spell_level = compute_casting_level( ch, sn );
    		if (spell_level > 54)
    		{
        	  spell_level = 54 ;
    		}

          if ( sn == skill_lookup("turn undead") )
          {
            spell_level2 -= 5;
          }
 	  if ( number_percent() < 5 && number_percent() >= 1)
	  { 
            spell_level1 = skill_level(ch,sn);
            spell_level2 = spell_level;
            check_improve(ch,gsn_infuse,TRUE,2);

            sprintf (wand_name, "a wand of ");
            strcat (wand_name, "rasefseers");
            free_string( wand -> name );
            wand->name = str_dup(wand_name);
            free_string( wand->short_descr );
            wand->short_descr = str_dup(wand_name);
            free_string( wand->description );
            sprintf (wand_name, "A wand of ");
            strcat (wand_name, "rasefseers");
            strcat (wand_name, " lies here.\r\n");
            wand->description = str_dup(wand_name);
            wand->level = spell_level1;
            wand->cost = 0;
            wand->value[1] = charges;
            wand->value[0] = spell_level2;
            wand->value[2] = charges;
            wand->value[3] = skill_lookup("restrain");;
            wand->value[4] = -1;
            SET_BIT(wand->extra_flags,ITEM_NOIDENTIFY);
	    SET_BIT(wand->extra_flags,ITEM_HUM);
            send_to_char("{YCRACK{x!  You infuse the wand with a special kind of mojo!\r\n",ch);
            act("$n grins evily as the piece of wood glows with a magical aura.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
	  }
	  else
	  {
       	    spell_level1 = skill_level(ch,sn);
            spell_level2 = spell_level;
            check_improve(ch,gsn_infuse,TRUE,2);
            sprintf (wand_name, "a wand of ");
            strcat (wand_name, skill_table[sn].name);
            free_string( wand -> name );
            wand->name = str_dup(wand_name);
            free_string( wand->short_descr );
            wand->short_descr = str_dup(wand_name);
            free_string( wand->description );
            sprintf (wand_name, "A wand of ");
            strcat (wand_name, skill_table[sn].name);
            strcat (wand_name, " lies here.\r\n");
            wand->description = str_dup(wand_name);
            wand->level = spell_level1;
            wand->cost = 0;
             wand->value[1] = 0;
            wand->value[0] = spell_level2;
            wand->value[2] = charges;
            wand->value[3] = sn;
             wand->value[4] = -1;
            SET_BIT(wand->extra_flags,ITEM_NOIDENTIFY);
	    SET_BIT(wand->extra_flags,ITEM_GLOW);
            send_to_char("{YCRACK{x!  You infuse the wand with your mojo!\r\n",ch);
            act("$n grins evily as the piece of wood glows with a magical aura.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
	  }
	}
	else
	{
		//they fail
                check_improve(ch,gsn_infuse,FALSE,4);
                send_to_char("{YCRACK{x!  You snap the wand in two!\r\n",ch);
                act("$n curses as the wand breaks in two.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
                extract_obj(wand);
                return;
	}
} //end do_wmake
//#endif
void do_scribe( CHAR_DATA *ch, char *argument )
{ /*bFALSegin do_scribe */

    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    char arg3[MAX_INPUT_LENGTH];

    char scroll_name[MAX_INPUT_LENGTH];
    OBJ_DATA *scroll;
    OBJ_DATA *ink;

    /*OBJ_DATA *obj;*/
	int sn;
	int new_sn_percent;
	int way_cool_spell;

	int spell_level1;
	int spell_level;
	int spell_level2;

	int percent;

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    argument = one_argument( argument, arg3 );

    if ( ( arg1[0] == '\0' ) || ( arg3[0] == '\0' ) || ( arg2[0] == '\0' ) )
    {
  send_to_char( "Syntax for scribe is: scribe spellname scrollname inkname\n\r", ch );
  return;
    }


    /*Begin the sanity checks*/
    switch ( ch->in_room->sector_type )
    {
    case SECT_MAGELAB_SIMPLE:  break;
    case SECT_MAGELAB_INTERMEDIATE:  break;
    case SECT_MAGELAB_ADVANCED:  break;
    case SECT_MAGELAB_SUPERIOR:  break;
    default:
        send_to_char("You must be in a magelab.\n\r",ch);
        return;
    }


    if ( ( sn = find_spell( ch,arg1 ) ) < 0
    || ( !IS_NPC(ch) && (ch->level < skill_level(ch,sn)
    ||       ch->pcdata->learned[sn] == 0)))
    {
        send_to_char( "You don't know any spells of that name.\n\r", ch );
        return;
    }

    if (skill_table[sn].spell_fun == spell_null)
    {
        send_to_char( "That's not a spell!\n\r", ch );
        return;
    }
    
    if ( skill_table[sn].bitvector & SS_SCRIBE )
    {
	//do nothing
    }
    else
    {
	send_to_char("You may not put that spell on a scroll.\r\n",ch);
	return;
    }

    if ( ( scroll = get_obj_carry( ch, arg2 ) ) == NULL )
    {
        send_to_char( "You do not have that scroll.\n\r", ch );
        return;
    }
    
    if ( ( ink = get_obj_carry( ch, arg3 ) ) == NULL )
    {
	send_to_char( "You do not have that ink.\n\r",ch);
	return;
    }

    
    /*Now that they have a scroll, check to see if it's the right kind for the level */

    spell_level = compute_casting_level( ch, sn ); 
    if (spell_level >= 55)
    {
	spell_level = 54;
    }
    spell_level1 = skill_level(ch,sn);

    if ( spell_level1 >= 50 
    && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_PARCHMENT)
    {
	send_to_char("You need to use a parchment scroll to scribe this spell.\r\n",ch);
	return;
    }

    if ( (spell_level1 >= 39 && spell_level1 <= 49) && (scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM) )
    {
        send_to_char("You need to use a vellum scroll to scribe this spell.\r\n",ch);
        return;
    }

    if ( (spell_level1 >= 25 && spell_level1 <=38)  
    && ( scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_RICEPAPER) ) 
    {
        send_to_char("You need to put that spell on a rice paper scroll.\r\n",ch);
        return;
    }

    if ( (spell_level1 >= 11 && spell_level1 <=24 )
   && ( scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_KOZO) ) 

    {
        send_to_char("You need to scribe that spell on to a kozo scroll. \r\n",ch);
        return;
    }
    if ( (spell_level1 >= 1 && spell_level1 <=10 )
    && (scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_PAPYRUS ) )
    {
	send_to_char("You need to scribe that spell on to a papyrus scroll.\r\n",ch);
        return;
    }


/* Ok put the checks here to see if they succed or not*/

	percent = ( (get_skill(ch,gsn_scribe)*8) / 10 ) ;

	switch ( ink->pIndexData->vnum )
        {
        	case OBJ_VNUM_SCRIBE_DBLOOD:
			percent += 15;
			break;
        	
		case OBJ_VNUM_SCRIBE_INDIGO:  
			percent += 10;
			break;
        	case OBJ_VNUM_SCRIBE_BISTRE:
                        percent += 5;
                        break;

     		case OBJ_VNUM_SCRIBE_SEPIA:
			percent -= 10;
			break;
       		default:
        		percent += 0;
			return;
        }

	percent = URANGE(5,percent,100);

        /*send_to_char("Checking to see if the scribe is going to work or not.\r\n",ch);*/

	new_sn_percent = number_percent( );


	if ( sn == skill_lookup("dispel magic") )
	{
		spell_level2 -= 15;
	}

	if ( (number_percent( ) < percent) )
	{
		/*spell_level2=(spell_level + spell_level1)/2;i*/
		spell_level2=spell_level;
		check_improve(ch,gsn_scribe,TRUE,2);
		sprintf (scroll_name, "a scroll of ");
		strcat (scroll_name, skill_table[sn].name);
                free_string( scroll -> name );
                scroll->name = str_dup(scroll_name);
      		free_string( scroll->short_descr );
      		scroll->short_descr = str_dup(scroll_name); 
      		free_string( scroll->description );
                sprintf (scroll_name, "A scroll of ");
                strcat (scroll_name, skill_table[sn].name);
		strcat (scroll_name, " lies here.\r\n");
      		scroll->description = str_dup(scroll_name); 
		scroll->level = spell_level1;
		scroll->cost = 0;
		scroll->value[1] =  sn;
		scroll->value[0] = spell_level2;
		scroll->value[2] = -1;
		scroll->value[3] = -1;
                scroll->value[4] = -1;
		SET_BIT(scroll->extra_flags,ITEM_NOIDENTIFY);
		/*scroll->extra_flags = ITEM_NOIDENTIFY;*/

                way_cool_spell = number_percent( );

                if (way_cool_spell <= 5)
                {
			send_to_char("Whoa, what is this spell you have scribed?\r\n",ch);
			SET_BIT(scroll->extra_flags,ITEM_HUM);

                        switch ( number_range(0,5)  )
                        {
			case 0:
				scroll->value[3] = skill_lookup("pox");
				scroll->value[2] = sn;
				scroll->value[1] = skill_lookup("haste");
				SET_BIT(scroll->extra_flags,ITEM_MAGIC);
				break;
			case 1:
                                scroll->value[3] = skill_lookup("learned knowledge");
                                scroll->value[1] = sn;
                                scroll->value[2] = skill_lookup("sanctuary");
				SET_BIT(scroll->extra_flags,ITEM_INVIS);
				break;
			case 2:
                                scroll->value[3] = skill_lookup("wrath of the pen");
                                scroll->value[1] = sn;
                                scroll->value[2] = skill_lookup("confusion");
				SET_BIT(scroll->extra_flags,ITEM_EVIL);
				SET_BIT(scroll->extra_flags,ITEM_GLOW);
                                break;
			case 3:
                                scroll->value[3] = skill_lookup("magical rest");
                                scroll->value[2] = sn;
                                scroll->value[1] = skill_lookup("calm");
				SET_BIT(scroll->extra_flags,ITEM_MELT_DROP);
                                break;
			case 4:
                                scroll->value[1] = skill_lookup("haste");
                                scroll->value[2] = skill_lookup("shield");;
                                scroll->value[3] = skill_lookup("giant strength");
				SET_BIT(scroll->extra_flags,ITEM_BLESS);
				SET_BIT(scroll->extra_flags,ITEM_MAGIC);
                                break;
			case 5:
                                scroll->value[1] = skill_lookup("shield");
                                scroll->value[2] = skill_lookup("magical rest");
                                scroll->value[3] = skill_lookup("learned knowledge");
				SET_BIT(scroll->extra_flags,ITEM_NODROP);
				SET_BIT(scroll->extra_flags,ITEM_INVIS);
				SET_BIT(scroll->extra_flags,ITEM_GLOW);
                                break;

                        default:
				break;
                        }
                }



		act("$n begins scribbling furiously on a piece of paper.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
                send_to_char("You have created a new scroll.\r\n",ch);
		extract_obj(ink);

		return;
	}
	else
	{
		/*they fail*/
		check_improve(ch,gsn_scribe,FALSE,4);
		send_to_char("Whoops!  This isn't the scroll you were trying to write.\r\n",ch);
		act("$n spills his ink all over the page.  What a mess.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
		extract_obj(scroll);
		extract_obj(ink);
		return;
	}



} /*end do_scribe */






void do_deposit( CHAR_DATA *ch, char *argument )
{
    int money_has = 0, number_deposit;
    OBJ_DATA *money_lose,  *money_next;
	CHAR_DATA *banker;
	char	buf[MAX_STRING_LENGTH];
	char	buf2[MAX_STRING_LENGTH];
	char	arg[MAX_INPUT_LENGTH];

	one_argument(argument,arg);   

	for (banker=ch->in_room->people;banker!=NULL;banker=banker->next_in_room)
	{
	if (IS_NPC(banker) && IS_SET(banker->act,ACT_IS_CHANGER))
		break;
	}

    if (banker == NULL)
	{
        send_to_char("You don't see any trustworthy bankers around.\n\r",ch);
        return;
	}

    if ( !is_number(arg) )
	{
        send_to_char("Syntax: deposit <# of diamonds>\n\r",ch);
        return;
	}

    /* Prevent people from "depositing" negative numbers of diamonds */
    if ( atoi(arg) < 1 )
	{
	send_to_char("How thoughtful, you're giving it all away!\n\r",ch);
	return;
	}

    /* count how many diamonds there are in inventory */
    for ( money_next = ch->carrying; money_next!=NULL; money_next = money_next->next_content )
        if (money_next->pIndexData->vnum == OBJ_VNUM_EGG)
            money_has++;

    /* Do you even have as many as you want to deposit? */
    if ( money_has   < atoi(arg) )
	{
	send_to_char("You aren't carrying that many.\n\r",ch);
	return;
	}

	number_deposit = atoi(arg);

    for (money_lose = ch->carrying; 
         money_lose != NULL;
         money_lose = money_next )
	{
        money_next = money_lose->next_content;

        if ( money_next->pIndexData->vnum == OBJ_VNUM_EGG)
        {
            obj_from_char(money_lose);
            extract_obj(money_lose);
            ch->in_bank++;
            if ( --number_deposit == 0)
                break;
        }
	}	

    sprintf(buf,"You deposit %d diamond%s.",atoi(arg),atoi(arg) == 1 ? "" : "s");
    sprintf(buf2,"$n deposits %d diamond%s.",atoi(arg),atoi(arg) == 1 ? "" : "s");
	act(buf,ch,NULL,NULL,TO_CHAR,FALSE);
	act(buf2,ch,NULL,NULL,TO_ROOM,FALSE);
    sprintf(buf,"Your balance is %d diamond%s.\n\r",ch->in_bank,ch->in_bank == 1 ? "" : "s");
	send_to_char(buf,ch);	
	return;
}

void do_withdraw( CHAR_DATA *ch, char *argument )
{
	int i;
    OBJ_DATA *money;
	CHAR_DATA *banker;
	char	buf[MAX_STRING_LENGTH];
	char	buf2[MAX_STRING_LENGTH];
	char	arg[MAX_INPUT_LENGTH];

	one_argument(argument,arg);

    for(banker=ch->in_room->people;banker!=NULL;banker=banker->next_in_room)
    {
	if(IS_NPC(banker) && IS_SET(banker->act,ACT_IS_CHANGER))
		break;
    }

    if(banker == NULL)
    {
	send_to_char("You don't see any trustworthy bankers around.\n\r",ch);
	return;
    }

    if ( !ch->in_bank )
    {
	send_to_char("You don't have any assets saved.\n\r",ch);
	return;
    }
   
    if ( arg[0] == '\0' )
    {
    send_to_char("Withdraw how many diamonds?\n\r", ch);
	return;
    }

    if (!is_number(arg))
    {
    send_to_char("Syntax: withdraw <# of diamonds>\n\r",ch);
	return;
    }

    if ( atoi(arg) > ch->in_bank )
    {
	send_to_char("You don't have that kind of money available.\n\r",ch);
	return;
    }

    if ( atoi(arg) < 1 )
    {
	send_to_char("What's that?  You want to donate it all to charity!  How nice!\n\r",ch);
	return;
    }

    for( i = 0 ; i < atoi(arg) ; i++ )
    {
    money = create_object( get_obj_index(OBJ_VNUM_EGG), 0, FALSE );
    obj_to_char(money,ch);
	ch->in_bank--;
    }

    sprintf(buf,"You withdraw %d diamond%s.",atoi(arg),atoi(arg) == 1 ? "" : "s");
    sprintf(buf2,"$n withdraws %d diamond%s.",atoi(arg),atoi(arg) == 1 ? "" : "s");

  
    act(buf,ch,NULL,NULL,TO_CHAR,FALSE);
    act(buf2,ch,NULL,NULL,TO_ROOM,FALSE);

    sprintf(buf,"Your balance is %d diamond%s.\n\r",ch->in_bank,ch->in_bank == 1 ? "" : "s");
    send_to_char(buf,ch);
    return;
}
/* RT part of the corpse looting code */

bool can_loot(CHAR_DATA *ch, OBJ_DATA *obj, bool loot_check)
{
  CHAR_DATA *owner, *wch;

  if (IS_IMMORTAL(ch))
    return TRUE;
    
  owner = NULL;
  if (obj->owner) {
    for ( wch = char_list; wch != NULL ; wch = wch->next )
        if (!str_cmp(wch->name,obj->owner))
            owner = wch;
  }

  if (owner == NULL)
    return TRUE;

  if (!str_cmp(ch->name,owner->name))
    return TRUE;

  if (!IS_NPC(owner) && !IS_NPC(ch))
  {
      if (IS_SET(owner->act,PLR_CANLOOT))
         return TRUE;

     /* Seperate Clan and Nonclan corpses at this point */
     if (owner->clan != 0 && 
          (owner->clan != clan_lookup("matook") 
           || owner->clan != clan_lookup("newbie")))
     {
        if ( (is_same_group(ch,owner) && !is_affected(owner,AFF_CHARM) ) || is_same_clan(ch,owner))
           return TRUE;
     }
     else
     {
        if (is_same_group(ch,owner) )
           if(IS_SET(owner->act,PLR_CANLOOT))
              return TRUE;
     }
  
     if (IS_SET(obj->extra_flags,ITEM_CLAN_CORPSE)
	&& is_clan(ch) && loot_check)
        return TRUE;
  }

  return FALSE;
}


void get_obj( CHAR_DATA *ch, OBJ_DATA *obj, OBJ_DATA *container )
{
    /* variables for AUTOSPLIT */
    CHAR_DATA *gch;
    int members;
    char buffer[100];
    if ( !CAN_WEAR(obj, ITEM_TAKE) )
    {
  send_to_char( "You can't take that.\n\r", ch );
  return;
    }

    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
    {
  act( "$d: you can't carry that many items.",
      ch, NULL, obj->name, TO_CHAR ,FALSE);
  return;
    }


    if ( get_carry_weight(ch) + get_obj_weight( obj ) > can_carry_w( ch ) )
    {
  act( "$d: you can't carry that much weight.",
      ch, NULL, obj->name, TO_CHAR ,FALSE);
  return;
    }

    if (!can_loot(ch,obj,TRUE))
    {
  act("Corpse looting is not permitted.",ch,NULL,NULL,TO_CHAR ,FALSE);
  return;
    }

    if (obj->in_room != NULL)
    {
  for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
      if (gch->on == obj)
      {
    act("$N appears to be using $p.",
        ch,obj,gch,TO_CHAR,FALSE);
    return;
      }
    }
   
    if ( container != NULL )
    {
      if (container->pIndexData->vnum == OBJ_VNUM_PIT
  &&  get_trust(ch) < obj->level)
  {
      send_to_char("You are not powerful enough to use it.\n\r",ch);
      return;
  }

      if (container->pIndexData->vnum == OBJ_VNUM_PIT
  &&  !CAN_WEAR(container, ITEM_TAKE)
  &&  !IS_OBJ_STAT(obj,ITEM_HAD_TIMER))
      obj->timer = 0; 
  act( "You get $p from $P.", ch, obj, container, TO_CHAR ,FALSE);
  act( "$n gets $p from $P.", ch, obj, container, TO_ROOM ,FALSE);

  REMOVE_BIT(obj->extra_flags,ITEM_HAD_TIMER);
  obj_from_obj( obj );
    }
    else
    {
  act( "You get $p.", ch, obj, container, TO_CHAR ,FALSE);
  act( "$n gets $p.", ch, obj, container, TO_ROOM ,FALSE);
  obj_from_room( obj );
    }

    if ( obj->item_type == ITEM_MONEY)
    {
     if ( (get_carry_weight(ch) + obj->value[0]/10 + obj->value[1]*2/5)
          > can_carry_w( ch )) 
     {
       act( "$N can't carry that much weight.", ch, NULL, ch, TO_CHAR ,FALSE);
       obj_to_room( obj, ch->in_room );
       return;
     }
  ch->silver += obj->value[0];
  ch->gold += obj->value[1];
        if (IS_SET(ch->act,PLR_AUTOSPLIT))
        { /* AUTOSPLIT code */
        members = 0;
        for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
        {
            if (!IS_AFFECTED(gch,AFF_CHARM) && is_same_group( gch, ch ) )
              members++;
        }

    if ( members > 1 && (obj->value[0] > 1 || obj->value[1]))
    {
      sprintf(buffer,"%d %d",obj->value[0],obj->value[1]);
      do_split(ch,buffer);  
    }
        }
 
  extract_obj( obj );
    }
    else
    {
  obj_to_char( obj, ch );
    }

    return;
}

void do_specializ( CHAR_DATA *ch, char *argument )
{
    send_to_char("This command must be entered in full.\n\r",ch);
    return;
}

void do_specialize( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *mob;
    int weapon;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
	send_to_char("Syntax: specialize <weapon group>\n\r",ch);
	send_to_char("        specialize help\n\r",ch);
        return;
    }

    if ( IS_NPC(ch) )
	return;

    if ( ch->pcdata->old_class != class_lookup("warrior") )
    {
        send_to_char("Only warriors may specialize.\n\r",ch);
        return;
    }

    if ( !str_cmp( arg, "help" ) )
    {
	int i;

	do_help(ch,"specialize");

	send_to_char("Valid weapon groups are:\n\r",ch);
	send_to_char("(Note that these may not all be available "
		     " depeding on your class)\n\r",ch);
	for ( i = skill_lookup("axe" ) ;
	      i <= skill_lookup("whip") ;
	      i++ )
	{
	    sprintf(buf," * %-12s %d\n\r", 
		skill_table[i].name,
		(10 * skill_table[i].rating[ch->class]));
	    send_to_char(buf,ch);
 	}

	return;
    }

    if ( IS_NPC(ch) )
	return;

    for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
    {
       if ( IS_NPC(mob) && IS_SET(mob->act, ACT_TRAIN) )
       break;
    }
 
    if ( mob == NULL )
    {
       send_to_char( "You can't do that here.\n\r", ch );
       return;
    }

    /* Get GSN for weapon skill */
    weapon = skill_lookup(arg);

    if ( weapon            < skill_lookup("axe") ||
	 weapon            > skill_lookup("whip") )
    {
	send_to_char("That's not a valid weapon group.\n\r",ch);
	return;
    }

/*
	ch->train < skill_table[weapon].rating[ch->class] )
*/
    if ( !HAS_KIT(ch,"myrmidon") &&
	ch->practice < skill_table[weapon].rating[ch->class] * 10 )
    {
	send_to_char("You don't have enough practices to specialize.\n\r",ch);
	return;
    }

    if ( ch->pcdata->learned[weapon] == 0 )
    {
	send_to_char("You don't know that weapon group anyway!\n\r",ch);
	return;
    }

    /* Special handling */
    if ( class_table[ch->class].reclass )
    {
	int fCan = TRUE;

       if ( ch->class == class_lookup("samurai") )
       {
	  if ( weapon != skill_lookup("sword") &&
	       weapon != skill_lookup("polearm") &&
	       weapon != skill_lookup("dagger") )
		fCan = FALSE;
	}
	else
	if ( ch->class == class_lookup("paladin") )
	{
	  if ( weapon != skill_lookup("sword") &&
	       weapon != skill_lookup("flail") &&
	       weapon != skill_lookup("mace" ) )
		fCan = FALSE;
	}
	else
	if ( ch->class == class_lookup("berzerker") )
	{
	  if ( weapon != skill_lookup("sword") &&
	       weapon != skill_lookup("mace") &&
	       weapon != skill_lookup("axe") )
		fCan = FALSE;
	}

	if ( !fCan )
	{
	    send_to_char("You cannot specialize in that.\n\r",ch);
	    return;
	 }
   }
   if ( !HAS_KIT(ch,"myrmidon") )
      ch->practice -= skill_table[weapon].rating[ch->class] * 10;
    /*
   ch->train -= skill_table[weapon].rating[ch->class];
    */
   ch->pcdata->specialize = weapon;
   send_to_char("You are now specialized.\n\r",ch);
   return;
}


void do_loot( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    OBJ_DATA *container;
    bool found;

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }
    
    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if (!str_cmp(arg2,"from"))
       argument = one_argument(argument,arg2);

    /* no loot 1. corpse */
    number_argument(arg1,arg1);
    
    /* Get type. */
    if ( arg1[0] == '\0' || arg2[0] == '\0' )
    {
	send_to_char( "Loot what?\n\r", ch );
	return;
    }

    if ( ( container = get_obj_here( ch, arg2 ) ) == NULL )
    {  
      act( "I see no $T here.", ch, NULL, arg2, TO_CHAR ,FALSE);
      return;
    }  

  switch ( container->item_type )
  {  
  default:
      send_to_char( "That's not a container.\n\r", ch );
      return;
     
  case ITEM_CONTAINER:
  case ITEM_CORPSE_NPC:
    {
	send_to_char( "Use 'get'.\n\r", ch );
	return;
    }

  case ITEM_CORPSE_PC:
      {
    if (!can_loot(ch,container,TRUE))
    {
        send_to_char( "You can't do that.\n\r", ch );
        return;
    }
      }

  if ( str_cmp( arg1, "all" ) && str_prefix( "all.", arg1 ) )
  {
      /* 'get obj container' */
      obj = get_obj_list( ch, arg1, container->contains );
      if ( obj == NULL )
      {
    act( "I see nothing like that in the $T.",
        ch, NULL, arg2, TO_CHAR ,FALSE);
    return;
      }
/* Loot counter DISABLED by Nightdagger on 04/07/03

      if (  obj->item_type != ITEM_GEM && obj->item_type != ITEM_JEWELRY
	 && obj->item_type != ITEM_PILL && obj->item_type != ITEM_COMPONENT
	 && obj->item_type != ITEM_KEY && obj->item_type != ITEM_TREASURE
	 && obj->item_type != ITEM_SCROLL && obj->item_type != ITEM_WAND
	 && obj->item_type != ITEM_STAFF && obj->item_type != ITEM_POTION
	 && obj->item_type != ITEM_TRAP && obj->item_type != ITEM_GRENADE 
	 && obj->item_type != ITEM_MONEY && obj->item_type != ITEM_TRASH
	 && obj->item_type != ITEM_CONTAINER && !can_loot(ch,container,FALSE) )
      {
        if(container->value[4] > 0)
	{
	  container->value[4]--;
	}
        else
        {
	  send_to_char("This one has been picked clean already.\n\r",ch);
	  return;
	}
      }
	
*/	
      /* found something to grab, lag'em a bit */
      WAIT_STATE( ch, 12);
      get_obj( ch, obj, container );
      obj->stolen_timer += 10 * number_fuzzy(5);
  }
  else 
  {  
      /* 'get all container' or 'get all.obj container' */
      found = FALSE;
      for ( obj = container->contains; obj != NULL; obj = obj_next )
      {
    obj_next = obj->next_content;
    if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
    &&   can_see_obj( ch, obj ) )
    {
        found = TRUE;
        if( (container->pIndexData->vnum == OBJ_VNUM_PIT
        	&&  !IS_IMMORTAL(ch))
	   || (!can_loot(ch,container,FALSE)
		&& !IS_IMMORTAL(ch)) )
        {
          send_to_char("Don't be so greedy!\n\r",ch);
          return;
        }
        get_obj( ch, obj, container );
	obj->stolen_timer += 10 * number_fuzzy(5);
    }
      }
      
      if ( !found )
      {
    if ( arg1[3] == '\0' )
        act( "I see nothing in the $T.",
      ch, NULL, arg2, TO_CHAR ,FALSE);
    else
        act( "I see nothing like that in the $T.",
      ch, NULL, arg2, TO_CHAR ,FALSE);
      }
  }   
    }
    
    return;
}

void do_get( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    CHAR_DATA *victim_next;
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    OBJ_DATA *container;
    bool found;
    bool corpsefound = FALSE;
    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }

    
    if (!str_cmp(arg2,"from"))
  argument = one_argument(argument,arg2);

    /* Get type. */
    if ( arg1[0] == '\0' )
    {
  send_to_char( "Get what?\n\r", ch );
  return;
    }

    if ( arg2[0] == '\0' )
    {
  if ( str_cmp( arg1, "all" ) && str_prefix( "all.", arg1 ) )
  {
      /* 'get obj' */
      obj = get_obj_list( ch, arg1, ch->in_room->contents );
      if ( obj == NULL )
      {
    act( "I see no $T here.", ch, NULL, arg1, TO_CHAR ,FALSE);
    return;
      }	/* help hide items with no long description */
	else if ( (strlen(obj->description) < 1 || strlen(arg1) < 2) &&
		!IS_SET(obj->wear_flags,ITEM_TAKE)  )
	{
	act("I see no $T here.", ch, NULL, arg1, TO_CHAR, FALSE);
	return;
	}

      /* Only Clanmates and Groupmates or Yourself can get your corpse */
      if (obj->item_type == ITEM_CORPSE_PC && obj->owner != NULL 
	  && !IS_IMMORTAL(ch))
      {
	 found = FALSE;
         for ( victim = char_list; victim != NULL; victim = victim_next )
         {
            victim_next  = victim->next;
            if (is_name(obj->owner,victim->name))
            {
               found = TRUE;
               break;
            }
         }

         if(found && victim != ch && obj->contains != NULL) 
	 {
            if (!is_same_group( victim, ch ))
	    {
	       if(ch->clan != victim->clan || ch->clan == clan_lookup("loner")
		  || (ch->clan == victim->clan && (ch->level > victim->level+8
		  || ch->level +8 < victim->level)))  
	       {
	          send_to_char("You are not allowed to get the corpse.\n\r",ch);
	          return;
	       }
	    }
	 }
      }

      get_obj( ch, obj, NULL );
  }
  else
  {
      /* 'get all' or 'get all.obj' */
      found = FALSE;
      for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
      {
         obj_next = obj->next_content;
	 if ( strlen(obj->description) < 1 && !IS_SET(obj->wear_flags,ITEM_TAKE) ) /* hide items with no long descr */
		continue;
         if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
               &&   can_see_obj( ch, obj ) )
         {
            /* Only Clanmates and Groupmates or Yourself can get your corpse */
	    corpsefound = FALSE;
            if (obj->item_type == ITEM_CORPSE_PC && obj->owner != NULL
		&& !IS_IMMORTAL(ch))
            {
	       found = FALSE;
               for ( victim = char_list; victim != NULL; victim = victim_next )
               {
                  victim_next  = victim->next;
                  if (is_name(obj->owner,victim->name))
                  {
                     found = TRUE;
                     break;
                  }
               }

              if(found && victim != ch) 
	      {
                 if (!is_same_group( victim, ch ))
	         {
	            if(ch->clan != victim->clan 
		       || ch->clan == clan_lookup("loner")
		       || (ch->clan == victim->clan 
			   && (ch->level > victim->level+8
		       || ch->level +8 < victim->level)))  
	            {
		       corpsefound = TRUE;
	            }
	         }
	      }
           }

           found = TRUE;
	   if (corpsefound)
	      send_to_char("You are not allowed to get the corpse.\n\r",ch);
	   else
              get_obj( ch, obj, NULL );
        }
     }

      if ( !found ) 
      {
    if ( arg1[3] == '\0' )
        send_to_char( "I see nothing here.\n\r", ch );
    else
        act( "I see no $T here.", ch, NULL, &arg1[4], TO_CHAR ,FALSE);
      }
  }
    }
    else
    {
  /* 'get ... container' */
  if ( !str_cmp( arg2, "all" ) || !str_prefix( "all.", arg2 ) )
  {
      send_to_char( "You can't do that.\n\r", ch );
      return;
  }

  if ( ( container = get_obj_here( ch, arg2 ) ) == NULL )
  {
      act( "I see no $T here.", ch, NULL, arg2, TO_CHAR ,FALSE);
      return;
  }

  switch ( container->item_type )
  {
  default:
      send_to_char( "That's not a container.\n\r", ch );
      return;

  case ITEM_CONTAINER:
  case ITEM_CORPSE_NPC:
  case ITEM_FORGE:
      break;

  case ITEM_CORPSE_PC:
      {
	if (container->owner != NULL && !is_name(container->owner,ch->name))
	{
          send_to_char( "Use 'loot'.\n\r", ch );
          return;
	}
	break;
      }
  }


  if ( (IS_SET(container->value[1], CONT_CLOSED)) && container->item_type == ITEM_CONTAINER )
  {
      act( "The $d is closed.", ch, NULL, container->name, TO_CHAR ,FALSE);
      return;
  }

  if ( str_cmp( arg1, "all" ) && str_prefix( "all.", arg1 ) )
  {
      /* 'get obj container' */
      obj = get_obj_list( ch, arg1, container->contains );
      if ( obj == NULL )
      {
    act( "I see nothing like that in the $T.",
        ch, NULL, arg2, TO_CHAR ,FALSE);
    return;
      }
      get_obj( ch, obj, container );
  }
  else
  {
      /* 'get all container' or 'get all.obj container' */
      found = FALSE;
      for ( obj = container->contains; obj != NULL; obj = obj_next )
      {
    obj_next = obj->next_content;
    if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
    &&   can_see_obj( ch, obj ) )
    {
        found = TRUE;
        if (container->pIndexData->vnum == OBJ_VNUM_PIT
        &&  !IS_IMMORTAL(ch))
        {
          send_to_char("Don't be so greedy!\n\r",ch);
          return;
        }
        get_obj( ch, obj, container );
    }
      }

      if ( !found )
      {
    if ( arg1[3] == '\0' )
        act( "I see nothing in the $T.",
      ch, NULL, arg2, TO_CHAR ,FALSE);
    else
        act( "I see nothing like that in the $T.",
      ch, NULL, arg2, TO_CHAR ,FALSE);
      }
  }
    }

    return;
}


void do_put( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    OBJ_DATA *container;
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if (!str_cmp(arg2,"in") || !str_cmp(arg2,"on"))
  argument = one_argument(argument,arg2);

    if ( arg1[0] == '\0' || arg2[0] == '\0' )
    {
  send_to_char( "Put what in what?\n\r", ch );
  return;
    }

    if ( !str_cmp( arg2, "all" ) || !str_prefix( "all.", arg2 ) )
    {
  send_to_char( "You can't do that.\n\r", ch );
  return;
    }

    if ( ( container = get_obj_here( ch, arg2 ) ) == NULL )
    {
  act( "I see no $T here.", ch, NULL, arg2, TO_CHAR ,FALSE);
  return;
    }

    if ( container->item_type != ITEM_CONTAINER && container->item_type != ITEM_FORGE)
    {
  send_to_char( "That's not a container.\n\r", ch );
  return;
    }

    if ( IS_SET(container->value[1], CONT_CLOSED) && container->item_type == ITEM_CONTAINER )
    {
  act( "The $d is closed.", ch, NULL, container->name, TO_CHAR ,FALSE);
  return;
    }

    if ( str_cmp( arg1, "all" ) && str_prefix( "all.", arg1 ) )
    {
  /* 'put obj container' */
  if ( ( obj = get_obj_carry( ch, arg1 ) ) == NULL )
  {
      send_to_char( "You do not have that item.\n\r", ch );
      return;
  }

  if ( obj == container )
  {
      send_to_char( "You can't fold it into itself.\n\r", ch );
      return;
  }

  if ( !can_drop_obj( ch, obj ) )
  {
      send_to_char( "You can't let go of it.\n\r", ch );
      return;
  }

      if (WEIGHT_MULT(obj) != 100)
      {
           send_to_char("You have a feeling that would be a bad idea.\n\r",ch);
            return;
        }

  if ((get_obj_weight( obj ) + get_true_weight( container )
       > (container->value[0] * 10) 
  ||  get_obj_weight(obj) > (container->value[3] * 10)) && container->item_type == ITEM_CONTAINER)
  {
      send_to_char( "It won't fit.\n\r", ch );
      return;
  }
  
  if (container->pIndexData->vnum == OBJ_VNUM_PIT 
  &&  !CAN_WEAR(container,ITEM_TAKE))
  {
      if (obj->timer)
    SET_BIT(obj->extra_flags,ITEM_HAD_TIMER);
      else
          obj->timer = number_range(100,200);
   }

  obj_from_char( obj );
  obj_to_obj( obj, container );

  if (IS_SET(container->value[1],CONT_PUT_ON) && container->item_type == ITEM_CONTAINER)
  {
      act("$n puts $p on $P.",ch,obj,container, TO_ROOM,FALSE);
      act("You put $p on $P.",ch,obj,container, TO_CHAR,FALSE);
  }
  else
  {
      act( "$n puts $p in $P.", ch, obj, container, TO_ROOM ,FALSE);
      act( "You put $p in $P.", ch, obj, container, TO_CHAR ,FALSE);
  }
    }
    else
    {
  /* 'put all container' or 'put all.obj container' */
  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
      obj_next = obj->next_content;

      if ( (( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
      &&   can_see_obj( ch, obj )
      &&   WEIGHT_MULT(obj) == 100
      &&   obj->wear_loc == WEAR_NONE
      &&   obj != container
      &&   can_drop_obj( ch, obj )
      &&   get_obj_weight( obj ) + get_true_weight( container )
     <= (container->value[0] * 10) 
      &&   get_obj_weight(obj) <= (container->value[3] * 10)) && container->item_type == ITEM_CONTAINER)
      {
        if (container->pIndexData->vnum == OBJ_VNUM_PIT
        &&  !CAN_WEAR(obj, ITEM_TAKE) )
	{
            if (obj->timer)
      SET_BIT(obj->extra_flags,ITEM_HAD_TIMER);
            else
              obj->timer = number_range(100,200);
	 }
    obj_from_char( obj );
    obj_to_obj( obj, container );

          if (IS_SET(container->value[1],CONT_PUT_ON))
          {
                  act("$n puts $p on $P.",ch,obj,container, TO_ROOM,FALSE);
                  act("You put $p on $P.",ch,obj,container, TO_CHAR,FALSE);
          }
    else
    {
        act( "$n puts $p in $P.", ch, obj, container, TO_ROOM ,FALSE);
        act( "You put $p in $P.", ch, obj, container, TO_CHAR ,FALSE);
    }
      }
  }
    }

    return;
}



void do_drop( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    bool found;

    argument = one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg[0] == '\0' )
    {
  send_to_char( "Drop what?\n\r", ch );
  return;
    }

    if ( is_number( arg ) )
    {
  /* 'drop NNNN coins' */
  int amount, gold = 0, silver = 0;

  amount   = atoi(arg);
  argument = one_argument( argument, arg );
  if ( amount <= 0
  || ( str_cmp( arg, "coins" ) && str_cmp( arg, "coin" ) && 
       str_cmp( arg, "gold"  ) && str_cmp( arg, "silver") ) )
  {
      send_to_char( "Sorry, you can't do that.\n\r", ch );
      return;
  }

  if ( !str_cmp( arg, "coins") || !str_cmp(arg,"coin") 
  ||   !str_cmp( arg, "silver"))
  {
      if (ch->silver < amount)
      {
    send_to_char("You don't have that much silver.\n\r",ch);
    return;
      }

      ch->silver -= amount;
      silver = amount;
  }

  else
  {
      if (ch->gold < amount)
      {
    send_to_char("You don't have that much gold.\n\r",ch);
    return;
      }

      ch->gold -= amount;
        gold = amount;
  }

  for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
  {
      obj_next = obj->next_content;

      switch ( obj->pIndexData->vnum )
      {
      case OBJ_VNUM_SILVER_ONE:
    silver += 1;
    extract_obj(obj);
    break;

      case OBJ_VNUM_GOLD_ONE:
    gold += 1;
    extract_obj( obj );
    break;

      case OBJ_VNUM_SILVER_SOME:
    silver += obj->value[0];
    extract_obj(obj);
    break;

      case OBJ_VNUM_GOLD_SOME:
    gold += obj->value[1];
    extract_obj( obj );
    break;

      case OBJ_VNUM_COINS:
    silver += obj->value[0];
    gold += obj->value[1];
    extract_obj(obj);
    break;
      }
  }

  obj_to_room( create_money( gold, silver ), ch->in_room );
  act( "$n drops some coins.", ch, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( "OK.\n\r", ch );
  return;
    }

    if ( str_cmp( arg, "all" ) && str_prefix( "all.", arg ) )
    {
  /* 'drop obj' */
  if ( ( obj = get_obj_carry( ch, arg ) ) == NULL )
  {
      send_to_char( "You do not have that item.\n\r", ch );
      return;
  }

  if ( !can_drop_obj( ch, obj ) )
  {
      send_to_char( "You can't let go of it.\n\r", ch );
      return;
  }

  obj_from_char( obj );
  obj_to_room( obj, ch->in_room );
  act( "$n drops $p.", ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You drop $p.", ch, obj, NULL, TO_CHAR ,FALSE);
  if (IS_OBJ_STAT(obj,ITEM_MELT_DROP))
  {
      act("$p dissolves into smoke.",ch,obj,NULL,TO_ROOM,FALSE);
      act("$p dissolves into smoke.",ch,obj,NULL,TO_CHAR,FALSE);
      extract_obj(obj);
  }
    }
    else
    {
  /* 'drop all' or 'drop all.obj' */
  found = FALSE;
  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
      obj_next = obj->next_content;

      if ( ( arg[3] == '\0' || is_name( &arg[4], obj->name ) )
      &&   can_see_obj( ch, obj )
      &&   obj->wear_loc == WEAR_NONE
      &&   can_drop_obj( ch, obj ) )
      {
    found = TRUE;
    obj_from_char( obj );
    obj_to_room( obj, ch->in_room );
    act( "$n drops $p.", ch, obj, NULL, TO_ROOM ,FALSE);
    act( "You drop $p.", ch, obj, NULL, TO_CHAR ,FALSE);
          if (IS_OBJ_STAT(obj,ITEM_MELT_DROP))
          {
                  act("$p dissolves into smoke.",ch,obj,NULL,TO_ROOM,FALSE);
                  act("$p dissolves into smoke.",ch,obj,NULL,TO_CHAR,FALSE);
                  extract_obj(obj);
          }
      }
  }

  if ( !found )
  {
      if ( arg[3] == '\0' )
    act( "You are not carrying anything.",
        ch, NULL, arg, TO_CHAR ,FALSE);
      else
    act( "You are not carrying any $T.",
        ch, NULL, &arg[4], TO_CHAR ,FALSE);
  }
    }

    return;
}



void do_give( CHAR_DATA *ch, char *argument )
{
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA  *obj;

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }
  

    if ( arg1[0] == '\0' || arg2[0] == '\0' )
    {
  send_to_char( "Give what to whom?\n\r", ch );
  return;
    }

    if ( is_number( arg1 ) )
    {
  /* 'give NNNN coins victim' */
  int amount;
  bool silver;

  amount   = atoi(arg1);
  if ( amount <= 0
  || ( str_cmp( arg2, "coins" ) && str_cmp( arg2, "coin" ) && 
       str_cmp( arg2, "gold"  ) && str_cmp( arg2, "silver")) )
  {
      send_to_char( "Sorry, you can't do that.\n\r", ch );
      return;
  }

  silver = str_cmp(arg2,"gold");

  argument = one_argument( argument, arg2 );
  if ( arg2[0] == '\0' )
  {
      send_to_char( "Give what to whom?\n\r", ch );
      return;
  }

  if ( ( victim = get_char_room( ch, arg2 ) ) == NULL )
  {
      send_to_char( "They aren't here.\n\r", ch );
      return;
  }

  if( is_affected(victim,skill_lookup("wraithform")) )
  {
    send_to_char( "They are made of mist, how can they hold it.\n\r", ch);
    return;
  }

  if ( victim == ch )
  {
        send_to_char( "Why bother giving something to yourself?\n\r", ch);
        return;
  }

  if ( (!silver && ch->gold < amount) || (silver && ch->silver < amount) )
  {
      send_to_char( "You haven't got that much.\n\r", ch );
      return;
  }

  if (silver)
  {
   if (!IS_NPC(victim) &&
       get_carry_weight(victim) + amount/10 > can_carry_w( victim ) )
    {
      act( "$N can't carry that much weight.", ch, NULL, victim, TO_CHAR ,FALSE);
      return;
    }
      ch->silver    -= amount;
      victim->silver  += amount;
  }
  else
  {
   if (!IS_NPC(victim) &&
       get_carry_weight(victim) + amount*2/5 > can_carry_w( victim ) )
    {
     act( "$N can't carry that much weight.", ch, NULL, victim, TO_CHAR ,FALSE);
      return;
    }
      ch->gold    -= amount;
      victim->gold  += amount;
  }

  sprintf(buf,"$n gives you %d %s.",amount, silver ? "silver" : "gold");
  act( buf, ch, NULL, victim, TO_VICT    ,FALSE);
  act( "$n gives $N some coins.",  ch, NULL, victim, TO_NOTVICT ,FALSE);
  sprintf(buf,"You give $N %d %s.",amount, silver ? "silver" : "gold");
  act( buf, ch, NULL, victim, TO_CHAR    ,FALSE);

  if (IS_NPC(victim) && IS_SET(victim->act,ACT_IS_CHANGER))
  {
      int change;

      change = (silver ? 95 * amount / 100 / 100 
           : 95 * amount);


      if (!silver && change > victim->silver)
        victim->silver += change;

      if (silver && change > victim->gold)
        victim->gold += change;

      if (change < 1 && can_see(victim,ch,FALSE))
      {
    act(
  "$n tells you 'I'm sorry, you did not give me enough to change.'"
        ,victim,NULL,ch,TO_VICT,FALSE);
    ch->reply = victim;
    sprintf(buf,"%d %s %s", 
      amount, silver ? "silver" : "gold",ch->name);
    do_give(victim,buf);
      }
      else if (can_see(victim,ch,FALSE))
      {
    sprintf(buf,"%d %s %s", 
      change, silver ? "gold" : "silver",ch->name);
    do_give(victim,buf);
    if (silver)
    {
        sprintf(buf,"%d silver %s", 
      (95 * amount / 100 - change * 100),ch->name);
        do_give(victim,buf);
    }
    act("$n tells you 'Thank you, come again.'",
        victim,NULL,ch,TO_VICT,FALSE);
    ch->reply = victim;
      }
  }
  return;
    }

    if ( ( victim = get_char_room( ch, arg2 ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
 }
    if ( ( obj = get_obj_carry( ch, arg1 ) ) == NULL )
    {
  send_to_char( "You do not have that item.\n\r", ch );
  return;
    }

    if ( obj->wear_loc != WEAR_NONE )
    {
  send_to_char( "You must remove it first.\n\r", ch );
  return;
    }

    if ( ( victim = get_char_room( ch, arg2 ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }
if( is_affected(victim,skill_lookup("wraithform")) )
  {
    send_to_char( "They are made of mist, how can they hold it.\n\r", ch);
    return;
  }


  if ( victim == ch )
  {
        send_to_char( "Why bother giving something to yourself?\n\r", ch);
        return;
  }

    if (IS_NPC(victim) && victim->pIndexData->pShop != NULL
	&& victim->spec_fun == 0  && !IS_IMMORTAL(ch))
    {
  act("$N tells you 'Sorry, you'll have to sell that.'",
      ch,NULL,victim,TO_CHAR,FALSE);
  ch->reply = victim;
  return;
    }

    if ( !can_drop_obj( ch, obj ) && !IS_IMMORTAL(victim) )
    {
  send_to_char( "You can't let go of it.\n\r", ch );
  return;
    }

    if ( victim->carry_number + get_obj_number( obj ) > can_carry_n( victim ) )
    {
  act( "$N has $S hands full.", ch, NULL, victim, TO_CHAR ,FALSE);
  return;
    }

    if (get_carry_weight(victim) + get_obj_weight(obj) > can_carry_w( victim ) )
    {
  act( "$N can't carry that much weight.", ch, NULL, victim, TO_CHAR ,FALSE);
  return;
    }

    if ( !IS_IMMORTAL(ch) && !can_see_obj( victim, obj ) )
    {
  act( "$N can't see it.", ch, NULL, victim, TO_CHAR ,FALSE);
  return;
    }

    if (IS_NPC(victim) && IS_SET(victim->act, ACT_IS_WEAPONSMITH) && (obj->item_type == ITEM_WEAPON) )
    {
      int condition,original,i, cost;
      condition =0;
      original = 0;
      cost = 0;
      i =0;
      for ( i=1; i<3 ; i++ )
      {
	 condition += obj->value[i];
	 original += obj->pIndexData->value[i];
      }
      if ( ( cost = (original - condition)* 2000) == 0)
      {
    act("$n tells you 'I'm sorry, I would only damage this weapon.'"
        ,victim,NULL,ch,TO_VICT,FALSE);
    ch->reply = victim;
	return;
      }
      if ( ( ch->silver + 100 * ch->gold) < cost )
      {
    act("$n tells you 'I'm sorry, you can't afford my services.'"
        ,victim,NULL,ch,TO_VICT,FALSE);
    ch->reply = victim;
	return;
      }
      deduct_cost(ch,cost);
      for ( i=1; i<3 ; i++ )
      {
	obj->value[i] = obj->pIndexData->value[i];
      }
    act("$n tells you 'Thank you, come again.'",
        victim,NULL,ch,TO_VICT,FALSE);
    ch->reply = victim;
      return;
    }

    if (IS_NPC(victim) && IS_SET(victim->act, ACT_IS_ARMOURER) && (obj->item_type == ITEM_ARMOR) )
    {
      int condition,original,i, cost;
      condition =0;
      original = 0;
      cost = 0;
      i =0;
      for ( i=0; i<4 ; i++ )
      {
	 condition += obj->value[i];
	 original += obj->pIndexData->value[i];
      }
      if ( ( cost = (original - condition)* 200) == 0)
      {
    act("$n tells you 'I'm sorry, I would only damage this piece of armor.'"
        ,victim,NULL,ch,TO_VICT,FALSE);
    ch->reply = victim;
	return;
      }
      if ( ( ch->silver + 100 * ch->gold) < cost )
      {
    act("$n tells you 'I'm sorry, you can't afford my services.'"
        ,victim,NULL,ch,TO_VICT,FALSE);
    ch->reply = victim;
	return;
      }
      deduct_cost(ch,cost);
      for ( i=0; i<4 ; i++ )
      {
	obj->value[i] = obj->pIndexData->value[i];
      }
    act("$n tells you 'Thank you, come again.'",
        victim,NULL,ch,TO_VICT,FALSE);
    ch->reply = victim;
      return;

    }
    obj_from_char( obj );
    obj_to_char( obj, victim );
    act( "$n gives $p to $N.", ch, obj, victim, TO_NOTVICT ,FALSE);
    act( "$n gives you $p.",   ch, obj, victim, TO_VICT    ,FALSE);
    act( "You give $p to $N.", ch, obj, victim, TO_CHAR    ,FALSE);
    return;
}


void do_lick( CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *obj;
    AFFECT_DATA af;

    if ( ch->race != race_lookup("goblin") || ch->level < 15 )
    {
	send_to_char("You'll just cut your tongue.\n\r",ch);
	return;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( argument == '\0' )
    {
  send_to_char("What do you wish to poison?\n\r",ch);
  return;
    }

        if ( ( obj = get_obj_list(ch,argument,ch->carrying) ) == NULL )
	{
     send_to_char("You are not carrying that.\n\r",ch);
     return;
	}

    if ( obj->item_type != ITEM_WEAPON )
    {
	send_to_char("That isn't a weapon.\n\r",ch);
	return;
    }

    /* bladed weapons only */
    /* since some exotscs could have blades, we'll just use damage type */
    if ( attack_table[obj->value[3]].damage <= 0 ||
	 attack_table[obj->value[3]].damage == DAM_BASH )
    {
	send_to_char("Bladed weapons only.\n\r",ch);
	return;
    }

    if ( IS_WEAPON_STAT(obj,WEAPON_POISON) )
    {
	send_to_char("This weapon is already poisoned.\n\r",ch);
	return;
    }

       af.where     = TO_WEAPON;
       af.type		= gsn_poison;
       af.level		= ch->level + ( ch->level / 10 );
       af.duration	= ( ch->level / 2 );
       af.location	= 0;
       af.modifier	= 0;
       af.bitvector	= WEAPON_POISON;

       affect_to_obj(obj,&af);

	act("$n licks $p.",ch,obj,NULL,TO_ROOM,FALSE);
	act("You lick $p.",ch,obj,NULL,TO_CHAR,FALSE);

	return;
}

/* for poisoning weapons and food/drink */
void do_envenom(CHAR_DATA *ch, char *argument)
{
    OBJ_DATA *obj;
    AFFECT_DATA af;
    int skill;

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    /* find out what */
    if (argument[0] == '\0')
    {
  send_to_char("Envenom what item?\n\r",ch);
  return;
    }

    obj =  get_obj_list(ch,argument,ch->carrying);

    if (obj== NULL)
    {
  send_to_char("You don't have that item.\n\r",ch);
  return;
    }

    if ((skill = get_skill(ch,gsn_envenom)) < 1)
    {
  send_to_char("Are you crazy? You'd poison yourself!\n\r",ch);
  return;
    }

    if (obj->item_type == ITEM_FOOD || obj->item_type == ITEM_DRINK_CON)
    {
  if (IS_OBJ_STAT(obj,ITEM_BLESS) || IS_OBJ_STAT(obj,ITEM_BURN_PROOF))
  {
      act("You fail to poison $p.",ch,obj,NULL,TO_CHAR,FALSE);
      return;
  }

  if (number_percent() < skill)  /* success! */
  {
      act("$n treats $p with deadly poison.",ch,obj,NULL,TO_ROOM,FALSE);
      act("You treat $p with deadly poison.",ch,obj,NULL,TO_CHAR,FALSE);
      if (!obj->value[3])
      {
    obj->value[3] = 1;
    check_improve(ch,gsn_envenom,TRUE,4);
      }
      WAIT_STATE(ch,skill_table[gsn_envenom].beats);
      return;
  }

  act("You fail to poison $p.",ch,obj,NULL,TO_CHAR,FALSE);
  if (!obj->value[3])
      check_improve(ch,gsn_envenom,FALSE,4);
  WAIT_STATE(ch,skill_table[gsn_envenom].beats);
  return;
     }

    if (obj->item_type == ITEM_WEAPON)
    {
        if (IS_WEAPON_STAT(obj,WEAPON_FLAMING)
        ||  IS_WEAPON_STAT(obj,WEAPON_FROST)
        ||  IS_WEAPON_STAT(obj,WEAPON_VAMPIRIC)
        ||  IS_WEAPON_STAT(obj,WEAPON_SHARP)
        ||  IS_WEAPON_STAT(obj,WEAPON_VORPAL)
        ||  IS_WEAPON_STAT(obj,WEAPON_SHOCKING)
        ||  IS_OBJ_STAT(obj,ITEM_BLESS) || IS_OBJ_STAT(obj,ITEM_BURN_PROOF))
        {
            act("You can't seem to envenom $p.",ch,obj,NULL,TO_CHAR,FALSE);
            return;
        }

        if (obj->value[3] < 0 
        ||  attack_table[obj->value[3]].damage == DAM_BASH)
        {
           send_to_char("You can only envenom edged weapons.\n\r",ch);
           return;
        }

        if (IS_WEAPON_STAT(obj,WEAPON_POISON))
        {
            act("$p is already envenomed.",ch,obj,NULL,TO_CHAR,FALSE);
            return;
        }

        if (number_percent() < skill)
        {
 
            af.where     = TO_WEAPON;
            af.type      = gsn_poison;
            af.level     = 5 + ch->level/5;
            af.duration  = 5 + ch->level/3;
            af.location  = 0;
            af.modifier  = 0;
            af.bitvector = WEAPON_POISON;
            affect_to_obj(obj,&af);
 
            act("$n coats $p with deadly venom.",ch,obj,NULL,TO_ROOM,FALSE);
            act("You coat $p with venom.",ch,obj,NULL,TO_CHAR,FALSE);
            check_improve(ch,gsn_envenom,TRUE,3);
            WAIT_STATE(ch,skill_table[gsn_envenom].beats);
            return;
        }
	else 
	{
           act("You fail to envenom $p.",ch,obj,NULL,TO_CHAR,FALSE);
           check_improve(ch,gsn_envenom,FALSE,3);
           WAIT_STATE(ch,skill_table[gsn_envenom].beats);
           return;
        }
    }
 
    act("You can't poison $p.",ch,obj,NULL,TO_CHAR,FALSE);
    return;
}

void do_fill( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    OBJ_DATA *obj;
    OBJ_DATA *obj2 = NULL;
    OBJ_DATA *fountain;
    bool found;
    int count;

    argument = one_argument( argument, arg1 );
    one_argument( argument, arg2 );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg1[0] == '\0' )
    {
  send_to_char( "Fill what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_carry( ch, arg1 ) ) == NULL )
    {
  send_to_char( "You do not have that item.\n\r", ch );
  return;
    }

    if( arg2[0] != '\0' )
    {
       if ( ( obj2 = get_obj_here( ch, arg2 ) ) == NULL )
       {
          send_to_char( "You can't find it.\n\r", ch );
          return;
       }
    }

    found = FALSE;
    count = 0;
    for ( fountain = ch->in_room->contents; fountain != NULL;
           fountain = fountain->next_content )
    {
       if (arg2[0] == '\0' )
       {
          if ( fountain->item_type == ITEM_FOUNTAIN )
          {
/*	     if ( ++count == number )
	     {
	     */
                 found = TRUE;
                 break;
	  /*   }	 */ 
          }
       }
       else
       {
	  if ( fountain->item_type == ITEM_FOUNTAIN )
	  {
	     if ( fountain == obj2 )
	     {
		found = TRUE;
		break;
	     }
	  }
       }
    }

    if ( !found )
    {
  send_to_char( "There is no fountain here!\n\r", ch );
  return;
    }

      if ( obj->item_type != ITEM_DRINK_CON  || obj->pIndexData->vnum == OBJ_VNUM_GRAIL)
    {
  send_to_char( "You can't fill that.\n\r", ch );
  return;
    }

    if ( obj->value[1] != 0 && obj->value[2] != fountain->value[2] )
    {
  send_to_char( "There is already another liquid in it.\n\r", ch );
  return;
    }

    if ( obj->value[1] >= obj->value[0] )
    {
  send_to_char( "Your container is full.\n\r", ch );
  return;
    }

    sprintf(buf,"You fill $p with %s from $P.",
  liq_table[fountain->value[2]].liq_name);
    act( buf, ch, obj,fountain, TO_CHAR ,FALSE);
    sprintf(buf,"$n fills $p with %s from $P.",
  liq_table[fountain->value[2]].liq_name);
    act(buf,ch,obj,fountain,TO_ROOM,FALSE);
    obj->value[2] = fountain->value[2];
    obj->value[1] = obj->value[0];
    return;
}

void do_pour (CHAR_DATA *ch, char *argument)
{
    char arg[MAX_STRING_LENGTH],buf[MAX_STRING_LENGTH];
    OBJ_DATA *out, *in;
    CHAR_DATA *vch = NULL;
    int amount;

    argument = one_argument(argument,arg);

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }

    
    if (arg[0] == '\0' || argument[0] == '\0')
    {
  send_to_char("Pour what into what?\n\r",ch);
  return;
    }
    

    if ((out = get_obj_carry(ch,arg)) == NULL)
    {
  send_to_char("You don't have that item.\n\r",ch);
  return;
    }

    if (out->item_type != ITEM_DRINK_CON)
    {
  send_to_char("That's not a drink container.\n\r",ch);
  return;
    }

    if (!str_cmp(argument,"out"))
    {
  if (out->value[1] == 0)
  {
      send_to_char("It's already empty.\n\r",ch);
      return;
  }

  out->value[1] = 0;
  out->value[3] = 0;
  sprintf(buf,"You invert $p, spilling %s all over the ground.",
    liq_table[out->value[2]].liq_name);
  act(buf,ch,out,NULL,TO_CHAR,FALSE);
  
  sprintf(buf,"$n inverts $p, spilling %s all over the ground.",
    liq_table[out->value[2]].liq_name);
  act(buf,ch,out,NULL,TO_ROOM,FALSE);
  return;
    }

    if ((in = get_obj_here(ch,argument)) == NULL)
    {
  vch = get_char_room(ch,argument);

  if (vch == NULL)
  {
      send_to_char("Pour into what?\n\r",ch);
      return;
  }

  in = get_eq_char(vch,WEAR_HOLD);

  if (in == NULL)
  {
      send_to_char("They aren't holding anything.",ch);
      return;
  }
    }

    if (in->item_type != ITEM_DRINK_CON)
    {
  send_to_char("You can only pour into other drink containers.\n\r",ch);
  return;
    }
    if (in->pIndexData->vnum == OBJ_VNUM_GRAIL)
    {
      send_to_char("Only the Lord Almighty may refill the grail.  Quit trying to cheat.\n\r",ch);
      return;
    }

    
    if (in == out)
    {
  send_to_char("You cannot change the laws of physics!\n\r",ch);
  return;
    }

    if (in->value[1] != 0 && in->value[2] != out->value[2])
    {
  send_to_char("They don't hold the same liquid.\n\r",ch);
  return;
    }

    if (out->value[1] == 0)
    {
  act("There's nothing in $p to pour.",ch,out,NULL,TO_CHAR,FALSE);
  return;
    }

    if (in->value[1] >= in->value[0])
    {
  act("$p is already filled to the top.",ch,in,NULL,TO_CHAR,FALSE);
  return;
    }

    amount = UMIN(out->value[1],in->value[0] - in->value[1]);

    in->value[1] += amount;
    out->value[1] -= amount;
    in->value[2] = out->value[2];
    
    if (vch == NULL)
    {
      sprintf(buf,"You pour %s from $p into $P.",
      liq_table[out->value[2]].liq_name);
      act(buf,ch,out,in,TO_CHAR,FALSE);
      sprintf(buf,"$n pours %s from $p into $P.",
      liq_table[out->value[2]].liq_name);
      act(buf,ch,out,in,TO_ROOM,FALSE);
    }
    else
    {
        sprintf(buf,"You pour some %s for $N.",
            liq_table[out->value[2]].liq_name);
        act(buf,ch,NULL,vch,TO_CHAR,FALSE);
  if(!IS_NPC(vch)) 
    {
    sprintf(buf,"$n pours you some %s.",
        liq_table[out->value[2]].liq_name);
    act(buf,ch,NULL,vch,TO_VICT,FALSE);
          }
  sprintf(buf,"$n pours some %s for $N.",
            liq_table[out->value[2]].liq_name);
        act(buf,ch,NULL,vch,TO_NOTVICT,FALSE);
  
    }
}

void do_drink( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int amount;
    int liquid;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg[0] == '\0' )
    {
  for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
  {
      if ( obj->item_type == ITEM_FOUNTAIN )
    break;
  }

  if ( obj == NULL )
  {
      send_to_char( "Drink what?\n\r", ch );
      return;
  }
    }
    else
    {
  if ( ( obj = get_obj_here( ch, arg ) ) == NULL )
  {
      send_to_char( "You can't find it.\n\r", ch );
      return;
  }
    }

    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10 )
    {
  send_to_char( "You fail to reach your mouth.  *Hic*\n\r", ch );
  return;
    }

    switch ( obj->item_type )
    {
    default:
  send_to_char( "You can't drink from that.\n\r", ch );
  return;

    case ITEM_FOUNTAIN:
        if ( ( liquid = obj->value[2] )  < 0 )
        {
            bug( "Do_drink: bad liquid number %d.", liquid );
            liquid = obj->value[2] = 0;
        }
  amount = liq_table[liquid].liq_affect[4] * 3;
  break;

    case ITEM_DRINK_CON:
  if ( obj->value[1] <= 0 )
  {
      send_to_char( "It is already empty.\n\r", ch );
      return;
  }

  if ( ( liquid = obj->value[2] )  < 0 )
  {
      bug( "Do_drink: bad liquid number %d.", liquid );
      liquid = obj->value[2] = 0;
  }

        amount = liq_table[liquid].liq_affect[4];
        amount = UMIN(amount, obj->value[1]);
  break;
     }
    if (!IS_NPC(ch) && !IS_IMMORTAL(ch) 
    &&  ch->pcdata->condition[COND_FULL] > 45)
    {
  send_to_char("You're too full to drink more.\n\r",ch);
  return;
    }

    if ( IS_SET(ch->act,PLR_VAMP) 
	 && !IS_NPC(ch)
	 && liquid != liq_lookup("blood") )
    {
	send_to_char("But you desire blood...\n\r",ch);
	return;
    }

    if (IS_SET(ch->act,PLR_WERE)
	&& !IS_NPC(ch))
    {
       send_to_char("The smell of rotting flesh is more inviting... \n\r",ch);
       return;
    }

    if (IS_SET(ch->act,PLR_MUMMY)
	&& !IS_NPC(ch))
    {
       send_to_char("Fear is all the sustenance you need... \n\r",ch);
       return;
    }

    act( "$n drinks $T from $p.",
  ch, obj, liq_table[liquid].liq_name, TO_ROOM ,FALSE);
    act( "You drink $T from $p.",
  ch, obj, liq_table[liquid].liq_name, TO_CHAR ,FALSE);

    if ( !IS_SET(ch->act,PLR_VAMP) )
    {
    gain_condition( ch, COND_DRUNK,
  amount * liq_table[liquid].liq_affect[COND_DRUNK] / 36 );
    gain_condition( ch, COND_FULL,
  amount * liq_table[liquid].liq_affect[COND_FULL] / 4 );
    gain_condition( ch, COND_THIRST,
  amount * liq_table[liquid].liq_affect[COND_THIRST] / 10 );
    gain_condition(ch, COND_HUNGER,
  amount * liq_table[liquid].liq_affect[COND_HUNGER] / 2 );
    }
    else
    {
    gain_condition( ch, COND_FULL, 10 );
    gain_condition( ch, COND_HUNGER, 10 );
    gain_condition( ch, COND_THIRST, 10 );
    }

    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
  send_to_char( "You feel drunk.\n\r", ch );
    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL]   > 40 )
  send_to_char( "You are full.\n\r", ch );
    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] > 40 )
  send_to_char( "Your thirst is quenched.\n\r", ch );
  
    if (obj->value[0] > 0)
        obj->value[1] -= amount;

    if (obj->pIndexData->vnum == OBJ_VNUM_GRAIL)
        {
	ch->hit = UMIN(ch->max_hit, ch->hit+75);
        send_to_char("Your wounds are healed by the power of the grail!\n\r",ch);
        }

    switch(check_immune(ch,DAM_POISON))
     {
	case IS_IMMUNE: if(obj->value[0]>0) obj->value[1] -= amount; return;
	case IS_RESISTANT:  amount -= 3;  break;
	case IS_VULNERABLE: amount += 2;  break;
     }

    if ( obj->value[3] != 0)
    {

  /* The shit was poisoned ! */
  AFFECT_DATA af;

  act( "$n chokes and gags.", ch, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( "You choke and gag.\n\r", ch );
  af.where     = TO_AFFECTS;
  af.type      = gsn_poison;
  af.level   = number_fuzzy(amount); 
  af.duration  = 3 * amount;
  af.location  = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = AFF_POISON;
  affect_join( ch, &af );
    }
  
    return;
}



void do_eat( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int amount;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }

    if ( arg[0] == '\0' )
    {
  send_to_char( "Eat what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_carry( ch, arg ) ) == NULL )
    {
  send_to_char( "You do not have that item.\n\r", ch );
  return;
    }

    if ( !IS_IMMORTAL(ch) )
    {
  if ( obj->item_type != ITEM_FOOD && obj->item_type != ITEM_PILL )
  {
      send_to_char( "That's not edible.\n\r", ch );
      return;
  }

  if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL] > 40 )
  {   
      send_to_char( "You are too full to eat more.\n\r", ch );
      return;
  }
  if ( obj->item_type == ITEM_PILL && ch->position <= POS_RESTING )
  {
      send_to_char( "Nah....You feel too relaxed...\n\r", ch);
      return;
  }
    }

    amount = obj->value[0];

    if ((obj->item_type == ITEM_FOOD) 
	&& IS_SET(ch->act,PLR_VAMP)
	&& !IS_NPC(ch))
    {
       send_to_char("But you want blood... \n\r",ch);
       return;
    }

    /* Corpse vnums are less then 100, Were's eat those */
    if ((obj->item_type == ITEM_FOOD) 
	&& obj->pIndexData->vnum > 100
	&& IS_SET(ch->act,PLR_WERE)
	&& !IS_NPC(ch))
    {
       send_to_char("The smell of rotting flesh is more inviting... \n\r",ch);
       return;
    }

    if ((obj->item_type == ITEM_FOOD) 
	&& IS_SET(ch->act,PLR_MUMMY)
	&& !IS_NPC(ch))
    {
       send_to_char("Fear is all the sustenance you need... \n\r",ch);
       return;
    }

    act( "$n eats $p.",  ch, obj, NULL, TO_ROOM ,FALSE);
    act( "You eat $p.", ch, obj, NULL, TO_CHAR ,FALSE);

    switch ( obj->item_type )
    {

    case ITEM_FOOD:
  
  if  ( !IS_NPC(ch) )
  {
      int condition;
  
      if (IS_SET(ch->act,PLR_WERE))
      {
         gain_condition(ch,COND_FULL,   15 - ( ch->level / 5 ) );
         gain_condition(ch,COND_HUNGER, 15 - ( ch->level / 5 ) );
         gain_condition(ch,COND_THIRST, 15 - ( ch->level / 5 ) );

         if ( ch->pcdata->condition[COND_FULL] > 46 )
	 {
	    send_to_char("Your cravings for flesh has ended.\n\r",ch);
	    return;
         }
      }
      else
      {
         condition = ch->pcdata->condition[COND_HUNGER];
         gain_condition( ch, COND_FULL, obj->value[0] );
         gain_condition( ch, COND_HUNGER, obj->value[1]);
         if ( condition == 0 && ch->pcdata->condition[COND_HUNGER] > 0 )
            send_to_char( "You are no longer hungry.\n\r", ch );
         else if ( ch->pcdata->condition[COND_FULL] > 40 )
            send_to_char( "You are full.\n\r", ch );
      }
  }

    switch(check_immune(ch,DAM_POISON))
     {
        case IS_IMMUNE: extract_obj(obj); return;  
        case IS_RESISTANT:  amount -= 3;  break;
        case IS_VULNERABLE: amount += 2;  break;
     } 

  if ( obj->value[3] != 0 )
  {

      /* The shit was poisoned! */
      AFFECT_DATA af;

      act( "$n chokes and gags.", ch, 0, 0, TO_ROOM ,FALSE);
      send_to_char( "You choke and gag.\n\r", ch );

      af.where   = TO_AFFECTS;
      af.type      = gsn_poison;
      af.level   = number_fuzzy(amount);
      af.duration  = 2 * amount;
      af.location  = APPLY_NONE;
      af.modifier  = 0;
      af.bitvector = AFF_POISON;
      affect_join( ch, &af );
  }
  break;

    case ITEM_PILL:
  obj_cast_spell( obj->value[1], obj->value[0], ch, ch, NULL );
  obj_cast_spell( obj->value[2], obj->value[0], ch, ch, NULL );
  obj_cast_spell( obj->value[3], obj->value[0], ch, ch, NULL );
  break;
    }

    extract_obj( obj );
    return;
}

/*
 * Remove All Worn Objects.
 */
void remove_all_objs( CHAR_DATA *ch )
{
    OBJ_DATA *obj;
    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


   if ( ( obj = get_eq_char( ch, WEAR_LIGHT)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_FINGER_L)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_FINGER_R)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_NECK_1)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_NECK_2)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_BODY)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_HEAD)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_LEGS)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_FEET)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_HANDS)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_ARMS)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_ABOUT)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_WAIST)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_WRIST_L)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_WRIST_R)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_SHIELD)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_WIELD)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char(ch,WEAR_SECOND)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char(ch,WEAR_WIELD)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char( ch, WEAR_HOLD)) != NULL)
     unequip_char( ch, obj );
   if ( ( obj = get_eq_char(ch,WEAR_FLOAT)) != NULL)
     unequip_char( ch, obj );

   act( "$n removes all of $s equipment.", ch, NULL, NULL, TO_ROOM ,FALSE);
   act( "You remove all of your equipment.", ch, NULL, NULL, TO_CHAR ,FALSE);
}

/*
 * Remove an object.
 */
bool remove_obj( CHAR_DATA *ch, int iWear, bool fReplace )
{
    OBJ_DATA *obj;

    if ( ( obj = get_eq_char( ch, iWear ) ) == NULL )
  return TRUE;

    if ( !fReplace )
  return FALSE;

    if ( IS_SET(obj->extra_flags, ITEM_NOREMOVE) && !IS_IMMORTAL(ch) )
    {
  act( "You can't remove $p.", ch, obj, NULL, TO_CHAR ,FALSE);
  return FALSE;
    }

    unequip_char( ch, obj );
    act( "$n stops using $p.", ch, obj, NULL, TO_ROOM ,FALSE);
    act( "You stop using $p.", ch, obj, NULL, TO_CHAR ,FALSE);
    return TRUE;
}



/*
 * Is the secondary weapon wear-able?
 */
bool can_wear_secondary( CHAR_DATA *ch, OBJ_DATA *prim, OBJ_DATA *sec )
{
   if ( sec->weight >= prim->weight )
   {
       send_to_char("It's too heavy.\n\r",ch);
       return FALSE;
   }

   if (HAS_KIT(ch,"ranger"))
      return TRUE;

   if (prim->value[0] == WEAPON_SWORD && sec->value[0] == WEAPON_DAGGER)
      return TRUE;

   if (prim->value[0] == WEAPON_EXOTIC || sec->value[0] == WEAPON_EXOTIC)
      return TRUE;

   if ( prim->value[0] != sec->value[0]) 
   {
       send_to_char("That combination isn't possible.\n\r",ch);
       return FALSE;
   }

   return TRUE;
}


/*
 * Wear one object.
 * Optional replacement of existing objects.
 * Big repetitive code, ick.
 */
void wear_obj( CHAR_DATA *ch, OBJ_DATA *obj, bool fReplace )
{
    char buf[MAX_STRING_LENGTH];

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( HAS_KIT(ch,"nethermancer") && obj->item_type == ITEM_ARMOR )
    {
	send_to_char("You are forbidden to wear armor.\n\r",ch);
	return;
    }
    if ( obj->pIndexData->vnum == 4436)
    {
       send_to_char("That promise ring is no longer allowed in the game.\r\n",ch);
       return;
    }


    if ( ch->level < obj->level )
    {
  sprintf( buf, "You must be level %d to use this object.\n\r",
      obj->level );
  send_to_char( buf, ch );
  act( "$n tries to use $p, but is too inexperienced.",
      ch, obj, NULL, TO_ROOM ,FALSE);
  return;
    }

    if ( !IS_NPC(ch) && HAS_KIT(ch,"nethermancer")
	 && obj->item_type == ITEM_ARMOR )
    {
act("$n tries to wear $p and shudders in pain.",ch,obj,NULL,TO_ROOM,FALSE);
act("Your pact with the Netherworld forbids it.",ch,obj,NULL,TO_CHAR,FALSE);
	return;
    }

    if ( !can_wear_obj(ch,obj) )
    {
act("$n tries to wear $p and it doesn't fit.", ch, obj, NULL, TO_ROOM,FALSE);
act("You try to wear $p and it doesn't fit.", ch, obj, NULL, TO_CHAR,FALSE);
	return;
    }

    if ( obj->item_type == ITEM_LIGHT )
    {
  if ( !remove_obj( ch, WEAR_LIGHT, fReplace ) )
      return;
  act( "$n lights $p and holds it.", ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You light $p and hold it.",  ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_LIGHT );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_FINGER ) )
    {
  if ( get_eq_char( ch, WEAR_FINGER_L ) != NULL
  &&   get_eq_char( ch, WEAR_FINGER_R ) != NULL
  &&   !remove_obj( ch, WEAR_FINGER_L, fReplace )
  &&   !remove_obj( ch, WEAR_FINGER_R, fReplace ) )
      return;

  if ( get_eq_char( ch, WEAR_FINGER_L ) == NULL )
  {
      act( "$n wears $p on $s left finger.",    ch, obj, NULL, TO_ROOM ,FALSE);
      act( "You wear $p on your left finger.",  ch, obj, NULL, TO_CHAR ,FALSE);
      equip_char( ch, obj, WEAR_FINGER_L );
      return;
  }

  if ( get_eq_char( ch, WEAR_FINGER_R ) == NULL )
  {
      act( "$n wears $p on $s right finger.",   ch, obj, NULL, TO_ROOM ,FALSE);
      act( "You wear $p on your right finger.", ch, obj, NULL, TO_CHAR ,FALSE);
      equip_char( ch, obj, WEAR_FINGER_R );
      return;
  }

  bug( "Wear_obj: no free finger.", 0 );
  send_to_char( "You already wear two rings.\n\r", ch );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_NECK ) )
    {
  if ( get_eq_char( ch, WEAR_NECK_1 ) != NULL
  &&   get_eq_char( ch, WEAR_NECK_2 ) != NULL
  &&   !remove_obj( ch, WEAR_NECK_1, fReplace )
  &&   !remove_obj( ch, WEAR_NECK_2, fReplace ) )
      return;

  if ( get_eq_char( ch, WEAR_NECK_1 ) == NULL )
  {
      act( "$n wears $p around $s neck.",   ch, obj, NULL, TO_ROOM ,FALSE);
      act( "You wear $p around your neck.", ch, obj, NULL, TO_CHAR ,FALSE);
      equip_char( ch, obj, WEAR_NECK_1 );
      return;
  }

  if ( get_eq_char( ch, WEAR_NECK_2 ) == NULL )
  {
      act( "$n wears $p around $s neck.",   ch, obj, NULL, TO_ROOM ,FALSE);
      act( "You wear $p around your neck.", ch, obj, NULL, TO_CHAR ,FALSE);
      equip_char( ch, obj, WEAR_NECK_2 );
      return;
  }

  bug( "Wear_obj: no free neck.", 0 );
  send_to_char( "You already wear two neck items.\n\r", ch );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_BODY ) )
    {
  if ( !remove_obj( ch, WEAR_BODY, fReplace ) )
      return;
  act( "$n wears $p on $s torso.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p on your torso.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_BODY );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_HEAD ) )
    {
  if ( !remove_obj( ch, WEAR_HEAD, fReplace ) )
      return;
  act( "$n wears $p on $s head.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p on your head.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_HEAD );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_LEGS ) )
    {
  if ( !remove_obj( ch, WEAR_LEGS, fReplace ) )
      return;
  act( "$n wears $p on $s legs.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p on your legs.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_LEGS );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_FEET ) )
    {
  if ( !remove_obj( ch, WEAR_FEET, fReplace ) )
      return;
  act( "$n wears $p on $s feet.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p on your feet.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_FEET );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_HANDS ) )
    {
  if ( !remove_obj( ch, WEAR_HANDS, fReplace ) )
      return;
  act( "$n wears $p on $s hands.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p on your hands.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_HANDS );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_ARMS ) )
    {
  if ( !remove_obj( ch, WEAR_ARMS, fReplace ) )
      return;
  act( "$n wears $p on $s arms.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p on your arms.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_ARMS );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_ABOUT ) )
    {
  if ( !remove_obj( ch, WEAR_ABOUT, fReplace ) )
      return;
  act( "$n wears $p about $s torso.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p about your torso.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_ABOUT );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_WAIST ) )
    {
  if ( !remove_obj( ch, WEAR_WAIST, fReplace ) )
      return;
  act( "$n wears $p about $s waist.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p about your waist.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_WAIST );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_WRIST ) )
    {
  if ( get_eq_char( ch, WEAR_WRIST_L ) != NULL
  &&   get_eq_char( ch, WEAR_WRIST_R ) != NULL
  &&   !remove_obj( ch, WEAR_WRIST_L, fReplace )
  &&   !remove_obj( ch, WEAR_WRIST_R, fReplace ) )
      return;

  if ( get_eq_char( ch, WEAR_WRIST_L ) == NULL )
  {
      act( "$n wears $p around $s left wrist.",
    ch, obj, NULL, TO_ROOM ,FALSE);
      act( "You wear $p around your left wrist.",
    ch, obj, NULL, TO_CHAR ,FALSE);
      equip_char( ch, obj, WEAR_WRIST_L );
      return;
  }

  if ( get_eq_char( ch, WEAR_WRIST_R ) == NULL )
  {
      act( "$n wears $p around $s right wrist.",
    ch, obj, NULL, TO_ROOM ,FALSE);
      act( "You wear $p around your right wrist.",
    ch, obj, NULL, TO_CHAR ,FALSE);
      equip_char( ch, obj, WEAR_WRIST_R );
      return;
  }

  bug( "Wear_obj: no free wrist.", 0 );
  send_to_char( "You already wear two wrist items.\n\r", ch );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WEAR_SHIELD ) )
    {
  OBJ_DATA *weapon;

  if ( !remove_obj( ch, WEAR_SHIELD, fReplace ) )
      return;

  weapon = get_eq_char(ch,WEAR_WIELD);
  if (weapon != NULL && ch->size < SIZE_LARGE 
  &&  IS_WEAPON_STAT(weapon,WEAPON_TWO_HANDS))
  {
      send_to_char("Your hands are tied up with your weapon!\n\r",ch);
      return;
  }

  if ( is_affected(ch,gsn_bladesong))
  {
     send_to_char("You can not wear a shield while performing the bladesong.\n\r",ch);
     return;
  }

  act( "$n wears $p as a shield.", ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You wear $p as a shield.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_SHIELD );
  return;
    }

    if ( CAN_WEAR( obj, ITEM_WIELD ) )
    {
 /* 
  int sn,skill;
 */
  if ( !IS_NPC(ch) && get_skill(ch,gsn_dual_wield) <= 0 )
  if ( !remove_obj( ch, WEAR_WIELD, fReplace ) )
      return;

  if ( !IS_NPC(ch) 
  && get_obj_weight(obj) > (str_app[get_curr_stat(ch,STAT_STR)].wield  
    * 10))
  {
      send_to_char( "It is too heavy for you to wield.\n\r", ch );
      return;
  }

  if ( is_affected(ch,gsn_bladesong) && 
       obj->value[0] != WEAPON_SWORD && 
       obj->value[0] != WEAPON_DAGGER)
  {
     send_to_char("You can only wear a sword or dagger while performing the bladesong.\n\r",ch);
     return;
  }

  if ( is_affected(ch,gsn_rage) && obj->value[0] != WEAPON_AXE )
  {
     send_to_char("You must wield an axe while battleraging.\n\r", ch);
     return;
  }

  if (!IS_NPC(ch) && ch->size < SIZE_LARGE 
  &&  IS_WEAPON_STAT(obj,WEAPON_TWO_HANDS)
  &&  get_eq_char(ch,WEAR_SHIELD) != NULL)
  {
      send_to_char("You need two hands free for that weapon.\n\r",ch);
      return;
  }

  /* This gets tricky.  Check if they have dual wield.  If so, see if
     they're already equipped with a weapon.  If so, try to equip thisa
     as a secondary weapon, if THAT fails, replace the primary 
     */

  if ( get_skill(ch,gsn_dual_wield) && get_eq_char(ch,WEAR_WIELD) != NULL )
  {
     /* secondary weapon */
     if (!can_wear_secondary( ch,get_eq_char(ch,WEAR_WIELD),obj))
	return;

     if (!remove_obj(ch,WEAR_SECOND,fReplace))
	 return;

      act( "$n wields $p.", ch, obj, NULL, TO_ROOM ,FALSE);
      act( "You wield $p.", ch, obj, NULL, TO_CHAR ,FALSE);
      equip_char( ch, obj, WEAR_SECOND );
      return;
  }
  else /*  Wield as primary */
  {
     if (!remove_obj(ch,WEAR_WIELD,fReplace))
	 return;

     act("$n wields $p.", ch, obj, NULL, TO_ROOM,FALSE);
     act("You wield $p.", ch, obj, NULL, TO_CHAR,FALSE);
     equip_char( ch, obj, WEAR_WIELD );
     return;
  }
/*
        sn = get_weapon_sn(ch);

  if (sn == gsn_hand_to_hand)
     return;

        skill = get_weapon_skill(ch,sn);
 
        if (skill >= 100)
            act("$p feels like a part of you!",ch,obj,NULL,TO_CHAR,FALSE);
        else if (skill > 85)
            act("You feel quite confident with $p.",ch,obj,NULL,TO_CHAR,FALSE);
        else if (skill > 70)
            act("You are skilled with $p.",ch,obj,NULL,TO_CHAR,FALSE);
        else if (skill > 50)
            act("Your skill with $p is adequate.",ch,obj,NULL,TO_CHAR,FALSE);
        else if (skill > 25)
       act("$p feels a little clumsy in your hands.",ch,obj,NULL,TO_CHAR,FALSE);
        else if (skill > 1)
            act("You fumble and almost drop $p.",ch,obj,NULL,TO_CHAR,FALSE);
        else
            act("You don't even know which end is up on $p.",
                ch,obj,NULL,TO_CHAR,FALSE);

  return;
  */
    }

    if ( CAN_WEAR( obj, ITEM_HOLD ) )
    {
  if ( !remove_obj( ch, WEAR_HOLD, fReplace ) )
      return;
  act( "$n holds $p in $s hand.",   ch, obj, NULL, TO_ROOM ,FALSE);
  act( "You hold $p in your hand.", ch, obj, NULL, TO_CHAR ,FALSE);
  equip_char( ch, obj, WEAR_HOLD );
  return;
    }

    if ( CAN_WEAR(obj,ITEM_WEAR_FLOAT) )
    {
  if (!remove_obj(ch,WEAR_FLOAT, fReplace) )
      return;
  act("$n releases $p to float next to $m.",ch,obj,NULL,TO_ROOM,FALSE);
  act("You release $p and it floats next to you.",ch,obj,NULL,TO_CHAR,FALSE);
  equip_char(ch,obj,WEAR_FLOAT);
  return;
    }

    if ( fReplace )
  send_to_char( "You can't wear, wield, or hold that.\n\r", ch );

    return;
}



void do_wear( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg[0] == '\0' )
    {
  send_to_char( "Wear, wield, or hold what?\n\r", ch );
  return;
    }

    if ( !str_cmp( arg, "all" ) )
    {
  OBJ_DATA *obj_next;

  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
      obj_next = obj->next_content;
      if ( obj->wear_loc == WEAR_NONE && can_see_obj( ch, obj ) )
    wear_obj( ch, obj, FALSE );
  }
  return;
    }
    else
    {
  if ( ( obj = get_obj_carry( ch, arg ) ) == NULL )
  {
      send_to_char( "You do not have that item.\n\r", ch );
      return;
  }

  wear_obj( ch, obj, TRUE );
    }

    return;
}



void do_remove( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg[0] == '\0' )
    {
  send_to_char( "Remove what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_wear( ch, arg ) ) == NULL )
    {
  send_to_char( "You do not have that item.\n\r", ch );
  return;
    }

    remove_obj( ch, obj->wear_loc, TRUE );

/* Primary has been removed, move Secondary to Primary */
    if (get_eq_char(ch,WEAR_SECOND) != NULL && 
	get_eq_char(ch,WEAR_WIELD) == NULL)
    {
       obj = get_eq_char(ch,WEAR_SECOND);
       obj_from_char( obj );
       obj_to_char( obj, ch);
       equip_char( ch, obj, WEAR_WIELD );
    }

    return;
}



void do_sacrifice( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    OBJ_DATA *obj;
    int silver;
    
    /* variables for AUTOSPLIT */
    CHAR_DATA *gch;
    int members;
    char buffer[100];

    
    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }



    if ( IS_NPC(ch))
    {
    send_to_char("You are unable to sacrifice anything, silly MOB.\n\r", ch);
    return;
    }

    if ( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
    {
  act( "$n offers $mself to $s deity, who graciously declines.",
      ch, NULL, NULL, TO_ROOM ,FALSE);
  sprintf(buf,"%s appreciates your offer and may accept it later.\n\r",
	  deity_table[ch->pcdata->deity].pname);
  send_to_char(buf,ch);
  return;
    }

    obj = get_obj_list( ch, arg, ch->in_room->contents );
    if ( obj == NULL )
    {
  send_to_char( "You can't find it.\n\r", ch );
  return;
    }

    if ( obj->item_type == ITEM_CORPSE_PC )
    {
  if (obj->contains)
        {
     sprintf(buf,"%s wouldn't like that.\n\r",deity_table[ch->pcdata->deity].pname);
     send_to_char(buf,ch);
     return;
        }
    }


    if ( !CAN_WEAR(obj, ITEM_TAKE) || CAN_WEAR(obj, ITEM_NO_SAC)
	|| obj->item_type == ITEM_FURNITURE)
    {
  act( "$p is not an acceptable sacrifice.", ch, obj, 0, TO_CHAR ,FALSE);
  return;
    }

    silver = UMAX(1,obj->level * 3);

    if (obj->item_type != ITEM_CORPSE_NPC && obj->item_type != ITEM_CORPSE_PC)
      silver = UMIN(silver,obj->cost);

    if (obj->item_type == ITEM_CORPSE_NPC || obj->item_type == ITEM_CORPSE_PC)
    {
	sprintf(buf,"%s finds your offering pleasing and rewards you.\n\r",
		deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,ch);
	ch->pcdata->sac += get_sac_points(ch, silver );
    }
    else
    {
       if(IS_SET(ch->mhs,MHS_GLADIATOR))
       {
	  send_to_char("Sorry you are not permitted to sacrific things.\n\r",ch);
	  return;
       }

       if ( obj->item_type == ITEM_CONTAINER ) 
       {
          if (!IS_SET(ch->mhs,MHS_FULL_SAC) && obj->contains)
          {
             sprintf(buf,"You have full sacing off, read 'help fullsac'.\n\r");
             send_to_char(buf,ch);
             return;
          }
       }

    if (silver == 1)
	{
	sprintf(buf,"%s gives you one silver coin for your sacrifice.\n\r",
		deity_table[ch->pcdata->deity].pname);
        send_to_char(buf,ch);
	}
    else
    {
  sprintf(buf,"%s gives you %d silver coins for your sacrifice.\n\r",
    	deity_table[ch->pcdata->deity].pname,silver);
  send_to_char(buf,ch);
    }
    
    ch->silver += silver;
    
    if (IS_SET(ch->act,PLR_AUTOSPLIT) )
    { /* AUTOSPLIT code */
      members = 0;
  for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
      {
          if ( is_same_group( gch, ch ) )
            members++;
      }

  if ( members > 1 && silver > 1)
  {
      sprintf(buffer,"%d",silver);
      do_split(ch,buffer);  
  }
    }
    }

    act( "$n sacrifices $p to $s deity.", ch, obj, NULL, TO_ROOM ,FALSE);
    wiznet("$N sends up $p as a burnt offering.",
     ch,obj,WIZ_SACCING,0,0);
    extract_obj( obj );
    return;
}

void do_mix( CHAR_DATA *ch, char *argument )
{
    return;
}

void do_create( CHAR_DATA *ch, char *argument )
{
    return;
}

void do_quaff( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg[0] == '\0' )
    {
  send_to_char( "Quaff what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_carry( ch, arg ) ) == NULL )
    {
  send_to_char( "You do not have that potion.\n\r", ch );
  return;
    }

    if ( obj->item_type != ITEM_POTION )
    {
  send_to_char( "You can quaff only potions.\n\r", ch );
  return;
    }

    if (ch->level < obj->level)
    {
  send_to_char("This liquid is too powerful for you to drink.\n\r",ch);
  return;
    }

    if (IS_SET(ch->mhs,MHS_GLADIATOR) && 
        gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
    {
       send_to_char("You can not quaff potions in the arena.\n\r", ch);
       return;
    }

    act( "$n quaffs $p.", ch, obj, NULL, TO_ROOM ,FALSE);
    act( "You quaff $p.", ch, obj, NULL ,TO_CHAR ,FALSE);

    obj_cast_spell( obj->value[1], obj->value[0], ch, ch, NULL );
    obj_cast_spell( obj->value[2], obj->value[0], ch, ch, NULL );
    obj_cast_spell( obj->value[3], obj->value[0], ch, ch, NULL );

    extract_obj( obj );
    return;
}



void do_recite( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *scroll;
    OBJ_DATA *obj;
    int smod;


    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( ( scroll = get_obj_carry( ch, arg1 ) ) == NULL )
    {
  send_to_char( "You do not have that scroll.\n\r", ch );
  return;
    }

    if ( scroll->item_type != ITEM_SCROLL )
    {
  send_to_char( "You can recite only scrolls.\n\r", ch );
  return;
    }

    if ( ch->level < scroll->level)
    {
  send_to_char(
    "This scroll is too complex for you to comprehend.\n\r",ch);
  return;
    }

    obj = NULL;
    if ( arg2[0] == '\0' )
    {
  victim = ch;
    }
    else
    {
  if ( ( victim = get_char_room ( ch, arg2 ) ) == NULL
  &&   ( obj    = get_obj_here  ( ch, arg2 ) ) == NULL )
  {
      send_to_char( "You can't find it.\n\r", ch );
      return;
  }
    }

    act( "$n recites $p.", ch, scroll, NULL, TO_ROOM ,FALSE);
    act( "You recite $p.", ch, scroll, NULL, TO_CHAR ,FALSE);

    if  (
           scroll->pIndexData->vnum == OBJ_VNUM_SCRIBE_PARCHMENT
        || scroll->pIndexData->vnum == OBJ_VNUM_SCRIBE_VELLUM
        || scroll->pIndexData->vnum == OBJ_VNUM_SCRIBE_RICEPAPER
        || scroll->pIndexData->vnum == OBJ_VNUM_SCRIBE_KOZO
        || scroll->pIndexData->vnum == OBJ_VNUM_SCRIBE_PAPYRUS 
        )
        {
            smod = 5;
        } 
    else
        {
            smod = 20;
        }
/*Origional line below commented out to make way for the scribe kit.  Scribed scrolls
are less effective than stock scrolls */

/*    if (number_percent() >= 20 + get_skill(ch,gsn_scrolls) * 4/5)*/
    if (number_percent() >= smod + get_skill(ch,gsn_scrolls) * 4/5)
    {
  send_to_char("You mispronounce a syllable.\n\r",ch);
  check_improve(ch,gsn_scrolls,FALSE,2);
    }

    else
    {
      obj_cast_spell( scroll->value[1], scroll->value[0], ch, victim, obj );
      obj_cast_spell( scroll->value[2], scroll->value[0], ch, victim, obj );
      obj_cast_spell( scroll->value[3], scroll->value[0], ch, victim, obj );
  check_improve(ch,gsn_scrolls,TRUE,2);
    }

    extract_obj( scroll );
    return;
}



void do_brandish( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *vch;
    CHAR_DATA *vch_next;
    OBJ_DATA *staff;
    int sn;

    int brandish_base;

    brandish_base = 20;
    if(ch->race == race_lookup("dwarf") )
    {
      brandish_base = 10;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( ( staff = get_eq_char( ch, WEAR_HOLD ) ) == NULL )
    {
  send_to_char( "You hold nothing in your hand.\n\r", ch );
  return;
    }

    if ( staff->item_type != ITEM_STAFF )
    {
  send_to_char( "You can brandish only with a staff.\n\r", ch );
  return;
    }

    if ( ( sn = staff->value[3] ) < 0
    ||   sn >= MAX_SKILL
    ||   skill_table[sn].spell_fun == 0 )
    {
  bug( "Do_brandish: bad sn %d.", sn );
  return;
    }

    WAIT_STATE( ch, 2 * PULSE_VIOLENCE );

    if ( staff->value[2] > 0 )
    {
  act( "$n brandishes $p.", ch, staff, NULL, TO_ROOM ,FALSE);
  act( "You brandish $p.",  ch, staff, NULL, TO_CHAR ,FALSE);
  if ( ch->level < staff->level 
  ||   number_percent() >= brandish_base + get_skill(ch,gsn_staves) * 4/5)
  {
      act("You fail to invoke $p.",ch,staff,NULL,TO_CHAR,FALSE);
      act("...and nothing happens.",ch,NULL,NULL,TO_ROOM,FALSE);
      check_improve(ch,gsn_staves,FALSE,2);
  }
  
  else for ( vch = ch->in_room->people; vch; vch = vch_next )
  {
      vch_next  = vch->next_in_room;

      switch ( skill_table[sn].target )
      {
      default:
    bug( "Do_brandish: bad target for sn %d.", sn );
    return;

      case TAR_IGNORE:
    if ( vch != ch )
        continue;
    break;

      case TAR_CHAR_OFFENSIVE:
    if ( IS_NPC(ch) ? IS_NPC(vch) : !IS_NPC(vch) )
        continue;
    break;
    
      case TAR_CHAR_DEFENSIVE:
    if ( IS_NPC(ch) ? !IS_NPC(vch) : IS_NPC(vch) )
        continue;
    break;

      case TAR_CHAR_SELF:
    if ( vch != ch )
        continue;
    break;
      }

      obj_cast_spell( staff->value[3], staff->value[0], ch, vch, NULL );
      check_improve(ch,gsn_staves,TRUE,2);
  }
    }

    if ( abs(--staff->value[2]) == 0 )
    {
  act( "$n's $p blazes bright and is gone.", ch, staff, NULL, TO_ROOM ,FALSE);
  act( "Your $p blazes bright and is gone.", ch, staff, NULL, TO_CHAR ,FALSE);
  extract_obj( staff );
    }

    return;
}



void do_zap( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *wand;
    OBJ_DATA *obj;
    int wand_base;
    
    wand_base = 20;
    if(ch->race == race_lookup("dwarf") )
    {
      wand_base = 10;
    }
    
    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    one_argument( argument, arg );
    if ( arg[0] == '\0' && ch->fighting == NULL )
    {
  send_to_char( "Zap whom or what?\n\r", ch );
  return;
    }

    if ( ( wand = get_eq_char( ch, WEAR_HOLD ) ) == NULL )
    {
  send_to_char( "You hold nothing in your hand.\n\r", ch );
  return;
    }

    if ( wand->item_type != ITEM_WAND )
    {
  send_to_char( "You can zap only with a wand.\n\r", ch );
  return;
    }
    if (wand->pIndexData->vnum == OBJ_VNUM_WAND_PINE ||
 wand->pIndexData->vnum == OBJ_VNUM_WAND_PINE   ||
 wand->pIndexData->vnum == OBJ_VNUM_WAND_APPLE  ||
 wand->pIndexData->vnum == OBJ_VNUM_WAND_OAK    ||
 wand->pIndexData->vnum == OBJ_VNUM_WAND_WILLOW ||
 wand->pIndexData->vnum == OBJ_VNUM_WAND_YEW )
     {
	wand_base /= 2;
     }

    obj = NULL;
    if ( arg[0] == '\0' )
    {
  if ( ch->fighting != NULL )
  {
      victim = ch->fighting;
  }
  else
  {
      send_to_char( "Zap whom or what?\n\r", ch );
      return;
  }
    }
    else
    {
  if ( ( victim = get_char_room ( ch, arg ) ) == NULL
  &&   ( obj    = get_obj_here  ( ch, arg ) ) == NULL )
  {
      send_to_char( "You can't find it.\n\r", ch );
      return;
  }
    }



   if ( victim != NULL)
   {
      if ( IS_NPC(victim) &&                                                 
           victim->fighting != NULL &&                                          
          !is_same_group(ch,victim->fighting))                              
      {                                                 
         send_to_char("Kill stealing is not permitted.\n\r",ch);             
         return;                                                            
      }          
   }

    WAIT_STATE( ch, 2 * PULSE_VIOLENCE );

    if ( wand->value[2] > 0 )
    {
  if ( victim != NULL )
  {
      act( "$n zaps $N with $p.", ch, wand, victim, TO_ROOM ,FALSE);
      act( "You zap $N with $p.", ch, wand, victim, TO_CHAR ,FALSE);
  }
  else
  {
      act( "$n zaps $P with $p.", ch, wand, obj, TO_ROOM ,FALSE);
      act( "You zap $P with $p.", ch, wand, obj, TO_CHAR ,FALSE);
  }


  if (ch->level < wand->level 
  ||  number_percent() >= wand_base + get_skill(ch,gsn_wands) * 4/5) 
  {
      act( "Your efforts with $p produce only smoke and sparks.",
     ch,wand,NULL,TO_CHAR,FALSE);
      act( "$n's efforts with $p produce only smoke and sparks.",
     ch,wand,NULL,TO_ROOM,FALSE);
      check_improve(ch,gsn_wands,FALSE,2);
  }
  else
  {
      obj_cast_spell( wand->value[3], wand->value[0], ch, victim, obj );
      check_improve(ch,gsn_wands,TRUE,2);
  }
    }

    if ( --wand->value[2] <= 0 )
    {
  act( "$n's $p explodes into fragments.", ch, wand, NULL, TO_ROOM ,FALSE);
  act( "Your $p explodes into fragments.", ch, wand, NULL, TO_CHAR ,FALSE);
  extract_obj( wand );
    }

    return;
}

void do_snatch( CHAR_DATA *ch, char *argument )
{
    char buf  [MAX_STRING_LENGTH];
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *obj, *t_obj, *n_obj;
    int percent;

    argument = one_argument( argument, arg1 );
    one_argument( argument, arg2 );

    if  (!IS_NPC(ch) && get_skill(ch, gsn_snatch) < 2)
    {
      send_to_char( "That's a skill best left to professionals\n\r",ch );
      return;
    }
    if ( arg1[0] == '\0' && arg2[0] == '\0' )
    {
       send_to_char( " Syntax: snatch <float item> <victim>\n\r", ch);
       return;
    }
    if ( arg1[0] == '\0'  || arg2[0] == '\0' )
    {
      send_to_char( "Try to snatch what from who?\n\r", ch );
      return;
    }

    if ( ( victim = get_char_room( ch, arg2 ) ) == NULL )
    {
      send_to_char( "They aren't here.\n\r", ch );
      return;
    }


//ok now that victim's actuall set lets do things to it
    if ( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_HIDE))
    {
       REMOVE_BIT(ch->affected_by, AFF_HIDE);
    }
    if ( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_SNEAK))
    {
       REMOVE_BIT(ch->affected_by, AFF_SNEAK);
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }
    if (IS_SET(ch->mhs, MHS_GLADIATOR) || IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("You are not permitted to snatch.\n\r",ch);
       return;
    }



    if ( victim->fighting != NULL && !IS_AFFECTED(victim,AFF_BLIND) )
    {
      send_to_char("You cannot get close enough to them.\r\n",ch);
      return;
    }
    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("They are made of mist.\r\n",ch);
    return;
    }
    if ( ch->clan  && ch->in_room->clan )
    {
        send_to_char("Snatching items from your clan mates is illegal.\n\r", ch);
        return;
    }
    if ( victim == ch )
    {
      send_to_char( "That's {YPATHETIC{x.\n\r", ch );
      return;
    }
    if ( is_affected(ch,skill_lookup("hold person")))
    {
        send_to_char("Your muscles are frozen!\n\r",ch);
        return;
    }
    if( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_HIDE))
         REMOVE_BIT( ch->affected_by, AFF_HIDE );
    if ( ( obj = find_obj_wear(ch,victim, arg1) ) == NULL )
    {
      send_to_char("Your victim isn't wearing that!\n\r", ch);
      return;
    }
    if ( obj->wear_loc != WEAR_FLOAT )
    {
      send_to_char( "That's not a floating item.\n\r", ch );
      return;
    }
    if (is_safe_steal(ch,victim))
    {
       send_to_char("They are safe, leave them alone\n\r",ch);
       return;
    }
    if ( ch->move < (ch->level/15) )
    {
      send_to_char("You're too exhausted.\n\r",ch);
      return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));
    WAIT_STATE( ch, skill_table[gsn_snatch].beats) ;
    percent  = number_percent();
    /* Why the hell is this here?
     * Because those without the steal skill should NEVER succeed! -Rusty
     */
   sprintf(log_buf,"steal-bef:%s race %d cls %d lvl %d dex %d percent:%d victim %s lvl %d dex %d",ch->name,ch->race,ch->class,ch->level,
get_curr_stat(ch,STAT_DEX),percent,victim->name,victim->level,get_curr_stat(victim,STAT_DEX));
   log_string(log_buf);
    if (get_skill(ch,gsn_snatch) > 1)
    {
       percent  += ( IS_AWAKE(victim) ? 10 : -50 );
       percent += (victim->level - ch->level)*15;
       percent += (get_curr_stat(victim,STAT_DEX) - get_curr_stat(ch,STAT_DEX)) *2;
       if(IS_SET(victim->vuln_flags,VULN_DISTRACTION))
          percent -= ch->level/2;
       if(!IS_NPC(ch) && ch->pcdata->old_class != class_lookup("thief") )
          percent += 25;
       if(!IS_NPC(ch) && ch->class == class_lookup("rogue"))
          percent -= 25;
       if ( ch->race == race_lookup("kender") )
          percent -= 10;
    }
    else
    {
       /* garauntee failure */
       percent = 110;
    }

   sprintf(log_buf,"snatch-aft:%s skill %d percent:%d victim %s ",ch->name,(get_skill(ch,gsn_snatch)*9/10),percent,victim->name);
   log_string(log_buf);
    if ( ((ch->level -7 > victim->level)
          && !IS_NPC(victim) && !IS_NPC(ch) )
       || ( !IS_NPC(ch) && percent > get_skill(ch,gsn_snatch) * 9 / 10 )
       || ( !IS_NPC(victim) && !is_clan(ch)) )
    {
  /*
   * Failure.
   */
       send_to_char( "{RDOH!!!{x\n\r", ch );
       act( "{Y$n tried to snatch your floater!{x\n\r", ch, NULL, victim, TO_VICT    ,FALSE);
       act( "{Y$n tried to snatch a floater from $N{x.\n\r",  ch, NULL, victim, TO_NOTVICT ,FALSE);
       if (IS_AWAKE(victim))
       {
          switch(number_range(0,5))
          {
             case 0 :
                sprintf( buf, "%s is a lousy thief!", ch->name );
                break;
             case 1 :
                sprintf( buf, "%s couldn't rob %s way out of a paper bag!",
                  ch->name,(ch->sex == 2) ? "her" : "his");
                break;
             case 2 :
                sprintf( buf,"%s tried to grope me!",ch->name );
                break;
             case 3 :
                sprintf(buf,"Keep your hands out of there, %s!",ch->name);
                break;
             case 4 :
                sprintf(buf,"%s touched me in my special place! Help!", ch->name);
                break;
             case 5 :
                sprintf(buf, "Don't touch me there %s!", ch->name);
                break;
          }
          do_yell( victim, buf );
       }
       if ( !IS_NPC(ch) )
       {
          if ( IS_NPC(victim) )
          {
             check_improve(ch,gsn_steal,FALSE,2);
             multi_hit( victim, ch, TYPE_UNDEFINED );
          }
          else
          {
             ch->pcdata->quit_time = 5;
             sprintf(buf,"$N tried to snatch from %s.",victim->name);
             wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);
             if (((IS_SET(ch->act,PLR_THIEF) || IS_SET(ch->act,PLR_KILLER))
                   && ch->level+12 < victim->level )
                   || (ch->trumps == 0 && ch->level+8 < victim->level)
                   || (ch->trumps > 0 && ch->level+10 < victim->level ) )
                victim->pcdata->last_attacked_by = str_dup(ch->name);
               if ( !IS_SET(ch->act, PLR_THIEF) 
	       &&   !IS_SET(victim->act, PLR_THIEF)
                  )
             {
                  SET_BIT(ch->act, PLR_THIEF);
                  send_to_char( "***{Y You are now a THIEF!!{x ***\n\r", ch );
                  sprintf(buf,"%s got THIEF on %s in room %d",ch->name,
                  victim->name,ch->in_room->vnum);
                  log_string(buf);
                  save_char_obj( ch );
             }
          }
       }
       return;
    }

    if ( !can_drop_obj( victim, obj )
    ||   (obj->level - 2) > ch->level )
    {
  send_to_char( "You can't pry it away.\n\r", ch );
  return;
    }

    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
    {
  send_to_char( "You have your hands full.\n\r", ch );
  return;
    }

    if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
    {
  send_to_char( "You can't carry that much weight.\n\r", ch );
  return;
    }

    obj_from_char( obj );
    obj_to_char( obj, ch );
    check_improve(ch,gsn_snatch,TRUE,2);
    obj->stolen_timer += 10 * number_fuzzy(5);
    if (!IS_NPC(victim))
    {
       sprintf(buf,"$N snatched %s from %s.",obj->short_descr,victim->name);
       wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);
       ch->pcdata->steal_data[PC_STOLEN_ITEMS] += 1 ;
    }
    send_to_char( "Got it!\n\r", ch );
    return;
}

void do_slice( CHAR_DATA *ch, char *argument )
{
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *obj, *t_obj, *n_obj;
    int percent;
    
    if (IS_SET(ch->mhs, MHS_GLADIATOR) || IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("You are not permitted to slice.\n\r",ch);
       return;
    }
    if (ch->clan == clan_lookup("smurf"))
    {
       send_to_char("You are not permitted to slice.\n\r",ch);
       return;
    }
    argument = one_argument( argument, arg1 );
    one_argument( argument, arg2 );

   
    if ( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_HIDE))
       REMOVE_BIT(ch->affected_by, AFF_HIDE);
	
    if  (!IS_NPC(ch) && get_skill(ch, gsn_slice) < 2) 
    {
      send_to_char( "That's a skill best left to professionals\n\r",ch );
      return;
    }
    if ( arg1[0] == '\0' && arg2[0] == '\0' )     
       {
       send_to_char( " Syntax: slice <contianer> <victim>\n\r", ch);
       return;
       }

    if ( arg1[0] == '\0'  || arg2[0] == '\0' )
    {
      send_to_char( "Try to cut open whose containers?\n\r", ch );
      return;
    }

    if ( ( victim = get_char_room( ch, arg2 ) ) == NULL )
    {
      send_to_char( "They aren't here.\n\r", ch );
      return;
    }
//COREY SLICE CHECK
    if ( victim->fighting != NULL && !IS_AFFECTED(victim,AFF_BLIND) )
    {
      send_to_char("You cannot get close enough to them.\r\n",ch);
      return;
    }


    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("They are made of mist.\r\n",ch);
    return;
    }


    if ( victim == ch )
    {
      send_to_char( "That's pointless.\n\r", ch );
      return;
    }

    if ( is_affected(ch,skill_lookup("hold person")))
    {
	send_to_char("Your muscles are frozen!\n\r",ch);
	return;
    }
    
     if( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_HIDE))
	 REMOVE_BIT( ch->affected_by, AFF_HIDE );

    if ( ( obj = find_obj_wear(ch,victim, arg1) ) == NULL )
    {
      send_to_char("Your victim isn't wearing that!\n\r", ch);
      return;
    }

    if ( obj->item_type != ITEM_CONTAINER 
	|| obj->pIndexData->vnum == OBJ_VNUM_DISC )
    {
      send_to_char( "That's not a container.\n\r", ch );
      return;
    }
    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

    
    if (is_safe_steal(ch,victim))
    {
       send_to_char("They are safe, leave them alone\n\r",ch);
       return;
    }

    if ( ch->move < (ch->level/15) )
    {
      send_to_char("You're too exhausted.\n\r",ch);
      return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));
   
    if (ch->in_room->clan && ch->in_room->clan != ch->clan)
    {
    WAIT_STATE( ch,( skill_table[gsn_slice].beats)*3/2 );
    }

    /*  This code removed by NIGHTDAGGER
    else if (!IS_NPC(ch) && ch->clan == clan_lookup("avarice"))
    {
    WAIT_STATE(ch, skill_table[gsn_slice].beats/2);
    }
    End code nerf */

    else
    {
    WAIT_STATE( ch, skill_table[gsn_slice].beats);
    }

    percent = get_skill(ch,gsn_slice);
    percent -= ( IS_AWAKE(victim) ? 10 : -50 );
    percent -= (victim->level - ch->level)*20;
    percent -= ( (get_curr_stat(victim, STAT_INT) + get_curr_stat(victim, STAT_WIS))/2
			- get_curr_stat(ch, STAT_INT))*5;
    percent -= ( get_curr_stat(victim, STAT_DEX) - get_curr_stat(ch, STAT_DEX))*2;
    percent -= (obj->level - ch->level);
    if (IS_OBJ_STAT(obj, ITEM_BURN_PROOF))
	percent -= 25;
    if ( ch->race == race_lookup("kender") )
	percent += 10;
    if(IS_SET(victim->vuln_flags, VULN_DISTRACTION))
	percent += ch->level/2;
    
    if ( ( (ch->level -7 > victim->level)
         && !IS_NPC(victim) && !IS_NPC(ch) )
    || ( !IS_NPC(ch) && percent < number_percent())
    || ( !IS_NPC(victim) && !is_clan(ch) ) )
    {
      send_to_char("Doh!\n\r",ch);
      check_improve(ch,gsn_slice,FALSE,2);
      if (!IS_SET(ch->act, PLR_THIEF) && !IS_SET(victim->act, PLR_THIEF)
	 && !IS_NPC(victim))
         {
           SET_BIT(ch->act, PLR_THIEF);
	   send_to_char("*****You are now a THIEF*****\n\r",ch);
	   save_char_obj(ch);
         }
      damage(ch,victim,0,gsn_slice,DAM_OTHER,FALSE,TRUE);
    }
    else
    {
       check_improve(ch,gsn_slice,TRUE,1);
       send_to_char("Nicely done!\n\r",ch);
       if (!IS_NPC(victim)) ch->pcdata->steal_data[PC_SLICES] += 1 ;
     /* This is the fun part.  If the attempt succeeds, dump the contents of the container
      * into the victim's inventory.
      */
      if (obj->contains)  /* dump contents */
       {
	 for (t_obj = obj->contains; t_obj != NULL; t_obj = n_obj)
	 {
	   n_obj = t_obj->next_content;
	   if (number_percent() < ((ch->level)*3/2))
	   {
	   obj_from_obj(t_obj);
	   obj_to_char(t_obj, victim); 
         }
       }
      }
    }
      
    return;
}     

void do_steal( CHAR_DATA *ch, char *argument )
{
    char buf  [MAX_STRING_LENGTH];
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    int percent;

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if (IS_SET(ch->mhs, MHS_GLADIATOR) || IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("You are not permitted steal.\n\r",ch);
       return;
    }
    if (ch->clan == clan_lookup("smurf"))
    {
       send_to_char("You are not permitted to steal.\n\r",ch);
       return;
    }

    if ( arg1[0] == '\0' || arg2[0] == '\0' )
    {
  send_to_char( "Steal what from whom?\n\r", ch );
  return;
    }

    if( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_HIDE))
        REMOVE_BIT( ch->affected_by, AFF_HIDE );

    if ( ( victim = get_char_room( ch, arg2 ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }


    if (get_skill(ch,gsn_steal) < 1)
    {
  send_to_char( "Leave the stealing to the thieves.\n\r", ch );
  return;
    }

    if ( victim == ch )
    {
  send_to_char( "That's pointless.\n\r", ch );
  return;
    }

    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("They are made of mist.\r\n",ch);
    return;
    }


    if ( is_affected(ch,skill_lookup("hold person")))
    {
	send_to_char("Your muscles are frozen!\n\r",ch);
	return;
    }

    if ( ch->clan  && ch->in_room->clan ) 
    {
	send_to_char("Stealing from your clan mates is illegal.\n\r", ch);
	return;
    }

    if ( ch->move < (ch->level/15) )
    {   
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

    if (is_safe_steal(ch,victim))
    {
    send_to_char("Not on that person.\n\r",ch);
    return;
    } 

    if ( IS_NPC(victim) 
    && victim->position == POS_FIGHTING)
    {
  send_to_char(  "Kill stealing is not permitted.\n\r"
           "You'd better not -- you might get hit.\n\r",ch);
  return;
    }
    
    /*  This code killed by NIGHTDAGGER
    if(!IS_NPC(ch) && ch->clan == clan_lookup("avarice") && !IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1) && !is_affected(ch,  skill_lookup("speed")) && !IS_SET(ch->res_flags, RES_DELAY) )
    {
    WAIT_STATE(ch, skill_table[gsn_steal].beats/2);
    }
    else
    {
    WAIT_STATE( ch, skill_table[gsn_steal].beats );
    }
    End code nerf */

    WAIT_STATE( ch, skill_table[gsn_steal].beats) ;
    percent  = number_percent();
    /* Why the hell is this here? 
     * Because those without the steal skill should NEVER succeed! -Rusty
     */
   sprintf(log_buf,"steal-bef:%s race %d cls %d lvl %d dex %d percent:%d victim %s lvl %d dex %d",ch->name,ch->race,ch->class,ch->level,get_curr_stat(ch,STAT_DEX),percent,victim->name,victim->level,get_curr_stat(victim,STAT_DEX));
   log_string(log_buf);
    if (get_skill(ch,gsn_steal) > 1)
    {
       percent  += ( IS_AWAKE(victim) ? 10 : -50 );
       percent += (victim->level - ch->level)*15;
       percent += ( ( (get_curr_stat(victim,STAT_DEX)/2) + (get_curr_stat(victim,STAT_AGT)/2) ) - ( (get_curr_stat(ch,STAT_DEX)/2) + (get_curr_stat(ch,STAT_DEX)/2) ) ) *2;
       if(IS_SET(victim->vuln_flags,VULN_DISTRACTION))
          percent -= ch->level/2;
       if(!IS_NPC(ch) && ch->pcdata->old_class != class_lookup("thief") )
          percent += 25;
       if( !IS_NPC(ch) && ch->class == class_lookup("monk")  )
       {
           percent += 15;
       } 
       if( !IS_NPC(ch) && ch->class == class_lookup("berzerker")  )
       {
           percent += 20;
       }

      if(!IS_NPC(ch) && ch->class == class_lookup("assassin"))
          percent -= 15;
       if(!IS_NPC(ch) && ch->class == class_lookup("rogue"))
          percent -= 25;
       if ( ch->race == race_lookup("kender") )
          percent -= 10;
    }
    else
    {
       /* garauntee failure */
       percent = 110;
    }

   sprintf(log_buf,"steal-aft:%s skill %d percent:%d victim %s ",ch->name,(get_skill(ch,gsn_steal)*9/10),percent,victim->name);
   log_string(log_buf);
    if ( ((ch->level -7 > victim->level) 
          && !IS_NPC(victim) && !IS_NPC(ch) )
       || ( !IS_NPC(ch) && percent > get_skill(ch,gsn_steal) * 9 / 10 )
       || ( !IS_NPC(victim) && !is_clan(ch)) )
    {
  /*
   * Failure.
   */
       send_to_char( "Oops.\n\r", ch );
       act( "$n tried to steal from you.\n\r", ch, NULL, victim, TO_VICT    ,FALSE);
       act( "$n tried to steal from $N.\n\r",  ch, NULL, victim, TO_NOTVICT ,FALSE);
       if (IS_AWAKE(victim))
       {
          switch(number_range(0,5))
          {
             case 0 :
                sprintf( buf, "%s is a lousy thief!", ch->name );
                break;
             case 1 :
                sprintf( buf, "%s couldn't rob %s way out of a paper bag!",
                  ch->name,(ch->sex == 2) ? "her" : "his");
                break;
             case 2 :
                sprintf( buf,"%s tried to grope me!",ch->name );
                break;
             case 3 :
                sprintf(buf,"Keep your hands out of there, %s!",ch->name);
                break;
             case 4 :
                sprintf(buf,"%s touched me in my special place! Help!", ch->name);
                break;
             case 5 :
                sprintf(buf, "Don't touch me there %s!", ch->name);
                break;
          }
          do_yell( victim, buf );
       }

       if ( !IS_NPC(ch) )
       {
          if ( IS_NPC(victim) )
          {
             check_improve(ch,gsn_steal,FALSE,2);
             multi_hit( victim, ch, TYPE_UNDEFINED );
          }
          else
          {
             ch->pcdata->quit_time = 5;
             sprintf(buf,"$N tried to steal from %s.",victim->name);
             wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);

    /* If someone not fighting the victim casts a spell at the victim then
      add the caster to the victims last attacked by, but only if the
      character is normally outside the victim's level range */
             if (((IS_SET(ch->act,PLR_THIEF) || IS_SET(ch->act,PLR_KILLER))
                   && ch->level+12 < victim->level ) 
                   || (ch->trumps == 0 && ch->level+8 < victim->level)
                   || (ch->trumps > 0 && ch->level+10 < victim->level ) )
                victim->pcdata->last_attacked_by = str_dup(ch->name);

/*COREY DO THE HONOR VS DEMISE CHECK HERE */

             if ( 
		  (!IS_SET(ch->act, PLR_THIEF) && 
                  !IS_SET(victim->act, PLR_THIEF) 
                  )
                 // ||
                 // (
                 // ch->clan != clan_lookup("honor") &&
                  //victim->clan != clan_lookup("demise")
                 // )
		)
             {
                  SET_BIT(ch->act, PLR_THIEF);
                  send_to_char( "*** You are now a THIEF!! ***\n\r", ch );
                  sprintf(buf,"%s got THIEF on %s in room %d",ch->name,
		  victim->name,ch->in_room->vnum);
                  log_string(buf);
                  save_char_obj( ch );
             }
          }
       }
       return;
    }

    if ( !str_cmp( arg1, "coin"  )
    ||   !str_cmp( arg1, "coins" )
    ||   !str_cmp( arg1, "gold"  ) 
    ||   !str_cmp( arg1, "silver"))
    {
  int gold, silver;

  gold = victim->gold * number_range(1, ch->level) / MAX_LEVEL;
  silver = victim->silver * number_range(1,ch->level) / MAX_LEVEL;
  if ( gold <= 0 && silver <= 0 )
  {
      send_to_char( "You couldn't get any coins.\n\r", ch );
      return;
  }

  ch->gold      += gold;
  ch->silver    += silver;
  victim->silver  -= silver;
  victim->gold  -= gold;
  if (silver <= 0)
      sprintf( buf, "Bingo!  You got %d gold coins.\n\r", gold );
  else if (gold <= 0)
      sprintf( buf, "Bingo!  You got %d silver coins.\n\r",silver);
  else
      sprintf(buf, "Bingo!  You got %d silver and %d gold coins.\n\r",
        silver,gold);

  send_to_char( buf, ch );
  if (!IS_NPC(victim))
  {
     sprintf(buf,"$N stole %d gold and %d silver from %s.",
	  gold,silver,victim->name);
     wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);
     ch->pcdata->steal_data[PC_STOLEN_GOLD] += gold ;
     ch->pcdata->steal_data[PC_STOLEN_GOLD] += silver/100 ;
  }
  check_improve(ch,gsn_steal,TRUE,2);
  return;
    }

    if ( ( obj = find_obj_carry( ch, victim, arg1 ) ) == NULL )
    {
  send_to_char( "You can't find it.\n\r", ch );
  return;
    }
  
    if ( !can_drop_obj( victim, obj )
    ||   IS_SET(obj->extra_flags, ITEM_INVENTORY)
    ||   (obj->level - 2) > ch->level )
    {
  send_to_char( "You can't pry it away.\n\r", ch );
  return;
    }

    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
    {
  send_to_char( "You have your hands full.\n\r", ch );
  return;
    }

    if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
    {
  send_to_char( "You can't carry that much weight.\n\r", ch );
  return;
    }

    obj_from_char( obj );
    obj_to_char( obj, ch );
    check_improve(ch,gsn_steal,TRUE,2);
    obj->stolen_timer += 10 * number_fuzzy(5);
    if (!IS_NPC(victim))
    {
       sprintf(buf,"$N stole %s from %s.",obj->short_descr,victim->name);
       wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);
       ch->pcdata->steal_data[PC_STOLEN_ITEMS] += 1 ;
    }
    send_to_char( "Got it!\n\r", ch );
    return;
}



/*
 * Shopping commands.
 */
CHAR_DATA *find_keeper( CHAR_DATA *ch )
{
    /*char buf[MAX_STRING_LENGTH];*/
    CHAR_DATA *keeper;
    SHOP_DATA *pShop;

    pShop = NULL;
    for ( keeper = ch->in_room->people; keeper; keeper = keeper->next_in_room )
    {
  if ( IS_NPC(keeper) && (pShop = keeper->pIndexData->pShop) != NULL )
      break;
    }

    if ( pShop == NULL )
    {
  send_to_char( "You can't do that here.\n\r", ch );
  return NULL;
    }

    /*
     * Undesirables.
     *
    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_KILLER) )
    {
  do_say( keeper, "Killers are not welcome!" );
  sprintf( buf, "%s the KILLER is over here!\n\r", ch->name );
  do_yell( keeper, buf );
  return NULL;
    }

    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_THIEF) )
    {
  do_say( keeper, "Thieves are not welcome!" );
  sprintf( buf, "%s the THIEF is over here!\n\r", ch->name );
  do_yell( keeper, buf );
  return NULL;
    }
  */
    /*
     * Shop hours.
     */
    if ( time_info.hour < pShop->open_hour )
    {
  do_say( keeper, "Sorry, I am closed. Come back later." );
  return NULL;
    }
    
    if ( time_info.hour > pShop->close_hour )
    {
  do_say( keeper, "Sorry, I am closed. Come back tomorrow." );
  return NULL;
    }

    /*
     * Invisible or hidden people.
     */
/*COREY PUT THAT STUFF FOR FENCE HERE*/
   if ( (!can_see( keeper, ch, FALSE ) &&  ch->kit != kit_lookup("fence")) )
    {
  do_say( keeper, "I don't trade with folks I can't see." );
  return NULL;
    }

    return keeper;
}

/* insert an object at the right spot for the keeper */
void obj_to_keeper( OBJ_DATA *obj, CHAR_DATA *ch )
{
    OBJ_DATA *t_obj, *t_obj_next;

    /* see if any duplicates are found */
    for (t_obj = ch->carrying; t_obj != NULL; t_obj = t_obj_next)
    {
  t_obj_next = t_obj->next_content;

  if (obj->pIndexData == t_obj->pIndexData 
  &&  !str_cmp(obj->short_descr,t_obj->short_descr))
  {
      /* if this is an unlimited item, destroy the new one */
      if (IS_OBJ_STAT(t_obj,ITEM_INVENTORY))
      {
    extract_obj(obj);
    return;
      }
      obj->cost = t_obj->cost; /* keep it standard */
      break;
  }
    }

    if (t_obj == NULL)
    {
  obj->next_content = ch->carrying;
  ch->carrying = obj;
    }
    else
    {
  obj->next_content = t_obj->next_content;
  t_obj->next_content = obj;
    }

    obj->carried_by      = ch;
    obj->in_room         = NULL;
    obj->in_obj          = NULL;
    ch->carry_number    += get_obj_number( obj );
    ch->carry_weight    += get_obj_weight( obj );
}

/* get an object from a shopkeeper's list */
OBJ_DATA *get_obj_keeper( CHAR_DATA *ch, CHAR_DATA *keeper, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int number;
    int count;
 
    number = number_argument( argument, arg );
    count  = 0;
    for ( obj = keeper->carrying; obj != NULL; obj = obj->next_content )
    {
        if (obj->wear_loc == WEAR_NONE
        &&  can_see_obj( keeper, obj )
  &&  can_see_obj(ch,obj)
        &&  is_name( arg, obj->name ) )
        {
            if ( ++count == number )
                return obj;
  
      /* skip other objects of the same name */
      while (obj->next_content != NULL
      && obj->pIndexData == obj->next_content->pIndexData
      && !str_cmp(obj->short_descr,obj->next_content->short_descr))
    obj = obj->next_content;
        }
    }
 
    return NULL;
}

int get_cost( CHAR_DATA *keeper, OBJ_DATA *obj, bool fBuy )
{
    SHOP_DATA *pShop;
    int cost;

    if ( obj == NULL || ( pShop = keeper->pIndexData->pShop ) == NULL )
       return 0;

    if ( fBuy )
    {
       cost = obj->cost * pShop->profit_buy  / 100;
    }
    else
    {
       OBJ_DATA *obj2;
       int itype;

       cost = 0;
       for ( itype = 0; itype < MAX_TRADE; itype++ )
       {
          if ( obj->item_type == pShop->buy_type[itype] )
          {
             cost = obj->cost * pShop->profit_sell / 100;
             break;
          }
       }

       if (!IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT))
       {
          for ( obj2 = keeper->carrying; obj2; obj2 = obj2->next_content )
          {
             if ( obj->pIndexData == obj2->pIndexData
             &&   !str_cmp(obj->short_descr,obj2->short_descr) )
             { 
                if (IS_OBJ_STAT(obj2,ITEM_INVENTORY))
	        {
                   cost /= 2;
	        }
                else
	        {
                   cost = cost * 3 / 4;
	        }
	     }
	  }
       }
    }

    if ( (obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND))
    {

       if(obj->pIndexData->vnum == 8147 ||
          obj->pIndexData->vnum == 3141 ||
          obj->pIndexData->vnum == 3128
         )
       {
	cost = cost;
	}
	else
       {

       		if (obj->value[1] == 0)
       		{
        	  cost /= 4;
       		}
       		else
       		{
        	  cost = cost * obj->value[2] / obj->value[1];
       		}
       }
    }

    return cost;
}



void do_buy( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    int roll;
    long cost;

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("You are pretty freaking looking, and scare the shopkeeper.\r\n",ch);
    return;
    }

    
    if ( argument[0] == '\0' )
    {
  send_to_char( "Buy what?\n\r", ch );
  return;
    }

    if (!IS_NPC(ch) && ch->in_room->clan && ch->clan &&
       IS_SET(ch->pcdata->clan_flags, CLAN_NO_STORE) )
       {
       send_to_char("You have been forbidden to use the clan store.\n\r", ch);
       return;
       }


    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
    {
  char arg[MAX_INPUT_LENGTH];
  char buf[MAX_STRING_LENGTH];
  CHAR_DATA *pet;
  ROOM_INDEX_DATA *pRoomIndexNext;
  ROOM_INDEX_DATA *in_room;

  if ( IS_NPC(ch) )
      return;

  argument = one_argument(argument,arg);

  /* hack to make new thalos pets work */
  if (ch->in_room->vnum == 9621)
      pRoomIndexNext = get_room_index(9706);
  else
      pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
  if ( pRoomIndexNext == NULL )
  {
      bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
      send_to_char( "Sorry, you can't buy that here.\n\r", ch );
      return;
  }

  in_room     = ch->in_room;
  ch->in_room = pRoomIndexNext;
  pet         = get_char_room( ch, arg );
  ch->in_room = in_room;

  if ( pet == NULL || !IS_SET(pet->act, ACT_PET) )
  {
      send_to_char( "Sorry, you can't buy that here.\n\r", ch );
      return;
  }

  if ( ch->pet != NULL )
  {
      send_to_char("You already own a pet.\n\r",ch);
      return;
  }

  cost = 10 * pet->level * pet->level;

  if ( (ch->silver + 100 * ch->gold) < cost )
  {
      send_to_char( "You can't afford it.\n\r", ch );
      return;
  }

  if ( ch->level < pet->level )
  {
      send_to_char(
    "You're not powerful enough to master this pet.\n\r", ch );
      return;
  }

  /* haggle */
  roll = number_range(30,100);
  if ( (roll - get_curr_stat(ch,STAT_SOC)) < get_skill(ch,gsn_haggle))
  {
      cost -= cost / 2 * roll / 100;
      sprintf(buf,"You haggle the price down to %d coins.\n\r",cost);
      send_to_char(buf,ch);
      check_improve(ch,gsn_haggle,TRUE,4);
  
  }
  if (IS_SET(ch->act,PLR_DWEEB)) cost *= 2;

  deduct_cost(ch,cost);
  pet     = create_mobile( pet->pIndexData );
  SET_BIT(pet->act, ACT_PET);
  SET_BIT(pet->affected_by, AFF_CHARM);
  pet->comm = COMM_NOTELL|COMM_NOSHOUT|COMM_NOCHANNELS;

/* Naming pets causes to many problems
 *
  argument = one_argument( argument, arg );
  if ( arg[0] != '\0' )
  {
      sprintf( buf, "%s %s", pet->name, arg );
      free_string( pet->name );
      pet->name = str_dup( buf );
  }
 */

  sprintf( buf, "%sA neck tag says 'I belong to %s'.\n\r",
      pet->description, ch->name );
  free_string( pet->description );
  pet->description = str_dup( buf );

  char_to_room( pet, ch->in_room );
  add_follower( pet, ch );
  pet->leader = ch;
  ch->pet = pet;
  send_to_char( "Enjoy your pet.\n\r", ch );
  act( "$n bought $N as a pet.", ch, NULL, pet, TO_ROOM ,FALSE);
  return;
    }
    else
    {
  CHAR_DATA *keeper;
  OBJ_DATA *obj,*t_obj;
  char arg[MAX_INPUT_LENGTH];
  int number, count = 1;

  if ( ( keeper = find_keeper( ch ) ) == NULL )
      return;

  number = mult_argument(argument,arg);
  if ( number <= 0 )
  {
     if (!is_number(arg))
     {
     sprintf(buf,"Well, aren't you clever. We fixed this a long time ago.\n\r");
     /* Removed punishing them
     ch->gold = 0;
     ch->silver =0;
     */
     }
     else
     {
     sprintf(buf,"Wrong syntax, please try again or look at 'Help Buy'.\n\r");
     }
     send_to_char(buf,ch);
     return;
  }
  else
  if( number > 100 )
  {
      send_to_char("Rent a U-Haul first, to carry all that.\n\r",ch);
      return;
  }
  obj  = get_obj_keeper( ch,keeper, arg );
  cost = get_cost( keeper, obj, TRUE );
  if (IS_SET(ch->act,PLR_DWEEB)) cost *= 2;
  if ( cost <= 0 || !can_see_obj( ch, obj ) )
  {
      act( "$n tells you 'I don't sell that -- try 'list''.",
    keeper, NULL, ch, TO_VICT ,FALSE);
      ch->reply = keeper;
      return;
  }

  if ( ch->clan == clan_lookup("outcast") && (ch->pcdata->outcT > 0) )
  {
     act("$n tells you 'I don't do business with Outcasts!'",
	keeper,NULL,ch, TO_VICT ,FALSE);
     return;
  }

  if (!IS_OBJ_STAT(obj,ITEM_INVENTORY))
  {
      for (t_obj = obj->next_content;
         count < number && t_obj != NULL; 
         t_obj = t_obj->next_content) 
      {
        if (t_obj->pIndexData == obj->pIndexData
        &&  !str_cmp(t_obj->short_descr,obj->short_descr))
        count++;
        else
        break;
      }

      if (count < number)
      {
        act("$n tells you 'I don't have that many in stock.",
        keeper,NULL,ch,TO_VICT,FALSE);
        ch->reply = keeper;
        return;
      }
  }

  if ( (ch->silver + ch->gold * 100) < cost * number )
  {
      if (number > 1)
    act("$n tells you 'You can't afford to buy that many.",
        keeper,obj,ch,TO_VICT,FALSE);
      else
        act( "$n tells you 'You can't afford to buy $p'.",
        keeper, obj, ch, TO_VICT ,FALSE);
      ch->reply = keeper;
      return;
  }
  
  if ( obj->level > ch->level + 2 )
  {
      act( "$n tells you 'You can't use $p yet'.",
    keeper, obj, ch, TO_VICT ,FALSE);
      ch->reply = keeper;
      return;
  }

  if (ch->carry_number +  number * get_obj_number(obj) > can_carry_n(ch))
  {
      send_to_char( "You can't carry that many items.\n\r", ch );
      return;
  }

  if ( ch->carry_weight + number * get_obj_weight(obj) > can_carry_w(ch))
  {
      send_to_char( "You can't carry that much weight.\n\r", ch );
      return;
  }

  /* haggle */
  roll = number_range(30,100);
  if (!IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT) 
  && ((roll - get_curr_stat(ch,STAT_SOC)) < get_skill(ch,gsn_haggle)) )
  {
      cost -= obj->cost / 2 * roll / 100;
      act("You haggle with $N.",ch,NULL,keeper,TO_CHAR,FALSE);
      check_improve(ch,gsn_haggle,TRUE,4);
  }

  if (number > 1)
  {
      sprintf(buf,"$n buys $p[%d].",number);
      act(buf,ch,obj,NULL,TO_ROOM,FALSE);
      sprintf(buf,"You buy $p[%d] for %d silver.",number,cost * number);
      act(buf,ch,obj,NULL,TO_CHAR,FALSE);
  }
  else
  {
      act( "$n buys $p.", ch, obj, NULL, TO_ROOM ,FALSE);
      sprintf(buf,"You buy $p for %d silver.",cost);
      act( buf, ch, obj, NULL, TO_CHAR ,FALSE);
  }
  deduct_cost(ch,cost * number);
  keeper->gold += cost * number/100;
  keeper->silver += cost * number - (cost * number/100) * 100;

  for (count = 0; count < number; count++)
  {
      if ( IS_SET( obj->extra_flags, ITEM_INVENTORY ) )
        t_obj = create_object( obj->pIndexData, obj->level, FALSE ); 
      else
      {
    t_obj = obj;
    obj = obj->next_content;
        obj_from_char( t_obj );
      }

      if (t_obj->timer > 0 && !IS_OBJ_STAT(t_obj,ITEM_HAD_TIMER))
        t_obj->timer = 0;
      REMOVE_BIT(t_obj->extra_flags,ITEM_HAD_TIMER);
      obj_to_char( t_obj, ch );
      if (cost < t_obj->cost)
        t_obj->cost = cost;
  }
    }
}



void do_list( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char buf2[6*MAX_STRING_LENGTH];

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("You are pretty scary looking, the shopkeeper is scared.\r\n",ch);
    return;
    }


    if (!IS_NPC(ch) && ch->in_room->clan && ch->clan &&
       IS_SET(ch->pcdata->clan_flags, CLAN_NO_STORE) )
       {
       send_to_char("You have been forbidden to use the clan store.\n\r", ch);
       return;
       }

    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
    {
  ROOM_INDEX_DATA *pRoomIndexNext;
  CHAR_DATA *pet;
  bool found;

        /* hack to make new thalos pets work */
        if (ch->in_room->vnum == 9621)
            pRoomIndexNext = get_room_index(9706);
        else
            pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );

  if ( pRoomIndexNext == NULL )
  {
      bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
      send_to_char( "You can't do that here.\n\r", ch );
      return;
  }

  found = FALSE;
  buf2[0] = '\0';
  for ( pet = pRoomIndexNext->people; pet; pet = pet->next_in_room )
  {
      if ( IS_SET(pet->act, ACT_PET) )
      {
    if ( !found )
    {
        found = TRUE;
        send_to_char( "Pets for sale:\n\r", ch );
    }
    sprintf( buf, "[%2d] %8d - %s\n\r",
        pet->level,
        10 * pet->level * pet->level,
        pet->short_descr );
    strcat( buf2, buf );
      }
  }
    page_to_char( buf2, ch);
  if ( !found )
      send_to_char( "Sorry, we're out of pets right now.\n\r", ch );
  return;
    }
    else
    {
  CHAR_DATA *keeper;
  OBJ_DATA *obj;
  int cost,count;
  bool found;
  char arg[MAX_INPUT_LENGTH];

  if ( ( keeper = find_keeper( ch ) ) == NULL )
      return;
        one_argument(argument,arg);

  found = FALSE;
  buf2[0] = '\0';
  for ( obj = keeper->carrying; obj; obj = obj->next_content )
  {
      if ( obj->wear_loc == WEAR_NONE
      &&   can_see_obj( ch, obj )
      &&   ( cost = get_cost( keeper, obj, TRUE ) ) > 0 
      &&   ( arg[0] == '\0'  
         ||  is_name(arg,obj->name) ))
      {
    if ( !found )
    {
        found = TRUE;
        send_to_char( "[Lv Price Qty] Item\n\r", ch );
    }

    if (IS_OBJ_STAT(obj,ITEM_INVENTORY))
        sprintf(buf,"[%2d %5d -- ] %s\n\r",
      obj->level,cost,obj->short_descr);
    else
    {
        count = 1;

        while (obj->next_content != NULL 
        && obj->pIndexData == obj->next_content->pIndexData
        && !str_cmp(obj->short_descr,
              obj->next_content->short_descr))
        {
      obj = obj->next_content;
      count++;
        }
        sprintf(buf,"[%2d %5d %2d ] %s\n\r",
      obj->level,cost,count,obj->short_descr);
    }
     strcat(buf2, buf);
      }
  }
     page_to_char(buf2, ch);

  if ( !found )
      send_to_char( "You can't buy anything here.\n\r", ch );
  return;
    }
}



void do_sell( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *keeper;
    OBJ_DATA *obj;
    int roll;
    long cost;

    one_argument( argument, arg );

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }



    if ( arg[0] == '\0' )
    {
  send_to_char( "Sell what?\n\r", ch );
  return;
    }
    
    if (!IS_NPC(ch) && ch->in_room->clan && ch->clan &&
       IS_SET(ch->pcdata->clan_flags, CLAN_NO_STORE) )
       {
       send_to_char("You have been forbidden to use the clan store.\n\r", ch);
       return;
       }

    if ( ( keeper = find_keeper( ch ) ) == NULL )
  return;

    if ( ( obj = get_obj_carry( ch, arg ) ) == NULL )
    {
  act( "$n tells you 'You don't have that item'.",
      keeper, NULL, ch, TO_VICT ,FALSE);
  ch->reply = keeper;
  return;
    }

    if ( !can_drop_obj( ch, obj ) )
    {
  send_to_char( "You can't let go of it.\n\r", ch );
  return;
    }

    if (!can_see_obj(keeper,obj))
    {
  act("$n doesn't see what you are offering.",keeper,NULL,ch,TO_VICT,FALSE);
  return;
    }

    if ( ( cost = get_cost( keeper, obj, FALSE ) ) <= 0 )
    {
  act( "$n looks uninterested in $p.", keeper, obj, ch, TO_VICT ,FALSE);
  return;
    }
  if (IS_SET(ch->act,PLR_DWEEB)) cost /= 2;
    if ( cost > (keeper-> silver + 100 * keeper->gold) )
    {
  act("$n tells you 'I'm afraid I don't have enough wealth to buy $p.",
      keeper,obj,ch,TO_VICT,FALSE);
  return;
    }

    act( "$n sells $p.", ch, obj, NULL, TO_ROOM ,FALSE);
    /* connive */
    roll = number_percent();
    if (!IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT) && roll < get_skill(ch,gsn_connive))
    {
	send_to_char("You are sooooooo smooth.\n\r",ch);
        cost += obj->cost / 4 * roll / 100;
        cost = UMIN(cost,95 * get_cost(keeper,obj,TRUE) / 100);
	cost = UMIN(cost,(keeper->silver + 100 * keeper->gold));
        check_improve(ch,gsn_connive,TRUE,4);
    }
    roll = number_range(30,100);
	/* haggle*/
    if (!IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT) && (roll - get_curr_stat(ch,STAT_SOC) < get_skill(ch,gsn_haggle)) )
    {
        send_to_char("You haggle with the shopkeeper.\n\r",ch);
        cost += obj->cost / 2 * roll / 100;
        cost = UMIN(cost,95 * get_cost(keeper,obj,TRUE) / 100);
  cost = UMIN(cost,(keeper->silver + 100 * keeper->gold));
        check_improve(ch,gsn_haggle,TRUE,4);
    }
    sprintf( buf, "You sell $p for %d silver and %d gold piece%s.",
  cost - (cost/100) * 100, cost/100, cost == 1 ? "" : "s" );
    act( buf, ch, obj, NULL, TO_CHAR ,FALSE);
    ch->gold     += cost/100;
    ch->silver   += cost - (cost/100) * 100;
    deduct_cost(keeper,cost);
    if ( keeper->gold < 0 )
  keeper->gold = 0;
    if ( keeper->silver< 0)
  keeper->silver = 0;

    if ( obj->item_type == ITEM_TRASH || IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT))
    {
  extract_obj( obj );
    }
    else
    {
  obj_from_char( obj );
  if (obj->timer)
      SET_BIT(obj->extra_flags,ITEM_HAD_TIMER);
  else
      /* No timers on clan shopkeeper special MOBs */
      if(!keeper->in_room->clan || keeper->in_room->clan != ch->clan)
	obj->timer = number_range(50,100);
  obj_to_keeper( obj, keeper );
    }

    return;
}



void do_value( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *keeper;
    OBJ_DATA *obj;
    int cost;

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Value what?\n\r", ch );
  return;
    }

    if (!IS_NPC(ch) && ch->in_room->clan && ch->clan &&
       IS_SET(ch->pcdata->clan_flags, CLAN_NO_STORE) )
       {
       send_to_char("You have been forbidden to use the clan store.\n\r", ch);
       return;
       }
    
    if ( ( keeper = find_keeper( ch ) ) == NULL )
  return;

    if ( ( obj = get_obj_carry( ch, arg ) ) == NULL )
    {
  act( "$n tells you 'You don't have that item'.",
      keeper, NULL, ch, TO_VICT ,FALSE);
  ch->reply = keeper;
  return;
    }

    if (!can_see_obj(keeper,obj))
    {
      act("$n doesn't see what you are offering.",keeper,NULL,ch,TO_VICT,FALSE);
      return;
    }

    if ( !can_drop_obj( ch, obj ) )
    {
  send_to_char( "You can't let go of it.\n\r", ch );
  return;
    }

    if ( ( cost = get_cost( keeper, obj, FALSE ) ) <= 0 )
    {
  act( "$n looks uninterested in $p.", keeper, obj, ch, TO_VICT ,FALSE);
  return;
    }

    sprintf( buf, 
  "$n tells you 'I'll give you %d silver and %d gold coins for $p'.", 
  cost - (cost/100) * 100, cost/100 );
    act( buf, keeper, obj, ch, TO_VICT ,FALSE);
    ch->reply = keeper;

    return;
}


void do_assemble ( CHAR_DATA *ch, char *argument)
{
	OBJ_DATA *piece;
	OBJ_DATA *whole;
 	OBJ_DATA *obj;
	int count = 0, check_count = 0;
	int i;

        if ( argument[0] == '\0')
	{
	send_to_char("Assemble what?\n\r", ch);
	return;
	}

	if ( ( piece = get_obj_carry(ch, argument) )== NULL )
	{
	send_to_char("You're not carrying that.\n\r", ch);
	return;
	}

	if ( piece->item_type != ITEM_PART )
	{
	act( "$p is not part of a greater item.",ch, piece, NULL, TO_CHAR, FALSE);
	return;
	}

	for ( i = 0; i <= 4; i++)
	{
   	  if (piece->value[i] != 0) count++;	
	}

	// now, take one away from count, since we don't need the vnum of the whole item
	if (count != 0) count -= 1;

	// if count = 0 at this point then the item is a part, with no whole, so lets return
	if ( count == 0) return;

	// now start checking to see if they have the items necessary
 	for ( i = 1; i <= count; i++)
		for ( obj = ch->carrying; obj != NULL; obj = obj->next_content)
			if ( obj->pIndexData->vnum == piece->value[i] && obj->item_type == ITEM_PART )
				check_count++;
	
	//now we know if they have all the items if the count and check_count match
 	if ( count == check_count )
	{
	whole = create_object(get_obj_index(piece->value[0]), 0, FALSE);
	send_to_char("A blinding light engulfs you!\n\r", ch);
	act ("You have created $p!",ch, whole, NULL, TO_CHAR, FALSE);
	act ("$N creates $p in a blaze of magical light!", ch, whole, NULL, TO_ROOM, FALSE);
	obj_to_char( whole, ch);

	// now remove all the parts
 	for ( i = 1; i <= count; i++)
		for ( obj = ch->carrying; obj != NULL; obj = obj->next_content)
			if ( obj->pIndexData->vnum == piece->value[i] )
				{
				obj_from_char(obj);
				extract_obj(obj);	
				}
      	}
	else
	{
	send_to_char ("You don't have all the necessary pieces.\n\r", ch);
	return;
	}
	return;
}

void do_get_voucher ( CHAR_DATA *ch, CHAR_DATA *argument )
{
  OBJ_DATA *obj;
  OBJ_DATA *obj_next;
  int brick_count=0;
  int taken_bricks=0;

  if ( !IS_IMMORTAL(ch) )
  {
    return;
  }
  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
    obj_next = obj->next_content;

    if ( obj->pIndexData->vnum == OBJ_VNUM_PLAT_BRICK )
    {
      brick_count++;
    }
  }
  if ( ( ch->pcdata->rank < 4 && ch->clan == clan_lookup("zealot") ) && !IS_IMMORTAL(ch) )
  {
    if ( brick_count >=5 )
    {
      send_to_char("The Almighty bestows a vial of his Holy Oil upon you.\n\r", ch );
      act( "$n is surrouned by a beautiful {Wwhite light.", ch, NULL, NULL, TO_ROOM ,FALSE);
      for ( obj = ch->carrying; obj != NULL; obj = obj_next )
      {
        obj_next = obj->next_content;

        if ( obj->pIndexData->vnum == OBJ_VNUM_PLAT_BRICK && taken_bricks < 5)
        {
          extract_obj(obj);
          taken_bricks++;
        }
      }
      obj_to_char(create_object(get_obj_index(OBJ_VNUM_HOLY_OIL),0,FALSE),ch);
    } 
    else
    {
      send_to_char("You do not have enough beautiful platinum bricks.  You must have a sacrifice of at least five. \n\r", ch );
    }
  } 

  return;
}

void do_forge ( CHAR_DATA *ch, char *argument )
{
	RECIPE_DATA *recipe;
	OBJ_DATA *forge, *obj, *complete, *t_obj;
	int count = 0;
        int  i, j;
        bool  match = FALSE;
	int part_list[MAX_IN_RECIPE];
	int chance;

	if ( argument[0] == '\0' )
	{
	send_to_char("Attempt to use what to craft a greater item?\n\r", ch);
	return;
	}

	if ( (forge = get_obj_here(ch, argument)) == NULL)
	{
	send_to_char("You don't see that here.\n\r", ch);
	return;
	}

	if ( forge->item_type != ITEM_FORGE )
	{
	send_to_char("That item is not capable of transmuting objects.\n\r", ch);
	return;
	}

	/* first thing we need to do is loop through all the possible recipes associated with
	   this forge.  For each recipe, we need to check what items are required for
	   this recipe.  If we don't have all the items, check the next recipe for this forge.
	   if we do have them all, remove them from the game, and replace the contents with
	   the completed item for this recipe */

	for ( i = 0 ; i <= 4; i++ )
	{
		count = 0;

		if ( forge->value[i] <= 0 )
			continue;

		if ((recipe = get_recipe_data(forge->value[i])) == NULL)
		{
	        act("$p appears to be broken.", ch, forge, NULL, TO_CHAR, FALSE);
		return;
		}	

		for ( j = 0 ; j <= MAX_IN_RECIPE ; j++)
		{
		  if (recipe->vnum_parts[j] != 0) 
		  {
			part_list[j] = recipe->vnum_parts[j];
			count++;	
		  }
		  else
			break;
		}
		for (obj = forge->contains ; obj != NULL ; obj = obj->next_content )
		   for ( j = 0 ; j < count ; j++)
		   {
			if (obj->pIndexData->vnum == part_list[j] )
			{
				 part_list[j] = 0;
				break; /* Added by G to fix bug */
			}
		   }
	        for ( j = 0 ; j < count; j++ )
		{
		if ( part_list[j] != 0 )
			{
			match = FALSE;
			break;
			}
		else
			match = TRUE;
		}
		if (match) break;
	}

	/* At this point, we've gone through all possible recipes for this forge.  If match
	   is true, we have all the items we need, so lets extract them from the forge.  If
	   match is false, tell the player, and return */ 

	if (!match)
	{
	send_to_char("The forge does not have all the required ingredients.\n\r", ch);
	return;
	}
	else
	{
	    bool bFail = FALSE;

	   /* Check chance with skill */
	   if ( recipe->skill_sn > 0 )
	    {
		chance = get_skill(ch, recipe->skill_sn ) - recipe->difficulty;
		if ( number_percent() > chance )
	  	{
		    check_improve(ch,recipe->skill_sn,FALSE,15); /* failed */
		    bFail = TRUE;
		}
		else
			check_improve(ch,recipe->skill_sn,TRUE,5);
	    }

	   for(obj = forge->contains ; obj != NULL ; obj = t_obj )
	   {
		t_obj = obj->next_content;
		obj_from_obj(obj);
		extract_obj(obj);
	   }

	if ( bFail )
	{
		send_to_char("You failed to create anything.\n\r",ch);
		return;
	}
        complete = ( create_object(get_obj_index(recipe->vnum_complete), 0, FALSE));
	if ( complete == NULL )
	{
	    bug("ERROR in forge, completion object doesn't exit!  Vnum %d",recipe->vnum_complete);
	    send_to_char("There is a game error with this recipe.\n\r",ch);
	    return;
  	}

	obj_to_obj(complete, forge);
	act("$p glows with a magical light!", ch, forge, NULL, TO_ROOM, FALSE);
	act("Your forging is successful.  $p glows with magical light!", ch, forge, NULL, TO_CHAR, FALSE);
   	}
	return;
}
	
void do_ritual( CHAR_DATA *ch, char *argument )
{
    int chance;
    OBJ_DATA *scroll;
    int sector;

    if ( IS_NPC(ch) )
	return;

    if ( ch->pcdata->old_class != class_lookup("cleric") && ch->pcdata->old_class != class_lookup("elementalist"))
    {
	send_to_char("You are not devoted enough.  Only oldclass clerics may Ritual.\n\r",ch);
 	return;
    }

    sector = ch->in_room->sector_type;

    switch( sector )
    {
    case SECT_ALTAR_BASIC:
    case SECT_ALTAR_BLESSED:
    case SECT_ALTAR_ANNOINTED:
    case SECT_ALTAR_HOLY_GROUND: break;
    default:
	send_to_char("You can only perform the Ritual at an Altar.\n\r",ch);
	return;
    }

    if ( ( scroll = get_eq_char(ch,WEAR_HOLD) ) == NULL ||
	 scroll->item_type != ITEM_SPELL_PAGE )
    {
	send_to_char("You must be holding a spell page.\n\r",ch); 
	return;
    }

    if ( scroll->value[3] < 1 )
    {
	send_to_char("This scroll has been worn out beyond readability.\n\r",ch);
	return;
    }

	/* 0 : scribe level, 1 : Diff, 2: slot, 3: uses */ 
    if ( ch->level < scroll->value[0] )
    {
	send_to_char("You aren't ready yet.\n\r",ch);
	return;
    }

    if ( skill_table[scroll->value[2]].skill_level[ch->class] > 51 )
    {
	send_to_char("Your class cannot learn this spell.\n\r",ch);
	return;
    }

    if ( ch->pcdata->learned[scroll->value[2]] >= 1 )
    {
	send_to_char("You already know that spell!\n\r",ch);
	return;
    }

    /* DOn't have spell, can learn spell, have scroll, is right level, is in altar room */
    chance = ch->level;
    chance += (get_curr_stat(ch,STAT_INT)+get_curr_stat(ch,STAT_WIS))*2;
    chance -= scroll->value[1];
    switch ( sector )
   {
	case SECT_ALTAR_BASIC: chance += 10; break;
	case SECT_ALTAR_BLESSED: chance += 15; break;
	case SECT_ALTAR_ANNOINTED: chance += 30; break;
	case SECT_ALTAR_HOLY_GROUND: chance += 60; break;
   }
   chance = URANGE(5,chance,95);
   
   if ( number_percent( ) < chance )
   {
	ch->pcdata->learned[scroll->value[2]] = 1;
	scroll->value[3]--;
	scroll->cost = 0;
        act("You have learned a new spell from $p!",ch,scroll,NULL,TO_CHAR,FALSE);
	act("$n has learned a new spell from $p!",ch,scroll,NULL,TO_ROOM,FALSE);
	gain_exp(ch, scroll->value[0] * 100 );
   }
   else
   {
	scroll->value[3]--;
	scroll->cost = 0; 
	act("You attempt to learn from $p, but fail.",ch,scroll,NULL,TO_CHAR,FALSE);
	act("$n attempts to learn from $p, but fails.",ch,scroll,NULL,TO_ROOM,FALSE);
    }

    if ( scroll->value[3] < 1 )
    {
	act("$p wavers and then crumbles to ashes.",ch,scroll,NULL,TO_CHAR,FALSE);
	act("$p wavers and then crumbles to ashes.",ch,scroll,NULL,TO_ROOM,FALSE);
	extract_obj(scroll);
    }
}

void do_copyspell( CHAR_DATA *ch, char *argument )
{
    int chance;
    OBJ_DATA *scroll;
    int sector;

    if ( IS_NPC(ch) )
	return;

    if ( ch->pcdata->old_class != class_lookup("mage") )
    {
	send_to_char("You are not learned enough.  Only oldclass mages may copy scrolls.\n\r",ch);
 	return;
    }

    sector = ch->in_room->sector_type;

    switch( sector )
    {
    case SECT_MAGELAB_SIMPLE:
    case SECT_MAGELAB_INTERMEDIATE:
    case SECT_MAGELAB_ADVANCED:
    case SECT_MAGELAB_SUPERIOR: break;
    default:
	send_to_char("You must be in a Magelab to study spell pages.\n\r",ch);
	return;
    }

    if ( ( scroll = get_eq_char(ch,WEAR_HOLD) ) == NULL ||
	 scroll->item_type != ITEM_SPELL_PAGE )
    {
	send_to_char("You must be holding a spell page.\n\r",ch); 
	return;
    }

    if ( scroll->value[3] < 1 )
    {
	send_to_char("This spell page has been worn out beyond readability.\n\r",ch);
	return;
    }

	/* 0 : scribe level, 1 : Diff, 2: slot, 3: uses */ 
    if ( ch->level < scroll->value[0] )
    {
	send_to_char("You aren't ready yet.\n\r",ch);
	return;
    }

    if ( skill_table[scroll->value[2]].skill_level[ch->class] > 51 )
    {
	send_to_char("Your class cannot learn this spell.\n\r",ch);
	return;
    }

    if ( ch->pcdata->learned[scroll->value[2]] >= 1 )
    {
	send_to_char("You already know that spell!\n\r",ch);
	return;
    }

    /* DOn't have spell, can learn spell, have scroll, is right level, is in altar room */
    chance = ch->level;
    chance += (get_curr_stat(ch,STAT_INT)+get_curr_stat(ch,STAT_WIS))*2;
    chance -= scroll->value[1];
    switch ( sector )
   {
	case SECT_MAGELAB_SIMPLE: chance += 10; break;
	case SECT_MAGELAB_INTERMEDIATE: chance += 15; break;
	case SECT_MAGELAB_ADVANCED: chance += 30; break;
	case SECT_MAGELAB_SUPERIOR: chance += 60; break;
   }
   chance = URANGE(5,chance,95);
   
   if ( number_percent( ) < chance )
   {
	ch->pcdata->learned[scroll->value[2]] = 1;
	scroll->value[3]--;
	scroll->cost = 0;
        act("You have learned a new spell from $p!",ch,scroll,NULL,TO_CHAR,FALSE);
	act("$n has learned a new spell from $p!",ch,scroll,NULL,TO_ROOM,FALSE);
	gain_exp(ch,scroll->value[0] * 100 );
   }
   else
   {
	scroll->value[3]--;
	scroll->cost = 0; 
	act("You attempt to learn from $p, but fail.",ch,scroll,NULL,TO_CHAR,FALSE);
	act("$n attempts to learn from $p, but fails.",ch,scroll,NULL,TO_ROOM,FALSE);
    }

    if ( scroll->value[3] < 1 )
    {
	act("$p wavers and then crumbles to ashes.",ch,scroll,NULL,TO_CHAR,FALSE);
	act("$p wavers and then crumbles to ashes.",ch,scroll,NULL,TO_ROOM,FALSE);
	extract_obj(scroll);
    }
}

void do_newloot( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    OBJ_DATA *container;
    bool found;

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if (!str_cmp(arg2,"from"))
       argument = one_argument(argument,arg2);

    /* no loot 1. corpse */
    number_argument(arg1,arg1);
    
    if( is_affected(ch,skill_lookup("wraithform")) )
    {
        send_to_char( "You cannot loot while in wraithform.\r\n", ch);
        return;
    }

    /* Get type. */
    if ( arg1[0] == '\0' || arg2[0] == '\0' )
    {
	send_to_char( "Loot what?\n\r", ch );
	return;
    }

    if ( ( container = get_obj_here( ch, arg2 ) ) == NULL )
    {  
      act( "I see no $T here.", ch, NULL, arg2, TO_CHAR ,FALSE);
      return;
    }  

    switch ( container->item_type )
    {  
       default:
          send_to_char( "That's not a container.\n\r", ch );
          return;
     
       case ITEM_CONTAINER:
       case ITEM_CORPSE_NPC:
       {
	  send_to_char( "Use 'get'.\n\r", ch );
	  return;
       }

       case ITEM_CORPSE_PC:
       {
          if (!can_loot(ch,container,TRUE))
          {
             send_to_char( "You can't do that.\n\r", ch );
             return;
          }
       }

       if ( str_cmp( arg1, "all" ) && str_prefix( "all.", arg1 ) )
       {
          /* 'get obj container' */
          obj = get_obj_list( ch, arg1, container->contains );
          if ( obj == NULL )
          {
             act( "I see nothing like that in the $T.",
                 ch, NULL, arg2, TO_CHAR ,FALSE);
             return;
          }
          if (  obj->item_type != ITEM_GEM 
             && obj->item_type != ITEM_JEWELRY
	     && obj->item_type != ITEM_PILL 
             && obj->item_type != ITEM_COMPONENT
	     && obj->item_type != ITEM_KEY 
             && obj->item_type != ITEM_TREASURE
	     && obj->item_type != ITEM_SCROLL 
             && obj->item_type != ITEM_WAND
	     && obj->item_type != ITEM_STAFF 
             && obj->item_type != ITEM_POTION
	     && obj->item_type != ITEM_TRAP 
             && obj->item_type != ITEM_GRENADE 
	     && obj->item_type != ITEM_MONEY 
             && obj->item_type != ITEM_TRASH
	     && obj->item_type != ITEM_CONTAINER 
             && !can_loot(ch,container,FALSE) )
          {
             /* Decriment the corpse lootable counter */
             if(container->value[4] > 0)
	     {
	        container->value[4]--;
	     }
             else
             {
	        send_to_char("This one has been picked clean already.\n\r",ch);
	        return;
	     }
          }
	
          /* found something to grab, lag'em a bit */
          WAIT_STATE( ch, 12);
          get_obj( ch, obj, container );
       }
       else 
       {  
          /* 'get all container' or 'get all.obj container' */
          found = FALSE;
          for ( obj = container->contains; obj != NULL; obj = obj_next )
          {
             obj_next = obj->next_content;
             if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
                   &&   can_see_obj( ch, obj ) )
             {
                found = TRUE;
                if( (container->pIndexData->vnum == OBJ_VNUM_PIT
                        &&  !IS_IMMORTAL(ch))
	             || (!can_loot(ch,container,FALSE)
	                && !IS_IMMORTAL(ch)) )
                {
                   send_to_char("Don't be so greedy!\n\r",ch);
                   return;
                }
                get_obj( ch, obj, container );
             }
          }
      
          if ( !found )
          {
             if ( arg1[3] == '\0' )
                act( "I see nothing in the $T.",
                   ch, NULL, arg2, TO_CHAR ,FALSE);
             else
                act( "I see nothing like that in the $T.",
                   ch, NULL, arg2, TO_CHAR ,FALSE);
          }
       }   
    }
    
    return;
}


//#ifdef COREYCODE
void do_sharpen( CHAR_DATA *ch, char *argument )
{ //start of do sharpen
    AFFECT_DATA af;
    int skill,save_it;
    //OBJ_DATA obj;
    OBJ_DATA *obj,*stone;


    char arg1[MAX_INPUT_LENGTH];


    argument = one_argument( argument, arg1 );

    if ((skill = get_skill(ch,gsn_sharpen)) < 1)
    {
        send_to_char("No, this skill will not let you sharpen your wits, much less your weapon.\n\r",ch);
        return;
    }
    if ( ( arg1[0] == '\0' ) )
    {
  send_to_char( "Syntax for sharpen is: sharpen <weapon> \n\r", ch );
  return;
    }

if ( ( obj = get_obj_carry( ch, arg1 ) ) == NULL )
{
  send_to_char("You do not have that item.\r\n",ch);
  return;
}

    if ( obj->item_type != ITEM_WEAPON  )
    {
        send_to_char("That is not a weapon.\n\r",ch);
        return;
    }

    stone = get_eq_char(ch,WEAR_HOLD);
    if (stone == NULL || stone->item_type != ITEM_WARP_STONE)
    {
  send_to_char("You lack the proper type of stone to sharpen this weapon.\n\r",ch);
  return;
    }

  switch (obj->value[0])
  {
      case(WEAPON_EXOTIC) : send_to_char("You may not sharpen that.\n\r",ch); return;break;
      case(WEAPON_MACE)   : send_to_char("You may not sharpen that mace/club.\n\r",ch);return;  break;
      case(WEAPON_WHIP) : send_to_char("You may not sharpen that whip.\n\r",ch);return;   break;
      case(WEAPON_GAROTTE): send_to_char("You may not sharpen that garotte.\n\r",ch);return;  break;
      default: break;
  }


    if (IS_WEAPON_STAT(obj,WEAPON_SHARP))
    {
       send_to_char("This weapon can not be made any sharper..\n\r",ch);
       return;
    }

    if (stone != NULL && stone->item_type == ITEM_WARP_STONE)
    {
      act("You draw upon the power of $p.",ch,stone,NULL,TO_CHAR,FALSE);
      act("It flares brightly and vanishes!",ch,stone,NULL,TO_CHAR,FALSE);
      extract_obj(stone);
    }
    if ( get_skill(ch,gsn_sharpen)*9/10 > number_percent() )
    {
      send_to_char("You apply a fine edge to the weapon.\r\n",ch);
      check_improve(ch,gsn_sharpen,TRUE,2);
 
            af.where     = TO_WEAPON;
            af.type      = gsn_sharpen;
            af.level     = ch->level;
            if ( (number_percent() < get_skill(ch,gsn_sharpen)/10 + ch->level/10)
	    && ch->level >= 40 )
      	    {
		send_to_char("{YWHOA!{x Now {RTHAT'S{x a fine edge!!!\r\n",ch);
  		af.duration = -1;
	    }
	    else
	    {
            	af.duration  = 30 + ch->level/3;
	    }
            af.location  = 0;
            af.modifier  = 0;
            af.bitvector = WEAPON_SHARP;
            affect_to_obj(obj,&af);
   
	save_it = ch->level;
        save_it = URANGE(5,save_it, 100);

    }
    else
    {
      send_to_char("You fail to sharpen the weapon.\r\n",ch);
    check_improve(ch,gsn_sharpen,FALSE,2);
      if ( number_percent() > ch->level + (get_skill(ch,gsn_sharpen) / 3) )
      {
        if ( number_percent() < number_range(1,ch->level/5) )
        {
          SET_BIT( obj->value[4], WEAPON_VORPAL );
          act("ACK!  What's happened to $p ??? ",ch,obj,NULL,TO_ROOM,FALSE);
          act("ACK!  What's happened to $p ??? ",ch,obj,NULL,TO_CHAR,FALSE); 
        }
	else
	{
          act("Whoops! There's a horrible sound as $p shatters into many many pieces!",ch,obj,NULL,TO_ROOM,FALSE);
          act("Whoops! There's a horrible sound as $p shatters into many many pieces!",ch,obj,NULL,TO_CHAR,FALSE);
          extract_obj(obj);
	}
      }
    }
return;

}//end of do sharpen
//#endif

@


1.413
log
@No timer on items sold to special shopkeeper MOBs meant to replace pits.
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: act_obj.c,v 1.412 2004/06/21 20:06:55 boogums Exp $";
d5575 1
a5575 1
      if(keeper->in_room->clan && keeper->in_room->clan == ch->clan)
@


1.412
log
@ok tweaking with vampiric touch and vorpaling sharpen fails
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: act_obj.c,v 1.411 2004/06/19 14:22:45 boogums Exp $";
d5574 3
a5576 1
      obj->timer = number_range(50,100);
@


1.411
log
@tweaking steal a bit
corey
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: act_obj.c,v 1.410 2004/06/19 03:52:16 boogums Exp $";
d6336 12
a6347 3
      act("Whoops! There's a horrible sound as $p shatters into many many pieces!",ch,obj,NULL,TO_ROOM,FALSE);
      act("Whoops! There's a horrible sound as $p shatters into many many pieces!",ch,obj,NULL,TO_CHAR,FALSE);
      extract_obj(obj);
@


1.410
log
@tweaking steal
corey
@
text
@d19 1
a19 1
static char rcsid[] = "$Id: act_obj.c,v 1.409 2004/06/19 03:50:30 boogums Exp $";
d4648 1
a4648 1
       percent += ( ( get_curr_stat(victim,STAT_DEX) + get_curr_stat(victim,STAT_AGT) ) - ( get_curr_stat(ch,STAT_DEX) + get_curr_stat(ch,STAT_DEX)) ) *2;
d4659 1
a4659 1
           percent += 25;
@


1.409
log
@tweaking steal
@
text
@d18 2
a19 1
static char rcsid[] = "$Id: act_obj.c,v 1.408 2004/04/27 00:30:25 boogums Exp $";
@


1.408
log
@thanks for catching this for me Rusty
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.407 2004/04/26 02:25:09 boogums Exp $";
d4647 1
a4647 1
       percent += (get_curr_stat(victim,STAT_DEX) - get_curr_stat(ch,STAT_DEX)) *2;
d4652 11
@


1.407
log
@stuff and things
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.406 2004/04/25 01:28:24 boogums Exp $";
a4116 10
    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }
    if (IS_SET(ch->mhs, MHS_GLADIATOR) || IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("You are not permitted to snatch.\n\r",ch);
       return;
    }
a4118 9
    if ( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_HIDE))
    {
       REMOVE_BIT(ch->affected_by, AFF_HIDE);
    }
    if ( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_SNEAK))
    {
       REMOVE_BIT(ch->affected_by, AFF_SNEAK);
    }

d4141 25
@


1.406
log
@yadda yadda yadda
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.405 2004/04/25 01:09:44 boogums Exp $";
d57 6
a62 6
#define COST_ACCURACY	200
#define COST_SPEED	600
#define COST_MAGIC_RESISTANCE 	500
#define COST_VISION	100
#define COST_RESTORATION	50
#define COST_MOLOTOV	 50
@


1.405
log
@doh forgot the thing
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.404 2004/04/25 00:57:47 boogums Exp $";
d4216 1
a4216 1
    if (get_skill(ch,gsn_steal) > 1)
@


1.404
log
@ok lets try this
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.403 2004/04/25 00:32:04 boogums Exp $";
d4139 1
a4139 1
    if  (!IS_NPC(ch) && get_skill(ch, gsn_slice) < 2)
@


1.403
log
@banishment will cause a clanners guard to attack them
snatch added to the game
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.402 2004/04/22 03:41:43 boogums Exp $";
d4192 1
a4192 1
    if ( obj->item_type != ITEM_WEAR_FLOAT )
d4208 1
a4208 1
    WAIT_STATE( ch, skill_table[gsn_steal].beats) ;
a4308 1
    ||   IS_SET(obj->extra_flags, ITEM_INVENTORY)
@


1.402
log
@hmmmm honor thing
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.401 2004/04/22 03:35:30 boogums Exp $";
d4108 233
d4431 6
@


1.401
log
@honor demise thief check
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.400 2004/01/26 00:00:21 boogums Exp $";
d4487 5
a4491 5
                  ||
                  (
                  ch->clan != clan_lookup("honor") &&
                  victim->clan != clan_lookup("demise")
                  )
@


1.400
log
@putting farsee back in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.399 2004/01/12 02:34:34 boogums Exp $";
a4480 12
             if (victim->clan == clan_lookup("warlock")
               	&& !IS_SET(ch->mhs,MHS_WARLOCK_ENEMY))
                SET_BIT(ch->mhs,MHS_WARLOCK_ENEMY);
             if (victim->clan == clan_lookup("posse")
               	&& !IS_SET(ch->mhs,MHS_POSSE_ENEMY))
                SET_BIT(ch->mhs,MHS_POSSE_ENEMY);
             if (victim->clan == clan_lookup("zealot")
               	&& !IS_SET(ch->mhs,MHS_ZEALOT_ENEMY))
                SET_BIT(ch->mhs,MHS_ZEALOT_ENEMY);
             if (victim->clan == clan_lookup("honor")
               	&& !IS_SET(ch->mhs,MHS_HONOR_ENEMY))
                SET_BIT(ch->mhs,MHS_HONOR_ENEMY);
d4484 1
a4484 1
		  !IS_SET(ch->act, PLR_THIEF) && 
d4486 6
a4493 5
	     	if (
               	  ch->clan != clan_lookup("honor") &&
                  victim->clan != clan_lookup("demise")
		)
		{
a4499 1
		}
@


1.399
log
@testing out the holy oil thing
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.398 2004/01/11 22:20:52 boogums Exp $";
d5497 1
a5497 1
  if ( brick_count >=5 )
d5499 1
a5499 2
    send_to_char("The Almighty bestows a vial of his Holy Oil upon you.\n\r", ch );
    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
d5501 5
a5505 1
      obj_next = obj->next_content;
d5507 5
a5511 4
      if ( obj->pIndexData->vnum == OBJ_VNUM_PLAT_BRICK && taken_bricks < 5)
      {
        extract_obj(obj);
        taken_bricks++;
d5513 5
a5518 1
    obj_to_char(create_object(get_obj_index(OBJ_VNUM_HOLY_OIL),0,FALSE),ch);
a5519 4
  else
  {
    send_to_char("You do not have enough beautiful platinum bricks.  You must have a sacrifice of at least five. \n\r", ch );
  }
@


1.398
log
@testing new function
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.397 2004/01/11 22:07:29 boogums Exp $";
d5482 1
a5487 2


d5499 12
a5510 1
    send_to_char("You have enough beautiful platinum bricks.\n\r", ch );
d5514 1
a5514 1
    send_to_char("You do not have enough beautiful platinum bricks.\n\r", ch );
@


1.397
log
@trying something new
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.396 2003/12/01 01:51:44 boogums Exp $";
d5477 1
a5477 1
void do_get_voucher ( CHAR_DATA *ch, char *argument )
d5491 1
@


1.396
log
@spelling correction
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.395 2003/11/29 23:15:36 boogums Exp $";
d5475 32
@


1.395
log
@yanking the copyspell command replacing with study
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.394 2003/11/28 00:43:27 boogums Exp $";
d234 1
a234 1
      send_to_char("You must be on concerated ground to endow.\r\n",ch);
@


1.394
log
@ok i got it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.393 2003/11/28 00:41:25 boogums Exp $";
d5731 1
a5731 1
	send_to_char("You must be in a Magelab to copy scrolls.\n\r",ch);
d5744 1
a5744 1
	send_to_char("This scroll has been worn out beyond readability.\n\r",ch);
@


1.393
log
@dgrrrr
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.392 2003/11/28 00:37:11 boogums Exp $";
d243 5
@


1.392
log
@damn it
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.391 2003/11/28 00:13:52 boogums Exp $";
d205 1
a205 1
  int spellNumber;
d237 3
a239 3
  if ( spellNumber = find_spell(ch, arg1) < 0
  || (!IS_NPC(ch) && ch->level < skill_level(ch, spellNumber))
  || (ch->pcdata->learned[spellNumber] == 0) )
d244 1
a244 1
  if ( skill_table[spellNumber].bitvector & SS_STAFF )
d290 1
a290 1
    spellLevel= compute_casting_level( ch, spellNumber );
d295 1
a295 1
    staffLevel = skill_level(ch,spellNumber);
d298 1
a298 1
    strcat (staffName, skill_table[spellNumber].name);
d305 1
a305 1
    strcat (staffName, skill_table[spellNumber].name);
d313 1
a313 1
    staff->value[3] = spellNumber;
@


1.391
log
@ok it's in finally
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.390 2003/11/27 23:09:07 boogums Exp $";
d201 2
a202 2
  char spellArg[MAX_INPUT_LENGTH];
  char staffArg[MAX_INPUT_LENGTH];
d210 2
a211 2
  argument = one_argument(argument, spellArg); 
  argument = one_argument(argument, staffArg);
d218 1
a218 1
  if (  spellArg[0] == '\0' || staffArg[0] == '\0' )
d237 1
a237 1
  if ( spellNumber = find_spell(ch, spellArg) < 0
d253 1
a253 1
  if ( ( staff = get_obj_carry( ch, staffArg ) ) == NULL )
@


1.390
log
@adding staff crafter kit
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.389 2003/11/22 15:29:40 boogums Exp $";
d213 1
a213 1
  if( get_skill(ch,gsn_infuse) == 0 )
d296 1
a296 1
    check_improve(ch,gsn_infuse,TRUE,2);
d317 1
a317 1
    send_to_char("{YCRACK{x!  You infuse the staff with your god's mojo!\r\n",ch);
d323 1
a323 1
    check_improve(ch,gsn_infuse,FALSE,4);
@


1.389
log
@t tweaking vamp/nether
also makde scribed scrolls harder to recite
bogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.388 2003/11/22 03:34:19 boogums Exp $";
d199 133
a333 1

a335 1

a339 1

a342 1

a343 1

a345 1

a349 2


a366 2


d490 1
a490 1
             wand->value[1] = charges;
@


1.388
log
@doing random stuff.  infuse bug, and wiping out honor skill
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.387 2003/09/20 22:23:58 boogums Exp $";
d3719 1
a3719 1
            smod = 10;
@


1.387
log
@stupid thief check
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.386 2003/09/20 18:18:58 boogums Exp $";
d272 6
d282 1
a282 1
                        percent -= 10;
d286 1
a286 1
                        percent -= 5 ;
d290 1
a290 1
                        percent += 0;
d316 61
a376 64
        if ( sn == skill_lookup("turn undead") )
        {
                spell_level2 -= 5;
        }
 		if ( number_percent() < 5 && number_percent() >= 1)
		{
                spell_level1 = skill_level(ch,sn);
                spell_level2 = spell_level;

                check_improve(ch,gsn_infuse,TRUE,2);

                sprintf (wand_name, "a wand of ");
                strcat (wand_name, "rasefseers");
                free_string( wand -> name );
                wand->name = str_dup(wand_name);
                free_string( wand->short_descr );
                wand->short_descr = str_dup(wand_name);
                free_string( wand->description );
                sprintf (wand_name, "A wand of ");
                strcat (wand_name, "rasefseers");
                strcat (wand_name, " lies here.\r\n");
                wand->description = str_dup(wand_name);
                wand->level = spell_level1;
                wand->cost = 0;
                wand->value[1] = charges;
                wand->value[0] = spell_level2;
                wand->value[2] = charges;
                wand->value[3] = skill_lookup("restrain");;
                wand->value[4] = -1;
                SET_BIT(wand->extra_flags,ITEM_NOIDENTIFY);
		SET_BIT(wand->extra_flags,ITEM_HUM);
                send_to_char("{YCRACK{x!  You infuse the wand with a special kind of mojo!\r\n",ch);
                act("$n grins evily as the piece of wood glows with a magical aura.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
		}
		else
		{
    		spell_level1 = skill_level(ch,sn);
                spell_level2 = spell_level;

                check_improve(ch,gsn_infuse,TRUE,2);

                sprintf (wand_name, "a wand of ");
                strcat (wand_name, skill_table[sn].name);
                free_string( wand -> name );
                wand->name = str_dup(wand_name);
                free_string( wand->short_descr );
                wand->short_descr = str_dup(wand_name);
                free_string( wand->description );
                sprintf (wand_name, "A wand of ");
                strcat (wand_name, skill_table[sn].name);
                strcat (wand_name, " lies here.\r\n");
                wand->description = str_dup(wand_name);
                wand->level = spell_level1;
                wand->cost = 0;
                wand->value[1] = charges;
                wand->value[0] = spell_level2;
                wand->value[2] = charges;
                wand->value[3] = sn;
                wand->value[4] = -1;
                SET_BIT(wand->extra_flags,ITEM_NOIDENTIFY);
		SET_BIT(wand->extra_flags,ITEM_GLOW);
                send_to_char("{YCRACK{x!  You infuse the wand with your mojo!\r\n",ch);
                act("$n grins evily as the piece of wood glows with a magical aura.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
		}
@


1.386
log
@honor vs demise steal fix
various kit chagnes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.385 2003/08/16 02:56:26 boogums Exp $";
d4370 1
a4370 1
               	  ch->clan == clan_lookup("honor") &&
@


1.385
log
@doh damn steal change
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.384 2003/08/09 18:31:47 boogums Exp $";
d4365 2
a4366 8
		  (!IS_SET(ch->act, PLR_THIEF) && 
                  !IS_SET(victim->act, PLR_THIEF)) 
		  || 
		  (
		   ch->clan == clan_lookup("honor") &&
		   victim->clan != clan_lookup("demise")
		  )
		
d4369 12
a4380 6
                SET_BIT(ch->act, PLR_THIEF);
                send_to_char( "*** You are now a THIEF!! ***\n\r", ch );
                sprintf(buf,"%s got THIEF on %s in room %d",ch->name,
		victim->name,ch->in_room->vnum);
                log_string(buf);
                save_char_obj( ch );
@


1.384
log
@t makding it so honors can steal from demise with no risk of getting a
thief flag
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.383 2003/07/08 15:04:17 rusty Exp $";
d4367 1
a4367 1
		  ||
d4369 1
a4369 1
		   ch->clan != clan_lookup("honor") &&
@


1.383
log
@Someone commented out the refillable grails no-no check.
Don't do that shit!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.382 2003/06/14 19:53:09 boogums Exp $";
d4362 1
d4364 10
a4373 2
             if ( !IS_SET(ch->act, PLR_THIEF) && 
                  !IS_SET(victim->act, PLR_THIEF) )
@


1.382
log
@adding the restrain spell to the infuse ability
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.381 2003/06/03 03:13:07 boogums Exp $";
d2362 1
a2362 2
/*    if ( obj->item_type != ITEM_DRINK_CON  || obj->pIndexData->vnum == OBJ_VNUM_GRAIL)*/
      if ( obj->item_type != ITEM_DRINK_CON )
@


1.381
log
@ok this'll yank confusion and aura of cthon
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.380 2003/05/30 02:23:04 ndagger Exp $";
d312 1
a312 1
                spell_level2 -= 15;
d314 6
d321 25
d373 1
@


1.380
log
@05/29/03 Nightdagger:  All clan skills nerfed to prepare for new ones.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.379 2003/05/24 00:55:25 boogums Exp $";
d568 1
a568 1
                                scroll->value[2] = skill_lookup("giant strength");
@


1.379
log
@done deal
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.378 2003/05/24 00:48:19 boogums Exp $";
d4054 2
d4060 2
d4219 1
d4228 1
d4230 1
@


1.378
log
@fixing promise ring bug
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.377 2003/05/19 03:32:09 ndagger Exp $";
d2966 1
a2966 1
       send_to_char("That item is no longer allowed.  See an IMM and get an egg for it.\r\n",ch);
@


1.377
log
@05/18/03 Nightdagger:  Fixed an oversight with pray speed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.376 2003/05/19 03:20:34 ndagger Exp $";
d2964 6
@


1.376
log
@05/18/03 Nightdagger:  Fixed speed stacking bug.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.375 2003/05/08 03:13:39 boogums Exp $";
d4209 1
a4209 1
    if(!IS_NPC(ch) && ch->clan == clan_lookup("avarice") && !IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1) && !is_affected(ch,  skill_lookup("speed")) )
@


1.375
log
@fill grail bug filxed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.374 2003/05/06 00:48:00 boogums Exp $";
d4209 1
a4209 1
    if(!IS_NPC(ch) && ch->clan == clan_lookup("avarice") && !IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1))
@


1.374
log
@no longer able to fill holy grails
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.373 2003/04/08 01:29:45 ndagger Exp $";
d2439 6
@


1.373
log
@04/07/03 Nightdagger:  Disabled loot counter for PK looting.  FULL LOOT!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.372 2003/03/23 21:09:46 boogums Exp $";
d2330 2
a2331 1
    if ( obj->item_type != ITEM_DRINK_CON  || obj->pIndexData->vnum == OBJ_VNUM_GRAIL)
@


1.372
log
@added message to perma sharp
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.371 2003/03/23 18:43:57 boogums Exp $";
d1140 2
a1150 1
        /* Decriment the corpse lootable counter */
d1162 1
a1162 1
	
@


1.371
log
@tweaked sharpen code
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.370 2003/01/03 19:41:52 boogums Exp $";
d5831 1
@


1.370
log
@3jan02
making turn undead wands less effective
making dispel magic scrolls less effective
making precious pab flag white for the blind players we have
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.369 2002/12/05 16:21:46 boogums Exp $";
d5828 9
a5836 1
            af.duration  = 30 + ch->level/3;
d5850 1
a5850 1
      if ( number_percent() > ch->level + (get_skill(ch,gsn_sharpen) / 4) )
@


1.369
log
@ok this thosu get it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.368 2002/12/05 16:12:25 boogums Exp $";
d310 5
d513 4
d546 1
a546 1
                if (way_cool_spell <= 10)
@


1.368
log
@nasty bug in get_cost dealing with wands and stuff have to exclude
kit wands and staves
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.367 2002/12/05 15:44:51 boogums Exp $";
d4588 6
a4593 4
    if ( (obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND) &&
         (obj->pIndexData->vnum != 8147 ||
          obj->pIndexData->vnum != 3141 ||
          obj->pIndexData->vnum != 3128
a4594 3
       )
    {
       if (obj->value[1] == 0)
d4596 3
a4598 3
          cost /= 4;
       }
       else
d4600 9
a4608 1
          cost = cost * obj->value[2] / obj->value[1];
@


1.367
log
@fixing haggle bug
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.366 2002/12/05 06:33:33 boogums Exp $";
d4588 6
a4593 1
    if ( obj->item_type == ITEM_STAFF || obj->item_type == ITEM_WAND )
@


1.366
log
@got it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.365 2002/12/05 06:20:36 boogums Exp $";
d4608 2
a4609 1
    int cost,roll;
d5013 2
a5014 1
    int cost,roll;
@


1.365
log
@bug sqashd
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.364 2002/12/05 06:12:23 boogums Exp $";
d218 2
a219 1
    if( skill_level(ch,gsn_infuse) <= 0 )
d341 1
a341 1
                check_improve(ch,gsn_scribe,FALSE,4);
@


1.364
log
@damn it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.363 2002/12/05 06:06:01 boogums Exp $";
d218 1
a218 1
    if( ch->level < skill_level(ch,gsn_infuse) )
@


1.363
log
@t one last infuse check
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.362 2002/12/05 05:52:06 boogums Exp $";
d218 1
a218 2
   if ( !IS_NPC(ch)
    &&   ch->level < skill_level(ch,gsn_infuse) )
@


1.362
log
@ok making wand made wands harder to cast
turned the kit on
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.361 2002/12/05 05:16:56 boogums Exp $";
d218 6
@


1.361
log
@ok here goes the wand maker kit
and removing damage from pof while in wraith
*gulp* i hate messing with merc.h
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.360 2002/12/02 18:49:36 boogums Exp $";
d273 1
a273 1
			charges = number_range(2,5);
d277 1
a277 1
			charges = number_range(3,6);
d281 1
a281 1
			charges = number_range(4,8);
d285 1
a285 1
			charges = number_range(5,10);
d3829 9
@


1.360
log
@t boost to the casting level
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.359 2002/12/02 18:36:17 boogums Exp $";
d149 1
a149 1
    WAIT_STATE( ch, PULSE_PER_SECOND * 10 );
d198 1
a198 1
#ifdef COREY_TEST
a203 1
    char arg3[MAX_INPUT_LENGTH];
d208 1
a208 1
        int new_sn_percent;
d250 2
a251 1
    switch ( skill_table[sn].bitvector )
d253 1
a253 5
    default:
      send_to_char("You may not put that spell on a scroll.\r\n",ch);
      return;
    case SS_WAND:
      break;
d255 1
a255 1
    if ( ( wand = get_obj_carry( ch, arg2 ) ) == NULL )
d257 1
a257 1
        send_to_char( "You do not have that wand.\n\r", ch );
d261 1
a261 2
    spell_level = compute_casting_level( ch, sn );
    if (spell_level >= 52)
d263 2
a264 1
        spell_level = 51;
a265 4
    spell_level1 = skill_level(ch,sn)

        percent = ( (get_skill(ch,gsn_infuse)*8) / 10 ) ;

d269 2
a270 1
                        percent -= 15;
d273 2
a274 1
                        percent -= 0 ;
d277 2
a278 1
                        percent += 5;
d281 2
a282 1
                        percent += 10;
d285 2
a286 1
                        percent += 20;
d293 48
d342 1
a342 1
#endif
@


1.359
log
@ok for got to go bitwise on the check
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.358 2002/12/02 05:24:17 boogums Exp $";
a366 11
/*
      switch ( skill_table[sn].bitvector )
      {
      default:
		send_to_char("You may not put that spell on a scroll.\r\n",ch);
		return;
      case SS_SCRIBE: 
      		break;
      }
*/

d384 1
a384 1
    if (spell_level >= 52)
d386 1
a386 1
	spell_level = 51;
@


1.358
log
@turning off weather messages if brief room is togled on
more code wrapped in the wand kit
spells adjusted to be wandable and not
luria's message added to fight.c
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.357 2002/11/26 09:01:45 ndagger Exp $";
d357 11
a367 1

a372 1

d376 1
a376 1

@


1.357
log
@11/26/02 Nightdagger:  Steal now checks pkill login delay.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.356 2002/11/22 06:29:16 ndagger Exp $";
d198 3
d202 96
d488 1
a488 1
                if (way_cool_spell <= 20)
@


1.356
log
@11/22/02 Nightdagger:  Steal now checks Avarice skill sanction for reduced lag.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.355 2002/10/21 04:31:23 boogums Exp $";
d3975 7
@


1.355
log
@final tweak to sharpe
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.354 2002/10/21 03:55:22 boogums Exp $";
d4028 1
a4028 1
    if(!IS_NPC(ch) && ch->clan == clan_lookup("avarice"))
@


1.354
log
@ok sharpen's going in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.353 2002/10/21 02:55:35 boogums Exp $";
d5641 1
a5641 1
            af.duration  = 50 + ch->level/3;
d5655 1
a5655 1
      if ( number_percent() > number_percent() + (ch->level *8 /10) )
@


1.353
log
@fucking logic
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.352 2002/10/21 02:47:20 boogums Exp $";
d5571 1
a5571 1
    int percent,skill,save_it;
d5614 3
a5616 3
      case(WEAPON_MACE)   : send_to_char("You may not sharpen that. mace/club.\n\r",ch);return;  break;
      case(WEAPON_WHIP) : send_to_char("You may not sharpen that.whip.\n\r",ch);return;   break;
      case(WEAPON_GAROTTE): send_to_char("You may not sharpen that.garotte.\n\r",ch);return;  break;
a5626 2
//    percent = URANGE(5,percent,100);

d5655 1
a5655 1
      if ( number_percent() > number_percent() + ch->level )
@


1.352
log
@adding new skills is such a bitch
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.351 2002/10/21 02:40:27 boogums Exp $";
d5635 1
a5635 1
    if ( get_skill(ch,gsn_sharpen)*9/10 < number_percent() )
d5657 1
a5657 1
      if ( number_percent() > number_percent() )
d5660 1
@


1.351
log
@oik lets try this
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.350 2002/10/21 02:24:54 boogums Exp $";
d5635 1
a5635 1
    if ( (get_skill(ch,gsn_sharpen)*9/10) < number_percent() )
d5655 1
a5655 1
//they fail
d5657 1
a5657 1
      if ( number_percent() - save_it > number_percent()+get_skill(ch,gsn_sharpen) )
@


1.350
log
@im a doofun
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.349 2002/10/21 02:18:00 boogums Exp $";
d5594 1
a5594 1
  send_to_char("You do not hav that item.\r\n",ch);
d5605 1
a5605 2
    if (!IS_IMMORTAL(ch)
    &&  (stone == NULL || stone->item_type != ITEM_WARP_STONE))
d5607 1
a5607 1
  send_to_char("You lack the proper type of stone to sharpen this object.\n\r",ch);
@


1.349
log
@i really ahte this fucking skill
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.348 2002/10/21 01:52:04 boogums Exp $";
d5618 1
a5618 1
      default   :return; break;
@


1.348
log
@i hate this fucking skill
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.347 2002/10/21 01:38:46 boogums Exp $";
a5569 2
    OBJ_DATA *obj;
    OBJ_DATA *stone;
d5572 3
a5576 1
    char arg2[MAX_INPUT_LENGTH];
a5579 1
    argument = one_argument( argument, arg2 );
d5586 1
a5586 1
    if ( ( arg1[0] == '\0' ) || ( arg2[0] == '\0' ) )
d5588 1
a5588 1
  send_to_char( "Syntax for sharpen is: sharpen <weapon> <whetstone-used>\n\r", ch );
d5591 4
a5594 10
  if ( obj = get_obj_carry( ch, arg1 ) == NULL )
  {
   send_to_char("You do not have that object.\r\n",ch);
    return;
  }
    stone = get_eq_char(ch,WEAR_HOLD);
    if (!IS_IMMORTAL(ch)
    &&  (stone == NULL || stone->item_type != ITEM_WARP_STONE))
    {
  send_to_char("You lack the proper type of stone to sharpen this object..\n\r",ch);
d5596 1
a5596 2
    }

d5600 1
a5600 1
        send_to_char("That's not a weapon.\n\r",ch);
d5604 7
@


1.347
log
@ok trying sharpen again
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.346 2002/10/21 01:08:38 boogums Exp $";
d5597 3
a5599 8

  if ( stone = get_obj_carry( ch, arg2 ) == NULL )
  {
    send_to_char("You do not have that whetstone.\r\n",ch);
    return;
  }
   
  if ( stone->pIndexData->vnum != OBJ_VNUM_WHETSTONE ) 
d5601 2
a5602 2
      send_to_char("You do not have the correct whetstone.\r\n",ch);
      return;
a5604 5
    if (obj == NULL)
    {
        send_to_char("You don't have that weapon.\n\r",ch);
        return;
    }
d5630 7
a5653 6
      if ( number_percent() > get_skill(ch,gsn_sharpen)*9/10 )
      {
        act("Your whetstone shatters in two!",ch,obj,NULL,TO_CHAR,FALSE);
        act("Your whetstone shatters in two!",ch,obj,NULL,TO_ROOM,FALSE);
        extract_obj(stone);
      }
a5660 1
      act("Whoops! There's a horrible sound as $p shatters into many many pieces!",ch,obj,NULL,TO_CHAR,FALSE);
a5662 1
      extract_obj(stone);
@


1.346
log
@taking sharp out can't think straight when bear in the big blue house
is playing
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.345 2002/10/21 00:24:51 boogums Exp $";
d5567 1
a5567 1
#ifdef COREYCODE
d5592 5
d5598 7
a5604 4
    obj =  get_obj_carry(ch,arg1);
    stone = get_obj_carry(ch,arg2);
    
    if(stone->pIndexData->vnum != OBJ_VNUM_WHETSTONE)
d5679 1
a5679 1
#endif
@


1.345
log
@i'm such a dumbass sometimes
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.344 2002/10/21 00:04:51 boogums Exp $";
d5567 1
a5567 1
//#ifdef COREYCODE
d5604 1
a5604 1
        send_to_char("You don't have that item.\n\r",ch);
d5671 1
a5671 1
//#endif
@


1.344
log
@try this one
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.343 2002/10/20 23:43:30 boogums Exp $";
d5593 2
a5594 2
    obj =  get_obj_list(ch,arg1,ch->carrying);
    stone = get_obj_list(ch,arg2,ch->carrying);
@


1.343
log
@ok another test go round of sharpen
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.342 2002/10/20 00:46:27 boogums Exp $";
d5634 1
@


1.342
log
@ahhh effects.c touched that's right
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.341 2002/10/18 14:31:39 boogums Exp $";
d5565 3
a5567 1
#ifdef COREYCODE
d5621 1
a5621 1
      default   : break;
d5634 10
a5643 11
      check_improve(ch,gsn_scribe,TRUE,2);


    af.where            = TO_WEAPON;
    af.type             = 0;
    af.level            = 0;
    af.duration         = obj->value[4] == 0 ? ch->level * 4 / 3 : ch->level * 3 / 4;
    af.location         = 0;
    af.modifier         = 0;
    af.bitvector        = WEAPON_SHARP;
    affect_to_obj( obj, &af );
d5645 1
a5645 1
	save_it = number_percent() - ch->level;
d5648 1
a5648 1
      if ( number_percent() < save_it )
d5658 3
a5660 1
    check_improve(ch,gsn_scribe,FALSE,2);
d5665 1
d5670 1
a5670 1
#endif
@


1.341
log
@turning bount offy again
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.340 2002/10/13 21:22:40 boogums Exp $";
d3814 7
@


1.340
log
@making dwarves use wands and staves less better
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.339 2002/10/13 03:28:49 boogums Exp $";
d364 1
a364 1
		spell_level2=spell_level*.9;
@


1.339
log
@ok sharpen breaks the game, examining why
corey
until then taking out
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.338 2002/10/13 02:55:43 boogums Exp $";
d3551 8
d3593 1
a3593 1
  ||   number_percent() >= 20 + get_skill(ch,gsn_staves) * 4/5)
d3654 8
a3661 1

d3739 1
d3741 1
a3741 1
  ||  number_percent() >= 20 + get_skill(ch,gsn_wands) * 4/5) 
@


1.338
log
@sharpen skilll for dwarves going in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.337 2002/10/10 03:13:19 boogums Exp $";
d5542 1
a5542 1
//#ifdef COREYCODE
d5643 1
a5643 1
//#endif
@


1.337
log
@actobj interep.h merc.h wait oh shit gotta ocmment those out
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.336 2002/09/26 22:29:49 boogums Exp $";
d5542 1
a5542 1
#ifdef COREYCODE
d5546 1
d5548 8
a5555 3
    int percent,skill;
    char arg[MAX_INPUT_LENGTH];
    argument = one_argument(argument, arg);
d5562 5
d5568 8
a5575 1
    obj =  get_obj_list(ch,argument,ch->carrying);
d5577 1
a5577 1
    if (obj== NULL)
d5606 5
d5613 3
a5615 3
    af.type             = sn;
    af.level            = level;
    af.duration         = obj->value[4] == 0 ? level / 3 : level / 6;
d5620 3
d5624 17
a5640 1

d5643 1
a5643 1
#endif
@


1.336
log
@t ok trying a different method
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.335 2002/09/26 22:23:37 boogums Exp $";
d5542 61
@


1.335
log
@fixing haggle bug
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.334 2002/09/26 04:24:02 boogums Exp $";
d4502 1
a4502 1
  roll = UMIN(26,number_percent() );
d4650 1
a4650 1
  roll = UMIN(26,number_percent() );
d4897 1
a4897 1
    roll = UMIN(26,number_percent() );
@


1.334
log
@tweaking haggle a bit, making the social stat play into it
corey

CVSk: ----------------------------------------------------------------------
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.333 2002/09/10 16:55:49 mud Exp $";
d4502 1
a4502 1
  roll = number_percent();
d4650 1
a4650 1
  roll = number_percent();
d4897 1
a4897 1
    roll = number_percent();
@


1.333
log
@Make sure a pc corpse->owner is not NULL before doing an is_name()
check on it.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.332 2002/06/20 15:54:59 rusty Exp $";
d4503 1
a4503 1
  if (roll < get_skill(ch,gsn_haggle))
d4652 1
a4652 1
  && roll < get_skill(ch,gsn_haggle))
d4899 1
a4899 1
    if (!IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT) && roll < get_skill(ch,gsn_haggle))
@


1.332
log
@Some bug fixes from off the net.
new_note() used for loading the note spools.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.331 2002/05/22 19:20:57 mud Exp $";
d1219 1
a1219 1
	if (!is_name(container->owner,ch->name))
@


1.331
log
@s/obj/container/  D'oh!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.330 2002/05/22 19:10:27 rusty Exp $";
d1408 1
a1408 1
      &&   get_obj_weight(obj) < (container->value[3] * 10)) && container->item_type == ITEM_CONTAINER)
@


1.330
log
@Can use 'get all corpse' on your own corpse
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.329 2002/05/22 18:00:40 rusty Exp $";
d1219 1
a1219 1
	if (!is_name(obj->owner,ch->name))
@


1.329
log
@All gems end up in corpses.
All items stolen within the last 10*number_fuzzy(5) ticks go into corpses.
Items taken by steal, loot, heat metal and disarm get timers
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.328 2002/05/21 20:20:58 rage Exp $";
d1219 6
a1224 2
        send_to_char( "Use 'loot'.\n\r", ch );
        return;
@


1.328
log
@dropped potion costs for alchemy
added randomly teleporting portal for Slodhain area
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.327 2002/05/04 16:50:53 boogums Exp $";
a937 7
    /*20may01 - Added a wraithform check Boogums */
    if( is_affected(ch,skill_lookup("wraithform")) )
    {
        send_to_char( "You cannot loot while in wraithform.\r\n", ch);
        return;
    }

d1008 1
d1030 1
d4195 1
@


1.327
log
@MENTAL NOTE:  you can't buy stuff wizi *whap self*
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.326 2002/05/04 16:40:53 boogums Exp $";
d57 1
a57 1
#define COST_ACCURACY	400
d59 3
a61 3
#define COST_MAGIC_RESISTANCE 	1000
#define COST_VISION	200
#define COST_RESTORATION	100
@


1.326
log
@backing out changes thinking of stuff to do later
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.325 2002/05/04 16:37:06 boogums Exp $";
d4272 1
a4272 1
   if ( !can_see( keeper, ch, FALSE )  )
@


1.325
log
@doh
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.324 2002/05/04 16:33:13 boogums Exp $";
a4273 4
    if ( ch->kit == kit_lookup("fence") )
    {
   	return keeper; 
    }
@


1.324
log
@stupid parens
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.323 2002/05/04 16:30:35 boogums Exp $";
d4272 1
a4272 1
   if ( (!can_see( keeper, ch, FALSE ) && ch->kit != kit_lookup("fence")) )
d4274 4
@


1.323
log
@mental note, don't code while hungover and watching
blues clues
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.322 2002/05/04 16:26:51 boogums Exp $";
d4272 1
a4272 1
   if ( !can_see( keeper, ch, FALSE ) && ch->kit != kit_lookup("fence") )
@


1.322
log
@i hate boolean logic
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.321 2002/05/04 16:23:06 boogums Exp $";
d4272 1
a4272 1
   if ( !can_see( keeper, ch, FALSE ) &! ch->kit==kit_lookup("fence") )
@


1.321
log
@damn boolean logic ;)
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.320 2002/05/04 16:16:44 boogums Exp $";
d4272 1
a4272 5
   if ( !can_see( keeper, ch, FALSE ) && ch->kit==kit_lookup("fence") )
    {
	return keeper;
    }
    else
@


1.320
log
@allowying hidden and invis ppl with fence kit to sell and buy at stores
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.319 2002/05/03 03:17:12 boogums Exp $";
d4272 5
a4276 1
   if ( !can_see( keeper, ch, FALSE ) )
a4277 4
    if ( ch->kit==kit_lookup("fence") )
	{
		return keeper;
	}
@


1.319
log
@had the wrong variable
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.318 2002/05/03 03:13:46 boogums Exp $";
d4272 1
a4272 1
    if ( !can_see( keeper, ch, FALSE ) )
d4274 4
@


1.318
log
@doh took it the wrong way
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.317 2002/05/03 02:58:58 boogums Exp $";
d364 1
a364 1
		spell_level2=spell_level1*.9;
@


1.317
log
@minor tweakings on the scribe kit
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.316 2002/04/24 02:38:08 boogums Exp $";
d364 1
a364 1
		spell_level2=spell_level1*3/4;
@


1.316
log
@adding spec_jabber
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.315 2002/04/05 15:24:27 boogums Exp $";
d363 3
a365 2
		spell_level2=(spell_level + spell_level1)/2;
		check_improve(ch,gsn_scribe,TRUE,3);
d389 1
a389 1
                if (way_cool_spell <= 10)
@


1.315
log
@5apr02
putting in the fence kit.  changes to do_sell in act_obj.c
the kit info in merc.h db.c and const.c
and a special.c change in spec_guard.  it checks to see
if the guard turns the other way cuz they're sooo cool
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.314 2002/04/01 21:48:06 rusty Exp $";
d4270 1
@


1.314
log
@No PNET_SACCING, too easy for pkillers
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.313 2002/04/01 21:05:43 rusty Exp $";
d4885 1
a4885 1
    /* haggle */
d4887 10
@


1.313
log
@Added pnet, wiznet like info for mortals
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.312 2002/01/26 16:25:27 rage Exp $";
a3376 1
    pnet("$N sacrifices $p as an offering.",ch,obj,PNET_SACCING,0,0);
@


1.312
log
@whole mess of bug fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.311 2001/12/13 17:52:42 poquah Exp $";
d3377 1
@


1.311
log
@smurfs cant steal, slice or cutpurse
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.310 2001/12/09 15:10:39 poquah Exp $";
d3334 1
a3334 1
          if (IS_SET(ch->mhs,MHS_FULL_SAC) && obj->contains)
@


1.310
log
@working out bug in death code with charmies
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.309 2001/12/05 16:39:00 poquah Exp $";
d3764 5
d3930 5
@


1.309
log
@new kr stats
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.308 2001/11/23 16:18:38 poquah Exp $";
d5379 140
@


1.308
log
@missing )
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.307 2001/11/23 16:17:15 poquah Exp $";
d3889 1
a3889 1
       if (!IS_NPC(victim)) ch->steal_data[PC_SLICES] += 1 ;
d4153 2
a4154 2
     ch->steal_data[PC_STOLEN_GOLD] += gold ;
     ch->steal_data[PC_STOLEN_SILVER] += silver ;
d4193 1
a4193 1
       ch->steal_data[PC_STOLEN_ITEMS] += 1 ;
@


1.307
log
@Newbie flag and code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.306 2001/11/15 03:10:32 poquah Exp $";
d645 1
a645 1
           || owner->clan != clan_lookup("newbie"))
@


1.306
log
@add full sac, able to sac containers with things in them
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.305 2001/11/10 19:13:42 rage Exp $";
d643 3
a645 1
     if (owner->clan != 0 && owner->clan != clan_lookup("matook"))
@


1.305
log
@bug fixes for spec_elemental_water
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.304 2001/11/10 18:38:24 rage Exp $";
d3328 10
@


1.304
log
@initial insertion of spec_water
added in healing for drinking from holy grail
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.303 2001/10/21 20:35:43 rage Exp $";
d2477 1
a2477 1
	ch->hit = UMAX(ch->max_hit, ch->hit+75);
@


1.303
log
@bug fix in assemble..if the part had no values, we kaboomed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.302 2001/10/13 02:11:59 rage Exp $";
d2170 1
a2170 1
    if ( obj->item_type != ITEM_DRINK_CON )
d2474 6
@


1.302
log
@Bug fixes as follow

can no longer drag furniture that's being used
steal/slice kr only increments on players
IMMs now immune to sector damage
die command should work now
spec_average now has an IS_AWAKE check
Cavalier attack is now given to groupmates
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.301 2001/08/20 20:14:55 boogums Exp $";
d4999 3
@


1.301
log
@fixing the "special scroll" spell order per Rusty
-boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.300 2001/08/13 22:17:58 boogums Exp $";
d3871 1
a3871 1
       ch->steal_data[PC_SLICES] += 1 ;
@


1.300
log
@minor tweakings on do_scribe
made it easier (10 percent chance) to make a "magical" scroll
also expanded on the bits set on the random scrolls
-Boogums
oh fixed the no gain thing either
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.299 2001/08/08 05:45:51 poquah Exp $";
d396 1
a396 1
				scroll->value[1] = skill_lookup("pox");
d398 1
a398 1
				scroll->value[3] = skill_lookup("haste");
d402 3
a404 3
                                scroll->value[1] = skill_lookup("learned knowledge");
                                scroll->value[2] = sn;
                                scroll->value[3] = skill_lookup("sanctuary");
d408 3
a410 3
                                scroll->value[1] = skill_lookup("wrath of the pen");
                                scroll->value[2] = sn;
                                scroll->value[3] = skill_lookup("giant strength");
d415 1
a415 1
                                scroll->value[1] = skill_lookup("magical rest");
d417 1
a417 1
                                scroll->value[3] = skill_lookup("calm");
@


1.299
log
@Adding Honor's Enemy flag for Loner's and Outcasts
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.298 2001/08/04 19:29:22 guerrand Exp $";
d200 1
a200 1
{ /*begin do_scribe */
d364 1
a364 1
		check_improve(ch,gsn_scribe,TRUE,1);
a384 1
		SET_BIT(scroll->extra_flags,ITEM_GLOW);
d388 1
a388 1
                if (way_cool_spell <= 5)
d399 1
d405 1
d411 2
d418 1
d424 2
d428 1
a428 1
                                scroll->value[1] = skill_lookup("pox");
d431 3
d452 1
a452 1
		check_improve(ch,gsn_scribe,TRUE,1);
@


1.298
log
@Alchemy prices lowered about 20%.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.297 2001/08/03 02:24:29 boogums Exp $";
d4074 3
@


1.297
log
@ok now putting scribed spells and goodies back in the game
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.296 2001/08/01 21:44:56 mud Exp $";
d57 6
a62 6
#define COST_ACCURACY	500
#define COST_SPEED	800
#define COST_MAGIC_RESISTANCE 	1250
#define COST_VISION	250
#define COST_RESTORATION	150
#define COST_MOLOTOV	100
@


1.296
log
@= to == in if(), I'm a dumbass
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.295 2001/08/01 21:43:40 rusty Exp $";
a377 1
		way_cool_spell = number_percent( );
d383 50
a432 1
		scroll->extra_flags = ITEM_NOIDENTIFY;
@


1.295
log
@making infinite staves possible
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.294 2001/08/01 04:02:50 boogums Exp $";
d3553 1
a3553 1
    if ( abs(--staff->value[2]) = 0 )
@


1.294
log
@ok the skill table got fubard took out the scribe spells i added\
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.293 2001/07/31 02:59:42 boogums Exp $";
d3553 1
a3553 1
    if ( --staff->value[2] <= 0 )
@


1.293
log
@ok me thinks i gots it
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.292 2001/07/31 02:52:55 boogums Exp $";
a378 25

		if ( new_sn_percent < 6 )
		{
			send_to_char("Whoa, what is this spell I wrote?\r\n",ch);
			switch (number_range(0,3))
			{
			case 0:
				sn = skill_lookup("pox");
				break;
                        case 1:
                                sn = skill_lookup("magical rest");
                                break;
                        case 2:
                                sn = skill_lookup("sanctuary");
                                break;
                        case 3:
                                sn = skill_lookup("magus wrath");
                                break;

			default:
				break;
			}

		}

@


1.292
log
@ok almost got this done
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.291 2001/07/31 02:48:15 boogums Exp $";
d380 1
a380 1
		if ( (new_sn_percent * 8) /10 < (percent *3 ) / 10 )
@


1.291
log
@ok for some reason the magus knowledge spell was freaking every thing out
i've yanked it and will add more spells later as time permits
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.290 2001/07/31 01:48:59 boogums Exp $";
d380 1
a380 1
		if ( (new_sn_percent * 8) /10 > (percent *3 ) / 10 )
@


1.290
log
@
ok backed out the changes, seeing if it will crash now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.289 2001/07/31 01:28:08 boogums Exp $";
d330 1
a330 1
	percent = ( get_skill(ch,gsn_scribe) ) ;
d335 1
a335 1
			percent += 10;
d339 1
a339 1
			percent += 5;
d342 1
a342 1
                        percent += 0;
d379 1
a379 1
/*
d392 1
a392 1
                                sn = skill_lookup("scribed knowledge");
d403 1
a403 1
*/
@


1.289
log
@wow, it's really broken tweaking now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.288 2001/07/31 01:23:39 boogums Exp $";
d379 1
a379 1

a382 1
			/*do stuff*/
d403 1
a403 1

@


1.288
log
@yep, totally broke scribe :)
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.287 2001/07/31 01:11:37 boogums Exp $";
d330 1
a330 1
	percent = ( get_skill(ch,gsn_scribe) * 8) / 10;
d335 1
a335 1
			percent += 15;
d339 1
a339 1
			percent += 10;
d342 1
a342 1
                        percent += 5;
d346 1
a346 1
			percent  += 0;
@


1.287
log
@Ok added four new spells and tweaked do_scribe a bit
hope this woirks
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.286 2001/07/30 22:44:34 guerrand Exp $";
d335 1
a335 1
			percent *= 1.25;
d339 1
a339 1
			percent *= .95;
d342 1
a342 1
                        percent *= .80;
d346 1
a346 1
			percent  *= .70;
d349 1
a349 1
        		percent *= .2;
a377 10
                /*check new_sn_percent here. with a case imbed it in an if
		  so if the percent is > 95 do the check otherwise scribe
		  as normal
                  if it's 1 do magical heal
                  if it's 2 do pox
                  if it's 3 do magus wrath
                  if it's 4 do knowledge
                  BUT the scroll will say what they origionally wanted
		  to put on it
                */
d379 1
@


1.286
log
@Elementaliss can use 'ritual' now.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.285 2001/07/24 02:01:39 boogums Exp $";
a200 1
/*syntax is scribe spellname scrollname */
d211 7
a217 5
    int sn;

   int spell_level1;
   int spell_level;
    int spell_level2;
a292 3



d330 2
a331 1
	percent = get_skill(ch,gsn_scribe);
d335 1
a335 1
			percent *= .95;
d339 1
a339 1
			percent *= .8;
d342 1
a342 1
                        percent *= .6;
d346 1
a346 1
			percent  *= .4;
d354 1
d357 3
d378 36
d419 1
@


1.285
log
@DOH
it is now possible to fail when scribing
sorry guys
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.284 2001/07/20 23:50:08 boogums Exp $";
d5108 1
a5108 1
    if ( ch->pcdata->old_class != class_lookup("cleric") )
@


1.284
log
@putting the new skill_table in boinga.  added bitvector to all the skills
here goes nothing
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.283 2001/07/20 20:40:25 boogums Exp $";
a219 34
#ifdef NEVER_VERSION
    int sn_fire  = skill_lookup("fire breath");
    int sn_acid  = skill_lookup("acid breath");
    int sn_frost = skill_lookup("frost breath");
    int sn_gas   = skill_lookup("gas breath");
    int sn_light = skill_lookup("lightning breath");
    int sn_withstand = skill_lookup("withstand death");
    int sn_heal      = skill_lookup("heal");
    int sn_acidblast = skill_lookup("acid blast");
    int sn_holdperson= skill_lookup("hold person");
    int sn_feeblemind= skill_lookup("feeblemind");
    int sn_chainl    = skill_lookup("chain lightning");
    int sn_askin     = skill_lookup("adamantite skin");
    int sn_sskin     = skill_lookup("steel skin");
    int sn_dskin     = skill_lookup("diamond skin");
    int sn_mmissle   = skill_lookup("magic missle");
    int sn_demonfire = skill_lookup("demonfire");
    int sn_rot       = skill_lookup("ray of truth");
    int sn_sunburst     = skill_lookup("sunburst");
    int sn_flamestrike  = skill_lookup("flamestrike");
    int sn_earthquake   = skill_lookup("earthquake");
    int sn_colourspray   = skill_lookup("colour spray");
    int sn_incinerate    = skill_lookup("incinerate");
    int sn_symboli       = skill_lookup("symbol i");
    int sn_symbolii       = skill_lookup("symbol ii");
    int sn_symboliii       = skill_lookup("symbol iii");
    int sn_symboliv       = skill_lookup("symbol iv");
    int sn_harm           = skill_lookup("harm");
    int sn_turn_undead    = skill_lookup("turn undead");
    int sn_woundxfer      = skill_lookup("wound transfer");
#endif



a256 1
/* add the adamanite steel diamond skin checks too */
a257 1
/* Ok the below is broken, i'm going to look into it tonight*/
a269 38
#ifdef NEVER_VERSION

    if (	   (sn == sn_fire) 
		|| (sn == sn_acid)
		|| (sn == sn_frost)
		|| (sn == sn_gas)
		|| (sn == sn_withstand)
		|| (sn == sn_light)
		|| (sn == sn_heal)
		|| (sn == sn_acidblast)
		|| (sn == sn_holdperson)
		|| (sn == sn_feeblemind)
		|| (sn == sn_chainl)		
		|| (sn == sn_askin)
		|| (sn == sn_dskin)
		|| (sn == sn_sskin)	
    		|| (sn == sn_demonfire)
                || (sn == sn_rot)
    		|| (sn == sn_sunburst)
    		|| (sn == sn_flamestrike)
    		|| (sn == sn_earthquake)
    		|| (sn == sn_colourspray)
		|| (sn == sn_incinerate)
		|| (sn == sn_symboli)
                || (sn == sn_symbolii)
                || (sn == sn_symboliii)
                || (sn == sn_symboliv)
                || (sn == sn_harm)
		|| (sn == sn_mmissle)
		|| (sn == sn_turn_undead)
		|| (sn == sn_woundxfer)
	)
    {
	send_to_char("That spell may not be put on a scroll.\r\n",ch);
	return;
    }
#endif

d336 1
a336 1
			percent += 5;
d340 1
a340 1
			percent -= 5;
d343 1
a343 1
                        percent -= 10;
d347 1
a347 1
			percent  -=20;
d350 1
a350 1
        		percent -=20;
a353 3
	
	/* Put checks here based on the ink they are using later after Mar goes down for her nap */

d358 1
a358 2
	if ( (number_percent( ) < percent)
	   || (get_skill(ch,gsn_scribe) >=2 ) ) 
@


1.283
log
@ i coulnd't tell if i was in teh olc version or the game vversion of
the sanity check :)
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.282 2001/07/20 20:10:39 boogums Exp $";
d220 1
a220 1
#ifdef GAME_VERSION
a293 1
#ifdef OLC_VERSION
d297 1
a297 1
		send_to_char("OLC_VERSION Check - You may not put that spell on a scroll.\r\n",ch);
a304 1
#endif
d306 1
a306 1
#ifdef GAME_VERSION
@


1.282
log
@ok ging to try a switch
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.281 2001/07/20 19:59:24 boogums Exp $";
d298 1
a298 1
		send_to_char("You may not put that spell on a scroll.\r\n",ch);
@


1.281
log
@hey, let's try this i don't think ISSET is going to cut it
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.280 2001/07/20 18:47:08 boogums Exp $";
d295 11
a305 6
    if (skill_table[sn].bitvector != SS_SCRIBE )
	{
        send_to_char("That spell may not be put on a scroll.\r\n",ch);
        return;
	
	}
@


1.280
log
@ok yanked out the olc_version stuff
=Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.279 2001/07/20 18:30:07 boogums Exp $";
d293 1
a293 1
/* Ok the below is broken, i'm going to look into it tonight
d295 1
a295 1
    if (!IS_SET(skill_table[sn].bitvector, SS_SCRIBE) )
a301 1
*/
@


1.279
log
@ i have no idea why this isn't werking
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.278 2001/07/20 18:21:16 boogums Exp $";
d293 1
d295 1
a295 1
    if (!IS_SET(skill_table[sn].extra_settings, SS_SCRIBE) )
d302 1
@


1.278
log
@damn parens
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.277 2001/07/20 18:07:38 boogums Exp $";
d294 1
a294 1
    if (!IS_SET(skill_table[sn].extra_settings, SS_IS_SCRIBABLE) )
@


1.277
log
@t doh damn typos
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.276 2001/07/20 18:05:40 boogums Exp $";
d294 1
a294 1
    if (!IS_SET(skill_table[sn].extra_settings, SS_IS_SCRIBABLE)
@


1.276
log
@Ok i've got teh new ch3ck wrapped in OLC_VERSION, going to see if it
actually works
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.275 2001/07/18 04:05:29 boogums Exp $";
d294 1
a294 1
    if (!IS_SET(spell_table[sn].extra_settings, SS_IS_SCRIBABLE)
@


1.275
log
@Ok took wound xfer off of the castable list
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.274 2001/07/17 14:48:00 boogums Exp $";
d202 1
a202 4
/*
void obj_cast_spell( int sn, int level, CHAR_DATA *ch, CHAR_DATA *victim, OBJ_DA
TA *obj )
*/
d219 2
d250 1
d293 10
d338 1
@


1.274
log
@trying something a bit different with the levels of the affects on
teh scribed scroll
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.273 2001/07/17 14:32:20 boogums Exp $";
d250 1
d322 1
@


1.273
log
@Put a mod in do_recite.  if it's a scribed scroll, reciting will be at
a base of 10 instead of 20 for stock scrolls
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.272 2001/07/17 04:13:13 boogums Exp $";
d219 2
d421 1
d434 1
a434 3
/*		spell_level1 += 3;
		spell_level1 = URANGE(1,percent,51); */
		scroll->level = ( spell_level1 );
d437 1
a437 1
		scroll->value[0] = spell_level -8 ;
@


1.272
log
@ok had to twak something
back again
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.271 2001/07/17 03:58:28 boogums Exp $";
d3436 2
d3486 19
a3504 1
    if (number_percent() >= 20 + get_skill(ch,gsn_scrolls) * 4/5)
@


1.271
log
@doh forgot to take moutm magic missle
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.270 2001/07/17 03:07:44 boogums Exp $";
d247 1
d318 1
a318 3



d431 2
d436 1
a436 1
		scroll->value[0] = spell_level - 8;
@


1.270
log
@turned on the kit in conts.c
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.269 2001/07/17 02:56:42 boogums Exp $";
d234 1
a234 1

d316 1
@


1.269
log
@forgot a couple of spells and had to set the value to 0
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.268 2001/07/17 02:46:14 boogums Exp $";
a208 1
    char temp[MAX_INPUT_LENGTH];
@


1.268
log
@doh forgot to set the cost to 0
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.267 2001/07/17 02:02:57 boogums Exp $";
d239 1
a239 1
    int sn_flamestrike  = skill_lookup("flamestring");
d247 1
d316 2
d432 1
a432 1
		scroll->level = ( (spell_level1 *4)/ 5);
@


1.267
log
@ok i think i got all of scribe so far
-Booogly
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.266 2001/07/16 19:37:55 boogums Exp $";
d430 1
@


1.266
log
@ok i m ready to starting the serious testing of scribe
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.265 2001/07/16 04:56:27 boogums Exp $";
d236 12
d304 13
@


1.265
log
@and the band played on
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.264 2001/07/16 04:51:25 boogums Exp $";
d232 4
d288 5
a292 1
		|| (sn == sn_chainl)		)
d318 1
a318 3
   /*  if (container->pIndexData->vnum == OBJ_VNUM_PIT */

	spell_level1 = skill_level(ch,sn);
d364 1
a364 1
			percent += 0;
d386 1
a386 1
        send_to_char("Checking to see if the scribe is going to work or not.\r\n",ch);
d404 1
a404 1
		scroll->level = ( (spell_level *4)/ 5) +3;
d421 1
a421 1
		send_to_char("You have goofed up.  This isn't the scroll you were trying to write.\r\n",ch);
@


1.264
log
@here we go again damn logic
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.263 2001/07/16 04:33:38 boogums Exp $";
d324 1
a324 2
    if ( (spell_level1 >= 39 && spell_level1 <= 49) && (scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM
	|| scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_PARCHMENT) )
@


1.263
log
@trying agian
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.262 2001/07/16 04:28:36 boogums Exp $";
d324 2
a325 1
    if ( (spell_level1 >= 39 && spell_level1 <= 49) && (scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM) )
d348 1
a348 1
	sprintf(temp,"You need to scribet that spell on to a papyrus scroll.\r\n");
@


1.262
log
@lets try a different tack shall we
-boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.261 2001/07/16 04:16:49 boogums Exp $";
d324 1
a324 1
    else if ( (spell_level1 >= 39 && spell_level1 <= 49) && (scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM) )
d330 1
a330 1
    else if ( (spell_level1 >= 25 && spell_level1 <=38)  
d337 1
a337 1
    else if ( (spell_level1 >= 11 && spell_level1 <=24 )
d344 1
a344 1
    else if ( (spell_level1 >= 1 && spell_level1 <=10 )
@


1.261
log
@
tta see this
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.260 2001/07/16 03:47:07 boogums Exp $";
d320 1
a320 1
	send_to_char("Your parchment scroll is not of high enough quality to put that spell on.\r\n",ch);
d324 1
a324 3
    else if ( (spell_level1 >= 39) && (scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM
	|| 
	scroll->pIndexData->vnum !=  OBJ_VNUM_SCRIBE_PARCHMENT)  )
d326 1
a326 1
        send_to_char("Your  vellum scroll is not of high enough quality to put that spell on.\r\n",ch);
d330 2
a331 4
    else if ( (spell_level1 >= 25) 
    && ( scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_RICEPAPER 
	|| scroll->pIndexData->vnum !=  OBJ_VNUM_SCRIBE_PARCHMENT
	|| scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM)  )
d337 2
a338 5
    else if ( (spell_level1 >= 11)
   && ( scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_KOZO 
    ||  scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_RICEPAPER
        || scroll->pIndexData->vnum !=  OBJ_VNUM_SCRIBE_PARCHMENT
        || scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM)  )
d341 1
a341 1
        send_to_char("Your kozo scroll is not of high enough quality to put that spell on.\r\n",ch);
d344 2
a345 7
    else if ( (spell_level1 >= 1)
    && (scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_PAPYRUS 
   ||  scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_KOZO
    ||  scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_RICEPAPER
        || scroll->pIndexData->vnum !=  OBJ_VNUM_SCRIBE_PARCHMENT
        || scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM)  )

d347 1
a347 3
	sprintf(temp,"You papyrus scroll is not of high enough quality to put that spell on.\r\n");
	sprintf(temp,spell_level1);
        send_to_char(temp,ch);
@


1.260
log
@Revamped the check to see if the scroll was the right one
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.259 2001/07/16 03:28:44 boogums Exp $";
d209 2
d315 2
d359 3
a361 1
        send_to_char("You papyrus scroll is not of high enough quality to put that spell on.\r\n",ch);
@


1.259
log
@trying somethign new in act_obj.c
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.258 2001/07/16 03:20:48 boogums Exp $";
d320 3
a322 1
    else if ( (spell_level1 >= 39 && spell_level1 <= 49) && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM )
d328 4
a331 2
    else if ( (spell_level1 >= 25 && spell_level1 <= 38) 
    && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_RICEPAPER )
d333 1
a333 1
        send_to_char("Your ricepaper scroll is not of high enough quality to put that spell on.\r\n",ch);
d337 6
a342 2
    else if ( (spell_level1 >= 11 && spell_level1 <= 24)
    && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_KOZO )
d347 7
a353 2
    else if ( (spell_level1 >= 1 && spell_level1 <= 10)
    && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_PAPYRUS )
d355 1
a355 1
        send_to_char("Your papyrus scroll is not of high enough quality to put that spell on.\r\n",ch);
@


1.258
log
@More do_scribe madness
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.257 2001/07/16 01:44:57 boogums Exp $";
d320 1
a320 1
    if ( (spell_level1 >= 39 && spell_level1 <= 49) && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM )
d326 1
a326 1
    if ( (spell_level1 >= 25 && spell_level1 <= 38) 
d333 1
a333 1
    if ( (spell_level1 >= 11 && spell_level1 <= 24)
d339 1
a339 1
    if ( (spell_level1 >= 1 && spell_level1 <= 10)
@


1.257
log
@Alright, i thi k i've go tit
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.256 2001/07/16 00:14:40 boogums Exp $";
d236 6
d269 2
d316 1
a316 1
	send_to_char("Your scroll is not of high enough quality to put that spell on.\r\n",ch);
d322 1
a322 1
        send_to_char("Your scroll is not of high enough quality to put that spell on.\r\n",ch);
d329 1
a329 1
        send_to_char("Your scroll is not of high enough quality to put that spell on.\r\n",ch);
d336 1
a336 1
        send_to_char("Your scroll is not of high enough quality to put that spell on.\r\n",ch);
d342 1
a342 1
        send_to_char("Your scroll is not of high enough quality to put that spell on.\r\n",ch);
d393 1
@


1.256
log
@well that didnt' work taking that out
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.255 2001/07/16 00:10:01 boogums Exp $";
a209 1
    char temp[MAX_INPUT_LENGTH];
d302 4
a305 1
    if ( spell_level >= 50 
d312 1
a312 1
    if ( (spell_level >= 39 && spell_level <= 49) && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM )
d318 1
a318 1
    if ( (spell_level >= 25 && spell_level <= 38) 
d325 1
a325 1
    if ( (spell_level >= 11 && spell_level <= 24)
d331 1
a331 1
    if ( (spell_level >= 1 && spell_level <= 10)
@


1.255
log
@wow this has been fun
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.254 2001/07/15 23:50:20 boogums Exp $";
a294 5
    spell_level1 = skill_table[sn].skill_level[ch->class];
                sprintf (temp, "level of the spell:  ");
                strcat (temp,spell_level1);
		send_to_char(temp,ch);

d303 1
a303 1
    if ( spell_level1 >= 50 
d310 1
a310 1
    if ( (spell_level1 >= 39 && spell_level1 <= 49) && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM )
d316 1
a316 1
    if ( (spell_level1 >= 25 && spell_level1 <= 38) 
d323 1
a323 1
    if ( (spell_level1 >= 11 && spell_level1 <= 24)
d329 1
a329 1
    if ( (spell_level1 >= 1 && spell_level1 <= 10)
@


1.254
log
@Whoohooo i think i got it now
-Boogums
ZZ
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.253 2001/07/15 23:00:53 boogums Exp $";
d210 1
a210 1

d296 4
@


1.253
log
@ahhh i think i have it now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.252 2001/07/15 22:48:20 boogums Exp $";
d217 1
d295 1
d304 1
a304 1
    if ( spell_level >= 50 
d311 1
a311 1
    if ( (spell_level >= 39 && spell_level <= 49) && scroll->pIndexData->vnum != OBJ_VNUM_SCRIBE_VELLUM )
d317 1
a317 1
    if ( (spell_level >= 25 && spell_level <= 38) 
d324 1
a324 1
    if ( (spell_level >= 11 && spell_level <= 24)
d330 1
a330 1
    if ( (spell_level >= 1 && spell_level <= 10)
@


1.252
log
@Ok i think i got it
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.251 2001/07/15 22:24:21 boogums Exp $";
a372 1
		strcat (scroll_name,"\r\n");
d374 1
a374 1
                scroll->name = scroll_name;
d376 1
a376 1
      		scroll->short_descr = scroll_name; 
d380 2
a381 1
      		scroll->description = strcat(scroll_name, " lies here.\r\n"); 
@


1.251
log
@Whoa, was throwin the elvel into the spell number really goofed up
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.250 2001/07/15 22:03:20 boogums Exp $";
d371 1
a371 1
		sprintf (scroll_name, "A scroll of ");
d373 1
d379 2
d389 1
a389 1
                send_to_char("You have created a new scroll.r\n",ch);
@


1.250
log
@ when receiting, it crashes figuring out now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.249 2001/07/15 21:49:49 boogums Exp $";
d373 2
d379 2
a380 4
		free_string( scroll -> name );
		scroll->name = scroll_name;
		scroll->value[0] =  sn;
		scroll->value[1] = ch->level - 5;
d387 1
@


1.249
log
@ok, the spell check works but it don't do nothing when it comes to
finding out if the scroll is there
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.248 2001/07/15 21:29:51 boogums Exp $";
d381 4
d386 2
@


1.248
log
@still trying
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.247 2001/07/15 21:25:26 boogums Exp $";
a248 20
    if ( arg1 == '\0'  )
    {
        send_to_char("Syntax:  scribe 'spell name' 'scroll name' 'ink name'\r\n",ch);
        return;
    }
    if ( arg2 == '\0'  )
    {
        send_to_char("Syntax:  scribe 'spell name' 'scroll name' 'ink name'\r\n",ch);
        return;
    }
    if ( arg3 == '\0'  )
    {
        send_to_char("Syntax:  scribe 'spell name' 'scroll name' 'ink name'\r\n",ch);
        return;
    }

	send_to_char(arg1,ch);
	send_to_char(arg2,ch);
	send_to_char(arg3,ch);

d286 1
a286 1
    if ( ( ink = get_obj_carry(ch,arg3 ) ) == NULL )
@


1.247
log
@let's try this
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.246 2001/07/15 21:21:26 boogums Exp $";
d265 3
@


1.246
log
@weird it's not working
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.245 2001/07/15 21:13:35 boogums Exp $";
d249 1
a249 1
    if ( arg1 == ""  )
d254 1
a254 1
    if ( arg2 == ""  )
d259 1
a259 1
    if ( arg3 == ""  )
@


1.245
log
@changing the order in which it checks stuff
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.244 2001/07/15 21:09:09 boogums Exp $";
d249 1
a249 1
    if ( arg1 == NULL  )
d254 1
a254 1
    if ( arg2 == NULL  )
d259 1
a259 1
    if ( arg3 == NULL  )
d381 2
@


1.244
log
@Ok had to redo the checks on the spell.  thanks Rage for helping me out
with that.  changes to ac_obj.c commiting now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.243 2001/07/15 20:01:19 boogums Exp $";
d249 1
a249 1
    if ( (arg1 == NULL) || (arg2 == NULL) || (arg3 == NULL) )
d254 11
@


1.243
log
@Adding the scribe do_scribe for the scribe kit
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.242 2001/07/02 17:12:40 mud Exp $";
a215 1
	int gn;
d219 11
d249 1
a249 1
    if( is_affected(ch,skill_lookup("wraithform")) )
d251 1
a251 1
        send_to_char("Not while in wraithform.\r\n",ch);
d255 1
d270 16
a340 19
    gn = group_lookup("draconian");
    
    if (group_table[gn].spells[sn] != NULL)
    {
	send_to_char( "Draconian spells cannot be put on scrolls.\r\n",ch );
	return;
    }

    if ( sn == skill_lookup("withstand death") )
    {
        send_to_char( "Withstand Death cannot be put on a scroll.\r\n",ch);
        return;
    }

    if ( sn == skill_lookup("heal") )
    {
        send_to_char( "A simple scroll is to weak to hold the heal spell.\r\n",ch);
        return;
    }
@


1.242
log
@Made SHOP MOBs with spec_proc's able to receive items
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.241 2001/06/26 01:21:51 guerrand Exp $";
d38 1
a38 1

d198 201
@


1.241
log
@No more charming to full loot.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.240 2001/06/24 06:00:25 guerrand Exp $";
d1519 1
a1519 1
  && !IS_IMMORTAL(ch))
@


1.240
log
@YOu now gain XP when ritual or scribing a scroll.  Lots of it, too!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.239 2001/06/23 18:48:41 guerrand Exp $";
d375 1
a375 1
        if (is_same_group(ch,owner) || is_same_clan(ch,owner))
@


1.239
log
@Added logic for recipe skills.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.238 2001/06/23 07:04:24 guerrand Exp $";
d4951 1
d5049 1
@


1.238
log
@Fixed a few bugs in forge
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.237 2001/06/19 02:11:32 guerrand Exp $";
d4747 1
d4829 15
d4850 6
d4857 7
@


1.237
log
@FIx for critical strikes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.236 2001/06/19 00:52:23 rage Exp $";
d4750 1
a4750 1
	send_to_char("Attempt to use what to forge a greater item?\n\r", ch);
d4776 3
a4778 1
	       if (forge->value[0] != 0 ) 
d4801 1
@


1.236
log
@ One final superficial change to forging.
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.235 2001/06/19 00:33:08 rage Exp $";
d4833 2
a4834 2
	act("$P glows with a magical light!", ch, forge, NULL, TO_ROOM, FALSE);
	act("Your forging is successful.  $P glows with magical light!", ch, forge, NULL, TO_CHAR, FALSE);
@


1.235
log
@change to do_get to allow you to get stuff from forges
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.234 2001/06/19 00:08:17 rage Exp $";
d4833 2
a4834 2
	act("$p glows with a magical light!", ch, forge, NULL, TO_ROOM, FALSE);
	act("Your forging in successful.  $p glows with magical light!", ch, forge, NULL, TO_CHAR, FALSE);
@


1.234
log
@Fixed a crash bug in forges
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.233 2001/06/18 23:13:01 rage Exp $";
d946 1
d956 2
a957 1
  if ( IS_SET(container->value[1], CONT_CLOSED) )
@


1.233
log
@LAst fix to forge...I hope
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.232 2001/06/18 22:55:34 rage Exp $";
d4774 1
a4774 1
	       if (forge->value[i] != 0 ) 
@


1.232
log
@More fixes to forge, changed some logic
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.231 2001/06/18 01:43:00 rage Exp $";
d4740 1
a4740 1
	OBJ_DATA *forge, *obj, *complete;
d4823 1
a4823 1
	   for(obj = forge->contains ; obj != NULL ; obj = obj->next_content )
d4825 1
@


1.231
log
@ more fixes to forging
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.230 2001/06/18 01:24:11 rage Exp $";
d4772 2
d4792 1
a4792 1
		   for ( j = 0 ; j <= count ; j++)
d4799 1
a4799 1
	        for ( j = 0 ; j <= count; j++ )
@


1.230
log
@ Some quick fixes to forges before I even get going
	rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.229 2001/06/18 01:17:32 rage Exp $";
d1049 1
a1049 1
    if ( container->item_type != ITEM_CONTAINER || container->item_type != ITEM_FORGE)
d4772 1
a4772 1
	   
@


1.229
log
@ Initial insertion of forging items.  Added new item type ITEM_FORGE.
 One can create "recipes" for these forges.  Each recipe is a list of
 objects that once placed inside the forge will create a bigger/better
 object.  Basically a better implementation of item parts.

-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.228 2001/06/17 18:35:35 guerrand Exp $";
d4772 7
a4778 1
		recipe = get_recipe_data(forge->value[i]);
@


1.228
log
@wizard 'copyspell' command is done.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.227 2001/06/17 06:30:17 guerrand Exp $";
d1049 1
a1049 1
    if ( container->item_type != ITEM_CONTAINER )
d1055 1
a1055 1
    if ( IS_SET(container->value[1], CONT_CLOSED) )
d1088 1
a1088 1
  if (get_obj_weight( obj ) + get_true_weight( container )
d1090 1
a1090 1
  ||  get_obj_weight(obj) > (container->value[3] * 10))
d1108 1
a1108 1
  if (IS_SET(container->value[1],CONT_PUT_ON))
d1126 1
a1126 1
      if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
d1134 1
a1134 1
      &&   get_obj_weight(obj) < (container->value[3] * 10))
d4737 91
@


1.227
log
@Fixed SCintilla's bug with taking items with no longer description.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.226 2001/06/17 06:21:37 guerrand Exp $";
d4823 98
a4920 1
	act("$n attempts to learn from $p, but fails.",ch,scroll,NULL,TO_CHAR,FALSE);
@


1.226
log
@Scrolls will crumble to ashes when expended.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.225 2001/06/17 05:58:51 guerrand Exp $";
d823 2
a824 1
	else if ( strlen(obj->description) < 1 || strlen(arg1) < 2 )
d869 1
a869 1
	 if ( strlen(obj->description) < 1 ) /* hide items with no long descr */
@


1.225
log
@Added oldclass cleric check for scribe
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.224 2001/06/17 05:31:07 guerrand Exp $";
a4815 1
	return;
d4823 7
a4829 1
	return;
@


1.224
log
@Fixed bug in ritual
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.223 2001/06/17 05:26:57 guerrand Exp $";
d4744 6
@


1.223
log
@Debugging ritual now
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.222 2001/06/17 05:18:02 guerrand Exp $";
a4777 1
    log_string("ritual 1");
a4783 1
    log_string("ritual 2");
a4789 1
    log_string("ritual 3");
a4802 1
   log_string("ritual 4"); 
d4808 2
a4809 2
        act("You have learned a new spell from $p!",ch,NULL,NULL,TO_CHAR,FALSE);
	act("$n has learned a new spell from $p!",ch,NULL,NULL,TO_ROOM,FALSE);
@


1.222
log
@Ritual command is in.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.221 2001/06/09 01:10:51 guerrand Exp $";
a4739 1
    int sn;
d4742 3
d4778 1
d4785 1
d4792 1
d4796 1
a4796 1
    chance -= scroll->value[2];
d4805 2
a4806 1
    
@


1.221
log
@GMAN
Added the first test DOT: boiling blood.
It will eventually go into a 'shaman' kit with some other DOT spells.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.220 2001/06/07 22:29:59 rage Exp $";
d4736 32
d4769 50
@


1.220
log
@Fixed up "Assemble" function a bit
Added in spells flameseek and started on wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.219 2001/06/05 00:39:40 rage Exp $";
d4735 2
@


1.219
log
@First attempt at adding do_assemble a command used to assemble objects from other objects
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.218 2001/06/03 23:28:37 guerrand Exp $";
d4678 6
d4692 1
a4692 1
	act( "$p is not part of a greater item",ch, piece, NULL, TO_CHAR, FALSE);
d4707 1
a4707 1
			if ( obj->pIndexData->vnum == piece->value[i] )
d4709 1
d4714 3
a4732 1
	
@


1.218
log
@FIxed a minor bug in get GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.217 2001/06/03 23:20:06 guerrand Exp $";
d4667 58
@


1.217
log
@And, at least, the final stages of secret and concealed flags are done!
-GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.216 2001/05/25 01:35:13 guerrand Exp $";
d822 4
a825 5
      }
      else /* help hide items with no long description */
      if ( strlen(obj->description) < 1 )
      {
    act("I see no $T here.",ch,NULL,arg1,TO_CHAR,FALSE);
d827 1
a827 1
     	}
@


1.216
log
@Guerrand:
* Added a new magelab type.
* Made it so immortals can give things while wizi
* Imprroved AI for the Yinn monk
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.215 2001/05/24 14:35:22 poquah Exp $";
d823 6
d869 2
@


1.215
log
@change looting so mobs dont pick up corpses
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.214 2001/05/24 01:33:26 poquah Exp $";
d92 1
d182 4
a185 3
            case SECT_MAGELAB_SIMPLE: potion->value[0] = 4; break;
            case SECT_MAGELAB_INTERMEDIATE: potion->value[0] = 6; break;
	    case SECT_MAGELAB_ADVANCED: potion->value[0] = 8; break;
d1535 1
a1535 1
    if ( !can_see_obj( victim, obj ) )
@


1.214
log
@change looting for nonclanners
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.213 2001/05/22 02:14:31 boogums Exp $";
d365 4
a368 3
  if (!IS_NPC(owner)
      && (IS_SET(owner->act,PLR_CANLOOT)))
    return TRUE;
d370 4
a373 10
  /* Seperate Clan and Nonclan corpses at this point */
  if (owner->clan != 0 && owner->clan != clan_lookup("matook"))
  {
     if (is_same_group(ch,owner) || is_same_clan(ch,owner))
        return TRUE;
  }
  else
  {
     if (is_same_group(ch,owner) )
        if(IS_SET(owner->act,PLR_CANLOOT))
d375 7
a381 1
  }
d383 1
a383 1
  if (IS_SET(obj->extra_flags,ITEM_CLAN_CORPSE)
d385 2
a386 1
    return TRUE;
@


1.213
log
@doh, had to put it in one more place
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.212 2001/05/22 02:07:28 boogums Exp $";
d369 12
a380 2
  if (is_same_group(ch,owner) || is_same_clan(ch,owner))
    return TRUE;
@


1.212
log
@21may01
Doh, forgot to add a check in do_give to see if the victim is in wraithform
Learning, learning, always learning
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.211 2001/05/20 21:25:43 rusty Exp $";
d1481 6
@


1.211
log
@No more looting while wraithed
Squashed necro bonus casting levels bug.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.210 2001/04/09 18:30:39 mud Exp $";
d650 7
d1331 1
a1331 1

d1368 7
@


1.210
log
@Applied rom 2.4 b5 and b6 patches as necessary.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.209 2001/04/09 03:14:18 mud Exp $";
d636 6
@


1.209
log
@No hiding all your stuff in a bag
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.208 2001/04/09 03:08:03 mud Exp $";
d1666 1
a1666 1
    if (argument == '\0')
d3766 2
a3767 2
  gold = victim->gold * number_range(1, ch->level) / 60;
  silver = victim->silver * number_range(1,ch->level) / 60;
@


1.208
log
@Last of the looting typo fixes
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.207 2001/04/09 01:34:14 mud Exp $";
d697 1
a697 1
	 && !can_loot(ch,container,FALSE) )
@


1.207
log
@Clan mates may now always loot your corpse.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.206 2001/04/09 01:30:26 mud Exp $";
d696 2
a697 1
	 && obj->item_type != ITEM_MONEY && !can_loot(ch,container,FALSE) )
@


1.206
log
@Made looting of non-treasure items limited to 4 from a corpse.
Also made group mates and stuff able to loot all from your corpse
to save your ass.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.205 2001/03/10 16:42:32 mud Exp $";
d369 1
a369 1
  if (is_same_group(ch,owner))
@


1.205
log
@you can pick up corpses that are empty
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.204 2001/03/03 19:05:25 mud Exp $";
d345 1
a345 1
bool can_loot(CHAR_DATA *ch, OBJ_DATA *obj)
a364 4
/*
  if (!IS_NPC(owner) 
      && (IS_SET(owner->act,PLR_CANLOOT) || IS_SET(obj->extra_flags,ITEM_DARK))) 
      */
d373 1
a373 1
	&& is_clan(ch))
d407 1
a407 1
    if (!can_loot(ch,obj))
d673 1
a673 1
    if (!can_loot(ch,container))
d690 21
d728 1
a728 1
	   || (str_cmp(ch->name,container->owner)
@


1.204
log
@initializing a var
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.203 2001/03/03 18:53:56 mud Exp $";
d794 1
a794 1
         if(found && victim != ch) 
@


1.203
log
@Took out all references to damage_old() and used iOld var in damage()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.202 2000/12/14 04:59:01 mud Exp $";
d1760 1
a1760 1
    OBJ_DATA *obj2;
@


1.202
log
@13DEC00
Added checks in the act_obj.c file, covered the rest of the commands
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.201 2000/12/14 04:49:10 mud Exp $";
d3507 1
a3507 1
      damage_old(ch,victim,0,gsn_slice,DAM_OTHER,FALSE);
@


1.201
log
@13DEC00
Yippie another clean compile.  Added checks for put, get, sacrifice,
open close, movement related commands
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.200 2000/12/09 07:05:46 mud Exp $";
d1122 7
d1295 7
d1577 7
d1640 7
d1768 7
d1869 7
d2007 7
d2174 7
d2321 6
d2441 7
d2818 7
d2866 7
d3042 7
d3104 7
d3175 7
d3271 7
d3418 7
d3579 7
d4031 7
d4313 7
d4438 7
d4543 7
@


1.200
log
@08DEC00
DAMN this wraithform it's gone now :)
=Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.199 2000/12/07 06:45:43 mud Exp $";
d749 7
d965 7
d2833 7
@


1.199
log
@ok got all the necromancer stuff out trying to restore order
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.198 2000/12/07 05:46:10 mud Exp $";
a749 7
    /*Wraith form check -Boogums*/
    /*if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
    {
      send_to_char("You are made of wraith mist.  How can you get anything?\r\n",ch);
      return;
    }
    */
a960 7
    /*Wraithform check -Boogums*/
    /*if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
    {
      send_to_char("No putting while in wraithform.\r\n",ch);
      return;
    }
    */
a1113 6
    /*if(IS_AFFECTED(ch,skill_lookup("wraithform")))
    {
      send_to_char("You are in wraithform, no dropping.\r\n",ch);
      return;
    }
    */
a2826 7
    /*if( IS_AFFECTED(ch, skill_lookup("wraithform")))
	{
	      send_to_char("You are in wraithform, no sacrificing.\r\n",ch);
		    return;
			}
    */

a3885 6
    /*if(IS_AFFECTED(ch,skill_lookup("wraithform")))
    {
      send_to_char( "You scare the shopkeeper so much, he isn't selling.\r\n",ch);
      return;
    }
    */
a4277 6
    /*if (IS_AFFECTED(ch,skill_lookup("wraithform")))
    {
      send_to_char("Not while in wraithform.\r\n",ch);
      return;
    }
    */
@


1.198
log
@06DEC00
Ok no AFF_WRAITHFORM had to change those to skill_lookups
compiled clean testing now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.197 2000/12/06 04:47:39 mud Exp $";
d751 1
a751 1
    if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
d756 1
d969 1
a969 1
    if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
d974 1
a974 1

d1128 1
a1128 1
    if(IS_AFFECTED(ch,skill_lookup("wraithform")))
d1133 1
a1133 1

d2847 1
a2847 1
    if( IS_AFFECTED(ch, skill_lookup("wraithform")))
d2852 1
d3913 1
a3913 1
    if(IS_AFFECTED(ch,skill_lookup("wraithform")))
d3918 1
a3918 1

d4311 1
a4311 1
    if (IS_AFFECTED(ch,skill_lookup("wraithform")))
d4316 1
a4316 1

@


1.197
log
@05DEC00
doh forgot the drop command
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.196 2000/12/06 04:40:39 mud Exp $";
d751 1
a751 1
    if( IS_AFFECTED(ch,AFF_WRAITHFORM) )
d968 1
a968 1
    if( IS_AFFECTED(ch,AFF_WRAITHFORM) )
d1127 1
a1127 1
    if(IS_AFFECTED(ch,AFF_WRAITHFORM))
d2846 1
a2846 1
    if( IS_AFFECTED(ch, AFF_WRAITHFORM))
d3911 1
a3911 1
    if(IS_AFFECTED(ch,AFF_WRAITHFORM))
d4309 1
a4309 1
    if (IS_AFFECTED(ch,AFF_WRAITHFORM))
@


1.196
log
@05DEC00
Alright, me thinks i got the kit done, compiling on olc and gonna do
some testing.
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.195 2000/12/03 19:22:56 mud Exp $";
d1125 6
@


1.195
log
@03DEC00
Ok i forgot to do buy and sell. covered now cann't do while in wraithform
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.194 2000/12/03 03:24:00 mud Exp $";
d2839 6
@


1.194
log
@2DEC00 - Ok here goes teh necromancer kit.  changes in act_info.c act_move.c
         act_obj.c const.c figt.c mag2.c magic.c magic.h merc.h update.c
	 all sorts of cool stuff
	 -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.193 2000/10/23 22:05:55 mud Exp $";
d3898 6
d4296 7
@


1.193
log
@zealot and posse enemies
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.192 2000/10/18 21:39:09 mud Exp $";
d750 6
d966 7
@


1.192
log
@logging steal for a bit, want to see some percents
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.191 2000/10/17 22:45:32 mud Exp $";
d3573 6
@


1.191
log
@enemies for clans , just warlock for now
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.190 2000/10/16 19:16:59 mud Exp $";
d3486 2
d3490 17
a3506 15
    percent  += ( IS_AWAKE(victim) ? 10 : -50 );
    percent += (victim->level - ch->level)*15;
    percent += (get_curr_stat(victim,STAT_DEX) - get_curr_stat(ch,STAT_DEX)) *2;
    if(IS_SET(victim->vuln_flags,VULN_DISTRACTION))
	percent -= ch->level/2;
    if(!IS_NPC(ch) && ch->pcdata->old_class != class_lookup("thief") )
	percent += 25;
    if(!IS_NPC(ch) && ch->class == class_lookup("rogue"))
	percent -= 25;
    if ( ch->race == race_lookup("kender") )
	percent -= 10;
    } else {
	   /* garauntee failure */
	   percent = 110;
	   }
d3508 2
d3511 3
a3513 3
    && !IS_NPC(victim) && !IS_NPC(ch) )
    || ( !IS_NPC(ch) && percent > get_skill(ch,gsn_steal) * 9 / 10 )
    || ( !IS_NPC(victim) && !is_clan(ch)) )
d3518 29
a3546 26
  send_to_char( "Oops.\n\r", ch );
  act( "$n tried to steal from you.\n\r", ch, NULL, victim, TO_VICT    ,FALSE);
  act( "$n tried to steal from $N.\n\r",  ch, NULL, victim, TO_NOTVICT ,FALSE);
  if (IS_AWAKE(victim))
  {
  switch(number_range(0,5))
  {
  case 0 :
     sprintf( buf, "%s is a lousy thief!", ch->name );
     break;
        case 1 :
     sprintf( buf, "%s couldn't rob %s way out of a paper bag!",
        ch->name,(ch->sex == 2) ? "her" : "his");
     break;
  case 2 :
      sprintf( buf,"%s tried to grope me!",ch->name );
      break;
  case 3 :
      sprintf(buf,"Keep your hands out of there, %s!",ch->name);
      break;
  case 4 :
      sprintf(buf,"%s touched me in my special place! Help!", ch->name);
      break;
  case 5 :
      sprintf(buf, "Don't touch me there %s!", ch->name);
      break;
d3548 12
a3559 16
        }
  do_yell( victim, buf );
  }

  if ( !IS_NPC(ch) )
  {
      if ( IS_NPC(victim) )
      {
          check_improve(ch,gsn_steal,FALSE,2);
    multi_hit( victim, ch, TYPE_UNDEFINED );
      }
      else
      {
	 ch->pcdata->quit_time = 5;
    sprintf(buf,"$N tried to steal from %s.",victim->name);
    wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);
d3564 16
a3579 16
    if (((IS_SET(ch->act,PLR_THIEF) || IS_SET(ch->act,PLR_KILLER))
             && ch->level+12 < victim->level ) 
          || (ch->trumps == 0 && ch->level+8 < victim->level)
          || (ch->trumps > 0 && ch->level+10 < victim->level ) )
       victim->pcdata->last_attacked_by = str_dup(ch->name);

    if (victim->clan == clan_lookup("warlock")
	&& !IS_SET(ch->mhs,MHS_WARLOCK_ENEMY))
	SET_BIT(ch->mhs,MHS_WARLOCK_ENEMY);

    if ( !IS_SET(ch->act, PLR_THIEF) && 
	 ! IS_SET(victim->act, PLR_THIEF) )
    {
        SET_BIT(ch->act, PLR_THIEF);
        send_to_char( "*** You are now a THIEF!! ***\n\r", ch );
	sprintf(buf,"%s got THIEF on %s in room %d",ch->name,
d3581 6
a3586 7
	log_string(buf);
        save_char_obj( ch );
    }
      }
  }

  return;
@


1.190
log
@ added in second avarice clan skill
 fixed bug in indulgence
 added in functionality for "sanction skill"
 -rage
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.189 2000/09/20 23:03:31 mud Exp $";
d3564 4
@


1.189
log
@remove unused variable percent
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.188 2000/09/20 22:54:18 mud Exp $";
d2817 3
d2821 5
a2825 1
    one_argument( argument, arg );
d3328 1
d3330 5
d3336 1
d3338 2
d3446 1
a3446 1
    if ( ch->clan  && ch->in_room->clan )
d3473 6
d3480 2
a3481 1
    
@


1.188
log
@ get rid of some ambiguous else with bracketswarnings
 -poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.187 2000/09/20 03:35:42 mud Exp $";
d1603 1
a1603 1
    int percent,skill;
@


1.187
log
@IMM's can remove noremove items
Morts can give nodrop items to IMM's
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.186 2000/09/13 14:01:48 mud Exp $";
d1668 6
a1673 6
  if (obj->value[3] < 0 
  ||  attack_table[obj->value[3]].damage == DAM_BASH)
  {
      send_to_char("You can only envenom edged weapons.\n\r",ch);
      return;
  }
d1681 2
a1682 4
  percent = number_percent();
  if (percent < skill)
  if (percent < skill)
  {
d1694 3
a1696 3
      act("You coat $p with venom.",ch,obj,NULL,TO_CHAR,FALSE);
      check_improve(ch,gsn_envenom,TRUE,3);
      WAIT_STATE(ch,skill_table[gsn_envenom].beats);
d1698 8
a1705 6
  } else {
      act("You fail to envenom $p.",ch,obj,NULL,TO_CHAR,FALSE);
      check_improve(ch,gsn_envenom,FALSE,3);
      WAIT_STATE(ch,skill_table[gsn_envenom].beats);
      return;
  }
d3786 1
a3786 1
  return 0;
d3790 1
a3790 1
  cost = obj->cost * pShop->profit_buy  / 100;
d3794 2
a3795 2
  OBJ_DATA *obj2;
  int itype;
d3797 9
a3805 9
  cost = 0;
  for ( itype = 0; itype < MAX_TRADE; itype++ )
  {
      if ( obj->item_type == pShop->buy_type[itype] )
      {
    cost = obj->cost * pShop->profit_sell / 100;
    break;
      }
  }
d3807 18
a3824 10
  if (!IS_OBJ_STAT(obj,ITEM_SELL_EXTRACT))
      for ( obj2 = keeper->carrying; obj2; obj2 = obj2->next_content )
      {
        if ( obj->pIndexData == obj2->pIndexData
    &&   !str_cmp(obj->short_descr,obj2->short_descr) )
        if (IS_OBJ_STAT(obj2,ITEM_INVENTORY))
      cost /= 2;
        else
                      cost = cost * 3 / 4;
      }
d3829 8
a3836 4
  if (obj->value[1] == 0)
      cost /= 4;
  else
      cost = cost * obj->value[2] / obj->value[1];
@


1.186
log
@
added check for holylight to detect good/evil and see spell effects like detect magic

slightly curved damage done by morphed chars

changed sneak again to make it less effective
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.185 2000/08/23 13:38:03 mud Exp $";
d1431 1
a1431 1
    if ( !can_drop_obj( ch, obj ) )
d2312 1
a2312 1
    if ( IS_SET(obj->extra_flags, ITEM_NOREMOVE) )
@


1.185
log
@ fixed little bug in olist with multiple declaration of aconstants
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.183 2000/08/18 22:52:07 mud Exp $";
d3483 1
a3483 1
    || ( !IS_NPC(ch) && percent > get_skill(ch,gsn_steal))
@


1.184
log
@ another attempt to add in olist, also some general clean up
 -Rage
@
text
@@


1.183
log
@highlanders do not steal,slice, cutpurse
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.182 2000/08/18 01:46:13 mud Exp $";
d3504 1
a3504 1
      sprintf( buf,"%s tried to rob me!",ch->name );
d3510 1
a3510 1
      sprintf(buf,"%s touched me in my special place! Help!i", ch->name);
@


1.182
log
@Corrected some missing {} errors.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.181 2000/08/18 01:43:24 mud Exp $";
d3244 1
a3244 1
    if (IS_SET(ch->mhs, MHS_GLADIATOR))
d3246 1
a3246 1
       send_to_char("Gladiator's do not slice.\n\r",ch);
d3391 1
a3391 1
    if (IS_SET(ch->mhs, MHS_GLADIATOR))
d3393 1
a3393 1
       send_to_char("Gladiator's do not steal.\n\r",ch);
@


1.181
log
@Kenders get +10% in slice and no stealing without at least 2% in the skill!
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.180 2000/08/18 01:28:09 mud Exp $";
d1031 1
d1036 1
d1071 1
d1076 1
@


1.180
log
@Kenders get a 10% better chance on steals
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.179 2000/08/17 15:41:17 mud Exp $";
d3320 1
a3320 1
    percent = get_skill(ch,gsn_slice); 
d3329 2
d3457 4
a3460 2
    if (get_skill(ch,gsn_steal) >= 1)
    */
d3472 5
@


1.179
log
@ more implementation of sanction command
 finished all but no_clan_skill
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.178 2000/08/11 22:53:43 mud Exp $";
d3466 2
@


1.178
log
@ added in "the almighty" deity
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.177 2000/07/21 23:51:38 mud Exp $";
d3828 8
d4096 7
d4219 7
d4320 7
@


1.177
log
@decalre gladiator.h
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.176 2000/07/21 23:45:26 mud Exp $";
d3424 6
d3479 1
a3479 1
  switch(number_range(0,3))
d3494 7
@


1.176
log
@glads can not quaff or withstand or orb after arena starts
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.175 2000/07/12 21:24:56 mud Exp $";
d31 1
@


1.175
log
@ adjusted chances for slice/steal
 Fixed bug with victim needing to see obj for thief to slice
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.174 2000/07/06 15:35:56 mud Exp $";
d2948 7
@


1.174
log
@ added in message to room for failed brew attempts
 changed min position for hide to POS_FIGHTING
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.173 2000/07/04 17:50:16 mud Exp $";
d3282 1
a3282 1
    if ( ( obj = get_obj_wear(victim, arg1) ) == NULL )
@


1.173
log
@ no level restrictions on trans'ing mobs, still there for transing PC's

 modified potion costs for alchemists

 fixed a couple bugs in gladiator betting.
 added in check to stop betting when event is a team event
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.172 2000/06/27 23:30:17 mud Exp $";
d152 1
@


1.172
log
@gladiators saccing
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.171 2000/06/19 22:45:07 mud Exp $";
d56 3
a58 3
#define COST_ACCURACY	750
#define COST_SPEED	1000
#define COST_MAGIC_RESISTANCE 	2000
d60 2
a61 2
#define COST_RESTORATION	200
#define COST_MOLOTOV	300
@


1.171
log
@added check improves to do_brew
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.170 2000/06/17 21:33:11 mud Exp $";
d2863 6
@


1.170
log
@can not steal or slice while hold person affected
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.169 2000/06/17 19:06:03 mud Exp $";
d152 1
d155 1
@


1.169
log
@to change to too in steal
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.168 2000/05/28 22:35:46 mud Exp $";
d3264 5
d3399 6
@


1.168
log
@only people with steal skill can steal
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.167 2000/05/27 02:44:08 mud Exp $";
d3398 1
a3398 1
        send_to_char("You're to exhausted.\n\r",ch);
@


1.167
log
@Kit Changing: REmove sepcial effects ( ennemy, spec)
Float: swim skill helps you vs floating away
Hold: casting level capped similar to sleep
Position for zap, brandish, quaff, recite set to Fighting
Check on eating pills for position at least of fighting
Snare: duration similar to hold

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.166 2000/05/21 02:54:08 mud Exp $";
d3384 6
d3420 1
d3422 1
@


1.166
log
@gladiators cant steal or slice
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.165 2000/05/19 13:43:58 mud Exp $";
d2126 5
@


1.165
log
@ more adjustments to alchemy, as well as removeing CODE_TES #ifdef's
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.164 2000/05/18 14:27:18 mud Exp $";
d3218 5
d3357 6
@


1.164
log
@ YABFIB ( yet another bug fix in brew)
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.163 2000/05/18 14:22:48 mud Exp $";
d58 1
a58 1
#define COST_MAGIC_RESISTANCE 	2500
d60 2
a61 2
#define COST_RESTORATION	2000
#define COST_MOLOTOV	1500
a65 1
#ifdef CODE_TEST
a190 1
#endif
@


1.163
log
@ another bug fix in do_brew()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.162 2000/05/18 14:17:00 mud Exp $";
d171 1
a171 1
       potion->short_descr = str_dup(buf);
@


1.162
log
@ whoops, use strcat not str_cat
 beat me, please
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.161 2000/05/18 14:14:16 mud Exp $";
d75 1
a75 1
			  "green", "yellow", "pink", "aqua", "magenta",
d169 3
a171 1
       strcat(potion->name, colour);
@


1.161
log
@ more changes to grenade and brew
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.160 2000/05/17 03:14:49 mud Exp $";
d169 1
a169 1
       str_cat(potion->name, colour);
@


1.160
log
@ finally got damage type right I think
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.159 2000/05/17 03:02:26 mud Exp $";
d169 1
@


1.159
log
@ last change to grenade for now
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.158 2000/05/17 02:49:55 mud Exp $";
a169 1
        potion->value[3] = attack_table[attack[num]].damage;
@


1.158
log
@ still trying to get damagem messages for grenades working
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.157 2000/05/17 02:36:12 mud Exp $";
d170 2
a171 2
        potion->value[4] = attack_table[attack[num]].damage;
        potion->value[3] = attack[num];
@


1.157
log
@ changes to grenade to get damage messages showing properly
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.156 2000/05/16 20:35:34 mud Exp $";
d170 1
a170 1
        potion->value[4] = attack[num];
@


1.156
log
@ Turned alchemist kit on, fixed bug with molotov log descriptions

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.155 2000/05/16 15:22:05 mud Exp $";
d171 1
a171 1

@


1.155
log
@ changed placing of #ifdef so interp.c doesn't go spanky :)
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.154 2000/05/16 15:17:59 mud Exp $";
d166 3
@


1.154
log
@Added in a #ifdef CODETEST flag
-Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.153 2000/05/16 15:01:27 mud Exp $";
a63 1
#ifdef CODE_TEST
d66 1
d186 2
a188 1
#endif
@


1.153
log
@ Addition of alchemist kit.
 act_obj.c : added "brew" command to create potions
 const.c   : added in a couple new damaget types into attack_table
 fight.c   : grenade code for molotov cocktails
 handler.c : modified wait_state for speed potion
 mag2.c    : spells for use with alchemist potions

- Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.152 2000/05/13 22:57:03 mud Exp $";
d64 1
d187 1
@


1.152
log
@remove unused 'number' in declarations
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.151 2000/05/13 22:55:10 mud Exp $";
d67 1
a67 1
    int chance;
d69 2
d72 4
d98 1
a98 1
/*
d128 1
a128 1
    else */
d161 10
a170 6
	if ( ch->level >  5 ) potion->value[1] = 11;
	if ( ch->level > 15 ) potion->value[1] = 12;
	if ( ch->level > 25 ) potion->value[1] = 13;
	if ( ch->level > 35 ) potion->value[1] = 14;
	if ( ch->level > 45 ) potion->value[1] = 15;
        switch ( ch->in_room->sector_type )
d172 3
a174 3
            case SECT_MAGELAB_SIMPLE: potion->value[0] = 1; break;
            case SECT_MAGELAB_INTERMEDIATE: potion->value[0] = 2; break;
	    case SECT_MAGELAB_ADVANCED: potion->value[0] = 3; break;
d177 4
@


1.151
log
@Cleaning up warnings - declare do_help
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.150 2000/04/22 06:45:07 mud Exp $";
d1693 1
a1693 1
    int number, count;
@


1.150
log
@Repair shop fixes
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.149 2000/04/22 06:37:08 mud Exp $";
d36 1
@


1.149
log
@ Repair shop act messages changed
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.148 2000/04/22 04:54:25 mud Exp $";
d1438 7
a1444 1
      cost = (original - condition)* 2000;
d1447 3
a1449 1
	send_to_char( "You can't afford my services.\n\r", ch);
d1457 3
a1459 1
      send_to_char( "Your weapon has been fixed. \n\r", ch);
@


1.148
log
@Fixed the sleeping bag issue and float code
Added moving players in air / sea zones
Added the weaponsmith code
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.147 2000/04/22 03:40:28 mud Exp $";
d1465 7
a1471 1
      cost = (original - condition)* 200;
d1474 3
a1476 1
	send_to_char( "You can't afford my services.\n\r", ch);
d1484 3
a1486 1
      send_to_char( "Your armor has been fixed. \n\r", ch);
@


1.147
log
@ Added a armourer check in give function
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.146 2000/04/18 20:33:46 mud Exp $";
d1426 27
d1468 1
a1468 1
	send_to_char( "you can't afford my services.\n\r", ch);
d1476 1
a1476 1
      send_to_char( "all fixed. \n\r", ch);
a1479 2
    else
    {
a1484 1
    }
@


1.146
log
@fixed act ( entries
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.145 2000/04/18 19:50:52 mud Exp $";
d1426 29
d1460 1
@


1.145
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.144 2000/04/17 22:00:45 mud Exp $";
d2958 2
a2959 2
      act ("You fail to invoke $p.",ch,staff,NULL,TO_CHAR);
      act ("...and nothing happens.",ch,NULL,NULL,TO_ROOM);
@


1.144
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.143 2000/04/17 21:04:00 mud Exp $";
d168 2
a169 2
    act("$n has created $p!",ch,potion,NULL,TO_ROOM);
    act("You create $p!",ch,potion,NULL,TO_CHAR);
d240 2
a241 2
	act(buf,ch,NULL,NULL,TO_CHAR);
	act(buf2,ch,NULL,NULL,TO_ROOM);
d311 2
a312 2
    act(buf,ch,NULL,NULL,TO_CHAR);
    act(buf2,ch,NULL,NULL,TO_ROOM);
d374 1
a374 1
      ch, NULL, obj->name, TO_CHAR );
d382 1
a382 1
      ch, NULL, obj->name, TO_CHAR );
d388 1
a388 1
  act("Corpse looting is not permitted.",ch,NULL,NULL,TO_CHAR );
d398 1
a398 1
        ch,obj,gch,TO_CHAR);
d416 2
a417 2
  act( "You get $p from $P.", ch, obj, container, TO_CHAR );
  act( "$n gets $p from $P.", ch, obj, container, TO_ROOM );
d424 2
a425 2
  act( "You get $p.", ch, obj, container, TO_CHAR );
  act( "$n gets $p.", ch, obj, container, TO_ROOM );
d434 1
a434 1
       act( "$N can't carry that much weight.", ch, NULL, ch, TO_CHAR );
d633 1
a633 1
      act( "I see no $T here.", ch, NULL, arg2, TO_CHAR );
d666 1
a666 1
        ch, NULL, arg2, TO_CHAR );
d700 1
a700 1
      ch, NULL, arg2, TO_CHAR );
d703 1
a703 1
      ch, NULL, arg2, TO_CHAR );
d743 1
a743 1
    act( "I see no $T here.", ch, NULL, arg1, TO_CHAR );
d834 1
a834 1
        act( "I see no $T here.", ch, NULL, &arg1[4], TO_CHAR );
d849 1
a849 1
      act( "I see no $T here.", ch, NULL, arg2, TO_CHAR );
d872 1
a872 1
      act( "The $d is closed.", ch, NULL, container->name, TO_CHAR );
d883 1
a883 1
        ch, NULL, arg2, TO_CHAR );
d913 1
a913 1
      ch, NULL, arg2, TO_CHAR );
d916 1
a916 1
      ch, NULL, arg2, TO_CHAR );
d953 1
a953 1
  act( "I see no $T here.", ch, NULL, arg2, TO_CHAR );
d965 1
a965 1
  act( "The $d is closed.", ch, NULL, container->name, TO_CHAR );
d1016 2
a1017 2
      act("$n puts $p on $P.",ch,obj,container, TO_ROOM);
      act("You put $p on $P.",ch,obj,container, TO_CHAR);
d1021 2
a1022 2
      act( "$n puts $p in $P.", ch, obj, container, TO_ROOM );
      act( "You put $p in $P.", ch, obj, container, TO_CHAR );
d1053 2
a1054 2
                  act("$n puts $p on $P.",ch,obj,container, TO_ROOM);
                  act("You put $p on $P.",ch,obj,container, TO_CHAR);
d1058 2
a1059 2
        act( "$n puts $p in $P.", ch, obj, container, TO_ROOM );
        act( "You put $p in $P.", ch, obj, container, TO_CHAR );
d1160 1
a1160 1
  act( "$n drops some coins.", ch, NULL, NULL, TO_ROOM );
d1182 2
a1183 2
  act( "$n drops $p.", ch, obj, NULL, TO_ROOM );
  act( "You drop $p.", ch, obj, NULL, TO_CHAR );
d1186 2
a1187 2
      act("$p dissolves into smoke.",ch,obj,NULL,TO_ROOM);
      act("$p dissolves into smoke.",ch,obj,NULL,TO_CHAR);
d1207 2
a1208 2
    act( "$n drops $p.", ch, obj, NULL, TO_ROOM );
    act( "You drop $p.", ch, obj, NULL, TO_CHAR );
d1211 2
a1212 2
                  act("$p dissolves into smoke.",ch,obj,NULL,TO_ROOM);
                  act("$p dissolves into smoke.",ch,obj,NULL,TO_CHAR);
d1222 1
a1222 1
        ch, NULL, arg, TO_CHAR );
d1225 1
a1225 1
        ch, NULL, &arg[4], TO_CHAR );
d1297 1
a1297 1
      act( "$N can't carry that much weight.", ch, NULL, victim, TO_CHAR );
d1308 1
a1308 1
      act( "$N can't carry that much weight.", ch, NULL, victim, TO_CHAR );
d1316 2
a1317 2
  act( buf, ch, NULL, victim, TO_VICT    );
  act( "$n gives $N some coins.",  ch, NULL, victim, TO_NOTVICT );
d1319 1
a1319 1
  act( buf, ch, NULL, victim, TO_CHAR    );
d1339 1
a1339 1
        ,victim,NULL,ch,TO_VICT);
d1357 1
a1357 1
        victim,NULL,ch,TO_VICT);
d1397 1
a1397 1
      ch,NULL,victim,TO_CHAR);
d1410 1
a1410 1
  act( "$N has $S hands full.", ch, NULL, victim, TO_CHAR );
d1416 1
a1416 1
  act( "$N can't carry that much weight.", ch, NULL, victim, TO_CHAR );
d1422 1
a1422 1
  act( "$N can't see it.", ch, NULL, victim, TO_CHAR );
d1428 3
a1430 3
    act( "$n gives $p to $N.", ch, obj, victim, TO_NOTVICT );
    act( "$n gives you $p.",   ch, obj, victim, TO_VICT    );
    act( "You give $p to $N.", ch, obj, victim, TO_CHAR    );
d1489 2
a1490 2
	act("$n licks $p.",ch,obj,NULL,TO_ROOM);
	act("You lick $p.",ch,obj,NULL,TO_CHAR);
d1527 1
a1527 1
      act("You fail to poison $p.",ch,obj,NULL,TO_CHAR);
d1533 2
a1534 2
      act("$n treats $p with deadly poison.",ch,obj,NULL,TO_ROOM);
      act("You treat $p with deadly poison.",ch,obj,NULL,TO_CHAR);
d1544 1
a1544 1
  act("You fail to poison $p.",ch,obj,NULL,TO_CHAR);
d1561 1
a1561 1
            act("You can't seem to envenom $p.",ch,obj,NULL,TO_CHAR);
d1574 1
a1574 1
            act("$p is already envenomed.",ch,obj,NULL,TO_CHAR);
d1592 2
a1593 2
            act("$n coats $p with deadly venom.",ch,obj,NULL,TO_ROOM);
      act("You coat $p with venom.",ch,obj,NULL,TO_CHAR);
d1598 1
a1598 1
      act("You fail to envenom $p.",ch,obj,NULL,TO_CHAR);
d1605 1
a1605 1
    act("You can't poison $p.",ch,obj,NULL,TO_CHAR);
d1700 1
a1700 1
    act( buf, ch, obj,fountain, TO_CHAR );
d1703 1
a1703 1
    act(buf,ch,obj,fountain,TO_ROOM);
d1749 1
a1749 1
  act(buf,ch,out,NULL,TO_CHAR);
d1753 1
a1753 1
  act(buf,ch,out,NULL,TO_ROOM);
d1796 1
a1796 1
  act("There's nothing in $p to pour.",ch,out,NULL,TO_CHAR);
d1802 1
a1802 1
  act("$p is already filled to the top.",ch,in,NULL,TO_CHAR);
d1816 1
a1816 1
      act(buf,ch,out,in,TO_CHAR);
d1819 1
a1819 1
      act(buf,ch,out,in,TO_ROOM);
d1825 1
a1825 1
        act(buf,ch,NULL,vch,TO_CHAR);
d1830 1
a1830 1
    act(buf,ch,NULL,vch,TO_VICT);
d1834 1
a1834 1
        act(buf,ch,NULL,vch,TO_NOTVICT);
d1939 1
a1939 1
  ch, obj, liq_table[liquid].liq_name, TO_ROOM );
d1941 1
a1941 1
  ch, obj, liq_table[liquid].liq_name, TO_CHAR );
d1984 1
a1984 1
  act( "$n chokes and gags.", ch, NULL, NULL, TO_ROOM );
d2063 2
a2064 2
    act( "$n eats $p.",  ch, obj, NULL, TO_ROOM );
    act( "You eat $p.", ch, obj, NULL, TO_CHAR );
d2112 1
a2112 1
      act( "$n chokes and gags.", ch, 0, 0, TO_ROOM );
d2187 2
a2188 2
   act( "$n removes all of $s equipment.", ch, NULL, NULL, TO_ROOM );
   act( "You remove all of your equipment.", ch, NULL, NULL, TO_CHAR );
d2206 1
a2206 1
  act( "You can't remove $p.", ch, obj, NULL, TO_CHAR );
d2211 2
a2212 2
    act( "$n stops using $p.", ch, obj, NULL, TO_ROOM );
    act( "You stop using $p.", ch, obj, NULL, TO_CHAR );
d2269 1
a2269 1
      ch, obj, NULL, TO_ROOM );
d2276 2
a2277 2
	act("$n tries to wear $p and shudders in pain.",ch,obj,NULL,TO_ROOM);
	act("Your pact with the Netherworld forbids it.",ch,obj,NULL,TO_CHAR);
d2283 2
a2284 2
	act("$n tries to wear $p and it doesn't fit.", ch, obj, NULL, TO_ROOM);
	act("You try to wear $p and it doesn't fit.", ch, obj, NULL, TO_CHAR);
d2292 2
a2293 2
  act( "$n lights $p and holds it.", ch, obj, NULL, TO_ROOM );
  act( "You light $p and hold it.",  ch, obj, NULL, TO_CHAR );
d2308 2
a2309 2
      act( "$n wears $p on $s left finger.",    ch, obj, NULL, TO_ROOM );
      act( "You wear $p on your left finger.",  ch, obj, NULL, TO_CHAR );
d2316 2
a2317 2
      act( "$n wears $p on $s right finger.",   ch, obj, NULL, TO_ROOM );
      act( "You wear $p on your right finger.", ch, obj, NULL, TO_CHAR );
d2337 2
a2338 2
      act( "$n wears $p around $s neck.",   ch, obj, NULL, TO_ROOM );
      act( "You wear $p around your neck.", ch, obj, NULL, TO_CHAR );
d2345 2
a2346 2
      act( "$n wears $p around $s neck.",   ch, obj, NULL, TO_ROOM );
      act( "You wear $p around your neck.", ch, obj, NULL, TO_CHAR );
d2360 2
a2361 2
  act( "$n wears $p on $s torso.",   ch, obj, NULL, TO_ROOM );
  act( "You wear $p on your torso.", ch, obj, NULL, TO_CHAR );
d2370 2
a2371 2
  act( "$n wears $p on $s head.",   ch, obj, NULL, TO_ROOM );
  act( "You wear $p on your head.", ch, obj, NULL, TO_CHAR );
d2380 2
a2381 2
  act( "$n wears $p on $s legs.",   ch, obj, NULL, TO_ROOM );
  act( "You wear $p on your legs.", ch, obj, NULL, TO_CHAR );
d2390 2
a2391 2
  act( "$n wears $p on $s feet.",   ch, obj, NULL, TO_ROOM );
  act( "You wear $p on your feet.", ch, obj, NULL, TO_CHAR );
d2400 2
a2401 2
  act( "$n wears $p on $s hands.",   ch, obj, NULL, TO_ROOM );
  act( "You wear $p on your hands.", ch, obj, NULL, TO_CHAR );
d2410 2
a2411 2
  act( "$n wears $p on $s arms.",   ch, obj, NULL, TO_ROOM );
  act( "You wear $p on your arms.", ch, obj, NULL, TO_CHAR );
d2420 2
a2421 2
  act( "$n wears $p about $s torso.",   ch, obj, NULL, TO_ROOM );
  act( "You wear $p about your torso.", ch, obj, NULL, TO_CHAR );
d2430 2
a2431 2
  act( "$n wears $p about $s waist.",   ch, obj, NULL, TO_ROOM );
  act( "You wear $p about your waist.", ch, obj, NULL, TO_CHAR );
d2447 1
a2447 1
    ch, obj, NULL, TO_ROOM );
d2449 1
a2449 1
    ch, obj, NULL, TO_CHAR );
d2457 1
a2457 1
    ch, obj, NULL, TO_ROOM );
d2459 1
a2459 1
    ch, obj, NULL, TO_CHAR );
d2490 2
a2491 2
  act( "$n wears $p as a shield.", ch, obj, NULL, TO_ROOM );
  act( "You wear $p as a shield.", ch, obj, NULL, TO_CHAR );
d2549 2
a2550 2
      act( "$n wields $p.", ch, obj, NULL, TO_ROOM );
      act( "You wield $p.", ch, obj, NULL, TO_CHAR );
d2559 2
a2560 2
     act("$n wields $p.", ch, obj, NULL, TO_ROOM);
     act("You wield $p.", ch, obj, NULL, TO_CHAR);
d2573 1
a2573 1
            act("$p feels like a part of you!",ch,obj,NULL,TO_CHAR);
d2575 1
a2575 1
            act("You feel quite confident with $p.",ch,obj,NULL,TO_CHAR);
d2577 1
a2577 1
            act("You are skilled with $p.",ch,obj,NULL,TO_CHAR);
d2579 1
a2579 1
            act("Your skill with $p is adequate.",ch,obj,NULL,TO_CHAR);
d2581 1
a2581 1
            act("$p feels a little clumsy in your hands.",ch,obj,NULL,TO_CHAR);
d2583 1
a2583 1
            act("You fumble and almost drop $p.",ch,obj,NULL,TO_CHAR);
d2586 1
a2586 1
                ch,obj,NULL,TO_CHAR);
d2596 2
a2597 2
  act( "$n holds $p in $s hand.",   ch, obj, NULL, TO_ROOM );
  act( "You hold $p in your hand.", ch, obj, NULL, TO_CHAR );
d2606 2
a2607 2
  act("$n releases $p to float next to $m.",ch,obj,NULL,TO_ROOM);
  act("You release $p and it floats next to you.",ch,obj,NULL,TO_CHAR);
d2715 1
a2715 1
      ch, NULL, NULL, TO_ROOM );
d2743 1
a2743 1
  act( "$p is not an acceptable sacrifice.", ch, obj, 0, TO_CHAR );
d2793 1
a2793 1
    act( "$n sacrifices $p to $s deity.", ch, obj, NULL, TO_ROOM );
d2841 2
a2842 2
    act( "$n quaffs $p.", ch, obj, NULL, TO_ROOM );
    act( "You quaff $p.", ch, obj, NULL ,TO_CHAR );
d2899 2
a2900 2
    act( "$n recites $p.", ch, scroll, NULL, TO_ROOM );
    act( "You recite $p.", ch, scroll, NULL, TO_CHAR );
d2953 2
a2954 2
  act( "$n brandishes $p.", ch, staff, NULL, TO_ROOM );
  act( "You brandish $p.",  ch, staff, NULL, TO_CHAR );
d3001 2
a3002 2
  act( "$n's $p blazes bright and is gone.", ch, staff, NULL, TO_ROOM );
  act( "Your $p blazes bright and is gone.", ch, staff, NULL, TO_CHAR );
d3079 2
a3080 2
      act( "$n zaps $N with $p.", ch, wand, victim, TO_ROOM );
      act( "You zap $N with $p.", ch, wand, victim, TO_CHAR );
d3084 2
a3085 2
      act( "$n zaps $P with $p.", ch, wand, obj, TO_ROOM );
      act( "You zap $P with $p.", ch, wand, obj, TO_CHAR );
d3092 1
a3092 1
     ch,wand,NULL,TO_CHAR);
d3094 1
a3094 1
     ch,wand,NULL,TO_ROOM);
d3106 2
a3107 2
  act( "$n's $p explodes into fragments.", ch, wand, NULL, TO_ROOM );
  act( "Your $p explodes into fragments.", ch, wand, NULL, TO_CHAR );
d3322 2
a3323 2
  act( "$n tried to steal from you.\n\r", ch, NULL, victim, TO_VICT    );
  act( "$n tried to steal from $N.\n\r",  ch, NULL, victim, TO_NOTVICT );
d3764 1
a3764 1
  act( "$n bought $N as a pet.", ch, NULL, pet, TO_ROOM );
d3807 1
a3807 1
    keeper, NULL, ch, TO_VICT );
d3815 1
a3815 1
	keeper,NULL,ch, TO_VICT );
d3835 1
a3835 1
        keeper,NULL,ch,TO_VICT);
d3845 1
a3845 1
        keeper,obj,ch,TO_VICT);
d3848 1
a3848 1
        keeper, obj, ch, TO_VICT );
d3856 1
a3856 1
    keeper, obj, ch, TO_VICT );
d3879 1
a3879 1
      act("You haggle with $N.",ch,NULL,keeper,TO_CHAR);
d3886 1
a3886 1
      act(buf,ch,obj,NULL,TO_ROOM);
d3888 1
a3888 1
      act(buf,ch,obj,NULL,TO_CHAR);
d3892 1
a3892 1
      act( "$n buys $p.", ch, obj, NULL, TO_ROOM );
d3894 1
a3894 1
      act( buf, ch, obj, NULL, TO_CHAR );
d4051 1
a4051 1
      keeper, NULL, ch, TO_VICT );
d4064 1
a4064 1
  act("$n doesn't see what you are offering.",keeper,NULL,ch,TO_VICT);
d4070 1
a4070 1
  act( "$n looks uninterested in $p.", keeper, obj, ch, TO_VICT );
d4077 1
a4077 1
      keeper,obj,ch,TO_VICT);
d4081 1
a4081 1
    act( "$n sells $p.", ch, obj, NULL, TO_ROOM );
d4094 1
a4094 1
    act( buf, ch, obj, NULL, TO_CHAR );
d4144 1
a4144 1
      keeper, NULL, ch, TO_VICT );
d4151 2
a4152 2
        act("$n doesn't see what you are offering.",keeper,NULL,ch,TO_VICT);
        return;
d4163 1
a4163 1
  act( "$n looks uninterested in $p.", keeper, obj, ch, TO_VICT );
d4170 1
a4170 1
    act( buf, keeper, obj, ch, TO_VICT );
@


1.143
log
@Changed kurijitsu check
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.142 2000/04/17 20:15:25 mud Exp $";
d1335 1
a1335 1
      if (change < 1 && can_see(victim,ch))
d1345 1
a1345 1
      else if (can_see(victim,ch))
d3523 1
a3523 1
    if ( !can_see( keeper, ch ) )
@


1.142
log
@ Added delay to hide.
 If hidden, attmpting a slice unhides you.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.141 2000/04/15 17:00:33 mud Exp $";
d3126 4
a3129 1
    
@


1.141
log
@ changed can_see back to how it was before bug fixes.
 modified level mods in steeal and slice

 -Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.140 2000/04/06 01:45:45 mud Exp $";
d3155 4
@


1.140
log
@ Increased level difference adjustment in steal and slice

 -Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.139 2000/03/28 01:20:16 mud Exp $";
d3188 1
a3188 1
    percent -= (victim->level - ch->level)*6;
d3298 1
a3298 1
    percent += (victim->level - ch->level)*5;
@


1.139
log
@ Fixed a couple of obscue bugs in steal caused by misplaced victim and ch's

 Alos, you will now only yell on a failed steal if you are awake.
age.
----------------------------------------------------------------------
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.138 2000/03/20 23:10:51 mud Exp $";
d3188 1
a3188 1
    percent -= (victim->level - ch->level)*2;
d3298 1
a3298 1
    percent += (victim->level - ch->level);
@


1.138
log
@move the stolen data into a steal_data with long int
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.137 2000/03/14 21:39:08 mud Exp $";
d3317 2
d3336 1
d3422 1
a3422 1
    if ( !can_drop_obj( ch, obj )
@


1.137
log
@use pIndexData->vnum for garour eating
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.136 2000/03/14 21:34:39 mud Exp $";
d3218 1
a3218 1
       ch->killer_data[PC_SLICES] += 1 ;
d3406 2
a3407 2
     ch->killer_data[PC_STOLEN_GOLD] += gold ;
     ch->killer_data[PC_STOLEN_SILVER] += silver ;
d3446 1
a3446 1
       ch->killer_data[PC_STOLEN_ITEMS] += 1 ;
@


1.136
log
@were's and mummies cant drink
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.135 2000/03/14 21:29:50 mud Exp $";
d2047 1
a2047 1
	&& obj->vnum > 100
@


1.135
log
@make were's and mummies eat specially like vamps
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.134 2000/03/14 01:43:22 mud Exp $";
d1916 3
a1918 2
    if ( IS_SET(ch->act,PLR_VAMP) &&
	 liquid != liq_lookup("blood") )
d1922 14
@


1.134
log
@wiznet steal line only if !NPC
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.133 2000/03/13 17:58:19 mud Exp $";
d2030 18
d2060 22
a2081 7
      condition = ch->pcdata->condition[COND_HUNGER];
      gain_condition( ch, COND_FULL, obj->value[0] );
      gain_condition( ch, COND_HUNGER, obj->value[1]);
      if ( condition == 0 && ch->pcdata->condition[COND_HUNGER] > 0 )
    send_to_char( "You are no longer hungry.\n\r", ch );
      else if ( ch->pcdata->condition[COND_FULL] > 40 )
    send_to_char( "You are full.\n\r", ch );
@


1.133
log
@stolen adjustments
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.132 2000/03/12 02:02:31 mud Exp $";
a3352 3
  sprintf(buf,"$N stole %d gold and %d silver from %s.",
	  gold,silver,victim->name);
  wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);
d3355 3
a3393 2
    sprintf(buf,"$N stole %s from %s.",obj->short_descr,victim->name);
    wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);
d3395 3
d3399 1
@


1.132
log
@fix crash bug and get all bug
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.131 2000/03/12 01:55:20 mud Exp $";
d3353 3
d3394 2
@


1.131
log
@owner = null?
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.130 2000/03/12 01:50:47 mud Exp $";
d748 2
a749 1
      if (obj->item_type == ITEM_CORPSE_PC && !IS_IMMORTAL(ch))
d790 3
a792 4
	    /*
            if (obj->item_type == ITEM_CORPSE_PC && !IS_IMMORTAL(ch))
	    */
            if (obj->item_type == ITEM_CORPSE_PC && obj->owner != NULL )
@


1.130
log
@o
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.129 2000/03/12 01:48:12 mud Exp $";
d792 1
a792 1
            if (obj->item_type == ITEM_CORPSE_PC )
a797 1
		  /*
a802 1
		  */
a804 2
	       /*

d815 1
a815 1
		       cfound = TRUE;
a818 1
	      */
d822 1
a822 2
	   /*
	   if (cfound)
a824 1
	   */
@


1.129
log
@poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.128 2000/03/12 01:40:13 mud Exp $";
d789 1
d791 2
@


1.128
log
@p
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.127 2000/03/12 01:36:04 mud Exp $";
d795 1
d801 1
@


1.127
log
@comment out till we fidn it
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.126 2000/03/12 01:31:53 mud Exp $";
a788 1
	    /*
d802 2
d818 1
a819 1
	   */
@


1.126
log
@debugging
-p
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.125 2000/03/12 01:26:25 mud Exp $";
a714 1
    char buf[MAX_STRING_LENGTH];
d721 1
a721 1
    bool cfound = FALSE;
d789 1
a816 1
             send_to_char("after\n\r",ch);
d818 1
@


1.125
log
@debug
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.124 2000/03/12 01:18:39 mud Exp $";
a781 1
             send_to_char("starting\n\r",ch);
a802 1
             send_to_char("before\n\r",ch);
d821 1
a821 1
             send_to_char("b if",ch);
d825 1
a826 1
             send_to_char("a if",ch);
@


1.124
log
@debugging crash
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.123 2000/03/12 01:09:02 mud Exp $";
d782 1
d804 1
a804 1
             send_to_char("before",ch);
d819 1
a819 1
             send_to_char("after",ch);
@


1.123
log
@get all corpse crash
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.122 2000/03/12 00:32:40 mud Exp $";
d803 1
d818 1
d822 1
d827 1
@


1.122
log
@new thieving data
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.121 2000/03/10 00:24:23 mud Exp $";
d722 1
d813 1
a813 2
	               send_to_char("You are not allowed to get the corpse.\n\r",ch);
	               continue;
d820 4
a823 1
           get_obj( ch, obj, NULL );
d3351 5
a3355 2
  ch->killer_data[PC_STOLEN_GOLD] += gold ;
  ch->killer_data[PC_STOLEN_SILVER] += silver ;
d3389 2
a3390 1
    ch->killer_data[PC_STOLEN_ITEMS] += 1 ;
@


1.121
log
@fix get all to keep going after corpse
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.120 2000/03/06 22:44:48 mud Exp $";
d765 3
a767 1
	       if(ch->clan != victim->clan || ch->clan == clan_lookup("loner"))
d784 3
a786 9
    obj_next = obj->next_content;
    if ( ( arg1[3] == '\0' || is_name( &arg1[4], obj->name ) )
    &&   can_see_obj( ch, obj ) )
    {
      /* Only Clanmates and Groupmates or Yourself can get your corpse */
      if (obj->item_type == ITEM_CORPSE_PC && !IS_IMMORTAL(ch))
      {
	 found = FALSE;
         for ( victim = char_list; victim != NULL; victim = victim_next )
d788 2
a789 2
            victim_next  = victim->next;
            if (is_name(obj->owner,victim->name))
d791 27
a817 4
               found = TRUE;
               break;
            }
         }
d819 4
a822 17
         if(found && victim != ch) 
	 {
            if (!is_same_group( victim, ch ))
	    {
	       if(ch->clan != victim->clan || ch->clan == clan_lookup("loner"))
	       {
	          send_to_char("You are not allowed to get the corpse.\n\r",ch);
	          break;
	       }
	    }
	 }
      }

	found = TRUE;
        get_obj( ch, obj, NULL );
    }
      }
d3165 1
d3348 2
d3383 1
@


1.120
log
@do_steal updates last_attacked_by
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.119 2000/02/25 00:00:48 mud Exp $";
d807 1
a807 1
	          return;
@


1.119
log
@Turn on the Pfresh
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.118 2000/02/23 03:34:07 mud Exp $";
d3274 1
a3274 1
  if (!IS_NPC(victim) && ch->pcdata) ch->pcdata->quit_time = 5;  
d3284 1
d3287 10
@


1.118
log
@finish get
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.117 2000/02/23 02:15:53 mud Exp $";
d544 3
d548 1
a548 1
	ch->train < skill_table[weapon].rating[ch->class] )
d550 1
a550 1
	send_to_char("You don't have enough trains to specialize.\n\r",ch);
d596 7
a602 4
    ch->train -= skill_table[weapon].rating[ch->class];
    ch->pcdata->specialize = weapon;
    send_to_char("You are now specialized.\n\r",ch);
    return;
@


1.117
log
@still trying get corpse
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.116 2000/02/23 01:03:47 mud Exp $";
d742 1
a742 1
      if (obj->item_type == ITEM_CORPSE_PC)
a743 1
      /*
d745 1
a745 1
         for ( victim = char_list; victim != NULL; victim = victim->next )
d747 7
a753 16
	 sprintf(buf,"v = %s o = %s f = %d\n\r",victim->name,obj->owner,found);
	 send_to_char(buf,ch);
            if(!is_name( obj->owner, victim->name ) )
               continue;
	    found = TRUE;
	    break;
	 }
	 */
    for ( victim = char_list; victim != NULL; victim = victim_next )
    {
  victim_next  = victim->next;
  if (is_name(obj->owner,victim->name))
  {
     found = TRUE;
     break;
     }
d755 1
a755 3
    }

         if(found) 
d757 7
a763 5
	    if (ch != victim && ch->clan != victim->clan &&
	     !is_same_group(ch,victim))
            {
	       send_to_char("You are not allowed to get the corpse.\n\r",ch);
	       return;
d780 28
a807 1
        found = TRUE;
@


1.116
log
@dogetdogetdoget
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.115 2000/02/23 00:59:04 mud Exp $";
d708 1
d755 11
a767 2
	 */
	 if (victim=get_char_world(ch,obj->owner) != NULL)
@


1.115
log
@playing with do_get
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.114 2000/02/23 00:33:26 mud Exp $";
d759 1
a759 1
	    if (str_cmp(ch->name,victim->name) && ch->clan != victim->clan &&
@


1.114
log
@debug do_get
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.113 2000/02/22 23:45:58 mud Exp $";
d743 1
d756 2
d759 1
a759 1
	    if (!str_cmp(ch->name,victim->name) && ch->clan != victim->clan &&
@


1.113
log
@can only drag clanmates/groupmates
only canmates/groupmates can get your corpse
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.112 2000/02/20 08:30:06 mud Exp $";
d708 1
d746 2
@


1.112
log
@ removed all sorts fo debug statements now the the bug has been removed

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.111 2000/02/20 07:45:14 mud Exp $";
d707 1
d737 23
@


1.111
log
@ FOUND the crash bug, can_carry_n and can_carry_w crashed teh game
 since it checked ch->pcdata for mobs....KABOOM
 Minister
 i removed my temp kludges in do_get and do_give and added some
 IS_NPC check before every logout_tracker
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.110 2000/02/20 06:49:29 mud Exp $";
a364 2
sprintf(log_buf, " 1 get_obj " );
bug(log_buf,0);
a366 2
sprintf(log_buf, " 2 get_obj " );
bug(log_buf,0);
a370 2
sprintf(log_buf, " 2b get_obj " );
bug(log_buf,0);
a374 2
sprintf(log_buf, " 3 get_obj " );
bug(log_buf,0);
a377 2
sprintf(log_buf, " 3b get_obj " );
bug(log_buf,0);
a380 2
sprintf(log_buf, " 4 get_obj " );
bug(log_buf,0);
a385 4
sprintf(log_buf, " 4b get_obj " );
bug(log_buf,0);
sprintf(log_buf, " 5 get_obj " );
bug(log_buf,0);
a387 2
sprintf(log_buf, " 6 get_obj " );
bug(log_buf,0);
a391 2
sprintf(log_buf, " 7 get_obj " );
bug(log_buf,0);
a393 2
sprintf(log_buf, " 8 get_obj " );
bug(log_buf,0);
a396 2
sprintf(log_buf, " 9 get_obj " );
bug(log_buf,0);
a402 2
sprintf(log_buf, " 11 get_obj " );
bug(log_buf,0);
a404 2
sprintf(log_buf, " 21 get_obj " );
bug(log_buf,0);
a424 2
sprintf(log_buf, " 31 get_obj " );
bug(log_buf,0);
a428 2
sprintf(log_buf, " 41 get_obj " );
bug(log_buf,0);
a459 2
sprintf(log_buf, " 51 get_obj " );
bug(log_buf,0);
a673 2
      sprintf(log_buf,"P8");
      bug( log_buf, 0 );
a718 2
sprintf( log_buf, "1 do_get");
bug(log_buf,0); 
a729 2
sprintf( log_buf, "2 do_get");
bug(log_buf,0); 
a737 2
sprintf( log_buf, "2b do_get");
bug(log_buf,0); 
a738 2
sprintf( log_buf, "3 do_get");
bug(log_buf,0); 
a745 4
sprintf( log_buf, "4 do_get");
bug(log_buf,0); 
      sprintf(log_buf,"P9");
      bug( log_buf, 0 );
a750 2
sprintf( log_buf, "5 do_get");
bug(log_buf,0); 
a769 2
sprintf( log_buf, "6 do_get");
bug(log_buf,0); 
a775 2
sprintf( log_buf, "7 do_get");
bug(log_buf,0); 
a819 2
      sprintf(log_buf,"P10");
      bug( log_buf, 0 );
a956 2
      sprintf(log_buf,"P11");
      bug( log_buf, 0 );
a1122 2
      sprintf(log_buf,"P12");
      bug( log_buf, 0 );
a1167 2
      sprintf(log_buf,"%s tried to give something to someon", ch->name);
      bug( log_buf, 0 );
a1294 2
      sprintf(log_buf,"Before get_obj_carry %s.", ch->name );
      bug( log_buf, 0 );
a1299 2
      sprintf(log_buf,"after get_obj_carry  %s.", ch->name );
      bug( log_buf, 0 );
a1345 2
      sprintf(log_buf,"P1");
      bug( log_buf, 0 );
a1350 2
      sprintf(log_buf,"After cansee %s.", ch->name );
      bug( log_buf, 0 );
a2517 2
      sprintf(log_buf,"P2");
      bug( log_buf, 0 );
a3427 2
      sprintf(log_buf,"P3");
      bug( log_buf, 0 );
a3645 2
      sprintf(log_buf,"P4");
      bug( log_buf, 0 );
a3827 2
      sprintf(log_buf,"P5");
      bug( log_buf, 0 );
a3903 2
      sprintf(log_buf,"P6");
      bug( log_buf, 0 );
a3990 2
      sprintf(log_buf,"P7");
      bug( log_buf, 0 );
@


1.110
log
@ more debug flags in get_obj
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.109 2000/02/20 06:40:14 mud Exp $";
a1267 6
  if ( IS_NPC(victim))
  {
    send_to_char( "That would crash us, can't give to mobs for now\n\r", ch);
        return;

  }
a1356 6
  if ( IS_NPC(victim))
  {
    send_to_char( "That would crash us, can't give to mobs for now\n\r", ch);
        return;

  }
@


1.109
log
@ compile error, syntax error
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.108 2000/02/20 06:37:18 mud Exp $";
d375 2
d386 2
d398 2
@


1.108
log
@ more debug flags
 Minister
 :x
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.107 2000/02/20 06:31:30 mud Exp $";
d366 1
a366 1
bug(log_bug,0);
d370 1
a370 1
bug(log_bug,0);
d380 1
a380 1
bug(log_bug,0);
d388 1
a388 1
bug(log_bug,0);
d395 1
a395 1
bug(log_bug,0);
d399 1
a399 1
bug(log_bug,0);
d405 1
a405 1
bug(log_bug,0);
d409 1
a409 1
bug(log_bug,0);
d414 1
a414 1
bug(log_bug,0);
d422 1
a422 1
bug(log_bug,0);
d426 1
a426 1
bug(log_bug,0);
d448 1
a448 1
bug(log_bug,0);
d454 1
a454 1
bug(log_bug,0);
d487 1
a487 1
bug(log_bug,0);
@


1.107
log
@ more debug flags in act_obj

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.106 2000/02/20 06:16:55 mud Exp $";
d366 1
a366 1
bug(log_bug);
d370 1
a370 1
bug(log_bug);
d380 1
a380 1
bug(log_bug);
d388 1
a388 1
bug(log_bug);
d395 1
a395 1
bug(log_bug);
d399 1
a399 1
bug(log_bug);
d405 1
a405 1
bug(log_bug);
d409 1
a409 1
bug(log_bug);
d414 1
a414 1
bug(log_bug);
d422 1
a422 1
bug(log_bug);
d426 1
a426 1
bug(log_bug);
d448 1
a448 1
bug(log_bug);
d454 1
a454 1
bug(log_bug);
d487 1
a487 1
bug(log_bug);
@


1.106
log
@ removed debug msg in act_info, added more in act_obj

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.105 2000/02/20 06:05:49 mud Exp $";
d365 2
a366 1

d369 2
d379 2
d387 2
d394 2
d398 2
d404 2
d408 2
d413 2
d421 2
d425 2
d447 2
d453 2
d486 2
@


1.105
log
@ more debug msg in do_get
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.104 2000/02/20 05:24:01 mud Exp $";
d744 3
@


1.104
log
@   do get is also crashing the game

temp fix in there to prevent mobs from getting items


   Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.103 2000/02/20 04:52:53 mud Exp $";
a715 1

d718 1
a718 5
    if ( IS_NPC(ch) )
    {
     // this crashes the game, so return out for now
     return;
     }
d722 2
d735 2
d745 2
d754 2
d763 2
d784 2
d792 2
@


1.103
log
@ tracking who is crashing us by logging do_give

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.102 2000/02/20 04:19:32 mud Exp $";
d719 5
a723 1

@


1.102
log
@ added in that you can't give items to mbos , temp fix for crash bug

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.101 2000/02/20 03:46:18 mud Exp $";
d1179 2
@


1.101
log
@debugging
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.100 2000/02/20 03:13:19 mud Exp $";
d1217 4
d1222 1
d1307 11
@


1.100
log
@debugging debugs
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.99 2000/02/20 02:38:58 mud Exp $";
d675 2
d749 2
d825 2
d964 2
d1132 2
d1357 1
a1357 1
      sprintf(log_buf,"Before cansee %s.", ch->name );
d2533 2
d3445 2
d3665 2
d3849 2
d3927 2
d4016 2
@


1.99
log
@debugging cansee
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.98 2000/02/16 07:08:07 mud Exp $";
d1292 2
d1299 2
@


1.98
log
@remove pfresh beta code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.97 2000/02/11 20:20:39 mud Exp $";
d1343 2
d1350 2
@


1.97
log
@change ITEM_DARK to ITEM_IMM_LOAD and add removal of imm loads from pfreshed char
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.96 2000/01/26 19:14:00 mud Exp $";
d502 2
d505 2
a506 2
	send_to_char("(Note that these may not all be available if you"
		     " are a reclass)\n\r",ch);
d513 1
a513 1
		skill_table[i].rating[ch->class]);
@


1.96
log
@Took out some old infiltrate code in get_obj()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.95 2000/01/26 18:35:02 mud Exp $";
d340 1
d343 3
@


1.95
log
@Added lag back in only when actually picking an object from the corpse.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.94 2000/01/26 18:32:30 mud Exp $";
d414 1
a414 17
  if ( number_percent() >= get_skill(ch,gsn_infiltrate) )
    act( "$n gets $p from $P.", ch, obj, container, TO_ROOM );
  /* Broken somehow 
  else
  {
    for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
    {
      if(IS_IMMORTAL(gch) && IS_SET(gch->act,PLR_HOLYLIGHT)
	 && can_see(gch,ch) && ch != gch)
      {
	sprintf(buf, "%s gets %s from %s.\n\r",ch->name,obj->short_descr,
		container->short_descr);
	send_to_char(buf,gch);
      }
    }
  }
  */
d422 1
a422 16
  if ( number_percent() >= get_skill(ch,gsn_infiltrate) )
    act( "$n gets $p.", ch, obj, container, TO_ROOM );
  /* broken somehow
  else
  {
    for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
    {
      if(IS_IMMORTAL(gch) && IS_SET(gch->act,PLR_HOLYLIGHT)
	 && can_see(gch,ch))
      {
	sprintf(buf, "%s gets %s.\n\r",ch->name,obj->short_descr);
	send_to_char(buf,gch);
      }
    }
  }
  */
@


1.94
log
@Strip the number off the first argument from loot so they
MUST type in the name of the object.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.93 1999/11/26 20:51:34 mud Exp $";
a671 3
    /* 
	WAIT_STATE( ch, 12);
 	*/
d689 2
@


1.93
log
@Dont remove all gold and silver for making a typo anymore
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.92 1999/11/19 19:45:25 mud Exp $";
d640 3
@


1.92
log
@Can only specialize at TRAINERS
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.91 1999/11/19 19:35:01 mud Exp $";
d3644 2
a3645 1
     sprintf(buf,"Well, aren't you clever.\n\r");
d3648 1
@


1.91
log
@Can only specializing at the ACT_PRACTICE
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.90 1999/11/18 17:38:27 mud Exp $";
d550 1
a550 1
       if ( IS_NPC(mob) && IS_SET(mob->act, ACT_PRACTICE) )
@


1.90
log
@Put do_fill back in as was, not sure who was changing it
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.89 1999/11/11 18:26:03 mud Exp $";
d504 1
d547 12
@


1.89
log
@Fixed up some stuff in blind.
-G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.88 1999/11/08 21:32:05 mud Exp $";
d1586 1
a1586 1
	     if ( ++count == number )
d1588 1
d1591 1
a1591 1
	     }	  
d1593 11
@


1.88
log
@Remove level check on plr_thief flag in steal for now
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.87 1999/11/08 20:02:01 mud Exp $";
d1551 1
d1554 1
a1554 1
    argument = one_argument( argument, arg2 );
d1578 1
a1578 1

d1586 5
a1590 2
             found = TRUE;
             break;
a1591 9
       }
       else
       {
          if ( fountain->item_type == ITEM_FOUNTAIN 
	       && fountain == obj2)
	  {
	     found = TRUE;
	     break;
	  }
@


1.87
log
@Thief flag only if victim is higher then 8 levels above you
Killer flag only allows +12 levels to kill you
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.86 1999/11/06 18:56:36 mud Exp $";
a3223 1
	 (ch->level +8  < victim->level) && 
@


1.86
log
@Add a blank line in do_fill to get this recommited, for some reason
do_fill change works on olc but didnt take on game port
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.85 1999/11/05 21:03:54 mud Exp $";
d3224 1
@


1.85
log
@added argument to pull arg2 from do_fill
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.84 1999/11/05 20:58:39 mud Exp $";
d1577 1
@


1.84
log
@Allow fill from other fountains (fixed syntax erro)
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.83 1999/11/05 20:57:08 mud Exp $";
d1552 2
a1553 2
    one_argument( argument, arg1 );
    one_argument( argument, arg2 );
@


1.83
log
@Change to do_fill to allow you to fill from other fountains then the first
in the room
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.82 1999/10/10 17:20:52 mud Exp $";
d1591 1
a1591 1
	       && fountain = obj2)
@


1.82
log
@declared remove_all_obj() in act_obj.c section of merc.h and added
the DECLARE_DO_FUN for do_outfit() in act_info.c
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.81 1999/10/09 17:16:40 mud Exp $";
d1544 2
a1545 1
    char arg[MAX_INPUT_LENGTH];
d1548 1
d1552 2
a1553 1
    one_argument( argument, arg );
d1555 1
a1555 1
    if ( arg[0] == '\0' )
d1561 1
a1561 1
    if ( ( obj = get_obj_carry( ch, arg ) ) == NULL )
d1567 9
d1578 1
a1578 1
  fountain = fountain->next_content )
d1580 17
a1596 5
  if ( fountain->item_type == ITEM_FOUNTAIN )
  {
      found = TRUE;
      break;
  }
@


1.81
log
@ Added in some changes to outcast.  All checks on clan outcast now include an additional check on their timre.  read the change to find out why

 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.80 1999/10/06 23:10:43 mud Exp $";
a50 1
void  remove_all_objs  args( (CHAR_DATA *ch) );
@


1.80
log
@Cosmetic eating bug
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.79 1999/09/30 04:18:15 mud Exp $";
d3628 1
a3628 1
  if ( ch->clan == clan_lookup("outcast") )
@


1.79
log
@Fixing the Wands bug Rage just put in
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.78 1999/09/30 00:35:50 mud Exp $";
d1924 11
a1943 6
      if ( IS_SET(ch->act,PLR_VAMP) )
      {
	  send_to_char("But you want blood... \n\r",ch);
	  return;
      }

a1985 4


    act( "$n eats $p.",  ch, obj, NULL, TO_ROOM );
    act( "You eat $p.", ch, obj, NULL, TO_CHAR );
@


1.78
log
@Fixes to bleed, and zap, kill stealing bugs


Rage
:wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.77 1999/09/28 23:20:31 mud Exp $";
d2911 1
d2915 10
a2924 8
   if ( IS_NPC(victim) &&                                                     
   victim->fighting != NULL &&                                             
  !is_same_group(ch,victim->fighting))                                         
	   {                                                 
	  send_to_char("Kill stealing is not permitted.\n\r",ch);                
	   return;                                                                
	   }          
    }
@


1.77
log
@Myrmidon
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.76 1999/09/14 23:03:05 mud Exp $";
d2911 10
@


1.76
log
@Fixed a bug in brew
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.75 1999/09/14 22:59:35 mud Exp $";
d558 2
a559 1
    if ( ch->train < skill_table[weapon].rating[ch->class] )
d606 1
@


1.75
log
@Brewing
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.74 1999/08/23 19:19:22 mud Exp $";
a70 1
    if ( !IS_IMMORTAL(ch) )
d72 1
a72 1
	!HAS_KIT(ch,"alchemist") )
@


1.74
log
@Not sure why these are changed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.73 1999/08/23 02:04:24 mud Exp $";
d71 1
d93 1
d98 1
a98 1
   }
d123 1
a123 1
    else
d149 20
a169 2
    potion = create_object( get_obj_index(vnum), 0, FALSE );
    obj_to_char( potion, ch ); 
@


1.73
log
@Added blank do_create and do_mix functions
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.72 1999/08/13 19:02:17 mud Exp $";
d55 98
@


1.72
log
@Temp fix for an undefined symbol
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.71 1999/08/12 01:23:01 mud Exp $";
a55 5
void do_create ( CHAR_DATA *ch, char *argument )
{
   return;
}

d2534 4
d2539 4
@


1.71
log
@Nethermaner stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.70 1999/07/14 18:13:27 mud Exp $";
d56 4
@


1.70
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_obj.c,v 1.69 1999/07/11 19:09:19 mud Exp $";
d1991 6
@


1.69
log
@fixed some bugs in battle ragere, new toast messages and summon elemental

Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.68 1999/07/02 23:57:54 mud Exp $ */
@


1.68
log
@If primary disarmed or praimary removed move secondary into primary
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.67 1999/07/02 23:53:58 mud Exp $ */
d2247 6
@


1.67
log
@Move second weapon to primary when disarmed primary and when remove primary
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.66 1999/07/02 20:21:08 mud Exp $ */
d2406 1
a2406 1
    if ((obj = get_eq_char(ch,WEAR_SECOND) != NULL) && 
d2409 1
@


1.66
log
@Had an || where should have been a && for blademaster wearing sword/dagger
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.65 1999/07/02 03:17:48 mud Exp $ */
d2404 10
@


1.65
log
@Bladesong cant wear shield and can only wear dagger and sword
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.64 1999/07/02 03:14:33 mud Exp $ */
d2243 2
a2244 2
       (obj->value[0] != WEAPON_SWORD ||
        obj->value[0] != WEAPON_DAGGER))
@


1.64
log
@Bladesong can't wear shield and can only wear dagger or shield whiel songed
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.63 1999/07/02 03:12:50 mud Exp $ */
d2243 2
a2244 2
       (obj-value[0] != WEAPON_SWORD ||
        obj_value[0] != WEAPON_DAGGER))
@


1.63
log
@Bladesong fixes and notifications
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.62 1999/07/02 02:14:59 mud Exp $ */
d2213 1
a2213 1
  if ( is_affected(ch,gsn_bladesong)
@


1.62
log
@Fixing Dual Wield Bug
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.61 1999/07/02 02:10:39 mud Exp $ */
d2213 6
d2240 8
@


1.61
log
@Trying to fix the Dual Wield bug
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.60 1999/06/24 02:33:57 mud Exp $ */
d1967 1
a1967 1
   if (prim->value[0] = WEAPON_SWORD && sec->value[0] = WEAPON_DAGGER)
d1970 2
a1971 2
   if (prim->value[0] = WEAPON_EXOTIC || sec->value[0] = WEAPON_EXOTIC)
      return TRUE:
@


1.60
log
@Fixed an obscure bug in steal
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.59 1999/06/11 23:21:50 mud Exp $ */
d1964 10
a1973 4
   if ( prim->value[0] != sec->value[0] && 
	prim->value[0] != WEAPON_EXOTIC && sec->value[0] != WEAPON_EXOTIC &&
	( prim->value[0] != WEAPON_SWORD && sec->value[0] != WEAPON_DAGGER ) &&
	!HAS_KIT(ch,"ranger") )
@


1.59
log
@Stuff I changed.  mostly updates of existing files and changes to seer
and flee.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.58 1999/05/15 22:07:38 mud Exp $ */
d3064 1
a3064 1
    if ( ( obj = get_obj_carry( victim, arg1 ) ) == NULL )
@


1.58
log
@Typo in remove_all_objs
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.57 1999/05/15 22:04:20 mud Exp $ */
d1994 8
@


1.57
log
@Added obj declaration in remove_all_objs
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.56 1999/05/15 21:08:06 mud Exp $ */
d1915 1
a1915 1
   if ( ( obj = get_eq_char(ch,WEAR_WIELD,TRUE)) != NULL)
@


1.56
log
@Added remove_all_objs routine to do exactly that for shapeshifter us
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.55 1999/05/15 16:39:01 mud Exp $ */
d1877 2
@


1.55
log
@Rangers.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.54 1999/05/03 08:00:16 mud Exp $ */
d51 1
d1872 47
d1920 3
@


1.54
log
@Bank code.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.53 1999/04/17 02:30:21 mud Exp $ */
d1913 2
a1914 1
	( prim->value[0] != WEAPON_SWORD && sec->value[0] != WEAPON_DAGGER ) )
@


1.53
log
@Dweeb corpses lootable
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.52 1999/04/17 02:05:40 mud Exp $ */
d55 147
@


1.52
log
@Trying to fix syntax error from someone elses change
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.51 1999/04/17 01:58:59 mud Exp $ */
d77 2
a78 1
  if (!IS_NPC(owner) && (IS_SET(owner->act,PLR_CANLOOT)) 
@


1.51
log
@Remove || IS_SET(obj->extra_flags,ITEM_DARK) from line 77 to allow
compile without syntax error
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.50 1999/04/16 16:59:15 mud Exp $ */
d77 1
a77 2
  if (!IS_NPC(owner) 
     && (IS_SET(owner->act,PLR_CANLOOT))
@


1.50
log
@DWEEBS corpses can be looted by anyone.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.49 1999/04/06 21:36:43 mud Exp $ */
d78 1
a78 1
     && (IS_SET(owner->act,PLR_CANLOOT) || IS_SET(obj->extra_flags,ITEM_DARK) )
@


1.49
log
@Ok tests pass on OLC, wont crash and will still steal Abusers money
but for simple typos will not. Looks good now.
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.48 1999/04/06 21:31:44 mud Exp $ */
d77 2
a78 1
  if (!IS_NPC(owner) && IS_SET(owner->act,PLR_CANLOOT))
@


1.48
log
@Cleaned up, added nice messages, this should do it
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.47 1999/04/06 21:24:25 mud Exp $ */
d3213 1
a3213 1
     sprintf(buf,"Wrong syntax, please try again or look at 'Help Buy'.");
@


1.47
log
@Closing in on it, almost there
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.46 1999/04/06 21:11:24 mud Exp $ */
d3205 1
a3205 1
     if (is_number(arg))
d3207 3
a3209 1
     sprintf(buf,"Well, aren't you clever %d.\n\r",number);
d3213 1
a3213 1
     sprintf(buf,"Wrong Syntax");
@


1.46
log
@Added number to clever line to check what was typed
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.45 1999/04/06 21:07:30 mud Exp $ */
d3205 2
d3208 5
@


1.45
log
@Got a warning with the old code too?
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.44 1999/04/06 20:58:37 mud Exp $ */
d3205 1
a3205 1
     sprintf(buf,"Well, aren't you clever %s.\n\r",number);
@


1.44
log
@Reverted back to original, start this whole thing again
-poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.43 1999/04/06 20:41:49 mud Exp $ */
a3206 4
/* Remove Stripping money for now 
     ch->gold = 0;
     ch->silver = 0;
*/
@


1.43
log
@Passing arg[0] for is_number
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.42 1999/04/06 20:36:31 mud Exp $ */
d3203 1
a3203 1
  if (!is_number(arg[0]))
d3205 3
a3207 7
     send_to_char("Incorrect syntax, try again.\n\r",ch);
     return;
  }
  else
  if ( is_number( arg[0] ) && number < 1 )
  {
     send_to_char("Well, aren't you clever.\n\r",ch);
d3210 1
@


1.42
log
@Lets try passing 'number' instead of 'arg'
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.41 1999/04/06 20:29:29 mud Exp $ */
d3203 1
a3203 1
  if (!is_number(number))
d3209 1
a3209 1
  if ( is_number( number ) && number < 1 )
@


1.41
log
@Added a send to char that the syntax is incorrect and return
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.40 1999/04/06 20:24:39 mud Exp $ */
d3203 1
a3203 1
  if (!is_number(arg))
d3209 1
a3209 1
  if ( is_number( arg ) && number < 1 )
@


1.40
log
@Change to buy code crashed OLC - change is_number
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.39 1999/04/06 18:34:38 mud Exp $ */
d3203 6
@


1.39
log
@Modify check for -1 item purchases
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.38 1999/01/03 01:19:07 mud Exp $ */
d3203 1
a3203 1
  if ( is_number( number ) && number < 1 )
@


1.38
log
@Infiltrating rogues, can no longer recall, or use healers while in an eney clan hall.  Slice moidified to limit the number of objects that fall out on a successful slice.

Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.37 1999/01/02 19:55:19 mud Exp $ */
d3203 1
a3203 1
  if( number <= 0 )
@


1.37
log
@removed spare buf[] var
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.36 1999/01/02 19:53:23 mud Exp $ */
d2687 2
d2691 2
a2692 1
	 }
@


1.36
log
@Undo crash causing changes to get_obj()
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.35 1999/01/02 19:10:06 mud Exp $ */
d96 1
a96 1
    char buffer[100],buf[MAX_STRING_LENGTH];
@


1.35
log
@Infiltrators can not hide getting things from IMM's with HOLYLIHGT on.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.34 1999/01/02 00:48:29 mud Exp $ */
a150 1
  {
d152 1
a152 1
  }
d158 1
a158 1
	 && can_see(gch,ch))
d166 1
a174 1
  {
d176 1
a176 1
  }
d189 1
@


1.34
log
@typo fix on slice change.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.33 1999/01/02 00:40:44 mud Exp $ */
d96 1
a96 1
    char buffer[100];
d151 17
a167 1
  act( "$n gets $p from $P.", ch, obj, container, TO_ROOM );
d175 15
a189 1
  act( "$n gets $p.", ch, obj, container, TO_ROOM );
@


1.33
log
@Made floating discs unslicable.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.32 1999/01/01 19:00:06 mud Exp $ */
d2593 2
a2594 1
    if ( obj->item_type != ITEM_CONTAINER || obj->vnum == OBJ_VNUM_DISC )
@


1.32
log
@Fnail try to get this bug out of infiltrate, removed infiltrating into guild
halls temporarily.

R.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.31 1998/12/31 21:25:54 mud Exp $ */
d2593 1
a2593 1
    if ( obj->item_type != ITEM_CONTAINER )
@


1.31
log
@Adding Rage's changes.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.30 1998/12/31 21:16:33 mud Exp $ */
d2612 1
a2612 1
    if (ch->in_room->clan && ch->in_room-clan != ch->clan)
@


1.30
log
@Hmmmm
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.29 1998/12/29 23:54:25 mud Exp $ */
d2599 1
a2599 1
    if (is_safe(ch,victim))
d2611 5
a2615 3
    
    WAIT_STATE( ch, skill_table[gsn_slice].beats );
    
d2705 1
a2705 1
    if (is_safe(ch,victim))
d2707 1
a2707 1
    send_to_char("Not on that person\n\r",ch);
@


1.29
log
@Made some mod's to rogues.
Rremoved check in do_where
changed is_safe_steal to is_safe in do_steal and do_slice
removed wait_state reduction for rogues in steal and slice
added check to give infiltrating rogues a THIEF flag if attacked in a foreign clan hall

Rob.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.28 1998/12/23 16:51:29 mud Exp $ */
d2558 1
a2558 1
    if  (!IS_NPC(ch) && ch->level < skill_table[gsn_slice].skill_level[ch->level] )
@


1.28
log
@Bunch of changes for rogues, including new skill and pther improvements
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.27 1998/12/16 21:06:59 mud Exp $ */
d2599 6
a2611 3
    if (ch->class == class_lookup("rogue"))
    WAIT_STATE( ch, (skill_table[gsn_slice].beats)/2);
    else
d2635 1
d2639 1
a2639 1

d2703 3
a2705 1
    if (is_safe_steal(ch,victim))
d2707 2
a2708 1
 
a2716 3
    if ( ch->class == class_lookup("rogue"))
    WAIT_STATE( ch, (skill_table[gsn_steal].beats)/2);
    else
@


1.27
log
@Fixed slifce check_pomrv
e
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.26 1998/12/16 20:42:38 mud Exp $ */
d2605 4
a2608 1

d2610 1
d2612 2
a2613 2
    percent -= ( IS_AWAKE(victim) ? -10 : 50 );
    percent -= (victim->level - ch->level);
d2615 1
a2615 1
			- get_curr_stat(ch, STAT_INT))*2;
d2630 6
d2699 3
a2701 3
    if (is_safe(ch,victim))
  return;

d2709 4
a2712 1

d2714 1
d2724 2
a2725 1

@


1.26
log
@i
Fix bug
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.25 1998/12/12 01:20:51 mud Exp $ */
d2624 1
d2630 1
@


1.25
log
@Error checking
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.24 1998/11/30 02:20:06 mud Exp $ */
d2565 1
a2565 1
       send_to_char( " Syntax: slice <victim> <container>\n\r", ch);
d2575 1
a2575 1
    if ( ( victim = get_char_room( ch, arg1 ) ) == NULL )
d2587 1
a2587 1
    if ( ( obj = get_obj_wear(victim, arg2) ) == NULL )
@


1.24
log
@Few things
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.23 1998/11/28 07:49:29 mud Exp $ */
d2209 1
a2209 3
	ch->pcdata->sac = (ch->class == class_lookup("paladin")) ?
	UMIN(MAX_SAC_PNTS*2,ch->pcdata->sac+silver/2) 
	: UMIN(MAX_SAC_PNTS,ch->pcdata->sac+silver/2);
@


1.23
log
@favored flag
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.22 1998/11/24 05:48:01 mud Exp $ */
d135 1
a135 2
    

@


1.22
log
@More dual wield shit
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.21 1998/11/24 05:29:00 mud Exp $ */
d3264 1
a3264 1
        t_obj = create_object( obj->pIndexData, obj->level );
@


1.21
log
@Dual wield
startof it anyway
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.20 1998/11/22 08:04:41 mud Exp $ */
d2015 1
a2015 1
      equip_char( ch, obj, WEAR_WIELD );
@


1.20
log
@Infiltrate coded.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.19 1998/11/17 23:20:09 mud Exp $ */
d1724 23
d1976 1
d1978 2
a1979 1

d1999 4
a2002 3
  act( "$n wields $p.", ch, obj, NULL, TO_ROOM );
  act( "You wield $p.", ch, obj, NULL, TO_CHAR );
  equip_char( ch, obj, WEAR_WIELD );
d2004 25
d2053 1
@


1.19
log
@Hopefully fixed the wholist and also added outcast changes
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.18 1998/11/14 07:15:49 mud Exp $ */
d151 1
d159 1
@


1.18
log
@Finished the damn reclass changed finally.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.17 1998/10/21 23:46:36 mud Exp $ */
d37 2
a38 1

d3117 7
@


1.17
log
@Thief flag change
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.16 1998/10/20 02:05:14 mud Exp $ */
d219 4
a222 1
    if ( ch->class != class_lookup("warrior") )
d233 2
d273 35
d2654 2
@


1.16
log
@fixed bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.15 1998/10/19 07:19:04 mud Exp $ */
d2655 2
a2656 1
    if ( !IS_SET(ch->act, PLR_THIEF) )
@


1.15
log
@More stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.14 1998/10/19 06:47:09 mud Exp $ */
d234 3
a236 1
	    sprintf(buf," * %s\n\r",skill_table[i].name);
@


1.14
log
@Goblin lick thing
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.13 1998/10/18 16:28:54 mud Exp $ */
d1033 1
a1033 1
    if ( ch->race != race_lookup("goblin") )
@


1.13
log
@I don't know?
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.12 1998/10/17 05:31:56 mud Exp $ */
d1027 60
@


1.12
log
@Fixed bug, thanks to surma for pointing it out
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.11 1998/10/15 23:05:59 mud Exp $ */
d316 1
a316 1
     
d318 1
a318 1

@


1.11
log
@Various bug fixes
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.10 1998/10/11 06:52:41 mud Exp $ */
d2989 13
a3001 1
  if( number <= 0 ) return;
@


1.10
log
@Completed specializ
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.9 1998/10/11 00:13:32 mud Exp $ */
a2402 3
    sprintf(log_buf,"ARg1 %s Arg 2 %s",arg1, arg2);
    bug(log_buf,0);

d2447 1
a2447 1
      send_to_char("You're to exhausted.\n\r",ch);
d2474 2
a2475 1
  
d2488 3
a2490 1
      return;
@


1.9
log
@Specializatio for warriros is in
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.8 1998/10/06 14:11:27 mud Exp $ */
d195 6
@


1.8
log
@fixed extraneous ; in do_slice if()
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.7 1998/08/30 03:51:25 mud Exp $ */
d195 68
@


1.7
log
@if ( obj->level > ch->level +2 )

 Only line I changed.
 -Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.6 1998/08/20 21:05:26 mud Exp $ */
d2362 1
a2362 1
    if ( ( obj = get_obj_wear(victim, arg2) ) == NULL );
@


1.6
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.5 1998/08/15 18:45:48 mud Exp $ */
d2961 1
a2961 1
  if ( obj->level > ch->level )
@


1.5
log
@skills.c changed to add level range args for 'skills' and spells' commands
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.4 1998/08/13 21:42:34 mud Exp $ */
d167 1
a1446 3
    act( "$n eats $p.",  ch, obj, NULL, TO_ROOM );
    act( "You eat $p.", ch, obj, NULL, TO_CHAR );

d1507 4
d1939 1
a1939 1
	  deity_table[ch->deity].pname);
d1955 1
a1955 1
     sprintf(buf,"%s wouldn't like that.\n\r",deity_table[ch->deity].pname);
d1977 1
a1977 1
		deity_table[ch->deity].pname);
d1979 3
a1981 3
	ch->sac = (ch->class == class_lookup("paladin")) ?
	UMIN(MAX_SAC_PNTS*2,ch->sac+silver/2) 
	: UMIN(MAX_SAC_PNTS,ch->sac+silver/2);
d1988 1
a1988 1
		deity_table[ch->deity].pname);
d1994 1
a1994 1
    	deity_table[ch->deity].pname,silver);
d2318 100
@


1.4
log
@Logging THIEF flags too.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.3 1998/08/06 04:24:49 mud Exp $ */
d2422 2
a2423 2
		victim->name,ch->in_room);
	log_buf(buf);
@


1.3
log
@Tons of stuff, mostly additions of holy flag for weapons.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.2 1998/08/05 06:59:12 mud Exp $ */
d2421 3
@


1.2
log
@* Fire breath blind effect lowered to 0 ticks from 1
* Few minor aesthetic fixes in spells and eating code

-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_obj.c,v 1.1 1998/06/16 17:49:14 mud Exp $ */
d1342 7
d1354 2
d1364 7
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d1439 2
a1440 1
  if ( !IS_NPC(ch) )
d1443 6
@
