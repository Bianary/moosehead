head	1.418;
access;
symbols;
locks; strict;
comment	@ * @;


1.418
date	2004.10.25.02.48.44;	author boogums;	state Exp;
branches;
next	1.417;

1.417
date	2004.05.01.01.07.14;	author ndagger;	state Exp;
branches;
next	1.416;

1.416
date	2004.01.08.21.59.17;	author ndagger;	state Exp;
branches;
next	1.415;

1.415
date	2004.01.05.22.12.45;	author ndagger;	state Exp;
branches;
next	1.414;

1.414
date	2003.12.09.21.38.43;	author rusty;	state Exp;
branches;
next	1.413;

1.413
date	2003.11.26.04.20.56;	author boogums;	state Exp;
branches;
next	1.412;

1.412
date	2003.08.16.16.45.06;	author boogums;	state Exp;
branches;
next	1.411;

1.411
date	2003.06.14.19.53.10;	author boogums;	state Exp;
branches;
next	1.410;

1.410
date	2003.06.03.03.13.07;	author boogums;	state Exp;
branches;
next	1.409;

1.409
date	2003.06.03.02.57.27;	author boogums;	state Exp;
branches;
next	1.408;

1.408
date	2003.04.25.06.57.14;	author ndagger;	state Exp;
branches;
next	1.407;

1.407
date	2003.04.25.06.41.47;	author ndagger;	state Exp;
branches;
next	1.406;

1.406
date	2003.04.24.03.13.41;	author boogums;	state Exp;
branches;
next	1.405;

1.405
date	2003.04.24.01.48.01;	author boogums;	state Exp;
branches;
next	1.404;

1.404
date	2003.04.14.05.11.51;	author ndagger;	state Exp;
branches;
next	1.403;

1.403
date	2003.04.14.04.56.55;	author ndagger;	state Exp;
branches;
next	1.402;

1.402
date	2003.04.14.04.50.56;	author ndagger;	state Exp;
branches;
next	1.401;

1.401
date	2003.03.27.16.09.57;	author rusty;	state Exp;
branches;
next	1.400;

1.400
date	2003.02.20.19.08.06;	author rusty;	state Exp;
branches;
next	1.399;

1.399
date	2003.02.20.19.01.53;	author rusty;	state Exp;
branches;
next	1.398;

1.398
date	2003.02.20.00.56.10;	author ndagger;	state Exp;
branches;
next	1.397;

1.397
date	2003.01.19.18.01.52;	author boogums;	state Exp;
branches;
next	1.396;

1.396
date	2003.01.18.19.19.04;	author ndagger;	state Exp;
branches;
next	1.395;

1.395
date	2002.12.12.00.11.37;	author ndagger;	state Exp;
branches;
next	1.394;

1.394
date	2002.11.26.05.57.31;	author boogums;	state Exp;
branches;
next	1.393;

1.393
date	2002.11.23.03.49.28;	author mud;	state Exp;
branches;
next	1.392;

1.392
date	2002.11.23.03.42.17;	author rusty;	state Exp;
branches;
next	1.391;

1.391
date	2002.11.15.02.26.51;	author boogums;	state Exp;
branches;
next	1.390;

1.390
date	2002.11.02.10.34.30;	author ndagger;	state Exp;
branches;
next	1.389;

1.389
date	2002.10.26.15.55.50;	author boogums;	state Exp;
branches;
next	1.388;

1.388
date	2002.10.15.21.28.48;	author boogums;	state Exp;
branches;
next	1.387;

1.387
date	2002.10.13.22.22.35;	author ndagger;	state Exp;
branches;
next	1.386;

1.386
date	2002.10.13.22.02.52;	author ndagger;	state Exp;
branches;
next	1.385;

1.385
date	2002.10.13.21.49.02;	author ndagger;	state Exp;
branches;
next	1.384;

1.384
date	2002.09.15.14.51.15;	author boogums;	state Exp;
branches;
next	1.383;

1.383
date	2002.09.15.14.39.04;	author boogums;	state Exp;
branches;
next	1.382;

1.382
date	2002.09.15.01.12.13;	author boogums;	state Exp;
branches;
next	1.381;

1.381
date	2002.09.14.18.22.03;	author boogums;	state Exp;
branches;
next	1.380;

1.380
date	2002.06.20.15.55.00;	author rusty;	state Exp;
branches;
next	1.379;

1.379
date	2002.06.14.20.14.27;	author rusty;	state Exp;
branches;
next	1.378;

1.378
date	2002.05.22.14.44.40;	author mud;	state Exp;
branches;
next	1.377;

1.377
date	2002.05.22.14.43.22;	author rusty;	state Exp;
branches;
next	1.376;

1.376
date	2002.04.11.03.17.37;	author boogums;	state Exp;
branches;
next	1.375;

1.375
date	2002.04.03.15.56.19;	author rusty;	state Exp;
branches;
next	1.374;

1.374
date	2002.04.01.21.05.43;	author rusty;	state Exp;
branches;
next	1.373;

1.373
date	2002.03.09.19.14.27;	author rusty;	state Exp;
branches;
next	1.372;

1.372
date	2002.02.21.16.05.35;	author poquah;	state Exp;
branches;
next	1.371;

1.371
date	2002.01.20.21.37.14;	author rage;	state Exp;
branches;
next	1.370;

1.370
date	2002.01.20.21.33.18;	author rage;	state Exp;
branches;
next	1.369;

1.369
date	2001.12.15.02.43.34;	author poquah;	state Exp;
branches;
next	1.368;

1.368
date	2001.12.14.23.04.16;	author poquah;	state Exp;
branches;
next	1.367;

1.367
date	2001.12.14.20.54.40;	author poquah;	state Exp;
branches;
next	1.366;

1.366
date	2001.12.14.20.09.36;	author poquah;	state Exp;
branches;
next	1.365;

1.365
date	2001.12.13.17.34.39;	author poquah;	state Exp;
branches;
next	1.364;

1.364
date	2001.12.05.21.48.53;	author poquah;	state Exp;
branches;
next	1.363;

1.363
date	2001.12.05.21.45.31;	author poquah;	state Exp;
branches;
next	1.362;

1.362
date	2001.12.05.17.07.04;	author poquah;	state Exp;
branches;
next	1.361;

1.361
date	2001.12.05.16.42.53;	author poquah;	state Exp;
branches;
next	1.360;

1.360
date	2001.12.05.16.39.01;	author poquah;	state Exp;
branches;
next	1.359;

1.359
date	2001.12.03.18.46.10;	author poquah;	state Exp;
branches;
next	1.358;

1.358
date	2001.12.03.18.42.08;	author poquah;	state Exp;
branches;
next	1.357;

1.357
date	2001.12.03.18.34.53;	author poquah;	state Exp;
branches;
next	1.356;

1.356
date	2001.12.03.15.11.23;	author poquah;	state Exp;
branches;
next	1.355;

1.355
date	2001.11.25.02.35.08;	author rusty;	state Exp;
branches;
next	1.354;

1.354
date	2001.11.25.01.26.37;	author rusty;	state Exp;
branches;
next	1.353;

1.353
date	2001.10.17.03.02.46;	author boogums;	state Exp;
branches;
next	1.352;

1.352
date	2001.10.05.15.56.50;	author rage;	state Exp;
branches;
next	1.351;

1.351
date	2001.10.05.15.48.57;	author rage;	state Exp;
branches;
next	1.350;

1.350
date	2001.09.04.18.34.35;	author rusty;	state Exp;
branches;
next	1.349;

1.349
date	2001.07.26.00.50.00;	author poquah;	state Exp;
branches;
next	1.348;

1.348
date	2001.07.25.18.27.44;	author rage;	state Exp;
branches;
next	1.347;

1.347
date	2001.07.12.00.14.26;	author rage;	state Exp;
branches;
next	1.346;

1.346
date	2001.07.10.23.39.13;	author rage;	state Exp;
branches;
next	1.345;

1.345
date	2001.07.09.22.01.24;	author rusty;	state Exp;
branches;
next	1.344;

1.344
date	2001.07.02.21.36.08;	author rage;	state Exp;
branches;
next	1.343;

1.343
date	2001.06.26.03.46.48;	author guerrand;	state Exp;
branches;
next	1.342;

1.342
date	2001.06.25.22.09.19;	author mud;	state Exp;
branches;
next	1.341;

1.341
date	2001.06.25.22.07.33;	author rusty;	state Exp;
branches;
next	1.340;

1.340
date	2001.06.23.20.58.51;	author rage;	state Exp;
branches;
next	1.339;

1.339
date	2001.06.10.03.53.09;	author guerrand;	state Exp;
branches;
next	1.338;

1.338
date	2001.06.10.03.45.58;	author guerrand;	state Exp;
branches;
next	1.337;

1.337
date	2001.06.09.19.34.45;	author guerrand;	state Exp;
branches;
next	1.336;

1.336
date	2001.06.09.17.42.40;	author guerrand;	state Exp;
branches;
next	1.335;

1.335
date	2001.06.03.22.44.22;	author guerrand;	state Exp;
branches;
next	1.334;

1.334
date	2001.05.27.19.56.04;	author rusty;	state Exp;
branches;
next	1.333;

1.333
date	2001.05.26.18.53.08;	author boogums;	state Exp;
branches;
next	1.332;

1.332
date	2001.05.26.03.10.26;	author rage;	state Exp;
branches;
next	1.331;

1.331
date	2001.05.26.03.00.35;	author rage;	state Exp;
branches;
next	1.330;

1.330
date	2001.05.26.00.33.57;	author rage;	state Exp;
branches;
next	1.329;

1.329
date	2001.05.25.17.33.11;	author poquah;	state Exp;
branches;
next	1.328;

1.328
date	2001.05.20.21.25.43;	author rusty;	state Exp;
branches;
next	1.327;

1.327
date	2001.05.14.15.08.32;	author rusty;	state Exp;
branches;
next	1.326;

1.326
date	2001.04.09.18.30.39;	author mud;	state Exp;
branches;
next	1.325;

1.325
date	2001.03.27.17.38.21;	author mud;	state Exp;
branches;
next	1.324;

1.324
date	2001.03.26.17.20.07;	author mud;	state Exp;
branches;
next	1.323;

1.323
date	2001.03.25.15.16.50;	author mud;	state Exp;
branches;
next	1.322;

1.322
date	2001.02.27.18.53.21;	author mud;	state Exp;
branches;
next	1.321;

1.321
date	2001.02.26.07.10.58;	author mud;	state Exp;
branches;
next	1.320;

1.320
date	2001.02.10.03.42.41;	author mud;	state Exp;
branches;
next	1.319;

1.319
date	2001.01.26.15.16.41;	author mud;	state Exp;
branches;
next	1.318;

1.318
date	2001.01.25.18.09.30;	author mud;	state Exp;
branches;
next	1.317;

1.317
date	2001.01.08.23.16.01;	author mud;	state Exp;
branches;
next	1.316;

1.316
date	2000.12.27.04.27.40;	author mud;	state Exp;
branches;
next	1.315;

1.315
date	2000.12.25.11.08.24;	author mud;	state Exp;
branches;
next	1.314;

1.314
date	2000.12.24.10.05.55;	author mud;	state Exp;
branches;
next	1.313;

1.313
date	2000.12.14.22.43.43;	author mud;	state Exp;
branches;
next	1.312;

1.312
date	2000.12.14.22.41.14;	author mud;	state Exp;
branches;
next	1.311;

1.311
date	2000.12.14.22.36.25;	author mud;	state Exp;
branches;
next	1.310;

1.310
date	2000.11.27.00.01.32;	author mud;	state Exp;
branches;
next	1.309;

1.309
date	2000.11.24.23.23.14;	author mud;	state Exp;
branches;
next	1.308;

1.308
date	2000.10.26.12.22.46;	author mud;	state Exp;
branches;
next	1.307;

1.307
date	2000.10.25.13.06.21;	author mud;	state Exp;
branches;
next	1.306;

1.306
date	2000.10.25.12.42.06;	author mud;	state Exp;
branches;
next	1.305;

1.305
date	2000.10.16.23.09.30;	author mud;	state Exp;
branches;
next	1.304;

1.304
date	2000.10.16.20.18.43;	author mud;	state Exp;
branches;
next	1.303;

1.303
date	2000.10.08.20.48.33;	author mud;	state Exp;
branches;
next	1.302;

1.302
date	2000.09.27.14.32.40;	author mud;	state Exp;
branches;
next	1.301;

1.301
date	2000.09.27.14.24.41;	author mud;	state Exp;
branches;
next	1.300;

1.300
date	2000.09.26.20.27.41;	author mud;	state Exp;
branches;
next	1.299;

1.299
date	2000.09.26.07.00.14;	author mud;	state Exp;
branches;
next	1.298;

1.298
date	2000.09.24.21.27.37;	author mud;	state Exp;
branches;
next	1.297;

1.297
date	2000.08.26.18.38.10;	author mud;	state Exp;
branches;
next	1.296;

1.296
date	2000.08.25.16.55.42;	author mud;	state Exp;
branches;
next	1.295;

1.295
date	2000.08.25.16.47.04;	author mud;	state Exp;
branches;
next	1.294;

1.294
date	2000.08.24.19.26.18;	author mud;	state Exp;
branches;
next	1.293;

1.293
date	2000.08.23.14.06.54;	author mud;	state Exp;
branches;
next	1.292;

1.292
date	2000.08.23.13.47.43;	author mud;	state Exp;
branches;
next	1.291;

1.291
date	2000.08.23.13.38.04;	author mud;	state Exp;
branches;
next	1.290;

1.290
date	2000.08.23.13.26.25;	author mud;	state Exp;
branches;
next	1.289;

1.289
date	2000.08.20.00.37.53;	author mud;	state Exp;
branches;
next	1.288;

1.288
date	2000.08.20.00.11.24;	author mud;	state Exp;
branches;
next	1.287;

1.287
date	2000.08.19.23.22.08;	author mud;	state Exp;
branches;
next	1.286;

1.286
date	2000.08.19.23.03.24;	author mud;	state Exp;
branches;
next	1.285;

1.285
date	2000.08.19.22.38.56;	author mud;	state Exp;
branches;
next	1.284;

1.284
date	2000.08.19.19.48.50;	author mud;	state Exp;
branches;
next	1.283;

1.283
date	2000.08.18.23.52.33;	author mud;	state Exp;
branches;
next	1.282;

1.282
date	2000.08.18.22.49.01;	author mud;	state Exp;
branches;
next	1.281;

1.281
date	2000.08.18.21.33.58;	author mud;	state Exp;
branches;
next	1.280;

1.280
date	2000.08.17.17.18.00;	author mud;	state Exp;
branches;
next	1.279;

1.279
date	2000.08.16.15.32.27;	author mud;	state Exp;
branches;
next	1.278;

1.278
date	2000.08.16.15.26.20;	author mud;	state Exp;
branches;
next	1.277;

1.277
date	2000.08.16.01.33.38;	author mud;	state Exp;
branches;
next	1.276;

1.276
date	2000.08.16.01.32.10;	author mud;	state Exp;
branches;
next	1.275;

1.275
date	2000.08.09.21.33.47;	author mud;	state Exp;
branches;
next	1.274;

1.274
date	2000.08.09.21.30.27;	author mud;	state Exp;
branches;
next	1.273;

1.273
date	2000.08.09.21.20.56;	author mud;	state Exp;
branches;
next	1.272;

1.272
date	2000.08.09.21.18.48;	author mud;	state Exp;
branches;
next	1.271;

1.271
date	2000.08.09.21.16.27;	author mud;	state Exp;
branches;
next	1.270;

1.270
date	2000.07.26.02.38.28;	author mud;	state Exp;
branches;
next	1.269;

1.269
date	2000.07.25.20.06.37;	author mud;	state Exp;
branches;
next	1.268;

1.268
date	2000.07.25.00.42.37;	author mud;	state Exp;
branches;
next	1.267;

1.267
date	2000.07.24.23.17.26;	author mud;	state Exp;
branches;
next	1.266;

1.266
date	2000.07.24.22.55.44;	author mud;	state Exp;
branches;
next	1.265;

1.265
date	2000.07.24.15.50.07;	author mud;	state Exp;
branches;
next	1.264;

1.264
date	2000.07.21.19.56.19;	author mud;	state Exp;
branches;
next	1.263;

1.263
date	2000.07.21.19.49.15;	author mud;	state Exp;
branches;
next	1.262;

1.262
date	2000.07.20.22.16.27;	author mud;	state Exp;
branches;
next	1.261;

1.261
date	2000.07.18.18.48.44;	author mud;	state Exp;
branches;
next	1.260;

1.260
date	2000.07.04.17.50.17;	author mud;	state Exp;
branches;
next	1.259;

1.259
date	2000.06.29.20.47.57;	author mud;	state Exp;
branches;
next	1.258;

1.258
date	2000.06.28.23.03.11;	author mud;	state Exp;
branches;
next	1.257;

1.257
date	2000.06.28.01.21.09;	author mud;	state Exp;
branches;
next	1.256;

1.256
date	2000.06.28.00.57.11;	author mud;	state Exp;
branches;
next	1.255;

1.255
date	2000.06.25.23.36.08;	author mud;	state Exp;
branches;
next	1.254;

1.254
date	2000.06.17.21.18.39;	author mud;	state Exp;
branches;
next	1.253;

1.253
date	2000.05.30.00.26.39;	author mud;	state Exp;
branches;
next	1.252;

1.252
date	2000.05.29.19.37.02;	author mud;	state Exp;
branches;
next	1.251;

1.251
date	2000.05.26.14.07.09;	author mud;	state Exp;
branches;
next	1.250;

1.250
date	2000.05.26.02.26.21;	author mud;	state Exp;
branches;
next	1.249;

1.249
date	2000.05.26.02.04.24;	author mud;	state Exp;
branches;
next	1.248;

1.248
date	2000.05.26.02.02.56;	author mud;	state Exp;
branches;
next	1.247;

1.247
date	2000.05.26.01.51.34;	author mud;	state Exp;
branches;
next	1.246;

1.246
date	2000.05.26.01.46.24;	author mud;	state Exp;
branches;
next	1.245;

1.245
date	2000.05.26.01.43.25;	author mud;	state Exp;
branches;
next	1.244;

1.244
date	2000.05.26.01.26.24;	author mud;	state Exp;
branches;
next	1.243;

1.243
date	2000.05.24.02.02.58;	author mud;	state Exp;
branches;
next	1.242;

1.242
date	2000.05.24.02.01.30;	author mud;	state Exp;
branches;
next	1.241;

1.241
date	2000.05.24.00.25.09;	author mud;	state Exp;
branches;
next	1.240;

1.240
date	2000.05.23.04.55.41;	author mud;	state Exp;
branches;
next	1.239;

1.239
date	2000.05.23.04.14.29;	author mud;	state Exp;
branches;
next	1.238;

1.238
date	2000.05.23.04.12.38;	author mud;	state Exp;
branches;
next	1.237;

1.237
date	2000.05.21.04.47.46;	author mud;	state Exp;
branches;
next	1.236;

1.236
date	2000.05.21.04.12.31;	author mud;	state Exp;
branches;
next	1.235;

1.235
date	2000.05.21.01.17.14;	author mud;	state Exp;
branches;
next	1.234;

1.234
date	2000.05.21.00.28.53;	author mud;	state Exp;
branches;
next	1.233;

1.233
date	2000.05.20.03.10.03;	author mud;	state Exp;
branches;
next	1.232;

1.232
date	2000.05.20.02.28.19;	author mud;	state Exp;
branches;
next	1.231;

1.231
date	2000.05.20.01.32.22;	author mud;	state Exp;
branches;
next	1.230;

1.230
date	2000.05.20.01.12.20;	author mud;	state Exp;
branches;
next	1.229;

1.229
date	2000.05.18.21.31.46;	author mud;	state Exp;
branches;
next	1.228;

1.228
date	2000.05.16.00.55.58;	author mud;	state Exp;
branches;
next	1.227;

1.227
date	2000.05.14.00.02.21;	author mud;	state Exp;
branches;
next	1.226;

1.226
date	2000.05.13.23.58.12;	author mud;	state Exp;
branches;
next	1.225;

1.225
date	2000.05.13.22.58.46;	author mud;	state Exp;
branches;
next	1.224;

1.224
date	2000.05.13.22.44.52;	author mud;	state Exp;
branches;
next	1.223;

1.223
date	2000.05.13.22.37.22;	author mud;	state Exp;
branches;
next	1.222;

1.222
date	2000.05.13.21.55.09;	author mud;	state Exp;
branches;
next	1.221;

1.221
date	2000.04.25.01.00.02;	author mud;	state Exp;
branches;
next	1.220;

1.220
date	2000.04.18.20.33.46;	author mud;	state Exp;
branches;
next	1.219;

1.219
date	2000.04.18.19.53.40;	author mud;	state Exp;
branches;
next	1.218;

1.218
date	2000.04.18.19.50.53;	author mud;	state Exp;
branches;
next	1.217;

1.217
date	2000.04.17.22.45.35;	author mud;	state Exp;
branches;
next	1.216;

1.216
date	2000.04.17.22.38.42;	author mud;	state Exp;
branches;
next	1.215;

1.215
date	2000.04.17.22.00.46;	author mud;	state Exp;
branches;
next	1.214;

1.214
date	2000.03.31.16.35.31;	author mud;	state Exp;
branches;
next	1.213;

1.213
date	2000.03.30.21.47.01;	author mud;	state Exp;
branches;
next	1.212;

1.212
date	2000.03.28.23.20.14;	author mud;	state Exp;
branches;
next	1.211;

1.211
date	2000.03.25.20.31.39;	author mud;	state Exp;
branches;
next	1.210;

1.210
date	2000.03.20.23.22.25;	author mud;	state Exp;
branches;
next	1.209;

1.209
date	2000.03.20.23.10.52;	author mud;	state Exp;
branches;
next	1.208;

1.208
date	2000.03.12.00.32.41;	author mud;	state Exp;
branches;
next	1.207;

1.207
date	2000.03.10.02.12.34;	author mud;	state Exp;
branches;
next	1.206;

1.206
date	2000.03.07.14.31.36;	author mud;	state Exp;
branches;
next	1.205;

1.205
date	2000.03.06.00.23.37;	author mud;	state Exp;
branches;
next	1.204;

1.204
date	2000.03.03.21.16.24;	author mud;	state Exp;
branches;
next	1.203;

1.203
date	2000.03.03.20.32.15;	author mud;	state Exp;
branches;
next	1.202;

1.202
date	2000.03.03.06.28.54;	author mud;	state Exp;
branches;
next	1.201;

1.201
date	2000.03.03.06.16.36;	author mud;	state Exp;
branches;
next	1.200;

1.200
date	2000.03.03.06.03.11;	author mud;	state Exp;
branches;
next	1.199;

1.199
date	2000.03.02.19.29.37;	author mud;	state Exp;
branches;
next	1.198;

1.198
date	2000.02.29.07.18.30;	author mud;	state Exp;
branches;
next	1.197;

1.197
date	2000.02.29.07.15.03;	author mud;	state Exp;
branches;
next	1.196;

1.196
date	2000.02.29.06.58.00;	author mud;	state Exp;
branches;
next	1.195;

1.195
date	2000.02.26.00.21.47;	author mud;	state Exp;
branches;
next	1.194;

1.194
date	2000.02.26.00.18.59;	author mud;	state Exp;
branches;
next	1.193;

1.193
date	2000.02.25.19.46.12;	author mud;	state Exp;
branches;
next	1.192;

1.192
date	2000.02.18.21.01.44;	author mud;	state Exp;
branches;
next	1.191;

1.191
date	2000.02.16.22.01.11;	author mud;	state Exp;
branches;
next	1.190;

1.190
date	2000.02.16.21.58.21;	author mud;	state Exp;
branches;
next	1.189;

1.189
date	2000.02.16.21.23.28;	author mud;	state Exp;
branches;
next	1.188;

1.188
date	2000.02.16.19.07.57;	author mud;	state Exp;
branches;
next	1.187;

1.187
date	2000.02.15.22.32.15;	author mud;	state Exp;
branches;
next	1.186;

1.186
date	2000.02.11.20.23.49;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	2000.02.11.18.27.32;	author mud;	state Exp;
branches;
next	1.184;

1.184
date	2000.02.11.17.25.47;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2000.02.11.17.12.24;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	2000.02.07.19.40.00;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	2000.02.07.19.33.08;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	2000.02.06.19.08.52;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	2000.02.04.02.18.43;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	2000.02.01.02.55.33;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	2000.01.31.22.12.36;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	2000.01.25.00.13.33;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	2000.01.25.00.08.21;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	2000.01.24.23.55.20;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	2000.01.24.23.49.22;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	2000.01.24.23.41.26;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	2000.01.24.23.20.46;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	2000.01.24.23.02.35;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	2000.01.24.22.47.09;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	2000.01.24.20.58.20;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	2000.01.24.19.51.54;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	2000.01.21.00.53.15;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	2000.01.12.08.12.34;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	2000.01.11.01.35.32;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	2000.01.08.04.58.52;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	2000.01.07.22.03.17;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	99.12.15.00.56.53;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	99.12.03.01.48.28;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	99.12.02.21.32.22;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	99.12.02.19.22.58;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	99.11.29.00.14.02;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	99.11.24.22.48.04;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	99.11.24.22.09.11;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	99.11.24.22.05.59;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	99.11.24.22.04.34;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	99.11.24.22.00.50;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	99.11.21.21.50.38;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	99.11.20.22.28.30;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	99.11.20.21.26.06;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	99.11.07.00.56.00;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	99.10.31.02.50.12;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	99.10.31.02.23.21;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	99.10.30.20.26.48;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	99.10.10.17.25.57;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	99.10.10.17.24.21;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	99.10.09.17.16.41;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	99.10.02.22.16.12;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	99.09.18.21.46.40;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	99.09.16.23.31.47;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	99.09.16.23.08.01;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	99.09.16.18.26.29;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	99.09.15.03.57.27;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	99.09.02.03.15.38;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	99.09.01.19.00.10;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	99.09.01.18.20.01;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	99.08.28.21.17.14;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	99.08.23.03.34.41;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	99.08.13.21.35.50;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	99.08.12.13.33.09;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	99.08.11.03.36.26;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	99.08.09.22.08.26;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	99.08.04.14.45.18;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	99.07.27.15.02.05;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	99.07.27.14.58.09;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	99.07.27.14.50.45;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	99.07.23.20.10.15;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	99.07.23.20.08.28;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	99.07.23.20.01.08;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	99.07.23.04.33.15;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	99.07.23.04.07.18;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	99.07.23.03.48.35;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	99.07.14.18.13.28;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	99.07.14.13.55.34;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	99.07.13.07.26.55;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	99.07.10.00.11.35;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	99.07.07.06.16.44;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	99.07.05.00.54.19;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	99.07.05.00.47.45;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	99.07.02.01.30.37;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	99.07.02.00.40.25;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	99.06.20.20.29.19;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	99.06.17.15.36.09;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	99.06.11.23.21.51;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	99.05.26.03.27.28;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	99.05.19.18.18.46;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	99.05.17.21.28.22;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	99.05.16.20.51.50;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	99.05.16.20.49.47;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	99.05.16.20.48.02;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	99.05.16.20.39.24;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	99.05.16.04.42.54;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	99.05.05.21.54.14;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	99.05.04.01.04.15;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	99.05.04.00.57.41;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	99.05.04.00.49.03;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.05.04.00.47.20;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.05.04.00.43.29;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.04.24.02.04.50;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.04.23.23.43.38;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.04.23.21.45.14;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.04.20.17.11.23;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.04.17.09.30.55;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.04.17.07.08.05;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.04.17.06.46.26;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	99.04.17.06.39.34;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	99.04.17.06.17.46;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	99.04.17.06.09.31;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	99.04.17.01.35.16;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.04.15.03.06.26;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.04.15.02.59.52;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	99.04.15.02.56.11;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	99.04.14.23.46.22;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	99.04.12.22.18.25;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	99.04.11.17.50.37;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	99.04.11.05.26.05;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	99.04.11.05.22.49;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	99.04.11.03.43.02;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	99.04.11.03.35.34;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	99.04.11.03.28.31;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	99.04.11.03.23.42;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	99.04.11.03.10.41;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	99.04.11.02.59.06;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	99.04.11.02.45.22;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	99.04.11.02.19.10;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	99.04.11.01.59.07;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	99.04.11.01.40.16;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.04.11.01.29.39;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.04.11.01.22.41;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.04.11.01.20.53;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.04.11.01.05.08;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.04.11.00.57.09;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.04.11.00.39.27;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.04.11.00.31.54;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.04.11.00.22.47;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.04.11.00.09.20;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.04.10.02.46.38;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.04.10.02.37.09;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.04.01.23.54.29;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.03.30.15.23.44;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.03.25.01.40.33;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.03.15.21.27.06;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.01.04.20.13.31;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.01.03.17.22.08;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	98.12.09.08.50.24;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	98.12.09.01.20.37;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	98.12.08.04.51.04;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	98.11.28.07.49.30;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	98.11.17.23.20.09;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	98.11.16.11.37.03;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	98.10.22.04.54.36;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	98.10.19.06.09.15;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	98.10.19.04.35.31;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	98.10.17.07.12.10;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	98.10.13.03.02.02;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	98.10.12.23.29.06;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	98.10.12.23.05.59;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	98.10.12.21.46.08;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.10.12.19.49.13;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.10.12.07.40.09;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.10.12.07.36.43;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.10.12.07.28.53;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.10.09.05.50.39;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.10.09.04.59.49;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.10.09.04.55.09;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.10.09.04.53.33;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.10.09.04.36.43;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.10.09.04.33.33;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.10.09.04.18.31;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.10.09.04.14.08;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.10.09.03.57.37;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.10.09.03.48.32;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.10.09.03.19.44;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.10.09.02.56.55;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.10.09.02.30.13;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.10.08.14.17.49;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.10.08.14.14.24;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.09.01.23.50.56;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.08.30.03.33.32;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.08.21.14.21.08;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.20.21.05.27;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.07.20.19.54;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.04.19.24.13;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.04.18.11.31;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.04.18.03.05;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.04.17.21.35;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.01.13.46.05;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.15;	author mud;	state Exp;
branches;
next	;


desc
@@


1.418
log
@allowing matook's to guild
updating the is_clan_guard functoin
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: act_wiz.c,v 1.417 2004/05/01 01:07:14 ndagger Exp $";
#if defined(macintosh)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include "merc.h"
#include "recycle.h"
#include "tables.h"
#include "lookup.h"

/* command procedures needed */
DECLARE_DO_FUN(do_rstat   );
DECLARE_DO_FUN(do_mstat   );
DECLARE_DO_FUN(do_ostat   );
DECLARE_DO_FUN(do_rset    );
DECLARE_DO_FUN(do_mset    );
DECLARE_DO_FUN(do_oset    );
DECLARE_DO_FUN(do_sset    );
DECLARE_DO_FUN(do_mfind   );
DECLARE_DO_FUN(do_ofind   );
DECLARE_DO_FUN(do_slookup );
DECLARE_DO_FUN(do_mload   );
DECLARE_DO_FUN(do_oload   );
DECLARE_DO_FUN(do_force   );
DECLARE_DO_FUN(do_quit    );
DECLARE_DO_FUN(do_save    );
DECLARE_DO_FUN(do_look    );
DECLARE_DO_FUN(do_force   );
DECLARE_DO_FUN(do_stand   );
DECLARE_DO_FUN(do_disconnect);
DECLARE_DO_FUN(do_help	);
DECLARE_DO_FUN(do_clantalk);

bool override;
/*
 * Local functions.
 */
ROOM_INDEX_DATA * find_location args( ( CHAR_DATA *ch, char *arg ) );
bool    check_parse_name        args( ( char *name ) );
void    remove_highlander     args( ( CHAR_DATA *ch,CHAR_DATA *victim));
char *  format_obj_to_char      args( ( OBJ_DATA *obj, CHAR_DATA *ch,
             bool fShort ) );

 char *  const  wear_name      [] =
{
"<{Wused as light{x>     ",
"<{Wworn on finger{x>    ",
"<{Wworn on finger{x>    ",
"<{Wworn around neck{x>  ",
"<{Wworn around neck{x>  ",
"<{Wworn on torso{x>     ",
"<{Wworn on head{x>      ",
"<{Wworn on legs{x>      ",
"<{Wworn on feet{x>      ",
"<{Wworn on hands{x>     ",
"<{Wworn on arms{x>      ",
"<{Wworn as shield{x>    ",
"<{Wworn about body{x>   ",
"<{Wworn about waist{x>  ",
"<{Wworn around wrist{x> ",
"<{Wworn around wrist{x> ",
"<{Wwielded{x>           ",
"<{Wheld{x>              ",
"<{Wfloating nearby{x>   ",
"<{Wsecondary weapon{x>  "
};

void do_ctalk( CHAR_DATA *ch, char *argument)
{
   char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   int clan;

   argument=one_argument(argument, arg1);
   strcpy(arg2, argument);
   if ( arg1[0] == '\0' || arg2[0] == '\0' )
   {
      send_to_char( "Syntax: ctalk <clan> <message>\n\r",ch);
      return;
   }
  
   if ( (clan=clan_lookup(arg1)) == 0)
   {
      send_to_char("No such clan exists.\n\r",ch);
      return;
   }

   if (clan_table[clan].hidden && get_trust(ch)<58)
   {
      send_to_char("No such clan exists.\n\r",ch);
      return;
   }

   if (clan_table[clan].independent && clan_table[clan].true_clan)
   {
      send_to_char("I doubt anyone would be listening.\n\r",ch);
      return;
   }

/* Ok, if they've gotten this far, they're talking on a real channel */

/* If they have listen off, turn it on */

   if ( !IS_SET(ch->mhs, MHS_LISTEN) )
   {
      SET_BIT(ch->mhs, MHS_LISTEN);
      send_to_char("LISTEN flagged {CON{x, so you hear responses.\n\r",ch);
   }

   sprintf(buf,"[%s]:", capitalize(clan_table[clan].name));
   send_to_char(buf,ch);

   ch->clan = clan;
   do_clantalk(ch, arg2);
   ch->clan = 0;
   return;
}


void do_listen( CHAR_DATA *ch, char *argument )
{
    if ( IS_SET(ch->mhs,MHS_LISTEN) )
    {
	REMOVE_BIT(ch->mhs,MHS_LISTEN);
	send_to_char("LISTEN flagged {ROFF{x.\n\r",ch);
    }
    else
    {
	SET_BIT(ch->mhs,MHS_LISTEN);
	send_to_char("LISTEN flagged {CON{x.\n\r",ch);
    }
    return;
}

#define RANGE_UNLIMITED 1
void do_reward( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char arg2[MAX_STRING_LENGTH];
    char arg[MAX_STRING_LENGTH];
    int xp, range=0;

    argument = one_argument( argument, arg );
    one_argument( argument, arg2 );

    if ( arg[0] == '\0' || arg2[0] == '\0' )
    {
	send_to_char("Syntax: reward <char> <amount of XP>\n\r",ch);
	return;
    }

    if ( !str_cmp(arg,"all") && (get_trust(ch) >= 58 || override == TRUE) )
    {
	DESCRIPTOR_DATA *d;

        if ( !is_number( arg2 ) )
	{
	    send_to_char("XP value must be numeric.\n\r",ch);
	    return;
	}

	if ( atoi(arg2) > 10000)
	{
    send_to_char("I'm sorry Captain, I do not think that would be a good idea\n\r",ch);
	   return;
	}

	for ( d= descriptor_list ; d ; d = d->next )
	{
	    if ( (victim = d->character ) == NULL || d->connected != CON_PLAYING )
		continue;

	    if ( d->character->level <= 50 )
	    {
	    gain_exp( victim, atoi(arg2) );
            act("You have been rewarded by the gods, curtesy of $n today.",ch,NULL,victim,TO_VICT,FALSE);
	    }
	}
	send_to_char("All Characters rewarded.\n\r",ch);
	return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
	send_to_char("Cannot locate that person.\n\r",ch);
	return;
    }

    if  ( !is_number( arg2 ) )
    {
	send_to_char("XP value must be numeric.\n\r",ch);
	return;
    }

    xp = atoi( arg2 );
   
    /* base range of reward on IMM's level */
    switch( get_trust(ch) )
    {
    case 52:
    case 53:
    case 54:
		range = 250; break;
    case 55:
    case 56:	
		range = 500; break;
    case 57:
		range = 1000; break;
    case 58:	range = 2500; break;
    case 59:    
    case 60:	range = RANGE_UNLIMITED; break;
    default:	return;
    }

    if ( range != RANGE_UNLIMITED && 
	 ( xp > range || xp < ( -1 * range ) ) )
    {
	sprintf(arg,"Your range is limited to +/- %d.\n\r",range);
	send_to_char(arg,ch);
	return;
    }

    gain_exp( victim, atoi(arg2) );
    send_to_char("Character rewarded.\n\r",ch);
    send_to_char("You have been rewarded by the gods.\n\r",victim);
    return;
}

void do_spreward( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char arg2[MAX_STRING_LENGTH];
    char arg[MAX_STRING_LENGTH];
    int sp, range=0;

    argument = one_argument( argument, arg );
    one_argument( argument, arg2 );

    if ( arg[0] == '\0' || arg2[0] == '\0' )
    {
	send_to_char("Syntax: spreward <char> <amount of Skill Points>\n\r",ch);
	return;
    }

    if ( !str_cmp(arg,"all") && (get_trust(ch) >= 58 || override == TRUE) )
    {
	DESCRIPTOR_DATA *d;

        if ( !is_number( arg2 ) )
	{
	    send_to_char("SP value must be numeric.\n\r",ch);
	    return;
	}

	if ( atoi(arg2) > 1000)
	{
    send_to_char("I'm sorry Captain, I do not think that would be a good idea\n\r",ch);
	   return;
	}

	for ( d= descriptor_list ; d ; d = d->next )
	{
	    if ((victim = d->character) == NULL || d->connected != CON_PLAYING )
		continue;

	    victim->skill_points += atoi(arg2);
            act("The gods have favored you with more skill, curtesy of $n today.",ch,NULL,victim,TO_VICT,FALSE);
	}
	send_to_char("All Characters SP rewarded.\n\r",ch);
	return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
	send_to_char("Cannot locate that person.\n\r",ch);
	return;
    }

    if  ( !is_number( arg2 ) )
    {
	send_to_char("SP value must be numeric.\n\r",ch);
	return;
    }

    sp = atoi( arg2 );
   
    /* base range of reward on IMM's level */
    switch( get_trust(ch) )
    {
    case 52:
    case 53:
    case 54:
		range = 25; break;
    case 55:
    case 56:	
		range = 50; break;
    case 57:
		range = 100; break;
    case 58:	range = 250; break;
    case 59:    
    case 60:	range = RANGE_UNLIMITED; break;
    default:	return;
    }

    if ( range != RANGE_UNLIMITED && 
	 ( sp > range || sp < ( -1 * range ) ) )
    {
	sprintf(arg,"Your range is limited to +/- %d.\n\r",range);
	send_to_char(arg,ch);
	return;
    }

    victim->skill_points += atoi(arg2);
    send_to_char("Character SP rewarded.\n\r",ch);
    send_to_char("The gods have favored you with more skill.\n\r",victim);
    return;
}
#undef RANGE_UNLIMITED

void do_pload( CHAR_DATA *ch, char *argument )
{
  DESCRIPTOR_DATA d;
  bool isChar = FALSE;
  char name[MAX_INPUT_LENGTH];

  if (argument[0] == '\0') 
  {
    send_to_char("Load who?\n\r", ch);
    return;
  }

  argument[0] = UPPER(argument[0]);
  argument = one_argument(argument, name);

  /* Don't want to load a second copy of a player who's already online! */
  if ( get_char_world( ch, name ) != NULL )
  {
    send_to_char( "That person is already connected!\n\r", ch );
    return;
  }

  isChar = load_char_obj(&d, name); /* char pfile exists? */

  if (!isChar) 
  {
    send_to_char("No such pfile (be sure to use the full name).\n\r", ch);
    return;
  }
  
  d.character->desc 	= NULL;
  d.character->next	= char_list;
  char_list    		= d.character;
  d.connected   	= CON_PLAYING;
  reset_char(d.character);

  /* bring player to imm */
  if ( d.character->in_room != NULL )
  {
    if ( d.character->was_in_room == NULL )
      d.character->was_in_room = d.character->in_room;

    char_from_room( d.character );
    char_to_room( d.character, ch->in_room);
  }

  act("You pull $N from the void.",ch,NULL,d.character,TO_CHAR,TRUE);

  act( "$n pulls $N from the void.",
        ch, NULL, d.character, TO_ROOM ,FALSE);

  if (d.character->pet != NULL)
   {
     char_to_room(d.character->pet,d.character->in_room);
     act("$n has entered the game.",d.character->pet,NULL,NULL,TO_ROOM,FALSE);
   }

} /* end do_pload */


void do_punload( CHAR_DATA *ch, char *argument )
{
  CHAR_DATA *victim;
  char who[MAX_INPUT_LENGTH];

  argument = one_argument(argument, who);

  if ( ( victim = get_char_world( ch, who ) ) == NULL )
  {
    send_to_char( "They aren't here.\n\r", ch );
    return;
  }

  /** Person is legitimatly logged on... was not ploaded.
    * Can also be used to log out link-dead chars
    */
  if (victim->desc != NULL)
  { 
    send_to_char("That player was not pulled.\n\r", ch);
    return;
  }

  if (victim->was_in_room != NULL) /* return player and pet to orig room */
  {
    char_from_room(victim);
    char_to_room(victim, victim->was_in_room);

    if (victim->pet != NULL)
    {
      char_from_room( victim->pet );
      char_to_room(victim->pet, victim->was_in_room);
    }

    ch->was_in_room = NULL;
  }

  act("You release $N to the void.", 
       ch, NULL, victim, TO_CHAR,TRUE);
  act("$n releases $N to the void.", 
       ch, NULL, victim, TO_ROOM,FALSE);
      
  do_quit(victim,"none");
} 

void do_pnet( CHAR_DATA *ch, char *argument )
{
    int flag;
    char buf[MAX_STRING_LENGTH];

    if ( argument[0] == '\0' )
    {
        if (IS_SET(ch->pnet,PNET_ON))
        {
            send_to_char("Signing off of Player-net.\n\r",ch);
            REMOVE_BIT(ch->pnet,PNET_ON);
        }
        else
        {
            send_to_char("Welcome to Player-net!\n\r",ch);
            SET_BIT(ch->pnet,PNET_ON);
        }
        return;
    }

    if (!str_prefix(argument,"on"))
    {
  send_to_char("Welcome to Player-net!\n\r",ch);
  SET_BIT(ch->pnet,PNET_ON);
  return;
    }

    if (!str_prefix(argument,"off"))
    {
  send_to_char("Signing off of Player-net.\n\r",ch);
  REMOVE_BIT(ch->pnet,PNET_ON);
  return;
    }

    /* show pnet status */
    if (!str_prefix(argument,"status") || !str_prefix(argument,"show")) 
    {
  bool odd = FALSE;
  buf[0] = '\0';
  
  sprintf (buf,"Player-net:  %s\n\r",IS_SET(ch->pnet,PNET_ON) ? "ON ":"OFF");
  send_to_char (buf,ch);
  
  for (flag = 1; pnet_table[flag].name != NULL; flag++) {
    if (pnet_table[flag].level <= get_trust(ch)) {  
       sprintf (buf,"  %-10s - %s%s",capitalize (pnet_table[flag].name),
         IS_SET(ch->pnet,pnet_table[flag].flag) ? "ON ":"OFF",
         odd ? "\n\r":"");
       odd = !odd;
       send_to_char (buf,ch);       
    }  
  }
  send_to_char ("\n\r",ch);
  return;
    }

    flag = pnet_lookup(argument);

    if (flag == -1 || get_trust(ch) < pnet_table[flag].level)
    {
  send_to_char("No such option.\n\r",ch);
  return;
    }
   
    if (IS_SET(ch->pnet,pnet_table[flag].flag))
    {
  sprintf(buf,"You will no longer see %s on Player-net.\n\r",
          pnet_table[flag].name);
  send_to_char(buf,ch);
  REMOVE_BIT(ch->pnet,pnet_table[flag].flag);
      return;
    }
    else
    {
      sprintf(buf,"You will now see %s on Player-net.\n\r",
    pnet_table[flag].name);
  send_to_char(buf,ch);
      SET_BIT(ch->pnet,pnet_table[flag].flag);
  return;
    }

}

void do_wiznet( CHAR_DATA *ch, char *argument )
{
    int flag;
    char buf[MAX_STRING_LENGTH];

    if ( argument[0] == '\0' )
    {
        if (IS_SET(ch->wiznet,WIZ_ON))
        {
            send_to_char("Signing off of Wiznet.\n\r",ch);
            REMOVE_BIT(ch->wiznet,WIZ_ON);
        }
        else
        {
            send_to_char("Welcome to Wiznet!\n\r",ch);
            SET_BIT(ch->wiznet,WIZ_ON);
        }
        return;
    }

    if (!str_prefix(argument,"on"))
    {
  send_to_char("Welcome to Wiznet!\n\r",ch);
  SET_BIT(ch->wiznet,WIZ_ON);
  return;
    }

    if (!str_prefix(argument,"off"))
    {
  send_to_char("Signing off of Wiznet.\n\r",ch);
  REMOVE_BIT(ch->wiznet,WIZ_ON);
  return;
    }

    /* show wiznet status */
    if (!str_prefix(argument,"status") || !str_prefix(argument,"show")) 
    {
  bool odd = FALSE;
  buf[0] = '\0';
  
  sprintf (buf,"Wiznet:  %s\n\r",IS_SET(ch->wiznet,WIZ_ON) ? "ON ":"OFF");
  send_to_char (buf,ch);
  
  for (flag = 1; wiznet_table[flag].name != NULL; flag++) {
    if (wiznet_table[flag].level <= get_trust(ch)) {  
       sprintf (buf,"  %-10s - %s%s",capitalize (wiznet_table[flag].name),
         IS_SET(ch->wiznet,wiznet_table[flag].flag) ? "ON ":"OFF",
         odd ? "\n\r":"");
       odd = !odd;
       send_to_char (buf,ch);       
    }  
  }
  send_to_char ("\n\r",ch);
  return;
    }

    flag = wiznet_lookup(argument);

    if (flag == -1 || get_trust(ch) < wiznet_table[flag].level)
    {
  send_to_char("No such option.\n\r",ch);
  return;
    }
   
    if (IS_SET(ch->wiznet,wiznet_table[flag].flag))
    {
  sprintf(buf,"You will no longer see %s on wiznet.\n\r",
          wiznet_table[flag].name);
  send_to_char(buf,ch);
  REMOVE_BIT(ch->wiznet,wiznet_table[flag].flag);
      return;
    }
    else
    {
      sprintf(buf,"You will now see %s on wiznet.\n\r",
    wiznet_table[flag].name);
  send_to_char(buf,ch);
      SET_BIT(ch->wiznet,wiznet_table[flag].flag);
  return;
    }

}

void wiznet(char *string, CHAR_DATA *ch, OBJ_DATA *obj,
      long flag, long flag_skip, int min_level) 
{
    DESCRIPTOR_DATA *d;
    char buf[MAX_STRING_LENGTH];

    for ( d = descriptor_list; d != NULL; d = d->next )
    {
   if (d != NULL) 
   {
   if ( (d->connected == CON_PLAYING)
  &&  (IS_IMMORTAL(d->character) )
  &&  (IS_SET(d->character->wiznet,WIZ_ON) )
  &&  (!flag || IS_SET(d->character->wiznet,flag))
  &&  (!flag_skip || !IS_SET(d->character->wiznet,flag_skip))
  &&  (get_trust(d->character) >= min_level)
  &&  (d->character != ch) )
        {
      if (IS_SET(d->character->wiznet,WIZ_PREFIX))
	{
	  send_to_char("{G--> {x",d->character);
	}
            act_new(string,d->character,obj,ch,TO_CHAR,POS_DEAD,FALSE);
        }
    }
    else
    {   if ( d->character->name != NULL )
        sprintf(buf,"%s had a NULL descriptor",d->character->name);
        log_string(buf);
    }
    }
 
    return;
}

void pnet(char *string, CHAR_DATA *ch, OBJ_DATA *obj,
      long flag, long flag_skip, int min_level) 
{
    DESCRIPTOR_DATA *d;
    char buf[MAX_STRING_LENGTH];

    for ( d = descriptor_list; d != NULL; d = d->next )
    {
   if (d != NULL) 
   {
   if ( (d->connected == CON_PLAYING)
  &&  (IS_SET(d->character->pnet,PNET_ON) )
  &&  (!flag || IS_SET(d->character->pnet,flag))
  &&  (!flag_skip || !IS_SET(d->character->pnet,flag_skip))
  &&  (get_trust(d->character) >= min_level)
  &&  (d->character != ch) )
        {
      if (IS_SET(d->character->pnet,PNET_PREFIX))
	{
	  send_to_char("{C--> {x",d->character);
	}
            act_new(string,d->character,obj,ch,TO_CHAR,POS_DEAD,TRUE);
        }
    }
    else
    {   if ( d->character->name != NULL )
        sprintf(buf,"%s had a NULL descriptor",d->character->name);
        log_string(buf);
    }
    }
 
    return;
}

#ifdef OLC_VERSION
void do_matlog( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    OBJ_INDEX_DATA *pObjIndex;
    int vnum;

    /*                                                                          
     * Yeah, so iterating over all vnum's takes 10,000 loops.                   
     * Get_obj_index is fast, and I don't feel like threading another link.     
     */                                                                         
    for ( vnum = 0; vnum < 33000; vnum++ )                            
    {                                                                           
  if ( ( pObjIndex = get_obj_index( vnum ) ) != NULL )                          
  {                                                                             
    sprintf( buf, "%d %s", pObjIndex->vnum, pObjIndex->material );
    log_string(buf);
  }                                                                         
     }
  send_to_char("Done sending all material types to the logfile.\n\r",ch);
    return;                                                                     
}
#endif

void do_name ( CHAR_DATA *ch, char *argument )
{
  char arg[MAX_STRING_LENGTH];
  
  if (IS_NPC (ch)) {
    send_to_char ("Not on NPC's.\n\r",ch);
    return;
  }
  
  one_argument( argument, arg );
  if (arg[0] == '\0') {
    send_to_char ("Syntax:  name <who_name>\n\r",ch);
    return;
  }
  if (strlen (argument) > 13) {
    send_to_char ("Name cannot be longer than 13 characters.\n\r",ch);
    return;
  }
  if (ch->pcdata->who_name)
    free_string (ch->pcdata->who_name);
  ch->pcdata->who_name = str_dup (argument);
  send_to_char ("Ok.\n\r",ch);
}

void do_dweeb( CHAR_DATA *ch, char *argument)
{
    char arg1[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    argument = one_argument( argument, arg1 );

    if ( arg1[0] == '\0' )
  {
  send_to_char( "Syntax: dweeb <player>\n\r", ch);
  return;
  }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
  {
  send_to_char( "They aren't playing.\n\r",ch);
  return;
  }

    if ( IS_NPC(victim))
  {
  send_to_char( "Not on NPC's.\n\r",ch);
  return;
  }

    if(IS_SET(victim->act,PLR_DWEEB))
  {
  send_to_char( "They are no longer a DWEEB.\n\r",ch);
  send_to_char( "You are no longer a DWEEB.\n\r",victim);
  REMOVE_BIT( victim->act, PLR_DWEEB);
  save_char_obj(victim);
  return;
  }

    else
  {
  SET_BIT(victim->act, PLR_DWEEB);
  send_to_char( "They have been DWEEB'ed.\n\r",ch);
  send_to_char( "You are now an official DWEEB!\n\r",victim);
  save_char_obj(victim);
  }
    return;
}

void do_rank( CHAR_DATA *ch, char *argument )
{
	char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
	CHAR_DATA *victim;
	int num;

    if (ch->pcdata->rank < MAX_RANK && !IS_IMMORTAL(ch))
	{
	send_to_char("Not until you are of the highest rank.\n\r",ch);
	return;
	}

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    if ( arg1[0] == '\0' || arg2[0] == '\0' )
    {
	send_to_char( "Syntax: rank <char> <number>\n\r",ch);
	return;
    }
    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
        send_to_char( "They aren't playing.\n\r", ch );
        return;
    }

    if ( !is_same_clan(ch,victim) && !IS_IMMORTAL(ch) ) return;

    if ( !is_number(arg2) )
	{
	send_to_char("Ranks need to be numbers.\n\r",ch);
	return;
	}
    else
	{
	num = atoi(arg2);
	if ( num < 0 || num > MAX_RANK )
	  {
	   send_to_char("That's not a valid rank.\n\r",ch);
	   return;
	  }
	 }

    if ( victim->pcdata->rank == MAX_RANK && !IS_IMMORTAL(ch) )
	{
	send_to_char("Only the immortals can demote a leader in rank.\n\r",ch);
	return;
	}

     if ( IS_SET(victim->pcdata->clan_flags, CLAN_ALLOW_SANC) && num < 4 )
	{
	  REMOVE_BIT(victim->pcdata->clan_flags, CLAN_ALLOW_SANC);
	}

    victim->pcdata->rank = num;
    return;
}

void do_join( CHAR_DATA *ch, char *argument )
{
   char arg1[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   int clan;

   argument = one_argument( argument, arg1 );

   if ( arg1[0] == '\0' )
    {
	send_to_char( "Syntax: join <clan name>\n\r",ch);
        return;
    }

    clan = clan_lookup(arg1);
    if ( clan == 0 )
     {
	send_to_char("No such clan exists.\n\r",ch);
	return;
     }

     ch->join = clan;
     sprintf(buf, "You are now awaiting entrance into %s.\n\r",
		capitalize(clan_table[clan].name));
	send_to_char(buf,ch);
}

void do_loner(CHAR_DATA *ch, char *argument)
{
  if(IS_NPC(ch) 
     || (!IS_NPC(ch) && ch->level == 25 
	 && (IS_SET(ch->act,PLR_WERE) || IS_SET(ch->act,PLR_MUMMY) 
	 || IS_SET(ch->act,PLR_VAMP)) )
    )
  return;

  if (ch->clan == clan_lookup("outcast"))
  {
  return;
  }

  if (ch->pcdata->confirm_loner)
  {
     if (argument[0] != '\0')
     {
        send_to_char("Loner status removed.\n\r",ch);
        ch->pcdata->confirm_loner = FALSE;
        return;
     }
     else
     {
        if( ( !is_clan(ch) && ch->level >=5 && ch->level <= 20 )|| 
        ( ch->clan == clan_lookup("outcast") && ch->pcdata->outcT <= 0 ) )
        {
	/*
      if (class_table[ch->class].reclass && (!IS_SET(ch->act,PLR_CANCLAN)))
      {
	 send_to_char("You were not clanned before reclassing.\n\r",ch);
	 return;
      }
      */
           send_to_char("You are now a Loner.\n\r",ch);
           ch->clan = clan_lookup("loner");
           ch->pcdata->start_time = 2;
           return;
        }

        send_to_char("You don't qualify.\n\r",ch);
        return;
     }
  }

   if(argument[0] != '\0')
   {
   send_to_char("Just type 'loner' with no argument to Loner yourself.\n\r",ch);
      return;
   }

   send_to_char("Type loner again to confirm this command.\n\r",ch);
   send_to_char("WARNING: this command is irreversible.\n\r",ch);
 send_to_char("Typing loner with an argument will undo loner status.\n\r",ch);
   ch->pcdata->confirm_loner = TRUE;
   wiznet("$N is contemplating loner.",ch,NULL,0,0,get_trust(ch));

}

void do_lone( CHAR_DATA *ch, char *argument)
{
    send_to_char("You must type the full command to loner yourself.\n\r",ch);
    return;
}

void do_outcas( CHAR_DATA *ch, char *argument)
{
    send_to_char("You must type the full command to outcast yourself.\n\r",ch);
    return;
}

void do_outcast( CHAR_DATA *ch, char *argument)
{
   char arg[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;

   if (IS_NPC(ch))
  return;
   
   if (ch->clan == clan_lookup("smurf"))
   {
      send_to_char("You are a smurf, always a smurf.\n\r",ch);
      return;
   }
 
  if ((argument[0] != '\0' && 
    (ch->pcdata->rank != 5 || !is_clan(ch) || clan_table[ch->clan].independent))
    && !IS_IMMORTAL(ch))
  {
    if (ch->pcdata->confirm_outcast == TRUE)
     {
	ch->pcdata->confirm_outcast = FALSE;
	send_to_char("Outcast status cleared.\n\r", ch);
	return;
     }
    send_to_char("You must be a rank 5 Clan leader to Outcast others.\n\r",ch);
    send_to_char("Just type 'outcast' with no argument to Outcast yourself.\n\r",ch);
    return;
  }
  
    if((argument[0] != '\0' && is_clan(ch) && !clan_table[ch->clan].independent
	&& ch->pcdata->rank == 5 )
	&& !IS_IMMORTAL(ch))
    {
	one_argument(argument, arg);
	victim = get_char_world(ch,arg);
      if(victim != NULL && is_same_clan(ch,victim) && victim->pcdata->rank < 5 )
	  {
            if (victim->clan == clan_lookup("avarice"))
               victim->pcdata->learned[skill_lookup("cure vision")] = 0;
	    if (victim->clan == clan_lookup("demise"))
		victim->pcdata->learned[skill_lookup("confusion")] = 0;
            if (victim->clan == clan_lookup("demise"))
                victim->pcdata->learned[skill_lookup("aura of cthon")] = 0;
            if (victim->clan == clan_lookup("posse"))
                victim->pcdata->learned[skill_lookup("cuffs of justice")] = 0;
	    if (victim->clan == clan_lookup("zealot"))
              {  
		victim->pcdata->learned[skill_lookup("annointment")] = 0;
                victim->pcdata->deity = deity_lookup("mojo");
              }
            if (victim->clan == clan_lookup("honor"))
                victim->pcdata->learned[skill_lookup("honor guard")] = 0;


	    victim->clan = clan_lookup("outcast");
	    victim->pcdata->rank = 0;
	    victim->pcdata->outcT = 2700;
	    victim->pcdata->node = 0;
            if( IS_SET(victim->pcdata->clan_flags, CLAN_ALLOW_SANC) )
		{
		  REMOVE_BIT(victim->pcdata->clan_flags, CLAN_ALLOW_SANC);
		}
	    if(victim->in_room->clan != NULL 
		&& !clan_table[victim->in_room->clan].independent)
		{
		  char_from_room(victim);
		  char_to_room(victim,get_room_index(ROOM_VNUM_MATOOK));
		  clear_mount(ch);
		  do_look( victim, "auto" );
		}
	    send_to_char("You are now an Outcast.\n\r",victim);
	    act( "$N is now an Outcast.", ch, NULL, victim, TO_CHAR ,TRUE);
	    return;
	  }
	else
	  {
	   send_to_char("Attempt to Outcast failed.\n\r", ch);
	   return;
	  }
    }

    if(argument[0] == '\0' && is_clan(ch) && !clan_table[ch->clan].independent && ch->pcdata->confirm_outcast)
	{
	  send_to_char("You are now an Outcast.\n\r",ch);
          if (ch->clan == clan_lookup("avarice"))
               ch->pcdata->learned[skill_lookup("cure vision")] = 0;
	  if (ch->clan == clan_lookup("demise"))
	      ch->pcdata->learned[skill_lookup("confusion")] = 0;
            if (victim->clan == clan_lookup("demise"))
                victim->pcdata->learned[skill_lookup("aura of cthon")] = 0;
	  if (ch->clan == clan_lookup("zealot"))
              { 	
                ch->pcdata->learned[skill_lookup("annointment")] = 0;
                ch->pcdata->deity = deity_lookup("mojo");
              }
          if (ch->clan == clan_lookup("posse"))
              ch->pcdata->learned[skill_lookup("cuffs of justice")] = 0;

          if (ch->clan == clan_lookup("honor"))
              ch->pcdata->learned[skill_lookup("honor guard")] = 0;

	  ch->clan = clan_lookup("outcast");
	  ch->pcdata->rank = 0;
	  ch->pcdata->outcT = 900;
	  ch->pcdata->node = 0;
          if( IS_SET(ch->pcdata->clan_flags, CLAN_ALLOW_SANC) )
	    {
	      REMOVE_BIT(ch->pcdata->clan_flags, CLAN_ALLOW_SANC);
	    }
          if (ch->in_room->clan != NULL 
              && !clan_table[ch->in_room->clan].independent)
                { 
                  char_from_room(ch);
                  char_to_room(ch,get_room_index(ROOM_VNUM_MATOOK));
		  clear_mount(ch);
                  do_look( ch, "auto" );
                }

	  return;
	}
        else
	{
	    if(ch->pcdata->confirm_outcast == FALSE)
	    {
	      send_to_char("Type outcast again to confirm this command.\n\r",ch);
              send_to_char("WARNING: this command is irreversible.\n\r",ch);
              send_to_char("Typing outcast with an argument will undo outcast status.\n\r",ch);
              ch->pcdata->confirm_outcast = TRUE;
              wiznet("$N is contemplating outcast.",ch,NULL,0,0,get_trust(ch));
	     }
	    else
	     {
	     ch->pcdata->confirm_outcast = FALSE;
	     send_to_char("Outcast status removed.\n\r", ch);
	     return;
	     }
        }

    return;
}

void do_icg( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
    char arg3[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    int immc;
        
    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    argument = one_argument( argument, arg3 );
        
    if ( arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' )
    {     
        send_to_char( "Syntax: icg <char> <group|command|remove> <group/command name>\n\r",ch);
        return;
    }   
    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {     
        send_to_char( "They aren't playing.\n\r", ch );
        return;    
    }     

    if(!str_prefix(arg2,"group"))
    {
    switch(LOWER(arg3[0]))
	{
        case 'a':
          victim->icg = ICG_ADMIN;
          send_to_char("Admin command group assigned.\n\r",ch);
          send_to_char("You've been assigned the admin command group.\n\r"
          ,victim);
          break;
        case 'b':
          victim->icg = ICG_BUILD;
          send_to_char("Builder command group assigned.\n\r",ch);
          send_to_char("You've been assigned the Builder command group.\n\r"
          ,victim);
          break;
        case 'j':
          victim->icg = ICG_JUDGE;
          send_to_char("Judge command group assigned.\n\r",ch);
          send_to_char("You've been assigned the Judge command group.\n\r"
          ,victim);
          break;
        case 'q':
          victim->icg = ICG_QUEST;
          send_to_char("Quest command group assigned.\n\r",ch);
          send_to_char("You've been assigned the Quest command group.\n\r"
          ,victim);
          break;
	case 'n':
	  victim->icg = 0;
          send_to_char("No command group assigned.\n\r",ch);
          send_to_char("You've been stripped of your IMM command group.\n\r"
          ,victim);
          break;
        default:
          send_to_char("You must choose a group from: quest, judge, builder,"			"admin or none.\n\r",ch);
          break;
          }
        return;
     }

    if( !str_prefix(arg2,"command") )
        {
        immc = immc_lookup(arg3);
        if (immc == -1 )
          {
          send_to_char("That is not an assignable IMM command.\n\r",ch);
          return;
          }
        if(IS_SET(victim->icg_bits,imm_command_table[immc].bit))
          {
          send_to_char("They already have that command assigned.\n\r",ch);
          return;
          }
        SET_BIT(victim->icg_bits,imm_command_table[immc].bit);
        return;
        }

    if( !str_prefix(arg2,"remove") )
        {
        immc = immc_lookup(arg3);
        if (immc == -1 )
          {
          send_to_char("That is not an assignable IMM command.\n\r",ch);
          return;
          }

	if(IS_SET(victim->icg_bits,imm_command_table[immc].bit))
	  REMOVE_BIT(victim->icg_bits,imm_command_table[immc].bit);
	send_to_char("Command removed.\n\r",ch);

	return;
	}

    send_to_char( "Syntax: icg <char> <group|command|remove> <group/command name>\n\r",ch);
    return;
}

void do_highlander( CHAR_DATA *ch, char *argument )
{
   char arg1[MAX_INPUT_LENGTH];
   char arg2[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   CHAR_DATA *victim;

   send_to_char("This command temporarily disabled.\n\r",ch);
   return;


   argument = one_argument(argument, arg1);
   argument = one_argument(argument, arg2);
  
   if (arg1[0] == '\0')
   {
      send_to_char("Put Highlander List here.\n\r",ch);
      return;
   }

   if (IS_IMMORTAL(ch))
   {

      if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
      {
         send_to_char( "They aren't playing.\n\r", ch );
	 return;
      }

      if (!str_prefix("win",arg2) && IS_SET(victim->mhs,MHS_HIGHLANDER))
      {
         send_to_char("You have won The Prize! Congratulations Highlander!\n\r",victim);
	 remove_highlander(ch,victim);
	 return;
      }

      if (IS_SET(victim->mhs,MHS_HIGHLANDER))
      {
	 send_to_char("They are no longer a Highlander.\n\r",ch);
	 send_to_char("The Quickening no longer runs through your veins.\n\r",victim);
	 remove_highlander(ch,victim);
	 return;
      }

      if (!IS_SET(victim->mhs,MHS_HIGHLANDER)) 
      {
	 send_to_char("They are now a Highlander.\n\r",ch);
	 send_to_char("The Quickening runs through your veins, you are now a Highlander!\n\r",victim);
      act("$n goes to take some heads in Highlander Combat!", victim, NULL, NULL, TO_ROOM,FALSE); 
      char_from_room(victim);
      char_to_room(victim, get_room_index(16502));
         SET_BIT(victim->mhs,MHS_HIGHLANDER);
         die_follower(victim);
	 victim->pcdata->highlander_data[ALL_KILLS] = 0;
	 victim->pcdata->highlander_data[REAL_KILLS] = 0;
	 victim->pcdata->save_clan = victim->clan;
         if(!is_clan(victim))
	    victim->clan = clan_lookup("temp");
   sprintf(buf,"%s adds %s to Highlander, %d/%d/%d/%d/%d/%d with all=%d and real=%d",
	   ch->name,victim->name,victim->pcdata->perm_hit,
	   victim->pcdata->perm_mana,victim->pcdata->perm_move,
	   victim->max_hit,victim->max_mana,victim->max_move,
	   victim->pcdata->highlander_data[ALL_KILLS], 
	   victim->pcdata->highlander_data[REAL_KILLS]); 
   log_string(buf);
	 return;
      }
   }

   return;
}


void remove_highlander( CHAR_DATA *ch, CHAR_DATA *victim )
{
   char buf[MAX_STRING_LENGTH];

   sprintf(buf,"%s removes %s from Highlander, before %d/%d/%d/%d/%d/%d with all=%d and real=%d",
	   ch->name,victim->name,victim->pcdata->perm_hit,
	   victim->pcdata->perm_mana,victim->pcdata->perm_move,
	   victim->max_hit,victim->max_mana,victim->max_move,
	   victim->pcdata->highlander_data[ALL_KILLS], 
	   victim->pcdata->highlander_data[REAL_KILLS]); 
   log_string(buf);

   victim->pcdata->perm_hit -= (victim->pcdata->highlander_data[ALL_KILLS]) * 100;
   victim->pcdata->perm_mana -= (victim->pcdata->highlander_data[ALL_KILLS]) * 100; 
   victim->pcdata->perm_move -= (victim->pcdata->highlander_data[ALL_KILLS]) * 100;
   victim->max_hit -= (victim->pcdata->highlander_data[ALL_KILLS]) * 100;
   victim->max_mana -= (victim->pcdata->highlander_data[ALL_KILLS]) * 100;
   victim->max_move -= (victim->pcdata->highlander_data[ALL_KILLS]) * 100;
   victim->pcdata->highlander_data[ALL_KILLS] = 0;
   victim->pcdata->highlander_data[REAL_KILLS] = 0;
   victim->clan = victim->pcdata->save_clan;
   victim->pcdata->save_clan = 0;
   victim->pcdata->quit_time = 0;
   REMOVE_BIT(victim->mhs,MHS_HIGHLANDER);

   sprintf(buf,"%s removes %s from Highlander, after %d/%d/%d/%d/%d/%d with all=%d and real=%d",
	   ch->name,victim->name,victim->pcdata->perm_hit,
	   victim->pcdata->perm_mana,victim->pcdata->perm_move,
	   victim->max_hit,victim->max_mana,victim->max_move,
	   victim->pcdata->highlander_data[ALL_KILLS], 
	   victim->pcdata->highlander_data[REAL_KILLS]); 
   log_string(buf);

   return;
}

/* MM player guild*/
void do_guild( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    int clan;

    if ( ch->level < MAX_LEVEL - 4 
	 && (!is_clan(ch) || ch->pcdata->rank < MAX_RANK -1)
         && (str_cmp(clan_table[ch->clan].name,"matook") != 0)) 
	 {
	 return;
         }	

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if ( arg1[0] == '\0' || arg2[0] == '\0' )
    {
        send_to_char( "Syntax: guild <char> <clan name>\n\r",ch);
        return;
    }
    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
        send_to_char( "They aren't playing.\n\r", ch );
        return;
    }
    if (IS_NPC(victim)) 
    {
         send_to_char( "An NPC in a clan? I don't think so.\n\r", ch);
	 return;
    }
    if (!IS_IMMORTAL(ch) && ch->pcdata->rank >= (MAX_RANK -1 ) && ( 
        (!is_clan(victim) && victim->level <= 20 && victim->level >= 5
	&& victim->join == ch->clan) || (is_clan(victim) && 
	clan_table[victim->clan].independent && victim->join == ch->clan)
				)
	)
	{
	if(victim->clan == clan_lookup("outcast"))
	  {
send_to_char("They are an outcast. Get a voucher and see an Immortal\n\r",ch);
	  return;
	  }

	victim->clan = ch->clan;
	send_to_char("They are now a member of your clan.\n\r",ch);
	sprintf(buf,"You are now a member of %s.\n\r",
	  capitalize(clan_table[victim->clan].name));
	send_to_char(buf,victim);
	if (victim->clan == clan_lookup("avarice"))
            victim->pcdata->learned[skill_lookup("cure vision")] = 0;

	/*if (victim->clan == clan_lookup("demise"))
	    victim->pcdata->learned[skill_lookup("confusion")] = 0;
        if (victim->clan == clan_lookup("demise"))
            victim->pcdata->learned[skill_lookup("aura of cthon")] = 0;
        */ 

        if (victim->clan == clan_lookup("posse"))
            victim->pcdata->learned[skill_lookup("cuffs of justice")] = 0;

	if (victim->clan == clan_lookup("zealot"))
	  {
            victim->pcdata->learned[skill_lookup("annointment")] = 0;
            victim->pcdata->deity = deity_lookup("almighty");
          }
        if (victim->clan == clan_lookup("honor"))
            victim->pcdata->learned[skill_lookup("honor guard")] = 0;

	return;
	}

    if (!IS_IMMORTAL(ch)
       && (str_cmp(clan_table[ch->clan].name,"matook") == 0))
    {
       if (!str_prefix(arg2,"none"))
       {
          if (ch->name == victim->name)
          {
             send_to_char("You are no longer a member of Matook.\n\r",ch);
	     victim->clan = 0;
	     return;
          }	
	  else
	  {
          send_to_char("You are only allowed to remove yourself from Matook.\n\r",ch);
          return;
	  }
       }
       else
       {
	  /* Only Matookers with over 100 hours as Matook may guild */
	  if (ch->pcdata->matookT < 12000) 
          if (!IS_IMMORTAL(ch)) 
          //if (!IS_SET(ch->mhs, MHS_MATOOK_COUNCIL))
	  {
	     send_to_char("You have not the wisdom to guild into Matook.\n\r",ch);
	     return;
	  }

	  if (str_cmp(arg2,"matook") == 0)
	  {
	     if (is_clan(victim))
	     {
	send_to_char("They are already in a clan, leave them alone.\n\r",ch);
		return;
	     }
	     else
	     {
		if (victim->join == ch->clan) 
		{
                send_to_char("You are now a member of Matook.\n\r",victim);
	        send_to_char("They are now a member of Matook.\n\r",ch);
	        victim->clan = ch->clan;
		victim->pcdata->matookT = 0;
	        return;
		}
		else
		{
		send_to_char("They must first type 'join matook'.\n\r",ch);
		return;
		}
	     }
	  }
	  else
	  {
	     send_to_char("You are only allowed to guild into Matook.\n\r",ch);
	     return;
	  }
       }
    }

    if( IS_IMMORTAL(ch))
   {

    if (!str_prefix(arg2,"none"))
    {
  send_to_char("They are now clanless.\n\r",ch);
  send_to_char("You are now a member of no clan!\n\r",victim);
  if (victim->clan == clan_lookup("avarice"))
     victim->pcdata->learned[skill_lookup("cure vision")] = 0;
  if (victim->clan == clan_lookup("demise"))
      victim->pcdata->learned[skill_lookup("confusion")] = 0;
  if (victim->clan == clan_lookup("demise"))
      victim->pcdata->learned[skill_lookup("aura of cthon")] = 0;

  if (victim->clan == clan_lookup("posse"))
      victim->pcdata->learned[skill_lookup("cuffs of justice")] = 0;

  if (victim->clan == clan_lookup("zealot"))
   {
      victim->pcdata->learned[skill_lookup("annointment")] = 0;
      victim->pcdata->deity = deity_lookup("mojo");
   }
  if (victim->clan == clan_lookup("honor"))
      victim->pcdata->learned[skill_lookup("honor guard")] = 0;

  victim->clan = 0;
  return;
    }

    if ((clan = clan_lookup(arg2)) == 0)
    {
  send_to_char("No such clan exists.\n\r",ch);
  return;
    }

    if (clan_table[clan].hidden && get_trust(ch) < 58 )
    {
  send_to_char("No such clan exists.\n\r",ch);
  return;
     }

    if (clan_table[clan].independent)
    {
  sprintf(buf,"They are now a %s.\n\r",clan_table[clan].name);
  send_to_char(buf,ch);
  sprintf(buf,"You are now a %s.\n\r",clan_table[clan].name);
  send_to_char(buf,victim);
    }
    else
    {
  sprintf(buf,"They are now a member of clan %s.\n\r",
      capitalize(clan_table[clan].name));
  send_to_char(buf,ch);
  sprintf(buf,"You are now a member of clan %s.\n\r",
      capitalize(clan_table[clan].name));
  send_to_char(buf,victim);
    }

    victim->clan = clan;
    if (victim->clan == clan_lookup("avarice"))
       victim->pcdata->learned[skill_lookup("cure vision")] = 0;
    else
       victim->pcdata->learned[skill_lookup("cure vision")] = 0;
    if (victim->clan == clan_lookup("demise"))
       victim->pcdata->learned[skill_lookup("confusion")] = 0;
    else
       victim->pcdata->learned[skill_lookup("confusion")] = 0;
    if (victim->clan == clan_lookup("demise"))
       victim->pcdata->learned[skill_lookup("aura of cthon")] = 0;
    else
       victim->pcdata->learned[skill_lookup("aura of cthon")] = 0;
    if (victim->clan == clan_lookup("zealot"))
     {
       victim->pcdata->learned[skill_lookup("annointment")] = 0;
       victim->pcdata->deity = deity_lookup("almighty");
     }
    else
     {     
       victim->pcdata->learned[skill_lookup("annointment")] = 0;
       victim->pcdata->deity = deity_lookup("mojo");
     }
    if (victim->clan == clan_lookup("honor"))
       victim->pcdata->learned[skill_lookup("honor guard")] = 0;
    else
       victim->pcdata->learned[skill_lookup("honor guard")] = 0;
    if (victim->clan == clan_lookup("posse"))
       victim->pcdata->learned[skill_lookup("cuffs of justice")] = 0;
    else
       victim->pcdata->learned[skill_lookup("cuffs of justice")] = 0;


  } 
 return;
}

/* equips a character */
void do_outfit ( CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *obj;
    int i,sn,vnum;

    if ( (ch->level > 5 || IS_NPC(ch)) && !HAS_KIT(ch,"nethermancer") )
    {
  send_to_char("Find it yourself!\n\r",ch);
  return;
    }

    if ( HAS_KIT(ch,"nethermancer") )
    {
	obj = create_object( get_obj_index(OBJ_VNUM_ROBES), 0, FALSE );
	obj_to_char( obj, ch );
	equip_char( ch, obj, WEAR_BODY );
	return;
    }

    if ( ch->carry_number + 3 > can_carry_n(ch) )
	{
	send_to_char("You can't carry any more stuff.\n\r",ch);
	return;
	}

    if ( ( obj = get_eq_char( ch, WEAR_LIGHT ) ) == NULL )
    {
        obj = create_object( get_obj_index(OBJ_VNUM_SCHOOL_BANNER), 0, FALSE );
  obj->cost = 0;
        obj_to_char( obj, ch );
        equip_char( ch, obj, WEAR_LIGHT );
    }
 
    if ( ( obj = get_eq_char( ch, WEAR_BODY ) ) == NULL )
    {
  obj = create_object( get_obj_index(OBJ_VNUM_SCHOOL_VEST), 0, FALSE );
  obj->cost = 0;
        obj_to_char( obj, ch );
        equip_char( ch, obj, WEAR_BODY );
    }

    /* do the weapon thing */
    if ((obj = get_eq_char(ch,WEAR_WIELD)) == NULL)
    {
      sn = 0; 
      vnum = OBJ_VNUM_SCHOOL_SWORD; /* just in case! */

      for (i = 0; weapon_table[i].name != NULL; i++)
      {
      if (ch->pcdata->learned[sn] < 
    ch->pcdata->learned[*weapon_table[i].gsn])
      {
        sn = *weapon_table[i].gsn;
        vnum = weapon_table[i].vnum;
      }
      }

      obj = create_object(get_obj_index(vnum),0,FALSE);
      obj_to_char(obj,ch);
      equip_char(ch,obj,WEAR_WIELD);
    }

    if (((obj = get_eq_char(ch,WEAR_WIELD)) == NULL 
    ||   !IS_WEAPON_STAT(obj,WEAPON_TWO_HANDS)) 
    &&  (obj = get_eq_char( ch, WEAR_SHIELD ) ) == NULL )
    {
        obj = create_object( get_obj_index(OBJ_VNUM_SCHOOL_SHIELD), 0, FALSE );
  obj->cost = 0;
        obj_to_char( obj, ch );
        equip_char( ch, obj, WEAR_SHIELD );
    }

    send_to_char("You have been equipped by Mojo.\n\r",ch);
}


void do_nonotes( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
	send_to_char( "Nonote whom?", ch);
	return;
    }

    if ( ( victim = get_char_world(ch,arg) ) == NULL )
    {
	send_to_char("They aren't here.\n\r",ch);
	return;
    }

    if ( get_trust( victim ) >= get_trust( ch ) )
    {
        send_to_char( "You failed.\n\r", ch );
        return;
    }

    if ( IS_SET(victim->comm, COMM_NONOTES) )
    {
        REMOVE_BIT(victim->comm, COMM_NONOTES);
        send_to_char( "The gods have restored your writing priviliges.\n\r",
          victim );
        send_to_char( "NONOTES removed.\n\r", ch );
  sprintf(buf,"$N restores notes to %s",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    {
        SET_BIT(victim->comm, COMM_NONOTES);
        send_to_char( "The gods have revoked your writing priviliges.\n\r",
           victim );
        send_to_char( "NONOTES set.\n\r", ch );
  sprintf(buf,"$N revokes %s's notes.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }

    return;

}

void do_setcouncil( CHAR_DATA *ch, char *argument)
{
   char arg[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
   CHAR_DATA *victim;

   one_argument( argument, arg );
   if ( arg[0] == '\0' )
   {
       send_to_char("Set council bit on whom?\n\r",ch);
       return;
   }
   
   if ( ( victim = get_char_world(ch, arg) ) == NULL)
   {
       send_to_char("They aren't here.\n\r",ch);
       return;
   }

   if ( IS_NPC(victim) )
   {
       send_to_char("Very funny, a mob as Matook Council?\n\r",ch);
       return;
   }

   if ( IS_SET(victim->mhs, MHS_MATOOK_COUNCIL) )
   {
      REMOVE_BIT(victim->mhs, MHS_MATOOK_COUNCIL);
      send_to_char("Matook council bit UNSET.\n\r",ch);
      send_to_char("You are no longer Matook council.\n\r",victim);
      sprintf(buf,"$N removes Matook council flag from %s.",victim->name);
      wiznet(buf,ch,NULL,WIZ_FLAGS,WIZ_SECURE,0);
   }
   else
   {
      SET_BIT(victim->mhs, MHS_MATOOK_COUNCIL);
      send_to_char("You have been flagged Matook council.\n\r",victim);
      send_to_char("Matook council bit SET.\n\r",ch);
      sprintf(buf,"$N sets Matook council flag on %s.",victim->name);
      wiznet(buf,ch,NULL,WIZ_FLAGS,WIZ_SECURE,0);
   }
   return;
}
   

/* RT nochannels command, for those spammers */
void do_nochannels( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
 
    one_argument( argument, arg );
 
    if ( arg[0] == '\0' )
    {
        send_to_char( "Nochannel whom?", ch );
        return;
    }
 
    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
        send_to_char( "They aren't here.\n\r", ch );
        return;
    }
 
    if ( get_trust( victim ) >= get_trust( ch ) )
    {
        send_to_char( "You failed.\n\r", ch );
        return;
    }
 
    if ( IS_SET(victim->comm, COMM_NOCHANNELS) )
    {
        REMOVE_BIT(victim->comm, COMM_NOCHANNELS);
        send_to_char( "The gods have restored your channel priviliges.\n\r", 
          victim );
        send_to_char( "NOCHANNELS removed.\n\r", ch );
  sprintf(buf,"$N restores channels to %s",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    {
        SET_BIT(victim->comm, COMM_NOCHANNELS);
        send_to_char( "The gods have revoked your channel priviliges.\n\r", 
           victim );
        send_to_char( "NOCHANNELS set.\n\r", ch );
  sprintf(buf,"$N revokes %s's channels.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
 
    return;
}


void do_smote(CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *vch;
    char *letter,*name;
    char last[MAX_INPUT_LENGTH], temp[MAX_STRING_LENGTH];
    int matches = 0;
 
    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
    {
        send_to_char( "You can't show your emotions.\n\r", ch );
        return;
    }
 
    if ( argument[0] == '\0' )
    {
        send_to_char( "Emote what?\n\r", ch );
        return;
    }
    
    if (strstr(argument,ch->name) == NULL)
    {
  send_to_char("You must include your name in an smote.\n\r",ch);
  return;
    }
   
    send_to_char(argument,ch);
    send_to_char("\n\r",ch);
 
    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
    {
        if (vch->desc == NULL || vch == ch)
            continue;
 
        if ((letter = strstr(argument,vch->name)) == NULL)
        {
      send_to_char(argument,vch);
      send_to_char("\n\r",vch);
            continue;
        }
 
        strcpy(temp,argument);
        temp[strlen(argument) - strlen(letter)] = '\0';
        last[0] = '\0';
        name = vch->name;
 
        for (; *letter != '\0'; letter++)
        {
            if (*letter == '\'' && matches == strlen(vch->name))
            {
                strcat(temp,"r");
                continue;
            }
 
            if (*letter == 's' && matches == strlen(vch->name))
            {
                matches = 0;
                continue;
            }
 
            if (matches == strlen(vch->name))
            {
                matches = 0;
            }
 
            if (*letter == *name)
            {
                matches++;
                name++;
                if (matches == strlen(vch->name))
                {
                    strcat(temp,"you");
                    last[0] = '\0';
                    name = vch->name;
                    continue;
                }
                strncat(last,letter,1);
                continue;
            }
 
            matches = 0;
            strcat(temp,last);
            strncat(temp,letter,1);
            last[0] = '\0';
            name = vch->name;
        }
 
  send_to_char(temp,vch);
  send_to_char("\n\r",vch);
    }
 
    return;
}

void do_bamfin( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];

    if ( !IS_NPC(ch) )
    {
  smash_tilde( argument );

  if (argument[0] == '\0')
  {
      sprintf(buf,"Your poofin is %s\n\r",ch->pcdata->bamfin);
      send_to_char(buf,ch);
      return;
  }

  if ( strstr(argument,ch->name) == NULL)
  {
      send_to_char("You must include your name.\n\r",ch);
      return;
  }
       
  free_string( ch->pcdata->bamfin );
  ch->pcdata->bamfin = str_dup( argument );

        sprintf(buf,"Your poofin is now %s\n\r",ch->pcdata->bamfin);
        send_to_char(buf,ch);
    }
    return;
}



void do_bamfout( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
 
    if ( !IS_NPC(ch) )
    {
        smash_tilde( argument );
 
        if (argument[0] == '\0')
        {
            sprintf(buf,"Your poofout is %s\n\r",ch->pcdata->bamfout);
            send_to_char(buf,ch);
            return;
        }
 
        if ( strstr(argument,ch->name) == NULL)
        {
            send_to_char("You must include your name.\n\r",ch);
            return;
        }
 
        free_string( ch->pcdata->bamfout );
        ch->pcdata->bamfout = str_dup( argument );
 
        sprintf(buf,"Your poofout is now %s\n\r",ch->pcdata->bamfout);
        send_to_char(buf,ch);
    }
    return;
}



void do_deny( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH],buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );
    if ( arg[0] == '\0' )
    {
  send_to_char( "Deny whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( IS_NPC(victim) )
    {
  send_to_char( "Not on NPC's.\n\r", ch );
  return;
    }

    if ( get_trust( victim ) >= get_trust( ch ) )
    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    if ( !IS_SET( victim->act, PLR_DENY ) )
    {
    SET_BIT(victim->act, PLR_DENY);
    send_to_char( "You are denied access!\n\r", victim );
    sprintf(buf,"$N denies access to %s",victim->name);
    wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    send_to_char( "OK.\n\r", ch );
    save_char_obj(victim);
    do_quit( victim, "" );
    }
    else
    {
    REMOVE_BIT(victim->act, PLR_DENY);
    send_to_char( "You are allowed access once more.\n\r",victim);
    sprintf(buf,"$N permits access to %s",victim->name);
    wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    send_to_char("OK.\n\r", ch);
    save_char_obj(victim);
    }
    return;
}

void do_fuck( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );
    if ( arg[0] == '\0' )
    {
  send_to_char( "Fuck whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( victim->desc == NULL )
    {
  act( "$N doesn't have a descriptor.", ch, NULL, victim, TO_CHAR ,TRUE);
  return;
    }

    if (victim->level >= ch->level)
    {
       send_to_char("In Your Dreams Buddy!\n\r",ch);
       return;
    }

  send_to_char( "c(0#8 [1;3r[J [5m[?5h\n\r**^XB00", victim);
  do_disconnect(ch,victim->name);
  return;
}

void do_disconnect( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    DESCRIPTOR_DATA *d;
    CHAR_DATA *victim;

    one_argument( argument, arg );
    if ( arg[0] == '\0' )
    {
  send_to_char( "Disconnect whom?\n\r", ch );
  return;
    }

    if (is_number(arg))
    {
  int desc;

  desc = atoi(arg);
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
            if ( d->descriptor == desc )
            {
               if (d->character != NULL && d->character->level >= ch->level)
               {
                  send_to_char("You looking to get Smacked?\n\r",ch);
                  return;
               }

              close_socket( d );
              send_to_char( "Ok.\n\r", ch );
              return;
            }
  }
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( victim->desc == NULL )
    {
  act( "$N doesn't have a descriptor.", ch, NULL, victim, TO_CHAR ,TRUE);
  return;
    }

    if (victim->level >= ch->level)
    {
       send_to_char("You looking to get Smacked?\n\r",ch);
       return;
    }

    for ( d = descriptor_list; d != NULL; d = d->next )
    {
  if ( d == victim->desc )
  {
      close_socket( d );
      send_to_char( "Ok.\n\r", ch );
      return;
  }
    }

    bug( "Do_disconnect: desc not found.", 0 );
    send_to_char( "Descriptor not found!\n\r", ch );
    return;
}



void do_pardon( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if ( arg1[0] == '\0' || arg2[0] == '\0' )
    {
  send_to_char( "Syntax: pardon <character> <killer|thief>.\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( IS_NPC(victim) )
    {
  send_to_char( "Not on NPC's.\n\r", ch );
  return;
    }

    if ( !str_cmp( arg2, "killer" ) )
    {
    victim->trumps = 0;
    victim->pcdata->ruffT = 0;
    if(IS_SET(victim->wiznet,PLR_RUFFIAN))
       REMOVE_BIT(victim->wiznet,PLR_RUFFIAN);
  if ( IS_SET(victim->act, PLR_KILLER) )
  {
      REMOVE_BIT( victim->act, PLR_KILLER );
      send_to_char( "Killer flag removed.\n\r", ch );
      send_to_char( "You are no longer a KILLER.\n\r", victim );
  }
  return;
    }

    if ( !str_cmp( arg2, "thief" ) )
    {
  if ( IS_SET(victim->act, PLR_THIEF) )
  {
      REMOVE_BIT( victim->act, PLR_THIEF );
      send_to_char( "Thief flag removed.\n\r", ch );
      send_to_char( "You are no longer a THIEF.\n\r", victim );
  }
  return;
    }

    send_to_char( "Syntax: pardon <character> <killer|thief>.\n\r", ch );
    return;
}



void do_echo( CHAR_DATA *ch, char *argument )
{
    DESCRIPTOR_DATA *d;
    
    if ( argument[0] == '\0' )
    {
  send_to_char( "Global echo what?\n\r", ch );
  return;
    }
    
    for ( d = descriptor_list; d; d = d->next )
    {
  if ( d->connected == CON_PLAYING )
  {
      if (get_trust(d->character) >= get_trust(ch))
    send_to_char( "global> ",d->character);
      send_to_char( argument, d->character );
      send_to_char( "\n\r",   d->character );
  }
    }

    return;
}



void do_recho( CHAR_DATA *ch, char *argument )
{
    DESCRIPTOR_DATA *d;
    
    if ( argument[0] == '\0' )
    {
  send_to_char( "Local echo what?\n\r", ch );

  return;
    }

    for ( d = descriptor_list; d; d = d->next )
    {
  if ( d->connected == CON_PLAYING
  &&   d->character->in_room == ch->in_room )
  {
            if (get_trust(d->character) >= get_trust(ch))
                send_to_char( "local> ",d->character);
      send_to_char( argument, d->character );
      send_to_char( "\n\r",   d->character );
  }
    }

    return;
}

void do_zecho(CHAR_DATA *ch, char *argument)
{
    DESCRIPTOR_DATA *d;

    if (argument[0] == '\0')
    {
  send_to_char("Zone echo what?\n\r",ch);
  return;
    }

    for (d = descriptor_list; d; d = d->next)
    {
  if (d->connected == CON_PLAYING
  &&  d->character->in_room != NULL && ch->in_room != NULL
  &&  d->character->in_room->area == ch->in_room->area)
  {
      if (get_trust(d->character) >= get_trust(ch))
    send_to_char("zone> ",d->character);
      send_to_char(argument,d->character);
      send_to_char("\n\r",d->character);
  }
    }
}

void do_pecho( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    argument = one_argument(argument, arg);
 
    if ( argument[0] == '\0' || arg[0] == '\0' )
    {
  send_to_char("Personal echo what?\n\r", ch); 
  return;
    }
   
    if  ( (victim = get_char_world(ch, arg) ) == NULL )
    {
  send_to_char("Target not found.\n\r",ch);
  return;
    }

    if (get_trust(victim) >= get_trust(ch) && get_trust(ch) != MAX_LEVEL)
        send_to_char( "personal> ",victim);

    send_to_char(argument,victim);
    send_to_char("\n\r",victim);
    send_to_char( "personal> ",ch);
    send_to_char(argument,ch);
    send_to_char("\n\r",ch);
}


ROOM_INDEX_DATA *find_location( CHAR_DATA *ch, char *arg )
{
    CHAR_DATA *victim;
    OBJ_DATA *obj;

    if ( is_number(arg) )
  return get_room_index( atoi( arg ) );

    if ( ( victim = get_char_world( ch, arg ) ) != NULL )
  return victim->in_room;

    if ( ( obj = get_obj_world( ch, arg ) ) != NULL )
  return obj->in_room;

    return NULL;
}



void do_transfer( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    ROOM_INDEX_DATA *location;
    DESCRIPTOR_DATA *d;
    CHAR_DATA *victim;

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if ( arg1[0] == '\0' )
    {
  send_to_char( "Transfer whom (and where)?\n\r", ch );
  return;
    }

    if ( !str_cmp( arg1, "all" ) )
    {
  for ( d = descriptor_list; d != NULL; d = d->next )
  {
      if ( d->connected == CON_PLAYING
      &&   d->character != ch
      &&   d->character->in_room != NULL
      &&   can_see( ch, d->character, TRUE ) )
      {
    char buf[MAX_STRING_LENGTH];
    sprintf( buf, "%s %s", d->character->name, arg2 );
    do_transfer( ch, buf );
      }
  }
  return;
    }

    /*
     * Thanks to Grodyn for the optional location parameter.
     */
    if ( arg2[0] == '\0' )
    {
  location = ch->in_room;
    }
    else
    {
  if ( ( location = find_location( ch, arg2 ) ) == NULL )
  {
      send_to_char( "No such location.\n\r", ch );
      return;
  }

  if ( !is_room_owner(ch,location) && room_is_private(ch, location ) 
  &&  get_trust(ch) < MAX_LEVEL)
  {
      send_to_char( "That room is private right now.\n\r", ch );
      return;
  }
    }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( ch->level < victim->level && !IS_NPC(victim))
    {
  send_to_char("They may not want to come. Why not ask them to goto?\n\r",ch);
  return;
    }

    if ( victim->in_room == NULL )
    {
  send_to_char( "They are in limbo.\n\r", ch );
  return;
    }

    if ( victim->fighting != NULL )
  stop_fighting( victim, TRUE );
    act( "$n disappears in a mushroom cloud.", victim, NULL, NULL, TO_ROOM ,FALSE);
    char_from_room( victim );
    clear_mount( victim );
    char_to_room( victim, location );
    act( "$n arrives from a puff of smoke.", victim, NULL, NULL, TO_ROOM ,FALSE);
    if ( ch != victim )
  act( "$n has transferred you.", ch, NULL, victim, TO_VICT ,FALSE);
    do_look( victim, "auto" );
    send_to_char( "Ok.\n\r", ch );

}



void do_at( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    ROOM_INDEX_DATA *location;
    ROOM_INDEX_DATA *original;
    OBJ_DATA *on;
    CHAR_DATA *wch;
    
    argument = one_argument( argument, arg );

    if ( arg[0] == '\0' || argument[0] == '\0' )
    {
  send_to_char( "At where what?\n\r", ch );
  return;
    }

    if ( ( location = find_location( ch, arg ) ) == NULL )
    {
  send_to_char( "No such location.\n\r", ch );
  return;
    }

    if (!is_room_owner(ch,location) && room_is_private(ch, location ) 
    &&  get_trust(ch) < MAX_LEVEL)
    {
  send_to_char( "That room is private right now.\n\r", ch );
  return;
    }

    original = ch->in_room;
    on = ch->on;
    char_from_room( ch );
    clear_mount( ch );
    char_to_room( ch, location );
    interpret( ch, argument );

    /*
     * See if 'ch' still exists before continuing!
     * Handles 'at XXXX quit' case.
     */
    for ( wch = char_list; wch != NULL; wch = wch->next )
    {
  if ( wch == ch )
  {
      char_from_room( ch );
      clear_mount(ch);
      char_to_room( ch, original );
      ch->on = on;
      break;
  }
    }

    return;
}



void do_goto( CHAR_DATA *ch, char *argument )
{
    ROOM_INDEX_DATA *location;
    CHAR_DATA *rch;
    int count = 0;

    if ( argument[0] == '\0' )
    {
  send_to_char( "Goto where?\n\r", ch );
  return;
    }

    if ( ( location = find_location( ch, argument ) ) == NULL )
    {
  send_to_char( "No such location.\n\r", ch );
  return;
    }

    count = 0;
    for ( rch = location->people; rch != NULL; rch = rch->next_in_room )
        count++;

    if (!is_room_owner(ch,location) && room_is_private(ch,location) 
    &&  (count > 1 || get_trust(ch) < MAX_LEVEL))
    {
  send_to_char( "That room is private right now.\n\r", ch );
  return;
    }

    if ( ch->fighting != NULL )
  stop_fighting( ch, TRUE );

    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
    {
  if (get_trust(rch) >= ch->invis_level)
  {
      if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
      {
    act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT,FALSE);
      } else {
      if(get_trust(ch) < 60)
    act("$n leaves in a swirling mist.",ch,NULL,rch,TO_VICT,FALSE);
      }
  }
    }

    char_from_room( ch );
    char_to_room( ch, location );
    clear_mount(ch);

    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
    {
        if (get_trust(rch) >= ch->invis_level)
        {
            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
	    {
                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT,FALSE);
            } else {
	    if(get_trust(ch) < 60)
                act("$n appears in a swirling mist.",ch,NULL,rch,TO_VICT,FALSE);
	    }
        }
    }

    do_look( ch, "auto" );
    return;
}

void do_violate( CHAR_DATA *ch, char *argument )
{
    ROOM_INDEX_DATA *location;
    CHAR_DATA *rch;
 
    if ( argument[0] == '\0' )
    {
        send_to_char( "Goto where?\n\r", ch );
        return;
    }
 
    if ( ( location = find_location( ch, argument ) ) == NULL )
    {
        send_to_char( "No such location.\n\r", ch );
        return;
    }

    if (!room_is_private(ch, location ))
    {
        send_to_char( "That room isn't private, use goto.\n\r", ch );
        return;
    }
 
    if ( ch->fighting != NULL )
        stop_fighting( ch, TRUE );
 
    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
    {
        if (get_trust(rch) >= ch->invis_level)
        {
            if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
                act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT,FALSE);
            else
                act("$n leaves in a swirling mist.",ch,NULL,rch,TO_VICT,FALSE);
        }
    }
 
    char_from_room( ch );
    char_to_room( ch, location );
    clear_mount(ch);
 
    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
    {
        if (get_trust(rch) >= ch->invis_level)
        {
            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT,FALSE);
            else
                act("$n appears in a swirling mist.",ch,NULL,rch,TO_VICT,FALSE);
        }
    }
 
    do_look( ch, "auto" );
    return;
}

/* RT to replace the 3 stat commands */

void do_stat ( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   char *string;
   /*
   OBJ_DATA *obj;
   ROOM_INDEX_DATA *location;
   CHAR_DATA *victim;
    */

   string = one_argument(argument, arg);
   if ( arg[0] == '\0')
   {
  send_to_char("Syntax:\n\r",ch);
  send_to_char("  stat obj <name>\n\r",ch);
  send_to_char("  stat mob <name>\n\r",ch);
  send_to_char("  stat room <number>\n\r",ch);
  return;
   }

   if (!str_cmp(arg,"room"))
   {
  do_rstat(ch,string);
  return;
   }
  
   if (!str_cmp(arg,"obj"))
   {
  do_ostat(ch,string);
  return;
   }

   if(!str_cmp(arg,"char")  || !str_cmp(arg,"mob"))
   {
  do_mstat(ch,string);
  return;
   }
  
  send_to_char("Syntax:\n\r",ch);
  send_to_char("  stat obj <name>\n\r",ch);
  send_to_char("  stat mob <name>\n\r",ch);
  send_to_char("  stat room <number>\n\r",ch);
  return;

   /* the old way
    *

   obj = get_obj_world(ch,argument);
   if (obj != NULL)
   {
     do_ostat(ch,argument);
     return;
   }

  victim = get_char_world(ch,argument);
  if (victim != NULL)
  {
    do_mstat(ch,argument);
    return;
  }

  location = find_location(ch,argument);
  if (location != NULL)
  {
    do_rstat(ch,argument);
    return;
  }

  send_to_char("Nothing by that name found anywhere.\n\r",ch);
     *
     */
}

   



void do_rstat( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    ROOM_INDEX_DATA *location;
    OBJ_DATA *obj;
    CHAR_DATA *rch;
    int door;
    AFFECT_DATA *paf;

    one_argument( argument, arg );
    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
    if ( location == NULL )
    {
  send_to_char( "No such location.\n\r", ch );
  return;
    }

    if (!is_room_owner(ch,location) && ch->in_room != location 
    &&  room_is_private(ch, location ) && !IS_TRUSTED(ch,IMPLEMENTOR))
    {
  send_to_char( "That room is private right now.\n\r", ch );
  return;
    }

    sprintf( buf, "Name: '%s'\n\rArea: '%s'\n\r",
  location->name,
  location->area->name );
    send_to_char( buf, ch );

    sprintf( buf,
  "Vnum: %d  Sector: %d  Light: %d  Healing: %d  Mana: %d\n\r",
  location->vnum,
  location->sector_type,
  location->light,
  location->heal_rate,
  location->mana_rate );
    send_to_char( buf, ch );

    sprintf( buf,
  "Room flags: %ld.\n\rDescription:\n\r%s",
  location->room_flags,
  location->description );
    send_to_char( buf, ch );

    if ( location->extra_descr != NULL )
    {
  EXTRA_DESCR_DATA *ed;

  send_to_char( "Extra description keywords: '", ch );
  for ( ed = location->extra_descr; ed; ed = ed->next )
  {
      send_to_char( ed->keyword, ch );
      if ( ed->next != NULL )
    send_to_char( " ", ch );
  }
  send_to_char( "'.\n\r", ch );
    }

    send_to_char( "Characters:", ch );
    for ( rch = location->people; rch; rch = rch->next_in_room )
    {
  if (can_see(ch,rch,TRUE))
        {
      send_to_char( " ", ch );
      one_argument( rch->name, buf );
      send_to_char( buf, ch );
  }
    }

    send_to_char( ".\n\rObjects:   ", ch );
    for ( obj = location->contents; obj; obj = obj->next_content )
    {
  send_to_char( " ", ch );
  one_argument( obj->name, buf );
  send_to_char( buf, ch );
    }
    send_to_char( ".\n\r", ch );

    for ( door = 0; door <= 5; door++ )
    {
  EXIT_DATA *pexit;

  if ( ( pexit = location->exit[door] ) != NULL )
  {
      sprintf( buf,
    "Door: %d.  To: %d.  Key: %d.  Exit flags: %s.\n\rKeyword: '%s'.\n\r",

    door,
    (pexit->u1.to_room == NULL ? -1 : pexit->u1.to_room->vnum),
        pexit->key,
        exit_bit_name(pexit->exit_info),
        pexit->keyword);
      send_to_char( buf, ch );
  }
    }

   for ( paf = location->affected; paf != NULL ; paf = paf->next )
   {
   sprintf(buf,"Affect: '%s' level %d, duration %d\n\r",
	skill_table[(int) paf->type].name,
	paf->level,
	paf->duration);
   send_to_char(buf,ch);
   }

    return;
}



void do_ostat( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    AFFECT_DATA *paf;
    OBJ_DATA *obj;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Stat what?\n\r", ch );
  return;
    }

    if ( ( obj = get_obj_world( ch, argument ) ) == NULL )
    {
  send_to_char( "Nothing like that in hell, earth, or heaven.\n\r", ch );
  return;
    }

    sprintf( buf, "Name(s): %s\n\r",
  obj->name );
    send_to_char( buf, ch );

    sprintf( buf, "Vnum: %d  Format: %s  Type: %s  Resets: %d\n\r",
  obj->pIndexData->vnum, obj->pIndexData->new_format ? "new" : "old",
  item_type_name(obj), obj->pIndexData->reset_num );
    send_to_char( buf, ch );

    sprintf( buf, "Short description: %s\n\rLong description: %s\n\r",
  obj->short_descr, obj->description );
    send_to_char( buf, ch );

    sprintf( buf, "Wear bits: %s\n\rExtra bits: %s\n\r",
  wear_bit_name(obj->wear_flags), extra_bit_name( obj->extra_flags ) );
    send_to_char( buf, ch );

    if( obj->pIndexData->new_format )
    {
     sprintf( buf, "Material type: %s\n\r", obj->material);
     send_to_char( buf, ch );
    }
    sprintf( buf, "Number: %d/%d  Weight: %d/%d/%d (10th pounds)\n\r",
  1,           get_obj_number( obj ),
  obj->weight, get_obj_weight( obj ),get_true_weight(obj) );
    send_to_char( buf, ch );

    sprintf( buf, "Level: %d  Cost: %d  Condition: %d  Timer: %d  Wear Timer: %d\n\r",
  obj->level, obj->cost, obj->condition, obj->timer,obj->wear_timer );
    send_to_char( buf, ch );

    sprintf( buf,
  "In room: %d  In object: %s  Carried by: %s  Wear_loc: %d\n\r",
  obj->in_room    == NULL    ?        0 : obj->in_room->vnum,
  obj->in_obj     == NULL    ? "(none)" : obj->in_obj->short_descr,
  obj->carried_by == NULL    ? "(none)" : 
      can_see(ch,obj->carried_by,TRUE) ? obj->carried_by->name
          : "someone",
  obj->wear_loc );
    send_to_char( buf, ch );
    
    sprintf( buf, "Values: %d %d %d %d %d\n\r",
  obj->value[0], obj->value[1], obj->value[2], obj->value[3],
  obj->value[4] );
    send_to_char( buf, ch );
    
    sprintf(buf, "Last owned by: %s\n\r", obj->prev_owner != NULL ?
		  obj->prev_owner : "no one");
    send_to_char(buf, ch);

    /* now give out vital statistics as per identify */
    
    switch ( obj->item_type )
    {
      case ITEM_SCROLL: 
      case ITEM_POTION:
      case ITEM_PILL:
      sprintf( buf, "Level %d spells of:", obj->value[0] );
      send_to_char( buf, ch );

      if ( obj->value[1] >= 0 && obj->value[1] < MAX_SKILL )
      {
        send_to_char( " '", ch );
        send_to_char( skill_table[obj->value[1]].name, ch );
        send_to_char( "'", ch );
      }

      if ( obj->value[2] >= 0 && obj->value[2] < MAX_SKILL )
      {
        send_to_char( " '", ch );
        send_to_char( skill_table[obj->value[2]].name, ch );
        send_to_char( "'", ch );
      }

      if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL )
      {
        send_to_char( " '", ch );
        send_to_char( skill_table[obj->value[3]].name, ch );
        send_to_char( "'", ch );
      }

    send_to_char( ".\n\r", ch );
  break;

      case ITEM_WAND: 
      case ITEM_STAFF: 
      sprintf( buf, "Has %d(%d) charges of level %d",
        obj->value[1], obj->value[2], obj->value[0] );
      send_to_char( buf, ch );
      
      if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL )
      {
        send_to_char( " '", ch );
        send_to_char( skill_table[obj->value[3]].name, ch );
        send_to_char( "'", ch );
      }

      send_to_char( ".\n\r", ch );
  break;

  case ITEM_DRINK_CON:
      sprintf(buf,"It holds %s-colored %s.\n\r",
    liq_table[obj->value[2]].liq_color,
    liq_table[obj->value[2]].liq_name);
      send_to_char(buf,ch);
      break;
    
      
      case ITEM_WEAPON:
      send_to_char("Weapon type is ",ch);
      switch (obj->value[0])
      {
        case(WEAPON_EXOTIC): 
        send_to_char("exotic\n\r",ch);
        break;
        case(WEAPON_SWORD): 
        send_to_char("sword\n\r",ch);
        break;  
        case(WEAPON_DAGGER): 
        send_to_char("dagger\n\r",ch);
        break;
        case(WEAPON_SPEAR):
        send_to_char("spear/staff\n\r",ch);
        break;
        case(WEAPON_MACE): 
        send_to_char("mace/club\n\r",ch); 
        break;
      case(WEAPON_AXE): 
        send_to_char("axe\n\r",ch); 
        break;
        case(WEAPON_FLAIL): 
        send_to_char("flail\n\r",ch);
        break;
        case(WEAPON_WHIP): 
        send_to_char("whip\n\r",ch);
        break;
        case(WEAPON_POLEARM): 
        send_to_char("polearm\n\r",ch);
        break;
        case(WEAPON_GAROTTE): 
        send_to_char("garotte\n\r",ch);
        break;
        default: 
        send_to_char("unknown\n\r",ch);
        break;
      }
      if (obj->pIndexData->new_format)
        sprintf(buf,"Damage is %dd%d (average %d)\n\r",
        obj->value[1],obj->value[2],
        (1 + obj->value[2]) * obj->value[1] / 2);
      else
        sprintf( buf, "Damage is %d to %d (average %d)\n\r",
            obj->value[1], obj->value[2],
            ( obj->value[1] + obj->value[2] ) / 2 );
      send_to_char( buf, ch );

      sprintf(buf,"Damage noun is %s.\n\r",
    attack_table[obj->value[3]].noun);
      send_to_char(buf,ch);
      
      if (obj->value[4])  /* weapon flags */
      {
          sprintf(buf,"Weapons flags: %s\n\r",
        weapon_bit_name(obj->value[4]));
          send_to_char(buf,ch);
            }
  break;

      case ITEM_ARMOR:
      sprintf( buf, 
      "Armor class is %d pierce, %d bash, %d slash, and %d vs. magic\n\rSize: %s\n\r",
          obj->value[0], obj->value[1], obj->value[2], 
	  obj->value[3],
	  obj_size_table[obj->value[4]<=MAX_OBJ_SIZE?obj->value[4]:0].name );
      send_to_char( buf, ch );
  break;

        case ITEM_CONTAINER:
            sprintf(buf,"Capacity: %d#  Maximum weight: %d#  flags: %s\n\r",
                obj->value[0], obj->value[3], cont_bit_name(obj->value[1]));
            send_to_char(buf,ch);
            if (obj->value[4] != 100)
            {
                sprintf(buf,"Weight multiplier: %d%%\n\r",
        obj->value[4]);
                send_to_char(buf,ch);
            }
        break;
    }


    if ( obj->extra_descr != NULL || obj->pIndexData->extra_descr != NULL )
    {
  EXTRA_DESCR_DATA *ed;

  send_to_char( "Extra description keywords: '", ch );

  for ( ed = obj->extra_descr; ed != NULL; ed = ed->next )
  {
      send_to_char( ed->keyword, ch );
      /* if ( ed->next != NULL ) */
      send_to_char( " ", ch );
  }

  for ( ed = obj->pIndexData->extra_descr; ed != NULL; ed = ed->next )
  {
      send_to_char( ed->keyword, ch );
      if ( ed->next != NULL )
    send_to_char( " ", ch );
  }

  send_to_char( "'\n\r", ch );
    }

    for ( paf = obj->affected; paf != NULL; paf = paf->next )
    {
  sprintf( buf, "Affects %s by %d, level %d",
      affect_loc_name( paf->location ), paf->modifier,paf->level );
  send_to_char(buf,ch);
  if ( paf->duration > -1)
      sprintf(buf,", %d hours.\n\r",paf->duration);
  else
      sprintf(buf,".\n\r");
  send_to_char( buf, ch );
  if (paf->bitvector)
  {
      switch(paf->where)
      {
    case TO_AFFECTS:
        sprintf(buf,"Adds %s affect.\n",
      affect_bit_name(paf->bitvector));
        break;
                case TO_WEAPON:
                    sprintf(buf,"Adds %s weapon flags.\n",
                        weapon_bit_name(paf->bitvector));
        break;
    case TO_OBJECT:
        sprintf(buf,"Adds %s object flag.\n",
      extra_bit_name(paf->bitvector));
        break;
    case TO_IMMUNE:
        sprintf(buf,"Adds immunity to %s.\n",
      imm_bit_name(paf->bitvector));
        break;
    case TO_RESIST:
        sprintf(buf,"Adds resistance to %s.\n\r",
      imm_bit_name(paf->bitvector));
        break;
    case TO_VULN:
        sprintf(buf,"Adds vulnerability to %s.\n\r",
      imm_bit_name(paf->bitvector));
        break;
    default:
        sprintf(buf,"Unknown bit %d: %ld\n\r",
      paf->where,paf->bitvector);
        break;
      }
      send_to_char(buf,ch);
  }
    }

    if (!obj->enchanted)
    for ( paf = obj->pIndexData->affected; paf != NULL; paf = paf->next )
    {
  sprintf( buf, "Affects %s by %d, level %d.\n\r",
      affect_loc_name( paf->location ), paf->modifier,paf->level );
  send_to_char( buf, ch );
        if (paf->bitvector)
        {
            switch(paf->where)
            {
                case TO_AFFECTS:
                    sprintf(buf,"Adds %s affect.\n",
                        affect_bit_name(paf->bitvector));
                    break;
                case TO_OBJECT:
                    sprintf(buf,"Adds %s object flag.\n",
                        extra_bit_name(paf->bitvector));
                    break;
                case TO_IMMUNE:
                    sprintf(buf,"Adds immunity to %s.\n",
                        imm_bit_name(paf->bitvector));
                    break;
                case TO_RESIST:
                    sprintf(buf,"Adds resistance to %s.\n\r",
                        imm_bit_name(paf->bitvector));
                    break;
                case TO_VULN:
                    sprintf(buf,"Adds vulnerability to %s.\n\r",
                        imm_bit_name(paf->bitvector));
                    break;
                default:
                    sprintf(buf,"Unknown bit %d: %ld\n\r",
                        paf->where,paf->bitvector);
                    break;
            }
            send_to_char(buf,ch);
        }
    }

    if (obj->item_type == ITEM_FORGE && ch->level >= CREATOR)
	{
	RECIPE_DATA *recipe;
	int i,j;
	OBJ_INDEX_DATA *t_obj;
	char buf2[MAX_STRING_LENGTH];

	send_to_char("RECIPES:\n\r\n\r", ch);

	for ( i = 0 ; i <= 4 ; i++ )
	{
	  recipe = NULL;
	  if (obj->value[i] != 0 )
	  {
		recipe = get_recipe_data(obj->value[i]);
	  }

	  if ( recipe == NULL )
		continue;

	  sprintf(buf, "Recipe vnum %d: \n\rComplete Item: %d\n\r", recipe->recipe_num, recipe->vnum_complete);
	  send_to_char(buf, ch);
	  buf2[0] = '\0';
	  for( j = 0; j < MAX_IN_RECIPE; j++ )
	  {
		if ( recipe->vnum_parts[j] == 0 ) 
			break;

		t_obj = get_obj_index (recipe->vnum_parts[j]);
	  	if ( t_obj == NULL )
			bug("Null recipe item %d",recipe->vnum_parts[j] );
		else
	 	{
		    sprintf(buf, ", %s  ", t_obj->short_descr );
		    strcat(buf2, buf);
		}
	  }
	  send_to_char(buf2+1, ch); /* +1 to skip the first comma */
	  send_to_char("\n\r", ch);
	  }
	  send_to_char("\n\r", ch);
        }
    return;
}



void do_mstat( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char buf2[MAX_STRING_LENGTH];
    char strtime[25];
    char arg[MAX_INPUT_LENGTH];
    AFFECT_DATA *paf;
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Stat whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, argument ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    sprintf( buf, "Name: %s %s\n\r",
  victim->name, !IS_NPC(victim) ? victim->pcdata->surname : "(Mob)" );
    send_to_char( buf, ch );

    if ( !IS_NPC(victim) )
    {
    strcpy(strtime,ctime(&victim->pcdata->created_date));
    strtime[strlen(strtime)-1] = '\0';
    sprintf(buf,"Clan: %s  Rank: %d  Host: %s Created: %s\n\rStart Timer: %d \r\n",
	is_clan(victim) ? clan_table[victim->clan].name : "(none)",
	is_clan(victim) ? victim->pcdata->rank : 0,
	victim->pcdata->last_host,
	strtime,
        is_clan(victim) ? victim->pcdata->start_time : 0 ); 
    send_to_char(buf,ch);
    }

    sprintf( buf, 
  "Vnum: %d  Format: %s  Race: %s  Group: %d  Sex: %s  Room: %d\n\r",
  IS_NPC(victim) ? victim->pIndexData->vnum : 0,
  IS_NPC(victim) ? victim->pIndexData->new_format ? "new" : "old" : "pc",
  race_table[victim->race].name,
  IS_NPC(victim) ? victim->group : 0, sex_table[victim->sex].name,
  victim->in_room == NULL    ?        0 : victim->in_room->vnum
  );
    send_to_char( buf, ch );

    if (IS_NPC(victim))
    {
  sprintf(buf,"Count: %d  Killed: %d  -  Life Timer:  %d\n\r",
      victim->pIndexData->count,victim->pIndexData->killed,
      victim->life_timer);
  send_to_char(buf,ch);
    }

    sprintf( buf, 
    "Str: %d(%d)  Int: %d(%d)  Wis: %d(%d)  Dex: %d(%d)\n\rCon: %d(%d)  Agt: %d(%d)  End: %d(%d)  Soc: %d(%d)\n\r",
  victim->perm_stat[STAT_STR],
  get_curr_stat(victim,STAT_STR),
  victim->perm_stat[STAT_INT],
  get_curr_stat(victim,STAT_INT),
  victim->perm_stat[STAT_WIS],
  get_curr_stat(victim,STAT_WIS),
  victim->perm_stat[STAT_DEX],
  get_curr_stat(victim,STAT_DEX),
  victim->perm_stat[STAT_CON],
  get_curr_stat(victim,STAT_CON),
  victim->perm_stat[STAT_AGT],
  get_curr_stat(victim,STAT_AGT),
  victim->perm_stat[STAT_END],
  get_curr_stat(victim,STAT_END),
  victim->perm_stat[STAT_SOC],
  get_curr_stat(victim,STAT_SOC) );
    send_to_char( buf, ch );

    sprintf( buf, "Hp: %d/%d  Mana: %d/%d  Move: %d/%d  Prac: %d  Train: %d\n\r",
  victim->hit,         victim->max_hit,
  victim->mana,        victim->max_mana,
  victim->move,        victim->max_move,
  IS_NPC(victim) ? 0 : victim->practice,
  IS_NPC(victim) ? 0 : victim->train );
    send_to_char( buf, ch );
  
    sprintf( buf,
  "Lv: %d(%d)  Cls: %s %s  Align: %d  Go: %ld  Si: %ld  XP: %d\n\r",
  victim->level, 
  IS_NPC(victim) ? 0 : victim->pcdata->debit_level,       
  IS_NPC(victim) ? "" : class_table[victim->pcdata->old_class].name,
  IS_NPC(victim) ? "mobile" : class_table[victim->class].name,            
  victim->alignment,
  victim->gold, victim->silver, victim->exp );
    send_to_char( buf, ch );

    sprintf(buf,"Armor: pierce: %d  bash: %d  slash: %d  magic: %d\n\r",
      GET_AC(victim,AC_PIERCE), GET_AC(victim,AC_BASH),
      GET_AC(victim,AC_SLASH),  GET_AC(victim,AC_EXOTIC));
    send_to_char(buf,ch);

    if (!IS_NPC(victim))
    {
       sprintf( buf, 
  "Hit: %d/%d  Dam: %d/%d  Saves: %d  Size: %s  Position: %s  Wimpy: %d\n\r",
  GET_HITROLL(victim),GET_SECOND_HITROLL(victim),
  GET_DAMROLL(victim),GET_SECOND_DAMROLL(victim), victim->saving_throw,
  size_table[victim->size].name, position_table[victim->position].name,
  victim->wimpy );
    }
    else
    {
       sprintf( buf, 
  "Hit: %d  Dam: %d  Saves: %d  Size: %s  Position: %s  Wimpy: %d\n\r",
  GET_HITROLL(victim),GET_DAMROLL(victim),
  victim->saving_throw,
  size_table[victim->size].name, position_table[victim->position].name,
  victim->wimpy );
    }
    send_to_char( buf, ch );

     if(!IS_NPC(victim) && is_clan(victim))
        {
sprintf( buf, "Kills: Lw: %d Eq: %d Gr: %d Deaths: %d Stolen: (%ld/%ld) Slices: %ld\n\r",
       victim->pcdata->killer_data[PC_LOWER_KILLS],  
       victim->pcdata->killer_data[PC_EQUAL_KILLS],  
       victim->pcdata->killer_data[PC_GREATER_KILLS],  
       victim->pcdata->killer_data[PC_DEATHS], 
       victim->pcdata->steal_data[PC_STOLEN_ITEMS],
       victim->pcdata->steal_data[PC_STOLEN_GOLD], 
       victim->pcdata->steal_data[PC_SLICES]); 
        send_to_char(buf, ch);
	   sprintf( buf, "Outcast: %d  Ruffian: %d\n\r",victim->pcdata->outcT,
	   victim->pcdata->ruffT);
	   send_to_char(buf,ch);
        }

     if(!IS_NPC(victim) && IS_SET(victim->mhs,MHS_HIGHLANDER))
     {
	sprintf(buf,"Highlander kills: %d  Real Kills: %d\n\r",
	       victim->pcdata->highlander_data[ALL_KILLS],
	       victim->pcdata->highlander_data[REAL_KILLS]);
	send_to_char(buf,ch);
     }
     if(!IS_NPC(victim))
     {
	sprintf(buf,"Single Events: %d  Victories: %d  Kills: %d  Team Events: %d  Victories: %d  Kills: %d\n\r",
	       victim->pcdata->gladiator_data[GLADIATOR_PLAYS],
	       victim->pcdata->gladiator_data[GLADIATOR_VICTORIES],
	       victim->pcdata->gladiator_data[GLADIATOR_KILLS],
	       victim->pcdata->gladiator_data[GLADIATOR_TEAM_PLAYS],
	       victim->pcdata->gladiator_data[GLADIATOR_TEAM_VICTORIES], 
	       victim->pcdata->gladiator_data[GLADIATOR_TEAM_KILLS]);
	send_to_char(buf,ch);
     }

    if (IS_NPC(victim) && victim->pIndexData->new_format)
    {
  sprintf(buf, "Damage: %dd%d  Message:  %s\n\r",
      victim->damage[DICE_NUMBER],victim->damage[DICE_TYPE],
      attack_table[victim->dam_type].noun);
  send_to_char(buf,ch);
    }
    sprintf( buf, "Fighting: %s  Riding: %s  Passenger: %s\n\r",
  victim->fighting ? victim->fighting->name : "(none)",
  victim->riding ? victim->riding->name : "(none)",
  victim->passenger ? victim->passenger->name : "(none)");
   if(!IS_NPC(victim))
   {
    sprintf( buf2, "Remort: %s  Deity: %s (%d / %d)  Skill Points: (%d / %d / %d)\n\r",
        IS_SET(victim->act,PLR_WERE) ? "garou" :
        IS_SET(victim->act,PLR_MUMMY) ? "mummy" :
	    IS_SET(victim->act,PLR_VAMP) ? "nosferatu" : "(none)",
	deity_table[victim->pcdata->deity].pname,
	victim->pcdata->sac,
	(int) (((victim->played + (int) (current_time - victim->logon)) 
		- victim->pcdata->switched)/3600),
	victim->skill_points,
	victim->pcdata->skill_point_tracker,
	victim->pcdata->skill_point_timer);
    strcat( buf,buf2);
   }
   else
   {
    strcat( buf, "\n\r");
   }
    send_to_char( buf, ch );

    if ( !IS_NPC(victim) )
    {
  sprintf( buf,
      "Thirst: %d  Hunger: %d  Full: %d  Drunk: %d   Casting Level: %d\n\r",
      victim->pcdata->condition[COND_THIRST],
      victim->pcdata->condition[COND_HUNGER],
      victim->pcdata->condition[COND_FULL],
      victim->pcdata->condition[COND_DRUNK],
      compute_casting_level(victim, 0 ) );
  send_to_char( buf, ch );
//       if (victim->pcdata->logout_tracker > 0)
//       {
  sprintf( buf,
      "PFresh Logouts Remaining: %d\n\r",
      victim->pcdata->logout_tracker );
//  send_to_char( buf, ch );
//       }
    }

    sprintf( buf, "Carry number: %d  Carry weight: %ld   Kit: %s\n\r",
  victim->carry_number, get_carry_weight(victim) / 10,
  victim->kit ? kit_table[victim->kit].name : "none");
    send_to_char( buf, ch );

/*
      (int) (victim->played + victim->redid + current_time - victim->logon) / 3600, 
*/
    if (!IS_NPC(victim))
    {
      sprintf( buf, 
      "Age: %d  Played: %d  Last Level: %d  Timer: %d  Barb: %d  Mutate: %d\n\r",
      get_age(victim), 
      (int) (victim->played + current_time - victim->logon) / 3600, 
      victim->pcdata->last_level, 
      victim->timer,
      victim->pcdata->barbarian,
      victim->pcdata->mutant_timer);
      send_to_char( buf, ch );
    }

    sprintf(buf, "MHS: %s\n\r",mhs_bit_name(victim->mhs));
    send_to_char(buf,ch);

    if( !IS_NPC(victim) && is_clan(victim) )
    {
    sprintf(buf, "Clan Flags: %s\n\r", clan_bit_name(victim->pcdata->clan_flags));
    send_to_char(buf, ch);
    }

    if( !IS_NPC(victim) )
      {
      sprintf(buf, " Matook: %d\n\r",(int) (victim->pcdata->matookT));
      send_to_char(buf,ch);
      }

    sprintf(buf, "Act: %s\n\r",act_bit_name(victim->act));
    send_to_char(buf,ch);
    
    if (victim->comm)
    {
      sprintf(buf,"Comm: %s\n\r",comm_bit_name(victim->comm));
      send_to_char(buf,ch);
    }

    if (IS_NPC(victim) && victim->off_flags)
    {
      sprintf(buf, "Offense: %s\n\r",off_bit_name(victim->off_flags));
  send_to_char(buf,ch);
    }

    if (victim->imm_flags)
    {
  sprintf(buf, "Immune: %s\n\r",imm_bit_name(victim->imm_flags));
  send_to_char(buf,ch);
    }
 
    if (victim->res_flags)
    {
  sprintf(buf, "Resist: %s\n\r", imm_bit_name(victim->res_flags));
  send_to_char(buf,ch);
    }

    if (victim->vuln_flags)
    {
  sprintf(buf, "Vulnerable: %s\n\r", imm_bit_name(victim->vuln_flags));
  send_to_char(buf,ch);
    }

    sprintf(buf, "Form: %s\n\rParts: %s\n\r", 
  form_bit_name(victim->form), part_bit_name(victim->parts));
    send_to_char(buf,ch);

    if (victim->affected_by)
    {
  sprintf(buf, "Affected by %s\n\r", 
      affect_bit_name(victim->affected_by));
  send_to_char(buf,ch);
    }

    sprintf( buf, "Master: %s  Leader: %s  Pet: %s MOB-lAb: %s\n\r",
  victim->master      ? victim->master->name   : "(none)",
  victim->leader      ? victim->leader->name   : "(none)",
  victim->pet       ? victim->pet->name      : "(none)",
  victim->lAb       ? victim->lAb->name	: "(none)");
    send_to_char( buf, ch );

   sprintf( buf, "People: %s  Next In Room: %s\n\r",
      victim->in_room->people ? victim->in_room->people->name : "(none)",
      victim->next_in_room ? victim->next_in_room->name : "(none)");
   send_to_char( buf, ch );

   if (!IS_NPC(victim))
   {
      sprintf( buf, "Fighting: %s  Last Attacked By: %s  LAB Timer: %d Last Death Timer: %d  Trumps: %d\n\r",
	 victim->fighting ? victim->fighting->name : "(none)",
         victim->pcdata->last_attacked_by,   
	 victim->pcdata->last_attacked_by_timer,
	 victim->pcdata->last_death_timer,
	 victim->trumps) ; 
      send_to_char( buf, ch );
    strcpy(strtime,ctime(&victim->pcdata->last_combat_date));
    strtime[strlen(strtime)-1] = '\0';
      sprintf( buf,"Login Information:\n\r"
                    "Combats Since: %d Without Combats: %d Without Kill: %d Without Death: %d\n\r" 
                    "Last Combat Date: %s\n\r",
         victim->pcdata->combats_since_last_login,
         victim->pcdata->logins_without_combat,
         victim->pcdata->logins_without_kill,
         victim->pcdata->logins_without_death,
         strtime );
      send_to_char( buf, ch );
    strcpy(strtime,ctime(&victim->pcdata->last_kill_date));
    strtime[strlen(strtime)-1] = '\0';
      sprintf( buf, "Last Kill Date: %s\n\r", strtime); 
      send_to_char( buf, ch );
    strcpy(strtime,ctime(&victim->pcdata->last_death_date));
    strtime[strlen(strtime)-1] = '\0';
      sprintf( buf, "Last Death Date: %s\n\r", strtime); 
      send_to_char( buf, ch );
   }

    sprintf( buf, "Short description: %s\n\rLong  description: %s\n\r",
  victim->short_descr,
  victim->long_descr[0] != '\0' ? victim->long_descr : "(none)" );
    send_to_char( buf, ch );

    if ( IS_NPC(victim) && victim->spec_fun != 0 )
    {
  sprintf(buf,"Mobile has special procedure %s.\n\rWords[0]: %s\n\rWords[1]: %s\n\rWords[2]: %s\n\r",
    spec_name(victim->spec_fun),victim->pIndexData->spec_words[0],
    victim->pIndexData->spec_words[1],victim->pIndexData->spec_words[2]);
  send_to_char(buf,ch);
    }

    for ( paf = victim->affected; paf != NULL; paf = paf->next )
    {
  sprintf( buf,
      "Spell: '%s' modifies %s by %d for %d hours with bits %s, level %d.\n\r",
      skill_table[(int) paf->type].name,
      affect_loc_name( paf->location ),
      paf->modifier,
      paf->duration,
      affect_bit_name( paf->bitvector ),
      paf->level
      );
  send_to_char( buf, ch );
    }
  if (IS_SET(victim->act,PLR_FREEZE)) send_to_char("{RPlayer has been frozen{x.\n\r",ch);
  if (IS_SET(victim->act,PLR_DENY)) send_to_char("{RPlayer has been denied{x.\n\r",ch);
   return;
}

/* ofind and mfind replaced with vnum, vnum skill also added */

void do_vnum(CHAR_DATA *ch, char *argument)
{
    char arg[MAX_INPUT_LENGTH];
    char *string;
    int vnum;

    string = one_argument(argument,arg);
 
    if (arg[0] == '\0')
    {
  send_to_char("Syntax:\n\r",ch);
  send_to_char("  vnum obj <name>\n\r",ch);
  send_to_char("  vnum mob <name>\n\r",ch);
  send_to_char("  vnum skill <skill or spell>\n\r",ch);
  send_to_char("  vnum #\n\r",ch);
  return;
    }
    
    if (is_number(arg)) {      
      MOB_INDEX_DATA *pMobIndex;
      OBJ_INDEX_DATA *pObjIndex;
      char buf[MAX_STRING_LENGTH];
      
      vnum = atoi (arg);      
      
      if ((pMobIndex = get_mob_index (vnum)) != NULL) {
        sprintf( buf, "[%5d] %s\n\r",pMobIndex->vnum, 
                 pMobIndex->short_descr );
        send_to_char( buf, ch );      
      } else {
        send_to_char ("No mobs with that vnum.\n\r",ch);
      }
      
      if ((pObjIndex = get_obj_index (vnum)) != NULL) {
        sprintf( buf, "[%5d] %s\n\r",pObjIndex->vnum, 
                 pObjIndex->short_descr );
        send_to_char( buf, ch );      
      } else {
        send_to_char ("No objects with that vnum.\n\r",ch);
      }
      
      return;      
    }

    if (!str_cmp(arg,"obj"))
    {
  do_ofind(ch,string);
  return;
    }

    if (!str_cmp(arg,"mob") || !str_cmp(arg,"char"))
    { 
  do_mfind(ch,string);
  return;
    }

    if (!str_cmp(arg,"skill") || !str_cmp(arg,"spell"))
    {
  do_slookup(ch,string);
  return;
    }
    /* do both */
    do_mfind(ch,argument);
    do_ofind(ch,argument);
}


void do_mfind( CHAR_DATA *ch, char *argument )
{
    extern int top_mob_index;
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    MOB_INDEX_DATA *pMobIndex;
    int vnum;
    int nMatch;
    bool fAll;
    bool found;

    one_argument( argument, arg );
    if ( arg[0] == '\0' )
    {
  send_to_char( "Find whom?\n\r", ch );
  return;
    }

    fAll  = FALSE; /* !str_cmp( arg, "all" ); */
    found = FALSE;
    nMatch  = 0;

    /*
     * Yeah, so iterating over all vnum's takes 10,000 loops.
     * Get_mob_index is fast, and I don't feel like threading another link.
     * Do you?
     * -- Furey
     */
    for ( vnum = 0; nMatch < top_mob_index; vnum++ )
    {
  if ( ( pMobIndex = get_mob_index( vnum ) ) != NULL )
  {
      nMatch++;
      if ( fAll || is_name( argument, pMobIndex->player_name ) )
      {
    found = TRUE;
    sprintf( buf, "[%5d] %s\n\r",
        pMobIndex->vnum, pMobIndex->short_descr );
    send_to_char( buf, ch );
      }
  }
    }

    if ( !found )
  send_to_char( "No mobiles by that name.\n\r", ch );

    return;
}



void do_ofind( CHAR_DATA *ch, char *argument )
{
    extern int top_obj_index;
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    OBJ_INDEX_DATA *pObjIndex;
    int vnum;
    int nMatch;
    bool fAll;
    bool found;

    one_argument( argument, arg );
    if ( arg[0] == '\0' )
    {
  send_to_char( "Find what?\n\r", ch );
  return;
    }

    fAll  = FALSE; /* !str_cmp( arg, "all" ); */
    found = FALSE;
    nMatch  = 0;

    /*
     * Yeah, so iterating over all vnum's takes 10,000 loops.
     * Get_obj_index is fast, and I don't feel like threading another link.
     * Do you?
     * -- Furey
     */
    for ( vnum = 0; nMatch < top_obj_index; vnum++ )
    {
  if ( ( pObjIndex = get_obj_index( vnum ) ) != NULL )
  {
      nMatch++;
      if ( fAll || is_name( argument, pObjIndex->name ) )
      {
    found = TRUE;
    sprintf( buf, "[%5d] %s\n\r",
        pObjIndex->vnum, pObjIndex->short_descr );
    send_to_char( buf, ch );
      }
  }
    }

    if ( !found )
  send_to_char( "No objects by that name.\n\r", ch );

    return;
}


void do_owhere(CHAR_DATA *ch, char *argument )
{
    char buf[MAX_INPUT_LENGTH];
    BUFFER *buffer;
    OBJ_DATA *obj;
    OBJ_DATA *in_obj;
    bool found;
    int number = 0, max_found;

    found = FALSE;
    number = 0;
    max_found = 200;

    buffer = new_buf();

    if (argument[0] == '\0')
    {
  send_to_char("Find what?\n\r",ch);
  return;
    }
 
    for ( obj = object_list; obj != NULL; obj = obj->next )
    {
        if ( !can_see_obj( ch, obj ) || !is_name( argument, obj->name )
        ||   ch->level < obj->level)
            continue;
 
        found = TRUE;
        number++;
 
        for ( in_obj = obj; in_obj->in_obj != NULL; in_obj = in_obj->in_obj )
            ;
 
        if ( in_obj->carried_by != NULL && can_see(ch,in_obj->carried_by,TRUE)
  &&   in_obj->carried_by->in_room != NULL)
            sprintf( buf, "%3d) %s is carried by %s [Room %d]\n\r",
                number, obj->short_descr,PERS(in_obj->carried_by, ch, TRUE),
    in_obj->carried_by->in_room->vnum );
        else if (in_obj->in_room != NULL && can_see_room(ch,in_obj->in_room))
            sprintf( buf, "%3d) %s is in %s [Room %d]\n\r",
                number, obj->short_descr,in_obj->in_room->name, 
      in_obj->in_room->vnum);
  else
            sprintf( buf, "%3d) %s is somewhere\n\r",number, obj->short_descr);
 
        buf[0] = UPPER(buf[0]);
        add_buf(buffer,buf);
 
        if (number >= max_found)
            break;
    }
 
    if ( !found )
        send_to_char( "Nothing like that in heaven or earth.\n\r", ch );
    else
        page_to_char(buf_string(buffer),ch);

    free_buf(buffer);
}


void do_mwhere( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    BUFFER *buffer;
    CHAR_DATA *victim;
    bool found;
    int count = 0;

    if ( argument[0] == '\0' )
    {
  DESCRIPTOR_DATA *d;

  /* show characters logged */

  buffer = new_buf();
  for (d = descriptor_list; d != NULL; d = d->next)
  {
      if (d->character != NULL && d->connected == CON_PLAYING
      &&  d->character->in_room != NULL && can_see(ch,d->character,TRUE)
      &&  can_see_room(ch,d->character->in_room))
      {
    victim = d->character;
    count++;
    if (d->original != NULL)
        sprintf(buf,"%3d) %s (in the body of %s) is in %s [%d]\n\r",
      count, d->original->name,victim->short_descr,
      victim->in_room->name,victim->in_room->vnum);
    else
        sprintf(buf,"%3d) %s is in %s [%d]\n\r",
      count, victim->name,victim->in_room->name,
      victim->in_room->vnum);
    add_buf(buffer,buf);
      }
  }

        page_to_char(buf_string(buffer),ch);
  free_buf(buffer);
  return;
    }

    found = FALSE;
    buffer = new_buf();
    for ( victim = char_list; victim != NULL; victim = victim->next )
    {
  if ( victim->in_room != NULL
  &&   is_name( argument, victim->name ) && can_see (ch,victim,TRUE) )
  {
      found = TRUE;
      count++;
      sprintf( buf, "%3d) [%5d] %-28s [%5d] %s\n\r", count,
    IS_NPC(victim) ? victim->pIndexData->vnum : 0,
    IS_NPC(victim) ? victim->short_descr : victim->name,
    victim->in_room->vnum,
    victim->in_room->name );
      add_buf(buffer,buf);
  }
    }

    if ( !found )
  act( "You didn't find any $T.", ch, NULL, argument, TO_CHAR ,FALSE);
    else
      page_to_char(buf_string(buffer),ch);

    free_buf(buffer);

    return;
}



void do_reboo( CHAR_DATA *ch, char *argument )
{
    send_to_char( "If you want to REBOOT, spell it out.\n\r", ch );
    return;
}



void do_reboot( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH]; /* Poquah - For Note Check */
    extern bool merc_down;
    DESCRIPTOR_DATA *d,*d_next;

/* Poquah Down - Check for Players writing notes */
    one_argument ( argument, arg);

    if ( str_cmp(arg,"force"))
    {
       bool fAny = FALSE;
       for (d = descriptor_list ; d != NULL ; d = d->next )
	  if ( d->connected == CON_PLAYING &&
	       d->character->pnote != NULL )
          {
	     fAny = TRUE;
             sprintf(buf,"%s is currently working on a note.\n\r",
		   d->character->name);
             send_to_char(buf,ch);
          }
	  if (fAny)
	  {
	     send_to_char("Use 'reboot force' to reboot anyway.\n\r",ch);
	     return;
          }
    }
/* Poquah Up */
#ifdef OLC_VERSION
  if(ch->icg == ICG_BUILD)
	return;
#endif
    if (ch->invis_level < LEVEL_HERO)
    {
      sprintf( buf, "Reboot by %s.", ch->name );
      do_echo( ch, buf );
    }
    do_force ( ch, "all save");
    do_save (ch, "");
    merc_down = TRUE;
    for ( d = descriptor_list; d != NULL; d = d_next )
    {
  d_next = d->next;
      close_socket(d);
    }
    
    return;
}



void do_shutdow( CHAR_DATA *ch, char *argument )
{
    send_to_char( "If you want to SHUTDOWN, spell it out.\n\r", ch );
    return;
}



void do_shutdown( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    extern bool merc_down;
    DESCRIPTOR_DATA *d,*d_next;

#ifdef OLC_VERSION
  if(ch->icg == ICG_BUILD)
	return;
#endif

    if (ch->invis_level < LEVEL_HERO)
    sprintf( buf, "Shutdown by %s.", ch->name );
    append_file( ch, SHUTDOWN_FILE, buf );
    strcat( buf, "\n\r" );
    if (ch->invis_level < LEVEL_HERO)
      do_echo( ch, buf );
    do_force ( ch, "all save");
    do_save (ch, "");
    merc_down = TRUE;
    for ( d = descriptor_list; d != NULL; d = d_next)
    {
  d_next = d->next;
  close_socket(d);
    }
    return;
}

void do_protect( CHAR_DATA *ch, char *argument)
{
    CHAR_DATA *victim;

    if (argument[0] == '\0')
    {
  send_to_char("Protect whom from snooping?\n\r",ch);
  return;
    }

    if ((victim = get_char_world(ch,argument)) == NULL)
    {
  send_to_char("You can't find them.\n\r",ch);
  return;
    }

    if (IS_SET(victim->comm,COMM_SNOOP_PROOF))
    {
  act_new("$N is no longer snoop-proof.",ch,NULL,victim,TO_CHAR,POS_DEAD,TRUE);
  send_to_char("Your snoop-proofing was just removed.\n\r",victim);
  REMOVE_BIT(victim->comm,COMM_SNOOP_PROOF);
    }
    else
    {
  act_new("$N is now snoop-proof.",ch,NULL,victim,TO_CHAR,POS_DEAD,TRUE);
  send_to_char("You are now immune to snooping.\n\r",victim);
  SET_BIT(victim->comm,COMM_SNOOP_PROOF);
    }
}
  


void do_snoop( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    DESCRIPTOR_DATA *d;
    CHAR_DATA *victim;
    char buf[MAX_STRING_LENGTH];

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Snoop whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( victim->desc == NULL )
    {
  send_to_char( "No descriptor to snoop.\n\r", ch );
  return;
    }

    if ( victim == ch )
    {
  send_to_char( "Cancelling all snoops.\n\r", ch );
  wiznet("$N stops being such a snoop.",
    ch,NULL,WIZ_SNOOPS,WIZ_SECURE,get_trust(ch));
  for ( d = descriptor_list; d != NULL; d = d->next )
  {
      if ( d->snoop_by == ch->desc )
    d->snoop_by = NULL;
  }
  return;
    }

    if ( victim->desc->snoop_by != NULL )
    {
  send_to_char( "Busy already.\n\r", ch );
  return;
    }
/*
    if (!is_room_owner(ch,victim->in_room) &&  !IS_TRUSTED(ch,IMPLEMENTOR))
    {
        send_to_char("That character is in a private room.\n\r",ch);
        return;
    }
*/
    if ( get_trust( victim ) >= get_trust( ch ) 
    ||   (IS_SET(victim->comm,COMM_SNOOP_PROOF) && !IS_TRUSTED(ch,IMPLEMENTOR)))
    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    if ( ch->desc != NULL )
    {
  for ( d = ch->desc->snoop_by; d != NULL; d = d->snoop_by )
  {
      if ( d->character == victim || d->original == victim )
      {
    send_to_char( "No snoop loops.\n\r", ch );
    return;
      }
  }
    }

    victim->desc->snoop_by = ch->desc;
    sprintf(buf,"$N starts snooping on %s",
  (IS_NPC(ch) ? victim->short_descr : victim->name));
    wiznet(buf,ch,NULL,WIZ_SNOOPS,WIZ_SECURE,get_trust(ch));
    send_to_char( "Ok.\n\r", ch );
    return;
}



void do_switch( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );
    
    if ( arg[0] == '\0' )
    {
  send_to_char( "Switch into whom?\n\r", ch );
  return;
    }

    if ( ch->desc == NULL )
  return;
    
    if ( ch->desc->original != NULL )
    {
  send_to_char( "You are already switched.\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( victim == ch )
    {
  send_to_char( "Ok.\n\r", ch );
  return;
    }

    if (!IS_NPC(victim))
    {
  send_to_char("You can only switch into mobiles.\n\r",ch);
  return;
    }

    if (!is_room_owner(ch,victim->in_room) && ch->in_room != victim->in_room 
    &&  room_is_private(ch,victim->in_room) && !IS_TRUSTED(ch,IMPLEMENTOR))
    {
  send_to_char("That character is in a private room.\n\r",ch);
  return;
    }

    if ( victim->desc != NULL )
    {
  send_to_char( "Character in use.\n\r", ch );
  return;
    }

    sprintf(buf,"$N switches into %s",victim->short_descr);
    wiznet(buf,ch,NULL,WIZ_SWITCHES,WIZ_SECURE,get_trust(ch));

    ch->desc->character = victim;
    ch->desc->original  = ch;
    victim->desc        = ch->desc;
    ch->desc            = NULL;
    /* change communications to match */
    if (ch->prompt != NULL)
    {
      free_string(victim->prompt);
      victim->prompt = str_dup(ch->prompt);
    }
    victim->comm = ch->comm;
    victim->lines = ch->lines;
    send_to_char( "Ok.\n\r", victim );
    return;
}



void do_return( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];

    if ( ch->desc == NULL )
  return;

    if ( ch->desc->original == NULL )
    {
  send_to_char( "You aren't switched.\n\r", ch );
  return;
    }

    send_to_char( 
"You return to your original body. Type replay to see any missed tells.\n\r", 
  ch );
    if (ch->prompt != NULL)
    {
  free_string(ch->prompt);
  ch->prompt = NULL;
    }

    sprintf(buf,"$N returns from %s.",ch->short_descr);
    wiznet(buf,ch->desc->original,0,WIZ_SWITCHES,WIZ_SECURE,get_trust(ch));
    ch->desc->character       = ch->desc->original;
    ch->desc->original        = NULL;
    ch->desc->character->desc = ch->desc; 
    ch->desc                  = NULL;
    return;
}

/* trust levels for load and clone */
bool obj_check (CHAR_DATA *ch, OBJ_DATA *obj)
{
    if (IS_TRUSTED(ch,GOD)
  || (IS_TRUSTED(ch,IMMORTAL) && obj->level <= 20 && obj->cost <= 1000)
  || (IS_TRUSTED(ch,DEMI)     && obj->level <= 10 && obj->cost <= 500)
  || (IS_TRUSTED(ch,ANGEL)    && obj->level <=  5 && obj->cost <= 250)
  || (IS_TRUSTED(ch,AVATAR)   && obj->level ==  0 && obj->cost <= 100))
  return TRUE;
    else
  return FALSE;
}

/* for clone, to insure that cloning goes many levels deep */
void recursive_clone(CHAR_DATA *ch, OBJ_DATA *obj, OBJ_DATA *clone)
{
    OBJ_DATA *c_obj, *t_obj;


    for (c_obj = obj->contains; c_obj != NULL; c_obj = c_obj->next_content)
    {
  if (obj_check(ch,c_obj))
  {
      t_obj = create_object(c_obj->pIndexData,0,FALSE);
      clone_object(c_obj,t_obj);
      obj_to_obj(t_obj,clone);
      recursive_clone(ch,c_obj,t_obj);
  }
    }
}

/* command that is similar to load */
void do_clone(CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH],
         buf[MAX_STRING_LENGTH];
    char *rest;
    CHAR_DATA *mob;
    OBJ_DATA  *obj;
    int count,number;

    rest = one_argument(argument,arg);    
     
    if (arg[0] == '\0')
    {
  send_to_char("Clone what?\n\r",ch);
  return;
    }

    if (!str_prefix(arg,"object"))
    {
  mob = NULL;
  number = mult_argument(rest,arg);
  obj = get_obj_here(ch,arg);
  if (obj == NULL)
  {
      send_to_char("You don't see that here.\n\r",ch);
      return;
  }
    }
    else if (!str_prefix(arg,"mobile") || !str_prefix(arg,"character"))
    {
  obj = NULL;
  number = mult_argument(rest,arg);
  mob = get_char_room(ch,arg);
  if (mob == NULL)
  {
      send_to_char("You don't see that here.\n\r",ch);
      return;
  }
    }
    else /* find both */
    {
  number = mult_argument(argument,arg);  
  mob = get_char_room(ch,arg);
  obj = get_obj_here(ch,arg);
  if (mob == NULL && obj == NULL)
  {
      send_to_char("You don't see that here.\n\r",ch);
      return;
  }
    }

    /* clone an object */
    if (obj != NULL)
    {
  OBJ_DATA *clone;
  
  clone = NULL;
  if (!obj_check(ch,obj))
  {
      send_to_char(
    "Your powers are not great enough for such a task.\n\r",ch);
      return;
  }
  
  if (number > 50) {
    send_to_char ("Whoa.. not more than 50.\n\r",ch);
    return;
  }

  if (number <= 0)
  {
    send_to_char("Did you mistype that number before the '*'?\n\r",ch);
    return;
  }
  
  for ( count = 0; count < number; count++ ) {
    clone = create_object(obj->pIndexData,0,FALSE); 
    clone_object(obj,clone);
    if (obj->carried_by != NULL)
        obj_to_char(clone,ch);
    else
        obj_to_room(clone,ch->in_room);
    recursive_clone(ch,obj,clone);
  }
  
  sprintf (buf,"$n has created [%d]$p.",number);
  act(buf,ch,clone,NULL,TO_ROOM,FALSE);
  sprintf (buf,"You clone [%d]$p.",number);
  act(buf,ch,clone,NULL,TO_CHAR,FALSE);
  sprintf (buf,"$N clones [%d]$p.",number);
  wiznet(buf,ch,clone,WIZ_LOAD,WIZ_SECURE,get_trust(ch));
  return;
    }
    else if (mob != NULL)
    {
  CHAR_DATA *clone;
  OBJ_DATA *new_obj;  
  
  clone = NULL;
  if (!IS_NPC(mob))
  {
      send_to_char("You can only clone mobiles.\n\r",ch);
      return;
  }

  if ((mob->level > 20 && !IS_TRUSTED(ch,GOD))
  ||  (mob->level > 10 && !IS_TRUSTED(ch,IMMORTAL))
  ||  (mob->level >  5 && !IS_TRUSTED(ch,DEMI))
  ||  (mob->level >  0 && !IS_TRUSTED(ch,ANGEL))
  ||  !IS_TRUSTED(ch,AVATAR))
  {
      send_to_char(
    "Your powers are not great enough for such a task.\n\r",ch);
      return;
  }
  
  if (number > 50) {
    send_to_char ("Whoa.. not more than 50.\n\r",ch);
    return;
  }  

  for ( count = 0; count < number; count++ ) {
    clone = create_mobile(mob->pIndexData);
    clone_mobile(mob,clone); 
    
    for (obj = mob->carrying; obj != NULL; obj = obj->next_content)
    {
        if (obj_check(ch,obj))
        {
      new_obj = create_object(obj->pIndexData,0,FALSE);
      clone_object(obj,new_obj);
      recursive_clone(ch,obj,new_obj);
      obj_to_char(new_obj,clone);
      new_obj->wear_loc = obj->wear_loc;
        }
    }
    char_to_room(clone,ch->in_room);
  }
  

  sprintf (buf,"$n has created [%d]$N.",number);
  act(buf,ch,NULL,clone,TO_ROOM,FALSE);
  sprintf (buf,"You clone [%d]$N.",number);
  act(buf,ch,NULL,clone,TO_CHAR,FALSE);
  sprintf (buf,"$N clones [%d]%s.",number,clone->short_descr);
  wiznet(buf,ch,NULL,WIZ_LOAD,WIZ_SECURE,get_trust(ch));
  return;
    }
}

/* RT to replace the two load commands */

void do_load(CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];

    argument = one_argument(argument,arg);

    if (arg[0] == '\0')
    {
  send_to_char("Syntax:\n\r",ch);
  send_to_char("  load mob <vnum>\n\r",ch);
  send_to_char("  load obj <vnum> <level>\n\r",ch);
  return;
    }

    if (!str_cmp(arg,"mob") || !str_cmp(arg,"char"))
    {
  do_mload(ch,argument);
  return;
    }

    if (!str_cmp(arg,"obj"))
    {
  do_oload(ch,argument);
  return;
    }
    /* echo syntax */
    do_load(ch,"");
}


void do_mload( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    MOB_INDEX_DATA *pMobIndex;
    CHAR_DATA *victim;
    char buf[MAX_STRING_LENGTH];
    
    one_argument( argument, arg );

    if ( arg[0] == '\0' || !is_number(arg) )
    {
  send_to_char( "Syntax: load mob <vnum>.\n\r", ch );
  return;
    }

    if ( ( pMobIndex = get_mob_index( atoi( arg ) ) ) == NULL )
    {
  send_to_char( "No mob has that vnum.\n\r", ch );
  return;
    }

    victim = create_mobile( pMobIndex );
    char_to_room( victim, ch->in_room );
    act( "$n has created $N!", ch, NULL, victim, TO_ROOM ,FALSE);
    sprintf(buf,"$N loads %s.",victim->short_descr);
    wiznet(buf,ch,NULL,WIZ_LOAD,WIZ_SECURE,get_trust(ch));
    send_to_char( "Ok.\n\r", ch );
    return;
}



void do_oload( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH] ,arg2[MAX_INPUT_LENGTH];
    OBJ_INDEX_DATA *pObjIndex;
    OBJ_DATA *obj;
    int level;
    
    argument = one_argument( argument, arg1 );
    one_argument( argument, arg2 );

    if ( arg1[0] == '\0' || !is_number(arg1))
    {
  send_to_char( "Syntax: load obj <vnum> <level>.\n\r", ch );
  return;
    }
    
    level = get_trust(ch); /* default */
  
    if ( arg2[0] != '\0')  /* load with a level */
    {
  if (!is_number(arg2))
        {
    send_to_char( "Syntax: oload <vnum> <level>.\n\r", ch );
    return;
  }
        level = atoi(arg2);
        if (level < 0 || level > get_trust(ch))
  {
    send_to_char( "Level must be be between 0 and your level.\n\r",ch);
      return;
  }
    }

    if ( ( pObjIndex = get_obj_index( atoi( arg1 ) ) ) == NULL )
    {
  send_to_char( "No object has that vnum.\n\r", ch );
  return;
    }

    obj = create_object( pObjIndex, level, FALSE );
    if ( CAN_WEAR(obj, ITEM_TAKE) )
  obj_to_char( obj, ch );
    else
  obj_to_room( obj, ch->in_room );
    act( "$n has created $p!", ch, obj, NULL, TO_ROOM ,FALSE);
    wiznet("$N loads $p.",ch,obj,WIZ_LOAD,WIZ_SECURE,get_trust(ch));
    send_to_char( "Ok.\n\r", ch );
    return;
}


void do_pur( CHAR_DATA *ch, char *argument)
{
    if (ch->level >= AVATAR) 
       send_to_char("Was that 'purr' or 'purge'? Spell it out.\n\r",ch);
    return;
}

void do_purge( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    char buf[100];
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    DESCRIPTOR_DATA *d;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  /* 'purge' */
  CHAR_DATA *vnext;
  OBJ_DATA  *obj_next;

  for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
  {
      vnext = victim->next_in_room;
      if ( IS_NPC(victim) && !IS_SET(victim->act,ACT_NOPURGE) 
      &&   victim != ch /* safety precaution */ )
    extract_char( victim, TRUE );
  }

  for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
  {
      obj_next = obj->next_content;
      if (!IS_OBJ_STAT(obj,ITEM_NOPURGE))
        extract_obj( obj );
  }

  act( "$n purges the room!", ch, NULL, NULL, TO_ROOM,FALSE);
  send_to_char( "Ok.\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( !IS_NPC(victim) )
    {

  if (ch == victim)
  {
    send_to_char("Ho ho ho.\n\r",ch);
    return;
  }

  if (get_trust(ch) <= get_trust(victim))
  {
    send_to_char("Maybe that wasn't a good idea...\n\r",ch);
    sprintf(buf,"%s tried to purge you!\n\r",ch->name);
    send_to_char(buf,victim);
    return;
  }

  act("$n disintegrates $N.",ch,0,victim,TO_NOTVICT,FALSE);

      if (victim->level > 1)
      save_char_obj( victim );
      d = victim->desc;
      extract_char( victim, TRUE );
      if ( d != NULL )
          close_socket( d );

  return;
    }

    act( "$n purges $N.", ch, NULL, victim, TO_NOTVICT ,FALSE);
    extract_char( victim, TRUE );
    return;
}



void do_advance( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    int level;
    int iLevel;

#ifdef OLC_VERSION
  if(ch->icg == ICG_BUILD)
  {
	send_to_char("Very funny buttmunch.\n\r",ch);
	return;
  }
#endif

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if ( arg1[0] == '\0' || arg2[0] == '\0' || !is_number( arg2 ) )
    {
  send_to_char( "Syntax: advance <char> <level>.\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
  send_to_char( "That player is not here.\n\r", ch);
  return;
    }

    if ( IS_NPC(victim) )
    {
  send_to_char( "Not on NPC's.\n\r", ch );
  return;
    }

    if ( ( level = atoi( arg2 ) ) < 1 || level > MAX_LEVEL )
    {
      sprintf(buf,"Level must be 1 to %d.\n\r", MAX_LEVEL);
      send_to_char(buf, ch);
      return;
    }

    if ( level > get_trust( ch ) )
    {
  send_to_char( "Limited to your trust level.\n\r", ch );
  return;
    }

    if (ch->level == victim->level)
    {
  send_to_char("Now now, play nicely.\n\r",ch);
  return;
    }

    /*
     * Lower level:
     *   Reset to level 1.
     *   Then raise again.
     *   Currently, an imp can lower another imp.
     *   -- Swiftest
     */
    if ( level <= victim->level )
    {
        int temp_prac;

  send_to_char( "Lowering a player's level!\n\r", ch );
  send_to_char( "**** OOOOHHHHHHHHHH  NNNNOOOO ****\n\r", victim );
  temp_prac = victim->practice;
  victim->level    = 1;
  victim->exp      = exp_per_level(victim,victim->pcdata->points);
  victim->max_hit  = 10;
  victim->max_mana = 100;
  victim->max_move = 100;
  victim->practice = 0;
  victim->pcdata->perm_hit  = victim->hit      = victim->max_hit;
  victim->pcdata->perm_mana = victim->mana     = victim->max_mana;
  victim->pcdata->perm_move = victim->move     = victim->max_move;
  victim->icg = ICG_NONE;
  victim->icg_bits = 0;
  victim->wiznet = 0;
  victim->incog_level = 0;
  victim->invis_level = 0;
   if ( IS_SET(victim->act, PLR_HOLYLIGHT) )
      REMOVE_BIT(victim->act, PLR_HOLYLIGHT);
  advance_level( victim );
  victim->practice = temp_prac;
    }
    else
    {
  send_to_char( "Raising a player's level!\n\r", ch );
  send_to_char( "**** OOOOHHHHHHHHHH  YYYYEEEESSS ****\n\r", victim );
    }

    for ( iLevel = victim->level ; iLevel < level; iLevel++ )
    {
  send_to_char( "You raise a level!!  ", victim );
  victim->level += 1;
  advance_level( victim );
    }
    victim->exp   = exp_per_level(victim,victim->pcdata->points) 
      * UMAX( 1, victim->level );
    victim->trust = 0;
    save_char_obj(victim);
    return;
}



void do_trust( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    int level;

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );

    if ( arg1[0] == '\0' || arg2[0] == '\0' || !is_number( arg2 ) )
    {
  send_to_char( "Syntax: trust <char> <level>.\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
  send_to_char( "That player is not here.\n\r", ch);
  return;
    }

    if ( ( level = atoi( arg2 ) ) < 0 || level > MAX_LEVEL )
    {
      sprintf(buf, "Level must be 0 (reset) or 1 to %d.\n\r",MAX_LEVEL);
      send_to_char(buf, ch);
      return;
    }

    if ( level > get_trust( ch ) )
    {
  send_to_char( "Limited to your trust.\n\r", ch );
  return;
    }

    victim->trust = level;
    return;
}



void do_restore( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH], buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *vch;
    DESCRIPTOR_DATA *d;

    one_argument( argument, arg );
    if (arg[0] == '\0' || !str_cmp(arg,"room"))
    {
    /* cure room */
      
        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
        {
            affect_strip(vch,gsn_plague);
            affect_strip(vch,gsn_poison);
            affect_strip(vch,gsn_blindness);
            affect_strip(vch,gsn_sleep);
            affect_strip(vch,gsn_curse);
            
            vch->hit  = vch->max_hit;
            vch->mana = vch->max_mana;
            vch->move = vch->max_move;
            update_pos( vch);
            act("$n has restored you.",ch,NULL,vch,TO_VICT,FALSE);
        }

        sprintf(buf,"$N restored room %d.",ch->in_room->vnum);
        wiznet(buf,ch,NULL,WIZ_RESTORE,WIZ_SECURE,get_trust(ch));
        
        send_to_char("Room restored.\n\r",ch);
        return;

    }
    
    if ( (get_trust(ch) >=  58 || override == TRUE)&& 
	 (!str_cmp(arg,"nonclan") || !str_cmp(arg,"all")))
    {
    /* cure all */
      
        for (d = descriptor_list; d != NULL; d = d->next)
        {
      victim = d->character;

      if (victim == NULL || IS_NPC(victim)
	  || (victim->pcdata && victim->pcdata->quit_time > 0 ))
    continue;
     
      if (!str_cmp(arg,"nonclan") && is_clan(victim))
    continue;
                
            affect_strip(victim,gsn_plague);
            affect_strip(victim,gsn_poison);
            affect_strip(victim,gsn_blindness);
            affect_strip(victim,gsn_sleep);
            affect_strip(victim,gsn_curse);
            
            victim->hit   = victim->max_hit;
            victim->mana  = victim->max_mana;
            victim->move  = victim->max_move;
            victim->pcdata->sac = (victim->class == class_lookup("paladin")) ? 600:300;
	    if(victim->class == class_lookup("crusader"))
	    {
	       victim->pcdata->sac = 400;
	    }

	    if(HAS_KIT(victim,"bishop"))
	       victim->pcdata->sac += 100;

            update_pos( victim);
      if (victim->in_room != NULL)
                act("$n has restored you.",ch,NULL,victim,TO_VICT,FALSE);
        }

	if (!str_cmp(arg,"nonclan"))
	   send_to_char("All active nonclanners restored.\n\r",ch);
	else
           send_to_char("All active players restored.\n\r",ch);
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    affect_strip(victim,gsn_plague);
    affect_strip(victim,gsn_poison);
    affect_strip(victim,gsn_blindness);
    affect_strip(victim,gsn_sleep);
    affect_strip(victim,gsn_curse);
    victim->hit  = victim->max_hit;
    victim->mana = victim->max_mana;
    victim->move = victim->max_move;
    update_pos( victim );
    act( "$n has restored you.", ch, NULL, victim, TO_VICT ,FALSE);
    sprintf(buf,"$N restored %s",
  IS_NPC(victim) ? victim->short_descr : victim->name);
    wiznet(buf,ch,NULL,WIZ_RESTORE,WIZ_SECURE,get_trust(ch));
    send_to_char( "Ok.\n\r", ch );
    return;
}

  
void do_freeze( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH],buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Freeze whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( IS_NPC(victim) )
    {
  send_to_char( "Not on NPC's.\n\r", ch );
  return;
    }

    if ( get_trust( victim ) >= get_trust( ch ) )
    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    if ( IS_SET(victim->act, PLR_FREEZE) )
    {
  REMOVE_BIT(victim->act, PLR_FREEZE);
  send_to_char( "You can play again.\n\r", victim );
  send_to_char( "FREEZE removed.\n\r", ch );
  sprintf(buf,"$N thaws %s.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    {
  SET_BIT(victim->act, PLR_FREEZE);
  send_to_char( "You can't do ANYthing!\n\r", victim );
  send_to_char( "FREEZE set.\n\r", ch );
  sprintf(buf,"$N puts %s in the deep freeze.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }

    save_char_obj( victim );

    return;
}



void do_log( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Log whom?\n\r", ch );
  return;
    }

    if ( !str_cmp( arg, "all" ) )
    {
  if ( fLogAll )
  {
      fLogAll = FALSE;
      send_to_char( "Log ALL off.\n\r", ch );
  }
  else
  {
      fLogAll = TRUE;
      send_to_char( "Log ALL on.\n\r", ch );
  }
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( IS_NPC(victim) )
    {
  send_to_char( "Not on NPC's.\n\r", ch );
  return;
    }

    /*
     * No level check, gods can log anyone.
     */
    if ( IS_SET(victim->act, PLR_LOG) )
    {
  REMOVE_BIT(victim->act, PLR_LOG);
  send_to_char( "LOG removed.\n\r", ch );
    }
    else
    {
  SET_BIT(victim->act, PLR_LOG);
  send_to_char( "LOG set.\n\r", ch );
    }

    return;
}



void do_noemote( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH],buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Noemote whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }


    if ( get_trust( victim ) >= get_trust( ch ) )
    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    if ( IS_SET(victim->comm, COMM_NOEMOTE) )
    {
  REMOVE_BIT(victim->comm, COMM_NOEMOTE);
  send_to_char( "You can emote again.\n\r", victim );
  send_to_char( "NOEMOTE removed.\n\r", ch );
  sprintf(buf,"$N restores emotes to %s.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    {
  SET_BIT(victim->comm, COMM_NOEMOTE);
  send_to_char( "You can't emote!\n\r", victim );
  send_to_char( "NOEMOTE set.\n\r", ch );
  sprintf(buf,"$N revokes %s's emotes.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }

    return;
}



void do_noshout( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH],buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Noshout whom?\n\r",ch);
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( IS_NPC(victim) )
    {
  send_to_char( "Not on NPC's.\n\r", ch );
  return;
    }

    if ( get_trust( victim ) >= get_trust( ch ) )
    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    if ( IS_SET(victim->comm, COMM_NOSHOUT) )
    {
  REMOVE_BIT(victim->comm, COMM_NOSHOUT);
  send_to_char( "You can shout again.\n\r", victim );
  send_to_char( "NOSHOUT removed.\n\r", ch );
  sprintf(buf,"$N restores shouts to %s.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    {
  SET_BIT(victim->comm, COMM_NOSHOUT);
  send_to_char( "You can't shout!\n\r", victim );
  send_to_char( "NOSHOUT set.\n\r", ch );
  sprintf(buf,"$N revokes %s's shouts.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }

    return;
}


void do_notel( CHAR_DATA *ch, char *argument)
{
    send_to_char("You must type the full command to notell someone.\n\r",ch);
    return;
}

void do_notitle( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
 send_to_char( "Notitle whom?\n\r", ch);
 return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "Not on-line.\n\r", ch);
  return;
    }

    if ( IS_NPC(victim) )
    {
 send_to_char( "Not on NPCs.\n\r", ch);
 return;
    }

    if ( get_trust( victim ) > get_trust(ch) )
    {
 send_to_char("You failed.\n\r",ch);
 return;
    }

    if ( IS_SET(victim->comm,COMM_NOTITLE) )
    {
	REMOVE_BIT(victim->comm,COMM_NOTITLE);
	sprintf(buf,"$N restores %s's title.",victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
	send_to_char("Notitle removed.\n\r",ch);
	return;
    }
    else
    {
	SET_BIT(victim->comm,COMM_NOTITLE);
	sprintf(buf,"$N disables %s's title." ,victim->name);
	wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
	send_to_char("Notitles set.\n\r",ch);
	return;
    }

    bug("End of functino: do_notitle",0);
    return;
}

void do_lag( CHAR_DATA *ch, char *argument )
{
   char arg[MAX_INPUT_LENGTH];
   char arg2[MAX_INPUT_LENGTH];
   CHAR_DATA *victim;

   argument = one_argument( argument, arg );
   one_argument( argument, arg2 );

   if ( arg[0] == '\0' || arg2[0] == '\0' )
   {
	do_help(ch,"lag");
	return;
   }

   if ( !is_number(arg2) )
   {
	send_to_char("Second argument msut be numeric.\n\r",ch);
	return;
   }

   if ( ( victim = get_char_world( ch, arg ) ) == NULL )
   {
       send_to_char("That person isn't here.\n\r",ch);
       return;
   }

   if ( get_trust(victim) > get_trust(ch) )
   {
       send_to_char("You failed.\n\r",ch);
       return;
   }

   WAIT_STATE( victim, atoi(arg2) * 4 );
   send_to_char("The lag beast strikes!\n\r",ch);
   return;
}

void do_notell( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH],buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Notell whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( get_trust( victim ) >= get_trust( ch ) )
    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    if ( IS_SET(victim->comm, COMM_NOTELL) )
    {
  REMOVE_BIT(victim->comm, COMM_NOTELL);
  send_to_char( "You can tell again.\n\r", victim );
  send_to_char( "NOTELL removed.\n\r", ch );
  sprintf(buf,"$N restores tells to %s.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }
    else
    {
  SET_BIT(victim->comm, COMM_NOTELL);
  send_to_char( "You can't tell!\n\r", victim );
  send_to_char( "NOTELL set.\n\r", ch );
  sprintf(buf,"$N revokes %s's tells.",victim->name);
  wiznet(buf,ch,NULL,WIZ_PENALTIES,WIZ_SECURE,0);
    }

    return;
}



void do_peace( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *rch;

    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
    {
  if ( rch->fighting != NULL )
      stop_fighting( rch, TRUE );
  if (IS_NPC(rch) && IS_SET(rch->act,ACT_AGGRESSIVE))
      REMOVE_BIT(rch->act,ACT_AGGRESSIVE);
    }

    send_to_char( "Ok.\n\r", ch );
    return;
}

void do_wizlock( CHAR_DATA *ch, char *argument )
{
    extern bool wizlock;
    wizlock = !wizlock;

    if ( wizlock )
    {
  wiznet("$N has wizlocked the game.",ch,NULL,0,0,0);
  send_to_char( "Game wizlocked.\n\r", ch );
    }
    else
    {
  wiznet("$N removes wizlock.",ch,NULL,0,0,0);
  send_to_char( "Game un-wizlocked.\n\r", ch );
    }

    return;
}

/* RT anti-newbie code */

void do_newlock( CHAR_DATA *ch, char *argument )
{
    extern bool newlock;
    newlock = !newlock;
 
    if ( newlock )
    {
  wiznet("$N locks out new characters.",ch,NULL,0,0,0);
        send_to_char( "New characters have been locked out.\n\r", ch );
    }
    else
    {
  wiznet("$N allows new characters back in.",ch,NULL,0,0,0);
        send_to_char( "Newlock removed.\n\r", ch );
    }
 
    return;
}


void do_slookup( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    int sn;

    one_argument( argument, arg );
    if ( arg[0] == '\0' )
    {
  send_to_char( "Lookup which skill or spell?\n\r", ch );
  return;
    }

    if ( !str_cmp( arg, "all" ) )
    {
  for ( sn = 0; sn < MAX_SKILL; sn++ )
  {
      if ( skill_table[sn].name == NULL )
    break;
      sprintf( buf, "Sn: %3d  Slot: %3d  Skill/spell: '%s'\n\r",
    sn, skill_table[sn].slot, skill_table[sn].name );
      send_to_char( buf, ch );
  }
    }
    else
    {
  if ( ( sn = skill_lookup( arg ) ) < 0 )
  {
      send_to_char( "No such skill or spell.\n\r", ch );
      return;
  }

  sprintf( buf, "Sn: %3d  Slot: %3d  Skill/spell: '%s'\n\r",
      sn, skill_table[sn].slot, skill_table[sn].name );
  send_to_char( buf, ch );
    }

    return;
}

/* RT set replaces sset, mset, oset, and rset */

void do_set( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];

    argument = one_argument(argument,arg);

    if (ch->level < 58)
    {
        send_to_char("You must be at least level 58 to use set.\n\r",ch);
        return;
    }

    if (arg[0] == '\0')
    {
  send_to_char("Syntax:\n\r",ch);
  send_to_char("  set mob   <name> <field> <value>\n\r",ch);
  send_to_char("  set obj   <name> <field> <value>\n\r",ch);
  send_to_char("  set room  <room> <field> <value>\n\r",ch);
        send_to_char("  set skill <name> <spell or skill> <value>\n\r",ch);
  return;
    }

    if (!str_prefix(arg,"mobile") || !str_prefix(arg,"character"))
    {
  do_mset(ch,argument);
  return;
    }

    if (!str_prefix(arg,"skill") || !str_prefix(arg,"spell"))
    {
  do_sset(ch,argument);
  return;
    }

    if (!str_prefix(arg,"object"))
    {
  do_oset(ch,argument);
  return;
    }

    if (!str_prefix(arg,"room"))
    {
  do_rset(ch,argument);
  return;
    }
    /* echo syntax */
    do_set(ch,"");
}


void do_sset( CHAR_DATA *ch, char *argument )
{
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    char arg3 [MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    int value;
    int sn;
    bool fAll;

  if( ch->level < MAX_LEVEL -2 && ch->icg != ICG_ADMIN)
    {
	send_to_char("You are not permitted to set skills.\n\r",ch);
	return;
    }

    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    argument = one_argument( argument, arg3 );

    if ( arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' )
    {
  send_to_char( "Syntax:\n\r",ch);
  send_to_char( "  set skill <name> <spell or skill> <value>\n\r", ch);
  send_to_char( "  set skill <name> all <value>\n\r",ch);  
  send_to_char("   (use the name of the skill, not the number)\n\r",ch);
  return;
    }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( IS_NPC(victim) )
    {
  send_to_char( "Not on NPC's.\n\r", ch );
  return;
    }

    fAll = !str_cmp( arg2, "all" );
    sn   = 0;
    if ( !fAll && ( sn = skill_lookup( arg2 ) ) < 0 )
    {
  send_to_char( "No such skill or spell.\n\r", ch );
  return;
    }

    /*
     * Snarf the value.
     */
    if ( !is_number( arg3 ) )
    {
  send_to_char( "Value must be numeric.\n\r", ch );
  return;
    }

    value = atoi( arg3 );
    if ( value < 0 || value > 100 )
    {
  send_to_char( "Value range is 0 to 100.\n\r", ch );
  return;
    }

    if ( fAll )
    {
  for ( sn = 0; sn < MAX_SKILL; sn++ )
  {
      if ( skill_table[sn].name != NULL )
    victim->pcdata->learned[sn] = value;
  }
    }
    else
    {
  victim->pcdata->learned[sn] = value;
    }

    return;
}



void do_mset( CHAR_DATA *ch, char *argument )
{
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    char arg3 [MAX_INPUT_LENGTH];
    char buf[100];
    CHAR_DATA *victim;
    int value;

    smash_tilde( argument );
    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    strcpy( arg3, argument );

    if ( arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' )
    {
  send_to_char("Syntax:\n\r",ch);
  send_to_char("  set char <name> <field> <value>\n\r",ch); 
  send_to_char( "  Field being one of:\n\r",      ch );
  send_to_char( "    str int wis dex con agt end soc\n\r", ch); 
  send_to_char( "    surname sex class level sac race\n\r",  ch );
  send_to_char( "    group gold silver hp mana move prac logins\n\r",ch);
  send_to_char( "    align train thirst hunger drunk full bounty\n\r", ch );
  return;
    }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    /* clear zones for mobs */
    victim->zone = NULL;

    /*
     * Snarf the value (which need not be numeric).
     */
    value = is_number( arg3 ) ? atoi( arg3 ) : -1;

    /*
     * Set something.
     */

    if (!str_cmp(arg2, "surname"))
    {
	if (IS_NPC(victim))
	{
	    send_to_char("Not on an NPC.\n\r",ch);
	    return;
	}

	if ( strlen(arg3) > 12 )
 	{
		send_to_char("Name too long.\n\r",ch);
		return;
	}

	if ( !str_cmp(arg3,"clear") )
	{
	    if ( victim->pcdata->surname != NULL )
		free_string(victim->pcdata->surname);
	    victim->pcdata->surname = NULL;
	    send_to_char("Surname cleared.\n\r",ch);
	    return;
	}
	else
        {
	    if ( victim->pcdata->surname != NULL )
		free_string(victim->pcdata->surname);
	    victim->pcdata->surname = str_dup(arg3);
	    send_to_char("Surname set.\n\r",ch);
	    return;
	}
    }

    if (!str_cmp(arg2, "logins"))
    {
	if (IS_NPC(victim))
	{
	    send_to_char("Not on an NPC.\n\r",ch);
	    return;
	}
	if( value < 0 )
	{
	    send_to_char("Value must be more than 0.\n\r",ch);
	    return;
	}
	victim->pcdata->logins_without_combat = value;
	victim->pcdata->logins_without_death = value;
	victim->pcdata->logins_without_kill = value; 
	send_to_char("Logins have been cleared.\n\r",ch);
	return;

    }

    if (!str_cmp(arg2, "bounty"))
    {
	if (IS_NPC(victim))
	{
	    send_to_char("Not on an NPC.\n\r",ch);
	    return;
	}

	if( value < 0 )
	{
	    send_to_char("Value must be more than 0.\n\r",ch);
	    return;
	}

	victim->pcdata->bounty = value;
	send_to_char("Bounty set.\n\r",ch);
	return;
    }

    if (!str_cmp(arg2, "mhs"))
    {
       if (IS_NPC(victim))
       {
	  send_to_char("Not on an NPC.\n\r",ch);
	  return;
       }

       if ( IS_SET(victim->mhs,MHS_OLD_RECLASS))
       {
          REMOVE_BIT(victim->mhs,MHS_OLD_RECLASS);
	  send_to_char("MHS bit removed.\n\r",ch);
	  return;
       }
       else
       {
	  SET_BIT(victim->mhs,MHS_OLD_RECLASS);
          send_to_char("MHS bit set.\n\r",ch);
          return;
       }
    }

    if (!str_cmp(arg2, "board"))
    {
        if ( get_trust(ch) < 59 )
	{
	    send_to_char("Only 59's can set the board flag.\n\r",ch);
	    return;
	}

	if ( IS_NPC(victim) )
	{
	    send_to_char("Not on an NPC.\n\r",ch);
	    return;
	}

    	if ( IS_SET(victim->mhs,MHS_ADVISORY_BOARD) )
	{
	   REMOVE_BIT(victim->mhs,MHS_ADVISORY_BOARD);
	   send_to_char("Board bit removed.\n\r",ch);
	   return;
	}
	else
	{
	   SET_BIT(victim->mhs,MHS_ADVISORY_BOARD);
	   send_to_char("Board bit set.\n\r",ch);
	   return;
	}
    }

    if (!str_cmp(arg2, "hours"))
	 {
	    if (value < 1)
	      {
		 send_to_char("You may not set a player to less than 1 hour.\n",ch);
		 return;
	      }
	    victim->played = value * 3600;
	    send_to_char("Ok.\n",ch);
	    return;
	 }


    if ( !str_cmp( arg2, "str" ) )
    {
  if ( value < 3 || value > get_max_train(victim,STAT_STR) )
  {
      sprintf(buf,
    "Strength range is 3 to %d\n\r.",
    get_max_train(victim,STAT_STR));
      send_to_char(buf,ch);
      return;
  }

  victim->perm_stat[STAT_STR] = value;
  return;
    }

    if ( !str_cmp( arg2, "int" ) )
    {
        if ( value < 3 || value > get_max_train(victim,STAT_INT) )
        {
            sprintf(buf,
    "Intelligence range is 3 to %d.\n\r",
    get_max_train(victim,STAT_INT));
            send_to_char(buf,ch);
            return;
        }
 
        victim->perm_stat[STAT_INT] = value;
        return;
    }

    if ( !str_cmp( arg2, "wis" ) )
    {
  if ( value < 3 || value > get_max_train(victim,STAT_WIS) )
  {
      sprintf(buf,
    "Wisdom range is 3 to %d.\n\r",get_max_train(victim,STAT_WIS));
      send_to_char( buf, ch );
      return;
  }

  victim->perm_stat[STAT_WIS] = value;
  return;
    }

    if ( !str_cmp( arg2, "dex" ) )
    {
  if ( value < 3 || value > get_max_train(victim,STAT_DEX) )
  {
      sprintf(buf,
    "Dexterity range is 3 to %d.\n\r",
    get_max_train(victim,STAT_DEX));
      send_to_char( buf, ch );
      return;
  }

  victim->perm_stat[STAT_DEX] = value;
  return;
    }

    if ( !str_cmp( arg2, "con" ) )
    {
  if ( value < 3 || value > get_max_train(victim,STAT_CON) )
  {
      sprintf(buf,
    "Constitution range is 3 to %d.\n\r",
    get_max_train(victim,STAT_CON));
      send_to_char( buf, ch );
      return;
  }

  victim->perm_stat[STAT_CON] = value;
  return;
    }

    if ( !str_cmp( arg2, "agt" ) )
    {
  if ( value < 3 || value > get_max_train(victim,STAT_AGT) )
  {
      sprintf(buf,
    "Agility range is 3 to %d\n\r.",
    get_max_train(victim,STAT_AGT));
      send_to_char(buf,ch);
      return;
  }

  victim->perm_stat[STAT_AGT] = value;
  return;
    }

    if ( !str_cmp( arg2, "end" ) )
    {
  if ( value < 3 || value > get_max_train(victim,STAT_END) )
  {
      sprintf(buf,
    "Endurance range is 3 to %d\n\r.",
    get_max_train(victim,STAT_END));
      send_to_char(buf,ch);
      return;
  }

  victim->perm_stat[STAT_END] = value;
  return;
    }

    if ( !str_cmp( arg2, "soc" ) )
    {
  if ( value < 3 || value > get_max_train(victim,STAT_SOC) )
  {
      sprintf(buf,
    "Social range is 3 to %d\n\r.",
    get_max_train(victim,STAT_SOC));
      send_to_char(buf,ch);
      return;
  }

  victim->perm_stat[STAT_SOC] = value;
  return;
    }

    if ( !str_prefix( arg2, "sac" ) )
    {
     if ( value < 0 || value > 300 )
	{
	 send_to_char( "Sac range is 0 to 300.\n\r",ch);
	 return;
	}
     victim->pcdata->sac = value;
     return;
    }

    if ( !str_prefix( arg2, "sex" ) )
    {
  if ( value < 0 || value > 2 )
  {
      send_to_char( "Sex range is 0 to 2.\n\r", ch );
      return;
  }
  victim->sex = value;
  if (!IS_NPC(victim))
      victim->pcdata->true_sex = value;
  return;
    }

    if ( !str_prefix( arg2, "oldclass" ) )
    {
  int class;

  if ( IS_NPC(victim) )
  {
      send_to_char("Mobs don't have any class.\n\r",ch);
      return;
  }

  if ( ( class = class_lookup( arg3 ) ) == -1 )
  {
	send_to_char("That's not a class.\n\r",ch);
	return; 
  }

  if (  class_table[class].reclass )
   {
       send_to_char("OLD CLASS, brain child.  Old class.\n\r",ch);
       return;
   }

  victim->pcdata->old_class = class;
  return;

  }




    if ( !str_prefix( arg2, "class" ) )
    {
  int class;

  if (IS_NPC(victim))
  {
      send_to_char("Mobiles have no class.\n\r",ch);
      return;
  }

  class = class_lookup(arg3);
  if ( class == -1 )
  {
      char buf[MAX_STRING_LENGTH];

          strcpy( buf, "Possible classes are: " );
          for ( class = 0; class < MAX_CLASS; class++ )
          {
                  if ( class > 0 )
                      strcat( buf, " " );
                  strcat( buf, class_table[class].name );
          }
            strcat( buf, ".\n\r" );

      send_to_char(buf,ch);
      return;
  }

  victim->class = class;
  return;
    }

    if ( !str_prefix( arg2, "level" ) )
    {
  if ( !IS_NPC(victim) )
  {
      send_to_char( "Not on PC's.\n\r", ch );
      return;
  }

  if ( value < 0 || value > MAX_LEVEL )
  {
    sprintf(buf, "Level range is 0 to %d.\n\r", MAX_LEVEL);
    send_to_char(buf, ch);
    return;
  }
  victim->level = value;
  return;
    }

    if ( !str_prefix( arg2, "gold" ) )
    {
  victim->gold = value;
  return;
    }

    if ( !str_prefix(arg2, "silver" ) )
    {
  victim->silver = value;
  return;
    }

    if ( !str_prefix( arg2, "hp" ) )
    {
  if ( value < -10 || value > 30000 )
  {
      send_to_char( "Hp range is -10 to 30,000 hit points.\n\r", ch );
      return;
  }
  victim->max_hit = value;
        if (!IS_NPC(victim))
            victim->pcdata->perm_hit = value;
  return;
    }

    if ( !str_prefix( arg2, "mana" ) )
    {
  if ( value < 0 || value > 30000 )
  {
      send_to_char( "Mana range is 0 to 30,000 mana points.\n\r", ch );
      return;
  }
  victim->max_mana = value;
        if (!IS_NPC(victim))
            victim->pcdata->perm_mana = value;
  return;
    }

    if ( !str_prefix( arg2, "move" ) )
    {
  if ( value < 0 || value > 30000 )
  {
      send_to_char( "Move range is 0 to 30,000 move points.\n\r", ch );
      return;
  }
  victim->max_move = value;
        if (!IS_NPC(victim))
            victim->pcdata->perm_move = value;
  return;
    }

    if ( !str_prefix( arg2, "practice" ) )
    {
  if ( value < 0 || value > 250 )
  {
      send_to_char( "Practice range is 0 to 250 sessions.\n\r", ch );
      return;
  }
  victim->practice = value;
  return;
    }

    if ( !str_prefix( arg2, "train" ))
    {
  if (value < 0 || value > 50 )
  {
      send_to_char("Training session range is 0 to 50 sessions.\n\r",ch);
      return;
  }
  victim->train = value;
  return;
    }

    if ( !str_prefix( arg2, "align" ) )
    {
  if ( value < -1000 || value > 1000 )
  {
      send_to_char( "Alignment range is -1000 to 1000.\n\r", ch );
      return;
  }
  victim->alignment = value;
  return;
    }

    if ( !str_prefix( arg2, "thirst" ) )
    {
  if ( IS_NPC(victim) )
  {
      send_to_char( "Not on NPC's.\n\r", ch );
      return;
  }

  if ( value < -1 || value > 100 )
  {
      send_to_char( "Thirst range is -1 to 100.\n\r", ch );
      return;
  }

  victim->pcdata->condition[COND_THIRST] = value;
  return;
    }

    if ( !str_prefix( arg2, "drunk" ) )
    {
  if ( IS_NPC(victim) )
  {
      send_to_char( "Not on NPC's.\n\r", ch );
      return;
  }

  if ( value < -1 || value > 100 )
  {
      send_to_char( "Drunk range is -1 to 100.\n\r", ch );
      return;
  }

  victim->pcdata->condition[COND_DRUNK] = value;
  return;
    }

    if ( !str_prefix( arg2, "full" ) )
    {
  if ( IS_NPC(victim) )
  {
      send_to_char( "Not on NPC's.\n\r", ch );
      return;
  }

  if ( value < -1 || value > 100 )
  {
      send_to_char( "Full range is -1 to 100.\n\r", ch );
      return;
  }

  victim->pcdata->condition[COND_FULL] = value;
  return;
    }

    if ( !str_prefix( arg2, "hunger" ) )
    {
        if ( IS_NPC(victim) )
        {
            send_to_char( "Not on NPC's.\n\r", ch );
            return;
        }
 
        if ( value < -1 || value > 100 )
        {
            send_to_char( "Full range is -1 to 100.\n\r", ch );
            return;
        }
 
        victim->pcdata->condition[COND_HUNGER] = value;
        return;
    }

    if (!str_prefix( arg2, "race" ) )
    {
  int race;

  race = race_lookup(arg3);

  if ( race == 0)
  {
      send_to_char("That is not a valid race.\n\r",ch);
      return;
  }

  if (!IS_NPC(victim) && !race_table[race].pc_race)
  {
      send_to_char("That is not a valid player race.\n\r",ch);
      return;
  }

  victim->race = race;
  victim->size = pc_race_table[race].size; 
  return;
    }
   
    if (!str_prefix(arg2,"group"))
    {
  if (!IS_NPC(victim))
  {
      send_to_char("Only on NPCs.\n\r",ch);
      return;
  }
  victim->group = value;
  return;
    }


    /*
     * Generate usage message.
     */
    do_mset( ch, "" );
    return;
}

void do_string( CHAR_DATA *ch, char *argument )
{
    char type [MAX_INPUT_LENGTH];
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    char arg3 [MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *obj;

    smash_tilde( argument );
    argument = one_argument( argument, type );
    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    strcpy( arg3, argument );

    if ( type[0] == '\0' || arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' )
    {
  send_to_char("Syntax:\n\r",ch);
  send_to_char("  string char <name> <field> <string>\n\r",ch);
  send_to_char("    fields: name short long desc title surname spec\n\r",ch);
  send_to_char("  string obj  <name> <field> <string>\n\r",ch);
  send_to_char("    fields: name short long extended\n\r",ch);
  return;
    }
    
    if (!str_prefix(type,"character") || !str_prefix(type,"mobile"))
    {
      if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
      {
      send_to_char( "They aren't here.\n\r", ch );
      return;
      }

  /* clear zone for mobs */
  victim->zone = NULL;

  /* string something */

      if ( !str_prefix( arg2, "name" ) )
      {
      if ( !IS_NPC(victim) )
      {
        send_to_char( "Not on PC's.\n\r", ch );
        return;
      }
      free_string( victim->name );
      victim->name = str_dup( arg3 );
      return;
      }
      
      if ( !str_prefix( arg2, "description" ) )
      {
          free_string(victim->description);
          victim->description = str_dup(arg3);
          return;
      }

      if ( !str_prefix( arg2, "short" ) )
      {
      free_string( victim->short_descr );
      victim->short_descr = str_dup( arg3 );
      return;
      }

      if ( !str_prefix( arg2, "long" ) )
      {
      free_string( victim->long_descr );
      strcat(arg3,"\n\r");
      victim->long_descr = str_dup( arg3 );
      return;
      }

      if ( !str_prefix( arg2, "title" ) )
      {
      if ( IS_NPC(victim) )
      {
        send_to_char( "Not on NPC's.\n\r", ch );
        return;
      }

      set_title( victim, arg3 );
      return;
      }

      if ( !str_prefix( arg2, "spec" ) )
      {
      if ( !IS_NPC(victim) )
      {
        send_to_char( "Not on PC's.\n\r", ch );
        return;
      }

      if ( ( victim->spec_fun = spec_lookup( arg3 ) ) == 0 )
      {
        send_to_char( "No such spec fun.\n\r", ch );
        return;
      }
	}

    if (!str_prefix(arg2, "surname"))
    {
	if (IS_NPC(victim))
	{
	    send_to_char("Not on an NPC.\n\r",ch);
	    return;
	}

	if ( strlen(arg3) > 12 )
 	{
		send_to_char("Name too long.\n\r",ch);
		return;
	}

	if ( !str_cmp(arg3,"clear") )
	{
	    if ( victim->pcdata->surname != NULL )
		free_string(victim->pcdata->surname);
	    victim->pcdata->surname = NULL;
	    send_to_char("Surname cleared.\n\r",ch);
	    return;
	}
	else
        {
	    if ( victim->pcdata->surname != NULL )
		free_string(victim->pcdata->surname);
	    victim->pcdata->surname = str_dup(arg3);
	    send_to_char("Surname set.\n\r",ch);
	    return;
	}
      }

      return;
    }
    
    if (!str_prefix(type,"object"))
    {
      /* string an obj */
      
    if ( ( obj = get_obj_world( ch, arg1 ) ) == NULL )
      {
      send_to_char( "Nothing like that in heaven or earth.\n\r", ch );
      return;
      }
      
        if ( !str_prefix( arg2, "name" ) )
      {
      free_string( obj->name );
      obj->name = str_dup( arg3 );
      return;
      }

      if ( !str_prefix( arg2, "short" ) )
      {
      free_string( obj->short_descr );
      obj->short_descr = str_dup( arg3 );
      return;
      }

      if ( !str_prefix( arg2, "long" ) )
      {
      free_string( obj->description );
      obj->description = str_dup( arg3 );
      return;
      }

      if ( !str_prefix( arg2, "ed" ) || !str_prefix( arg2, "extended"))
      {
      EXTRA_DESCR_DATA *ed;

      argument = one_argument( argument, arg3 );
      if ( argument == NULL )
      {
        send_to_char( "Syntax: oset <object> ed <keyword> <string>\n\r",
        ch );
        return;
      }

      strcat(argument,"\n\r");

      ed = new_extra_descr();

      ed->keyword   = str_dup( arg3     );
      ed->description = str_dup( argument );
      ed->next    = obj->extra_descr;
      obj->extra_descr  = ed;
      return;
      }
    }
    
      
    /* echo bad use message */
    do_string(ch,"");
}



void do_oset( CHAR_DATA *ch, char *argument )
{
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    char arg3 [MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int value;

    smash_tilde( argument );
    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    strcpy( arg3, argument );

    if ( arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' )
    {
  send_to_char("Syntax:\n\r",ch);
  send_to_char("  set obj <object> <field> <value>\n\r",ch);
  send_to_char("  Field being one of:\n\r",       ch );
  send_to_char("    value0 value1 value2 value3 value4 (v1-v4)\n\r",  ch );
  send_to_char("    extra wear level weight cost timer\n\r",    ch );
  return;
    }

    if ( ( obj = get_obj_world( ch, arg1 ) ) == NULL )
    {
  send_to_char( "Nothing like that in heaven or earth.\n\r", ch );
  return;
    }

    /*
     * Snarf the value (which need not be numeric).
     */
    value = atoi( arg3 );

    /*
     * Set something.
     */
    if ( !str_cmp( arg2, "value0" ) || !str_cmp( arg2, "v0" ) )
    {
  obj->value[0] = UMIN(50,value);
  return;
    }

    if ( !str_cmp( arg2, "value1" ) || !str_cmp( arg2, "v1" ) )
    {
  obj->value[1] = value;
  return;
    }

    if ( !str_cmp( arg2, "value2" ) || !str_cmp( arg2, "v2" ) )
    {
  obj->value[2] = value;
  return;
    }

    if ( !str_cmp( arg2, "value3" ) || !str_cmp( arg2, "v3" ) )
    {
  obj->value[3] = value;
  return;
    }

    if ( !str_cmp( arg2, "value4" ) || !str_cmp( arg2, "v4" ) )
    {
  obj->value[4] = value;
  return;
    }

    if ( !str_prefix( arg2, "extra" ) )
    {
  obj->extra_flags = value;
  return;
    }

    if ( !str_prefix( arg2, "wear" ) )
    {
  obj->wear_flags = value;
  return;
    }

    if ( !str_prefix( arg2, "level" ) )
    {
  obj->level = value;
  return;
    }
  
    if ( !str_prefix( arg2, "weight" ) )
    {
  obj->weight = value;
  return;
    }

    if ( !str_prefix( arg2, "cost" ) )
    {
  obj->cost = value;
  return;
    }

    if ( !str_prefix( arg2, "timer" ) )
    {
  obj->timer = value;
  return;
    }
  
    /*
     * Generate usage message.
     */
    do_oset( ch, "" );
    return;
}



void do_rset( CHAR_DATA *ch, char *argument )
{
    char arg1 [MAX_INPUT_LENGTH];
    char arg2 [MAX_INPUT_LENGTH];
    char arg3 [MAX_INPUT_LENGTH];
    ROOM_INDEX_DATA *location;
    int value;

    smash_tilde( argument );
    argument = one_argument( argument, arg1 );
    argument = one_argument( argument, arg2 );
    strcpy( arg3, argument );

    if ( arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' )
    {
  send_to_char( "Syntax:\n\r",ch);
  send_to_char( "  set room <location> <field> <value>\n\r",ch);
  send_to_char( "  Field being one of:\n\r",      ch );
  send_to_char( "    flags sector\n\r",       ch );
  return;
    }

    if ( ( location = find_location( ch, arg1 ) ) == NULL )
    {
  send_to_char( "No such location.\n\r", ch );
  return;
    }

    if (!is_room_owner(ch,location) && ch->in_room != location 
    &&  room_is_private(ch,location) && !IS_TRUSTED(ch,IMPLEMENTOR))
    {
        send_to_char("That room is private right now.\n\r",ch);
        return;
    }

    /*
     * Snarf the value.
     */
    if ( !is_number( arg3 ) )
    {
  send_to_char( "Value must be numeric.\n\r", ch );
  return;
    }
    value = atoi( arg3 );

    /*
     * Set something.
     */
    if ( !str_prefix( arg2, "flags" ) )
    {
  location->room_flags  = value;
  return;
    }

    if ( !str_prefix( arg2, "sector" ) )
    {
  location->sector_type = value;
  return;
    }

    /*
     * Generate usage message.
     */
    do_rset( ch, "" );
    return;
}

/*  removed by Nightdagger, 1/18/03, don't need it
void do_socke( CHAR_DATA *ch, char *argument )
{
    send_to_char("You must use the full command to check sockets.\n\r",ch);
}
*/

void do_sockets( CHAR_DATA *ch, char *argument )
{
    char buf[4 * MAX_STRING_LENGTH];
    char buf2[MAX_STRING_LENGTH];
    char cdbuf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    char *name;
    DESCRIPTOR_DATA *d;
    int count;
    bool suffix,prefix,disp;
    static char *connect_table[] = {
      "[ 0] Playing",
      "[ 1] Get Name", 
      "[ 2] Get Old Pass",
      "[ 3] Confirm Name",
      "[ 4] Get New Pass",
      "[ 5] Confirm Pass",
      "[ 6] Get New Race",
      "[ 7] Get New Sex",
      "[ 8] Get New Class",
      "[ 9] Get Alignment",
      "[10] Customize?",
      "[11] Gen Groups",
      "[12] Pick Weapon",
      "[13] Read IMOTD",
      "[14] Read MOTD",
      "[15] Break Connect",
      "[16] Line Editor",
      "[17] Pick Stats",
      "[18] Login Menu",
      "[19] Creation",
      "[20] P-Refresh Character",
      "[21] Smurf Password",
      "[22} Pick Surname",
      ""
    };

    count = 0;
    buf[0]  = '\0';
    buf2[0]  = '\0';

    one_argument(argument,arg);
    if (arg[0] == '@@') {
      name = &arg[1];
      prefix = suffix = FALSE;
      if (name[0] == '*')
      {
        prefix = TRUE;
        name++;
      }  
      if (name[strlen(name) - 1] == '*')
      {
        suffix = TRUE;
        name[strlen(name) - 1] = '\0';
      }
      
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
        if ( d->character != NULL && can_see( ch, d->character, TRUE ))
        {      
          disp = FALSE;
          if ((prefix &&  suffix) && strstr(d->host,name) != NULL)
              disp = TRUE;    
          if (prefix && !str_suffix(name,d->host))
              disp = TRUE;    
          if (suffix && !str_prefix(name,d->host))
              disp = TRUE;
          if (!suffix && !prefix && !str_cmp (name,d->host))
              disp = TRUE;
          if (disp)  {
              count++;
              sprintf( buf2, "[%2d] %-18s %s@@%s:%d\n\r",
                d->descriptor,
                connect_table[d->connected],
                d->original  ? d->original->name  :
                d->character ? d->character->name : "(none)",
                d->host, d->port);            
	      strcat(buf,buf2);
          }
        }
      }
    } else {
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
        if (d->character==NULL)
        {
		cdbuf[0]='\0';

	    if(d->descriptor != NULL && d->connected != NULL && d->host != NULL && d->port != NULL)
	    {
                sprintf(buf2,"[%2d] Nobody yet @@%s:%d\r\n",
		d->descriptor,d->host,d->port);
		strcat(buf,buf2);
	    }
	    else
	    {
              sprintf(cdbuf, "SOCKET ERROR Desc: %2d Conn: %-18s Host: %s Port: %d",
		(d->descriptor!=NULL)?d->descriptor:0,
		(d->connected!=NULL)?connect_table[d->connected]:"NULL",
		(d->host!=NULL)?d->host:"NULL",
		(d->port!=NULL)?d->port:0);
              log_string(cdbuf);
 	    }

        } else
        if ( d->character != NULL && can_see( ch, d->character, TRUE ) 
        && (arg[0] == '\0' || is_name(arg,d->character->name)
               || (d->original && is_name(arg,d->original->name))))
        {
            count++;
            sprintf( buf2, "[%2d] %-18s %-15s %s:%d\n\r",
          d->descriptor,
          connect_table[d->connected],
          d->original  ? d->original->name  :
          d->character ? d->character->name : "(none)",
          d->host,d->port);
	     strcat(buf,buf2);
        }
      }
    }
    if (count == 0)
    {
  send_to_char("No one by that name is connected.\n\r",ch);
  return;
    }

    sprintf( buf2, "%d user%s\n\r", count, count == 1 ? "" : "s" );
    strcat(buf,buf2);
    page_to_char( buf, ch );
    return;
}

/*
void do_sockets( CHAR_DATA *ch, char *argument )
{
    char buf[2 * MAX_STRING_LENGTH];
    char buf2[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    DESCRIPTOR_DATA *d;
    int count;

    count = 0;
    buf[0]  = '\0';

    one_argument(argument,arg);
    for ( d = descriptor_list; d != NULL; d = d->next )
    {
  if ( d->character != NULL && can_see( ch, d->character, TRUE ) 
  && (arg[0] == '\0' || is_name(arg,d->character->name)
         || (d->original && is_name(arg,d->original->name))))
  {
      count++;
      sprintf( buf + strlen(buf), "[%3d %2d] %s@@%s\n\r",
    d->descriptor,
    d->connected,
    d->original  ? d->original->name  :
    d->character ? d->character->name : "(none)",
    d->host
    );
  }
    }
    if (count == 0)
    {
  send_to_char("No one by that name is connected.\n\r",ch);
  return;
    }

    sprintf( buf2, "%d user%s\n\r", count, count == 1 ? "" : "s" );
    strcat(buf,buf2);
    page_to_char( buf, ch );
    return;
}
*/



/*
 * Thanks to Grodyn for pointing out bugs in this function.
 */
void do_force( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];

    argument = one_argument( argument, arg );

    if ( arg[0] == '\0' || argument[0] == '\0' )
    {
  send_to_char( "Force whom to do what?\n\r", ch );
  return;
    }

    one_argument(argument,arg2);
  
    if (!str_cmp(arg2,"delete"))
    {
  send_to_char("That will NOT be done.\n\r",ch);
  return;
    }

    sprintf( buf, "$n forces you to '%s'.", argument );

    if ( !str_cmp( arg, "all" ) )
    {
  CHAR_DATA *vch;
  CHAR_DATA *vch_next;

  if (get_trust(ch) < MAX_LEVEL - 3)
  {
      send_to_char("Not at your level!\n\r",ch);
      return;
  }

  for ( vch = char_list; vch != NULL; vch = vch_next )
  {
      vch_next = vch->next;

      if ( !IS_NPC(vch) && get_trust( vch ) < get_trust( ch ) )
      {
    act( buf, ch, NULL, vch, TO_VICT ,FALSE);
    interpret( vch, argument );
      }
  }
    }
    else if (!str_cmp(arg,"players"))
    {
        CHAR_DATA *vch;
        CHAR_DATA *vch_next;
 
        if (get_trust(ch) < MAX_LEVEL - 2)
        {
            send_to_char("Not at your level!\n\r",ch);
            return;
        }
 
        for ( vch = char_list; vch != NULL; vch = vch_next )
        {
            vch_next = vch->next;
 
            if ( !IS_NPC(vch) && get_trust( vch ) < get_trust( ch ) 
      &&   vch->level < LEVEL_HERO)
            {
                act( buf, ch, NULL, vch, TO_VICT ,FALSE);
                interpret( vch, argument );
            }
        }
    }
    else if (!str_cmp(arg,"gods"))
    {
        CHAR_DATA *vch;
        CHAR_DATA *vch_next;
 
        if (get_trust(ch) < MAX_LEVEL - 2)
        {
            send_to_char("Not at your level!\n\r",ch);
            return;
        }
 
        for ( vch = char_list; vch != NULL; vch = vch_next )
        {
            vch_next = vch->next;
 
            if ( !IS_NPC(vch) && get_trust( vch ) < get_trust( ch )
            &&   vch->level >= LEVEL_HERO)
            {
                act( buf, ch, NULL, vch, TO_VICT ,FALSE);
                interpret( vch, argument );
            }
        }
    }
    else
    {
  CHAR_DATA *victim;

  if ( ( victim = get_char_world( ch, arg ) ) == NULL )
  {
      send_to_char( "They aren't here.\n\r", ch );
      return;
  }

  if ( victim == ch )
  {
      send_to_char( "Aye aye, right away!\n\r", ch );
      return;
  }

      if (!is_room_owner(ch,victim->in_room) 
  &&  ch->in_room != victim->in_room 
        &&  room_is_private(ch,victim->in_room) && !IS_TRUSTED(ch,IMPLEMENTOR))
      {
            send_to_char("That character is in a private room.\n\r",ch);
            return;
        }

  if ( get_trust( victim ) >= get_trust( ch ) )
  {
      send_to_char( "Do it yourself!\n\r", ch );
      return;
  }

  if ( !IS_NPC(victim) && get_trust(ch) < MAX_LEVEL -3)
  {
      send_to_char("Not at your level!\n\r",ch);
      return;
  }

  act( buf, ch, NULL, victim, TO_VICT ,FALSE);
  interpret( victim, argument );
    }

    send_to_char( "Ok.\n\r", ch );
    return;
}



/*
 * New routines by Dionysos.
 */
void do_invis( CHAR_DATA *ch, char *argument )
{
    int level;
    char arg[MAX_STRING_LENGTH];

    /* RT code for taking a level argument */
    one_argument( argument, arg );

    if ( arg[0] == '\0' ) 
    /* take the default path */

      if ( ch->invis_level)
      {
    ch->invis_level = 0;
    act( "$n slowly fades into existence.", ch, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "You slowly fade back into existence.\n\r", ch );
      }
      else
      {
    ch->invis_level = get_trust(ch);
    act( "$n slowly fades into thin air.", ch, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "You slowly vanish into thin air.\n\r", ch );
      }
    else
    /* do the level thing */
    {
      level = atoi(arg);
      if (level < 2 || level > get_trust(ch))
      {
  send_to_char("Invis level must be between 2 and your level.\n\r",ch);
        return;
      }
      else
      {
    ch->reply = NULL;
          ch->invis_level = level;
          act( "$n slowly fades into thin air.", ch, NULL, NULL, TO_ROOM ,FALSE);
          send_to_char( "You slowly vanish into thin air.\n\r", ch );
      }
    }

    return;
}


void do_incognito( CHAR_DATA *ch, char *argument )
{
    int level;
    char arg[MAX_STRING_LENGTH];
 
    /* RT code for taking a level argument */
    one_argument( argument, arg );
 
    if ( arg[0] == '\0' )
    /* take the default path */
 
      if ( ch->incog_level)
      {
          ch->incog_level = 0;
          act( "$n is no longer cloaked.", ch, NULL, NULL, TO_ROOM ,FALSE);
          send_to_char( "You are no longer cloaked.\n\r", ch );
      }
      else
      {
          ch->incog_level = get_trust(ch);
          act( "$n cloaks $s presence", ch, NULL, NULL, TO_ROOM ,FALSE);
          send_to_char( "You cloak your presence.\n\r", ch );
      }
    else
    /* do the level thing */
    {
      level = atoi(arg);
      if (level < 2 || level > get_trust(ch))
      {
        send_to_char("Incog level must be between 2 and your level.\n\r",ch);
        return;
      }
      else
      {
          ch->reply = NULL;
          ch->incog_level = level;
          act( "$n cloaks $s presence.", ch, NULL, NULL, TO_ROOM ,FALSE);
          send_to_char( "You cloak your presence.\n\r", ch );
      }
    }
 
    return;
}

void do_dispvnum ( CHAR_DATA *ch, char *argument )
{
    if (IS_NPC(ch))
      return;

    if (IS_SET(ch->display,DISP_DISP_VNUM))     
    {
      send_to_char("Vnums will no longer be displayed.\n\r",ch);
      REMOVE_BIT(ch->display,DISP_DISP_VNUM); 
    }
    else
    {
      send_to_char("Vnums will be displayed.\n\r",ch);
      SET_BIT(ch->display,DISP_DISP_VNUM);
    }
}

void do_holylight( CHAR_DATA *ch, char *argument )
{
    if ( IS_NPC(ch) )
  return;

    if ( IS_SET(ch->act, PLR_HOLYLIGHT) )
    {
  REMOVE_BIT(ch->act, PLR_HOLYLIGHT);
  send_to_char( "Holy light mode off.\n\r", ch );
    }
    else
    {
  SET_BIT(ch->act, PLR_HOLYLIGHT);
  send_to_char( "Holy light mode on.\n\r", ch );
    }

    return;
}

void do_explode ( CHAR_DATA *ch, char *argument )
{
  char arg[MAX_STRING_LENGTH];
  CHAR_DATA *victim,*next_vict;
  OBJ_DATA *obj,*obj_content,*obj_next;
  ROOM_INDEX_DATA *pRoomIndex;
  int min,max,count=0,spin,num,retry;
  
  argument = one_argument( argument, arg );
 
  if ( arg[0] == '\0' ) 
  {
    send_to_char ("Syntax:\n\r",ch);
    send_to_char ("  explode room\n\r",ch);
    send_to_char ("  explode <name of container> <mob_min_level> "
		  "<mob_max_level>\n\r",ch);
    return;
  }

  if (!strcmp (arg,"room")) 
  {
    victim = ch->in_room->people;
    while (victim) 
    {        
      next_vict = victim->next_in_room;
      if ( IS_NPC(victim) ) 
      {          
          pRoomIndex = get_random_room(victim);
          act( "$n vanishes!", victim, NULL, NULL, TO_ROOM ,FALSE);
          char_from_room( victim );
          char_to_room( victim, pRoomIndex );
	  clear_mount( victim );
          act( "$n slowly fades into existence.", victim, NULL, 
		NULL, TO_ROOM ,FALSE);              
      }
        victim = next_vict;
    }       
    return;
  }
    
  obj = get_obj_list ( ch, arg, ch->carrying );
  if (obj == NULL)
  {
    send_to_char ("Item not found.\n\r",ch);
    return;
  }
  if (obj->item_type != ITEM_CONTAINER)
  {
    send_to_char ("That object is not a container.\n\r",ch);
    return;
  }
  argument = one_argument( argument, arg );
  if ( arg[0] != '\0' && is_number (arg))
  {
    min = atoi (arg);         
    argument = one_argument( argument, arg );  
    if ( arg[0] != '\0' && is_number (arg))
    {
      max = atoi (arg);
      if (max < min)
      {
        int temp;
        temp = min;
        min = max;
        max = temp;        
      }
      if ((min > 60) || (min < 1) || (max > 60) || (max < 1))
      {
        send_to_char ("Max and min must be within 0 to 60.\n\r",ch);
        return;
      }
      if ((max - min) < 5)
      {
        send_to_char ("Max and min must differ by at least 5.\n\r",ch);
        return;
      }
	for( victim = char_list; victim != NULL; victim = victim->next )
	{
	  count++;
	}
    while( obj->contains != NULL )
    {
      for ( obj_content = obj->contains; obj_content; obj_content = obj_next )
      {
        obj_next = obj_content->next_content;
        if (obj_content)
	{
          obj_from_obj ( obj_content );      
          victim = NULL;
          retry = 0;
          while (!victim)
          {
            retry++;
            if (retry > 300)
            {
              send_to_char ("Min and max levels are too terse.\n\r",ch);
              return;
            }

	      num = number_range(1,count);

	      victim = char_list;
	      for( spin=1; spin <= num; spin++ )
	      {
	        if( spin == num )
		{
	      
                  if( victim && IS_NPC(victim) && victim->in_room
                      && !IS_SET(victim->in_room->room_flags, ROOM_SAFE)
                      && !IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)
                      && !IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)
                      && !victim->pIndexData->pShop
                      && (victim->level >= min)
                      && (victim->level <= max) )
                  { 
                    obj_to_char (obj_content,victim);                  
                  }
		  else
		  {
		    obj_to_obj(obj_content, obj);
		  }
                }
                victim = victim->next;
	      }
	  }
	}
      }
    }
    send_to_char ("The items are spread throughout the mud.\n\r",ch);
    act("$n explodes $p.\n\r",ch,obj,NULL,TO_ROOM,FALSE);
    return;
  }
}
}


void do_hostmask( CHAR_DATA *ch, char *argument )                              
 {                                                                              
     char arg1[MAX_INPUT_LENGTH];                                               
     char arg2[MAX_INPUT_LENGTH];                                               
     char arg3[MAX_INPUT_LENGTH];                                               
     char *argN;
     char *pArg;                                                                
     char cEnd;                                                                 
     CHAR_DATA *victim;
                                                                                
     if ( IS_NPC(ch) )                                                          
   return;                                                                      

     argN = str_dup(argument);
     /*                                                                         
      * Can't use one_argument here because it smashes case.                    
      * So we just steal all its code.  Bleagh.                                 
      */                                                                        
     pArg = arg1;                                                               
     while ( isspace(*argument) )                                               
   argument++;                                                                  
                                                                                
     cEnd = ' ';                                                                
     if ( *argument == '\'' || *argument == '"' )                               
   cEnd = *argument++;                                                          
                                                                                
     while ( *argument != '\0' )                                                
     {                                                                          
   if ( *argument == cEnd )                                                     
   {                                                                            
       argument++;                                                              
       break;                                                                   
   }          

   *pArg++ = *argument++;                                                       
     }                                                                          
     *pArg = '\0';                                                              
                                                                                
     pArg = arg2;                                                               
     while ( isspace(*argument) )                                               
   argument++;                                                                  
                                                                                
     cEnd = ' ';                                                                
     if ( *argument == '\'' || *argument == '"' )                               
   cEnd = *argument++;                                                          
                                                                                
     while ( *argument != '\0' )                                                
     {                                                                          
   if ( *argument == cEnd )                                                     
   {                                                                            
       argument++;                                                              
       break;                                                                   
   }                                                                            
   *pArg++ = *argument++;                                                       
     }                                                                          
     *pArg = '\0';                                                              
                                                                                
	argN = one_argument(argN,arg3);
	argN = one_argument(argN,arg3);
	one_argument(argN,arg3);

     if ( arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' )
     {                                                                          
   send_to_char( "Syntax: hostmask <password> <string> <character>.\n\r", ch );
   return;                                                                      
     }          
/* Removed by Guerrand                                                                                
     if ( strcmp( crypt( arg1, ch->pcdata->pwd ), ch->pcdata->pwd ) )           
     {                                                                          
   WAIT_STATE( ch, 40 );                                                        
   send_to_char( "Wrong password.  Wait 10 seconds.\n\r", ch );                 
   return;                                                                      
     }                
 */
                                                                                
     if ( strlen(arg2) > 45 )
     {                                                                          
   send_to_char(                                                                
       "Hostname must be less than fourty five characters long.\n\r", ch );
   return;
     }

     if( (victim = get_char_world( ch, arg3 )) == NULL)
     {
       send_to_char("They're not here.\n\r",ch);
       return;
     }

     if ( strcmp( crypt( arg1, victim->pcdata->pwd ), victim->pcdata->pwd ) )
     {
	WAIT_STATE( ch, 40 );
	send_to_char("Wrong password.  Wait 10 seconds.\n\r", ch);
	return;
     }

     strcpy(victim->pcdata->hostmask,arg2);
     victim->desc->host = str_dup(victim->pcdata->hostmask);
     send_to_char( "Ok.\n\r", ch );                                             
     return;                                                                    
 }


void do_rename ( CHAR_DATA* ch, char* argument )
{
	char old_name[MAX_INPUT_LENGTH]; 
	char new_name[MAX_INPUT_LENGTH];
	char strsave [MAX_INPUT_LENGTH];

	CHAR_DATA* victim;
	FILE* file;
	
	argument = one_argument_cs( argument, old_name );
	one_argument_cs( argument, new_name );
	
	if (!old_name[0])
	{
		send_to_char ("Rename who?\n\r",ch);
		return;
	}
		
	if ( ( victim = get_char_world (ch, old_name) ) == NULL || IS_NPC(victim) )
	{
		send_to_char ("There is no such person online.\n\r",ch);
		return;
	}
		
	if ( (victim != ch) && (get_trust (victim) >= get_trust (ch)) )
	{
		send_to_char ("You failed.\n\r",ch);
		return;
	}
	
	if (!victim->desc || (victim->desc->connected != CON_PLAYING) )
	{
		send_to_char ("Player has no active descriptor.\n\r",ch);
		return;
	}

	if (!new_name[0])
	{
		send_to_char ("Rename to what new name?\n\r",ch);
		return;
	}
	
	if (!check_parse_name(new_name))
	{
		send_to_char ("The new name is illegal.\n\r",ch);
		return;
	}

        sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( new_name ) );

	fclose (fpReserve);
	file = fopen (strsave, "r");
	if (file)
	{
		send_to_char ("A player with that name already exists!\n\r",ch);
		fclose (file);
         	fpReserve = fopen( NULL_FILE, "r" );
		return;         
	}

	fpReserve = fopen( NULL_FILE, "r" );  /* reopen the extra file */

	if (get_char_world(ch,new_name)) /* check for playing level-1 non-saved */
	{
		send_to_char ("A player with the name you specified already exists!\n\r",ch);
		return;
	}

	/* Save the filename of the old name */

        sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( victim->name ) );


	/* Rename the character and save him to a new file */
	/* NOTE: Players who are level 1 do NOT get saved under a new name */

	free_string (victim->name);
	new_name[0] = UPPER(new_name[0]);
	victim->name = str_dup (new_name);
	
	save_char_obj (victim);
	
	/* unlink the old file */
	unlink (strsave); /* unlink does return a value.. but we do not care */

	/* That's it! */
	
	send_to_char ("Character renamed.\n\r",ch);

	victim->position = POS_STANDING; /* I am laaazy */

	act("$n has renamed you to $N!",ch,NULL,victim,TO_VICT,FALSE);
	sprintf(strsave, "%s%s", GOD_DIR, capitalize(old_name));
	unlink (strsave); /*Nuke the god file if there is one*/
}

void do_no_dns( CHAR_DATA *ch, char *argument ) {
     char buf[MAX_STRING_LENGTH];
     extern bool no_dns;

     no_dns = !no_dns;

     sprintf(buf,"DNS toggled %s.\n\r",
	no_dns ? "{CON" : "{ROFF" );
     send_to_char(buf,ch);
     return;
}

void do_imm_loads(CHAR_DATA *ch, char *argument )
{
    /* char buf[MAX_STRING_LENGTH]; Unusued var? */
    OBJ_DATA *obj;
    OBJ_INDEX_DATA *pObjIndex;
    FILE *fp;
    char fname[20];
    int vnum;

    fclose(fpReserve);

    strcpy(fname,"immloads.lst"); 
    fp = fopen(fname,"w");

    for (vnum = 0; vnum < 33000; vnum++)
    {
       if ((pObjIndex = get_obj_index(vnum)) != NULL)
       {
          if ( ( obj = get_obj_world( ch, pObjIndex->name) ) == NULL )
          {
	     if (IS_SET(pObjIndex->extra_flags,ITEM_IMM_LOAD))
	     {
                fprintf( fp, "[%5d] %s\n\r",pObjIndex->vnum, 
                     pObjIndex->short_descr );
	     }
	  }
       }
    }
    fclose(fp);

    fclose(fpReserve);

    strcpy(fname,"nonimlds.lst"); 
    fp = fopen(fname,"w");

    for (vnum = 0; vnum < 33000; vnum++)
    {
       if ((pObjIndex = get_obj_index(vnum)) != NULL)
       {
          if ( ( obj = get_obj_world( ch, pObjIndex->name) ) == NULL )
          {
	     if (!IS_SET(pObjIndex->extra_flags,ITEM_IMM_LOAD))
	     {
                fprintf( fp, "[%5d] %s\n\r",pObjIndex->vnum, 
                     pObjIndex->short_descr );
	     }
	  }
       }
    }
    fclose(fp);
}

/*
void do_dark_items(CHAR_DATA *ch, char *argument )
{
}

void do_dark_items(CHAR_DATA *ch, char *argument )
{
    OBJ_INDEX_DATA *pObjIndex;
    FILE *fp;
    char fname[20];
    int vnum;

    fclose(fpReserve);

    strcpy(fname,"darkitem.lst"); 
    fp = fopen(fname,"w");

    for (vnum = 0; vnum < 33000; vnum++)
    {
       if ((pObjIndex = get_obj_index(vnum)) != NULL)
       {
          if (IS_SET(pObjIndex->extra_flags,ITEM_DARK))
          {
             fprintf( fp, "[%5d] %s\n\r",pObjIndex->vnum, 
                     pObjIndex->short_descr );
	  }
       }
    }
    fclose(fp);
}
*/
void do_skstat( CHAR_DATA *ch, char *argument )
{

   int col;
   char buf[MAX_STRING_LENGTH * 2];
   char buf2[MAX_STRING_LENGTH * 2];
   int sn;

   CHAR_DATA *victim;

   if ( (victim = get_char_world (ch, argument)) == NULL)
   {
       send_to_char("They aren't here\n\r", ch);
       return;
   }

   if (IS_NPC(victim))
   {
      send_to_char("Skstat is only usable on players\n\r", ch);
      return;
   }
   
   if (!IS_IMMORTAL(ch) && ch->pcdata->rank >= (MAX_RANK -1 ) &&  
       victim->clan == ch->clan)
   {
       sn = skill_lookup("steal");
       sprintf( buf, "%-18s %3d%%\n\r",skill_table[sn].name,
				victim->pcdata->learned[sn]);
       send_to_char(buf,ch);
       return;
   }
   else
   {
      if (!IS_IMMORTAL(ch))
      {
         send_to_char("That is not permitted.\n\r",ch);
         return;
      }
   }


   col    = 0;
   buf2[0] = '\0';

   for ( sn = 0; sn < MAX_SKILL; sn++ )
   {

   if ( skill_table[sn].name == NULL )
     break;
   if ( victim->level < skill_level(victim,sn)
   || victim->pcdata->learned[sn] < 1)
          continue;

  sprintf( buf, "%-18s %3d%%  ",skill_table[sn].name,
				victim->pcdata->learned[sn]);

  strcat(buf2, buf);

  if (++col%3 == 0)
   strcat(buf2, "\n\r");

   }

   if (col % 3 != 0)
     strcat(buf2, "\n\r");

   sprintf(buf, "They have %d practices left\n\r", victim->practice);
   strcat (buf2, buf);
   page_to_char(buf2, ch);
  
}


void do_olist( CHAR_DATA *ch, char *argument )
 {
   OBJ_DATA *obj;
   int iWear;
   CHAR_DATA *victim;


   if ( argument[0] == '\0')
      {
      send_to_char("Look at who's objects?\n\r", ch);
      return;
      }
    
   if ( ( victim = get_char_world(ch, argument)) == NULL)
    {
       send_to_char("They aren't here.\n\r", ch);
       return;
    }

    if ( victim == ch )
    {
      send_to_char("Quit being an idiot, just look at yourself instead.\n\r", ch);
      return;
    }

   send_to_char( "They are using:\n\r", ch );
   for ( iWear = 0; iWear < MAX_WEAR; iWear++ )
     {
     if ((obj = get_eq_char(victim, iWear)) == NULL)
        {
	 send_to_char(wear_name[iWear], ch);
	 send_to_char("- - -\n\r", ch);
	}
     else
	{
	send_to_char(wear_name[iWear], ch);
	send_to_char(format_obj_to_char(obj, ch, TRUE), ch);
	send_to_char("\n\r", ch);

	if (obj->item_type == ITEM_CONTAINER )
	  {
	   send_to_char("   containing:\n\r", ch);
	   show_list_to_char(obj->contains, ch, TRUE, TRUE, TRUE);
          }//end if
       }//end if
     }//end for
     
     send_to_char("\n\r\n\rThey are carrying:\n\r", ch);
     show_list_to_char(victim->carrying, ch, TRUE, TRUE, TRUE);
    
     return;
}//end func

void do_doublexp( CHAR_DATA *ch, char *argument )
{
 if (override)
  {
    override = FALSE;
    send_to_char("Double xp and bonuses have been turned OFF.\n\r", ch);
  }
  else
  {
   override = TRUE;
   send_to_char("Double xp and bonuses have been turned ON.\n\r", ch);
  }
 
  return;
}

void do_ftick(CHAR_DATA *ch , char *argument)
{

   send_to_char("You force a tick.", ch);
   update_handler();
}

@


1.417
log
@4/30/04 Nightdagger:  Fixed do_mstat so that deny and freeze doesn't show after every affect.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.416 2004/01/08 21:59:17 ndagger Exp $";
d1294 1
a1294 1
}	
d1375 3
a1377 4
/*no longer allowing matookers to guild*/
/*	  if (ch->pcdata->matookT < 12000) */
/*          if (!IS_IMMORTAL(ch)) */
          if (!IS_SET(ch->mhs, MHS_MATOOK_COUNCIL))
@


1.416
log
@01/08/04 Nightdagger:  Deny shows in mstat, changed directionals to log never
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.415 2004/01/05 22:12:45 ndagger Exp $";
a3410 2
  if (IS_SET(victim->act,PLR_FREEZE)) send_to_char("Player has been frozen.\n\r",ch);
  if (IS_SET(victim->act,PLR_DENY)) send_to_char("Player has been denied.\n\r",ch);
d3412 2
a3413 1

@


1.415
log
@01/05/04 Nightdagger:  added freeze status to do_mstat in act_wiz.c
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.414 2003/12/09 21:38:43 rusty Exp $";
d3412 1
@


1.414
log
@Argument for do_quit in punload to subvert pnet login
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.413 2003/11/26 04:20:56 boogums Exp $";
d3411 1
@


1.413
log
@loner bug fixed.  lonering wasn't setting the kill timer
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.412 2003/08/16 16:45:06 boogums Exp $";
d446 1
a446 1
  do_quit(victim,"");
@


1.412
log
@got rid of hte rest of the clan skills
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.411 2003/06/14 19:53:10 boogums Exp $";
d896 1
@


1.411
log
@adding the restrain spell to the infuse ability
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.410 2003/06/03 03:13:07 boogums Exp $";
d1332 1
a1332 1
            victim->pcdata->learned[skill_lookup("cure vision")] = 1;
d1345 1
a1345 1
            victim->pcdata->learned[skill_lookup("annointment")] = 1;
d1349 1
a1349 1
            victim->pcdata->learned[skill_lookup("honor guard")] = 1;
d1475 1
a1475 1
       victim->pcdata->learned[skill_lookup("cure vision")] = 1;
d1488 1
a1488 1
       victim->pcdata->learned[skill_lookup("annointment")] = 1;
d1497 1
a1497 1
       victim->pcdata->learned[skill_lookup("honor guard")] = 1;
@


1.410
log
@ok this'll yank confusion and aura of cthon
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.409 2003/06/03 02:57:27 boogums Exp $";
d1341 1
a1341 1
            victim->pcdata->learned[skill_lookup("cuffs of justice")] = 1;
d1501 1
a1501 1
       victim->pcdata->learned[skill_lookup("cuffs of justice")] = 1;
@


1.409
log
@taking confusion out of demises setup as well as aura of cthon
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.408 2003/04/25 06:57:14 ndagger Exp $";
d1335 1
a1335 1
	    victim->pcdata->learned[skill_lookup("confusion")] = ;
d1337 1
a1337 1
            victim->pcdata->learned[skill_lookup("aura of cthon")] = 1;
d1479 1
a1479 1
       victim->pcdata->learned[skill_lookup("confusion")] = 1;
d1483 1
a1483 1
       victim->pcdata->learned[skill_lookup("aura of cthon")] = 1;
@


1.408
log
@04/25/2003 Nightdagger:  added IS_NPC check to do_setcouncil.  I'm a moron.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.407 2003/04/25 06:41:47 ndagger Exp $";
d1333 3
a1335 2
	if (victim->clan == clan_lookup("demise"))
	    victim->pcdata->learned[skill_lookup("confusion")] = 1;
d1338 1
@


1.407
log
@04/25/2003 Nightdagger:  Matook Council MHS flag and related stuff.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.406 2003/04/24 03:13:41 boogums Exp $";
d1648 6
@


1.406
log
@t hmmm let's try this
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.405 2003/04/24 01:48:01 boogums Exp $";
d144 1
d1375 1
a1375 1
	  if (ch->pcdata->rank >=0 )
d1632 38
@


1.405
log
@putting in the matok guld stuff
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.404 2003/04/14 05:11:51 ndagger Exp $";
d1374 1
a1374 1
	  if (ch->pcdata->rank >= (MAX_RANK -1 ))
@


1.404
log
@04/13/03 Nightdagger:  yet more autoswitching stuff with the Almighty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.403 2003/04/14 04:56:55 ndagger Exp $";
d1373 2
a1374 1
          if (!IS_IMMORTAL(ch))
@


1.403
log
@04/13/03 Nightdagger:  more autoswitching stuff for the Almighty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.402 2003/04/14 04:50:56 ndagger Exp $";
d1431 1
a1431 1
      victim->pcdata->deity = deity_lookup("almighty");
d1483 1
d1485 2
d1488 1
d1490 2
@


1.402
log
@04/13/03 Nightdagger:  second part of clan system change:  handling autoswitching to/from the Almighty.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.401 2003/03/27 16:09:57 rusty Exp $";
d1429 1
d1431 2
@


1.401
log
@Added missing connect_table[] entries in do_sockets() for newer states
to stop do_socket() from causing crashes.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.400 2003/02/20 19:08:06 rusty Exp $";
d975 1
d977 2
d1020 4
a1023 1
	      ch->pcdata->learned[skill_lookup("annointment")] = 0;
d1341 4
a1344 1
	    victim->pcdata->learned[skill_lookup("annointment")] = 1;
@


1.400
log
@Misplaced } moved up a few lines in do_string()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.399 2003/02/20 19:01:53 rusty Exp $";
d6206 3
@


1.399
log
@str_cmp() to str_prefix() for surname in string command
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.398 2003/02/20 00:56:10 ndagger Exp $";
d5890 1
a5924 1
      }
@


1.398
log
@02/19/03 Nightdagger:  hardcoding for lv 58 set command added to do_set
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.397 2003/01/19 18:01:52 boogums Exp $";
d5891 1
a5891 1
    if (!str_cmp(arg2, "surname"))
@


1.397
log
@removed ability for morets to guild matook
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.396 2003/01/18 19:19:04 ndagger Exp $";
d5066 6
@


1.396
log
@1/18/03 Nightdagger:  Commented out the do_socke idiotproofing, since it's worthless in preventing socket related crashes anyway.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.395 2002/12/12 00:11:37 ndagger Exp $";
d1362 3
a1364 1
	  if (ch->pcdata->matookT < 12000)
@


1.395
log
@12/11/02 Nightdagger:  added do_socke, before sockets in interp.c, makes imms type out the full sockets command so we don't have the weird alias.c crash thing.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.394 2002/11/26 05:57:31 boogums Exp $";
d6160 1
d6165 1
@


1.394
log
@doh
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.393 2002/11/23 03:49:28 mud Exp $";
d6158 5
@


1.393
log
@s/NULL/0/ in format string
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.392 2002/11/23 03:42:17 rusty Exp $";
d3019 1
a3019 1
    sprintf(buf,"Clan: %s  Rank: %d  Host: %s Created: %s\n\r",
d3023 2
a3024 1
	strtime); 
@


1.392
log
@cleaned up do_socket()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.391 2002/11/15 02:26:51 boogums Exp $";
d6253 4
a6256 4
		d->descriptor?d->descriptor:"NULL",
		d->connected?connect_table[d->connected]:"NULL",
		d->host?d->host:"NULL",
		d->port?d->port:"NULL");
@


1.391
log
@adding the aura of cthon skill for demise
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.390 2002/11/02 10:34:30 ndagger Exp $";
d6161 1
a6161 1
    char buf[3 * MAX_STRING_LENGTH];
d6195 1
d6227 1
a6227 1
              sprintf( buf + strlen(buf), "[%2d] %-18s %s@@%s:%d\n\r",
d6233 1
d6246 3
a6248 1
                sprintf(buf+strlen(buf),"[%2d] Nobody yet\r\n",d->descriptor);
d6252 5
a6256 2
              sprintf(cdbuf, "NULL DESCRIPTOR: %2d NULL CONNECTED:%-18s NULL HOST:%s NULL PORT:%d",
              d->descriptor,connect_table[d->connected],d->host,d->port);
a6258 6
	    /*
            sprintf( buf+strlen(buf) ,"[%2d] %-18s nobody yet@@%s:%d\n\r",
                d->descriptor, connect_table[d->connected], d->host, d->port );
            
		sprintf(buf+strlen(buf),"Nobody yet\r\n");
	    */
d6266 1
a6266 1
            sprintf( buf + strlen(buf), "[%2d] %-18s %-15s %s:%d\n\r",
d6271 2
a6272 2
          d->host,d->port
          );
@


1.390
log
@11/01/02 Nightdagger: disabled highlander command.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.389 2002/10/26 15:55:50 boogums Exp $";
d970 2
d979 1
d1014 2
d1328 3
d1411 3
d1464 4
@


1.389
log
@testing socket change
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.388 2002/10/15 21:28:48 boogums Exp $";
d1165 4
@


1.388
log
@putting in some of NDs things it looks like and making a change
to the necromancer kit
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.387 2002/10/13 22:22:35 ndagger Exp $";
d6225 1
a6225 1
                sprintf(buf+strlen(buf),"Nobody yet\r\n");
@


1.387
log
@10/13/02 Nightdagger-  Another fix to ctalk, should work right this time *sigh*
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.386 2002/10/13 22:02:52 ndagger Exp $";
d57 1
@


1.386
log
@10/13/02 Nightdagger-  Fix to ctalk so it works right.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.385 2002/10/13 21:49:02 ndagger Exp $";
d94 1
a94 1
   char arg1[MAX_INPUT_LENGTH];
d99 2
a100 2

   if ( arg1[0] == '\0'  )
d138 1
a138 1
   do_clantalk(ch, argument);
@


1.385
log
@10/13/02 Nightdagger-  Added ctalk command for imms, can talk on clan channels without guilding self in/out now.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.384 2002/09/15 14:51:15 boogums Exp $";
d94 1
a94 1
   char arg1[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
a98 1
   argument=one_argument(argument, arg2);
d100 1
a100 1
   if ( arg1[0] == '\0' || arg2[0] == '\0' )
d138 1
a138 1
   do_clantalk(ch, arg2);
a139 1
    
@


1.384
log
@fixing the warnings
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.383 2002/09/15 14:39:04 boogums Exp $";
d91 53
@


1.383
log
@trying ot figure out why socket crashes us
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.382 2002/09/15 01:12:13 boogums Exp $";
d6177 2
a6178 2
              sprintf(cdbuf, "NULL DESCRIPTOR: %s NULL CONNECTED:%s NULL HOST:%s NULL PORT:%s",
              d->descriptor,d->connected,d->host,d->port);
@


1.382
log
@stalk bug squashed, nobody yet bug hopefully gone too
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.381 2002/09/14 18:22:03 boogums Exp $";
d6092 1
d6169 14
a6182 1
            /*sprintf( buf+strlen(buf) ,"[%2d] %-18s nobody yet@@%s:%d\n\r",
d6184 1
a6184 1
            */
d6186 1
@


1.381
log
@ i have no idea what i'm doing in the socket command
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.380 2002/06/20 15:55:00 rusty Exp $";
d6171 1
a6171 1
		sprintf(buf+strlen(buf),"Nobody yet");
@


1.380
log
@Some bug fixes from off the net.
new_note() used for loading the note spools.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.379 2002/06/14 20:14:27 rusty Exp $";
d6168 1
a6168 1
            sprintf( buf+strlen(buf) ,"[%2d] %-18s nobody yet@@%s:%d\n\r",
d6170 3
@


1.379
log
@string char surname added
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.378 2002/05/22 14:44:40 mud Exp $";
d2998 2
a2999 2
  IS_NPC(ch) ? 0 : victim->practice,
  IS_NPC(ch) ? 0 : victim->train );
d3847 4
a3850 1
        victim->prompt = str_dup(ch->prompt);
@


1.378
log
@Missing commas
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.377 2002/05/22 14:43:22 rusty Exp $";
d5729 1
a5729 1
  send_to_char("    fields: name short long desc title spec\n\r",ch);
d5806 32
@


1.377
log
@Added new stats to do_mstat()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.376 2002/04/11 03:17:37 boogums Exp $";
d2987 1
a2987 1
  get_curr_stat(victim,STAT_AGT)
d2989 1
a2989 1
  get_curr_stat(victim,STAT_END)
@


1.376
log
@adding posse skill cuffs of justice
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.375 2002/04/03 15:56:19 rusty Exp $";
d2975 1
a2975 1
    "Str: %d(%d)  Int: %d(%d)  Wis: %d(%d)  Dex: %d(%d)  Con: %d(%d)\n\r",
d2985 7
a2991 1
  get_curr_stat(victim,STAT_CON) );
@


1.375
log
@Took out IMM dropping link from Pnet
Took out IMM login/logout if invis or incog from Pnet
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.374 2002/04/01 21:05:43 rusty Exp $";
d918 2
d961 3
d1267 3
d1347 3
d1405 5
@


1.374
log
@Added pnet, wiznet like info for mortals
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.373 2002/03/09 19:14:27 rusty Exp $";
d618 1
a618 1
            act_new(string,d->character,obj,ch,TO_CHAR,POS_DEAD,FALSE);
@


1.373
log
@Hiding information and reup_affect() additions. Initial
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.372 2002/02/21 16:05:35 poquah Exp $";
d396 83
d583 34
@


1.372
log
@only CREATOR+ can see Recipes on Stat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.371 2002/01/20 21:37:14 rage Exp $";
d4991 4
a4994 4
  send_to_char( "    str int wis dex con sex class level sac\n\r",  ch );
  send_to_char( "    race group gold silver hp mana move prac align\n\r",ch);
  send_to_char( "    train thirst hunger drunk full surname bounty\n\r", ch );
  send_to_char( "    logins\n\r", ch );
d5221 45
@


1.371
log
@change to fitck, something broke in the compile
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.370 2002/01/20 21:33:18 rage Exp $";
d2737 1
a2737 1
    if (obj->item_type == ITEM_FORGE )
@


1.370
log
@added OLC only command "ftick" to force ticks
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.369 2001/12/15 02:43:34 poquah Exp $";
a56 1
DECLARE_DO_FUN(do_ftick);
@


1.369
log
@act_wiz - remove unused buf
magic - working on quicken
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.368 2001/12/14 23:04:16 poquah Exp $";
d57 1
a57 1

d6863 8
@


1.368
log
@remove debug messages
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.367 2001/12/14 20:54:40 poquah Exp $";
a1286 1
    char buf[MAX_STRING_LENGTH];
@


1.367
log
@declare buf in outfit
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.366 2001/12/14 20:09:36 poquah Exp $";
a1303 2
       sprintf (buf,"SMURF: %s before carry",ch->name);
       log_string(buf); 
a1309 2
       sprintf (buf,"SMURF: %s before light",ch->name);
       log_string(buf); 
a1317 2
       sprintf (buf,"SMURF: %s before body",ch->name);
       log_string(buf); 
a1326 2
       sprintf (buf,"SMURF: %s before weapon",ch->name);
       log_string(buf); 
a1346 2
       sprintf (buf,"SMURF: %s before shield",ch->name);
       log_string(buf); 
a1355 2
       sprintf (buf,"SMURF: %s done",ch->name);
       log_string(buf); 
@


1.366
log
@debugging outfit for smurfs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.365 2001/12/13 17:34:39 poquah Exp $";
d1287 1
@


1.365
log
@smurfs cant outcast
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.364 2001/12/05 21:48:53 poquah Exp $";
d1303 2
d1311 2
d1321 2
d1332 2
d1354 2
d1365 2
@


1.364
log
@add logins to set so you can reset logins for storage checks
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.363 2001/12/05 21:45:31 poquah Exp $";
d768 6
@


1.363
log
@*** empty log message ***
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.362 2001/12/05 17:07:04 poquah Exp $";
d4989 1
d5043 1
a5043 1
    if (!str_cmp(arg2, "loginclear"))
d5050 8
a5057 3
	victim->pcdata->logins_without_combat = 0;
	victim->pcdata->logins_without_death = 0;
	victim->pcdata->logins_without_kill = 0; 
@


1.362
log
@move gladiator_data and highlander_data to pcdata
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.361 2001/12/05 16:42:53 poquah Exp $";
d5040 15
@


1.361
log
@fix killer_Data to pcdata
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.360 2001/12/05 16:39:01 poquah Exp $";
d1029 2
a1030 2
	 victim->highlander_data[ALL_KILLS] = 0;
	 victim->highlander_data[REAL_KILLS] = 0;
d1038 2
a1039 2
	   victim->highlander_data[ALL_KILLS], 
	   victim->highlander_data[REAL_KILLS]); 
d1057 2
a1058 2
	   victim->highlander_data[ALL_KILLS], 
	   victim->highlander_data[REAL_KILLS]); 
d1061 8
a1068 8
   victim->pcdata->perm_hit -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->pcdata->perm_mana -= (victim->highlander_data[ALL_KILLS]) * 100; 
   victim->pcdata->perm_move -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_hit -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_mana -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_move -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->highlander_data[ALL_KILLS] = 0;
   victim->highlander_data[REAL_KILLS] = 0;
d1078 2
a1079 2
	   victim->highlander_data[ALL_KILLS], 
	   victim->highlander_data[REAL_KILLS]); 
d2912 2
a2913 2
	       victim->highlander_data[ALL_KILLS],
	       victim->highlander_data[REAL_KILLS]);
d2919 6
a2924 6
	       victim->gladiator_data[GLADIATOR_PLAYS],
	       victim->gladiator_data[GLADIATOR_VICTORIES],
	       victim->gladiator_data[GLADIATOR_KILLS],
	       victim->gladiator_data[GLADIATOR_TEAM_PLAYS],
	       victim->gladiator_data[GLADIATOR_TEAM_VICTORIES], 
	       victim->gladiator_data[GLADIATOR_TEAM_KILLS]);
@


1.360
log
@new kr stats
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.359 2001/12/03 18:46:10 poquah Exp $";
d2895 1
a2895 1
sprintf( buf, "Kills: Lw: %d Eq: %d Gr: %d Deaths: %d Stolen: (%ld/%ld/%ld) Slices: %ld\n\r",
d2899 2
a2900 1
       victim->killer_data[PC_DEATHS], victim->pcdata->steal_data[PC_STOLEN_ITEMS],
@


1.359
log
@missing "
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.355 2001/11/25 02:35:08 rusty Exp $";
d2895 7
a2901 5
sprintf( buf, "Attempts: %d Kills: %d Deaths: %d Stolen: (%ld/%ld/%ld) Slices: %ld\n\r",
       victim->killer_data[PC_ATTACKS] /2, victim->killer_data[PC_KILLS],  
       victim->killer_data[PC_DEATHS], victim->steal_data[PC_STOLEN_ITEMS],
       victim->steal_data[PC_STOLEN_GOLD], 
       victim->steal_data[PC_STOLEN_SILVER],victim->steal_data[PC_SLICES]); 
d3081 3
a3083 3
      sprintf( buf,"Login Information:\n\r
                    Combats Since: %d Without Combats: %d Without Kill: %d Without Death: %d\n\r
                    Last Combat Date: %s\n\r",
@


1.358
log
@fixing syntax errors
:wq
:
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.357 2001/12/03 18:34:53 poquah Exp $";
d3081 1
a3081 1
                    Last Combat Date: %s\n\r
@


1.357
log
@add some code to look for storage chars
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.356 2001/12/03 15:11:23 poquah Exp $";
a3081 2
                    Last Kill Date %s\n\r
                    Last Death Date: %s\n\r",
d3090 1
a3090 1
      sprintf( buf, Last Kill Date: %s\n\r", strtime); 
d3094 1
a3094 1
      sprintf( buf, Last Death Date: %s\n\r", strtime); 
@


1.356
log
@fix die command, add back in last_death_timer
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.355 2001/11/25 02:35:08 rusty Exp $";
d3076 21
@


1.355
log
@Zap bug with disconnecting a socket with no d->character
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.354 2001/11/25 01:26:37 rusty Exp $";
d3070 1
a3070 1
      sprintf( buf, "Fighting: %s  Last Attacked By: %s  LAB Timer: %d  Trumps: %d\n\r",
d3074 1
@


1.354
log
@Webpage crash/bug fixes applied
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.353 2001/10/17 03:02:46 boogums Exp $";
d1717 1
a1717 1
               if (d->character->level >= ch->level)
@


1.353
log
@adding in the honor guard honor clan spell
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.352 2001/10/05 15:56:50 rage Exp $";
d5898 5
@


1.352
log
@fixed bug in outcast confirm
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.351 2001/10/05 15:48:57 rage Exp $";
d798 3
d837 3
d1142 3
d1219 3
d1268 5
@


1.351
log
@Added confirmation to player outcasting themselves...not there for leaders outcasting players
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.350 2001/09/04 18:34:35 rusty Exp $";
d773 6
@


1.350
log
@Added ability to 'set' bounty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.349 2001/07/26 00:50:00 poquah Exp $";
d814 2
a815 2
	    send_to_char("Attempt to Outcast failed.\n\r",ch);
	    return;
d819 1
a819 1
    if(argument[0] == '\0' && is_clan(ch) && !clan_table[ch->clan].independent)
d847 17
@


1.349
log
@fix the override bug in double exp, I hope
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.348 2001/07/25 18:27:44 rage Exp $";
d4924 2
a4925 2
  send_to_char( "    race group gold silver hp mana move prac\n\r",ch);
  send_to_char( "    align train thirst hunger drunk full surname\n\r", ch );
d4977 19
@


1.348
log
@fixed bug in double xp
more changes to spec_king functionality
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.347 2001/07/12 00:14:26 rage Exp $";
a114 3
    bool override = FALSE ;
    /* Swap out this line for double exp day */
    /* bool override = TRUE ; */
a4220 2
    /* Swap out this line for double exp day */
    /* bool override = TRUE ; */
@


1.347
log
@changes to wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.346 2001/07/10 23:39:13 rage Exp $";
a4223 1
    bool override = FALSE ;
@


1.346
log
@fixed some display stuff in ostat to list recipes better
added a bit more stuff to spec_king
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.345 2001/07/09 22:01:24 rusty Exp $";
d2733 1
@


1.345
log
@added MOB lAb to do_mstat()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.344 2001/07/02 21:36:08 rage Exp $";
d2715 1
a2715 1
	  sprintf(buf, "Recipe vnum %d:  ", recipe->recipe_num);
@


1.344
log
@initial attempt ant elemtal king special
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.343 2001/06/26 03:46:48 guerrand Exp $";
d3018 1
a3018 1
    sprintf( buf, "Master: %s  Leader: %s  Pet: %s\n\r",
d3021 2
a3022 1
  victim->pet       ? victim->pet->name      : "(none)");
@


1.343
log
@Added some code to fix potential crash problems with forge stating.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.342 2001/06/25 22:09:19 mud Exp $";
d2734 1
@


1.342
log
@spec_words typo fix
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.341 2001/06/25 22:07:33 rusty Exp $";
d2706 1
a2710 2
	  else
		break;
d2712 4
a2715 1
	  sprintf(buf, "Recipe: %d", recipe->recipe_num);
d2717 1
d2720 2
a2721 1
		if ( recipe->vnum_parts[j] == 0 ) break;
d2724 7
a2730 2
		sprintf(buf, "%s\n\r", t_obj->short_descr );
		strcat(buf2, buf);
d2732 1
a2732 1
	  send_to_char(buf2, ch);
@


1.341
log
@added spec_words to OLC menus and do_mstat()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.340 2001/06/23 20:58:51 rage Exp $";
d3037 2
a3038 2
    spec_name(victim->spec_fun),victim->spec_words[0],victim->spec_words[1],
    victim->spec_words[2]);
@


1.340
log
@ added to ostat to show recipes when statting forges
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.339 2001/06/10 03:53:09 guerrand Exp $";
a2962 2
    else
      send_to_char("\n\r",ch);
d3036 3
a3038 2
  sprintf(buf,"Mobile has special procedure %s.\n\r",
    spec_name(victim->spec_fun));
@


1.339
log
@OK!  Should be the last surname change.
Surnames report correctly in stat, and show correctly for mortals.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.338 2001/06/10 03:45:58 guerrand Exp $";
d2695 31
@


1.338
log
@Added sanity checking for surname lengths in act_wiz.c
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.337 2001/06/09 19:34:45 guerrand Exp $";
d2724 1
a2724 1
  victim->name, !IS_NPC(victim) ? ch->pcdata->surname : "(Mob)" );
@


1.337
log
@GMAN
Some more bug cleanup work.  Trying to eliminate the problem with getting
battle prompts when DOT'd.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.336 2001/06/09 17:42:40 guerrand Exp $";
d4917 6
@


1.336
log
@GMAN
Adde surnames, saving/reading functionality, ability for IMMs to set them, and
they show up in score only right noGMAN
Adde surnames, saving/reading functionality, ability for IMMs to set them, and
they show up in score only right noww
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.335 2001/06/03 22:44:22 guerrand Exp $";
d2723 2
a2724 2
    sprintf( buf, "Name: %s\n\r",
  victim->name);
@


1.335
log
@still working on it - GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.334 2001/05/27 19:56:04 rusty Exp $";
d4889 1
a4889 1
  send_to_char( "    align train thirst hunger drunk full\n\r", ch );
d4910 26
@


1.334
log
@Added Zealot clan skill "annointment"
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.333 2001/05/26 18:53:08 boogums Exp $";
d2349 1
a2349 1
    "Door: %d.  To: %d.  Key: %d.  Exit flags: %ld.\n\rKeyword: '%s'.\n\r",
d2354 1
a2354 1
        pexit->exit_info,
@


1.333
log
@turning off double xp day
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.332 2001/05/26 03:10:26 rage Exp $";
d793 2
d829 2
d1114 2
d1188 2
d1232 4
@


1.332
log
@missed a change to a global, silly me..3 commits for a 5 line change *sigh*
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.331 2001/05/26 03:00:35 rage Exp $";
d115 1
d4170 1
a4170 1
    bool override = TRUE ;
@


1.331
log
@ made further changes to double xp code
-Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.330 2001/05/26 00:33:57 rage Exp $";
d59 1
@


1.330
log
@added in IMM command to turn double xp on and off.
added global var "override" to do so.
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.329 2001/05/25 17:33:11 poquah Exp $";
a113 1
    bool override = TRUE;
a208 3
    bool override = FALSE ;
    /* Swap out this line for double exp day */
    /* bool override = TRUE ; */
@


1.329
log
@double exp day on
-poqq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.328 2001/05/20 21:25:43 rusty Exp $";
d6656 15
@


1.328
log
@No more looting while wraithed
Squashed necro bonus casting levels bug.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.327 2001/05/14 15:08:32 rusty Exp $";
d114 1
a114 1
    bool override = FALSE ;
d4172 1
a4172 1
    bool override = FALSE ;
@


1.327
log
@Pulling update from game machine
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.328 2001/04/26 19:24:41 mud Exp $";
a62 1
int	compute_casting_level args( ( CHAR_DATA *ch ) );
d2876 1
a2876 1
      compute_casting_level(victim) );
@


1.326
log
@Applied rom 2.4 b5 and b6 patches as necessary.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.325 2001/03/27 17:38:21 mud Exp $";
d115 3
a117 1
    bool override = FALSE ; 
d211 3
a213 1
    bool override = FALSE;
d4173 3
a4175 1
    bool override = FALSE;
@


1.325
log
@goto changes
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.324 2001/03/26 17:20:07 mud Exp $";
d4014 1
d4048 1
a4048 1
    if ( ( level = atoi( arg2 ) ) < 1 || level > 60 )
d4050 3
a4052 2
  send_to_char( "Level must be 1 to 60.\n\r", ch );
  return;
d4125 1
d4144 1
a4144 1
    if ( ( level = atoi( arg2 ) ) < 0 || level > 60 )
d4146 3
a4148 2
  send_to_char( "Level must be 0 (reset) or 1 to 60.\n\r", ch );
  return;
d5008 1
a5008 1
    "Dexterity ranges is 3 to %d.\n\r",
d5127 1
a5127 1
  if ( value < 0 || value > 60 )
d5129 3
a5131 2
      send_to_char( "Level range is 0 to 60.\n\r", ch );
      return;
@


1.324
log
@Turning off double EXP day
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.323 2001/03/25 15:16:50 mud Exp $";
d2084 1
d2086 2
a2087 1
      else
d2089 1
d2102 1
d2104 2
a2105 1
            else
d2107 1
@


1.323
log
@Turning on double EXP day
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.322 2001/02/27 18:53:21 mud Exp $";
d115 1
a115 1
    bool override = TRUE ; 
d209 1
a209 1
    bool override = TRUE;
d4159 1
a4159 1
    bool override = TRUE;
@


1.322
log
@remove double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.321 2001/02/26 07:10:58 mud Exp $";
d115 1
a115 1
    bool override = FALSE ; 
d209 1
a209 1
    bool override = FALSE;
d4159 1
a4159 1
    bool override = FALSE;
@


1.321
log
@double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.320 2001/02/10 03:42:41 mud Exp $";
d115 1
a115 1
    bool override = TRUE ; 
d209 1
a209 1
    bool override = TRUE;
d4159 1
a4159 1
    bool override = TRUE;
@


1.320
log
@Fix wiznet TICK formatting as well as artificial GREEN input
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.319 2001/01/26 15:16:41 mud Exp $";
d115 1
a115 1
    bool override = FALSE; 
d209 1
a209 1
    bool override = FALSE;
d4159 1
a4159 1
    bool override = FALSE;
@


1.319
log
@removed double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.318 2001/01/25 18:09:30 mud Exp $";
d502 1
a502 4
	if(IS_SET(d->character->display,DISP_COLOR))
	  send_to_char(GREEN"--> "NORMAL,d->character);
	else
	  send_to_char("--> ",d->character);
@


1.318
log
@override=TRUE for double exp day
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.317 2001/01/08 23:16:01 mud Exp $";
d115 1
a115 1
    bool override = TRUE; 
d209 1
a209 1
    bool override = TRUE;
d4162 1
a4162 1
    bool override = TRUE;
@


1.317
log
@Can only switch deities every 1 RL hour of play.
Fixed bug with not getting gifts after 1 hour of play.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.316 2000/12/27 04:27:40 mud Exp $";
d115 1
a115 1
    bool override = FALSE; 
d209 1
a209 1
    bool override = FALSE;
d4162 1
a4162 1
    bool override = FALSE;
@


1.316
log
@double exp off
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.315 2000/12/25 11:08:24 mud Exp $";
d2849 2
a2850 1
	(int) ((victim->played - victim->pcdata->switched)/3600),
@


1.315
log
@-Double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.314 2000/12/24 10:05:55 mud Exp $";
d115 1
a115 1
    bool override = TRUE; 
d209 1
a209 1
    bool override = TRUE;
d4161 1
a4161 1
    bool override = TRUE;
@


1.314
log
@send outcasts to temple of Matook instead of recall
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.313 2000/12/14 22:43:43 mud Exp $";
d115 1
a115 1
    bool override = FALSE; 
d209 1
a209 1
    bool override = FALSE;
d4161 1
a4161 1
    bool override = FALSE;
@


1.313
log
@Outcasting yourself removes CLAN_ALLOW_SANC too...
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.312 2000/12/14 22:41:14 mud Exp $";
d807 1
a807 1
		  char_to_room(victim,get_room_index(ROOM_VNUM_TEMPLE));
d841 1
a841 1
                  char_to_room(ch,get_room_index(ROOM_VNUM_TEMPLE));
@


1.312
log
@Remove CLAN_ALLOW_SANC from those being outcast.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.311 2000/12/14 22:36:25 mud Exp $";
d833 6
a838 2
            if(ch->in_room->clan != NULL 
                && !clan_table[ch->in_room->clan].independent)
@


1.311
log
@If someone is ranked down below 4 check and remove
their CLAN_ALLOW flag.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.310 2000/11/27 00:01:32 mud Exp $";
d799 4
@


1.310
log
@remove double exp
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.309 2000/11/24 23:23:14 mud Exp $";
d658 5
@


1.309
log
@double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.308 2000/10/26 12:22:46 mud Exp $";
d115 1
a115 1
    bool override = TRUE; 
d209 1
a209 1
    bool override = TRUE;
d4148 1
a4148 1
    bool override = TRUE;
@


1.308
log
@ removal of double xp

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.307 2000/10/25 13:06:21 mud Exp $";
d115 1
a115 1
    bool override = FALSE; 
d209 1
a209 1
    bool override = FALSE;
d4148 1
a4148 1
    bool override = FALSE;
@


1.307
log
@ missed turning on one override for double xp
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.306 2000/10/25 12:42:06 mud Exp $";
d115 1
a115 1
    bool override = TRUE; 
d209 1
a209 1
    bool override = TRUE;
d1078 1
a1078 1
        (!is_clan(victim) && victim->level <= 24 && victim->level >= 5
d4148 1
a4148 1
    bool override = TRUE;
@


1.306
log
@ adding double xp day code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.305 2000/10/16 23:09:30 mud Exp $";
d4148 1
a4148 1
    bool override = FALSE;
@


1.305
log
@last attack by timer
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.304 2000/10/16 20:18:43 mud Exp $";
d115 1
a115 1
    bool override = FALSE; 
d209 1
a209 1
    bool override = FALSE;
@


1.304
log
@Moving \n\r into format line after Long desc: ? if
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.303 2000/10/08 20:48:33 mud Exp $";
d2962 1
a2962 1
      sprintf( buf, "Fighting: %s  Last Attacked By: %s  Trumps: %d\n\r",
d2965 1
@


1.303
log
@Make sure a MOB is in a room before checking
the room properties in do_explode()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.302 2000/09/27 14:32:40 mud Exp $";
d2969 1
a2969 1
    sprintf( buf, "Short description: %s\n\rLong  description: %s",
d2971 1
a2971 1
  victim->long_descr[0] != '\0' ? victim->long_descr : "(none)\n\r" );
@


1.302
log
@I think I got explode working with a while() checking if the
container is empty yet.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.301 2000/09/27 14:24:41 mud Exp $";
d6180 1
a6180 1
                  if( victim && IS_NPC(victim)
@


1.301
log
@Made explode actually work, still need to adjust for missed items
as they current end up back in the bag.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.300 2000/09/26 20:27:41 mud Exp $";
d6153 2
d6198 1
@


1.300
log
@Changed how MOBs are randomly grabbed for an explode.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.299 2000/09/26 07:00:14 mud Exp $";
d6073 1
a6073 1
 void do_explode ( CHAR_DATA *ch, char *argument )
d6079 1
a6079 2
  MOB_INDEX_DATA *pMobIndex;
  int min,max,count,num,retry;
d6083 17
a6099 6
  if ( arg[0] != '\0' ) {    
    if (!strcmp (arg,"room")) {
      victim = ch->in_room->people;
      while (victim) {        
        next_vict = victim->next_in_room;
        if ( IS_NPC(victim) ) {          
d6105 3
a6107 2
          act( "$n slowly fades into existence.", victim, NULL, NULL, TO_ROOM ,FALSE);              
        }
d6109 3
a6111 3
      }        
      return;
    }
d6113 58
a6170 42
    obj = get_obj_list ( ch, arg, ch->carrying );
    if (obj == NULL) {
      send_to_char ("Item not found.\n\r",ch);
      return;
    }
    if (obj->item_type != ITEM_CONTAINER) {
      send_to_char ("That object is not a container.\n\r",ch);
      return;
    }
    argument = one_argument( argument, arg );
    if ( arg[0] != '\0' && is_number (arg)) {
      min = atoi (arg);         
      argument = one_argument( argument, arg );  
      if ( arg[0] != '\0' && is_number (arg)) {
        max = atoi (arg);
        if (max < min) {
          int temp;
          temp = min;
          min = max;
          max = temp;        
        }
        if ((min > 60) || (min < 1) || (max > 60) || (max < 1)) {
          send_to_char ("Max and min must be within 0 to 60.\n\r",ch);
          return;
        }
        if ((max - min) < 5) {
          send_to_char ("Max and min must differ by at least 5.\n\r",ch);
          return;
        }
        for ( obj_content = obj->contains; obj_content; obj_content = obj_next )
        {
          obj_next = obj_content->next_content;
          if (obj_content) {
            obj_from_obj ( obj_content );      
            victim = NULL;
            retry = 0;
            while (!victim) {
              retry++;
              if (retry > 30000) {
                send_to_char ("Min and max levels are too terse.\n\r",ch);
                return;
              }
d6172 2
a6173 2
	      pMobIndex = get_mob_index( number_range( 1, 65535 ) );
	      if ( pMobIndex != NULL )
d6175 1
a6175 1
		for( victim = char_list; victim; victim = victim->next )
a6176 16
		  if(victim->vnum == pMobIndex->vnum)
		    count++;
		}

	      if( count )
	      {
		num = number_range(1,count);

	        count = 0;
	        for( victim = char_list; victim; victim = victim->next )
	        {
	      	  if( victim->vnum == pMobIndex->vnum )
		    count++;
		  if( count == num )
		    break;
	        }
d6178 19
a6196 18
                if (victim && IS_NPC (victim)
                  && !IS_SET(victim->in_room->room_flags, ROOM_SAFE)
                  && !IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)
                  && !IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)
                  && !victim->pIndexData->pShop
                  && (victim->level >= min)
                  && (victim->level <= max) ) {
                  obj_to_char (obj_content,victim);                  
                } else {
                victim = NULL;
              }        
            }      
          }
        }
        send_to_char ("The items are spread throughout the mud.\n\r",ch);
        act("$n explodes $p.\n\r",ch,obj,NULL,TO_ROOM,FALSE);
        return;
      }      
d6198 3
d6202 1
a6202 5
  
  send_to_char ("Syntax:\n\r",ch);
  send_to_char ("  explode room\n\r",ch);
  send_to_char ("  explode <name of container> <mob_min_level> <mob_max_level>\n\r",ch);
  return;
@


1.299
log
@remove double exp
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.298 2000/09/24 21:27:37 mud Exp $";
d6079 1
a6116 4
        victim = char_list;
        for ( count = -1; victim != NULL; count++ ) {
          victim = victim->next;
        }
d6144 24
a6167 6
              num = number_range (0,count);
              victim = char_list;
              for ( count = 0; (count < num) && victim; count++ ) {
                victim = victim->next;
              }
              if (victim && IS_NPC (victim)
d6175 1
a6175 1
              } else {
@


1.298
log
@double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.297 2000/08/26 18:38:10 mud Exp $";
d115 1
a115 1
    bool override = TRUE; 
d209 1
a209 1
    bool override = TRUE;
d4147 1
a4147 1
    bool override = TRUE;
@


1.297
log
@remove double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.296 2000/08/25 16:55:42 mud Exp $";
d115 1
a115 1
    bool override = FALSE; 
d209 1
a209 1
    bool override = FALSE;
d4147 1
a4147 1
    bool override = FALSE;
@


1.296
log
@ bug fix in prev_owner
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.295 2000/08/25 16:47:04 mud Exp $";
d115 1
a115 1
    bool override = TRUE; 
d209 1
a209 1
    bool override = TRUE;
@


1.295
log
@ first attempt to add obbj->prev_owner to display who last owned an obj
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.294 2000/08/24 19:26:18 mud Exp $";
d2412 1
a2412 1
    sprintf(buf, "Last owned by: %s", obj->prev_owner == NULL ?
@


1.294
log
@ turn on override vars
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.293 2000/08/23 14:06:54 mud Exp $";
d2412 4
@


1.293
log
@ another addition to olist, expand containers
 :
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.292 2000/08/23 13:47:43 mud Exp $";
d115 1
a115 1
    bool override = FALSE; 
d209 1
a209 1
    bool override = FALSE;
@


1.292
log
@ another bug fix in olist
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.291 2000/08/23 13:38:04 mud Exp $";
a67 2
void    show_list_to_char       args( ( OBJ_DATA *list, CHAR_DATA *ch,
             bool fShort, bool fShowNothing ) );
d6584 1
a6584 1
	   show_list_to_char(obj->contains, ch, TRUE, TRUE);
d6590 1
a6590 1
     show_list_to_char(victim->carrying, ch, TRUE, TRUE);
@


1.291
log
@ fixed little bug in olist with multiple declaration of aconstants
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.289 2000/08/20 00:37:53 mud Exp $";
d6579 1
@


1.290
log
@ another attempt to add in olist, also some general clean up
 -Rage
@
text
@d71 23
d6574 1
a6574 1
	 send_to_char(where_name[iWear], ch);
@


1.289
log
@remove quit time on gladiator removal so they can quit with attack worries
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.288 2000/08/20 00:11:24 mud Exp $";
d66 5
d2863 1
a2863 1
    sprintf(buf, "MHS: %s",mhs_bit_name(victim->mhs));
d6523 1
a6523 1
   OBJ_DATA *obj, *s_obj, *t_obj, *m_obj, *n_obj;
a6524 1
   bool found;
a6525 2
   char buf[MAX_STRING_LENGTH * 5];
   char buf2[MAX_STRING_LENGTH];
a6526 2
   send_to_char("This command doesn't work yet.\n\r", ch);
   return;
a6546 1
   found = FALSE;
d6549 1
a6549 1
     if ((obj = get_eq_char(victim, iWear)) != NULL);
d6551 13
a6563 13
         found = TRUE; 
         sprintf(buf2, "[%5d] %s\n\r", obj->pIndexData->vnum, obj->short_descr);
	 strcat(buf, buf2);
         if (obj->item_type == ITEM_CONTAINER)
	 {
	  strcat(buf, "containing:\n\r");
          for(t_obj = obj->contains; t_obj != NULL; t_obj = n_obj)
          {
	     n_obj = t_obj->next_content;
             sprintf(buf2, "    [%5d] %s\n\r", t_obj->pIndexData->vnum, t_obj->short_descr);
    	     strcat(buf, buf2);
          }//end for
         }//end if
d6567 3
a6570 25

     strcat(buf, "\n\rThey are carrying:\n\r");
     for (t_obj = victim->carrying; t_obj != NULL; t_obj = n_obj)
	  {
            found = TRUE;
	    n_obj = t_obj->next_content;
	    sprintf(buf2, "[%5d] %s\n\r", t_obj->pIndexData->vnum, t_obj->short_descr);
            strcat(buf, buf2);
            if (t_obj->item_type == ITEM_CONTAINER)
	       {
		strcat(buf, "containing\n\r");
	        for(s_obj = obj->contains; s_obj != NULL; s_obj = m_obj)
                 {
                  m_obj = s_obj->next_content;
		  sprintf(buf2, "    [%5d] %s\n\r", t_obj->pIndexData->vnum, t_obj->short_descr);
		  strcat(buf, buf2); 
	         }
	       }
           }

          if (!found)
	   send_to_char("Nothing\n\r", ch);
	  else
	   page_to_char(buf, ch);

@


1.288
log
@highlander bugs and loggins some highlander stuff
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.287 2000/08/19 23:22:08 mud Exp $";
d1004 1
@


1.287
log
@track down crash bug in highlander
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.286 2000/08/19 23:03:24 mud Exp $";
d65 1
d917 1
d941 1
a941 12
   /* Remove Stats for Victims ALL_KILLS */
   victim->pcdata->perm_hit -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->pcdata->perm_mana -= (victim->highlander_data[ALL_KILLS]) * 100; 
   victim->pcdata->perm_move -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_hit -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_mana -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_move -= (victim->highlander_data[ALL_KILLS]) * 100;
	 victim->highlander_data[ALL_KILLS] = 0;
	 victim->highlander_data[REAL_KILLS] = 0;
         victim->clan = victim->pcdata->save_clan;
         victim->pcdata->save_clan = 0;
	 REMOVE_BIT(victim->mhs,MHS_HIGHLANDER);
d949 1
a949 13

   /* Remove Stats for Victims ALL_KILLS */
   victim->pcdata->perm_hit -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->pcdata->perm_mana -= (victim->highlander_data[ALL_KILLS]) * 100; 
   victim->pcdata->perm_move -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_hit -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_mana -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_move -= (victim->highlander_data[ALL_KILLS]) * 100;
	 victim->highlander_data[ALL_KILLS] = 0;
	 victim->highlander_data[REAL_KILLS] = 0;
         victim->clan = victim->pcdata->save_clan;
         victim->pcdata->save_clan = 0;
	 REMOVE_BIT(victim->mhs,MHS_HIGHLANDER);
d962 2
d967 7
d977 36
@


1.286
log
@fix highlander bugs
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.285 2000/08/19 22:38:56 mud Exp $";
d983 1
a983 1
	 victim->pcdata->save_clan = ch->clan;
@


1.285
log
@highlanders get transd to Matook
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.284 2000/08/19 19:48:50 mud Exp $";
d984 2
a985 2
         if(!is_clan(ch))
	    ch->clan = clan_lookup("temp");
@


1.284
log
@Can't guild NPCs crash bug fix - boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.283 2000/08/18 23:52:33 mud Exp $";
d978 3
@


1.283
log
@highlanders use temp clan, kr only shows highlandder info and fix levle limits
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.282 2000/08/18 22:49:01 mud Exp $";
d1018 5
a1022 1
   
@


1.282
log
@Highlanders Abound
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.281 2000/08/18 21:33:58 mud Exp $";
d948 2
d968 2
d980 3
@


1.281
log
@put highlander back in
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.280 2000/08/17 17:18:00 mud Exp $";
d939 7
d957 7
d975 1
@


1.280
log
@ added in sanction allow to allow clan leader to grant ability to /4's
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.279 2000/08/16 15:32:27 mud Exp $";
a935 12
      if (ch->level < 59)
      {
	 send_to_char( "Sorry setting Pfresh Bit is for Admins only.\n\r",ch);
	 return;
      }

      if (IS_SET(victim->mhs,MHS_PREFRESHED))
	 REMOVE_BIT(victim->mhs,MHS_PREFRESHED);
      else
	 SET_BIT(victim->mhs,MHS_PREFRESHED);
      /*

a962 1
     */ 
@


1.279
log
@ taking out olist command again
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.278 2000/08/16 15:26:20 mud Exp $";
d2819 7
@


1.278
log
@ attempting to fix olist command
 fixed crash bug in with zealots being attacked by mobs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.277 2000/08/16 01:33:38 mud Exp $";
d6477 2
d6480 6
@


1.277
log
@allow leaders to see steal %
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.276 2000/08/16 01:32:10 mud Exp $";
d6474 1
a6474 1
   char buf[MAX_STRING_LENGTH * 2];
a6477 2
  send_to_char ("This command doesn't work yet.\n\r", ch);
  return;
d6484 6
d6511 2
@


1.276
log
@*** empty log message ***
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.275 2000/08/09 21:33:47 mud Exp $";
d6419 1
d6425 1
@


1.275
log
@working on date created
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.274 2000/08/09 21:30:27 mud Exp $";
d6416 17
@


1.274
log
@try setting last byte in strtime to \0
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.273 2000/08/09 21:20:56 mud Exp $";
d2630 1
a2630 1
    strtime[25] = '\0';
@


1.273
log
@remove extra )
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.272 2000/08/09 21:18:48 mud Exp $";
d2630 1
@


1.272
log
@working on date
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.271 2000/08/09 21:16:27 mud Exp $";
d2634 1
a2634 1
	strtime)); 
@


1.271
log
@adjusting ate created in stat
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.270 2000/07/26 02:38:28 mud Exp $";
d2629 1
a2629 1
    strtime = ctime(&victim->pcdata->created_date);
@


1.270
log
@remove double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.269 2000/07/25 20:06:37 mud Exp $";
d2604 1
a2604 3
    /* unused var?
    char strtime[MAX_STRING_LENGTH];
     */
d2629 1
d2634 1
a2634 1
	(char *) ctime( &victim->pcdata->created_date )); 
a2888 7

/* Bah stupid Date thing, work on this later
    strtime       = ctime( ch->pcdata->created_date );
    strtime[strlen(strtime)-1]  = '\0';
    sprintf( buf, "Created Date: %s\n\r",str_dup( strtime ));
    send_to_char( buf, ch );
    */
@


1.269
log
@fix matookT from rolling over and give message when you reach 12000 matook ticks
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.268 2000/07/25 00:42:37 mud Exp $";
d88 1
a88 1
    bool override = TRUE; 
d182 1
a182 1
    bool override = TRUE;
d4076 1
a4076 1
    bool override = TRUE;
@


1.268
log
@putitng double exp in
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.267 2000/07/24 23:17:26 mud Exp $";
d1055 1
a1055 1
	  if (ch->pcdata->matookT <= 12000)
@


1.267
log
@missing a ;
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.266 2000/07/24 22:55:44 mud Exp $";
d182 1
a182 1
    bool override = FALSE;
d4076 1
a4076 1
    bool override = FALSE;
@


1.266
log
@remove the Simp joke code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.265 2000/07/24 15:50:07 mud Exp $";
d566 2
@


1.265
log
@ modified betting algorithm.  now use handicapping
 took out Poq's small modifiction to DWEEB flag
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.264 2000/07/21 19:56:19 mud Exp $";
a564 17
    if ( IS_SET(victim->act, PLR_DWEEB))
  {
    if (!str_cmp(victim->name,"Prowler")) 
    {
    send_to_char("Sorry they really are a Simp.\n\r",ch);
  return;
     }
    if (!str_cmp(victim->name,"Firestorm")) 
    {
    send_to_char("Sorry they really are a Simp.\n\r",ch);
  return;
     }
    if (!str_cmp(victim->name,"Poquah")) 
    {
    send_to_char("Sorry they really are a Simp.\n\r",ch);
  return;
     }
@


1.264
log
@having some fun with Rage and the other imms :)
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.263 2000/07/21 19:49:15 mud Exp $";
d577 1
a577 1
    if (!str_cmp(victim->name,"Rage")) 
@


1.263
log
@Simpified!

-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.262 2000/07/20 22:16:27 mud Exp $";
d567 11
a577 2
    if (str_cmp(victim->name,"Prowler")|| 
	str_cmp(victim->name,"Firestorm"))
@


1.262
log
@fix an old double exp problem
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.261 2000/07/18 18:48:44 mud Exp $";
d567 7
@


1.261
log
@splitting out gladiator plays
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.260 2000/07/04 17:50:17 mud Exp $";
d182 1
a182 1
    bool override = TRUE;
d4075 1
a4075 1
    bool override = TRUE;
@


1.260
log
@ no level restrictions on trans'ing mobs, still there for transing PC's

 modified potion costs for alchemists

 fixed a couple bugs in gladiator betting.
 added in check to stop betting when event is a team event
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.259 2000/06/29 20:47:57 mud Exp $";
d2735 1
a2735 1
	sprintf(buf,"Total Events: %d  Gladiator Victories: %d  Kills: %d  Team Victories: %d  Team Kills: %d\n\r",
d2739 1
@


1.259
log
@adjust the stat around
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.258 2000/06/28 23:03:11 mud Exp $";
d1884 1
a1884 1
    if ( ch->level < victim->level)
@


1.258
log
@fix rages bug in demise skill, ch not vicctim
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.257 2000/06/28 01:21:09 mud Exp $";
d2630 1
a2630 1
    sprintf(buf,"Clan: %s  Rank: %d  Created: %s  Host: %s\n\r",
d2633 2
a2634 2
	(char *) ctime( &victim->pcdata->created_date ),
	victim->pcdata->last_host );
@


1.257
log
@ Added in Demise clan skill confusion
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.256 2000/06/28 00:57:11 mud Exp $";
d790 2
a791 2
	  if (victim->clan == clan_lookup("demise"))
	      victim->pcdata->learned[skill_lookup("confusion")] = 0;
@


1.256
log
@gladiator stuff
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.255 2000/06/25 23:36:08 mud Exp $";
d760 2
d790 2
d1029 2
d1101 2
d1141 5
a1145 1
  }
@


1.255
log
@fix stat to show glad stats, adjust glad_plays counter it may not be working
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.254 2000/06/17 21:18:39 mud Exp $";
d2729 1
@


1.254
log
@guilding adds avarice clan skill, outcasting removes it
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.253 2000/05/30 00:26:39 mud Exp $";
d2721 1
a2721 1
     if(!IS_NPC(ch))
@


1.253
log
@add team stats to kr, score and stat
clean up bugs in team code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.252 2000/05/29 19:37:02 mud Exp $";
d758 2
d786 2
d1023 2
d1093 2
d1129 4
@


1.252
log
@adding new gladiator files and tteam gladiator code with gladitor code moved
out of old files.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.251 2000/05/26 14:07:09 mud Exp $";
d2711 2
a2712 1
	sprintf(buf,"Gladiator Victories: %d  Kills: %d\n\r",
d2714 3
a2716 2
	       victim->gladiator_data[GLADIATOR_KILLS]);
	send_to_char(buf,ch);
@


1.251
log
@ added in betting code to game port
 removed double xp
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.250 2000/05/26 02:26:21 mud Exp $";
a56 5
DECLARE_DO_FUN(do_startgladiator	);
DECLARE_DO_FUN(do_endgladiator	);
DECLARE_DO_FUN(do_removegladiator	);
DECLARE_DO_FUN(do_gladiator	);
DECLARE_DO_FUN(do_gbet          );
a64 1
void    gladiator_bet_resolve args( (CHAR_DATA *winner, CHAR_DATA *bettor));
a6492 401
void do_startgladiator(CHAR_DATA *ch, char *argument)
{
   char buf[MAX_STRING_LENGTH];
   char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
   char arg3[MAX_INPUT_LENGTH];
   char arg4[MAX_INPUT_LENGTH];
   int i1,i2,i3,i4;
   DESCRIPTOR_DATA *d;

   argument = one_argument(argument, arg1);
   argument = one_argument(argument, arg2);
   argument = one_argument(argument, arg3);
   argument = one_argument(argument, arg4);
   if (arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' || arg4[0] == '\0')
   {
      send_to_char("Syntax: startgladiator <type> <min_level> <max_level> <ticks till start>\n\r", ch);
      return;
   }

   if ( !is_number(arg1) || !is_number(arg2) 
	|| !is_number(arg3) || !is_number(arg4))
	{
	  send_to_char("All arguments to startgladiator are numeric.\n\r",ch);
	  return;
	}

   i1 = atoi(arg1);
   i2 = atoi(arg2);
   i3 = atoi(arg3);
   i4 = atoi(arg4);

   if ( i1 < 1 || i1 > 2 || i2 <= 0 || i2 > 51 || i3 <= 0 || i3 > 51 || i4 < 3)
   {
      send_to_char("The type either has to be one of the following:\n\r",ch);
      send_to_char("1 - Single Clanner Only\n\r",ch);
      send_to_char("2 - Single NonClanned Allowed\n\r",ch);
      send_to_char("3 - Teams Clanner Only (Not yet available)\n\r",ch);
      send_to_char("4 - Teams NonClanned Allowd (Not yet available)\n\r",ch);
      send_to_char("Levels must be between 1 and 51.\n\r", ch);
      send_to_char("Minimum Start Time is 3 Ticks.\n\r",ch);
      return;
    }

   if (i3 < i2)
   {
      send_to_char("Max level can not be less than the min level.\n\r", ch);
      return;
   }

   if (gladiator_info.started == TRUE)
   {
      send_to_char("There is already a Gladiator Event going on!\n\r", ch);
      return;
   }

   gladiator_info.started = TRUE;
   gladiator_info.type = i1;
   gladiator_info.min_level = i2;
   gladiator_info.max_level = i3;
   gladiator_info.time_left = i4;
   gladiator_info.playing = 0;
   sprintf(buf, "Gladiator combat started for levels %d to %d.  Type 'GLADIATOR' to join. Read 'help gladiator' for more info.", gladiator_info.min_level, gladiator_info.max_level);
   do_echo(ch,buf);
   for (d = descriptor_list; d != NULL; d = d->next)
   {
      if (d->character != NULL)
      {
         if (IS_SET(d->character->mhs, MHS_GLADIATOR))
            REMOVE_BIT(d->character->mhs, MHS_GLADIATOR);
	 if ( d->character->glad_bet_amt != 0)
	   d->character->glad_bet_amt = 0;
      }
   }
}

void remove_gladiator(CHAR_DATA *victim)
{
    char buf[MAX_STRING_LENGTH];

    REMOVE_BIT(victim->mhs, MHS_GLADIATOR);
    char_from_room(victim);
    char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
    victim->clan = victim->pcdata->save_clan;
    victim->pcdata->save_clan = 0;
    do_look(victim, "auto");
    /* Check if the gladiator has started and if so if the 
      removal of this player leaves only 1 person */
    if((gladiator_info.playing == 2) && gladiator_info.time_left == 0)
    {
       DESCRIPTOR_DATA *d;

       for(d = descriptor_list; d != NULL; d = d->next)
       {
	  if (d->character != NULL)
	  {
          if (IS_SET(d->character->mhs, MHS_GLADIATOR))
          {
             sprintf(buf, "%s is victorious in the arena!", d->character->name);
             gladiator_talk(buf); 
             gladiator_winner(d->character);
          }
	  }
       }
    }
    gladiator_info.playing--;
    return;
}

void do_removegladiator( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char arg1[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];

    argument = one_argument( argument, arg1 );

    if ( arg1[0] == '\0' )
    {
        send_to_char( "Syntax: removegladiator <char name>\n\r",ch);
        return;
    }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
        send_to_char( "They aren't playing.\n\r", ch );
        return;
    }

    if (IS_NPC(victim))
       return;

    if (!IS_SET(victim->mhs,MHS_GLADIATOR))
    {
       send_to_char( "They are not a Gladiator.\n\r",ch);
       return;
    }

    sprintf(buf, "%s has removed %s from the Event, oh the shame!",ch->name,victim->name);
    gladiator_talk(buf);
    remove_gladiator(victim);

    return;
}


void do_endgladiator( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    DESCRIPTOR_DATA *d;
    char arg1[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];

    argument = one_argument( argument, arg1 );

    if ( arg1[0] == '\0' )
    {
        send_to_char( "Syntax: endgladiator <victor's name or none>\n\r",ch);
        return;
    }

    if (strcmp (arg1,"none")) 
    {
       if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
       {
           send_to_char( "They aren't playing.\n\r", ch );
           return;
       }

       sprintf(buf, "%s has declared %s to be victorious!",ch->name,victim->name);
       gladiator_talk(buf);

       gladiator_winner(ch);
    }
    else
    {
       sprintf(buf, "%s has declared combat over with no one the victor!",ch->name);
       gladiator_talk(buf);

       gladiator_info.started = FALSE;
       gladiator_info.playing = 0;
       gladiator_info.time_left = 0;
       gladiator_info.min_level = 0;
       gladiator_info.max_level = 0;
       gladiator_info.type = 0;

       for(d = descriptor_list; d != NULL; d = d->next)
       {
	  if(d->character != NULL)
	  {
          if (!IS_NPC(d->character))
          {
             if (IS_SET(d->character->mhs, MHS_GLADIATOR))
             {
                char_from_room(d->character);
                char_to_room(d->character,get_room_index(clan_table[d->character->clan].hall));
                REMOVE_BIT(d->character->mhs, MHS_GLADIATOR);
	        d->character->clan = d->character->pcdata->save_clan;
		d->character->pcdata->save_clan = 0;
                do_look(d->character, "auto");
             }
          }
	  }
       }
    }
    return;
}

void gladiator_winner( CHAR_DATA *ch )
{
   DESCRIPTOR_DATA *d;

   ch->gladiator_data[GLADIATOR_VICTORIES] += 1;

   gladiator_info.started = FALSE;
   gladiator_info.playing = 0;
   gladiator_info.time_left = 0;
   gladiator_info.min_level = 0;
   gladiator_info.max_level = 0;
   gladiator_info.type = 0;

   for(d = descriptor_list; d != NULL; d = d->next)
   {
      if (d->character != NULL)
      {
         if (IS_SET(d->character->mhs, MHS_GLADIATOR))
         {
            char_from_room(d->character);
            char_to_room(d->character,get_room_index(clan_table[d->character->clan].hall));
            REMOVE_BIT(d->character->mhs, MHS_GLADIATOR);
	    d->character->clan = d->character->pcdata->save_clan;
            d->character->pcdata->save_clan = 0;
            do_look(d->character, "auto");
	 }
	 if ( d->character->glad_bet_amt != 0 )
	   {
	     gladiator_bet_resolve( ch, d->character);
	   }
      }
   }
   return;
}

void do_gladiator( CHAR_DATA *ch, char *argument)
{
   char arg1[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   ROOM_INDEX_DATA *location;

   if (IS_NPC(ch))
      return;

   argument = one_argument( argument, arg1 );

   if (gladiator_info.started != TRUE) 
   {
      send_to_char("There is no Gladiator Combat going!\n\r", ch);
      return;
   }

   if (ch->level < gladiator_info.min_level || ch->level > gladiator_info.max_level)
   {
      send_to_char("Sorry, you have not the right experience for this Combat.\n\r", ch);
      return;
   }
   if ( ch->glad_bet_amt != 0 && ch->glad_bet_on != ch )
      {
      send_to_char("You already bet on someone else.  Either clear\n\r", ch);
      send_to_char("your bet, or don't participate.\n\r", ch);
      return;
      }

   if (IS_SET(ch->mhs, MHS_GLADIATOR))
   {
      send_to_char("You are already a Gladiator, no turning back now.\n\r", ch);
      return;
   }

   if (gladiator_info.started == TRUE && gladiator_info.time_left < 1)
   {
      send_to_char("Hey goober its started already.\n\r", ch);
      return;
   }

   if (gladiator_info.type == 1 || gladiator_info.type == 2)
   {
      if (gladiator_info.type == 1 && !is_clan(ch))
      {
	 send_to_char("Sorry this Event is for Clanners Only. Try Again next time.\n\r",ch);
	 return;
      }

      location = get_room_index(ROOM_VNUM_SINGLE_GLADIATOR);  
      act("$n goes to spill some blood in Gladiator Combat!", ch, NULL, NULL, TO_ROOM,FALSE); 
      char_from_room(ch);
      char_to_room(ch, location);
      SET_BIT(ch->mhs, MHS_GLADIATOR);
      ch->gladiator_data[GLADIATOR_PLAYS] += 1;
      ch->pcdata->save_clan = ch->clan; 
      if (gladiator_info.type == 2 && !is_clan(ch))
	 ch->clan = clan_lookup("temp");
      sprintf(buf, "%s (Level %d %s) joins the Gladiators!", ch->name, ch->level, class_table[ch->class].name);
      gladiator_talk(buf);
      act("$n arrives to prove his worth!", ch, NULL, NULL, TO_ROOM,FALSE);
      gladiator_info.playing++;
      die_follower(ch);
      affect_strip(ch,gsn_sneak);
      do_look(ch, "auto");
      return;
   }
}

void do_gbet ( CHAR_DATA *ch , char *argument )
{
  int amount;
  CHAR_DATA *victim;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  char buf[MAX_STRING_LENGTH];
  argument = one_argument(argument, arg1);
  argument = one_argument(argument, arg2);
 
  if ( arg1[0] == '\0' )
    {
    send_to_char("Syntax: gbet <amount> <character>\n\r", ch);
    send_to_char("        gbet clear\n\r",ch);
    return;
    }

  if (!str_cmp(arg1, "clear"))
   {
   send_to_char("Bet cleared.\n\r", ch);
   ch->gold += ch->glad_bet_amt;
   ch->glad_bet_amt = 0;
   }

   if (gladiator_info.started != TRUE) 
   {
      send_to_char("There is no Gladiator Combat going!\n\r", ch);
      return;
   }
  
  if ( (victim = get_char_world(ch, arg2)) == NULL)
     {
     send_to_char("They aren't here.\n\r", ch);
     return;
     }

  if ( !IS_SET(victim->mhs, MHS_GLADIATOR) )
     {
     send_to_char("You can't bet on them, they aren't participating.\n\r", ch);
     return;
     }

  if (gladiator_info.started == TRUE && victim != ch 
      && IS_SET(ch->mhs, MHS_GLADIATOR))
      {
      send_to_char("If you want to bet, you have to bet on yourself. \n\r", ch);
      return;
      }
   if (gladiator_info.started == TRUE && gladiator_info.time_left < 1)
   {
      send_to_char("You may not bet after the combat has started\n\r", ch);
      return;
   }
  
  amount = atoi(arg1);

  if ( ch->gold < amount )
    {
    send_to_char("You can't bet that much, you don't have it in gold.\n\r",ch);
    return;
    }

  ch->glad_bet_amt = amount;
  ch->gold -= amount;
  ch->glad_bet_on = victim;

  sprintf(buf, "You have placed a bet of %d gold on %s.\n\r", amount, victim->name);
  send_to_char(buf,ch);
  return;
}

void gladiator_bet_resolve( CHAR_DATA *winner, CHAR_DATA *bettor )
{
 int odds;
 char buf[MAX_STRING_LENGTH];

 odds = 2; // for now, pay out 1:1

 if ( bettor->glad_bet_on == winner  && bettor->glad_bet_amt > 0 )
   {
   bettor->gold += (bettor->glad_bet_amt)*odds;
   sprintf(buf,"Your bet on %s came through, you won %d gold!!!!\n\r", winner->name, bettor->glad_bet_amt);
   }
 else
   {
   sprintf(buf,"Your bet on %s was a waste of money.  God they suck!  Better luck next time. \n\r", bettor->glad_bet_on->name);
   }

 send_to_char(buf,bettor);
 return;
}
@


1.250
log
@fix another of rages mistakes
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.249 2000/05/26 02:04:24 mud Exp $";
a6811 1
#ifdef CODE_TEST
d6829 1
a6877 1
#endif
d6887 1
a6887 1
 if ( bettor->glad_bet_on == winner )
@


1.249
log
@anotehr of rages bugs
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.248 2000/05/26 02:02:56 mud Exp $";
d6871 1
a6871 1
  ch->glad_bet_on = amount;
@


1.248
log
@fix rages missing )
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.247 2000/05/26 01:51:34 mud Exp $";
d6867 1
a6867 1
    send_to_char("You can't bet that much, you don't have it in gold.\n\r");
@


1.247
log
@ fixed syntax error in gbet, I hope
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.245 2000/05/26 01:43:25 mud Exp $";
d6852 1
a6852 1
      && IS_SET(ch->mhs, MHS_GLADIATOR)
@


1.246
log
@team gladiator
-poq
@
text
@d6505 1
a6505 2
   char arg5[MAX_INPUT_LENGTH];
   int i1,i2,i3,i4;i5;
a6547 21
   if (i1 == 3 || i1 == 4)
   {
      argument = one_argument(argument, arg5);
      if (arg5[0] == '\0')
      {
         send_to_char("Syntax: startgladiator <type> <min_level> <max_level> <ticks till start> <ticks till end>\n\r", ch);
         return;
      }
      if ( !is_number(arg5)) 
      {
	  send_to_char("All arguments to startgladiator are numeric.\n\r",ch);
	  return;
      }
      i5 = atoi(arg5);
      if (i5 <= 5)
      {
	 send_to_char("Atleast give them a chance to battle, minimum of 5 ticks.\n\r",ch);
	 return;
      }
   }

a6559 5
   gladiator_info.team_counter = i5;
   gladiator_info.gladiator_score = 0;
   gladiator_info.barbarian_score = 0;
   gladiator_info.bet_counter = 5;

d6586 1
a6586 2
    if((gladiator_info.playing == 2) && gladiator_info.time_left == 0
        &&(gladiator_info.type == 1 || gladiator_info.type == 2))
d6603 1
a6603 2
    if(gladiator_info.type == 1 || gladiator_info.type == 2)
       gladiator_info.playing--;
d6667 4
a6670 14
       if(gladiator_info.type == 1 || gladiator_info.type == 2)
       {
          sprintf(buf, "%s has declared %s to be victorious!",ch->name,victim->name);
          gladiator_talk(buf);
       }
       else
       {
	  if(victim->pcdata->gladiator_team == 1)
             sprintf(buf, "%s has declared the Gladiators victorious!",ch->name);
	  else
             sprintf(buf, "%s has declared the Barbarians victorious!",ch->name);
          gladiator_talk(buf);
       }
       gladiator_winner(victim);
a6682 3
       gladiator_info.team_counter = 0;
       gladiator_info.gladiator_score = 0;
       gladiator_info.barbarian_score = 0;
d6710 1
a6710 2
   if(gladiator_info.type == 1 || gladiator_info.type == 2)
      ch->gladiator_data[GLADIATOR_VICTORIES] += 1;
a6717 3
   gladiator_info.team_counter = 0;
   gladiator_info.gladiator_score = 0;
   gladiator_info.barbarian_score = 0;
a6724 6
	    if(gladiator_info.type == 3 || gladiator_info.type == 4)
	    {
	       if(ch->pcdata->gladiator_team == d->character->pcdata->gladiator_team)
		  d->character->gladiator_data[GLADIATOR_TEAM_VICTORIES] += 1;
	    }

@


1.245
log
@ fixed syntax error in gbet
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.244 2000/05/26 01:26:24 mud Exp $";
d6505 2
a6506 1
   int i1,i2,i3,i4;
d6549 21
d6582 5
d6613 2
a6614 1
    if((gladiator_info.playing == 2) && gladiator_info.time_left == 0)
d6631 2
a6632 1
    gladiator_info.playing--;
d6696 14
a6709 4
       sprintf(buf, "%s has declared %s to be victorious!",ch->name,victim->name);
       gladiator_talk(buf);

       gladiator_winner(ch);
d6722 3
d6752 2
a6753 1
   ch->gladiator_data[GLADIATOR_VICTORIES] += 1;
d6761 3
d6771 6
@


1.244
log
@ Added in betting functionality for gladiator combat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.243 2000/05/24 02:02:58 mud Exp $";
d6827 1
a6827 1
  if (!str_cmp(arg1, "clear")
@


1.243
log
@declare buf in remove_galdiator
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.242 2000/05/24 02:01:30 mud Exp $";
d61 1
a61 1

d70 1
d6568 2
d6732 4
d6763 6
d6795 1
d6808 92
@


1.242
log
@fix remove_gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.241 2000/05/24 00:25:09 mud Exp $";
d6573 2
@


1.241
log
@force gladiators to attack eveyr 5 ticks or be disqualified
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.240 2000/05/23 04:55:41 mud Exp $";
d6571 31
a6637 30
void remove_gladiator(CHAR_DATA *ch)
{
    REMOVE_BIT(victim->mhs, MHS_GLADIATOR);
    char_from_room(victim);
    char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
    victim->clan = victim->pcdata->save_clan;
    victim->pcdata->save_clan = 0;
    do_look(victim, "auto");
    /* Check if the gladiator has started and if so if the 
      removal of this player leaves only 1 person */
    if((gladiator_info.playing == 2) && gladiator_info.time_left == 0)
    {
       DESCRIPTOR_DATA *d;

       for(d = descriptor_list; d != NULL; d = d->next)
       {
	  if (d->character != NULL)
	  {
          if (IS_SET(d->character->mhs, MHS_GLADIATOR))
          {
             sprintf(buf, "%s is victorious in the arena!", d->character->name);
             gladiator_talk(buf); 
             gladiator_winner(d->character);
          }
	  }
       }
    }
    gladiator_info.playing--;
    return;
}
@


1.240
log
@more gladiator stuff
-poqa
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.239 2000/05/23 04:14:29 mud Exp $";
d6602 7
@


1.239
log
@opps its && not and
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.238 2000/05/23 04:12:38 mud Exp $";
d6780 1
@


1.238
log
@clean up some gladiator stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.237 2000/05/21 04:47:46 mud Exp $";
d6753 1
a6753 1
   if (gladiator_info.started = TRUE and gladiator_info.time_left < 1)
@


1.237
log
@add d->character != NULL checks on gladiator codes
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.236 2000/05/21 04:12:31 mud Exp $";
d6753 5
d6779 1
@


1.236
log
@cleaned up all those excessive atoi() calls in startgladiator as
well as adding some is_number() checks on the arguments prior to
converting them to integers.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.235 2000/05/21 01:17:14 mud Exp $";
d6563 1
a6563 1
      if (!IS_NPC(d->character))
d6616 2
d6624 1
d6673 2
d6687 1
d6708 1
a6708 1
      if (!IS_NPC(d->character))
@


1.235
log
@cleanup to gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.234 2000/05/21 00:28:53 mud Exp $";
d6504 1
d6511 1
a6511 3
   if (arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' || arg4[0] == '\0'
       || atoi(arg1) < 1 || atoi(arg1) > 2 || atoi(arg2) <= 0 || atoi(arg2) > 51
       || atoi(arg3) <= 0 || atoi(arg3) > 51 || atoi(arg4) < 3)
d6514 17
d6539 1
a6539 1
   }
d6541 1
a6541 1
   if (atoi(arg3) < atoi(arg2))
d6554 4
a6557 4
   gladiator_info.type = atoi(arg1);
   gladiator_info.min_level = atoi(arg2);
   gladiator_info.max_level = atoi(arg3);
   gladiator_info.time_left = atoi(arg4);
@


1.234
log
@fix gladiator update
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.233 2000/05/20 03:10:03 mud Exp $";
d6543 1
a6543 1
   sprintf(buf, "%s Gladiator combat started for levels %d to %d.  Type 'GLADIATOR' to join. Read 'help gladiator' for more info.", gladiator_info.type == 1 ? "Single" : "Team", gladiator_info.min_level, gladiator_info.max_level);
@


1.233
log
@make stating glads actually return their stats not yours
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.232 2000/05/20 02:28:19 mud Exp $";
a2713 1
#ifdef CODE_TEST
a2720 1
#endif
@


1.232
log
@clean up startglad to be more info friendly
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.231 2000/05/20 01:32:22 mud Exp $";
d2718 2
a2719 2
	       ch->gladiator_data[GLADIATOR_VICTORIES],
	       ch->gladiator_data[GLADIATOR_KILLS]);
@


1.231
log
@fix endglad with reversed strcmp
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.230 2000/05/20 01:12:20 mud Exp $";
d6512 3
a6514 1
   if (arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' || arg4[0] == '\0')
a6516 5
      return;
   }

   if (atoi(arg1) < 1 || atoi(arg1) > 2)
   {
d6522 2
a6523 12
      return;
   }

   if (atoi(arg2) <= 0 || atoi(arg2) > 51)
   {
      send_to_char("Level must be between 1 and 51.\n\r", ch);
      return;
   }

   if (atoi(arg3) <= 0 || atoi(arg3) > 51)
   {
      send_to_char("Level must be between 1 and 51.\n\r", ch);
a6531 6

   if(atoi(arg4) < 3)
   {
      send_to_char("Minimum Start Time is 3 Ticks.\n\r",ch);
      return;
  }
@


1.230
log
@working on Gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.229 2000/05/18 21:31:46 mud Exp $";
d6648 1
a6648 1
    if (!strcmp (arg1,"none")) 
@


1.229
log
@Ability to strip IMM command group with 'none' argument.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.228 2000/05/16 00:55:58 mud Exp $";
d6564 1
a6564 1
   sprintf(buf, "&c%s &RGladiator combat started for levels &Y%d &Rto &Y%d&R.  Type 'GLADIATOR' to join. Turn on Gladiator channel for more info.", gladiator_info.type == 1 ? "Single" : "Team", gladiator_info.min_level, gladiator_info.max_level);
d6769 1
a6769 1
      sprintf(buf, "&c%s &R(&cLevel &Y%d&R %s) joins the Gladiators!", ch->name, ch->level, class_table[ch->class].name);
@


1.228
log
@add in all the #ifdef CODE_TEST for gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.227 2000/05/14 00:02:21 mud Exp $";
d858 6
d865 1
a865 2
          send_to_char("You must choose a group from: quest, judge, builder or a
dmin.\n\r",ch);
@


1.227
log
@syntax error ing ladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.226 2000/05/13 23:58:12 mud Exp $";
d2709 1
a2709 1

d2717 1
@


1.226
log
@cleaning up syntax errors in gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.225 2000/05/13 22:58:46 mud Exp $";
d6630 1
a6666 2
       DESCRIPTOR_DATA *d;

d6690 1
a6690 1
   ch->pcdata->gladiator_data[GLADIATOR_VICTORIES] += 1;
@


1.225
log
@clean up gladiator syntax erros
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.224 2000/05/13 22:44:52 mud Exp $";
d6499 1
d6505 2
a6506 1
   if (arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0')
d6573 2
d6599 1
a6599 1
    sprintf(buf, "%s has removed %s from the Event, oh the shame!",ch->name,victim_.name);
d6601 6
a6606 6
    REMOVE_BIT(d->character->mhs, MHS_GLADIATOR);
    char_from_room(d->character);
    char_to_room(d->character,get_room_index(clan_table[d->character->clan].hall));
    ch->clan = ch->pcdata->save_clan;
    ch->pcdata->save_clan = 0;
    do_look(d->character, "auto");
d6630 2
d6666 2
d6689 3
a6691 1
   ch->pcdata->gladiator[VICTORIES] += 1;
d6718 1
a6718 1
void do_gladiator(CHAR_DATA *ch)
d6720 1
d6727 2
d6757 1
a6757 1
      act("$n goes to spill some blood in Gladiator Combat!", ch, NULL, NULL, TO_ROOM); 
d6766 1
a6766 1
      act("$n arrives to prove his worth!", ch, NULL, NULL, TO_ROOM);
@


1.224
log
@clean up couple more syntax erros in gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.223 2000/05/13 22:37:22 mud Exp $";
d6631 1
a6631 1
        send_to_char( "Syntax: endgladiator <"Victor's Name" or "none">\n\r",ch);
@


1.223
log
@cleaning up the declarations for gladiator talk
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.222 2000/05/13 21:55:09 mud Exp $";
d6605 1
a6605 1
    if((gladiator_info.playing -1) == 1 && gladiator_info.time_left = 0)
@


1.222
log
@Gladiator Combat - Intense!
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.221 2000/04/25 01:00:02 mud Exp $";
a60 1
DECLARE_DO_FUN(do_gladiator_winner);
d6596 1
a6596 1
    do_gladiatortalk(buf);
d6614 2
a6615 2
             do_gladiatortalk(buf); 
             do_gladiator_winner(d->character);
d6644 1
a6644 1
       do_gladiatortalk(buf);
d6646 1
a6646 1
       do_gladiator_winner(ch);
d6651 1
a6651 1
       do_gladiatortalk(buf);
d6679 1
a6679 1
void do_gladiator_winner( CHAR_DATA *ch )
d6752 1
a6752 1
      do_gladiatortalk(buf);
@


1.221
log
@Double EXP Day Code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.220 2000/04/18 20:33:46 mud Exp $";
d57 5
d2711 8
d6495 265
@


1.220
log
@fixed act ( entries
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.219 2000/04/18 19:53:40 mud Exp $";
d89 1
a89 1
    bool override = FALSE;
d124 1
a124 2
	    send_to_char("Character rewarded.\n\r",ch);
	    send_to_char("You have been rewarded by the gods.\n\r",victim);
d127 1
d183 1
a183 1
    bool override = FALSE;
d216 1
a216 1
	    send_to_char("The gods have favored you with more skill.\n\r",victim);
d218 1
a219 1
	send_to_char("All Characters SP rewarded.\n\r",ch);
d4036 1
a4036 1
    bool override = FALSE;
@


1.219
log
@comment yanked?
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.218 2000/04/18 19:50:53 mud Exp $";
d6056 1
a6056 1
        act ("$n explodes $p.\n\r",ch,obj,NULL,TO_ROOM);
d6262 1
a6262 1
	act ("$n has renamed you to $N!",ch,NULL,victim,TO_VICT);
@


1.218
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.217 2000/04/17 22:45:35 mud Exp $";
a6335 1
/*
@


1.217
log
@missing a variable on a can_See in mwhere
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.216 2000/04/17 22:38:42 mud Exp $";
d315 1
a315 1
  act("You pull $N from the void.",ch,NULL,d.character,TO_CHAR);
d318 1
a318 1
        ch, NULL, d.character, TO_ROOM );
d323 1
a323 1
     act("$n has entered the game.",d.character->pet,NULL,NULL,TO_ROOM);
d366 1
a366 1
       ch, NULL, victim, TO_CHAR);
d368 1
a368 1
       ch, NULL, victim, TO_ROOM);
d481 1
a481 1
            act_new(string,d->character,obj,ch,TO_CHAR,POS_DEAD);
d772 1
a772 1
	    act( "$N is now an Outcast.", ch, NULL, victim, TO_CHAR );
d1524 1
a1524 1
  act( "$N doesn't have a descriptor.", ch, NULL, victim, TO_CHAR );
d1582 1
a1582 1
  act( "$N doesn't have a descriptor.", ch, NULL, victim, TO_CHAR );
d1870 1
a1870 1
    act( "$n disappears in a mushroom cloud.", victim, NULL, NULL, TO_ROOM );
d1874 1
a1874 1
    act( "$n arrives from a puff of smoke.", victim, NULL, NULL, TO_ROOM );
d1876 1
a1876 1
  act( "$n has transferred you.", ch, NULL, victim, TO_VICT );
d1978 1
a1978 1
    act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT);
d1980 1
a1980 1
    act("$n leaves in a swirling mist.",ch,NULL,rch,TO_VICT);
d1993 1
a1993 1
                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT);
d1995 1
a1995 1
                act("$n appears in a swirling mist.",ch,NULL,rch,TO_VICT);
d2034 1
a2034 1
                act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT);
d2036 1
a2036 1
                act("$n leaves in a swirling mist.",ch,NULL,rch,TO_VICT);
d2049 1
a2049 1
                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT);
d2051 1
a2051 1
                act("$n appears in a swirling mist.",ch,NULL,rch,TO_VICT);
d3177 1
a3177 1
  act( "You didn't find any $T.", ch, NULL, argument, TO_CHAR );
d3302 1
a3302 1
  act_new("$N is no longer snoop-proof.",ch,NULL,victim,TO_CHAR,POS_DEAD);
d3308 1
a3308 1
  act_new("$N is now snoop-proof.",ch,NULL,victim,TO_CHAR,POS_DEAD);
d3617 1
a3617 1
  act(buf,ch,clone,NULL,TO_ROOM);
d3619 1
a3619 1
  act(buf,ch,clone,NULL,TO_CHAR);
d3672 1
a3672 1
  act(buf,ch,NULL,clone,TO_ROOM);
d3674 1
a3674 1
  act(buf,ch,NULL,clone,TO_CHAR);
d3736 1
a3736 1
    act( "$n has created $N!", ch, NULL, victim, TO_ROOM );
d3789 1
a3789 1
    act( "$n has created $p!", ch, obj, NULL, TO_ROOM );
d3834 1
a3834 1
  act( "$n purges the room!", ch, NULL, NULL, TO_ROOM);
d3862 1
a3862 1
  act("$n disintegrates $N.",ch,0,victim,TO_NOTVICT);
d3874 1
a3874 1
    act( "$n purges $N.", ch, NULL, victim, TO_NOTVICT );
d4055 1
a4055 1
            act("$n has restored you.",ch,NULL,vch,TO_VICT);
d4102 1
a4102 1
                act("$n has restored you.",ch,NULL,victim,TO_VICT);
d4127 1
a4127 1
    act( "$n has restored you.", ch, NULL, victim, TO_VICT );
d5737 1
a5737 1
    act( buf, ch, NULL, vch, TO_VICT );
d5760 1
a5760 1
                act( buf, ch, NULL, vch, TO_VICT );
d5783 1
a5783 1
                act( buf, ch, NULL, vch, TO_VICT );
d5824 1
a5824 1
  act( buf, ch, NULL, victim, TO_VICT );
d5851 1
a5851 1
    act( "$n slowly fades into existence.", ch, NULL, NULL, TO_ROOM );
d5857 1
a5857 1
    act( "$n slowly fades into thin air.", ch, NULL, NULL, TO_ROOM );
d5873 1
a5873 1
          act( "$n slowly fades into thin air.", ch, NULL, NULL, TO_ROOM );
d5896 1
a5896 1
          act( "$n is no longer cloaked.", ch, NULL, NULL, TO_ROOM );
d5902 1
a5902 1
          act( "$n cloaks $s presence", ch, NULL, NULL, TO_ROOM );
d5918 1
a5918 1
          act( "$n cloaks $s presence.", ch, NULL, NULL, TO_ROOM );
d5979 1
a5979 1
          act( "$n vanishes!", victim, NULL, NULL, TO_ROOM );
d5983 1
a5983 1
          act( "$n slowly fades into existence.", victim, NULL, NULL, TO_ROOM );              
@


1.216
log
@ck change to do_imm_loads
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.215 2000/04/17 22:00:46 mud Exp $";
d3163 1
a3163 1
  &&   is_name( argument, victim->name ) && can_see (ch,victim) )
@


1.215
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.214 2000/03/31 16:35:31 mud Exp $";
d6299 21
d6329 5
@


1.214
log
@Removed unused variable in do_immloads()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.213 2000/03/30 21:47:01 mud Exp $";
d1817 1
a1817 1
      &&   can_see( ch, d->character ) )
d2200 1
a2200 1
  if (can_see(ch,rch))
d2306 1
a2306 1
      can_see(ch,obj->carried_by) ? obj->carried_by->name
d3090 1
a3090 1
        if ( in_obj->carried_by != NULL && can_see(ch,in_obj->carried_by)
d3093 1
a3093 1
                number, obj->short_descr,PERS(in_obj->carried_by, ch),
d3136 1
a3136 1
      &&  d->character->in_room != NULL && can_see(ch,d->character)
d5597 1
a5597 1
        if ( d->character != NULL && can_see( ch, d->character ))
d5622 1
a5622 1
        if ( d->character != NULL && can_see( ch, d->character ) 
d5664 1
a5664 1
  if ( d->character != NULL && can_see( ch, d->character ) 
@


1.213
log
@turn overrrides off for rewards
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.212 2000/03/28 23:20:14 mud Exp $";
d6281 1
a6281 1
    char buf[MAX_STRING_LENGTH];
@


1.212
log
@fix spreward to not spam for each char
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.211 2000/03/25 20:31:39 mud Exp $";
d89 1
a89 1
    bool override = TRUE;
d183 1
a183 1
    bool override = TRUE;
d4036 1
a4036 1
    bool override = TRUE;
@


1.211
log
@interesting doublke exp day
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.210 2000/03/20 23:22:25 mud Exp $";
a215 1
	    send_to_char("Character SP rewarded.\n\r",ch);
d219 1
@


1.210
log
@syntax error in fear and d to ld in mstat
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.209 2000/03/20 23:10:52 mud Exp $";
d89 1
d100 1
a100 1
    if ( !str_cmp(arg,"all") && get_trust(ch) >= 58 )
d183 1
d194 1
a194 1
    if ( !str_cmp(arg,"all") && get_trust(ch) >= 58 )
d4036 1
d4066 1
a4066 1
    if ( get_trust(ch) >=  58 && 
@


1.209
log
@move the stolen data into a steal_data with long int
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.208 2000/03/12 00:32:41 mud Exp $";
d2685 1
a2685 1
sprintf( buf, "Attempts: %d Kills: %d Deaths: %d Stolen: (%ld/%ld/%ld) Slices: %d\n\r",
@


1.208
log
@new thieving data
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.207 2000/03/10 02:12:34 mud Exp $";
d2685 1
a2685 1
sprintf( buf, "Attempts: %d Kills: %d Deaths: %d Stolen: (%d/%d/%d) Slices: %d\n\r",
d2687 3
a2689 3
       victim->killer_data[PC_DEATHS], victim->killer_data[PC_STOLEN_ITEMS],
       victim->killer_data[PC_STOLEN_GOLD], 
       victim->killer_data[PC_STOLEN_SILVER],victim->killer_data[PC_SLICES]); 
@


1.207
log
@no discoing or fucking those above you
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.206 2000/03/07 14:31:36 mud Exp $";
d2685 1
a2685 1
sprintf( buf, "Attempts: %d  Kills: %d  Deaths: %d Outcast: %d Ruffian: %d\n\r",
d2687 3
a2689 2
       victim->killer_data[PC_DEATHS], victim->pcdata->outcT,
       victim->pcdata->ruffT); 
d2691 3
@


1.206
log
@do not get second_hitroll for mobs in mstat
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.205 2000/03/06 00:23:37 mud Exp $";
d1526 6
d1559 6
d1582 6
@


1.205
log
@Dual Wield changes, second_hitroll,second_damroll and increase skill points to 2 for spells
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.204 2000/03/03 21:16:24 mud Exp $";
d2645 3
a2647 1
    sprintf( buf, 
d2653 10
@


1.204
log
@ fixed last bug in skstat, initialization of buffer

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.203 2000/03/03 20:32:15 mud Exp $";
d2646 3
a2648 2
  "Hit: %d  Dam: %d  Saves: %d  Size: %s  Position: %s  Wimpy: %d\n\r",
  GET_HITROLL(victim), GET_DAMROLL(victim), victim->saving_throw,
@


1.203
log
@ fixed bug in skillstat, misplaced ch's instead ov victims

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.202 2000/03/03 06:28:54 mud Exp $";
d6322 2
@


1.202
log
@ made another minor change to olist

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.201 2000/03/03 06:16:36 mud Exp $";
d6327 2
a6328 2
   if ( ch->level < skill_level(ch,sn)
   || ch->pcdata->learned[sn] < 1)
@


1.201
log
@ temp took out olist, crashes the game , will fix later

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.200 2000/03/03 06:03:11 mud Exp $";
d6363 1
a6363 1
/*   if ( ( victim = get_char_world(ch, argument)) == NULL)
d6416 1
a6416 1
*/
@


1.200
log
@Added olist IMM command, returns list of all equip carried by target

-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.199 2000/03/02 19:29:37 mud Exp $";
d6360 4
a6363 1
   if ( ( victim = get_char_world(ch, argument)) == NULL)
d6416 1
@


1.199
log
@ Added new imm command skstat, returns list of targets skills/spells and percents

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.198 2000/02/29 07:18:30 mud Exp $";
d6350 63
@


1.198
log
@opps fix that restore
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.197 2000/02/29 07:15:03 mud Exp $";
d6299 50
@


1.197
log
@lower restore nonclan / all to 58
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.196 2000/02/29 06:58:00 mud Exp $";
d4028 1
a4028 1
    if ( get_trust(ch) >=  L2 && 
@


1.196
log
@allow 58's to reward and spreward all and lower pload/punload to 58
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.195 2000/02/26 00:21:47 mud Exp $";
d4028 1
a4028 1
    if ( get_trust(ch) >=  MAX_LEVEL - 1 && 
@


1.195
log
@make spreward do skill_points not xp
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.194 2000/02/26 00:18:59 mud Exp $";
d99 1
a99 1
    if ( !str_cmp(arg,"all") && get_trust(ch) >= 59 )
d192 1
a192 1
    if ( !str_cmp(arg,"all") && get_trust(ch) >= 59 )
@


1.194
log
@spreward
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.193 2000/02/25 19:46:12 mud Exp $";
d213 1
a213 1
	    gain_exp( victim, atoi(arg2) );
d260 1
a260 1
    gain_exp( victim, atoi(arg2) );
@


1.193
log
@players can not guild outcasts
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.192 2000/02/18 21:01:44 mud Exp $";
d173 90
@


1.192
log
@remove debug lines in random
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.191 2000/02/16 22:01:11 mud Exp $";
d912 1
a912 1
	if(victim->pcdata->outcT > 0)
d914 1
a914 2
	  send_to_char("They were outcast too recently.\n\r",ch);
	  send_to_char("You were outcast too recently.\n\r",victim);
@


1.191
log
@line feed added to immloads
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.190 2000/02/16 21:58:21 mud Exp $";
d1747 6
d3801 6
@


1.190
log
@print immloads that dont have imm_load flag
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.189 2000/02/16 21:23:28 mud Exp $";
d6162 1
a6162 1
                fprintf( fp, "[%5d] %s",pObjIndex->vnum, 
@


1.189
log
@working on settingimmload
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.188 2000/02/16 19:07:57 mud Exp $";
d6160 3
a6162 1
             fprintf( fp, "[%5d] %s",pObjIndex->vnum, 
a6163 4
	     if (!IS_SET(obj->pIndexData->extra_flags,ITEM_IMM_LOAD))
	     {
		fprintf( fp," - immload Set\n\r");
		SET_BIT(obj->pIndexData->extra_flags,ITEM_IMM_LOAD);
@


1.188
log
@Have do_imm_load set ITEM_IMM_LOAD
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.187 2000/02/15 22:32:15 mud Exp $";
d6160 1
a6160 1
             fprintf( fp, "[%5d] %s\n\r",pObjIndex->vnum, 
d6162 5
a6166 2
	     if (!IS_SET(obj->extra_flags,ITEM_IMM_LOAD))
		SET_BIT(obj->extra_flags,ITEM_IMM_LOAD);
@


1.187
log
@ added debit levels and logout remaining to mstat

 -rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.186 2000/02/11 20:23:49 mud Exp $";
d6162 2
@


1.186
log
@remove dark_item function
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.185 2000/02/11 18:27:32 mud Exp $";
d2536 3
a2538 2
  "Lv: %d  Cls: %s %s  Align: %d  Go: %ld  Si: %ld  XP: %d\n\r",
  victim->level,       
d2615 2
a2616 2
       if (victim->pcdata->logout_tracker > 0)
       {
d2620 2
a2621 2
  send_to_char( buf, ch );
       }
@


1.185
log
@Dark Item finder
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.184 2000/02/11 17:25:47 mud Exp $";
d6167 1
d6193 1
@


1.184
log
@only allow 59's to set pfresh bit
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.183 2000/02/11 17:12:24 mud Exp $";
d6158 26
@


1.183
log
@bastardize do_highlander to set pfreshed instead for testing
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.182 2000/02/07 19:40:00 mud Exp $";
d828 6
@


1.182
log
@ had a bad act_wiz file, that wasn't up to date..including correct file

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.180 2000/02/06 19:08:52 mud Exp $";
d831 6
d864 1
@


1.181
log
@ added in prefresh checks for loading eq from the pfile

 -Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.179 2000/02/04 02:18:43 mud Exp $";
a905 6
	if( !IS_SET(victim->act,PLR_CANCLAN) &&
		class_table[victim->class].reclass == TRUE )
	{
	send_to_char("They didn't clan the first time through.\n\r",ch);
	return;
	}
@


1.180
log
@ Removed size based damage coede temporarily.
 fixe bug not letting people who rare reclasses at creation be guilded without immortal help

 -Rage.
@
text
@d906 6
@


1.179
log
@Pfresh code:
merc.h
save.c
act_comm.c
act_wiz.c
- logout_tracker code

comm.c
- everything inside the if MHS_PREFRESH
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.178 2000/02/01 02:55:33 mud Exp $";
a905 6
	if( !IS_SET(victim->act,PLR_CANCLAN) &&
		class_table[victim->class].reclass == TRUE )
	{
	send_to_char("They didn't clan the first time through.\n\r",ch);
	return;
	}
@


1.178
log
@clea up old reclassing style and canclan ability in loner
-POquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.177 2000/01/31 22:12:36 mud Exp $";
d2607 7
@


1.177
log
@Must loner by levle 20 now
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.176 2000/01/25 00:13:33 mud Exp $";
d599 1
d605 1
@


1.176
log
@Think I got imm_load done now
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.175 2000/01/25 00:08:21 mud Exp $";
d596 1
a596 1
        if( ( !is_clan(ch) && ch->level >=5 && ch->level <= 25 )|| 
@


1.175
log
@forgot to close the file
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.174 2000/01/24 23:55:20 mud Exp $";
d6137 1
a6137 1
    for (vnum = 16730; vnum < 33000; vnum++)
@


1.174
log
@remove debug line
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.173 2000/01/24 23:49:22 mud Exp $";
d6132 2
d6148 1
@


1.173
log
@do second group of imm loads
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.172 2000/01/24 23:41:26 mud Exp $";
a6138 2
	  sprintf(buf,"[%5d] %s\n\r",pObjIndex->vnum,pObjIndex->short_descr);
	  send_to_char(buf,ch);
@


1.172
log
@debugging imm_loads
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.171 2000/01/24 23:20:46 mud Exp $";
d6135 1
a6135 1
    for (vnum = 0; vnum < 33000; vnum++)
@


1.171
log
@tweak do_imm_loads
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.170 2000/01/24 23:02:35 mud Exp $";
d6125 1
d6139 2
@


1.170
log
@doh my function had an infinite for loop.
-Pouqha
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.169 2000/01/24 22:47:09 mud Exp $";
a6128 1
    bool found;
a6135 1
       found = FALSE;
d6138 1
a6138 1
          for ( obj = object_list; obj != NULL; obj = obj->next )
a6139 7
             if (!is_name( pObjIndex->name, obj->name ))
	        continue;
 
             found = TRUE;
          }
 
          if ( !found )
d6142 1
@


1.169
log
@Change immloads to look at 33000
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.168 2000/01/24 20:58:20 mud Exp $";
a6129 1
    int nMatch;
d6135 1
a6135 2
    nMatch = 0;
    for (vnum = 0; nMatch < 33000; vnum++)
a6139 1
          nMatch++;
@


1.168
log
@Declare two missing variables in imm_load
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.167 2000/01/24 19:51:54 mud Exp $";
a6124 1
    extern int top_obj_index;
d6137 1
a6137 1
    for (vnum = 0; nMatch < top_obj_index; vnum++)
@


1.167
log
@do_imm_loads creates a file of all imm loads
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.166 2000/01/21 00:53:15 mud Exp $";
d6125 1
d6132 1
@


1.166
log
@Added new spelll confusion.
Confuses victims sense of direction
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.165 2000/01/12 08:12:34 mud Exp $";
d6122 35
@


1.165
log
@fix the stat for skill points
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.164 2000/01/11 01:35:32 mud Exp $";
d668 1
d694 1
@


1.164
log
@Added the new skill point trackers to save in the pfile and show in stat
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.163 2000/01/08 04:58:52 mud Exp $";
d2582 3
a2584 3
	ch->skill_points,
	ch->pcdata->skill_point_tracker,
	ch->pcdata->skill_point_timer);
@


1.163
log
@change set to change the size if you change the race
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.162 2000/01/07 22:03:17 mud Exp $";
d2575 1
a2575 1
    sprintf( buf2, "Remort: %s  Deity: %s (%d / %d)  Skill Points: %d\n\r",
d2582 3
a2584 1
	ch->skill_points);
@


1.162
log
@Added skill points to stat players
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.161 1999/12/15 00:56:53 mud Exp $";
d5018 1
@


1.161
log
@Remove the Remort/Reclass wiping out hours Dont need it anymore with no hours code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.160 1999/12/03 01:48:28 mud Exp $";
d2575 1
a2575 1
    sprintf( buf2, "Remort: %s  Deity: %s (%d / %d)\n\r",
d2581 2
a2582 1
	(int) ((victim->played - victim->pcdata->switched)/3600));
@


1.160
log
@Change the port on sockets to show : instead of . as : is more standard
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.159 1999/12/02 21:32:22 mud Exp $";
d2607 3
a2609 1

d2615 1
a2615 1
      (int) (victim->played + victim->redid + current_time - victim->logon) / 3600, 
@


1.159
log
@Rework Last Attacked by to not store a pointer, but store the name instead
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.158 1999/12/02 19:22:58 mud Exp $";
d5446 1
a5446 1
              sprintf( buf + strlen(buf), "[%2d] %-18s %s@@%s.%d\n\r",
d5463 1
a5463 1
            sprintf( buf + strlen(buf), "[%2d] %-18s %-15s %s.%d\n\r",
@


1.158
log
@Change mstat temporarily till I fix the Last Attacked by pointer vs name issue
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.157 1999/11/29 00:14:02 mud Exp $";
a2685 1
/*
d2690 1
a2690 2
         victim->pcdata->last_attacked_by ? 
	 victim->pcdata->last_attacked_by->name : "(none)",
a2693 1
   */
@


1.157
log
@Show trumps in mstat
Save Last Attacked By in pfile
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.156 1999/11/24 22:48:04 mud Exp $";
d2686 1
d2696 1
@


1.156
log
@added fighting info
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.155 1999/11/24 22:09:11 mud Exp $";
d2688 1
a2688 1
      sprintf( buf, "Fighting: %s  Last Attacked By: %s\n\r",
d2691 2
a2692 1
	 victim->pcdata->last_attacked_by->name : "(none)" ) ; 
@


1.155
log
@syntax error missing ;
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.154 1999/11/24 22:05:59 mud Exp $";
d2688 2
a2689 1
      sprintf( buf, "Last Attacked By: %s\n\r",
@


1.154
log
@syntax error missing )
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.153 1999/11/24 22:04:34 mud Exp $";
d2690 1
a2690 1
	 victim->pcdata->last_attacked_by->name : "(none)" )  
@


1.153
log
@Change last_attack to pcdatat->last_attack where it was
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.152 1999/11/24 22:00:50 mud Exp $";
d2690 1
a2690 1
	 victim->pcdata->last_attacked_by->name : "(none)",
@


1.152
log
@Added Last_Attacked_by to track new Flag System
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.151 1999/11/21 21:50:38 mud Exp $";
d2689 2
a2690 1
         victim->last_attacked_by ? victim->last_attacked_by->name : "(none)",
@


1.151
log
@Added nodns

-G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.150 1999/11/20 22:28:30 mud Exp $";
d2685 7
@


1.150
log
@Closing in on cleaning up Fear
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.149 1999/11/20 21:26:06 mud Exp $";
d6094 11
@


1.149
log
@Added "next in room" to mstat for Fear debugging
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.148 1999/11/07 00:56:00 mud Exp $";
d2681 2
a2682 1
   sprintf( buf, "Next In Room: %s\n\r",
@


1.148
log
@Wear Timer for Objects
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.147 1999/10/31 02:50:12 mud Exp $";
d2680 4
@


1.147
log
@fix my reward fix, put an atoi around arg2
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.146 1999/10/31 02:23:21 mud Exp $";
d2171 2
a2172 2
    sprintf( buf, "Level: %d  Cost: %d  Condition: %d  Timer: %d\n\r",
  obj->level, obj->cost, obj->condition, obj->timer );
@


1.146
log
@new remort 'mummy' with skill 'breathe'
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.145 1999/10/30 20:26:48 mud Exp $";
d109 1
a109 1
	if ( arg2 > 10000)
@


1.145
log
@Limit Reward to 10K
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.144 1999/10/10 17:25:57 mud Exp $";
d576 2
a577 1
	 && (IS_SET(ch->act,PLR_WERE) || IS_SET(ch->act,PLR_VAMP)) )
d2577 1
@


1.144
log
@ommented out unused var strtime in mstat
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.143 1999/10/10 17:24:21 mud Exp $";
d107 6
@


1.143
log
@Removed double declaration of
bool    check_parse_name        args( ( char *name ) );
in comm.c and added it to act_wiz.c
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.142 1999/10/09 17:16:41 mud Exp $";
d2442 1
d2444 1
@


1.142
log
@ Added in some changes to outcast.  All checks on clan outcast now include an additional check on their timre.  read the change to find out why

 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.141 1999/10/02 22:16:12 mud Exp $";
d65 1
a65 1

@


1.141
log
@Fix typo 'memeber' in guild
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.140 1999/09/18 21:46:40 mud Exp $";
d573 5
@


1.140
log
@Crahs bug fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.139 1999/09/16 23:31:47 mud Exp $";
d897 1
a897 1
	send_to_char("They are now a memeber of your clan.\n\r",ch);
@


1.139
log
@More work on mstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.138 1999/09/16 23:08:01 mud Exp $";
d2460 1
a2460 1
    if ( !IS_NPC(ch) )
@


1.138
log
@Fixed some of the formatting in mstat cuz it's hard to read.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.137 1999/09/16 18:26:29 mud Exp $";
d2459 10
@


1.137
log
@Change Restore to give "bishops" their +100 sac points
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.136 1999/09/15 03:57:27 mud Exp $";
d2545 1
a2545 1
    sprintf( buf, "Fighting: %s  Riding: %s  Passenger: %s  Remort: %s  ",
d2548 1
a2548 3
  victim->passenger ? victim->passenger->name : "(none)",
  IS_NPC(victim) ? "" : IS_SET(victim->act,PLR_WERE) ? "garou" :
    IS_SET(victim->act,PLR_VAMP) ? "nosferatu" : "(none)");
d2551 4
a2554 2
    sprintf( buf2, "Deity: %s (%d / %d)\n\r",
        deity_table[victim->pcdata->deity].pname,
@


1.136
log
@funky new creation system
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.135 1999/09/02 03:15:38 mud Exp $";
d3894 4
@


1.135
log
@Mounted code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.134 1999/09/01 19:00:10 mud Exp $";
d5364 1
a5364 1
      "[17] Get Color",
@


1.134
log
@Added port to socket
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.133 1999/09/01 18:20:01 mud Exp $";
d2545 1
a2545 1
    sprintf( buf, "Fighting: %s  Remort: %s  ",
d2547 2
@


1.133
log
@added port to sockets
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.132 1999/08/28 21:17:14 mud Exp $";
d5418 1
a5418 1
            sprintf( buf + strlen(buf), "[%2d] %-18s %-15s %s\n\r",
d5423 1
a5423 1
          d->host
@


1.132
log
@Added reward 'all'
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.131 1999/08/23 03:34:41 mud Exp $";
d5401 1
a5401 1
              sprintf( buf + strlen(buf), "[%2d] %-18s %s@@%s\n\r",
d5406 1
a5406 1
                d->host);            
@


1.131
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.130 1999/08/13 21:35:50 mud Exp $";
d99 25
d159 1
a159 1
	sprintf(arg,"Your range is limineted to +/- %d.\n\r",range);
@


1.130
log
@Listen command
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.129 1999/08/12 13:33:09 mud Exp $";
d636 1
d661 1
d1709 1
d1716 1
d1753 1
d1766 1
d1823 1
a1823 1

d1879 1
a1879 1
 
d5748 1
@


1.129
log
@ fixed bug in using guild for /4's


 Rage:wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.128 1999/08/11 03:36:26 mud Exp $";
d66 15
@


1.128
log
@Added explode
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.127 1999/08/09 22:08:26 mud Exp $";
d814 1
a814 1
	 && (!is_clan(ch) || ch->pcdata->rank < MAX_RANK)
@


1.127
log
@Removed all of Rusty's cheat codes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.126 1999/08/04 14:45:18 mud Exp $";
d5707 1
a5707 1
/* void do_explode ( CHAR_DATA *ch, char *argument )
d5810 1
a5810 1
} */
@


1.126
log
@ Enabled guilding for clanners of rank /4

 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.125 1999/07/27 15:02:05 mud Exp $";
d2435 1
a2435 1
  get_curr_stat(victim,STAT_STR) +(IS_SET(victim->act,PLR_OLD)?-1:0),
d2437 1
a2437 1
  get_curr_stat(victim,STAT_INT) +(IS_SET(victim->act,PLR_OLD)?-1:0),
d2439 1
a2439 1
  get_curr_stat(victim,STAT_WIS) +(IS_SET(victim->act,PLR_OLD)?-1:0),
d2441 1
a2441 1
  get_curr_stat(victim,STAT_DEX) +(IS_SET(victim->act,PLR_OLD)?-1:0),
d2443 1
a2443 1
  get_curr_stat(victim,STAT_CON) +(IS_SET(victim->act,PLR_OLD)?-1:0));
@


1.125
log
@Comment out date thing in do_mstat for now, too tired to work
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.124 1999/07/27 14:58:09 mud Exp $";
d834 1
a834 1
    if (!IS_IMMORTAL(ch) && ch->pcdata->rank == MAX_RANK && ( 
@


1.124
log
@declare strtime
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.123 1999/07/27 14:50:45 mud Exp $";
d2608 2
a2609 1
    strtime       = ctime( &ch->pcdata->created_date );
d2613 1
@


1.123
log
@Add display of created date in stat, this wont work I can tell
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.122 1999/07/23 20:10:15 mud Exp $";
d2391 1
a2607 1
    char *strtime;
@


1.122
log
@Remove MHS_UNAPPROVE from do_rename
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.121 1999/07/23 20:08:28 mud Exp $";
d2605 6
@


1.121
log
@Remove Approve stuff
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.120 1999/07/23 20:01:08 mud Exp $";
a5996 3
	/* autoname approval for renamed chars*/
	if ( IS_SET(victim->mhs, MHS_UNAPPROVED ) )
	  REMOVE_BIT(victim->mhs, MHS_UNAPPROVED);
@


1.120
log
@Removing Approval Code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.119 1999/07/23 04:33:15 mud Exp $";
a5905 41
/* Remove approve command, no longer needed with Rename 
void do_approve( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char arg[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    bool fPload = FALSE;

    argument = one_argument( argument, arg );
    one_argument( argument, arg2 );
  
    if ( !str_cmp( arg2, "-p" ) ) /* use pload */
    {
	do_pload( ch, arg );
	fPload = TRUE;
    }

    if ( ( victim = get_char_world( ch, arg ) ) == NULL )
    {
	send_to_char("Victim not found.  Try -p to use pload.\n\r",ch);
	return;
    }

    if ( !IS_SET(victim->mhs, MHS_UNAPPROVED ) )
    {
	send_to_char("Already approved.\n\r",ch);
        if ( fPload )
		do_punload( ch, arg );
        return;
    }

    REMOVE_BIT( victim->mhs, MHS_UNAPPROVED );

    if ( fPload )
		do_punload( ch, arg );

    send_to_char("Name approved.\n\r",ch);
    return;

}
*/
@


1.119
log
@Add a nonclan message to imm who did it
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.118 1999/07/23 04:07:18 mud Exp $";
d5906 1
d5946 1
a5946 1

@


1.118
log
@Restore Changes, now a restore noncln
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.117 1999/07/23 03:48:35 mud Exp $";
d3809 1
a3809 1
	 (!str_cmp(arg,"nonclan") || !str_cmp(arg,"all"))
d3842 5
a3846 1
  send_to_char("All active players restored.\n\r",ch);
@


1.117
log
@Restore All wont restore players with a quit_timer, meaning they are or
just were in  a pfight
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.116 1999/07/14 18:13:28 mud Exp $";
d3808 2
a3809 1
    if ( get_trust(ch) >=  MAX_LEVEL - 1 && !str_cmp(arg,"all"))
d3819 3
@


1.116
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: act_wiz.c,v 1.113 1999/07/10 00:11:35 mud Exp $";
d3816 2
a3817 1
      if (victim == NULL || IS_NPC(victim))
@


1.115
log
@added in an auto-approve to the rename command
changed level of farsee to 53 for all classes, just so
it's still there, but not usable by morts.

Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.114 1999/07/13 07:26:55 mud Exp $ */
@


1.114
log
@rename command
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.113 1999/07/10 00:11:35 mud Exp $ */
d6028 4
@


1.113
log
@Name approval
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.112 1999/07/07 06:16:44 mud Exp $ */
d5935 96
@


1.112
log
@Not reseting Crusader sac points to 300 on a restore all
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.111 1999/07/05 00:54:19 mud Exp $ */
d5896 41
@


1.111
log
@MHS Set ability
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.110 1999/07/05 00:47:45 mud Exp $ */
d3829 4
@


1.110
log
@Adding MHS to set
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.109 1999/07/02 01:30:37 mud Exp $ */
d4496 1
a4496 1
       if ( IS_SET(victim->mhs,arg3))
d4498 1
a4498 1
          REMOVE_BIT(victim->mhs,arg3);
d4504 1
a4504 1
	  SET_BIT(victim->mhs,arg3);
@


1.109
log
@quick fix to loner typed twice
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.108 1999/07/02 00:40:25 mud Exp $ */
d4487 22
@


1.108
log
@Must type Loner twice to loner, just like delete
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.107 1999/06/20 20:29:19 mud Exp $ */
a532 5

  if(argument[0] != '\0')
    {
   send_to_char("Just type 'loner' with no argument to Loner yourself.\n\r",ch);   return;
    }
@


1.107
log
@Bladesinger
Battlerager
Done
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.106 1999/06/17 15:36:09 mud Exp $ */
d539 13
a551 3
  if( ( !is_clan(ch) && ch->level >=5 && ch->level <= 25 )|| 
      ( ch->clan == clan_lookup("outcast") && ch->pcdata->outcT <= 0 ) )
    {
d557 13
a569 2
      send_to_char("You are now a Loner.\n\r",ch);
      ch->clan = clan_lookup("loner");
d571 7
a577 1
    }
a578 2
  send_to_char("You don't qualify.\n\r",ch);
  return;
@


1.106
log
@Addded NOCLAN room flag not allowing clanners in rooms
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.105 1999/06/11 23:21:51 mud Exp $ */
d4467 28
@


1.105
log
@Stuff I changed.  mostly updates of existing files and changes to seer
and flee.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.104 1999/05/26 03:27:28 mud Exp $ */
d1648 1
a1648 1
  if ( !is_room_owner(ch,location) && room_is_private( location ) 
d1704 1
a1704 1
    if (!is_room_owner(ch,location) && room_is_private( location ) 
d1759 1
a1759 1
    if (!is_room_owner(ch,location) && room_is_private(location) 
d1816 1
a1816 1
    if (!room_is_private( location ))
d1953 1
a1953 1
    &&  room_is_private( location ) && !IS_TRUSTED(ch,IMPLEMENTOR))
d3167 1
a3167 1
    &&  room_is_private(victim->in_room) && !IS_TRUSTED(ch,IMPLEMENTOR))
d5160 1
a5160 1
    &&  room_is_private(location) && !IS_TRUSTED(ch,IMPLEMENTOR))
d5460 1
a5460 1
        &&  room_is_private(victim->in_room) && !IS_TRUSTED(ch,IMPLEMENTOR))
@


1.104
log
@Changes to add in garotte item types and add the garotte
skill to assassins.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.103 1999/05/19 18:18:46 mud Exp $ */
d951 1
a951 1
    if (ch->level > 5 || IS_NPC(ch))
d955 8
@


1.103
log
@Added a check to make sure the number for clone didn't
do some goofy shit.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.102 1999/05/17 21:28:22 mud Exp $ */
d2192 3
@


1.102
log
@Remove Shapeshifter Debug from mstat
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.101 1999/05/16 20:51:50 mud Exp $ */
d3315 6
@


1.101
log
@All this just to debug
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.100 1999/05/16 20:49:47 mud Exp $ */
a2601 29
sprintf( buf,
   "Perm: %d %d %d %d %d\n\r",
   victim->perm_stat[STAT_STR],
   victim->perm_stat[STAT_INT],
   victim->perm_stat[STAT_WIS],
   victim->perm_stat[STAT_DEX],
   victim->perm_stat[STAT_CON]);
send_to_char(buf,ch);

sprintf( buf,
   "Mod: %d %d %d %d %d\n\r",
   victim->mod_stat[STAT_STR],
   victim->mod_stat[STAT_INT],
   victim->mod_stat[STAT_WIS],
   victim->mod_stat[STAT_DEX],
   victim->mod_stat[STAT_CON]);
send_to_char(buf,ch);

if (IS_SET(victim->mhs,MHS_SHAPESHIFTED))
{
sprintf( buf,
   "Save: %d %d %d %d %d\n\r",
   victim->save_stat[STAT_STR],
   victim->save_stat[STAT_INT],
   victim->save_stat[STAT_WIS],
   victim->save_stat[STAT_DEX],
   victim->save_stat[STAT_CON]);
send_to_char(buf,ch);
}
@


1.100
log
@Missing () in debuging
-Poq
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.99 1999/05/16 20:48:02 mud Exp $ */
d2620 1
a2620 1
if (IS_SET(victim,MHS_SHAPESHIFTED))
@


1.99
log
@Shapeshifter debugging
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.98 1999/05/16 20:39:24 mud Exp $ */
d2620 1
a2620 1
if IS_SET(victim,MHS_SHAPESHIFTED)
@


1.98
log
@Debug code for Shapeshifting
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.97 1999/05/16 04:42:54 mud Exp $ */
d2603 6
a2608 3
   "Perm: %s %s %s %s %s\n\r",victim->perm_stat[0],victim->perm_stat[1],
   victim->perm_stat[2],
      victim->perm_stat[3],victim->perm_stat[4]);
d2612 6
a2617 3
   "Mod: %s %s %s %s %s\n\r",victim->mod_stat[0],victim->mod_stat[1],
   victim->mod_stat[2],
      victim->mod_stat[3],victim->mod_stat[4]);
d2619 1
d2623 6
a2628 3
   "Save: %s %s %s %s %s\n\r",victim->save_stat[0],victim->save_stat[1],
   victim->save_stat[2],
      victim->save_stat[3],victim->save_stat[4]);
@


1.97
log
@Shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.96 1999/05/05 21:54:14 mud Exp $ */
d2602 20
a2621 1
    return;
@


1.96
log
@Fixed crash bug with do_mstat() and matook timer pcdata.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.95 1999/05/04 01:04:15 mud Exp $ */
d2520 1
a2520 1
      sprintf(buf, "Matook: %d\n\r",(int) (victim->pcdata->matookT));
@


1.95
log
@Debugging Matook Timer
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.94 1999/05/04 00:57:41 mud Exp $ */
d2497 1
a2497 1
    sprintf( buf, "Carry number: %d  Carry weight: %ld   Kit: %s Matook: %d\n\r",
d2499 1
a2499 1
  !victim->kit ? "none" : kit_table[victim->kit].name,(int) (victim->pcdata->matookT)/120 );
d2516 1
a2516 1
    sprintf(buf, "MHS: %s\n\r",mhs_bit_name(victim->mhs));
d2518 7
@


1.94
log
@Move where Matook Counter displays in mstat
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.93 1999/05/04 00:49:03 mud Exp $ */
d862 1
a862 1
	  if (ch->pcdata->matookT < 12000)
d882 1
@


1.93
log
@View Matook Timer in Stat
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.92 1999/05/04 00:47:20 mud Exp $ */
d2444 1
a2444 1
sprintf( buf, "Attempts: %d  Kills: %d  Deaths: %d Outcast: %d Ruffian: %d Matook: %d\n\r",
d2447 1
a2447 1
       victim->pcdata->ruffT,(int) (victim->pcdata->matookT)/120); 
d2496 1
a2496 1
    sprintf( buf, "Carry number: %d  Carry weight: %ld   Kit: %s\n\r",
d2498 1
a2498 1
  !victim->kit ? "none" : kit_table[victim->kit].name );
@


1.92
log
@Matook Guilding only after 100 hours
-poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.91 1999/05/04 00:43:29 mud Exp $ */
d2447 1
a2447 1
       victim->pcdata->ruffT,(int) (victim->pcdata->matookT)/120)); 
@


1.91
log
@Matooker Timer and only Matookers with 100 hours can Guild
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.90 1999/04/24 02:04:50 mud Exp $ */
d864 1
a864 1
	     send_to_char("You have not the wisdom to guild into Matook."\n\r",ch);
@


1.90
log
@Added the mutant's timer to the mstat command
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.89 1999/04/23 23:43:38 mud Exp $ */
d861 7
d2444 1
a2444 1
sprintf( buf, "Attempts: %d  Kills: %d  Deaths: %d Outcast: %d Ruffian: %d\n\r",
d2447 1
a2447 1
       victim->pcdata->ruffT); 
@


1.89
log
@Change all PLR_HIGHLANDER to MHS_HIGHLANDER and moved under MHS bit
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.88 1999/04/23 21:45:14 mud Exp $ */
d2498 1
a2498 1
      "Age: %d  Played: %d  Last Level: %d  Timer: %d   BTimer: %d\n\r",
d2503 2
a2504 1
      victim->pcdata->barbarian);
@


1.88
log
@A small function for the OLC port to list out object materials
to the log file.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.87 1999/04/20 17:11:23 mud Exp $ */
d753 1
a753 1
      if (!str_prefix("win",arg2) && IS_SET(victim->act,PLR_HIGHLANDER))
d758 1
a758 1
	 REMOVE_BIT(victim->act,PLR_HIGHLANDER);
d762 1
a762 1
      if (IS_SET(victim->act,PLR_HIGHLANDER))
d769 1
a769 1
	 REMOVE_BIT(victim->act,PLR_HIGHLANDER);
d773 1
a773 1
      if (!IS_SET(victim->act,PLR_HIGHLANDER)) 
d777 1
a777 1
         SET_BIT(victim->act,PLR_HIGHLANDER);
d2444 1
a2444 1
     if(!IS_NPC(victim) && IS_SET(victim->act,PLR_HIGHLANDER))
@


1.87
log
@Added function to log all the material names to build a material table.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.86 1999/04/17 09:30:55 mud Exp $ */
a358 1
    extern int top_obj_index;
d367 1
a367 1
    for ( vnum = 0; vnum < top_obj_index; vnum++ )                            
@


1.86
log
@Allow 58's to set skills
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.85 1999/04/17 07:08:05 mud Exp $ */
d355 25
@


1.85
log
@Highlander Highlander Highlander where does it all end?
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.84 1999/04/17 06:46:26 mud Exp $ */
d4295 1
a4295 1
  if( ch->level < MAX_LEVEL -1 && ch->icg != ICG_ADMIN)
@


1.84
log
@Fixing do_highlander
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.83 1999/04/17 06:39:34 mud Exp $ */
d729 1
a729 1
      if (!str_cmp(arg2,"wins"))
@


1.83
log
@Adding Highlander wins
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.82 1999/04/17 06:17:46 mud Exp $ */
d714 1
a714 1
   if (arg1 == '\0')
d729 1
a729 1
      if (str_cmp(arg2,"wins"))
@


1.82
log
@Missing " in Highlander Stuff
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.81 1999/04/17 06:09:31 mud Exp $ */
d714 7
a720 1
   if ( arg1 != '\0' && IS_IMMORTAL(ch))
a755 4
   }
   else
   {
      send_to_char("Put Highlander List Here",ch);
@


1.81
log
@More Highlande stuff
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.80 1999/04/17 01:35:16 mud Exp $ */
d725 1
a725 1
         send_to_char("You have one The Prize! Congratulations Highlander!\n\r,victim);
@


1.80
log
@Highlander changes
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.79 1999/04/15 03:06:26 mud Exp $ */
d707 2
a708 1
   char arg[MAX_INPUT_LENGTH];
d711 2
a712 1
   argument = one_argument(argument, arg);
d714 1
a714 1
   if ( arg != '\0' && IS_IMMORTAL(ch))
d717 1
a717 1
      if ( ( victim = get_char_world( ch, arg ) ) == NULL )
d723 9
d740 1
d742 2
a743 1
      else
d748 1
d753 1
a753 1

@


1.79
log
@Fixed messsages in do_highlander
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.78 1999/04/15 02:59:52 mud Exp $ */
d724 4
a727 1
	 send_to_char("You are no longer a Highlander.\n\r",victim);
@


1.78
log
@Fix arg1 to arg in do_highlander
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.77 1999/04/15 02:56:11 mud Exp $ */
d723 2
a724 2
	 send_to_char("They are no longer a Highlander.",ch);
	 send_to_char("You are no longer a Highlander.",victim);
d729 2
a730 2
	 send_to_char("They are now a Highlander.",ch);
	 send_to_char("The Quickening runs through your veins, you are now a Highlander!",victim);
@


1.77
log
@Added do_highlander for setting highlander bit and for checking highlanders
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.76 1999/04/14 23:46:22 mud Exp $ */
d715 1
a715 1
      if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
@


1.76
log
@Highlander Counts added to stat
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.75 1999/04/12 22:18:25 mud Exp $ */
d704 38
@


1.75
log
@Added do_pur cause a couple lazy Imms keep purging players they
mean to Purr
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.74 1999/04/11 17:50:37 mud Exp $ */
d2362 8
@


1.74
log
@Take away IMM stuff when demoting someone so
they don't get anything they shouldn't have at their
new level.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.73 1999/04/11 05:26:05 mud Exp $ */
d3403 6
@


1.73
log
@Blasted Loner bug
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.72 1999/04/11 05:22:49 mud Exp $ */
d3554 7
d4223 6
@


1.72
log
@Fix bug in Loners for NonReclasses
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.71 1999/04/11 03:43:02 mud Exp $ */
d515 1
a515 1
  if( ( !is_clan(ch) && ch->level >=5 && ch->level <= 25 || 
@


1.71
log
@All done. Matookers can now remove themselves and Guild Others in
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.70 1999/04/11 03:35:34 mud Exp $ */
d515 1
a515 2
  if( ( !is_clan(ch) && ch->level >=5 && ch->level <= 25 
	&& (IS_SET(ch->act,PLR_CANCLAN))) ||
d518 5
@


1.70
log
@Couple of syntax errors in last check for Guild Matook
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.69 1999/04/11 03:28:31 mud Exp $ */
a711 1
	 send_to_char(buf,ch);
d794 1
a794 1
		send_to_char("They must first type 'join matook'.",ch);
@


1.69
log
@Check Matooker Guild to verify Victim has joined Matook
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.68 1999/04/11 03:23:42 mud Exp $ */
d779 1
a779 1
	     if (IS_CLAN(victim))
d786 1
a786 1
		If (victim->join == ch->clan) 
@


1.68
log
@Bulletproofing Matook Guild so they cant guild Clanners
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.67 1999/04/11 03:10:41 mud Exp $ */
d786 1
a786 1
		If (str_cmp(victim->join,"matook") == 0)
@


1.67
log
@Remove Comments , Finish up Allowing Matookers to Guild and UnGuild
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.66 1999/04/11 02:59:06 mud Exp $ */
d779 20
a798 4
             send_to_char("You are now a member of Matook.\n\r",victim);
	     send_to_char("They are now a member of Matook.\n\r",ch);
	     victim->clan = ch->clan;
	     return;
@


1.66
log
@Oh Pookie was a srotrong lad Pookie was a strong lad
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.65 1999/04/11 02:45:22 mud Exp $ */
a711 1
sprintf(buf,"You should not be here!0, %s\n\r",clan_table[ch->clan].name);
a729 1
   send_to_char("First check\n\r",ch);
a757 1
send_to_char("You are here, almost there\n\r",ch);
d777 12
a788 4
          send_to_char("You are now a member of Matook.\n\r",victim);
	  send_to_char("They are now a member of Matook.\n\r",ch);
	  victim->clan = ch->clan;
	  return;
a790 1
send_to_char("Too far, tis is past the lloop\n\r",ch);
a831 1
send_to_char("You made it!\n\r",ch);
@


1.65
log
@Almost got it and a one and a two and a three
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.64 1999/04/11 02:19:10 mud Exp $ */
d762 1
a762 1
       && (str_cmp(clan_table[ch->clan].name,"matook") != 0))
@


1.64
log
@More debug messages , I'm so close I can taste it
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.63 1999/04/11 01:59:07 mud Exp $ */
a760 13
    if( IS_IMMORTAL(ch))
   {

    if (!str_prefix(arg2,"none"))
    {
  send_to_char("They are now clanless.\n\r",ch);
  send_to_char("You are now a member of no clan!\n\r",victim);
  victim->clan = 0;
  return;
    }


send_to_char("2\n\r",ch);
d762 1
a762 1
         && (str_cmp(clan_table[ch->clan].name,"matook") != 0)) 
a763 1
send_to_char("3\n\r",ch);
d766 3
a768 4
send_to_char("4\n\r",ch);
	  if (ch->name == victim->name)
	  {
	     send_to_char("You are no longer a member of Matook.\n\r",ch);
d771 1
a771 1
	  }
d774 2
a775 2
	     send_to_char("You are not permitted to remove someone other then yourself from Matook.\n\r",ch);
	     return;
d780 1
a780 1
	  send_to_char("You are now a member of Matook.\n\r",victim);
d782 2
a783 2
          victim->clan = ch->clan;
          return;
d786 12
a798 1
send_to_char("5\n\r",ch);
@


1.63
log
@Finishing up Matook guilding
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.62 1999/04/11 01:40:16 mud Exp $ */
d772 2
d777 1
d780 1
d802 1
@


1.62
log
@And in the days of Old, Tiama roared her ugly head...
-Poquah the novelist in log files
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.61 1999/04/11 01:29:39 mud Exp $ */
d770 26
@


1.61
log
@And Hell said the Devil is where you shall lie
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.60 1999/04/11 01:22:41 mud Exp $ */
d708 3
a710 4
 /*   if ( ch->level < MAX_LEVEL - 4 
	 && (!is_clan(ch) || ch->pcdata->rank < MAX_RANK
	 */
if ( str_cmp(clan_table[ch->clan].name,"matook") != 0) 
d714 1
a716 5
if ( str_cmp(clan_table[ch->clan].name,"matook") == 0) 
	 {
sprintf(buf,"You should not be here==0, %s\n\r",clan_table[ch->clan].name);
	 send_to_char(buf,ch);
}	
@


1.60
log
@Extra bracket
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.59 1999/04/11 01:20:53 mud Exp $ */
d713 1
a713 1
sprintf(buf,"You should not be here, %s\n\r",clan_table[ch->clan].name);
a714 1
	return;
d717 5
@


1.59
log
@Still going.. energizer bunny
-Pookie
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.58 1999/04/11 01:05:08 mud Exp $ */
d711 1
a711 1
if ( str_cmp(clan_table[ch->clan].name,"matook") != 0) )
@


1.58
log
@Try something else for Matook
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.57 1999/04/11 00:57:09 mud Exp $ */
d708 1
a708 1
    if ( ch->level < MAX_LEVEL - 4 
d710 2
a711 1
	 || str_cmp(clan_table[ch->clan].name,"matook") != 0) )
@


1.57
log
@Matook Guilding
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.56 1999/04/11 00:39:27 mud Exp $ */
d710 1
a710 1
	 || !str_cmp(clan_table[ch->clan].name,"matook")) )
@


1.56
log
@Debugging more Matook stuff
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.55 1999/04/11 00:31:54 mud Exp $ */
d710 1
a710 1
	 || clan_table[ch->clan].name != "matook") )
@


1.55
log
@Still working on Matook Guilding
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.54 1999/04/11 00:22:47 mud Exp $ */
d711 3
d715 1
@


1.54
log
@Threw in some Debug messages
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.53 1999/04/11 00:09:20 mud Exp $ */
d710 1
a710 1
	 || ch->clan != "matook") )
@


1.53
log
@Started adding in Matook ability to flag in own memebers
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.52 1999/04/10 02:46:38 mud Exp $ */
d727 1
d756 1
d797 1
@


1.52
log
@check IS_SET not !IS_SET for do_loner PLR_CANCLAN
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.51 1999/04/10 02:37:09 mud Exp $ */
d708 3
a710 1
    if ( ch->level < MAX_LEVEL - 4 && (!is_clan(ch) || ch->pcdata->rank < MAX_RANK) )
@


1.51
log
@Adding check to do_loner for PLR_CANCLAN
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.50 1999/04/01 23:54:29 mud Exp $ */
d516 1
a516 1
	&& (!IS_SET(ch->act,PLR_CANCLAN))) ||
@


1.50
log
@Set ruffian timer to 0 in pardon killer
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.49 1999/03/30 15:23:44 mud Exp $ */
d515 2
a516 1
  if( ( !is_clan(ch) && ch->level >=5 && ch->level <= 25 ) ||
@


1.49
log
@Added a RUFFIAN flag timer so they eventually wear off.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.48 1999/03/25 01:40:33 mud Exp $ */
d1289 1
@


1.48
log
@Check for Notes in Progress before Rebooting
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.47 1999/03/15 21:27:06 mud Exp $ */
d527 6
d2296 4
a2299 3
        sprintf( buf, "Attempts: %d  Kills: %d  Deaths: %d Outcast: %d\n\r",
                victim->killer_data[PC_ATTACKS] /2, victim->killer_data[PC_KILLS],  
                victim->killer_data[PC_DEATHS], victim->pcdata->outcT); 
@


1.47
log
@Allow IMM's to use Outcast command on others.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.46 1999/01/04 20:13:31 mud Exp $ */
d2745 1
d2749 22
@


1.46
log
@Fixed remort outcasts not being able to Loner themselves.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.45 1999/01/03 17:22:08 mud Exp $ */
d541 3
a543 2
  if (argument[0] != '\0' && 
	(ch->pcdata->rank != 5 || !is_clan(ch) || clan_table[ch->clan].independent) )
d550 1
a550 1
    if (argument[0] != '\0' && is_clan(ch) && !clan_table[ch->clan].independent
d552 1
d556 1
a556 1
	if(victim != NULL && is_same_clan(ch,victim) && victim->pcdata->rank < 5 )
@


1.45
log
@Fixed armor size out of range crash bug in do_ostat()
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.44 1998/12/09 08:50:24 mud Exp $ */
d505 2
a506 1
     || (!IS_NPC(ch) && (IS_SET(ch->act,PLR_WERE) || IS_SET(ch->act,PLR_VAMP)) )
@


1.44
log
@Few information things
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.43 1998/12/09 01:20:37 mud Exp $ */
d2065 2
a2066 1
	  obj->value[3],obj_size_table[obj->value[4]].name );
@


1.43
log
@Bug fixes
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.42 1998/12/08 04:51:04 mud Exp $ */
d2346 3
@


1.42
log
@Added stuff to wiznet stat
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.41 1998/11/28 07:49:30 mud Exp $ */
d2331 1
a2331 1
  !ch->kit ? "none" : kit_table[ch->kit].name );
@


1.41
log
@favored flag
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.40 1998/11/17 23:20:09 mud Exp $ */
d2329 3
a2331 2
    sprintf( buf, "Carry number: %d  Carry weight: %ld\n\r",
  victim->carry_number, get_carry_weight(victim) / 10 );
d2338 1
a2338 1
      "Age: %d  Played: %d  Last Level: %d  Timer: %d\n\r",
d2342 2
a2343 1
      victim->timer );
@


1.40
log
@Hopefully fixed the wholist and also added outcast changes
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.39 1998/11/16 11:37:03 mud Exp $ */
d808 1
a808 1
        obj = create_object( get_obj_index(OBJ_VNUM_SCHOOL_BANNER), 0 );
d816 1
a816 1
  obj = create_object( get_obj_index(OBJ_VNUM_SCHOOL_VEST), 0 );
d838 1
a838 1
      obj = create_object(get_obj_index(vnum),0);
d847 1
a847 1
        obj = create_object( get_obj_index(OBJ_VNUM_SCHOOL_SHIELD), 0 );
d3036 1
a3036 1
      t_obj = create_object(c_obj->pIndexData,0);
d3115 1
a3115 1
    clone = create_object(obj->pIndexData,0); 
d3168 1
a3168 1
      new_obj = create_object(obj->pIndexData,0);
d3292 1
a3292 1
    obj = create_object( pObjIndex, level );
@


1.39
log
@more avarice stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.38 1998/10/22 04:54:36 mud Exp $ */
d514 2
a515 1
  if(!is_clan(ch) && ch->level >= 5 && ch->level <= 25)
d521 2
@


1.38
log
@added casting level to mstat
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.37 1998/10/19 06:09:15 mud Exp $ */
d712 1
a712 1
    if (ch->pcdata->rank == MAX_RANK && ( 
d756 6
@


1.37
log
@*** empty log message ***
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.36 1998/10/19 04:35:31 mud Exp $ */
d64 2
d2255 1
a2255 1
  "Lv: %d  Cls: %s %s  A;ign: %d  Go: %ld  Si: %ld  XP: %d\n\r",
d2311 1
a2311 1
      "Thirst: %d  Hunger: %d  Full: %d  Drunk: %d\n\r",
d2315 2
a2316 1
      victim->pcdata->condition[COND_DRUNK] );
@


1.36
log
@CVeward command added
s beginning with `CVS:' are removed automatically
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.35 1998/10/17 07:12:10 mud Exp $ */
d65 1
d71 1
d94 28
d127 2
@


1.35
log
@New reclass stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.34 1998/10/13 03:02:02 mud Exp $ */
d65 32
@


1.34
log
@change Outcast time to 30 hours for forced outcasting
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.33 1998/10/12 23:29:06 mud Exp $ */
d2189 1
a2189 1
  "Lv: %d  Class: %s  Align: %d  Gold: %ld  Silver: %ld  Exp: %d\n\r",
d2191 1
d4262 30
@


1.33
log
@All bugs cleard.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.32 1998/10/12 23:05:59 mud Exp $ */
d488 1
a488 1
	    victim->pcdata->outcT = 1800;
@


1.32
log
@fucking bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.31 1998/10/12 21:46:08 mud Exp $ */
d661 1
a661 1
		class_table[ch->class].reclass == TRUE )
@


1.31
log
@Fixed bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.30 1998/10/12 19:49:13 mud Exp $ */
d660 2
a661 2
	if(!IS_SET(victim->act,PLR_CANCLAN) &&
		class_table[ch->class].reclass )
@


1.30
log
@a
REclass changes.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.29 1998/10/12 07:40:09 mud Exp $ */
d661 1
a661 1
	    IS_SET(victim->act,PLR_RECLASS) )
@


1.29
log
@Bug fixed
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.28 1998/10/12 07:36:43 mud Exp $ */
d659 7
@


1.28
log
@Added lag command
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.27 1998/10/12 07:28:53 mud Exp $ */
d56 1
@


1.27
log
@Nottil imped
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.26 1998/10/09 05:50:39 mud Exp $ */
d3787 1
a3787 1
	send_to_Char("Notitles set.\n\r",ch);
d3794 39
@


1.26
log
@Fixed a bug, yanked crap in comm.c
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.25 1998/10/09 04:59:49 mud Exp $ */
d3742 52
d3803 1
a3803 1
  send_to_char( "Notell whom?", ch );
@


1.25
log
@get_char_world() crash fix
-Ruty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.24 1998/10/09 04:55:09 mud Exp $ */
d5342 1
a5342 1
                                                                                
d5348 2
a5349 1
     }                                                                          
d5363 8
@


1.24
log
@Took out debugging shit.
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.23 1998/10/09 04:53:33 mud Exp $ */
d5358 1
d5360 2
@


1.23
log
@finally fixed it
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.22 1998/10/09 04:36:43 mud Exp $ */
a5288 2
	send_to_char(ch->pcdata->hostmask,ch);
	send_to_char("\n\r",ch);
a5332 6
	send_to_char(argN,ch);
	send_to_char("\n\r",ch);
	send_to_char(arg1,ch);
	send_to_char("\n\r",ch);
	send_to_char(arg2,ch);
	send_to_char("\n\r",ch);
a5333 2
	send_to_char(arg3,ch);
	send_to_char("\n\r",ch);
a5334 2
	send_to_char(arg3,ch);
	send_to_char("\n\r",ch);
a5335 2
	send_to_char(arg3,ch);
	send_to_char("\n\r",ch);
a5359 2
	send_to_char(victim->pcdata->hostmask,ch);
	send_to_char("\n\r",ch);
@


1.22
log
@conflict resolution
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.21 1998/10/09 04:33:33 mud Exp $ */
a5376 1
     victim->desc->host = str_dup(arg2);
@


1.21
log
@Last go befoer bed
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.20 1998/10/09 04:18:31 mud Exp $ */
d5289 2
d5374 3
@


1.20
log
@Debugging
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.19 1998/10/09 04:14:08 mud Exp $ */
d5371 1
a5371 1
     strcpy(arg2,victim->pcdata->hostmask);
@


1.19
log
@Think I got it
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.18 1998/10/09 03:57:37 mud Exp $ */
d5334 4
@


1.18
log
@Same shit
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.17 1998/10/09 03:48:32 mud Exp $ */
d5334 2
a5335 1
	one_argument(argN,argN);
d5337 2
a5338 1
	one_argument(argN,argN);
d5340 1
d5343 1
@


1.17
log
@Argument probs with hostname
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.16 1998/10/09 03:19:44 mud Exp $ */
d5334 1
a5334 1
	one_argument(argN,arg3);
d5336 1
a5336 1
	one_argument(argN,arg3);
@


1.16
log
@str_dup() to strcpy() conversions for non-pointer copying os hostmask value
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.15 1998/10/09 02:56:55 mud Exp $ */
d5281 1
a5281 1
     char argN[MAX_INPUT_LENGTH];                                               
a5283 1
     int i;
d5289 1
a5289 1
     strcpy(argument,argN);
d5333 5
a5337 2
     for( i=1;i<4;i++)
     {
a5339 1
     }
@


1.15
log
@fixes to hostmask
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.14 1998/10/09 02:30:13 mud Exp $ */
d5362 1
a5362 1
     victim->pcdata->hostmask = str_dup(arg2);
@


1.14
log
@Added 'hostmask' command.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.13 1998/10/08 14:17:49 mud Exp $ */
d29 2
a5282 2
     char *pwdnew;                                                              
     char *p;                                                                   
d5284 1
d5290 1
a5290 1
     argN = str_dup(argument);
d5334 1
a5334 1
     for( i=1,i<4,i++)
@


1.13
log
@s/pc_data/pcdata
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.12 1998/10/08 14:14:24 mud Exp $ */
d5272 94
@


1.12
log
@Added timers to being an Outcast.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.11 1998/09/01 23:50:56 mud Exp $ */
d650 1
a650 1
	if(victim->pc_data->outcT > 0)
@


1.11
log
@Security hidden char changes
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.10 1998/08/30 03:33:32 mud Exp $ */
d485 1
d509 1
d650 6
d2200 1
a2200 1
        sprintf( buf, "Approximate Attempts: %d  Kills: %d  Deaths: %d\n\r",
d2202 1
a2202 1
                victim->killer_data[PC_DEATHS]); 
@


1.10
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.9 1998/08/21 14:21:08 mud Exp $ */
d2775 1
a2775 1
    if ( victim->desc->snoop_by != NULL || IS_SET(victim->act,PLR_OLD) )
@


1.9
log
@I dunno
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.8 1998/08/20 21:05:27 mud Exp $ */
d269 1
a269 1
	if(IS_SET(d->character->act,PLR_COLOR))
d5129 1
a5129 1
    if (IS_SET(ch->comm,COMM_DISP_VNUM))     
d5132 1
a5132 1
      REMOVE_BIT(ch->comm,COMM_DISP_VNUM); 
d5137 1
a5137 1
      SET_BIT(ch->comm,COMM_DISP_VNUM);
@


1.8
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.7 1998/08/07 20:19:54 mud Exp $ */
d448 1
a448 1
      ch->pcdata->clan = clan_lookup("loner");
d469 1
a469 1
	(ch->pcdata->rank != 5 || !is_clan(ch) || clan_table[ch->pcdata->clan].independent) )
d476 1
a476 1
    if (argument[0] != '\0' && is_clan(ch) && !clan_table[ch->pcdata->clan].independent
d483 1
a483 1
	    victim->pcdata->clan = clan_lookup("outcast");
d503 1
a503 1
    if(argument[0] == '\0' && is_clan(ch) && !clan_table[ch->pcdata->clan].independent)
d506 1
a506 1
	  ch->pcdata->clan = clan_lookup("outcast");
d643 2
a644 2
	&& victim->join == ch->pcdata->clan) || (is_clan(victim) && 
	clan_table[victim->pcdata->clan].independent && victim->join == ch->pcdata->clan)
d648 1
a648 1
	victim->pcdata->clan = ch->pcdata->clan;
d651 1
a651 1
	  capitalize(clan_table[victim->pcdata->clan].name));
d663 1
a663 1
  victim->pcdata->clan = 0;
d690 1
a690 1
    victim->pcdata->clan = clan;
d1186 1
a1186 1
    victim->pcdata->trumps = 0;
d2107 1
d2205 1
a2205 1
    sprintf( buf, "Fighting: %s  Remort: %s  Deity: %s (%d / %d)\n\r",
d2208 13
a2220 3
    IS_SET(victim->act,PLR_VAMP) ? "nosferatu" : "(none)",
  IS_NPC(victim) ? "(none)" : deity_table[victim->pcdata->deity].pname,
	victim->pcdata->sac,(int) ((victim->played - victim->pcdata->switched)/3600));
@


1.7
log
@Room affects stuff for traps.
Bleed/vampire changes.
swim/scan start at 50% and 50%up for free for existing characters.
moved trap to after trip in interp list for grandfathered use
- Both of Us
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.6 1998/08/04 19:24:13 mud Exp $ */
d360 1
a360 1
    if (ch->rank < MAX_RANK && !IS_IMMORTAL(ch))
d396 1
a396 1
    if ( victim->rank == MAX_RANK && !IS_IMMORTAL(ch) )
d402 1
a402 1
    victim->rank = num;
d448 1
a448 1
      ch->clan = clan_lookup("loner");
d469 1
a469 1
	(ch->rank != 5 || !is_clan(ch) || clan_table[ch->clan].independent) )
d476 2
a477 2
    if (argument[0] != '\0' && is_clan(ch) && !clan_table[ch->clan].independent
	&& ch->rank == 5 )
d481 1
a481 1
	if(victim != NULL && is_same_clan(ch,victim) && victim->rank < 5 )
d483 2
a484 2
	    victim->clan = clan_lookup("outcast");
	    victim->rank = 0;
d503 1
a503 1
    if(argument[0] == '\0' && is_clan(ch) && !clan_table[ch->clan].independent)
d506 2
a507 2
	  ch->clan = clan_lookup("outcast");
	  ch->rank = 0;
d624 1
a624 1
    if ( ch->level < MAX_LEVEL - 4 && (!is_clan(ch) || ch->rank < MAX_RANK) )
d641 1
a641 1
    if (ch->rank == MAX_RANK && ( 
d643 2
a644 2
	&& victim->join == ch->clan) || (is_clan(victim) && 
	clan_table[victim->clan].independent && victim->join == ch->clan)
d648 1
a648 1
	victim->clan = ch->clan;
d651 1
a651 1
	  capitalize(clan_table[victim->clan].name));
d663 1
a663 1
  victim->clan = 0;
d690 1
a690 1
    victim->clan = clan;
d1186 1
a1186 1
    victim->trumps = 0;
d2208 2
a2209 2
  IS_NPC(victim) ? "(none)" : deity_table[victim->deity].pname,
	victim->sac,(int) ((victim->played - victim->switched)/3600));
d3468 1
a3468 1
            victim->sac = (victim->class == class_lookup("paladin")) ? 600:300;
d4125 1
a4125 1
     victim->sac = value;
@


1.6
log
@s screen doesn't handle VI well)

Changed bleed to depend upon condition of fullness/hunger.
We're just going to test this out and see how well it works.
If it's not working out, we'll go back to the old way.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.5 1998/08/04 18:11:31 mud Exp $ */
d1683 1
d1771 9
@


1.5
log
@Fixed a memory bug (do_quit) before act(victim);
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.4 1998/08/04 18:03:05 mud Exp $ */
d108 1
a108 1
  act("You pull $N from the void",ch,NULL,d.character,TO_CHAR);
@


1.4
log
@Added pload and punload, small mods to deny to allow for the bit to be removed.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.3 1998/08/04 17:21:35 mud Exp $ */
a157 2
  do_quit(victim,"");
 
d162 4
a165 2
       
} /* end do_punload */
@


1.3
log
@* Changed level field to 2 spaces instead of 3
* Added nonote command
* Added a 'set hours' ability
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.2 1998/08/01 13:46:05 mud Exp $ */
d62 104
d792 1
a792 2
        send_to_char( "The gods have restored your writing
priviliges.\n\r",
d801 1
a801 2
        send_to_char( "The gods have revoked your writing 
priviliges.\n\r",
d1048 2
d1057 10
a1066 1

@


1.2
log
@Added RUFFIAN flag logic
@
text
@d18 1
a18 1
/* @@(#)$Id: act_wiz.c,v 1.1 1998/06/16 17:49:15 mud Exp $ */
d659 51
a709 1
     
d3907 14
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d1024 2
@
