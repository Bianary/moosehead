head	1.311;
access;
symbols;
locks; strict;
comment	@ * @;


1.311
date	2004.10.20.18.59.00;	author rusty;	state Exp;
branches;
next	1.310;

1.310
date	2004.07.09.19.29.30;	author boogums;	state Exp;
branches;
next	1.309;

1.309
date	2004.03.27.15.51.40;	author boogums;	state Exp;
branches;
next	1.308;

1.308
date	2004.02.04.02.53.01;	author boogums;	state Exp;
branches;
next	1.307;

1.307
date	2004.01.11.22.07.29;	author boogums;	state Exp;
branches;
next	1.306;

1.306
date	2003.12.09.21.33.31;	author rusty;	state Exp;
branches;
next	1.305;

1.305
date	2003.12.06.22.43.42;	author boogums;	state Exp;
branches;
next	1.304;

1.304
date	2003.11.30.01.23.04;	author boogums;	state Exp;
branches;
next	1.303;

1.303
date	2003.11.30.01.19.40;	author boogums;	state Exp;
branches;
next	1.302;

1.302
date	2003.11.29.23.37.37;	author boogums;	state Exp;
branches;
next	1.301;

1.301
date	2003.11.29.23.31.32;	author boogums;	state Exp;
branches;
next	1.300;

1.300
date	2003.11.22.03.34.19;	author boogums;	state Exp;
branches;
next	1.299;

1.299
date	2003.10.08.00.49.27;	author ndagger;	state Exp;
branches;
next	1.298;

1.298
date	2003.09.15.17.18.19;	author rusty;	state Exp;
branches;
next	1.297;

1.297
date	2003.09.15.17.09.47;	author rusty;	state Exp;
branches;
next	1.296;

1.296
date	2003.08.25.22.57.55;	author boogums;	state Exp;
branches;
next	1.295;

1.295
date	2003.08.25.22.56.23;	author boogums;	state Exp;
branches;
next	1.294;

1.294
date	2003.06.14.19.53.10;	author boogums;	state Exp;
branches;
next	1.293;

1.293
date	2003.06.04.19.56.03;	author boogums;	state Exp;
branches;
next	1.292;

1.292
date	2003.06.03.03.13.07;	author boogums;	state Exp;
branches;
next	1.291;

1.291
date	2003.02.20.19.01.53;	author rusty;	state Exp;
branches;
next	1.290;

1.290
date	2003.02.05.05.17.15;	author boogums;	state Exp;
branches;
next	1.289;

1.289
date	2003.01.06.02.55.52;	author boogums;	state Exp;
branches;
next	1.288;

1.288
date	2002.12.23.01.54.33;	author boogums;	state Exp;
branches;
next	1.287;

1.287
date	2002.12.23.00.37.27;	author boogums;	state Exp;
branches;
next	1.286;

1.286
date	2002.11.26.05.35.26;	author boogums;	state Exp;
branches;
next	1.285;

1.285
date	2002.10.26.02.43.18;	author boogums;	state Exp;
branches;
next	1.284;

1.284
date	2002.10.12.03.07.35;	author boogums;	state Exp;
branches;
next	1.283;

1.283
date	2002.10.10.03.13.19;	author boogums;	state Exp;
branches;
next	1.282;

1.282
date	2002.09.29.02.02.35;	author boogums;	state Exp;
branches;
next	1.281;

1.281
date	2002.09.29.01.25.02;	author boogums;	state Exp;
branches;
next	1.280;

1.280
date	2002.09.29.01.11.57;	author boogums;	state Exp;
branches;
next	1.279;

1.279
date	2002.09.28.16.36.40;	author boogums;	state Exp;
branches;
next	1.278;

1.278
date	2002.09.28.15.19.24;	author boogums;	state Exp;
branches;
next	1.277;

1.277
date	2002.09.26.04.24.02;	author boogums;	state Exp;
branches;
next	1.276;

1.276
date	2002.09.24.03.15.33;	author boogums;	state Exp;
branches;
next	1.275;

1.275
date	2002.09.24.03.10.02;	author boogums;	state Exp;
branches;
next	1.274;

1.274
date	2002.09.24.02.19.43;	author boogums;	state Exp;
branches;
next	1.273;

1.273
date	2002.09.24.02.05.49;	author boogums;	state Exp;
branches;
next	1.272;

1.272
date	2002.09.22.23.28.36;	author boogums;	state Exp;
branches;
next	1.271;

1.271
date	2002.09.22.23.24.21;	author boogums;	state Exp;
branches;
next	1.270;

1.270
date	2002.09.22.23.20.21;	author boogums;	state Exp;
branches;
next	1.269;

1.269
date	2002.09.20.02.42.28;	author boogums;	state Exp;
branches;
next	1.268;

1.268
date	2002.09.15.23.35.34;	author boogums;	state Exp;
branches;
next	1.267;

1.267
date	2002.09.15.23.24.40;	author boogums;	state Exp;
branches;
next	1.266;

1.266
date	2002.09.11.18.23.27;	author boogums;	state Exp;
branches;
next	1.265;

1.265
date	2002.08.17.17.34.25;	author mud;	state Exp;
branches;
next	1.264;

1.264
date	2002.06.20.15.55.00;	author rusty;	state Exp;
branches;
next	1.263;

1.263
date	2002.06.14.20.15.05;	author mud;	state Exp;
branches;
next	1.262;

1.262
date	2002.06.14.19.42.03;	author mud;	state Exp;
branches;
next	1.261;

1.261
date	2002.06.14.19.33.26;	author rusty;	state Exp;
branches;
next	1.260;

1.260
date	2002.06.11.18.26.04;	author mud;	state Exp;
branches;
next	1.259;

1.259
date	2002.06.11.18.24.52;	author rusty;	state Exp;
branches;
next	1.258;

1.258
date	2002.04.17.15.24.17;	author poquah;	state Exp;
branches;
next	1.257;

1.257
date	2002.04.11.16.55.35;	author poquah;	state Exp;
branches;
next	1.256;

1.256
date	2002.04.03.15.57.22;	author mud;	state Exp;
branches;
next	1.255;

1.255
date	2002.04.03.15.56.19;	author rusty;	state Exp;
branches;
next	1.254;

1.254
date	2002.04.01.21.05.43;	author rusty;	state Exp;
branches;
next	1.253;

1.253
date	2002.03.23.17.34.45;	author rusty;	state Exp;
branches;
next	1.252;

1.252
date	2002.03.12.03.01.07;	author rusty;	state Exp;
branches;
next	1.251;

1.251
date	2002.03.11.06.24.38;	author rusty;	state Exp;
branches;
next	1.250;

1.250
date	2002.03.10.22.26.14;	author rusty;	state Exp;
branches;
next	1.249;

1.249
date	2002.03.09.19.14.27;	author rusty;	state Exp;
branches;
next	1.248;

1.248
date	2002.02.28.19.24.46;	author rusty;	state Exp;
branches;
next	1.247;

1.247
date	2002.02.11.19.38.23;	author poquah;	state Exp;
branches;
next	1.246;

1.246
date	2002.02.11.18.34.10;	author poquah;	state Exp;
branches;
next	1.245;

1.245
date	2002.01.26.16.25.27;	author rage;	state Exp;
branches;
next	1.244;

1.244
date	2001.12.14.21.27.12;	author poquah;	state Exp;
branches;
next	1.243;

1.243
date	2001.12.14.20.09.36;	author poquah;	state Exp;
branches;
next	1.242;

1.242
date	2001.12.14.19.56.12;	author poquah;	state Exp;
branches;
next	1.241;

1.241
date	2001.12.14.19.47.26;	author poquah;	state Exp;
branches;
next	1.240;

1.240
date	2001.12.14.17.04.38;	author poquah;	state Exp;
branches;
next	1.239;

1.239
date	2001.12.14.16.57.09;	author poquah;	state Exp;
branches;
next	1.238;

1.238
date	2001.12.14.16.41.57;	author poquah;	state Exp;
branches;
next	1.237;

1.237
date	2001.12.14.16.25.51;	author poquah;	state Exp;
branches;
next	1.236;

1.236
date	2001.12.14.16.07.48;	author poquah;	state Exp;
branches;
next	1.235;

1.235
date	2001.12.14.03.22.16;	author poquah;	state Exp;
branches;
next	1.234;

1.234
date	2001.12.13.20.43.44;	author poquah;	state Exp;
branches;
next	1.233;

1.233
date	2001.12.13.18.01.29;	author poquah;	state Exp;
branches;
next	1.232;

1.232
date	2001.12.13.17.30.31;	author poquah;	state Exp;
branches;
next	1.231;

1.231
date	2001.12.13.17.08.06;	author poquah;	state Exp;
branches;
next	1.230;

1.230
date	2001.12.13.15.09.10;	author poquah;	state Exp;
branches;
next	1.229;

1.229
date	2001.12.13.02.44.27;	author poquah;	state Exp;
branches;
next	1.228;

1.228
date	2001.12.13.02.35.50;	author poquah;	state Exp;
branches;
next	1.227;

1.227
date	2001.12.13.02.32.41;	author poquah;	state Exp;
branches;
next	1.226;

1.226
date	2001.12.12.20.37.31;	author poquah;	state Exp;
branches;
next	1.225;

1.225
date	2001.12.12.20.23.51;	author poquah;	state Exp;
branches;
next	1.224;

1.224
date	2001.12.12.20.14.07;	author poquah;	state Exp;
branches;
next	1.223;

1.223
date	2001.12.12.19.56.56;	author poquah;	state Exp;
branches;
next	1.222;

1.222
date	2001.12.07.19.04.19;	author poquah;	state Exp;
branches;
next	1.221;

1.221
date	2001.12.07.19.03.29;	author poquah;	state Exp;
branches;
next	1.220;

1.220
date	2001.12.07.19.00.50;	author poquah;	state Exp;
branches;
next	1.219;

1.219
date	2001.12.07.17.06.47;	author poquah;	state Exp;
branches;
next	1.218;

1.218
date	2001.12.05.17.07.04;	author poquah;	state Exp;
branches;
next	1.217;

1.217
date	2001.12.05.16.43.46;	author poquah;	state Exp;
branches;
next	1.216;

1.216
date	2001.12.05.16.39.01;	author poquah;	state Exp;
branches;
next	1.215;

1.215
date	2001.12.03.18.34.54;	author poquah;	state Exp;
branches;
next	1.214;

1.214
date	2001.12.02.06.05.03;	author boogums;	state Exp;
branches;
next	1.213;

1.213
date	2001.12.01.23.16.57;	author poquah;	state Exp;
branches;
next	1.212;

1.212
date	2001.11.29.17.24.10;	author poquah;	state Exp;
branches;
next	1.211;

1.211
date	2001.11.29.16.41.12;	author poquah;	state Exp;
branches;
next	1.210;

1.210
date	2001.11.29.15.27.52;	author poquah;	state Exp;
branches;
next	1.209;

1.209
date	2001.11.29.09.53.40;	author poquah;	state Exp;
branches;
next	1.208;

1.208
date	2001.11.29.09.38.58;	author poquah;	state Exp;
branches;
next	1.207;

1.207
date	2001.11.29.09.30.52;	author poquah;	state Exp;
branches;
next	1.206;

1.206
date	2001.11.25.04.39.20;	author poquah;	state Exp;
branches;
next	1.205;

1.205
date	2001.11.25.02.35.08;	author rusty;	state Exp;
branches;
next	1.204;

1.204
date	2001.11.25.01.33.20;	author mud;	state Exp;
branches;
next	1.203;

1.203
date	2001.11.25.01.27.47;	author mud;	state Exp;
branches;
next	1.202;

1.202
date	2001.11.25.01.26.38;	author rusty;	state Exp;
branches;
next	1.201;

1.201
date	2001.11.23.16.23.12;	author poquah;	state Exp;
branches;
next	1.200;

1.200
date	2001.11.23.16.17.15;	author poquah;	state Exp;
branches;
next	1.199;

1.199
date	2001.10.12.17.37.25;	author rage;	state Exp;
branches;
next	1.198;

1.198
date	2001.08.19.05.51.07;	author rage;	state Exp;
branches;
next	1.197;

1.197
date	2001.08.18.16.41.25;	author guerrand;	state Exp;
branches;
next	1.196;

1.196
date	2001.07.04.01.46.30;	author guerrand;	state Exp;
branches;
next	1.195;

1.195
date	2001.07.04.01.36.40;	author guerrand;	state Exp;
branches;
next	1.194;

1.194
date	2001.07.04.01.25.52;	author guerrand;	state Exp;
branches;
next	1.193;

1.193
date	2001.07.04.01.21.56;	author guerrand;	state Exp;
branches;
next	1.192;

1.192
date	2001.06.10.05.19.39;	author guerrand;	state Exp;
branches;
next	1.191;

1.191
date	2001.06.01.02.46.14;	author guerrand;	state Exp;
branches;
next	1.190;

1.190
date	2001.05.24.14.45.25;	author poquah;	state Exp;
branches;
next	1.189;

1.189
date	2001.05.24.01.34.57;	author poquah;	state Exp;
branches;
next	1.188;

1.188
date	2001.05.24.01.33.27;	author poquah;	state Exp;
branches;
next	1.187;

1.187
date	2001.05.14.19.57.47;	author rusty;	state Exp;
branches;
next	1.186;

1.186
date	2001.05.14.16.16.52;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	2001.05.14.16.14.27;	author rusty;	state Exp;
branches;
next	1.184;

1.184
date	2001.04.09.19.16.33;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2001.04.09.18.32.15;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	2001.04.09.18.30.39;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	2001.03.25.15.20.26;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	2001.03.21.20.00.35;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	2001.03.21.19.57.07;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	2001.03.21.19.55.13;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	2001.03.21.19.49.03;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	2001.03.06.21.52.48;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	2001.02.20.18.37.49;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	2000.10.16.23.09.31;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	2000.09.10.17.55.44;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	2000.08.28.18.09.22;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	2000.07.25.18.58.29;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	2000.07.25.18.46.01;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	2000.07.25.18.38.57;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	2000.07.25.18.26.06;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	2000.07.18.16.41.22;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	2000.07.17.22.18.54;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	2000.07.17.21.43.58;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	2000.07.13.19.20.52;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	2000.07.13.01.27.30;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	2000.07.13.01.25.20;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	2000.07.12.23.56.24;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	2000.07.12.23.23.09;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	2000.06.23.22.30.44;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	2000.06.23.22.14.27;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	2000.06.21.18.31.27;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	2000.06.21.18.30.22;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	2000.06.19.22.38.15;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	2000.06.19.22.37.04;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	2000.05.20.00.06.49;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	2000.04.24.12.43.14;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	2000.04.22.14.18.01;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	2000.04.18.20.33.48;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	2000.04.18.19.50.55;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	2000.04.17.22.00.47;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	2000.03.23.14.11.31;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	2000.03.20.23.10.54;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	2000.03.18.22.43.38;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	2000.03.18.22.22.12;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	2000.03.18.22.04.17;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	2000.03.18.20.08.10;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	2000.03.18.20.01.02;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	2000.03.18.19.53.55;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	2000.03.12.00.32.42;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	2000.03.08.14.50.28;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	2000.03.06.16.50.18;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	2000.03.06.15.59.19;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	2000.02.29.20.55.42;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	2000.02.25.02.20.59;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	2000.02.25.01.54.19;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	2000.02.25.01.20.57;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	2000.02.25.00.59.51;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	2000.02.24.19.09.23;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	2000.02.23.05.32.03;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	2000.02.15.23.42.32;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	2000.02.15.23.24.42;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	2000.02.15.22.19.59;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	2000.02.15.22.17.21;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	2000.02.15.22.06.24;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	2000.02.15.19.02.18;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	2000.02.12.14.33.03;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	2000.02.11.20.20.40;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	2000.02.11.00.35.26;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	2000.02.11.00.12.09;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	2000.02.10.23.28.50;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	2000.02.10.21.17.11;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2000.02.10.19.11.48;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	2000.02.10.03.05.10;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	2000.02.10.02.23.11;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	2000.02.10.02.14.51;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	2000.02.10.02.05.36;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	2000.02.10.01.47.44;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	2000.02.10.01.17.58;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	2000.02.10.00.56.27;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	2000.02.10.00.52.25;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	2000.02.10.00.49.53;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	2000.02.10.00.20.14;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	2000.02.09.23.40.08;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	2000.02.09.23.36.17;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	2000.02.09.23.03.03;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2000.02.09.23.01.55;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2000.02.09.22.01.14;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2000.02.08.23.05.42;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2000.02.08.21.56.27;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2000.02.08.02.53.44;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	2000.02.08.01.31.17;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	2000.02.05.01.28.17;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	2000.02.04.02.21.46;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	2000.02.04.02.18.44;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	2000.02.01.02.55.34;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	2000.02.01.02.33.08;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	2000.01.31.21.37.51;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	2000.01.31.21.01.55;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	2000.01.28.22.38.42;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	2000.01.20.23.33.32;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	2000.01.17.22.45.14;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	2000.01.17.22.44.29;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	2000.01.17.22.43.14;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	2000.01.09.01.53.23;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	2000.01.09.01.19.42;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	2000.01.09.01.10.02;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	2000.01.09.01.06.49;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	2000.01.09.01.02.20;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.12.24.16.34.41;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.12.22.18.20.19;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	99.12.04.04.39.16;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	99.12.02.22.53.41;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	99.11.23.21.53.17;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	99.11.23.21.44.15;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	99.11.23.20.04.13;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	99.11.23.19.54.51;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	99.11.21.21.50.39;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	99.11.02.07.51.16;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	99.10.31.02.33.11;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	99.10.31.02.23.22;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	99.10.21.02.53.15;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	99.10.10.17.24.22;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	99.10.10.15.18.46;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	99.10.07.01.48.00;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	99.10.05.23.50.46;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	99.10.05.23.41.49;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.09.25.01.08.16;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.09.25.00.46.45;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.09.25.00.17.17;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.09.19.07.21.11;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.09.16.04.19.20;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.09.15.16.51.45;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.09.15.06.00.12;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.09.15.05.49.50;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.09.15.05.25.50;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.09.15.05.16.49;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.09.15.05.11.34;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.09.15.05.03.03;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.09.15.04.54.07;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.09.15.04.39.10;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.09.15.04.22.34;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.09.15.03.57.29;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.08.23.03.34.42;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.08.16.20.46.00;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.08.12.01.12.14;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.08.12.01.03.54;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.07.27.13.00.02;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	99.07.26.20.31.06;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.07.23.20.01.10;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.07.14.18.13.30;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.07.10.00.11.36;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	99.07.05.23.24.30;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.06.20.20.29.20;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	99.05.18.23.01.51;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.05.18.23.00.42;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	99.05.15.21.56.41;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	99.05.05.19.13.15;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	99.05.02.15.33.47;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	99.04.23.00.09.38;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	99.01.18.17.38.45;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.12.29.20.35.01;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.12.13.22.06.24;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.12.09.01.46.35;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.12.09.01.20.38;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.11.28.19.32.41;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.11.28.07.49.31;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.11.21.00.13.43;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.11.19.08.03.32;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.11.19.07.22.11;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.11.14.07.15.50;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.10.11.05.22.24;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.10.09.14.17.53;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.10.09.05.50.40;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.10.09.02.30.14;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.09.20.03.46.45;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.09.01.23.50.57;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.08.30.03.33.33;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.08.21.00.52.14;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.08.20.21.05.28;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.17.20.04.58;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.13.05.24.07;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.12.08.20.14;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.07.20.19.55;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.05.07.30.30;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.04.21.37.29;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.04.20.21.52;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.16;	author mud;	state Exp;
branches;
next	;


desc
@@


1.311
log
@made bans only dump people on GAME_VERSION and not in OLC
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku vMud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Thanks to abaddon for proof-reading our comm.c and pointing out bugs.  *
 *  Any remaining bugs are, of course, our work, not his.  :)              *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/


/*
 * This file contains all of the OS-dependent stuff:
 *   startup, signals, BSD sockets for tcp/ip, i/o, timing.
 *
 * The data flow for input is:
 *    Game_loop ---> Read_from_descriptor ---> Read
 *    Game_loop ---> Read_from_buffer
 *
 * The data flow for output is:
 *    Game_loop ---> Process_Output ---> Write_to_descriptor -> Write
 *
 * The OS-dependent functions are Read_from_descriptor and Write_to_descriptor.
 * -- Furey  26 Jan 1993
 */

static char rcsid[] = "$Id: comm.c,v 1.310 2004/07/09 19:29:30 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include "gc.h"
#include <unistd.h>
#include <signal.h>
#include <ctype.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
/*
#include <sys/ipc.h>
#include <sys/msg.h>
*/
#include <sys/time.h>
#include <sys/resource.h>
#include "merc.h"
#include "recycle.h"
#include "gladiator.h"
#include "tables.h"
/* #include "imc.h"
 * #include "imc-mercbase.h"
 * #include "icec.h"
 * #include "icec-mercbase.h"
 */
/* command procedures needed */
DECLARE_DO_FUN	( action_wraithform );
DECLARE_DO_FUN (action_zealot_convert);
DECLARE_DO_FUN   ( action_ambush );
DECLARE_DO_FUN(do_help          );
DECLARE_DO_FUN(do_look          );
DECLARE_DO_FUN(do_skills        );
DECLARE_DO_FUN(do_outfit        );
DECLARE_DO_FUN(do_count		);
DECLARE_DO_FUN(do_unread        );
/* External Functions */
int	clan_lookup	args( (const char *name) );

/*
 * Malloc debugging stuff.
 */
#if defined(sun)
#undef MALLOC_DEBUG
#endif

#if defined(MALLOC_DEBUG)
#include <malloc.h>
extern  int     malloc_debug    args( ( int  ) );
extern  int     malloc_verify   args( ( void ) );
#endif



/*
 * Signal handling.
 * Apollo has a problem with __attribute(atomic) in signal.h,
 *   I dance around it.
 */
#if defined(apollo)
#define __attribute(x)
#endif

#if defined(unix)
#include <signal.h>
#include <sys/ipc.h>
#endif

#if defined(apollo)
#undef __attribute
#endif



/*
 * Socket and TCP/IP stuff.
 */
#if     defined(macintosh) || defined(MSDOS)
const   char    echo_off_str    [] = { '\0' };
const   char    echo_on_str     [] = { '\0' };
const   char    go_ahead_str    [] = { '\0' };
#endif

#if     defined(unix)
#include <fcntl.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/telnet.h>
const   char    echo_off_str    [] = { IAC, WILL, TELOPT_ECHO, '\0' };
const   char    echo_on_str     [] = { IAC, WONT, TELOPT_ECHO, '\0' };
const   char    go_ahead_str    [] = { IAC, GA, '\0' };
#endif



/*
 * OS-dependent declarations.
 */
#if     defined(_AIX)
#include <sys/select.h>
int     accept          args( ( int s, struct sockaddr *addr, int *addrlen ) );
int     bind            args( ( int s, struct sockaddr *name, int namelen ) );
void    bzero           args( ( char *b, int length ) );
int     getpeername     args( ( int s, struct sockaddr *name, int *namelen ) );
int     getsockname     args( ( int s, struct sockaddr *name, int *namelen ) );
int     gettimeofday    args( ( struct timeval *tp, struct timezone *tzp ) );
int     listen          args( ( int s, int backlog ) );
int     setsockopt      args( ( int s, int level, int optname, void *optval,
          int optlen ) );
int     socket          args( ( int domain, int type, int protocol ) );
#endif

#if     defined(apollo)
#include <unistd.h>
void    bzero           args( ( char *b, int length ) );
#endif

#if     defined(__hpux)
int     accept          args( ( int s, void *addr, int *addrlen ) );
int     bind            args( ( int s, const void *addr, int addrlen ) );
void    bzero           args( ( char *b, int length ) );
int     getpeername     args( ( int s, void *addr, int *addrlen ) );
int     getsockname     args( ( int s, void *name, int *addrlen ) );
int     gettimeofday    args( ( struct timeval *tp, struct timezone *tzp ) );
int     listen          args( ( int s, int backlog ) );
int     setsockopt      args( ( int s, int level, int optname,
        const void *optval, int optlen ) );
int     socket          args( ( int domain, int type, int protocol ) );
#endif

#if     defined(interactive)
#include <net/errno.h>
#include <sys/fnctl.h>
#endif

#if     defined(linux)
int     accept          args( ( int s, struct sockaddr *addr, int *addrlen ) );
int     bind            args( ( int s, struct sockaddr *name, int namelen ) );
int     close           args( ( int fd ) );
int     getpeername     args( ( int s, struct sockaddr *name, int *namelen ) );
int     getsockname     args( ( int s, struct sockaddr *name, int *namelen ) );
int     gettimeofday    args( ( struct timeval *tp, struct timezone *tzp ) );
int     listen          args( ( int s, int backlog ) );
int     read            args( ( int fd, char *buf, int nbyte ) );
int     select          args( ( int width, fd_set *readfds, fd_set *writefds,
          fd_set *exceptfds, struct timeval *timeout ) );
int     socket          args( ( int domain, int type, int protocol ) );
int     write           args( ( int fd, char *buf, int nbyte ) );
#endif

#if     defined(macintosh)
#include <console.h>
#include <fcntl.h>
#include <unix.h>
struct  timeval
{
  time_t  tv_sec;
  time_t  tv_usec;
};
#if     !defined(isascii)
#define isascii(c)              ( (c) < 0200 )
#endif
static  long                    theKeys [4];

int     gettimeofday            args( ( struct timeval *tp, void *tzp ) );
#endif

#if     defined(MIPS_OS)
extern  int             errno;
#endif

#if     defined(MSDOS)
int     gettimeofday    args( ( struct timeval *tp, void *tzp ) );
int     kbhit           args( ( void ) );
#endif

#if     defined(NeXT)
int     close           args( ( int fd ) );
int     fcntl           args( ( int fd, int cmd, int arg ) );
#if     !defined(htons)
u_short htons           args( ( u_short hostshort ) );
#endif
#if     !defined(ntohl)
u_long  ntohl           args( ( u_long hostlong ) );
#endif
int     read            args( ( int fd, char *buf, int nbyte ) );
int     select          args( ( int width, fd_set *readfds, fd_set *writefds,
          fd_set *exceptfds, struct timeval *timeout ) );
int     write           args( ( int fd, char *buf, int nbyte ) );
#endif

#if     defined(sequent)
int     accept          args( ( int s, struct sockaddr *addr, int *addrlen ) );
int     bind            args( ( int s, struct sockaddr *name, int namelen ) );
int     close           args( ( int fd ) );
int     fcntl           args( ( int fd, int cmd, int arg ) );
int     getpeername     args( ( int s, struct sockaddr *name, int *namelen ) );
int     getsockname     args( ( int s, struct sockaddr *name, int *namelen ) );
int     gettimeofday    args( ( struct timeval *tp, struct timezone *tzp ) );
#if     !defined(htons)
u_short htons           args( ( u_short hostshort ) );
#endif
int     listen          args( ( int s, int backlog ) );
#if     !defined(ntohl)
u_long  ntohl           args( ( u_long hostlong ) );
#endif
int     read            args( ( int fd, char *buf, int nbyte ) );
int     select          args( ( int width, fd_set *readfds, fd_set *writefds,
          fd_set *exceptfds, struct timeval *timeout ) );
int     setsockopt      args( ( int s, int level, int optname, caddr_t optval,
          int optlen ) );
int     socket          args( ( int domain, int type, int protocol ) );
int     write           args( ( int fd, char *buf, int nbyte ) );
#endif

/* This includes Solaris Sys V as well */
#if defined(sun)
int     accept          args( ( int s, struct sockaddr *addr, int *addrlen ) );
int     bind            args( ( int s, struct sockaddr *name, int namelen ) );
void    bzero           args( ( char *b, int length ) );
int     close           args( ( int fd ) );
int     getpeername     args( ( int s, struct sockaddr *name, int *namelen ) );
int     getsockname     args( ( int s, struct sockaddr *name, int *namelen ) );
int     gettimeofday    args( ( struct timeval *tp, struct timezone *tzp ) );
int     listen          args( ( int s, int backlog ) );
int     read            args( ( int fd, char *buf, int nbyte ) );
int     select          args( ( int width, fd_set *readfds, fd_set *writefds,
          fd_set *exceptfds, struct timeval *timeout ) );
#if defined(SYSV)
int setsockopt          args( ( int s, int level, int optname,
          const char *optval, int optlen ) );
#else
int     setsockopt      args( ( int s, int level, int optname, void *optval,
          int optlen ) );
#endif
int     socket          args( ( int domain, int type, int protocol ) );
int     write           args( ( int fd, char *buf, int nbyte ) );
#endif

#if defined(ultrix)
int     accept          args( ( int s, struct sockaddr *addr, int *addrlen ) );
int     bind            args( ( int s, struct sockaddr *name, int namelen ) );
void    bzero           args( ( char *b, int length ) );
int     close           args( ( int fd ) );
int     getpeername     args( ( int s, struct sockaddr *name, int *namelen ) );
int     getsockname     args( ( int s, struct sockaddr *name, int *namelen ) );
int     gettimeofday    args( ( struct timeval *tp, struct timezone *tzp ) );
int     listen          args( ( int s, int backlog ) );
int     read            args( ( int fd, char *buf, int nbyte ) );
int     select          args( ( int width, fd_set *readfds, fd_set *writefds,
          fd_set *exceptfds, struct timeval *timeout ) );
int     setsockopt      args( ( int s, int level, int optname, void *optval,
          int optlen ) );
int     socket          args( ( int domain, int type, int protocol ) );
int     write           args( ( int fd, char *buf, int nbyte ) );
#endif



/*
 * Global variables.
 */
DESCRIPTOR_DATA *   descriptor_list;    /* All open descriptors         */
DESCRIPTOR_DATA *   d_next;             /* Next descriptor in loop      */
FILE *              fpReserve;          /* Reserved file handle         */
bool                god;                /* All new chars are gods!      */
bool                merc_down;          /* Shutdown                     */
bool                wizlock;            /* Game is wizlocked            */
bool                newlock;            /* Game is newlocked            */
bool		    no_dns;
char                str_boot_time[MAX_INPUT_LENGTH];
time_t              current_time;       /* time of this pulse */        
bool		    telnet;		/* if we're binding to the telnet port*/
sh_int		    avarice_kills;
sh_int		    demise_kills;
sh_int		    honor_kills;
sh_int		    posse_kills;
sh_int		    warlock_kills;
sh_int		    zealot_kills;
sh_int              honor_demise_kills;
sh_int		    posse_killer_kills;
sh_int		    posse_thief_kills;
sh_int		    posse_thug_kills;
sh_int		    posse_ruffian_kills;

/*
 * OS-dependent local functions.
 */
#if defined(macintosh) || defined(MSDOS)
void    game_loop_mac_msdos     args( ( void ) );
bool    read_from_descriptor    args( ( DESCRIPTOR_DATA *d ) );
bool    write_to_descriptor     args( ( int desc, char *txt, int length ) );
#endif

#if defined(unix)
#define PERMS  0666
key_t msg_key;
int   msg_id;

void    game_loop_unix          args( ( int control[] ) );
int     init_socket             args( ( int port ) );
void    init_descriptor         args( ( int control ) );
bool    read_from_descriptor    args( ( DESCRIPTOR_DATA *d ) );
bool    write_to_descriptor     
	args( ( int desc, char *txt, int length, DESCRIPTOR_DATA *d ) );
#endif




/*
 * Other local functions (OS-independent).
 */
bool    check_parse_name        args( ( char *name ) );
bool    check_reconnect         args( ( DESCRIPTOR_DATA *d, char *name,
            bool fConn ) );
bool    check_playing           args( ( DESCRIPTOR_DATA *d, char *name ) );
int     main                    args( ( int argc, char **argv ) );
void    nanny                   args( ( DESCRIPTOR_DATA *d, char *argument ) );
void    show_stats		args( ( DESCRIPTOR_DATA *d ) );
int 	calc_stat_cost		args( ( CHAR_DATA *ch, int attr_type ) );
bool	can_use_points		args( ( CHAR_DATA *ch, int points ) );
bool    process_output          args( ( DESCRIPTOR_DATA *d, bool fPrompt ) );
void    read_from_buffer        args( ( DESCRIPTOR_DATA *d ) );
void    stop_idling             args( ( CHAR_DATA *ch ) );
void    bust_a_prompt           args( ( CHAR_DATA *ch ) );
bool    check_mob_name          args( ( char *name, bool old_char ) );

int main( int argc, char **argv )
{
    struct timeval now_time;
    int port;

#if defined(unix)
    int control[2] = {-1,-1};
#endif

    /*
     * Memory debugging if needed.
     */
#if defined(MALLOC_DEBUG)
    malloc_debug( 2 );
#endif

    /*
     * Init time.
     */
    gettimeofday( &now_time, NULL );
    current_time        = (time_t) now_time.tv_sec;
    strcpy( str_boot_time, ctime( &current_time ) );

    /*
     * Macintosh console initialization.
     */
#if defined(macintosh)
    console_options.nrows = 31;
    cshow( stdout );
    csetmode( C_RAW, stdin );
    cecho2file( "log file", 1, stderr );
#endif

    /* Set our eUID to that of the user 'mud' */
    seteuid(MUD_UID);

    /*
     * Reserve one channel for our use.
     */
    if ( ( fpReserve = fopen( NULL_FILE, "r" ) ) == NULL )
    {
  perror( NULL_FILE );
  exit( 1 );
    }

    /*
     * Get the port number.
     */
    port = 4000;
    if ( argc > 1 )
    {
  if ( !is_number( argv[1] ) )
  {
      fprintf( stderr, "Usage: %s [port #]\n", argv[0] );
      exit( 1 );
  }

  port = atoi( argv[1] );
  /*
  else if ( ( port = atoi( argv[1] ) ) <= 1024 )
  {
      fprintf( stderr, "Port number must be above 1024.\n" );
      exit( 1 );
  }
   */
    }

    /*
     * Run the game.
     */
#if defined(macintosh) || defined(MSDOS)
    boot_db( );
    log_string( "Merc is ready to rock." );
    game_loop_mac_msdos( );
#endif

#if defined(unix)
    telnet=FALSE;
    control[0] = init_socket( port );
    if( seteuid(0) == 0 )
    {
      telnet = TRUE;
      control[1] = init_socket( 23 );
    }
    if( telnet ) seteuid(MUD_UID);
    boot_db( );
/****
#ifdef IMC_GAME_VERSION
    imc_startup("/mud/moosehead/imc/");  
    icec_init();          
#endif
 ****/
    sprintf( log_buf, "MHS is ready on port %d.", port );
    log_string( log_buf );
#ifdef GAME_VERSION
    /* renice to 4 because we run on a shared machine 
    setpriority(PRIO_PROCESS,0,4);
     */
#else
    /* OLC version needs even less CPU time allocated to it */
    setpriority(PRIO_PROCESS,0,9);
#endif
    game_loop_unix( control );
/****
#ifdef IMC_GAME_VERSION
    imc_shutdown();
#endif
 ****/
    close (control[0]);
    if( telnet )
      close (control[1]);
#endif

    /*
     * That's all, folks.
     */
    log_string( "Normal termination of game." );
    exit( 0 );
    return 0;
}



#if defined(unix)
int init_socket( int port )
{
    static struct sockaddr_in sa_zero;
    struct sockaddr_in sa;
    int x = 1;
    int fd;

    if ( ( fd = socket( AF_INET, SOCK_STREAM, 0 ) ) < 0 )
    {
  perror( "Init_socket: socket" );
  exit( 1 );
    }

    if ( setsockopt( fd, SOL_SOCKET, SO_REUSEADDR,
    (char *) &x, sizeof(x) ) < 0 )
    {
  perror( "Init_socket: SO_REUSEADDR" );
  shutdown( fd, 2);
  close(fd);
  exit( 1 );
    }

/*if defined(SO_DONTLINGER) && !defined(SYSV)*/
    {
  struct  linger  ld;


  ld.l_onoff  = 1;
  ld.l_linger = 1000;

  if ( setsockopt( fd, SOL_SOCKET, SO_LINGER,
  (char *) &ld, sizeof(ld) ) < 0 )
  {
      perror( "Init_socket: SO_LINGER" );
      shutdown( fd, 2);
      close(fd);
      exit( 1 );
  }
    }
/*endif*/

    sa              = sa_zero;
    sa.sin_family   = AF_INET;
    sa.sin_port     = htons( port );

    if ( bind( fd, (struct sockaddr *) &sa, sizeof(sa) ) < 0 )
    {
  perror("Init socket: bind" );
  shutdown( fd, 2 );
  close(fd);
  exit(1);
    }


    if ( listen( fd, 3 ) < 0 )
    {
  perror("Init socket: listen");
  shutdown( fd, 2 );
  close(fd);
  exit(1);
    }

    return fd;
}
#endif



#if defined(macintosh) || defined(MSDOS)
void game_loop_mac_msdos( void )
{
    struct timeval last_time;
    struct timeval now_time;
    static DESCRIPTOR_DATA dcon;

    gettimeofday( &last_time, NULL );
    current_time = (time_t) last_time.tv_sec;

    /*
     * New_descriptor analogue.
     */
    dcon.descriptor     = 0;
    dcon.connected      = CON_GET_NAME;
    dcon.host           = str_dup( "localhost" );
    dcon.outsize        = 2000;
#ifdef OLC_VERSION
    dcon.outbuf         = alloc_mem( dcon.outsize );
#else  /*game version*/
    dcon.outbuf         = GC_MALLOC( dcon.outsize );
#endif
    dcon.next           = descriptor_list;
    dcon.showstr_head   = NULL;
    dcon.showstr_point  = NULL;
    descriptor_list     = &dcon;

    /*
     * Send the greeting.
     */
    {
  extern char * help_greeting;
  if ( help_greeting[0] == '.' )
      write_to_buffer( &dcon, help_greeting+1, 0 );
  else
      write_to_buffer( &dcon, help_greeting  , 0 );
    }

    /* Main loop */
    while ( !merc_down )
    {
  DESCRIPTOR_DATA *d;

  /*
   * Process input.
   */
  for ( d = descriptor_list; d != NULL; d = d_next )
  {
      d_next      = d->next;
      d->fcommand = FALSE;

#if defined(MSDOS)
      if ( kbhit( ) )
#endif
      {
    if ( d->character != NULL )
        d->character->timer = 0;
    if ( !read_from_descriptor( d ) )
    {
        if ( d->character != NULL)
      save_char_obj( d->character );
        d->outtop   = 0;
        close_socket( d );
        continue;
    }
      }

      if (d->character != NULL && d->character->daze > 0)
    --d->character->daze;

      if ( d->character != NULL && d->character->wait > 0 )
      {
    --d->character->wait;
    continue;
      }

      read_from_buffer( d );
      if ( d->incomm[0] != '\0' )
      {
    d->fcommand     = TRUE;
    stop_idling( d->character );
    
    if (d->showstr_point) {
        show_string(d,d->incomm);
    } else  
    if ( d->connected == CON_PLAYING ) {
       if (!check_macro (d->character, d->incomm)) {
        if (d->character->pcdata && d->character->pcdata->macro_count > 0) {
          /* inside a macro, so show command */
          send_to_char (d->incomm,d->character); 
          send_to_char ("\n\r",d->character);
        }          
        substitute_alias( d, d->incomm );
       }
    } else {
      if ( d->connected == CON_EDITOR )
        interpret (d->character, d->incomm);
      else
        nanny( d, d->incomm );
    }

    d->incomm[0]    = '\0';
      }
  }



  /*
   * Autonomous game motion.
   */
  update_handler( );


  /*
   * Output.
   */
  for ( d = descriptor_list; d != NULL; d = d_next )
  {
      d_next = d->next;

      if ( ( d->fcommand || d->outtop > 0 ) )
      {
    if ( !process_output( d, TRUE ) )
    {
        if ( d->character != NULL && d->character->level > 1)
      save_char_obj( d->character );
        d->outtop   = 0;
        close_socket( d );
    }
      }
  }



  /*
   * Synchronize to a clock.
   * Busy wait (blargh).
   */
  now_time = last_time;
  for ( ; ; )
  {
      int delta;

#if defined(MSDOS)
      if ( kbhit( ) )
#endif
      {
    if ( dcon.character != NULL )
        dcon.character->timer = 0;
    if ( !read_from_descriptor( &dcon ) )
    {
        if ( dcon.character != NULL && d->character->level > 1)
      save_char_obj( d->character );
        dcon.outtop = 0;
        close_socket( &dcon );
    }
#if defined(MSDOS)
    break;
#endif
      }

      gettimeofday( &now_time, NULL );
      delta = ( now_time.tv_sec  - last_time.tv_sec  ) * 1000 * 1000
      + ( now_time.tv_usec - last_time.tv_usec );
      if ( delta >= 1000000 / PULSE_PER_SECOND )
    break;
  }
  last_time    = now_time;
  current_time = (time_t) last_time.tv_sec;
    }

    return;
}
#endif



#if defined(unix)

struct my_mesg_buf {
  long mtype;
  char text[1024];
};
/*
void get_ident_info ( CHAR_DATA *ch )
{   
  struct my_mesg_buf buf;  
  int len;
  
  if (!ch->desc || !ch->desc->host) return;
  
  if ( msg_id >= 0 ) {
    sprintf (buf.text,"%s %d %s %d 4000",ch->name,ch->id,ch->desc->host, ch->desc->port );
    buf.mtype = 1;    
    len = strlen (buf.text)+1;
    msgsnd (msg_id, (struct msgbuf *)&buf, len, IPC_NOWAIT );
  }
}

void check_ident_info ( )
{   
  struct my_mesg_buf buf;  
  int id, len;
  char name[1024];
  DESCRIPTOR_DATA *d;
  
  if ( msg_id >= 0 ) {
    len = msgrcv (msg_id, (struct msgbuf *)&buf, 1024, 2, IPC_NOWAIT);
    if ( len > 0 ) {
      sscanf (buf.text,"%d %s",&id,&name[0]);
      if (id > 0)
      for ( d = descriptor_list; d; d = d->next ) {
        if (d->character) {
          if (d->character->id == id) {
            d->name = str_dup ( name );
            sprintf( log_buf, "Ident: %s  %s@@%s.", d->character->name, 
              d->name, d->host );
            log_string( log_buf );
            wiznet(log_buf,NULL,NULL,WIZ_SITES,0,get_trust(d->character));
          }
        }
      }
    }    
  }
}
*/

  /* for a while we're not going to save characters on a crash
   * This should avoid the CPU looping problems.
   *
   Put this back in to save pfiles on our crashes - Poquah
void sig_crash ()
{
  CHAR_DATA *ch, *ch_next;
  
  signal ( SIGSEGV, SIG_DFL );
  signal ( SIGBUS,  SIG_DFL );
  signal ( SIGHUP,  SIG_DFL );  
  signal ( SIGFPE,  SIG_DFL );
  signal ( SIGILL,  SIG_DFL );
  signal ( SIGIOT,  SIG_DFL );
  signal ( SIGKILL,  SIG_DFL );
  signal ( SIGTERM,  SIG_DFL );
           
  for ( ch = char_list; ch != NULL; ch = ch_next ) {
    ch_next = ch->next;
    if (!IS_NPC (ch) ) {
      save_char_obj( ch );
    }
  }
  
  abort ();
}

   */

void dummy()
{
	char log_buf[MAX_STRING_LENGTH];
	sprintf( log_buf, "Alarm set off");
	log_string( log_buf );
	dns_site(NULL,dns_buf);
	return;
}

void game_loop_unix( int control[] )
{
    static struct timeval null_time;
    struct timeval last_time;
    /* int child_pid; */
    
    /*signal ( SIGCLD, SIG_IGN );
    signal ( SIGSEGV, sig_crash );
    signal ( SIGBUS,  sig_crash );
    signal ( SIGHUP,  sig_crash );    
    signal ( SIGFPE,  sig_crash );
    signal ( SIGILL,  sig_crash );
    signal ( SIGIOT,  sig_crash );
    signal ( SIGKILL,  sig_crash );
    signal ( SIGTERM,  sig_crash );
    */
    /* Put above back in to save pfiles for crashes? - Poquah
     */
    signal ( SIGALRM, dummy );
    
	/*
    msg_key = ftok("/mud/moosehead/src/ident.base", 1);
    msg_key = 666666;
    if ( (msg_id = msgget (msg_key, PERMS | IPC_CREAT) ) < 0 )
      bug ("Could not create message queue.",0);
	*/

    signal( SIGPIPE, SIG_IGN );
    gettimeofday( &last_time, NULL );
    current_time = (time_t) last_time.tv_sec;

    /* Main loop */
    while ( !merc_down )
    {
  fd_set in_set;
  fd_set out_set;
  fd_set exc_set;
  DESCRIPTOR_DATA *d;
  int maxdesc=-1;

#if defined(MALLOC_DEBUG)
  if ( malloc_verify( ) != 1 )
      abort( );
#endif

  /*
   * Poll all active descriptors.
   */
  FD_ZERO( &in_set  );
  FD_ZERO( &out_set );
  FD_ZERO( &exc_set );
  FD_SET( control[0], &in_set );
  if(control[0] > maxdesc)
    maxdesc = control[0];
  if( telnet )
  {
  FD_SET( control[1], &in_set );
  if(control[1] > maxdesc)
    maxdesc = control[1];
  }
  for ( d = descriptor_list; d; d = d->next )
  {
      maxdesc = UMAX( maxdesc, d->descriptor );
      FD_SET( d->descriptor, &in_set  );
      FD_SET( d->descriptor, &out_set );
      FD_SET( d->descriptor, &exc_set );
  }

      /* IMC 
       maxdesc=imc_fill_fdsets(maxdesc, &in_set, &out_set, &exc_set);
       */

  if ( select( maxdesc+1, &in_set, &out_set, &exc_set, &null_time ) < 0 )
  {
      perror( "Game_loop: select: poll" );
      exit( 1 );
  }
      /*
       imc_idle_select(&in_set, &out_set, &exc_set, current_time);
       */

  /*
   * New connection?
   */
  if ( FD_ISSET( control[0], &in_set ) )
      init_descriptor( control[0] );
  if( telnet )
  {
  if ( FD_ISSET( control[1], &in_set ) )
      init_descriptor( control[1] );
  }

  /*
   * Kick out the freaky folks.
   */
  for ( d = descriptor_list; d != NULL; d = d_next )
  {
      d_next = d->next;   
      if ( FD_ISSET( d->descriptor, &exc_set ) )
      {
    FD_CLR( d->descriptor, &in_set  );
    FD_CLR( d->descriptor, &out_set );
    if ( d->character && d->character->level > 1)
        save_char_obj( d->character );
    d->outtop       = 0;
    close_socket( d );
      }
  }

  /*
   * Process input.
   */

  for ( d = descriptor_list; d != NULL; d = d_next )
  {
      d_next      = d->next;
      d->fcommand = FALSE;

      if ( FD_ISSET( d->descriptor, &in_set ) )
      {
    if ( d->character != NULL )
        d->character->timer = 0;
    if ( !read_from_descriptor( d ) )
    {
        FD_CLR( d->descriptor, &out_set );
        if ( d->character != NULL && d->character->level > 1)
      save_char_obj( d->character );
        d->outtop   = 0;
        close_socket( d );
        continue;
    }
      }

	/* Here we handle pulse-delayed actions like wraith form */
    if ( d->character != NULL &&  d->character->pcdata != NULL && d->character->pcdata->wraith_timer > 0 )
    {
	    if ( --d->character->pcdata->wraith_timer <= 0 )
		action_wraithform(d->character,"");
	    else
	    if ( d->character->pcdata->wraith_timer % 12 == 0 )
		act("Your form shimmers and fades...",d->character,NULL,NULL,TO_CHAR,FALSE);
    }

      if (d->character != NULL && d->character->daze > 0)
    --d->character->daze;

      if ( d->character != NULL && d->character->wait > 0 )
      {
    --d->character->wait;
    continue;
      }

      read_from_buffer( d );
      if ( d->incomm[0] != '\0' )
      {
    d->fcommand     = TRUE;
    stop_idling( d->character );
    
    if (d->showstr_point) {
        show_string(d,d->incomm);
    } else  
    if ( d->connected == CON_PLAYING ) {
       if (!check_macro (d->character, d->incomm)) {
        if (d->character->pcdata && d->character->pcdata->macro_count > 0) {
          /* inside a macro, so show command */
          send_to_char (d->incomm,d->character); 
          send_to_char ("\n\r",d->character);
        }          
        substitute_alias( d, d->incomm );
       }
    } else {
      if ( d->connected == CON_EDITOR )
        interpret (d->character, d->incomm);
      else
        nanny( d, d->incomm );
    }

    d->incomm[0]    = '\0';
      }
  }



  /*
   * Autonomous game motion.
   */
  update_handler( );

  for ( d = descriptor_list ; d ; d = d->next )
  {
      if ( d->character != NULL &&
	   HAS_KIT(d->character,"nethermancer") )
	   fade( d->character, "" );
  }

/*
  check_ident_info( );
*/

  /*
   * Output.
   */

  for ( d = descriptor_list; d != NULL; d = d_next )
  {
      d_next = d->next;

      if ( ( (d->fcommand) || (d->outtop > 0) )
      &&   (FD_ISSET(d->descriptor, &out_set)) )
      {
    if ( !process_output( d, TRUE ) )
    {
        if ( d->character != NULL && d->character->level > 1)
      save_char_obj( d->character );
        d->outtop   = 0;
        close_socket( d );
    }
      }
  }



  /*
   * Synchronize to a clock.
   * Sleep( last_time + 1/PULSE_PER_SECOND - now ).
   * Careful here of signed versus unsigned arithmetic.
   */
  {
      struct timeval now_time;
      long secDelta;
      long usecDelta;

      gettimeofday( &now_time, NULL );
      usecDelta   = ((int) last_time.tv_usec) - ((int) now_time.tv_usec)
      + 1000000 / PULSE_PER_SECOND;
      secDelta    = ((int) last_time.tv_sec ) - ((int) now_time.tv_sec );
      while ( usecDelta < 0 )
      {
    usecDelta += 1000000;
    secDelta  -= 1;
      }

      while ( usecDelta >= 1000000 )
      {
    usecDelta -= 1000000;
    secDelta  += 1;
      }

      if ( secDelta > 0 || ( secDelta == 0 && usecDelta > 0 ) )
      {
    struct timeval stall_time;

    stall_time.tv_usec = usecDelta;
    stall_time.tv_sec  = secDelta;
    if ( select( 0, NULL, NULL, NULL, &stall_time ) < 0 )
    {
        perror( "Game_loop: select: stall" );
        exit( 1 );
    }
      }
  }

  gettimeofday( &last_time, NULL );
  current_time = (time_t) last_time.tv_sec;
    }
    
    signal ( SIGSEGV, SIG_DFL );
    signal ( SIGBUS,  SIG_DFL );
    signal ( SIGHUP,  SIG_DFL );    
    signal ( SIGFPE,  SIG_DFL );
    signal ( SIGILL,  SIG_DFL );
    signal ( SIGIOT,  SIG_DFL );
    signal ( SIGKILL,  SIG_DFL );
    signal ( SIGTERM,  SIG_DFL );    

    return;
}
#endif



#if defined(unix)
void init_descriptor( int control )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *dnew;
    struct sockaddr_in sock;
    struct hostent *from = NULL;
    int desc;
    int size;

    size = sizeof(sock);
    getsockname( control, (struct sockaddr *) &sock, &size );
    if ( ( desc = accept( control, (struct sockaddr *) &sock, &size) ) < 0 )
    {
  perror( "New_descriptor: accept" );
  return;
    }

#if !defined(FNDELAY)
#define FNDELAY O_NDELAY
#endif

    if ( fcntl( desc, F_SETFL, FNDELAY ) == -1 )
    {
  perror( "New_descriptor: fcntl: FNDELAY" );
  return;
    }

    /*
     * Cons a new descriptor.
     */
    dnew = new_descriptor();

    dnew->descriptor    = desc;
    dnew->connected     = CON_GET_NAME;
    dnew->showstr_head  = NULL;
    dnew->showstr_point = NULL;
    dnew->outsize       = 2048;
#ifdef OLC_VERSION
    dnew->outbuf        = alloc_mem( dnew->outsize );
#else  /*game version*/
    dnew->outbuf        = GC_MALLOC( dnew->outsize );
#endif

    size = sizeof(sock);
    if ( getpeername( desc, (struct sockaddr *) &sock, &size ) < 0 )
    {
  perror( "New_descriptor: getpeername" );
  dnew->host = str_dup( "(unknown)" );
    }
    else
    {
  /*
   * Would be nice to use inet_ntoa here but it takes a struct arg,
   * which ain't very compatible between gcc and system libraries.
   */
  int addr;

  addr = ntohl( sock.sin_addr.s_addr );
  sprintf( buf, "%d.%d.%d.%d",
      ( addr >> 24 ) & 0xFF, ( addr >> 16 ) & 0xFF,
      ( addr >>  8 ) & 0xFF, ( addr       ) & 0xFF
      );
  sprintf( log_buf, "Sock.sinaddr:  %s", buf );
  log_string( log_buf );

  if ( !no_dns ) {
  alarm(30);
  strcpy(dns_buf,buf);
  if(!check_dns(buf))
  from = gethostbyaddr( (char *) &sock.sin_addr,
      sizeof(sock.sin_addr), AF_INET );
  alarm(0);
  strcpy(dns_buf,"");
  }

      dnew->port = ntohs (sock.sin_port);
      dnew->host = str_dup( from ? from->h_name : buf );
    }
  
    /*
     * Swiftest: I added the following to ban sites.  I don't
     * endorse banning of sites, but Copper has few descriptors now
     * and some people from certain sites keep abusing access by
     * using automated 'autodialers' and leaving connections hanging.
     *
     * Furey: added suffix check by request of Nickel of HiddenWorlds.
     */
    if ( check_ban(dnew->host,BAN_ALL))
    {
      sprintf( log_buf, "Ban denied %s.", dnew->host );
      log_string( log_buf );
  write_to_descriptor( desc,
      "Your site has been banned from this Sled.\n\r", 0, dnew );
 /* write_to_descriptor( desc,
      "Email rusty@@mraz.org for more information.\n\r", 0, dnew );*/
  write_to_descriptor( desc,
      "Bans are not given lightly.  You probobly earned it.  Go away.\n\r", 0, dnew );
  write_to_descriptor( desc, 
      "If you are connecting from mudconnector.com, please use a different IP to connect to our SLED from.  Thank you The MHS Admin Team.\n\r", 0, dnew);
#if defined (GAME_VERSION)
  shutdown( desc, 2 );
  close( desc );
  free_descriptor(dnew);
  return;
#endif
    }
    /*
     * Init descriptor data.
     */
    dnew->next                  = descriptor_list;
    descriptor_list             = dnew;

    /*
     * Send the greeting.
     */
    {
  extern char * help_greeting;
  if ( help_greeting[0] == '.' )
      write_to_buffer( dnew, help_greeting+1, 0 );
  else
      write_to_buffer( dnew, help_greeting  , 0 );
    }

    return;
}
#endif



void close_socket( DESCRIPTOR_DATA *dclose )
{
    CHAR_DATA *ch;

    if ( dclose->outtop > 0 )
  process_output( dclose, FALSE );

    if ( dclose->snoop_by != NULL )
    {
  write_to_buffer( dclose->snoop_by,
      "Your victim has left the game.\n\r", 0 );
    }

    {
  DESCRIPTOR_DATA *d;

  for ( d = descriptor_list; d != NULL; d = d->next )
  {
      if ( d->snoop_by == dclose )
    d->snoop_by = NULL;
  }
    }

    if ( ( ch = dclose->character ) != NULL )
    {
  sprintf( log_buf, "Closing link to %s.", ch->name );
  log_string( log_buf );
  if ( dclose->connected == CON_PLAYING && !merc_down)
  {
      act( "$n has lost $s link.", ch, NULL, NULL, TO_ROOM ,FALSE);
      wiznet("Net death has claimed $N.",ch,NULL,WIZ_LINKS,0,0);
//      if(!IS_IMMORTAL(ch))
 //     {
 //       pnet("Net death has claimed $N.",ch,NULL,PNET_LINKS,0,0);
 //     }
      ch->desc = NULL;
  }
  else
  {
      free_char( dclose->original ? dclose->original : dclose->character );
  }
    }

    if ( d_next == dclose )
  d_next = d_next->next;   

    if ( dclose == descriptor_list )
    {
  descriptor_list = descriptor_list->next;
    }
    else
    {
  DESCRIPTOR_DATA *d;

  for ( d = descriptor_list; d && d->next != dclose; d = d->next )
      ;
  if ( d != NULL )
      d->next = dclose->next;
  else
      bug( "Close_socket: dclose not found.", 0 );
    }
    shutdown( dclose->descriptor, 2 );
    close( dclose->descriptor );
    free_descriptor(dclose);
#if defined(MSDOS) || defined(macintosh)
    exit(1);
#endif
    return;
}



bool read_from_descriptor( DESCRIPTOR_DATA *d )
{
    int iStart;

    /* Hold horses if pending command already. */
    if ( d->incomm[0] != '\0' )
  return TRUE;

    /* Check for overflow. */
    iStart = strlen(d->inbuf);
    if ( iStart >= sizeof(d->inbuf) - 10 )
    {
  sprintf( log_buf, "%s input overflow!", d->host );
  log_string( log_buf );
  write_to_descriptor( d->descriptor,
      "\n\r*** PUT A LID ON IT!!! ***\n\r", 0, d );
  return FALSE;
    }

    /* Snarf input. */
#if defined(macintosh)
    for ( ; ; )
    {
  int c;
  c = getc( stdin );
  if ( c == '\0' || c == EOF )
      break;
  putc( c, stdout );
  if ( c == '\r' )
      putc( '\n', stdout );
  d->inbuf[iStart++] = c;
  if ( iStart > sizeof(d->inbuf) - 10 )
      break;
    }
#endif

#if defined(MSDOS) || defined(unix)
    for ( ; ; )
    {
  int nRead;

  nRead = read( d->descriptor, d->inbuf + iStart,
      sizeof(d->inbuf) - 10 - iStart );
  if ( nRead > 0 )
  {
      iStart += nRead;
      if ( d->inbuf[iStart-1] == '\n' || d->inbuf[iStart-1] == '\r' )
    break;
  }
  else if ( nRead == 0 )
  {
      log_string( "EOF encountered on read." );
      return FALSE;
  }
  else if ( errno == EWOULDBLOCK )
      break;
  else
  {
      sprintf(log_buf,"RFD: connection timed out on %s::%d",d->host,errno);
      wiznet(log_buf,NULL,NULL,WIZ_DEBUG,0,0);
      perror( "Read_from_descriptor" );
      return FALSE;
  }
    }
#endif

    d->inbuf[iStart] = '\0';
    return TRUE;
}



/*
 * Transfer one line from input buffer to input line.
 */
void read_from_buffer( DESCRIPTOR_DATA *d )
{
    int i, j, k, t;

    /*
     * Hold horses if pending command already.
     */
    if ( d->incomm[0] != '\0' )
  return;
  
    for ( i = 0; d->inbuf[i] != NULL; i++ ) {
      if (d->inbuf[i] == '~' ) {        
        d->inbuf[0] = '\r';
        for (t = 1; d->inbuf[t] != NULL; t++)
          d->inbuf[t] = d->inbuf[t+i];  
        d->inbuf[1] = NULL;
        d->incomm[0] = NULL;
        if (d->character && d->character->pcdata) {
          d->character->pcdata->macro_count = 0;
          clear_macro_marks (d->character);          
        }
        return;
      }      
    }  

    /*
     * Look for at least one new line.
     */
    for ( i = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r'; i++ )
    {
      if (d->inbuf[i] == 1) {                  /* signals end of macro */        
        for (t = i; d->inbuf[t] != NULL; t++)  /* shift over inbuff */
          d->inbuf[t] = d->inbuf[t+1];
        if (d->character && d->character->pcdata) {
          d->character->pcdata->macro_count--;
          if (d->character->pcdata->macro_count < 1) {
            d->character->pcdata->macro_count = 0;
            clear_macro_marks (d->character);
          }
        }        
      }
    
      if ( d->inbuf[i] == '\0' ) {
        if (d->character && d->character->pcdata) {
          if (d->character->pcdata->macro_count > 0) {   /* fixes weird situations */          
            d->character->pcdata->macro_count = 0;
            clear_macro_marks (d->character);          
          }          
        }
        return;
      }
    }

    /*
     * Canonical input processing.
     */
    for ( i = 0, k = 0; d->inbuf[i] != '\n' && d->inbuf[i] != '\r'; i++ )
    {
  if ( k >= MAX_INPUT_LENGTH - 2 )
  {
      write_to_descriptor( d->descriptor, "Line too long.\n\r", 0, d );

      /* skip the rest of the line */
      for ( ; d->inbuf[i] != '\0'; i++ )
      {
    if ( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
        break;
      }
      d->inbuf[i]   = '\n';
      d->inbuf[i+1] = '\0';
      break;
  }

  if ( d->inbuf[i] == '\b' && k > 0 )
      --k;
  else if ( isascii(d->inbuf[i]) && isprint(d->inbuf[i]) )
      d->incomm[k++] = d->inbuf[i];
    }

    /*
     * Finish off the line.
     */
    if ( k == 0 )
  d->incomm[k++] = ' ';
    d->incomm[k] = '\0';

    /*
     * Deal with bozos with #repeat 1000 ...
     */

    if ( k > 1 || d->incomm[0] == '!' )
    {
  if ( d->incomm[0] != '!' && strcmp( d->incomm, d->inlast ) )
  {
      d->repeat = 0;
  }
  else
  {
      if ( ++d->repeat >= 25 && d->character && d->connected == CON_PLAYING)
      {
    sprintf( log_buf, "%s@@%s input spamming!", d->character->name, d->host );
    log_string( log_buf );
    wiznet("Spam spam spam $N spam spam spam spam spam!",
           d->character,NULL,WIZ_SPAM,0,get_trust(d->character));
    if (d->incomm[0] == '!')
    {
        wiznet(d->inlast,d->character,NULL,WIZ_SPAM,0,get_trust(d->character));
    sprintf( log_buf, "%s", d->inlast );
    log_string( log_buf );
    }
    else
    {
        wiznet(d->incomm,d->character,NULL,WIZ_SPAM,0,get_trust(d->character));
    sprintf( log_buf, "%s", d->incomm );
    log_string( log_buf );
    }

    d->repeat = 0;
/*
    write_to_descriptor( d->descriptor,
        "\n\r*** PUT A LID ON IT!!! ***\n\r", 0 );
    strcpy( d->incomm, "quit" );
*/
      }
  }
    }


    /*
     * Do '!' substitution.
     */
    if ( d->incomm[0] == '!' )
  strcpy( d->incomm, d->inlast );
    else
  strcpy( d->inlast, d->incomm );

    /*
     * Shift the input buffer.
     */
    while ( d->inbuf[i] == '\n' || d->inbuf[i] == '\r' )
  i++;
    for ( j = 0; ( d->inbuf[j] = d->inbuf[i+j] ) != '\0'; j++ )
  ;
    return;
}



/*
 * Low level output function.
 */
bool process_output( DESCRIPTOR_DATA *d, bool fPrompt )
{
    extern bool merc_down;

    /*
     * Bust a prompt.
     */
    if (fPrompt && !merc_down && d->showstr_point)
  write_to_buffer(d,"[Hit Return to continue]\n\r",0);
    else if ((fPrompt && !merc_down && d->connected == CON_PLAYING ) &&
        ((d->character->pcdata && !d->character->pcdata->interp_fun) || 
        IS_NPC (d->character))) 
    {
  CHAR_DATA *ch;
  CHAR_DATA *victim;

  ch = d->character;

  /* battle prompt */
  if ((victim = ch->fighting) != NULL && can_see(ch,victim,FALSE))
  {
      int percent;
      char wound[100];
      char buf[MAX_STRING_LENGTH];
 
      if (victim->max_hit > 0)
    percent = victim->hit * 100 / victim->max_hit;
      else
    percent = -1;
 
      if (percent >= 100)
    sprintf(wound,"is in excellent condition.");
      else if (percent >= 90)
    sprintf(wound,"has a few scratches.");
      else if (percent >= 75)
    sprintf(wound,"has some small wounds and bruises.");
      else if (percent >= 50)
    sprintf(wound,"has quite a few wounds.");
      else if (percent >= 30)
    sprintf(wound,"has some big nasty wounds and scratches.");
      else if (percent >= 15)
    sprintf(wound,"looks pretty hurt.");
      else if (percent >= 0)
    sprintf(wound,"is in awful condition.");
      else
    sprintf(wound,"is bleeding to death.");
 
      if(IS_SET(victim->mhs,MHS_GLADIATOR) && gladiator_info.blind )
      {
         sprintf(buf,"%s %s \n\r", 
           IS_NPC(victim) ? victim->short_descr : victim->long_descr,wound);
      }
      else
      {
         sprintf(buf,"%s %s \n\r", 
           IS_NPC(victim) ? victim->short_descr : victim->name,wound);
      }
      buf[0] = UPPER(buf[0]);
      write_to_buffer( d, buf, 0);
  }


  ch = d->original ? d->original : d->character;
  if (!IS_SET(ch->display, DISP_COMPACT) )
      write_to_buffer( d, "\n\r", 2 );


  if ( IS_SET(ch->display, DISP_PROMPT) )
      bust_a_prompt( d->character );

  if (IS_SET(ch->comm,COMM_TELNET_GA))
      write_to_buffer(d,go_ahead_str,0);
    }

    /*
     * Short-circuit if nothing to write.
     */
    if ( d->outtop == 0 )
  return TRUE;

    /*
     * Snoop-o-rama.
     */
    if ( d->snoop_by != NULL )
    {
  if (d->character != NULL)
      write_to_buffer( d->snoop_by, d->character->name,0);
  write_to_buffer( d->snoop_by, "> ", 2 );
  write_to_buffer( d->snoop_by, d->outbuf, d->outtop );
    }

    /*
     * OS-dependent output.
     */
    if ( !write_to_descriptor( d->descriptor, d->outbuf, d->outtop, d ) )
    {
  d->outtop = 0;
  return FALSE;
    }
    else
    {
  d->outtop = 0;
  return TRUE;
    }
}

/* Prompt generation command */
void bust_a_prompt( CHAR_DATA *ch )
{
    char buf[MAX_STRING_LENGTH];
    char buf2[MAX_STRING_LENGTH];
    const char *str;
    const char *i;
    char *point;
    int j;
    char doors[MAX_INPUT_LENGTH];
    EXIT_DATA *pexit;
    bool found;
    const char *dir_name[] = {"N","E","S","W","U","D"};
    register int door;
 
    point = buf;
    str = ch->prompt;
    if (str == NULL || str[0] == '\0')
    {
	sprintf( buf, "{x<%dhp %dm %dmv> ",
	    ch->hit,ch->mana,ch->move);
	send_to_char(buf,ch);
	return;
    }

   if (IS_SET(ch->comm,COMM_AFK))
   {
     if(!IS_NPC(ch))
     {
	sprintf( buf, "{x<{CAFK{x - %d> ", ch->pcdata->afk_counter);
     }
     else
     {
	strcpy( buf, "{x<{CAFK{x> ");
     }
     send_to_char(buf,ch);
     return;
   }
    else
   if ( !IS_NPC(ch) && ch->pcdata->wraith_timer > 0 )
   {
	send_to_char(" < .. Fading to Wraithform .. > ",ch );
	return;
   }

   while( *str != '\0' )
   {
      if( *str != '%' )
      {
	 *point++ = *str++;
	 continue;
      }
      ++str;
      switch( *str )
      {
	 default :
	    i = " "; break;
	case 'e':
	    found = FALSE;
	    doors[0] = '\0';
	    if ( IS_AFFECTED(ch,AFF_BLIND) )
		strcat(doors,"(blinded)");
	    else
	    for (door = 0; door < 6 ; door++ )
	    {
		if ((pexit = ch->in_room->exit[door]) != NULL
		&&  pexit ->u1.to_room != NULL
		&&  (can_see_room(ch,pexit->u1.to_room)
		||   (IS_AFFECTED(ch,AFF_INFRARED) 
		&&    !IS_AFFECTED(ch,AFF_BLIND)))
		&&  !IS_SET(pexit->exit_info,EX_CLOSED))
		{
		    found = TRUE;
		    strcat(doors,dir_name[door]);
		}
	    }
	    if (!found)
		strcat(buf,"none");
	    sprintf(buf2,"%s",doors);
	    i = buf2; break;
    	case 'b' :
	    if ( is_affected(ch,gsn_rage) )
               sprintf( buf2, "???" );
	    else
	    {
	    sprintf(buf2,"[HP:");
	    if ( ch->hit * 100 / ch->max_hit > 75 )
		strcat(buf2,"{W");
	    else
	    if ( ch->hit * 100 / ch->max_hit > 50 )
		strcat(buf2,"{Y");
	    else
	    if ( ch->hit * 100 / ch->max_hit > 25 )
		strcat(buf2,"{R");
	    else
		strcat(buf2,"{r");
	    for( j = 0 ; j < ( ch->hit* 100 / ch->max_hit )/ 5 ; j ++ )
		    strcat(buf2,"*");
 	    strcat(buf2,"{x");
	    for( j = 0; j < 20 - (ch->hit*100/ch->max_hit)/ 5 ; j++ )
		    strcat(buf2,"-");
	    strcat(buf2,"]");
	    }
	    i = buf2; break;
	 case 'B' :
            sprintf(buf2,"[M:");
	    if ( ch->mana * 100 / ch->max_mana > 75 )
		strcat(buf2,"{W");
	    else
	    if ( ch->mana * 100 / ch->max_mana > 50 )
		strcat(buf2,"{Y");
	    else
	    if ( ch->mana * 100 / ch->max_mana > 25 )
		strcat(buf2,"{R");
	    else
		strcat(buf2,"{r");	
	for( j = 0 ; j < ( ch->mana * 100 / ch->max_mana)/ 5 ; j ++ )
		strcat(buf2,"*");
	strcat(buf2,"{x");
	for( j = 0; j < 20 - (ch->mana*100/ch->max_mana)/5 ; j++ )
		strcat(buf2,"-");
	strcat(buf2,"]");
	i = buf2; break;
	 case 'c' :
	    sprintf(buf2,"%s","\n\r");
	    i = buf2; break;
	 case 'h' :
	    if ( is_affected(ch,gsn_rage) )
               sprintf( buf2, "???" );
	    else
	       sprintf( buf2, "{%s%d%%{x", 
	          ch->hit < ch->max_hit /2 ? "R" :
		  ch->hit < ch->max_hit * 3 / 4 ? "Y" : "W", (ch->hit*100)/ch->max_hit );
	    i = buf2; break;
	 /*
	 case 'H' :
	    if ( is_affected(ch,gsn_rage) )
               sprintf( buf2, "???" );
	    else
	       sprintf( buf2, "{W%d{x", ch->max_hit );
	    i = buf2; break;
	    */
	 case 'm' :
	    sprintf( buf2, "{%s%d%%{x",
		ch->mana < ch->max_mana / 2 ? "R" : 
		ch->mana < ch->max_mana * 3 / 4 ? "Y" : "W", (ch->mana*100)/ch->max_mana );
	    i = buf2; break;
	    /*
	 case 'M' :
	    sprintf( buf2, "{W%d{x", ch->max_mana );
	    i = buf2; break;
	    */
	 case 'v' :
	    if ( ch->max_move < 1 )
	    {
              bug("bad max_move",0);
	    }
            else
            {
	      sprintf( buf2, "{%s%d%%{x",
		  ch->move < ch->max_move / 2 ? "R" :
		  ch->move < ch->max_move *3/4 ? "Y" : "W", (ch->move*100)/ch->max_move );
	      i = buf2; break;
            }
         case 'w' :
 	 case 'W' :
           sprintf( buf2, "%ld%%", (get_carry_weight(ch)*100)/can_carry_w(ch) );
	   i = buf2; break;
	 case 'V' :
            sprintf(buf2,"[MV:");
	    if ( ch->move * 100 / ch->max_move > 75 )
		strcat(buf2,"{W");
	    else
	    if ( ch->move * 100 / ch->max_move > 50 )
		strcat(buf2,"{Y");
	    else
	    if ( ch->move * 100 / ch->max_move > 25 )
		strcat(buf2,"{R");
	    else
		strcat(buf2,"{r");	
	for( j = 0 ; j < ( ch->move * 100 / ch->max_move)/ 20 ; j++ )
		strcat(buf2,"*");
	strcat(buf2,"{x");
	for( j = 0; j < 5 - (ch->move*100/ch->max_move)/20 ; j++ )
		strcat(buf2,"-");
	strcat(buf2,"]");
	i = buf2; break;
	 case 'n' :
	    sprintf( buf2, "%d.%d", ch->carry_number/10,ch->carry_number%10 );
		i = buf2; break;
	 case 'N' :
		sprintf( buf2, "%d", can_carry_n(ch) / 10 );
		i = buf2; break;
	 case 't' :
	 	sprintf( buf2, "%d", time_info.hour );
		i = buf2; break;
	/*
	 case 'V' :
	    sprintf( buf2, "{W%d{x", ch->max_move );
	    i = buf2; break;
	 */
	 case 'x' :
	    sprintf( buf2, "%d", ch->exp );
	    i = buf2; break;
	 case 'X' :
	    sprintf(buf2, "%d", IS_NPC(ch) ? 0 :
	    (ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp);
	    i = buf2; break;
	 case 'g' :
	    sprintf( buf2, "%ld", ch->gold);
	    i = buf2; break;
	 case 's' :
	    sprintf( buf2, "%ld", ch->silver);
	    i = buf2; break;
	 case 'a' :
	       sprintf( buf2, "%s", IS_GOOD(ch) ? "good" : IS_EVIL(ch) ?
		"evil" : "neutral" );
	    i = buf2; break;
	 case 'r' :
	    if( ch->in_room != NULL )
	       sprintf( buf2, "%s", 
		((!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT)) ||
		 (!IS_AFFECTED(ch,AFF_BLIND) && !room_is_dark( ch->in_room )))
		? ch->in_room->name : "darkness");
	    else
	       sprintf( buf2, " " );
	    i = buf2; break;
	 case 'R' :
	    if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
	       sprintf( buf2, "%d", ch->in_room->vnum );
	    else
	       sprintf( buf2, " " );
	    i = buf2; break;
	 case 'z' :
	    if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
	       sprintf( buf2, "%s", ch->in_room->area->name );
	    else
	       sprintf( buf2, " " );
	    i = buf2; break;
         case 'S' :
	   sprintf(buf2,"%d%%",IS_NPC(ch)?0:(ch->pcdata->sac*100)/MAX_SAC_PNTS);
           i = buf2; break;
	 case 'y' :
	    if( IS_IMMORTAL( ch ) && ch->invis_level > 0)
    	        sprintf(buf2," ({WWizi{x@@{W%d{x)", ch->invis_level);
	    else
		buf2[0] = '\0';
	    i = buf2; break;
	 case 'Y' : 
	     if ( IS_IMMORTAL( ch ) && ch->invis_level > 0)
		sprintf(buf2,"%d", ch->invis_level); 
	     else buf2[0] = '\0'; 
	     i = buf2; break;
	 case 'i' :
	    if( IS_IMMORTAL( ch ) && ch->incog_level > 0)
    	        sprintf(buf2," ({WIncog{x@@{W%d{x)", ch->incog_level);
	    else
		buf2[0] = '\0';
	    i = buf2; break;
	 case 'I' :
	    if( IS_IMMORTAL( ch ) && ch->incog_level > 0)
    	        sprintf(buf2,"%d", ch->incog_level);
	    else
		buf2[0] = '\0';
	    i = buf2; break;
	 case '%' :
	    sprintf( buf2, "%%" );
	    i = buf2; break;
      }
      ++str;
      while( (*point = *i) != '\0' )
	 ++point, ++i;
}
   buf2[0] = '\0';
   i = buf2;
      while( (*point = *i) != '\0' )
	 ++point, ++i;
   
   point = &buf[0];

   send_to_char("{x",ch);
   write_to_buffer( ch->desc, point, 0 );

   return;
}


/*
 * Append onto an output buffer.
 */
void write_to_buffer( DESCRIPTOR_DATA *d, const char *txt, int length )
{
  if (!d) return;
    /*
     * Find length in case caller didn't.
     */
    if ( length <= 0 )
  length = strlen(txt);

    /*
     * Initial \n\r if needed.
     */
    if ( d->outtop == 0 && !d->fcommand )
    {
  d->outbuf[0]    = '\n';
  d->outbuf[1]    = '\r';
  d->outtop       = 2;
    }

    /*
     * Expand the buffer as needed.
     */
    while ( d->outtop + length >= d->outsize )
    {
  char *outbuf;

  if (d->outsize >= 32000)
  {
      bug("Buffer overflow. Closing.\n\r",0);
      close_socket(d);
      return;
  }
#ifdef OLC_VERSION
  outbuf      = alloc_mem( 2 * d->outsize );
#else /*game version*/
  outbuf      = GC_MALLOC( 2 * d->outsize );
#endif
  strncpy( outbuf, d->outbuf, d->outtop );
  free_mem( d->outbuf, d->outsize );
  d->outbuf   = outbuf;
  d->outsize *= 2;
    }

    /*
     * Copy.
     */
    strcpy( d->outbuf + d->outtop, txt );
    d->outtop += length;
    return;
}


#if defined (GAME_VERSION)
/* Color compliant version */
bool write_to_descriptor( int desc, char *str, int length, DESCRIPTOR_DATA *d )
{
   int iStart;
   int nWrite;
   int nBlock;
   BUFFER *txt;
   char *point;
   char buf[2];
   char buf2[MAX_STRING_LENGTH];
#if defined(macintosh) || defined(MSDOS)
   if ( desc == 0 )
     desc = 1;
#endif

  if( d->character == NULL || !IS_SET(d->character->mhs,MHS_OLC) )
  {
   txt = new_buf();
   buf[1] = '\0';
   for(point = str; *point; point++)
     {  
	if( *point == '{')
	  {
	     ++point;
	     if ( ( d->character != NULL &&
		    IS_SET(d->character->display,DISP_COLOR) )
		    || *point == '!' )
	       {   
		  switch( *point )
		    {
		     default: /* fixed to accout for terminals */
		       sprintf( buf2, C_WHITE CLEAR );
		       break;
		     case 'x':
		       sprintf( buf2, C_WHITE CLEAR );
		       break;
		     case 'b':
		       sprintf( buf2, C_BLUE );
		       break;
		     case 'c':
		       sprintf( buf2, C_CYAN );
		       break;
		     case 'g':
		       sprintf( buf2, C_GREEN );
		       break;
		     case 'm':
		       sprintf( buf2, C_MAGENTA );
		       break;
		     case 'r':
		       sprintf( buf2, C_RED );
		       break;
		     case 'w':
		       sprintf( buf2, C_WHITE );
		       break;
		     case 'y':
		       sprintf( buf2, C_YELLOW );
		       break;
		     case 'B':
		       sprintf( buf2, C_B_BLUE );
		       break;
		     case 'C':
		       sprintf( buf2, C_B_CYAN );
		       break;
		     case 'G':
		       sprintf( buf2, C_B_GREEN );
		       break;
		     case 'M':
		       sprintf( buf2, C_B_MAGENTA );
		       break;
		     case 'R':
		       sprintf( buf2, C_B_RED );
		       break;
		     case 'W':
		       sprintf( buf2, C_B_WHITE );
		       break;
		     case 'Y':
		       sprintf( buf2, C_B_YELLOW );
		       break;
		     case 'D':
		       sprintf( buf2, C_D_GREY );
		       break;
		     case '!':
	       if (d->character != NULL && IS_IMMORTAL(d->character) )
			 {
			    sprintf(buf2, "%c", '\a');
			 }
		       else buf2[0] = '\0';
		       break;
		     case '{':
		       sprintf( buf2, "%c", '{' );
		       break;
		     case '\n':
		       sprintf( buf2, "\n" );
		       break;
		    }             
		  add_buf(txt, buf2);
		  continue;
	       }
	     continue;
	  }
	buf[0] = *point;
	add_buf(txt,buf);
     }
/*   if ( strlen(buf_string(txt)) != length )*/
     length = strlen(buf_string(txt));
  }
  else
  {
    if ( length <= 0 ) length = strlen(str);
    txt = new_buf();
    add_buf(txt,str);
  }

   for ( iStart = 0; iStart < length; iStart += nWrite )
     {
	nBlock = UMIN( length - iStart, 4096 );
	if ( ( nWrite = write( desc, buf_string(txt) + iStart, nBlock ) ) < 0 )
	  { perror( "Write_to_descriptor" ); return FALSE; }
     } 
   clear_buf(txt);
   free_buf(txt);
   return TRUE;
}
#endif

/*
 * Lowest level output function.
 * Write a block of text to the file descriptor.
 * If this gives errors on very long blocks (like 'ofind all'),
 *   try lowering the max block size.
*
 * Replaced with color-compliant version *
 */

#if defined (OLC_VERSION)
bool write_to_descriptor( int desc, char *txt, int length, DESCRIPTOR_DATA *d )
{
    int iStart;
    int nWrite;
    int nBlock;

#if defined(macintosh) || defined(MSDOS)
    if ( desc == 0 )
  desc = 1;
#endif

    if ( length <= 0 )
  length = strlen(txt);

    for ( iStart = 0; iStart < length; iStart += nWrite )
    {
  nBlock = UMIN( length - iStart, 4096 );
  if ( ( nWrite = write( desc, txt + iStart, nBlock ) ) < 0 )
      { perror( "Write_to_descriptor" ); return FALSE; }
    } 

    return TRUE;
}
#endif

/*
 * Deal with sockets that haven't logged in yet.
 */
void nanny( DESCRIPTOR_DATA *d, char *argument )
{
    DESCRIPTOR_DATA *d_old, *d_next;
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *ch;
    char *pwdnew;
    char *p;
    int iClass,deity,race,i,weapon,iOldClass, newLevel;
    bool fOld;
    int wStat;
    int statCost; /* cost to increase a customized stat by 1 */
    char *stat_str;
    OBJ_DATA *obj;
    OBJ_DATA *obj2;
    OBJ_DATA *obj_next;
    OBJ_DATA *obj_next2;
    bool weapon_found;

    while ( isspace(*argument) )
  argument++;

    ch = d->character;

    switch ( d->connected )
    {

    default:
  bug( "Nanny: bad d->connected %d.", d->connected );
  close_socket( d );
  return;
    case CON_GET_NAME:
  if ( argument[0] == '\0' )
  {
      close_socket( d );
      return;
  }


  argument[0] = UPPER(argument[0]);
  if (!check_parse_name (argument)) {
    write_to_buffer ( d, "Illegal name, try another.\n\rName: ", 0 );
    return;
  }

  fOld = load_char_obj ( d, argument );

  if ( !check_mob_name( argument, fOld ) && !fOld )
  {
      write_to_buffer( d, "Illegal name, try another.\n\rName: ", 0 );
      return;
  }

  ch   = d->character;

/*  argument[0] = UPPER(argument[0]);
  fOld = load_char_obj ( d, argument );

  if ( !fOld && !check_parse_name( argument ) )
  {
      write_to_buffer( d, "Illegal name, try another.\n\rName: ", 0 );
      return;
  }

  ch   = d->character;
*/
  if (IS_SET(ch->act, PLR_DENY))
  {
      sprintf( log_buf, "Denying access to %s@@%s.", argument, d->host );
      log_string( log_buf );
      write_to_buffer( d, "You are denied access.\n\r", 0 );
      close_socket( d );
      return;
  }
//COREY BAN CHEKC GOES HERE
  if (check_ban(d->host,BAN_PERMIT) && !IS_SET(ch->act,PLR_PERMIT))
  {
      sprintf( log_buf, "Permit ban, denied %s@@%s.", argument, d->host );
      log_string( log_buf );
      write_to_buffer(d,"Your site has been banned from this Sled.\n\r",0);
      close_socket(d);
      return;
  }

  if ( check_reconnect( d, argument, FALSE ) )
  {
      fOld = TRUE;
  }
  else
  {
#ifdef OLC_VERSION
     if ( !IS_SET(ch->act, PLR_FREEZE) && !IS_SET(ch->mhs,MHS_PREFRESHED) && !IS_IMMORTAL(ch)) 
#else /*game version*/
      if ( wizlock && !IS_IMMORTAL(ch)) 
      /* if ( wizlock || (IS_IMMORTAL(ch) && !IS_SET(ch->act,PLR_PERMIT))) */
#endif
      {
    write_to_buffer( d, "The game is wizlocked.\n\r", 0 );
    close_socket( d );
    return;
      }
  }

  if ( fOld )
  {
      /* Old player */

	/* not sure if you want them left in or not, Rusty */

      if(ch->pcdata->hostmask[0] != '\0')
      ch->desc->host = str_dup(ch->pcdata->hostmask);
      write_to_buffer( d, "Password: ", 0 );
      write_to_buffer( d, echo_off_str, 0 );
      d->connected = CON_GET_OLD_PASSWORD;
      return;
  }
  else
  {
      /* New player */
      if (newlock)
      {
    write_to_buffer( d, "The game is newlocked.\n\r", 0 );
    close_socket( d );
    return;
      }

      if (check_ban(d->host,BAN_NEWBIES))
      {
    write_to_buffer(d,
        "New players are not allowed from your site.\n\r",0);
    close_socket(d);
    return;
      }

 write_to_buffer(d,
"Note that some names are unacceptible.  We are fairly lenient on names\n\r",0);
 write_to_buffer(d,
"but nevertheless, some people manage to think of things that even the\n\r",0);
 write_to_buffer(d,
"hardy MHS Imm staff cannot stomach.  You'll be made to delete if you\n\r",0);
 write_to_buffer(d,
"manage to come up with something that falls into that category.\n\r",0);
      sprintf( buf, "Are you sure that %s is reasonable? (Y/N) ",argument );
      write_to_buffer( d, buf, 0 );
      d->connected = CON_CONFIRM_NEW_NAME;
      return;
  }
  break;

    case CON_GET_OLD_PASSWORD:
#if defined(unix)
  write_to_buffer( d, "\n\r", 2 );
#endif

  if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ))
  /*&&  strcmp( crypt(argument,"AltJOjLwtP8NE"),"AlHVvwOVMBOs6"))*/
  {
      write_to_buffer( d, "Wrong password.\n\r", 0 );

      if (d->character->pet) {
          CHAR_DATA *pet=d->character->pet;

          char_to_room(pet,get_room_index( ROOM_VNUM_LIMBO));
          stop_follower(pet);
          extract_char(pet,TRUE);
      }
      close_socket( d );
      return;
  }
 
  write_to_buffer( d, echo_on_str, 0 );

  if (check_playing(d,ch->name))
      return;

  if ( check_reconnect( d, ch->name, TRUE ) )
      return;

  sprintf( log_buf, "%s@@%s has connected.", ch->name, d->host );
  log_string( log_buf );
  wiznet(log_buf,NULL,NULL,WIZ_SITES,0,get_trust(ch));

  if (ch->race == race_lookup("smurf"))
  {
          close_socket( d );
      return;
  }


  if ( ch->kit== kit_lookup("buffy") )
  {
    for ( i = 0 ; i < 5 ; i++ )
      if ( kit_table[ch->kit].skills[i] == NULL )
         break;
      else
         group_remove(ch,kit_table[ch->kit].skills[i]);

       sprintf(log_buf,"Taking buffy kit from %s and giving them 100 pracs .",ch->name);
       log_string(log_buf);

    ch->kit = 0;
    ch->practice += 100;

  }

/* BEGIN THE REMOVAL OF CLAN AVARICE */
if (ch->clan == clan_lookup("avarice") )
{ 
  ch->clan = clan_lookup("loner");;
  ch->pcdata->rank = 0;
}
/*remove shapeshifterkit*/
if ( ch->kit == kit_lookup("shapeshifter") )
{
  ch->practice += 100;
  ch->kit = 0;
}

/*BEGIN THE REMOVAL OF RESEARCH SKILL*/
if ( ch->pcdata->learned[skill_lookup("research")] > 1 )
{
  ch->pcdata->learned[skill_lookup("research")] = 0;
  ch->practice += 10;
}
if ( ch->pcdata->learned[skill_lookup("research")]  == 1 )
{
  ch->pcdata->learned[skill_lookup("research")] = 0;
}




/*BEGIN THE REMOVAL OF CLAN SKILLS */
if (ch->clan == clan_lookup("honor")
&&  ch->pcdata->learned[skill_lookup("honor guard")] > 0 )
{
  ch->pcdata->learned[skill_lookup("honor guard")] = 0;
}
if (ch->clan == clan_lookup("demise")
&&  ch->pcdata->learned[skill_lookup("confusion")] > 0 )
{
  ch->pcdata->learned[skill_lookup("confusion")] = 0;
}

if (ch->clan == clan_lookup("demise")
&& ch->pcdata->learned[skill_lookup("aura of cthon")] > 0)
{
  ch->pcdata->learned[skill_lookup("aura of cthon")] = 0;
}

if (ch->clan == clan_lookup("posse")
&& ch->pcdata->learned[skill_lookup("cuffs of justice")] > 0)
{
  ch->pcdata->learned[skill_lookup("cuffs of justice")] = 0;
}

/*END THE REMOVAL OF CLAN SKILLS*/

/* COREY put the kaethan check here*/
/*#ifdef COREY_VERSION*/
if( !IS_SET(ch->mhs,MHS_KAETH_CLEAN) && !IS_IMMORTAL(ch) )
{ /*BEGIN KAETH CHECK*/
  /* Remove all EQ Worn just for good measure */
  remove_all_objs(ch);

  /* Remove all ITEM_IMM_LOAD and empty out the container
  if its a container */

/*having it loop thru a few more times to get containers within containers*/
  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
    obj_next = obj->next_content;

    if(obj->item_type == ITEM_CONTAINER)
    {
      for ( obj2 = obj->contains; obj2 != NULL; obj2 = obj_next2 )
      {
        obj_next2 = obj2->next_content;
        /*get_obj( ch, obj2, obj );*/

	/*putting this in*/
    if(
         obj2->pIndexData->vnum == 12046
      || obj2->pIndexData->vnum == 12047
      || obj2->pIndexData->vnum == 12048
      || obj2->pIndexData->vnum == 12049
      || obj2->pIndexData->vnum == 12050
      || obj2->pIndexData->vnum == 12051
      || obj2->pIndexData->vnum == 12055
      || obj2->pIndexData->vnum == 12056
      || obj2->pIndexData->vnum == 12057
      || obj2->pIndexData->vnum == 12058

      )
      {
       log_buf[0]='\0';
       sprintf(log_buf,"Taking %d from %s .",obj2->pIndexData->vnum,ch->name);
       log_string(log_buf);
       extract_obj(obj2);
//       obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),ch);
//       obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),ch);
      }
	/*taking this out*/
      }
    }
  }

  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
    obj_next = obj->next_content;
    if(
         obj->pIndexData->vnum == 12046
      || obj->pIndexData->vnum == 12047
      || obj->pIndexData->vnum == 12048
      || obj->pIndexData->vnum == 12049
      || obj->pIndexData->vnum == 12050
      || obj->pIndexData->vnum == 12051
      || obj->pIndexData->vnum == 12055
      || obj->pIndexData->vnum == 12056
      || obj->pIndexData->vnum == 12057
      || obj->pIndexData->vnum == 12058 

      )
      {
       log_buf[0]='\0';
       sprintf(log_buf,"Taking %d from %s and giving them two shards.",obj->pIndexData->vnum,ch->name);
       log_string(log_buf);
       extract_obj(obj);
       obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),ch);
       obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),ch);
      }
  }


   SET_BIT(ch->mhs,MHS_KAETH_CLEAN);
}/*end of KAETH CHECK */
/*#endif*/
/* Poquah temp remove come back to this later */

 if (is_clan(ch) )
 {
    ch->pcdata->start_time = 2;
 }


/*COREY COREY COREY put the remove matook stuff here */
/*

  if (is_clan(ch))
  {
  if(ch->pcdata->logins_without_death > 10 ||
     ch->pcdata->logins_without_kill > 10 ||
     ch->pcdata->logins_without_combat > 10)
  {
     sprintf( log_buf, "%s is a possible storage character.", ch->name);
     log_string( log_buf );
     wiznet(log_buf,NULL,NULL,WIZ_SITES,0,get_trust(ch));
  }
  }
*/

/*  get_ident_info ( ch ); */

      if( IS_SET(ch->mhs,MHS_PREFRESHED) )
      {
         do_help( ch, "pfreshmotd" );
         write_to_buffer(d,"\n\r",0);
         write_to_buffer(d,"'Continue' or 'Quit' Which would you like to do? ",0);
         d->connected = CON_PREFRESH_CHAR;
         break;
      }

      if( IS_SET(ch->act,PLR_RECLASS) )
      {
	REMOVE_BIT(ch->act,PLR_RECLASS);
	write_to_buffer( d, "\n\r", 2 );
	write_to_buffer( d, "You may be good, neutral, or evil.\n\r",0);
	write_to_buffer( d, "Which alignment (G/N/E)? ",0);
	/* perm stat based on old class */
	ch->perm_stat[class_table[ch->pcdata->old_class].attr_prime] += 3;
  	ch->perm_stat[class_table[ch->pcdata->old_class].attr_second] += 2;

	d->connected = CON_GET_ALIGNMENT;
	break;
      }

  if ( IS_IMMORTAL(ch) )
  {
      do_help( ch, "imotd" );
      d->connected = CON_READ_IMOTD;
  }
  else
  {
      do_help( ch, "motd" );
      d->connected = CON_READ_MOTD;
  }
  break;

/* RT code for breaking link */
 
    case CON_BREAK_CONNECT:
  switch( *argument )
  {
  case 'y' : case 'Y': default:
      for ( d_old = descriptor_list; d_old != NULL; d_old = d_next )
      {
    d_next = d_old->next;
    if (d_old == d || d_old->character == NULL)
        continue;

    if (str_cmp(ch->name,d_old->original ?
        d_old->original->name : d_old->character->name))
        continue;

    close_socket(d_old);
      }
      if (check_reconnect(d,ch->name,TRUE))
    return;
      write_to_buffer(d,"Reconnect attempt failed.\n\rName: ",0);
      if ( d->character != NULL )
      {
    free_char( d->character );
    d->character = NULL;
      }
      d->connected = CON_GET_NAME;
      break;
    }
/*
  case 'n' : case 'N':
      write_to_buffer(d,"Name: ",0);
      if ( d->character != NULL )
      {
    free_char( d->character );
    d->character = NULL;
      }
      d->connected = CON_GET_NAME;
      break;

  default:
      write_to_buffer(d,"Please type Y or N? ",0);
      break;
  }*/
  break;

    case CON_CONFIRM_NEW_NAME:
  switch ( *argument )
  {
  case 'y': case 'Y':
      sprintf( buf, "New character.\n\rChoose a surname for %s: ", ch->name);
      write_to_buffer( d, buf, 0 );
      d->connected = CON_GET_SURNAME;
      break;

  case 'n': case 'N':
      write_to_buffer( d, "Ok, what IS it, then? ", 0 );
      free_char( d->character );
      d->character = NULL;
      d->connected = CON_GET_NAME;
      break;

  default:
      write_to_buffer( d, "Please type Yes or No? ", 0 );
      break;
  }
  break;

    case CON_GET_SURNAME:
	do_surname(ch,argument);
 	if( ch->pcdata->surname == NULL )
 	{
	  write_to_buffer( d, "Please choose a surname: ", 0);
	  break;
	}
	else
	{
	  sprintf( buf, "Please choose a password: %s", echo_off_str );
	  write_to_buffer( d, buf, 0 );
	  d->connected = CON_GET_NEW_PASSWORD;
	  break;
	}

	

    case CON_PREFRESH_CHAR:
  one_argument(argument,arg);

  if (!strcmp(arg,"quit"))
  {
      write_to_buffer( d, "Character Not Refreshed.n\r", 0 );
      close_socket( d );
      return;
  }
  else
  if (!strcmp(arg,"continue"))
  {
     /* Move all skills to old skills and reset skills */
     for ( i = 0; i < MAX_SKILL; i++ )
     {
        ch->pcdata->old_learned[i] = ch->pcdata->learned[i];
        ch->pcdata->learned[i] = 0;
     }

     /* Clear Groups Known so they can pick them again */
     for (i = 0; i < MAX_GROUP; i++)
     {
        if (group_table[i].name == NULL)
           break;
        ch->pcdata->group_known[i] = 0;
     }

     /* Set the Logout tracker */
     ch->pcdata->logout_tracker = 6;

     /* Reset Skill Points */
     ch->skill_points = 0;
     ch->pcdata->skill_point_timer = 0;
     ch->pcdata->skill_point_tracker = 0;

     /* Remove Killer,Thief and Trumps */
     if (IS_SET(ch->act,PLR_KILLER))
        REMOVE_BIT(ch->act,PLR_KILLER); 
     if (IS_SET(ch->act,PLR_THIEF))
        REMOVE_BIT(ch->act,PLR_THIEF);
     if (IS_SET(ch->wiznet,PLR_RUFFIAN))
        REMOVE_BIT(ch->wiznet,PLR_RUFFIAN);
     ch->trumps = 0;

     /* Reset Fight, Outcast and Ruffian Timers */
     ch->timer = 0;
     ch->pcdata->outcT = 0;
     ch->pcdata->ruffT = 0;

     /* Reset Clan and Rank */
     if (is_clan(ch))
     {
        ch->clan = 0;
        ch->pcdata->rank = 0;
     }

     /* calculate gained xp for refresh purposes */
     if( IS_SET(ch->act, PLR_VAMP) || 
         IS_SET(ch->act, PLR_WERE ) ||
         IS_SET(ch->act, PLR_MUMMY ) )
     {
         ch->exp += 26 * exp_per_level(ch,ch->pcdata->points);
     }

     /* set pcdata points to zero */
     ch->pcdata->points = 0;

     /* Remove Kit */
     /* Remove specialization if any */
     ch->pcdata->specialize = 0;
     ch->species_enemy = 0;
     ch->kit = 0;

     /* Remove Nodes if Any */
     if (ch->pcdata->node != 0)
        ch->pcdata->node = 0;

     /* Remove Shapeshifted or Shapemorphed just in case */
     if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
        REMOVE_BIT(ch->mhs,MHS_SHAPESHIFTED);
     if (IS_SET(ch->mhs,MHS_SHAPEMORPHED))
        REMOVE_BIT(ch->mhs,MHS_SHAPEMORPHED);
     if (IS_SET(ch->mhs,MHS_MUTANT))
        REMOVE_BIT(ch->mhs,MHS_MUTANT);

     /* Remove Affects and Resists/Vulns/Imms */
     while ( ch->affected )
        affect_remove( ch, ch->affected,APPLY_BOTH );
     ch->affected_by = 0;

    if (ch->imm_flags)
       ch->imm_flags = 0; 
    if (ch->res_flags)
       ch->res_flags = 0;
    if (ch->vuln_flags)
       ch->vuln_flags = 0;

    /* Remove all EQ Worn just for good measure */
    remove_all_objs(ch);

    /* Remove all ITEM_IMM_LOAD and empty out the container
       if its a container */
   
    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
    {
       obj_next = obj->next_content;
       if(obj->item_type == ITEM_CONTAINER)
       {
          for ( obj2 = obj->contains; obj2 != NULL; obj2 = obj_next2 )
          {
             obj_next2 = obj2->next_content;
             get_obj( ch, obj2, obj );
          }
       }
    }

    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
    {
       obj_next = obj->next_content;
       if (IS_SET(obj->extra_flags,ITEM_IMM_LOAD))
          extract_obj(obj);
    }

    /* Clear Last Attacked By */
    ch->pcdata->last_attacked_by = str_dup("no one");
    ch->pcdata->last_attacked_by_timer = 0;
    ch->pcdata->last_death_timer = 0;
    ch->pcdata->logins_without_combat = 0;
    ch->pcdata->logins_without_death = 0;
    ch->pcdata->logins_without_kill = 0;
    ch->pcdata->last_combat_date = current_time;
    ch->pcdata->last_death_date = current_time;
    ch->pcdata->last_kill_date = current_time;

    /* Reset Report Stats */
    ch->pcdata->killer_data[PC_DEATHS] = 0;
    ch->pcdata->killer_data[PC_LOWER_KILLS] = 0;
    ch->pcdata->killer_data[PC_EQUAL_KILLS] = 0;
    ch->pcdata->killer_data[PC_GREATER_KILLS] = 0;
    ch->pcdata->steal_data[PC_STOLEN_ITEMS] = 0;
    ch->pcdata->steal_data[PC_STOLEN_GOLD] = 0;
    ch->pcdata->steal_data[PC_SLICES] = 0;
    ch->pcdata->last_kill = str_dup("no one");
    ch->pcdata->last_killed_by = str_dup("no one");

    /* Clear Trains and Pracs */
    ch->train = 0;
    ch->practice = 0;

    write_to_buffer(d,"The following races are available:\n\r  ",0);
    for ( race = 1; race_table[race].name != NULL; race++ )
    {
       if (!race_table[race].pc_race)
          break;
       write_to_buffer(d," * ",0);
       write_to_buffer(d,race_table[race].name,0);
       write_to_buffer(d,"\n\r",0);
       write_to_buffer(d," ",1);
    }

    write_to_buffer(d,"\n\r",0);
    write_to_buffer(d,"What is your race (help for more information)? ",0);
    d->connected = CON_GET_NEW_RACE;
    break;
 }
 else
 {
    write_to_buffer(d,"\n\r",0);
    write_to_buffer(d,"'Continue' or 'Quit' Which would you like to do? ",0);
    break;
 }
 break;

    case CON_GET_NEW_PASSWORD:
#if defined(unix)
  write_to_buffer( d, "\n\r", 2 );
#endif

  if ( strlen(argument) < 5 )
  {
      write_to_buffer( d,
    "Password must be at least five characters long.\n\rPassword: ",
    0 );
      return;
  }

  pwdnew = crypt( argument, ch->name );
  for ( p = pwdnew; *p != '\0'; p++ )
  {
      if ( *p == '~' )
      {
    write_to_buffer( d,
        "New password not acceptable, try again.\n\rPassword: ",
        0 );
    return;
      }
  }

  free_string( ch->pcdata->pwd );
  ch->pcdata->pwd = str_dup( pwdnew );
  write_to_buffer( d, "Please retype password: ", 0 );
  d->connected = CON_CONFIRM_NEW_PASSWORD;
  break;

    case CON_CONFIRM_NEW_PASSWORD:
#if defined(unix)
  write_to_buffer( d, "\n\r", 2 );
#endif

  if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
  {
      write_to_buffer( d, "Passwords don't match.\n\rRetype password: ",
    0 );
      d->connected = CON_GET_NEW_PASSWORD;
      return;
  }

  write_to_buffer( d, echo_on_str, 0 );
  write_to_buffer(d,"The following races are available:\n\r  ",0);
  for ( race = 1; race_table[race].name != NULL; race++ )
  {
      if (!race_table[race].pc_race)
    break;
      write_to_buffer(d," * ",0);
      write_to_buffer(d,race_table[race].name,0);
      write_to_buffer(d,"\n\r",0);
      write_to_buffer(d," ",1);
  }

  write_to_buffer(d,"\n\r",0);
  write_to_buffer(d,"What is your race (help for more information)? ",0);
  d->connected = CON_GET_NEW_RACE;
  break;

    case CON_GET_NEW_RACE:
  one_argument(argument,arg);

  if (!strcmp(arg,"help"))
  {
      argument = one_argument(argument,arg);
      if (argument[0] == '\0')
    do_help(ch,"race help");
      else
    do_help(ch,argument);
      write_to_buffer(d,
    "What is your race (help for more information)? ",0);
      break;
  }

  race = race_lookup(argument);

  if (race == 0 || !race_table[race].pc_race || race == race_lookup("mutant") || race == race_lookup("smurf"))
  {
      if (race == race_lookup("mutant"))
      {
	 write_to_buffer(d,"Sorry Mutants are Out of Order, Pick Again.\n\r",0);
	 write_to_buffer(d,"\n\r",0);
      }

      if (race == race_lookup("smurf"))
      {
         write_to_buffer(d,"Blue and two apples tall?  You wouldn't last two minutes.  Pick again please.\n\r",0);
         write_to_buffer(d,"\n\r",0);
      }


      write_to_buffer(d,"That is not a valid race.\n\r",0);
      write_to_buffer(d,"The following races are available:\n\r  ",0);

      for ( race = 1; race_table[race].name != NULL; race++ )
      {
         if (!race_table[race].pc_race)
            break;
         write_to_buffer(d,race_table[race].name,0);
         write_to_buffer(d," ",1);
      }

      write_to_buffer(d,"\n\r",0);
      write_to_buffer(d,
         "What is your race? (help for more information) ",0);
      break;
  }

/*  if (race == race_lookup("smurf"))
  {
      write_to_buffer(d,"This is a Beta Test Race right now. You must have the password.\n\r",0);
      write_to_buffer(d, "What is the password? ",0); 
      ch->race = race;
      d->connected = CON_TEMP_SMURF_PASSWORD;
      break;

  }
*/
  ch->race = race;
  /* initialize stats */
  for (i = 0; i < MAX_STATS; i++)
      ch->perm_stat[i] = pc_race_table[race].stats[i];
  ch->affected_by = ch->affected_by|race_table[race].aff;
  ch->imm_flags   = ch->imm_flags|race_table[race].imm;
  ch->res_flags   = ch->res_flags|race_table[race].res;
  ch->vuln_flags  = ch->vuln_flags|race_table[race].vuln;
  ch->form        = race_table[race].form;
  ch->parts       = race_table[race].parts;
  ch->hit     = 20;
  ch->max_hit = 20;
  ch->pcdata->perm_hit = 20;
  ch->mana    = 100;
  ch->max_mana = 100;
  ch->pcdata->perm_mana = 100;
  ch->move    = 100;
  ch->max_move = 100;
  ch->pcdata->perm_move = 100;
//COREY COREY COREY PUT THE KAETH BIT SET HERE
SET_BIT(ch->mhs,MHS_KAETH_CLEAN);

  if ( race == race_lookup("mutant") )
  {
	SET_BIT(ch->mhs,MHS_MUTANT);
	ch->pcdata->mutant_timer = 500;
  }

  /* add skills */
  for (i = 0; i < 5; i++)
  {
      if (pc_race_table[race].skills[i] == NULL)
    break;
      group_add(ch,pc_race_table[race].skills[i],FALSE);
  }
  /* add cost */
  ch->pcdata->points = pc_race_table[race].points;
  ch->size = pc_race_table[race].size;


  /* Stamp Time of Creation */
  ch->pcdata->created_date = current_time;

  /* Set all new characters as Newbies */
  ch->clan = clan_lookup("newbie");

  if (IS_SET(ch->mhs,MHS_PREFRESHED))
  {
     strcpy( buf, "Select a class (Help <class> for more information)\n\r [" );
     for ( iClass = 0; iClass < MAX_CLASS; iClass++ )
     {
        if (iClass > 0)
           strcat( buf, " " );
        strcat( buf, class_table[iClass].name );
     }
     strcat( buf, "]: " );
     write_to_buffer( d, buf, 0 );
     d->connected = CON_GET_NEW_CLASS;
  }
  else
  {
     write_to_buffer( d, "What is your sex (M/F)? ", 0 );
     d->connected = CON_GET_NEW_SEX;
  } 
  break;
  
    case CON_TEMP_SMURF_PASSWORD:
  one_argument(argument,arg);

  if (!strcmp(arg,"simpy"))
  {
     race = ch->race;
     for (i = 0; i < MAX_STATS; i++)
         ch->perm_stat[i] = pc_race_table[race].stats[i];
     ch->affected_by = ch->affected_by|race_table[race].aff;
     ch->imm_flags   = ch->imm_flags|race_table[race].imm;
     ch->res_flags   = ch->res_flags|race_table[race].res;
     ch->vuln_flags  = ch->vuln_flags|race_table[race].vuln;
     ch->form        = race_table[race].form;
     ch->parts       = race_table[race].parts;
     for (i = 0; i < 5; i++)
     {
         if (pc_race_table[race].skills[i] == NULL)
            break;
         group_add(ch,pc_race_table[race].skills[i],FALSE);
     }
     ch->pcdata->points = pc_race_table[race].points;
     ch->size = pc_race_table[race].size;
     ch->pcdata->created_date = current_time;
     ch->clan = clan_lookup("smurf");
     ch->pcdata->surname = str_dup("Smurf"); 
     ch->pcdata->rank = 0;
     write_to_buffer( d, "What is your sex (M/F)? ", 0 );
     d->connected = CON_GET_NEW_SEX;
  }
  else
  {
     write_to_buffer(d,"That password is not correct.\n\r  ",0);
     write_to_buffer(d,"The following races are available:\n\r  ",0);
     for ( race = 1; race_table[race].name != NULL; race++ )
     {
         if (!race_table[race].pc_race)
            break;
         write_to_buffer(d," * ",0);
         write_to_buffer(d,race_table[race].name,0);
         write_to_buffer(d,"\n\r",0);
         write_to_buffer(d," ",1);
     }

     write_to_buffer(d,"\n\r",0);
     write_to_buffer(d,"What is your race (help for more information)? ",0);
     d->connected = CON_GET_NEW_RACE;
  }
  break;

    case CON_GET_NEW_SEX:
  switch ( argument[0] )
  {
  case 'm': case 'M': ch->sex = SEX_MALE;    
          ch->pcdata->true_sex = SEX_MALE;
          break;
  case 'f': case 'F': ch->sex = SEX_FEMALE; 
          ch->pcdata->true_sex = SEX_FEMALE;
          break;
  default:
      write_to_buffer( d, "That's not a sex.\n\rWhat IS your sex? ", 0 );
      return;
  }

  strcpy( buf, "Select a class (Help <class> for more information)\n\r [" );
  for ( iClass = 0; iClass < MAX_CLASS; iClass++ )
  {
  /*
      if ( iClass > 0 && !class_table[iClass].reclass )
      */
      if (iClass > 0)
    strcat( buf, " " );
    /*
	if( !class_table[iClass].reclass )
	*/
      strcat( buf, class_table[iClass].name );
  }
  strcat( buf, "]: " );
  write_to_buffer( d, buf, 0 );
  d->connected = CON_GET_NEW_CLASS;
  break;

    case CON_GET_NEW_CLASS:
  one_argument(argument,arg);

  if (!strcmp(arg,"help"))
  {
      argument = one_argument(argument,arg);
      if (argument[0] == '\0')
    do_help(ch,"class help");
      else
    do_help(ch,argument);
  strcpy( buf, "Select a class (Help <class> for more information)\n\r [" );
  for ( iClass = 0; iClass < MAX_CLASS; iClass++ )
  {
      if (iClass > 0)
    strcat( buf, " " );
      strcat( buf, class_table[iClass].name );
  }
  strcat( buf, "]: " );
  write_to_buffer( d, buf, 0 );
      break;
  }

  iClass = class_lookup(argument);

/*
  if ( iClass == -1 || class_table[iClass].reclass )
  */
  if ( iClass == -1 )
  {
      write_to_buffer( d,
    "That's not a class.\n\rWhat IS your class? ", 0 );
      return;
  }

  ch->class = iClass;

  if (!IS_SET(ch->mhs,MHS_PREFRESHED))
  {
     sprintf( log_buf, "%s@@%s new player.", ch->name, d->host );
     log_string( log_buf );
     wiznet("Newbie alert!  $N sighted.",ch,NULL,WIZ_NEWBIE,0,0);
     wiznet(log_buf,NULL,NULL,WIZ_SITES,0,get_trust(ch));
  }
  else
  {
     sprintf( log_buf, "%s@@%s pfresh player.", ch->name, d->host );
     log_string( log_buf );
     wiznet("Pfresh alert!  $N sighted.",ch,NULL,WIZ_NEWBIE,0,0);
     wiznet(log_buf,NULL,NULL,WIZ_SITES,0,get_trust(ch));
  }

  if (!class_table[iClass].reclass ) 
  {
     ch->pcdata->old_class = iClass;
     /* primary and secondary based on oldclass setting */
     ch->perm_stat[class_table[ch->pcdata->old_class].attr_prime] += 3;
     ch->perm_stat[class_table[ch->pcdata->old_class].attr_second] += 2;

     if (IS_SET(ch->mhs,MHS_PREFRESHED))
     {
        group_add(ch,"rom basics",FALSE);
        group_add(ch,class_table[ch->class].base_group,FALSE);
        /** Prime the pump -> these are nice to have at low levels **/
        ch->pcdata->learned[gsn_recall] = 50;
        ch->pcdata->learned[gsn_scan] = 50;
        ch->pcdata->learned[gsn_swim] = 50;
        write_to_buffer(d,"Do you wish to customize this character?\n\r",0);
        write_to_buffer(d,"Customization takes time, but allows a wider range of skills and abilities.\n\r",0);
        write_to_buffer(d,"Customize (Y/N)? ",0);
        d->connected = CON_DEFAULT_CHOICE;
     }
     else
     {
        write_to_buffer( d, "\n\r", 2 );
        write_to_buffer( d, "You may be good, neutral, or evil.\n\r",0);
        write_to_buffer( d, "Which alignment (G/N/E)? ",0);
        d->connected = CON_GET_ALIGNMENT;
     }
  }
  else
  {
     strcpy( buf, "Select an old class [" );
     for ( iOldClass = 0 ; iOldClass < MAX_CLASS ; iOldClass++ )
     {
        if (iOldClass > 0)
           strcat( buf, " " );

        if ( class_table[iOldClass].reclass )
           continue;

        if (class_table[ch->class].allowed[0] == iOldClass ||
            class_table[ch->class].allowed[1] == iOldClass )
           strcat( buf, class_table[iOldClass].name );
     }
     strcat( buf, "]: " );
     write_to_buffer( d, buf, 0 );
     d->connected = CON_GET_OLD_CLASS;
  }
  break;


case CON_GET_OLD_CLASS:
  iOldClass = class_lookup(argument);

  if ( iOldClass == -1 || class_table[iOldClass].reclass 
       || (class_table[ch->class].allowed[0] != iOldClass &&
	   class_table[ch->class].allowed[1] != iOldClass))
  {
      write_to_buffer( d,
    "That's not a valid old class.\n\rWhat IS your old class? ", 0 );
      return;
  }

  ch->pcdata->old_class = iOldClass;
  /* primary and secondary based on oldclass setting */
  ch->perm_stat[class_table[ch->pcdata->old_class].attr_prime] += 3;
  ch->perm_stat[class_table[ch->pcdata->old_class].attr_second] += 2;

  if (IS_SET(ch->mhs,MHS_PREFRESHED))
  {
     group_add(ch,"rom basics",FALSE);
     group_add(ch,class_table[ch->class].base_group,FALSE);
     /** Prime the pump -> these are nice to have at low levels **/
     ch->pcdata->learned[gsn_recall] = 50;
     ch->pcdata->learned[gsn_scan] = 50;
     ch->pcdata->learned[gsn_swim] = 50;
     write_to_buffer(d,"Do you wish to customize this character?\n\r",0);
     write_to_buffer(d,"Customization takes time, but allows a wider range of skills and abilities.\n\r",0);
     write_to_buffer(d,"Customize (Y/N)? ",0);
     d->connected = CON_DEFAULT_CHOICE;
  }
  else
  {
     write_to_buffer( d, "\n\r", 2 );
     write_to_buffer( d, "You may be good, neutral, or evil.\n\r",0);
     write_to_buffer( d, "Which alignment (G/N/E)? ",0);
     d->connected = CON_GET_ALIGNMENT;
  }
  break;

case CON_GET_ALIGNMENT:
  switch( argument[0])
  {
      case 'g' : case 'G' : ch->alignment = 750;  break;
      case 'n' : case 'N' : ch->alignment = 0;    break;
      case 'e' : case 'E' : ch->alignment = -750; break;
      default:
    write_to_buffer(d,"That's not a valid alignment.\n\r",0);
    write_to_buffer(d,"Which alignment (G/N/E)? ",0);
    return;
  }

  write_to_buffer(d,"\n\r",0);

  group_add(ch,"rom basics",FALSE);
  group_add(ch,class_table[ch->class].base_group,FALSE);
  /** Prime the pump -> these are nice to have at low levels **/
  ch->pcdata->learned[gsn_recall] = 50;
  ch->pcdata->learned[gsn_scan] = 50;
  ch->pcdata->learned[gsn_swim] = 50;
  /* Turn off some channels they can't use */
  SET_BIT(ch->comm,COMM_NOBITCH);
  SET_BIT(ch->comm,COMM_NOAUCTION);
  SET_BIT(ch->comm,COMM_NOMUSIC);
  SET_BIT(ch->comm,COMM_NOQUOTE);
  SET_BIT(ch->comm,COMM_NOGRATS);
  SET_BIT(ch->act,PLR_NOOUTOFRANGE);
  write_to_buffer(d,"Do you wish to customize this character?\n\r",0);
  write_to_buffer(d,"Customization takes time, but allows a wider range of skills and abilities.\n\r",0);
  write_to_buffer(d,"Customize (Y/N)? ",0);
  d->connected = CON_DEFAULT_CHOICE;
  break;

case CON_DEFAULT_CHOICE:
  write_to_buffer(d,"\n\r",2);
  ch->gen_data = new_gen_data();
  ch->gen_data->bonus_points = 50;
  switch ( argument[0] )
  {
  case 'y': case 'Y': 
      ch->gen_data->points_chosen = ch->pcdata->points;
      do_help(ch,"group header");
      list_group_costs(ch);
      write_to_buffer(d,"You already have the following skills:\n\r",0);
      do_skills(ch,"");
      do_help(ch,"menu choice");
      d->connected = CON_GEN_GROUPS;
      break;
  case 'n': case 'N': 
      group_add(ch,class_table[ch->class].default_group,TRUE);
      write_to_buffer( d, "\n\r", 2 );
      write_to_buffer(d,
    "Please pick a weapon from the following choices:\n\r",0);
      buf[0] = '\0';
      for ( i = 0; weapon_table[i].name != NULL; i++)
    if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
    {
        strcat(buf,weapon_table[i].name);
        strcat(buf," ");
    }
      strcat(buf,"\n\rYour choice? ");
      write_to_buffer(d,buf,0);
      d->connected = CON_PICK_WEAPON;
      break;
  default:
      write_to_buffer( d, "Please answer (Y/N)? ", 0 );
      return;
  }
  break;

    case CON_PICK_DEITY:
      one_argument(argument,arg);
      write_to_buffer( d, "\n\r", 2 );
      if (!strcmp(arg,"help"))
      {
         argument = one_argument(argument,arg);
         if (argument[0] == '\0')
            do_help(ch,"deity");
         else
            do_help(ch,argument);
         write_to_buffer(d,
            "Please pick a Deity (help deity for more information)\n\r",0);
         write_to_buffer(d,"Your choice? ",0);
         break;
      }

      deity = deity_lookup(argument);

      if ( deity == -1)                  
      {                                                         
         write_to_buffer(d,"Not an existing Deity.\n\r",0);
         write_to_buffer(d,
            "Please pick a Deity (help deity for more information)\n\r",0);
         write_to_buffer(d,"Your choice? ",0);
         break;
      }

      /* smurfs can pick clanned deitied at creation */
      if (ch->race != race_lookup("smurf"))
      {
         if (deity_table[deity].clan && !is_clan(ch))
         {
            write_to_buffer(d,"Don't get ahead of yourself, you arent Clanned yet.\n\r",0);
            write_to_buffer(d,
               "Please pick a Non-Clan-Deity (help deity for more information):\n\r",0);
            write_to_buffer(d,"Your choice?\n\r",0);
            break;
         }
      }
      
      ch->pcdata->deity = deity;
      ch->pcdata->new_deity = deity; 
      ch->pcdata->sac = 0;

      write_to_buffer( d, "\n\r", 2 );
      write_to_buffer(d,
         "Please pick a weapon from the following choices:\n\r",0);
      buf[0] = '\0';
      for ( i = 0; weapon_table[i].name != NULL; i++)
      {
         if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
         {
            strcat(buf,weapon_table[i].name);
            strcat(buf," ");
         }
      }
      strcat(buf,"\n\rYour choice? ");
      write_to_buffer(d,buf,0);
      d->connected = CON_PICK_WEAPON;
      break;

    case CON_PICK_WEAPON:
  write_to_buffer(d,"\n\r",2);
  weapon = weapon_lookup(argument);
  if (weapon == -1 || ch->pcdata->learned[*weapon_table[weapon].gsn] <= 0)
  {
      write_to_buffer(d,
    "That's not a valid selection. Choices are:\n\r",0);
      buf[0] = '\0';
      for ( i = 0; weapon_table[i].name != NULL; i++)
    if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
    {
        strcat(buf,weapon_table[i].name);
        strcat(buf," ");
    }
      strcat(buf,"\n\rYour choice? ");
      write_to_buffer(d,buf,0);
      return;
  }
      /* calculate number of debit levels to give refresh chars */
      if (IS_SET(ch->mhs,MHS_PREFRESHED))
      {
	newLevel = ch->exp / exp_per_level(ch,ch->pcdata->points);
	/* remove the free level "1" */
	newLevel -= 1;
	if( ( ch->level < 11 ) && (newLevel > ch->level ) )
	{
	  newLevel = ch->level ;
	}
	if(   IS_SET(ch->act,PLR_VAMP) ||
	      IS_SET(ch->act,PLR_WERE) ||
	      IS_SET(ch->act,PLR_MUMMY) 
          )
	{
	  if ( newLevel > 76 )
	  {
	    newLevel = 76;
	  }
	  ch->pcdata->debit_level = newLevel;
	}
	else
	{
	 /* not a remort, max it at 50 */
	 if(newLevel > 50 )
	 {
	   newLevel =50;
         }
	 ch->pcdata->debit_level = newLevel;
	}

	ch->level=0;
	ch->exp = exp_per_level(ch,ch->pcdata->points) ;
	 /* Remove Remort Status */
	 if (IS_SET(ch->act,PLR_VAMP))
	    REMOVE_BIT(ch->act,PLR_VAMP);
	 if (IS_SET(ch->act,PLR_WERE))
	    REMOVE_BIT(ch->act,PLR_WERE);
	 if (IS_SET(ch->act,PLR_MUMMY))
	    REMOVE_BIT(ch->act,PLR_MUMMY);
      }
	  
  ch->pcdata->learned[*weapon_table[weapon].gsn] = 80;
  write_to_buffer(d,"\n\r",2);

  /* add racial skills back on incase they got dropped in customizing*/
  for (i = 0; i < MAX_SKILL; i++)
  {
      if (pc_race_table[ch->race].skills[i] == NULL)
         break;
      group_add(ch,pc_race_table[ch->race].skills[i],FALSE);
  }

  show_stats( d );
  d->connected = CON_PICK_STATS;
  break;

    case CON_PICK_STATS:
    if ( argument[0] == '\0' )
    {
	write_to_buffer(d,"Invalid selection, type 'help' for help.\n\r",0);
	show_stats( d );
	return;
    }

    if ( !str_cmp(argument,"help") )
    {
	do_help(ch,"pickstats");
	write_to_buffer(d,"Your choice -> ",0);
	return;
    }

    /* str, dex, int, wis, con, etc */
    if ( !str_cmp(argument,"str") ) {
       wStat = STAT_STR; stat_str = "STR"; }
    else
    if ( !str_cmp(argument,"dex") ) {
       wStat = STAT_DEX; stat_str = "DEX"; }
    else
    if ( !str_cmp(argument,"con") ) {
	wStat = STAT_CON; stat_str = "CON"; }
    else
    if ( !str_cmp(argument,"int") ) {
	wStat = STAT_INT; stat_str ="INT"; }
    else
    if ( !str_cmp(argument,"wis") ) {
	wStat = STAT_WIS; stat_str = "WIS"; }
    else
    if ( !str_cmp(argument,"agt") ) {
	wStat = STAT_AGT; stat_str = "AGT"; }
    else
    if ( !str_cmp(argument,"end") ) {
	wStat = STAT_END; stat_str = "END"; }
    else
    if ( !str_cmp(argument,"soc") ) {
	wStat = STAT_SOC; stat_str = "SOC"; }
    else
    {
	send_to_char("Invalid selection.  Type help for help.   Pick again -> ",ch); return;
    }

    if ( ch->perm_stat[wStat] +1 > get_max_train(ch, wStat) )
    {
	send_to_char("That would exceed your racial max.\n\r",ch);
	send_to_char("Pick again -> ",ch);
	return;
    }
    /* go calculate the stat cost to increase the selected stat */ 
    statCost = calc_stat_cost( ch, wStat);

    /* check to see if you have enough bonus points left */
    if (statCost > ch->gen_data->bonus_points )
    {
	sprintf(buf,"That requires %d points.  You only have %d.\n\r",
		statCost,
		ch->gen_data->bonus_points );
	send_to_char(buf,ch);
	send_to_char("Pick again -> ",ch);
	return;
    }

    /* decrease bonus points by the stat cost and increase stat by one */ 
    ch->gen_data->bonus_points -= statCost;
    ch->perm_stat[wStat]++;
    sprintf(buf,"Improved %s to %d.\n\r",stat_str,ch->perm_stat[wStat]);
    send_to_char(buf,ch);

    if (ch->gen_data->bonus_points <= 0 || !can_use_points(ch,ch->gen_data->bonus_points) )
    {
  ch->gen_data->bonus_points = UMAX(0,ch->gen_data->bonus_points);
  do_help(ch,"motd");
  d->connected = CON_READ_MOTD;
  ch->train += ch->gen_data->bonus_points;
  free_gen_data(ch->gen_data);
  ch->gen_data = NULL;
    }
    else
       show_stats( d );

    
    break;

    case CON_GEN_GROUPS:
  send_to_char("\n\r",ch);
  if (!str_cmp(argument,"done"))
  {
      /* Check for no weapons on finishing, else they get stuck */
      weapon_found = FALSE;
      for ( i = 0; weapon_table[i].name != NULL; i++)
      {
         if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
            weapon_found = TRUE;
      }
      if(!weapon_found)
      {
         strcat(buf,"\n\rYou have no weapons to choose from. Please add one. ");
         write_to_buffer(d,buf,0);
         break;
      }

      sprintf(buf,"Creation points: %d\n\r",ch->pcdata->points);
      send_to_char(buf,ch);
      sprintf(buf,"Experience per level: %d\n\r",
        exp_per_level(ch,ch->gen_data->points_chosen));
	/*
      if (ch->pcdata->points < 40)
    ch->train = (40 - ch->pcdata->points + 1) / 2;
    */
      send_to_char(buf,ch);
     
      /* Pfresh Chars dont pick a new deity */
      if (IS_SET(ch->mhs,MHS_PREFRESHED))
      {
	 newLevel = ch->exp / exp_per_level(ch,ch->pcdata->points);
	 /* remove the free level "1" */
	 newLevel -= 1;
	 if( ( ch->level < 11 ) && (newLevel > ch->level ) )
	   newLevel = ch->level ;
	 if(   IS_SET(ch->act,PLR_VAMP) ||
	       IS_SET(ch->act,PLR_WERE) ||
	      IS_SET(ch->act,PLR_MUMMY) 
           )
	 {
	    if ( newLevel > 76 )
	       newLevel = 76;
	 }
	 else
	 {
            if(newLevel > 50 )
	       newLevel =50;
	 }
         sprintf(buf,"Debit levels: %d\n\r",newLevel);
         send_to_char(buf,ch);

         write_to_buffer( d, "\n\r", 2 );
         write_to_buffer(d,
       "Please pick a weapon from the following choices:\n\r",0);
         buf[0] = '\0';
         for ( i = 0; weapon_table[i].name != NULL; i++)
            if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
            {
               strcat(buf,weapon_table[i].name);
               strcat(buf," ");
            }
         strcat(buf,"\n\rYour choice? ");
         write_to_buffer(d,buf,0);
         d->connected = CON_PICK_WEAPON;
      }
      else
      {
         write_to_buffer( d, "\n\r", 2 );
         write_to_buffer(d,
       "Please pick a Deity (help deity for more information)\n\r",0);
         write_to_buffer(d,"Your choice? ",0);
         d->connected = CON_PICK_DEITY;
      }

      break;
  }

  if (!parse_gen_groups(ch,argument))
  send_to_char(
  "Choices are: list,learned,premise,add,drop,info,help, and done.\n\r"
  ,ch);

  do_help(ch,"menu choice");
  break;

    case CON_READ_IMOTD:
  write_to_buffer(d,"\n\r",2);
  do_help( ch, "motd" );
  d->connected = CON_READ_MOTD;
  break;

    case CON_READ_MOTD:
  if ( ch->pcdata == NULL || ch->pcdata->pwd[0] == '\0')
  {
      write_to_buffer( d, "Warning! Null password!\n\r",0 );
      write_to_buffer( d, "Please report old password with bug.\n\r",0);
      write_to_buffer( d,
    "Type 'password null <new password>' to fix.\n\r",0);
  }

  write_to_buffer( d, 
    "\n\rWelcome to MooseHead Sled.  Please do not feed the mobiles.\n\r",
      0 );
  ch->next        = char_list;
  char_list       = ch;
  d->connected    = CON_PLAYING;
  reset_char(ch);
  if (ch->pcdata->last_level == 0 || ch->pcdata->last_level == NULL)
     ch->pcdata->last_level = 1; /* Fixes symbol bugs */
  if ( ch->level == 0 )
  {

      ch->level   = 1;
      ch->train    += 3;
      ch->practice = 5;

      if (IS_SET(ch->mhs,MHS_PREFRESHED))
      {
      /* Fill any last minute things in here */
         ch->hit     = 20;
         ch->max_hit = 20;
         ch->pcdata->perm_hit = 20;
         ch->mana    = 100;
         ch->max_mana= 100;
         ch->pcdata->perm_mana= 100;
         ch->move    = 100;
         ch->max_move= 100;
         ch->pcdata->perm_move= 100;
         do_outfit(ch,"");

         REMOVE_BIT(ch->mhs,MHS_PREFRESHED);
      }
      else
      {
         ch->hit     = ch->max_hit;
         ch->mana    = ch->max_mana;
         ch->move    = ch->max_move;
         ch->exp     = exp_per_level(ch,ch->pcdata->points);
         set_title( ch, "the confused" );

         ch->gold = number_range( 20,40 );
         ch->silver = number_range( 300,600 );
       sprintf (buf,"SMURF: %s outfit",ch->name);
       log_string(buf); 
         do_outfit(ch,"");
       sprintf (buf,"SMURF: %s after outfit",ch->name);
       log_string(buf); 
         obj_to_char(create_object(get_obj_index(OBJ_VNUM_MAP),0,FALSE),ch);
         obj_to_char(create_object(get_obj_index(OBJ_VNUM_MAP_BOINGA),0,FALSE),ch);
      }

#ifdef OLC_VERSION
      char_to_room( ch, get_room_index( ROOM_VNUM_DEAD ) );
#else /*game version*/
      char_to_room( ch, get_room_index( ROOM_VNUM_SCHOOL ) );
#endif

      send_to_char("\n\r",ch);
      do_help(ch,"NEWBIE INFO");
      send_to_char("\n\r",ch);
  }
  else if ( ch->in_room != NULL )
  {
      char_to_room( ch, ch->in_room );
  }
  else if ( IS_IMMORTAL(ch) )
  {
      char_to_room( ch, get_room_index( ROOM_VNUM_CHAT ) );
  }
  else
  {
      char_to_room( ch, get_room_index( ROOM_VNUM_TEMPLE ) );
  }

  act( "$n has entered the game.", ch, NULL, NULL, TO_ROOM ,FALSE);
  do_look( ch, "auto" );

  wiznet("$N has left real life behind.",ch,NULL,
    WIZ_LOGINS,WIZ_SITES,get_trust(ch));
    if( (!IS_IMMORTAL(ch) || (ch->incog_level == 0 && ch->invis_level == 0))
	&& ch->desc != NULL )
      {
  pnet("$N has entered Boinga.",ch,NULL,PNET_LOGINS,NULL,get_trust(ch));
      }

/* All Highlanders(with certain kills) feel a Highlander enter */
if (IS_SET(ch->mhs,MHS_HIGHLANDER))
{
   sprintf(buf, "You feel the presence of a Highlander entering Boinga.\n\r");

   for ( d = descriptor_list; d != NULL; d = d->next )
   {
       CHAR_DATA *victm;

       victm = d->original ? d->original : d->character;

       if ( d->connected == CON_PLAYING &&
            d->character != ch &&
            IS_SET(victm->mhs,MHS_HIGHLANDER) &&
	    (victm->pcdata->highlander_data[ALL_KILLS] >= 6))
          send_to_char(buf, victm);
   }
}

  ch->logon	= current_time;

  if (ch->pet != NULL)
  {
      char_to_room(ch->pet,ch->in_room);
      act("$n has entered the game.",ch->pet,NULL,NULL,TO_ROOM,FALSE);
  }
#ifdef GAME_VERSION
  do_unread(ch,"");
  do_count(ch,"");
#endif
  break;
    }

    return;
}


bool check_parse_surname( char *name )
{
    int clan;

    /*
     * Reserved words.
     */
  if ( is_name( name, 
      "all auto immortal self someone something the you outcast loner on off") )
    return FALSE;
  
    /* check clans */
    for (clan = 0; clan < MAX_CLAN; clan++)
    {
    	if (LOWER(name[0]) == LOWER(clan_table[clan].name[0])
    	&&  !str_cmp(name,clan_table[clan].name))
    	   return FALSE;
    }

    if (str_cmp(capitalize(name),"Rusty") && (!str_prefix("rusty",name)
        || !str_suffix("rusty",name)))
    return FALSE;

    /*
     * Length restrictions.
     */
     
    if ( strlen(name) <  2 )
  return FALSE;

    if ( strlen(name) > 12 )
  return FALSE;

    /*
     * Alphanumerics only.
     * Lock out IllIll twits.
     */
    {
  char *pc;
  bool fIll,adjcaps = FALSE,cleancaps = FALSE;
  int total_caps = 0;

  fIll = TRUE;
  for ( pc = name; *pc != '\0'; pc++ )
  {
      if ( !isalpha(*pc) && *pc != 0x27 )
    return FALSE;

      if ( isupper(*pc)) /* ugly anti-caps hack */
      {
    if (adjcaps)
        cleancaps = TRUE;
    total_caps++;
    adjcaps = TRUE;
      }
      else
    adjcaps = FALSE;

      if ( LOWER(*pc) != 'i' && LOWER(*pc) != 'l' )
    fIll = FALSE;
  }
  if ( fIll )
      return FALSE;

  if (cleancaps || (total_caps > (strlen(name)) / 2 && strlen(name) < 3))
      return FALSE;
    }

    return TRUE;
}



/*
 * Parse a name for acceptability.
 */
bool check_parse_name( char *name )
{
    int clan,count;
    DESCRIPTOR_DATA *d,*dnext;

    /*
     * Reserved words.
     */
    if ( is_name( name, 
        "all auto immortal self someone something the you outcast loner on off") )
    return FALSE;
  
    /*
     * check names of people playing. Yes, this is necessary for multiple
     * newbies with the same name
     */
    if (descriptor_list) {
        count=0;
        for (d = descriptor_list; d != NULL; d = dnext) {
            dnext=d->next;
            if (d->connected!=CON_PLAYING
		&& d->character
		&& d->character->name
                && d->character->name[0] 
		&& !str_cmp(d->character->name,name)) {
                count++;
                close_socket(d);
            }
        }
        if (count) {
            sprintf(log_buf,"Double newbie alert (%s)",name);
            wiznet(log_buf,NULL,NULL,WIZ_LOGINS,0,0);

            return FALSE;
        }
    }

    if( !str_cmp(capitalize(name),"Matook") )
      return TRUE;

    /* check clans */
    for (clan = 0; clan < MAX_CLAN; clan++)
    {
    	if (LOWER(name[0]) == LOWER(clan_table[clan].name[0])
    	&&  !str_cmp(name,clan_table[clan].name))
    	   return FALSE;
    }

    if (str_cmp(capitalize(name),"Rusty") && (!str_prefix("rusty",name)
        || !str_suffix("rusty",name)))
    return FALSE;

    /*
     * Length restrictions.
     */
     
    if ( strlen(name) <  2 )
  return FALSE;

#if defined(MSDOS)
    if ( strlen(name) >  8 )
  return FALSE;
#endif

#if defined(macintosh) || defined(unix)
    if ( strlen(name) > 12 )
  return FALSE;
#endif

    /*
     * Alphanumerics only.
     * Lock out IllIll twits.
     */
    {
  char *pc;
  bool fIll,adjcaps = FALSE,cleancaps = FALSE;
  int total_caps = 0;

  fIll = TRUE;
  for ( pc = name; *pc != '\0'; pc++ )
  {
      if ( !isalpha(*pc) )
    return FALSE;

      if ( isupper(*pc)) /* ugly anti-caps hack */
      {
    if (adjcaps)
        cleancaps = TRUE;
    total_caps++;
    adjcaps = TRUE;
      }
      else
    adjcaps = FALSE;

      if ( LOWER(*pc) != 'i' && LOWER(*pc) != 'l' )
    fIll = FALSE;
  }
  if ( fIll )
      return FALSE;

  if (cleancaps || (total_caps > (strlen(name)) / 2 && strlen(name) < 3))
      return FALSE;
    }

    /*
     * Prevent players from naming themselves after mobs.
     *
    {
  extern MOB_INDEX_DATA *mob_index_hash[MAX_KEY_HASH];
  MOB_INDEX_DATA *pMobIndex;
  int iHash;

  for ( iHash = 0; iHash < MAX_KEY_HASH; iHash++ )
  {
      for ( pMobIndex  = mob_index_hash[iHash];
      pMobIndex != NULL;
      pMobIndex  = pMobIndex->next )
      {
    if ( is_name( name, pMobIndex->player_name ) )
        return FALSE;
      }
  }
    }*/

    return TRUE;
}


/* in comm.c.. after check_parse_name */

bool check_mob_name (char *name,bool old_char)
{
  extern MOB_INDEX_DATA *mob_index_hash[MAX_KEY_HASH];
  MOB_INDEX_DATA *pMobIndex;
  int iHash;

  for ( iHash = 0; iHash < MAX_KEY_HASH; iHash++ )
  {
      for ( pMobIndex  = mob_index_hash[iHash];
      pMobIndex != NULL;
      pMobIndex  = pMobIndex->next )
      {
    if ( is_name( name, pMobIndex->player_name ) ) {
        if (old_char) {
          char buf[MAX_STRING_LENGTH];

          sprintf (buf,"Warning:  name conflict for name '%s'",
            name);
          log_string (buf);
        }
        return FALSE;
    }
      }
  }

    return TRUE;
} 


/*
 * Look for link-dead player to reconnect.
 */
bool check_reconnect( DESCRIPTOR_DATA *d, char *name, bool fConn )
{
    CHAR_DATA *ch;
    bool found=FALSE;

    for ( ch = char_list; ch != NULL; ch = ch->next )
    {
  if ( !IS_NPC(ch)
  &&   (!fConn || ch->desc == NULL)
  &&   !str_cmp( d->character->name, ch->name ) )
  {
      if ( fConn == FALSE )
      {
    free_string( d->character->pcdata->pwd );
    d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
      }
      else
      {
    OBJ_DATA *obj;

   if (d->character->pet) {
      CHAR_DATA *pet=d->character->pet;

      char_to_room(pet,get_room_index( ROOM_VNUM_LIMBO));
      stop_follower(pet);
      extract_char(pet,TRUE);
    }
    free_char( d->character );
    d->character = ch;
    ch->desc         = d;
    ch->timer        = 0;
    ch->pcdata->interp_fun = NULL;
/*    get_ident_info ( ch ); */
    for ( ch = char_list; ch != NULL; ch = ch->next )
    {
      if( ch == d->character )
	{ 
	  found = TRUE;
	  break;
	}
    }
    if( !found )
    {
      sprintf( log_buf, "%s not found in char_list on reconnect",
		d->character->name );
      log_string( log_buf );
      d->character->next = char_list;
      char_list = d->character;
    }
    send_to_char(
        "Reconnecting. Type replay to see missed tells.\n\r", ch );
    act( "$n has reconnected.", ch, NULL, NULL, TO_ROOM ,FALSE);
    if ((obj = get_eq_char(ch,WEAR_LIGHT)) != NULL
    &&  obj->item_type == ITEM_LIGHT && obj->value[2] != 0)
        --ch->in_room->light;

    sprintf( log_buf, "%s@@%s reconnected.", ch->name, d->host );
    log_string( log_buf );
    wiznet("$N groks the fullness of $S link.",
        ch,NULL,WIZ_LINKS,0,get_trust(ch));
   //pnet("$N groks the fullness of $S link.",ch,NULL,PNET_LINKS,0,get_trust(ch));
    d->connected = CON_PLAYING;

      }
      return TRUE;
  }
    }

    return FALSE;
}



/*
 * Check if already playing.
 */
bool check_playing( DESCRIPTOR_DATA *d, char *name )
{
    DESCRIPTOR_DATA *dold;

    for ( dold = descriptor_list; dold; dold = dold->next )
    {
  if ( dold != d
  &&   dold->character != NULL
  &&   dold->connected != CON_GET_NAME
  &&   dold->connected != CON_GET_OLD_PASSWORD
  &&   !str_cmp( name, dold->original
     ? dold->original->name : dold->character->name ) )
  {
      write_to_buffer( d, "That character is already playing.\n\r",0);
	strcpy( d->incomm, "" );
      /*write_to_buffer( d, "Do you wish to connect anyway (Y/N)?",0);*/
	     for ( dold = descriptor_list; dold != NULL; dold = d_next )
      {
    d_next = dold->next;
    if (dold == d || dold->character == NULL)
        continue;

    if (str_cmp(d->character->name,dold->original ?
        dold->original->name : dold->character->name))
        continue;

    close_socket(dold);
      }
      if (check_reconnect(d,d->character->name,TRUE))
    return TRUE;

      d->connected = CON_PLAYING;
      return TRUE;
  }
    }

    return FALSE;
}



void stop_idling( CHAR_DATA *ch )
{
    if ( ch == NULL
    ||   ch->desc == NULL
    ||   ch->desc->connected != CON_PLAYING
    ||   ch->was_in_room == NULL 
    ||   ch->in_room != get_room_index(ROOM_VNUM_LIMBO))
  return;

    ch->timer = 0;
    char_from_room( ch );
    char_to_room( ch, ch->was_in_room );
    if ( is_mounted(ch) )
    {
	char_from_room( ch->riding );
	char_to_room( ch->riding, ch->was_in_room );
    }
    ch->was_in_room     = NULL;
    act( "$n has returned from the void.", ch, NULL, NULL, TO_ROOM ,FALSE);
    return;
}

bool can_use_points( CHAR_DATA *ch, int points )
{
    int i;

    if ( points <= 0 ) return FALSE;
    for ( i = 0 ; i < MAX_STATS ; i++ )
       /* if ( improve_table[ch->perm_stat[i]].cost <= points */
        if ( calc_stat_cost(ch,i) <= points 
	  && get_max_train(ch,i) > ch->perm_stat[i] )
		return TRUE;

    return FALSE;
}

int calc_stat_cost( CHAR_DATA *ch, int attr_type )
{

/*    *** new code
      go to the race table and compare stats to current stats
      the difference between the two cost is the cost to increase
      that stat , add one since cost is
	always one more than the difference. example:
	str is currently 10, original is 10. difference is 0
	cost is 1 to increase str to 11 .  another mod for
	primary and secondary attrs -3 and -2 respectively
*/

  int cost;
  cost = ch->perm_stat[attr_type] - pc_race_table[ch->race].stats[attr_type];
  cost +=1; /*  mod because of difference */

  /*  check to see if this attr type is a primary or secondary stat
      always check based on old class , since bonus is based on old class */
  if (class_table[ch->pcdata->old_class].attr_prime == attr_type)
  {
      /*  it is the primary stat, decrease cost by 3 */
      cost -=3;
  }
  if ( class_table[ch->pcdata->old_class].attr_second == attr_type)
  {
     /*  it is a secondary stat, decrease cost by 2 */
      cost -=2;
  }

  return cost;
}


void show_stats( DESCRIPTOR_DATA *d )
{
    CHAR_DATA *ch;
    int i,statCost;
    char buf[MAX_STRING_LENGTH];
    static char *attrib_name[] = {
	"Str", "Int", "Wis", "Dex", "Con", "Agt", "End", "Soc" };

    if ( ( ch = d->character ) == NULL )
    {
	bug("display_stats : NULL ch in d",0);
	return;
    }

    send_to_char("\n\r",ch);
    for ( i = 0 ; i < MAX_STATS ; i++ )
    {
    statCost = calc_stat_cost(ch,i);
    sprintf(buf,"%s: Current: %2d, spend %d point%s to raise to %2d.\n\r",
        attrib_name[i],
	ch->perm_stat[i],
	/* improve_table[ch->perm_stat[i]].cost,
 	improve_table[ch->perm_stat[i]].cost == 1 ? "" : "s",
	*/
	statCost,
	statCost == 1 ? "" : "s",
	ch->perm_stat[i]+1 );
    send_to_char(buf,ch);
    }

    sprintf(buf,"You have %d points.  Improve which attribute? -> ",
	ch->gen_data->bonus_points );
    send_to_char(buf,ch);
}
/*
 * Write something to a given room
 * Hybred between stc and act, only works if awake
 */
void send_to_room( const char *txt, ROOM_INDEX_DATA *room )
{
    CHAR_DATA *ch;

    for ( ch = room->people ; ch!= NULL ; ch = ch->next_in_room )
    {
	if ( !IS_AWAKE(ch))
	    continue;

	send_to_char(txt,ch);
    }

    return;
}

/*
 * Write to one char.
 */
void send_to_char( const char *txt, CHAR_DATA *ch )
{
  
    if ( (txt != NULL) && (ch->desc != NULL) )
  write_to_buffer( ch->desc, txt, strlen(txt) );
    return;
}

/*
 * Send a page to one char.
 */
void page_to_char( const char *txt, CHAR_DATA *ch )
{
    if ( (txt == NULL) || (ch->desc == NULL) ) 
	return;

    if (ch->lines == 0 )
    {
  send_to_char(txt,ch);
  return;
    }
  
#if defined(macintosh)
  send_to_char(txt,ch);
#else
    if (ch->desc->showstr_head &&
       (strlen(txt)+strlen(ch->desc->showstr_head)+1) < 32000)
    {
#ifdef OLC_VERSION
      char *temp=alloc_mem(strlen(txt) + strlen(ch->desc->showstr_head) + 1);
#else
      char *temp=GC_MALLOC(strlen(txt) + strlen(ch->desc->showstr_head) + 1);
#endif
      strcpy(temp, ch->desc->showstr_head);
      strcat(temp, txt);
      ch->desc->showstr_point = temp +
       (ch->desc->showstr_point - ch->desc->showstr_head);
      free_mem(ch->desc->showstr_head, strlen(ch->desc->showstr_head) + 1);
      ch->desc->showstr_head=temp;
    }
    else
    {
      if (ch->desc->showstr_head)
      free_mem(ch->desc->showstr_head, strlen(ch->desc->showstr_head)+1);
#ifdef OLC_VERSION
      ch->desc->showstr_head = alloc_mem(strlen(txt) + 1);
#else
      ch->desc->showstr_head = GC_MALLOC(strlen(txt) + 1);
#endif
      strcpy(ch->desc->showstr_head,txt);
      ch->desc->showstr_point = ch->desc->showstr_head;
      show_string(ch->desc,"");
    }
    return;
#endif
}


/* string pager */
void show_string(struct descriptor_data *d, char *input)
{
    char buffer[4*MAX_STRING_LENGTH];
    char buf[MAX_INPUT_LENGTH];
    register char *scan, *chk;
    int lines = 0, toggle = 1;
    int show_lines;

    one_argument(input,buf);
    if (buf[0] != '\0')
    {
	  if (d->showstr_head)
  	  {
      	   free_mem(d->showstr_head,strlen(d->showstr_head));
     	   d->showstr_head = 0;
  	  }
  	  d->showstr_point  = 0;
 	  return;
    }

    if (d->character)
	show_lines = d->character->lines;
    else
	show_lines = 0;

    for (scan = buffer; ; scan++, d->showstr_point++)
    {
	if (((*scan = *d->showstr_point) == '\n' || *scan == '\r')
	   && (toggle = -toggle) < 0)
	   lines++;

  else if (!*scan || (show_lines > 0 && lines >= show_lines))
  {
      *scan = '\0';
      write_to_buffer(d,buffer,strlen(buffer));
      for (chk = d->showstr_point; isspace(*chk); chk++);
      {
	if (!*chk)
	{
           if (d->showstr_head)
           {
		free_mem(d->showstr_head,strlen(d->showstr_head));
		d->showstr_head = 0;
        }
        d->showstr_point  = 0;
    }
      }
      return;
  }
    }
    return;
}
  

/* quick sex fixer */
void fix_sex(CHAR_DATA *ch)
{
    if (ch->sex < 0 || ch->sex > 2)
  ch->sex = IS_NPC(ch) ? 0 : ch->pcdata->true_sex;
}

void act(const char *format, CHAR_DATA *ch, const void *arg1, const void *arg2,
    int type, bool ooc)
{
    /* to be compatible with older code */
    act_new(format,ch,arg1,arg2,type,POS_RESTING,ooc);
}

void act_new( const char *format, CHAR_DATA *ch, const void *arg1, 
        const void *arg2, int type, int min_pos, bool ooc)
{
    static char * const he_she  [] = { "it",  "he",  "she" };
    static char * const him_her [] = { "it",  "him", "her" };
    static char * const his_her [] = { "its", "his", "her" };
 
    char buf[2*MAX_STRING_LENGTH];
    char fname[MAX_INPUT_LENGTH];
    CHAR_DATA *to;
    CHAR_DATA *vch = (CHAR_DATA *) arg2;
    OBJ_DATA *obj1 = (OBJ_DATA  *) arg1;
    OBJ_DATA *obj2 = (OBJ_DATA  *) arg2;
    const char *str;
    const char *i='\0';
    char *point;
 
    /*
     * Discard null and zero-length messages.
     */
    if ( format == NULL || format[0] == '\0' )
  return;

    /* discard null rooms and chars */
    if (ch == NULL || ch->in_room == NULL)
  return;

    to = ch->in_room->people;
    if ( type == TO_VICT )
    {
  if ( vch == NULL )
  {
      bug( "Act: null vch with TO_VICT.", 0 );
      return;
  }

  if (vch->in_room == NULL)
      return;

  to = vch->in_room->people;
    }
 
    for ( ; to != NULL; to = to->next_in_room )
    {
  if ( (to->desc == NULL) || (to->position < min_pos) )
      continue;
 
  if ( (type == TO_CHAR) && to != ch )
      continue;
  if ( type == TO_VICT && ( to != vch || to == ch ) )
      continue;
  if ( type == TO_ROOM && to == ch )
      continue;
  if ( type == TO_NOTVICT && (to == ch || to == vch) )
      continue;
 
  point   = buf;
  str     = format;
  while ( *str != '\0' )
  {
      if ( *str != '$' )
      {
    *point++ = *str++;
    continue;
      }
      ++str;
 
      if ( arg2 == NULL && *str >= 'A' && *str <= 'Z' )
      {
    bug( "Act: missing arg2 for code %d.", *str );
    i = " <@@@@@@> ";
      }
      else
      {
    switch ( *str )
    {
    default:  bug( "Act: bad code %d.", *str );
        i = " <@@@@@@> ";                                break;
    /* Thx alex for 't' idea */
    case 't': if(arg1) i = (char *) arg1;	break;
    case 'T': if(arg2) i = (char *) arg2;	break;
    case 'l':
    case 'n': if(ch) {
        if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE )
	{
          i = (!IS_NPC(to) && IS_SET(to->act,PLR_HOLYLIGHT)) ?
       		 PERS(ch,to,ooc): ch->long_descr;
	}
	else
	{
	  i = PERS( ch, to, ooc );
	}
    }
	  break;
    case 'L':
    case 'N': if(vch) {
    if(IS_SET(vch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE )
	{
          i = (!IS_NPC(to) && IS_SET(to->act,PLR_HOLYLIGHT)) ?
       		 PERS(vch,to,ooc): vch->long_descr;
	}
	else
	{
	  i = PERS( vch, to, ooc );
	}
    }
	  break;
    case 'e': if(ch) i = he_she  [URANGE(0, ch  ->sex, 2)];        break;
    case 'E': if(vch) i = he_she  [URANGE(0, vch ->sex, 2)];        break;
    case 'm': if(ch) i = him_her [URANGE(0, ch  ->sex, 2)];        break;
    case 'M': if(vch) i = him_her [URANGE(0, vch ->sex, 2)];        break;
    case 's': if(ch) i = his_her [URANGE(0, ch  ->sex, 2)];        break;
    case 'S': if(vch) i = his_her [URANGE(0, vch ->sex, 2)];        break;
 
    case 'r': if(arg2) i = (char *) arg2;		    break;

    case 'p':
        if(obj1) i = can_see_obj( to, obj1 )
          ? obj1->short_descr
          : "something";
        break;
 
    case 'P':
        if(obj2) i = can_see_obj( to, obj2 )
          ? obj2->short_descr
          : "something";
        break;
 
    case 'd':
        if ( arg2 == NULL || ((char *) arg2)[0] == '\0' )
        {
      i = "door";
        }
        else
        {
      one_argument( (char *) arg2, fname );
      i = fname;
        }
        break;

    }
      }
 
      ++str;
      while ( ( *point = *i ) != '\0' )
    ++point, ++i;
  }
 
  *point++ = '\n';
  *point++ = '\r';
  buf[0]   = UPPER(buf[0]);
  write_to_buffer( to->desc, buf, point - buf );
    }
 
    return;
}



/*
 * Macintosh support functions.
 */
#if defined(macintosh)
int gettimeofday( struct timeval *tp, void *tzp )
{
    tp->tv_sec  = time( NULL );
    tp->tv_usec = 0;
}
#endif
@


1.310
log
@floating point bug in something
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.309 2004/03/27 15:51:40 boogums Exp $";
d1213 1
d1218 1
@


1.309
log
@many changes
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.308 2004/02/04 02:53:01 boogums Exp $";
d1798 11
a1808 4
	    sprintf( buf2, "{%s%d%%{x",
		ch->move < ch->max_move / 2 ? "R" :
		ch->move < ch->max_move *3/4 ? "Y" : "W", (ch->move*100)/ch->max_move );
	    i = buf2; break;
@


1.308
log
@taking out shapeshifter
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.307 2004/01/11 22:07:29 boogums Exp $";
d74 1
@


1.307
log
@trying something new
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.306 2003/12/09 21:33:31 rusty Exp $";
d2354 7
@


1.306
log
@pnet logins doesn't show pload and punload
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.305 2003/12/06 22:43:42 boogums Exp $";
d2217 1
a2217 1

@


1.305
log
@pnet logins and logouts no longer shown at all
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.304 2003/11/30 01:23:04 boogums Exp $";
d3670 5
a3674 4
  //  if(!IS_IMMORTAL(ch) || (ch->incog_level == 0 && ch->invis_level == 0))
  //    {
  //pnet("$N has entered Boinga.",ch,NULL,PNET_LOGINS,NULL,get_trust(ch));
  //    }
@


1.304
log
@10 not five
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.303 2003/11/30 01:19:40 boogums Exp $";
d1271 4
a1274 4
      if(!IS_IMMORTAL(ch))
      {
        pnet("Net death has claimed $N.",ch,NULL,PNET_LINKS,0,0);
      }
d3670 4
a3673 4
    if(!IS_IMMORTAL(ch) || (ch->incog_level == 0 && ch->invis_level == 0))
      {
  pnet("$N has entered Boinga.",ch,NULL,PNET_LOGINS,NULL,get_trust(ch));
      }
d4010 1
a4010 1
   pnet("$N groks the fullness of $S link.",ch,NULL,PNET_LINKS,0,get_trust(ch));
@


1.303
log
@10 pracs not five
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.302 2003/11/29 23:37:37 boogums Exp $";
d2358 1
a2358 1
  ch->practice += 15;
@


1.302
log
@prcs not skillpoints
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.301 2003/11/29 23:31:32 boogums Exp $";
d2358 1
a2358 1
  ch->practice += 5;
@


1.301
log
@taking out research skill
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.300 2003/11/22 03:34:19 boogums Exp $";
d2358 1
a2358 1
  ch->skill_points += 5;
@


1.300
log
@doing random stuff.  infuse bug, and wiping out honor skill
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.299 2003/10/08 00:49:27 ndagger Exp $";
d2350 11
d2362 1
a2362 2
	ch->clan = clan_lookup("loner");;
	ch->pcdata->rank = 0;
d2364 2
@


1.299
log
@10/07/03 Nightdager:  Implemented bitch channel.  FUN!
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.298 2003/09/15 17:18:19 rusty Exp $";
d2357 5
@


1.298
log
@timing try
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.297 2003/09/15 17:09:47 rusty Exp $";
d3203 1
@


1.297
log
@speeding up the game?
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.296 2003/08/25 22:57:55 boogums Exp $";
d730 1
a730 1
      if ( delta >= 800000 / PULSE_PER_SECOND )
@


1.296
log
@avarice is gone
made loners and ranked to 0
boogums
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.295 2003/08/25 22:56:23 boogums Exp $";
d730 1
a730 1
      if ( delta >= 1000000 / PULSE_PER_SECOND )
@


1.295
log
@Avarice is gone
boogums
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.294 2003/06/14 19:53:10 boogums Exp $";
d2351 1
a2351 1
	ch->clan = 0;
@


1.294
log
@adding the restrain spell to the infuse ability
corye
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.293 2003/06/04 19:56:03 boogums Exp $";
d2347 8
@


1.293
log
@changed the ban message
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.292 2003/06/03 03:13:07 boogums Exp $";
d2360 7
@


1.292
log
@ok this'll yank confusion and aura of cthon
corye
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.291 2003/02/20 19:01:53 rusty Exp $";
d1206 2
d1209 3
a1211 1
      "Email rusty@@mraz.org and/or poquah@@matook.com for more information.\n\r", 0, dnew );
@


1.291
log
@str_cmp() to str_prefix() for surname in string command
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.290 2003/02/05 05:17:15 boogums Exp $";
d2343 14
@


1.290
log
@slight change to pick stats prompt
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.289 2003/01/06 02:55:52 boogums Exp $";
d2095 1
@


1.289
log
@t prohipitibin smurfs from loggin in i think
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.288 2002/12/23 01:54:33 boogums Exp $";
d3394 1
a3394 1
	send_to_char("Invalid selection.  Pick again -> ",ch); return;
@


1.288
log
@buffies going out new kits going in
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.287 2002/12/23 00:37:27 boogums Exp $";
d2319 7
@


1.287
log
@trying the buffy swap out thing on OLC
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.286 2002/11/26 05:35:26 boogums Exp $";
d2327 3
@


1.286
log
@adding a start pfight timer to combat IM scouters
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.285 2002/10/26 02:43:18 boogums Exp $";
d2319 13
@


1.285
log
@have a comment in comm.c interp.c dunnow what's going on and mag2.c
has the affects done
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.284 2002/10/12 03:07:35 boogums Exp $";
d2400 6
@


1.284
log
@tweaks to the amgic system
took out the shard  for kaeth buyback
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.283 2002/10/10 03:13:19 boogums Exp $";
d2399 5
a2403 1
/* Poquah temp remove come back to this later 
@


1.283
log
@actobj interep.h merc.h wait oh shit gotta ocmment those out
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.282 2002/09/29 02:02:35 boogums Exp $";
d2358 1
a2358 1
       sprintf(log_buf,"Taking %d from %s and giving them two shards.",obj2->pIndexData->vnum,ch->name);
d2361 2
a2362 2
       obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),ch);
       obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),ch);
@


1.282
log
@ trying something else
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.281 2002/09/29 01:25:02 boogums Exp $";
d2847 2
a2848 1

@


1.281
log
@i figure that it has to do with them carrying more than they can darry
so i just cycle thru it twice
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.280 2002/09/29 01:11:57 boogums Exp $";
a2336 5
/*      if ( (IS_SET(obj->value[1], CONT_CLOSED)) )
      {
        REMOVE_BIT(obj->value[1], CONT_CLOSED); 
      }
*/
d2340 1
a2340 4
        get_obj( ch, obj2, obj );
      }
    }
  }
d2342 1
a2342 3
  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
    obj_next = obj->next_content;
d2344 10
a2353 10
         obj->pIndexData->vnum == 12046
      || obj->pIndexData->vnum == 12047
      || obj->pIndexData->vnum == 12048
      || obj->pIndexData->vnum == 12049
      || obj->pIndexData->vnum == 12050
      || obj->pIndexData->vnum == 12051
      || obj->pIndexData->vnum == 12055
      || obj->pIndexData->vnum == 12056
      || obj->pIndexData->vnum == 12057
      || obj->pIndexData->vnum == 12058 
d2358 1
a2358 1
       sprintf(log_buf,"Taking %d from %s and giving them two shards.",obj->pIndexData->vnum,ch->name);
d2360 1
a2360 1
       extract_obj(obj);
d2364 1
a2364 17
  }

  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
    obj_next = obj->next_content;

    if(obj->item_type == ITEM_CONTAINER)
    {
/*      if ( (IS_SET(obj->value[1], CONT_CLOSED)) )
      {
        REMOVE_BIT(obj->value[1], CONT_CLOSED);
      }
*/
      for ( obj2 = obj->contains; obj2 != NULL; obj2 = obj_next2 )
      {
        obj_next2 = obj2->next_content;
        get_obj( ch, obj2, obj );
d2368 1
d2382 1
a2382 1
      || obj->pIndexData->vnum == 12058
d2394 1
@


1.280
log
@found the bug i think
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.279 2002/09/28 16:36:40 boogums Exp $";
d2337 1
a2337 1
      if ( (IS_SET(obj->value[1], CONT_CLOSED)) )
d2341 1
a2341 1

d2364 44
@


1.279
log
@cycling thru bags within bags
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.278 2002/09/28 15:19:24 boogums Exp $";
d2337 1
a2337 1
      for ( obj2 = obj->contains; obj2 != NULL; obj2 = obj_next2 )
d2339 1
a2339 2
        obj_next2 = obj2->next_content;
        get_obj( ch, obj2, obj );
a2340 5
    }
  }
  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
    obj_next = obj->next_content;
a2341 15
    if(obj->item_type == ITEM_CONTAINER)
    {
      for ( obj2 = obj->contains; obj2 != NULL; obj2 = obj_next2 )
      {
        obj_next2 = obj2->next_content;
        get_obj( ch, obj2, obj );
      }
    }
  }
  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
  {
    obj_next = obj->next_content;

    if(obj->item_type == ITEM_CONTAINER)
    {
@


1.278
log
@in goes the kaethen check remove gear
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.277 2002/09/26 04:24:02 boogums Exp $";
d2330 27
@


1.277
log
@tweaking haggle a bit, making the social stat play into it
corey

CVSk: ----------------------------------------------------------------------
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.276 2002/09/24 03:15:33 boogums Exp $";
d2321 1
a2321 1
#ifdef COREY_VERSION
d2372 1
a2372 1
#endif
@


1.276
log
@wrapped the test code all up nice and clean
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.275 2002/09/24 03:10:02 boogums Exp $";
d2322 1
a2322 1
if( !IS_SET(ch->mhs,MHS_KAETH_CLEAN) )
@


1.275
log
@found my bug forgot the {}s
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.274 2002/09/24 02:19:43 boogums Exp $";
d2321 1
a2321 1
/*#ifdef COREY_VERSION*/
d2362 1
a2362 1
       sprintf(log_buf,"Taking %d from %s and giving them two shards.",obj,ch->name);
d2372 1
a2372 1
/*#endif*/
@


1.274
log
@ok this time it's actually commented in
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.273 2002/09/24 02:05:49 boogums Exp $";
d2360 4
d2367 1
@


1.273
log
@testing1
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.272 2002/09/22 23:28:36 boogums Exp $";
d2321 1
a2321 1
#ifdef COREY_VERSION
d2361 2
a2362 2
       obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),gch);
       obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),gch);
d2367 1
a2367 1
#endif
@


1.272
log
@ just undoing my code
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.271 2002/09/22 23:24:21 boogums Exp $";
d2361 2
@


1.271
log
@t DOH forgot to set the bit testing now
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.270 2002/09/22 23:20:21 boogums Exp $";
d2321 1
a2321 1
/*#ifdef COREY_VERSION*/
d2365 1
a2365 1
/*#endif*/
@


1.270
log
@testing yank the kaeth gear code
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.269 2002/09/20 02:42:28 boogums Exp $";
d2363 1
a2363 1
  /*SET_BIT(ch->mhs,MHS_KAETH_CLEAN);*/
@


1.269
log
@comm.c has my COREY code in it
fight.c has alagasters message changed
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.268 2002/09/15 23:35:34 boogums Exp $";
d2321 1
a2321 1
#ifdef COREY_VERSION
d2365 1
a2365 1
#endif
@


1.268
log
@ok i made my code a COREY_VERSION so it won't compile in
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.267 2002/09/15 23:24:40 boogums Exp $";
d2347 13
a2359 1
    if(obj->pIndexData->vnum == 12046)
@


1.267
log
@testing the 'yank kaeth' part in comm.c
boogums
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.266 2002/09/11 18:23:27 boogums Exp $";
d2321 1
a2321 1
#ifdef OLC_VERSION
@


1.266
log
@minor tweaks to identify
corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.265 2002/08/17 17:34:25 mud Exp $";
d2319 35
@


1.265
log
@Changes to make the game boot properly under OpenBSD
-Rusty
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.264 2002/06/20 15:55:00 rusty Exp $";
d2706 1
a2706 1
  if (race == 0 || !race_table[race].pc_race || race == race_lookup("mutant"))
d2714 7
d2738 1
a2738 1
  if (race == race_lookup("smurf"))
d2747 1
a2747 1

@


1.264
log
@Some bug fixes from off the net.
new_note() used for loading the note spools.
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.263 2002/06/14 20:15:05 mud Exp $";
d458 1
a458 2
    if( telnet )
	seteuid(MUD_UID);
@


1.263
log
@Last couple surname changes
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.262 2002/06/14 19:42:03 mud Exp $";
d1542 1
a1542 1
    if (!merc_down && d->showstr_point)
@


1.262
log
@few fixes
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.261 2002/06/14 19:33:26 rusty Exp $";
d3585 1
a3585 1
      if ( !isalpha(*pc) && !strcmp('\27',*pc) )
@


1.261
log
@Allow ' in Surname
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.260 2002/06/11 18:26:04 mud Exp $";
d3542 1
a3542 2
    int clan,count;
    DESCRIPTOR_DATA *d,*dnext;
d3585 1
a3585 1
      if ( !isalpha(*pc) && !strcmp("'",*pc) )
@


1.260
log
@Uncomment that other comment
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.259 2002/06/11 18:24:52 rusty Exp $";
d3537 73
@


1.259
log
@They MUST choose a surname.  Stop fucking with my changes!
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.258 2002/04/17 15:24:17 poquah Exp $";
d2452 2
a2453 2
/*	}
*/
@


1.258
log
@Dont force a Surname at creation, tahts annoying
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.257 2002/04/11 16:55:35 poquah Exp $";
d2421 1
a2421 2
      sprintf( buf, "New character.\n\rChoose a surname for %s: (Leave blank for none you can add it later with the surname command) %s",
    ch->name, echo_off_str );
a2440 1
/* Allow them to leave it blank
a2447 1
*/
@


1.257
log
@removing spamming storage character line
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.256 2002/04/03 15:57:22 mud Exp $";
d2421 1
a2421 1
      sprintf( buf, "New character.\n\rChoose a surname for %s: %s",
d2442 1
d2450 1
d2455 2
a2456 1
	}
@


1.256
log
@Added missing )
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.255 2002/04/03 15:56:19 rusty Exp $";
d2320 1
d2332 1
@


1.255
log
@Took out IMM dropping link from Pnet
Took out IMM login/logout if invis or incog from Pnet
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.254 2002/04/01 21:05:43 rusty Exp $";
d1268 1
a1268 1
      if(!IS_IMMORTAL(ch)
@


1.254
log
@Added pnet, wiznet like info for mortals
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.253 2002/03/23 17:34:45 rusty Exp $";
d1268 4
a1271 1
      pnet("Net death has claimed $N.",ch,NULL,PNET_LINKS,0,0);
d3496 2
d3499 1
@


1.253
log
@Let Matook be a valid char name
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.252 2002/03/12 03:01:07 rusty Exp $";
d1268 1
d1487 1
a1487 2
        wiznet(d->inlast,d->character,NULL,WIZ_SPAM,0,
      get_trust(d->character));
d1493 1
a1493 2
        wiznet(d->incomm,d->character,NULL,WIZ_SPAM,0,
      get_trust(d->character));
d3493 1
d3758 1
@


1.252
log
@Yanked starting HMV as fixed values and put back in gains
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.251 2002/03/11 06:24:38 rusty Exp $";
d3572 3
@


1.251
log
@Few stupidly missed updates
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.250 2002/03/10 22:26:14 rusty Exp $";
d2748 9
a2756 9
  ch->hit     = pc_race_table[ch->race].starting_hmv[0];
  ch->max_hit = pc_race_table[ch->race].starting_hmv[0];
  ch->pcdata->perm_hit = pc_race_table[ch->race].starting_hmv[0];
  ch->mana    = pc_race_table[ch->race].starting_hmv[1];
  ch->max_mana= pc_race_table[ch->race].starting_hmv[1];
  ch->pcdata->perm_mana= pc_race_table[ch->race].starting_hmv[1];
  ch->move    = pc_race_table[ch->race].starting_hmv[2];
  ch->max_move= pc_race_table[ch->race].starting_hmv[2];
  ch->pcdata->perm_move= pc_race_table[ch->race].starting_hmv[2];
d3059 1
a3059 1
  ch->gen_data->bonus_points = 35;
d3434 9
a3442 9
         ch->hit     = pc_race_table[ch->race].starting_hmv[0];
	 ch->max_hit = pc_race_table[ch->race].starting_hmv[0];
	 ch->pcdata->perm_hit = pc_race_table[ch->race].starting_hmv[0];
         ch->mana    = pc_race_table[ch->race].starting_hmv[1];
	 ch->max_mana= pc_race_table[ch->race].starting_hmv[1];
	 ch->pcdata->perm_mana= pc_race_table[ch->race].starting_hmv[1];
         ch->move    = pc_race_table[ch->race].starting_hmv[2];
	 ch->max_move= pc_race_table[ch->race].starting_hmv[2];
	 ch->pcdata->perm_move= pc_race_table[ch->race].starting_hmv[2];
d3784 1
a3784 1
	strcpy( d->incomm, "\n\r" );
@


1.250
log
@Fixed HP in bust_a_prompt()
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.249 2002/03/09 19:14:27 rusty Exp $";
a1718 1
	case 'h' :
a1742 1
	 case 'm' :
a1764 1
	 /*
d1769 1
a1769 1
	       sprintf( buf2, "{%s%d{x", 
d1771 1
a1771 1
		  ch->hit < ch->max_hit * 3 / 4 ? "Y" : "W", ch->hit );
d1773 1
d1780 1
d1782 1
a1782 1
	    sprintf( buf2, "{%s%d{x",
d1784 1
a1784 1
		ch->mana < ch->max_mana * 3 / 4 ? "Y" : "W", ch->mana );
d1786 1
d1790 1
d1792 1
a1792 1
	    sprintf( buf2, "{%s%d{x",
d1794 1
a1794 1
		ch->move < ch->max_move *3/4 ? "Y" : "W", ch->move );
a1795 1
	 */
a1800 1
	 case 'v' :
@


1.249
log
@Hiding information and reup_affect() additions. Initial
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.248 2002/02/28 19:24:46 rusty Exp $";
d1736 1
a1736 1
	    for( j = 0 ; j < ( ch->hit* 100 / ch->max_hit )/ 20 ; j ++ )
d1739 1
a1739 1
	    for( j = 0; j < 20 - (ch->hit*100/ch->max_hit)/ 20 ; j++ )
@


1.248
log
@Battleragers in rage can't see HP % in prompt using %b
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.247 2002/02/11 19:38:23 poquah Exp $";
d57 1
d60 1
d1208 1
a1208 1
      "Email rusty@@moosehead.com and/or poquah@@moosehead.com for more information.\n\r", 0, dnew );
d1719 1
d1736 1
a1736 1
	    for( j = 0 ; j < ( ch->hit* 100 / ch->max_hit )/ 5 ; j ++ )
d1739 1
a1739 1
	    for( j = 0; j < 20 - (ch->hit*100/ch->max_hit)/5 ; j++ )
d1744 1
d1746 1
a1746 1
            sprintf(buf2,"[MP:");
d1767 1
d1795 1
a1796 2
		sprintf( buf2, "%ld", get_carry_weight(ch)/10 );
		i = buf2; break;
d1798 22
a1819 2
		sprintf( buf2, "%d", can_carry_w(ch)/10 );
		i = buf2; break;
d1821 1
a1821 1
		sprintf( buf2, "%d.%d", ch->carry_number/10,ch->carry_number%10 );
d1829 1
d1833 1
d1873 2
a1874 2
             sprintf( buf2, "%d", ch->pcdata->sac);
             i = buf2; break;
d1991 2
d2081 7
d2418 1
a2418 1
      sprintf( buf, "New character.\n\rGive me a password for %s: %s",
d2421 1
a2421 1
      d->connected = CON_GET_NEW_PASSWORD;
d2437 16
d2749 10
d3219 1
a3219 1
  for (i = 0; i < 5; i++)
d3261 9
d3435 9
a3443 9
         ch->hit     = 20;
	 ch->max_hit = 20;
	 ch->pcdata->perm_hit = 20;
         ch->mana    = 100;
	 ch->max_mana= 100;
	 ch->pcdata->perm_mana= 100;
         ch->move    = 100;
	 ch->max_move= 100;
	 ch->pcdata->perm_move= 100;
d3785 1
a3785 1
	strcpy( d->incomm, "" );
d3888 1
a3888 1
	"Str", "Int", "Wis", "Dex", "Con" };
@


1.247
log
@few new cstat stuffs
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.246 2002/02/11 18:34:10 poquah Exp $";
d1718 4
d1739 1
@


1.246
log
@adding some smurf abilities
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.245 2002/01/26 16:25:27 rage Exp $";
d323 5
@


1.245
log
@whole mess of bug fixes
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.244 2001/12/14 21:27:12 poquah Exp $";
d3050 2
a3051 1
      if (deity_table[deity].clan && !is_clan(ch))
d3053 8
a3060 5
         write_to_buffer(d,"Don't get ahead of yourself, you arent Clanned yet.\n\r",0);
         write_to_buffer(d,
            "Please pick a Non-Clan-Deity (help deity for more information):\n\r",0);
         write_to_buffer(d,"Your choice?\n\r",0);
         break;
@


1.244
log
@remove some debugs
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.243 2001/12/14 20:09:36 poquah Exp $";
d3060 1
@


1.243
log
@debugging outfit for smurfs
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.242 2001/12/14 19:56:12 poquah Exp $";
a3222 5
    if (ch->race == race_lookup ("smurf"))
    {
       sprintf (buf,"SMURF: %s dex %d '",ch->name,ch->perm_stat[STAT_DEX]);
       log_string(buf); 
    }
a3329 2
       sprintf (buf,"SMURF: %s before welcome",ch->name);
       log_string(buf); 
a3336 2
       sprintf (buf,"SMURF: %s before reset",ch->name);
       log_string(buf); 
a3337 2
       sprintf (buf,"SMURF: %s after reset",ch->name);
       log_string(buf); 
a3367 2
       sprintf (buf,"SMURF: %s before exp_per_level",ch->name);
       log_string(buf); 
a3369 2
       sprintf (buf,"SMURF: %s after exp_per_level",ch->name);
       log_string(buf); 
a3387 2
       sprintf (buf,"SMURF: %s before newbie info",ch->name);
       log_string(buf); 
a3403 2
       sprintf (buf,"SMURF: %s boom?",ch->name);
       log_string(buf); 
@


1.242
log
@more debug
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.241 2001/12/14 19:47:26 poquah Exp $";
d3391 2
@


1.241
log
@more debugs to smurfs
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.240 2001/12/14 17:04:38 poquah Exp $";
d3383 2
d3388 2
@


1.240
log
@oops syntax error
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.239 2001/12/14 16:57:09 poquah Exp $";
d3335 2
d3344 2
d3347 2
d3379 2
d3397 2
d3415 2
@


1.239
log
@smurfs have surname smurf
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.238 2001/12/14 16:41:57 poquah Exp $";
d3225 1
a3225 1
       sprintf (buf,"SMURF: %s dex %d '",name,ch->perm_stat[STAT_DEX]);
@


1.238
log
@debugging craashes:wq
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.237 2001/12/14 16:25:51 poquah Exp $";
d2757 1
d3223 5
a3227 2
    sprintf (buf,"SMURF: %s dex %d '",name,ch->perm_stat[STAT_DEX]);
    log_string(buf); 
@


1.237
log
@can pick clanned deities if you are clanned at creation (like smurfs)
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.236 2001/12/14 16:07:48 poquah Exp $";
a436 2
    sprintf(log_buf,"Before ready on port");
    log_string(log_buf);
d3196 1
a3196 1
   /* if (improve_table[ch->perm_stat[wStat]].cost > ch->gen_data->bonus_points)*/
a3200 1
/*		improve_table[ch->perm_stat[wStat]].cost, */
a3207 1
 /*   ch->gen_data->bonus_points -= improve_table[ch->perm_stat[wStat]].cost; */
d3222 2
d3227 1
@


1.236
log
@put an if check around the last_level
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.235 2001/12/14 03:22:16 poquah Exp $";
d3051 1
a3051 1
      if (deity_table[deity].clan)
@


1.235
log
@put simpy password back
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.234 2001/12/13 20:43:44 poquah Exp $";
d3340 2
a3341 1
  ch->pcdata->last_level = 1; /* Fixes symbol bugs */
@


1.234
log
@changed password on smurfs
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.233 2001/12/13 18:01:29 poquah Exp $";
d2738 1
a2738 1
  if (!strcmp(arg,"simpyy"))
@


1.233
log
@add pcdata to rank
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.232 2001/12/13 17:30:31 poquah Exp $";
d2738 1
a2738 1
  if (!strcmp(arg,"simpy"))
@


1.232
log
@added smurf clan, smurfs clan at creation:
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.231 2001/12/13 17:08:06 poquah Exp $";
d2759 1
a2759 1
     ch->rank = 0;
@


1.231
log
@added CON_TEMP_SMURF_PASSWORD
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.230 2001/12/13 15:09:10 poquah Exp $";
d2758 2
a2759 1
     ch->clan = clan_lookup("newbie");
@


1.230
log
@removed smurf fun code
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.229 2001/12/13 02:44:27 poquah Exp $";
d2670 10
d2735 46
@


1.229
log
@backout smurf stuff
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.226 2001/12/12 20:37:31 poquah Exp $";
a2553 5
    write_to_buffer(d," * ",0);
    write_to_buffer(d,"smurf",0);
    write_to_buffer(d,"\n\r",0);
    write_to_buffer(d," ",1);

a2622 6
  /* Fun code - Poquah */
  write_to_buffer(d," * ",0);
  write_to_buffer(d,"smurf",0);
  write_to_buffer(d,"\n\r",0);
  write_to_buffer(d," ",1);

d2652 4
a2655 10
      /* Fun Code - Poquah */
      if (!strcmp(argument,"smurf"))
      {
	 write_to_buffer(d,"Blue and 3 Apples Tall? You wouldnt last long, try again.\n\r",0);
	 write_to_buffer(d,"\n\r",0);
      }
      else
      {
         write_to_buffer(d,"That is not a valid race.\n\r",0);
         write_to_buffer(d,"The following races are available:\n\r  ",0);
d2658 4
a2661 5
    if (!race_table[race].pc_race)
        break;
    write_to_buffer(d,race_table[race].name,0);
    write_to_buffer(d," ",1);
         }
d2663 1
d2666 1
a2666 1
    "What is your race? (help for more information) ",0);
@


1.228
log
@working on smurf stuff
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.227 2001/12/13 02:32:41 poquah Exp $";
d2554 5
d2628 6
d2663 10
a2672 4

      write_to_buffer(d,"That is not a valid race.\n\r",0);
      write_to_buffer(d,"The following races are available:\n\r  ",0);

d2686 1
a2686 10
 
  if (race == race_lookup("smurf"))
  {
      write_to_buffer(d,"Smurfs are a Beta Testing Race only right now. You must have the password.\n\r",0);
      write_to_buffer(d,
    "What is the password? ",0);
     d->connected = CON_TEMP_SMURF_PASSWORD;
  }
  else
  {
a2739 1
  }
a2741 54
    case CON_TEMP_SMURF_PASSWORD:
  one_argument(argument,arg);
  if(str_cmp(arg,"simpy"))
  {
      write_to_buffer(d,"That is not a valid password.\n\r",0);
      write_to_buffer(d,"The following races are available:\n\r  ",0);

      for ( race = 1; race_table[race].name != NULL; race++ )
      {
    if (!race_table[race].pc_race)
        break;
    write_to_buffer(d,race_table[race].name,0);
    write_to_buffer(d," ",1);
         }
      }
      write_to_buffer(d,"\n\r",0);
      write_to_buffer(d,
    "What is your race? (help for more information) ",0);
      d->connected = CON_GET_NEW_RACE;
      break;
  }

  race = race_lookup("smurf");
  ch->race = race;
  /* initialize stats */
  for (i = 0; i < MAX_STATS; i++)
      ch->perm_stat[i] = pc_race_table[race].stats[i];
  ch->affected_by = ch->affected_by|race_table[race].aff;
  ch->imm_flags   = ch->imm_flags|race_table[race].imm;
  ch->res_flags   = ch->res_flags|race_table[race].res;
  ch->vuln_flags  = ch->vuln_flags|race_table[race].vuln;
  ch->form        = race_table[race].form;
  ch->parts       = race_table[race].parts;

  /* add skills */
  for (i = 0; i < 5; i++)
  {
      if (pc_race_table[race].skills[i] == NULL)
    break;
      group_add(ch,pc_race_table[race].skills[i],FALSE);
  }
  /* add cost */
  ch->pcdata->points = pc_race_table[race].points;
  ch->size = pc_race_table[race].size;

  /* Stamp Time of Creation */
  ch->pcdata->created_date = current_time;

  /* Set all new characters as Newbies */
  ch->clan = clan_lookup("newbie");

  write_to_buffer( d, "What is your sex (M/F)? ", 0 );
  d->connected = CON_GET_NEW_SEX;
  break;
@


1.227
log
@added smurf race with a password on creation to limit people creating them
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.226 2001/12/12 20:37:31 poquah Exp $";
a2675 1
     break;
d2677 2
a2678 1

d2732 1
@


1.226
log
@upped storage checks to 10
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.225 2001/12/12 20:23:51 poquah Exp $";
a2553 5
    write_to_buffer(d," * ",0);
    write_to_buffer(d,"smurf",0);
    write_to_buffer(d,"\n\r",0);
    write_to_buffer(d," ",1);

a2622 6
  /* Fun code - Poquah */
  write_to_buffer(d," * ",0);
  write_to_buffer(d,"smurf",0);
  write_to_buffer(d,"\n\r",0);
  write_to_buffer(d," ",1);

d2652 4
a2655 10
      /* Fun Code - Poquah */
      if (!strcmp(argument,"smurf"))
      {
	 write_to_buffer(d,"Blue and 3 Apples Tall? You wouldnt last long, try again.\n\r",0);
	 write_to_buffer(d,"\n\r",0);
      }
      else
      {
         write_to_buffer(d,"That is not a valid race.\n\r",0);
         write_to_buffer(d,"The following races are available:\n\r  ",0);
d2669 9
d2734 54
@


1.225
log
@working on fixing no weapon problem
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.224 2001/12/12 20:14:07 poquah Exp $";
d2278 3
a2280 3
  if(ch->pcdata->logins_without_death > 5 ||
     ch->pcdata->logins_without_kill > 5 ||
     ch->pcdata->logins_without_combat > 5)
@


1.224
log
@working on fixing missing weapons
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.222 2001/12/07 19:04:19 poquah Exp $";
d2112 1
a3026 1
      weapon_found = FALSE;
a3030 1
            weapon_found = TRUE;
d3035 3
a3037 17
      if(weapon_found)
      {
         strcat(buf,"\n\rYour choice? ");
         write_to_buffer(d,buf,0);
         d->connected = CON_PICK_WEAPON;
      }
      else
      {
         strcat(buf,"\n\rYou have no weapons to choose from. Please add one. ");
         write_to_buffer(d,buf,0);
         do_help(ch,"group header");
         list_group_costs(ch);
         write_to_buffer(d,"You already have the following skills:\n\r",0);
         do_skills(ch,"");
         do_help(ch,"menu choice");
         d->connected = CON_GEN_GROUPS;
      }
d3196 14
@


1.223
log
@make sure people dont get stuck at creation with no weapon
@
text
@d2972 1
a2975 11
    }
    else
    {
      do_help(ch,"group header");
      list_group_costs(ch);
      write_to_buffer(d,"You already have the following skills:\n\r",0);
      do_skills(ch,"");
      do_help(ch,"menu choice");
      d->connected = CON_GEN_GROUPS;

    }
d3026 1
d3031 1
d3036 17
a3052 3
      strcat(buf,"\n\rYour choice? ");
      write_to_buffer(d,buf,0);
      d->connected = CON_PICK_WEAPON;
@


1.222
log
@extra */ removed
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.221 2001/12/07 19:03:29 poquah Exp $";
a2971 1
    }
d2975 11
@


1.221
log
@fix commenting out sig_crash
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.220 2001/12/07 19:00:50 poquah Exp $";
a811 1
*/
@


1.220
log
@make nonclanners immune to storage code for now
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.219 2001/12/07 17:06:47 poquah Exp $";
a805 1
/* Removed while having lots of crashes to help not lose eq
@


1.219
log
@removed saving in sig_crash while having crash problems
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.218 2001/12/05 17:07:04 poquah Exp $";
d2277 2
d2286 1
@


1.218
log
@move gladiator_data and highlander_data to pcdata
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.217 2001/12/05 16:43:46 poquah Exp $";
d806 1
d813 1
@


1.217
log
@missing pcdata for steal_data
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.216 2001/12/05 16:39:01 poquah Exp $";
d3364 1
a3364 1
	    (victm->highlander_data[ALL_KILLS] >= 6))
@


1.216
log
@new kr stats
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.215 2001/12/03 18:34:54 poquah Exp $";
d2531 1
a2531 1
    ch->steal_data[PC_SLICES] = 0;
@


1.215
log
@add some code to look for storage chars
-poq
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.214 2001/12/02 06:05:03 boogums Exp $";
d2525 6
a2530 6
    ch->killer_data[PC_ATTACKS] = 0;
    ch->killer_data[PC_DEATHS] = 0;
    ch->killer_data[PC_KILLS] = 0;
    ch->steal_data[PC_STOLEN_ITEMS] = 0;
    ch->steal_data[PC_STOLEN_GOLD] = 0;
    ch->steal_data[PC_STOLEN_SILVER] = 0;
@


1.214
log
@t trying something here
-corey
@
text
@d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.213 2001/12/01 23:16:57 poquah Exp $";
d2275 9
d2517 6
@


1.213
log
@working on death code bugs and new tracking fields
@
text
@d21 1
d37 1
a37 1
static char rcsid[] = "$Id: comm.c,v 1.212 2001/11/29 17:24:10 poquah Exp $";
@


1.212
log
@finally got cstat all debugged
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.211 2001/11/29 16:41:12 poquah Exp $";
d2506 1
@


1.211
log
@one step further on cstat
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.210 2001/11/29 15:27:52 poquah Exp $";
d318 1
a318 1
sh_int		    honor_ills;
@


1.210
log
@putting in debug to try and find why game isnt booting
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.209 2001/11/29 09:53:40 poquah Exp $";
d316 6
a321 1

@


1.209
log
@remove cstat stuff
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.208 2001/11/29 09:38:58 poquah Exp $";
a382 8
/*
    honor_kills=0;
    posse_kills=0;
    warlock_kills=0;
    demise_kills=0;
    avarice_kills=0;
    zealot_kills=0;
*/
d431 2
@


1.208
log
@working on cstat
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.207 2001/11/29 09:30:52 poquah Exp $";
d383 1
a383 1

d390 1
@


1.207
log
@change cstat a bit
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.206 2001/11/25 04:39:20 poquah Exp $";
a315 6
sh_int      honor_kills;
sh_int      posse_kills;
sh_int      warlock_kills;
sh_int      demise_kills;
sh_int      avarice_kills;
sh_int      zealot_kills;
@


1.206
log
@new 2X exp things
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.204 2001/11/25 01:33:20 mud Exp $";
d316 6
d389 7
@


1.205
log
@Zap bug with disconnecting a socket with no d->character
@
text
@d1918 1
a1918 2
  /* strncpy( outbuf, d->outbuf, d->outtop ); */
  strncpy( outbuf, d->outbuf, d->outtop, length );
@


1.204
log
@Var declarations in comm.c and OOC FALSE for can_see() in fight.c
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.203 2001/11/25 01:27:47 mud Exp $";
d1918 2
a1919 1
  strncpy( outbuf, d->outbuf, d->outtop );
@


1.203
log
@var declaration
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.202 2001/11/25 01:26:38 rusty Exp $";
d3369 2
a3370 1
    int clan;
d3384 1
a3384 1
        int count=0;
d3909 1
a3909 1
    const char *i;
@


1.202
log
@Webpage crash/bug fixes applied
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.201 2001/11/23 16:23:12 poquah Exp $";
d3383 1
a3383 1
        count=0;
@


1.201
log
@declar clan_lookup in comm.c
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.200 2001/11/23 16:17:15 poquah Exp $";
d2244 8
d3378 25
d3545 7
d3973 2
a3974 2
    case 't': i = (char *) arg1;                            break;
    case 'T': i = (char *) arg2;                            break;
d3976 1
a3976 2
    case 'n': 

d3986 1
d3989 1
a3989 1
    case 'N':
d3999 1
d4001 6
a4006 6
    case 'e': i = he_she  [URANGE(0, ch  ->sex, 2)];        break;
    case 'E': i = he_she  [URANGE(0, vch ->sex, 2)];        break;
    case 'm': i = him_her [URANGE(0, ch  ->sex, 2)];        break;
    case 'M': i = him_her [URANGE(0, vch ->sex, 2)];        break;
    case 's': i = his_her [URANGE(0, ch  ->sex, 2)];        break;
    case 'S': i = his_her [URANGE(0, vch ->sex, 2)];        break;
d4008 1
a4008 1
    case 'r': i = (char *) arg2;			    break;
d4011 1
a4011 1
        i = can_see_obj( to, obj1 )
d4017 1
a4017 1
        i = can_see_obj( to, obj2 )
@


1.200
log
@Newbie flag and code
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.199 2001/10/12 17:37:25 rage Exp $";
d78 2
a79 1

@


1.199
log
@bug fix for symbol/aid put back in
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.197 2001/08/18 16:41:25 guerrand Exp $";
d2681 3
@


1.198
log
@removed G's last change
@
text
@d3246 1
@


1.197
log
@Bug fix for lowbie +hp/mana/move spells.
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.196 2001/07/04 01:46:30 guerrand Exp $";
a3245 1
  ch->pcdata->last_level = 1; /* Fixes symbol bugs */
@


1.196
log
@Added some messages and a special prompt for wraith form
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.195 2001/07/04 01:36:40 guerrand Exp $";
d3246 1
@


1.195
log
@Scrapped wraith fix 1.0 and tried again.
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.194 2001/07/04 01:25:52 guerrand Exp $";
d956 3
d1662 6
@


1.194
log
@And the bug fixing begins.
Fixed an error with pcdata crashing
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.193 2001/07/04 01:21:56 guerrand Exp $";
d952 1
a952 1
    if ( d->character != NULL && d->character->pcdata != NULL )
d954 3
a956 26
	short *timer;
	DO_FUN **fun; /* pointer to pointer is necessary for NULL assignment below */

	timer = NULL;
	fun = NULL;
        *fun = (d->character->pcdata->action_function);

	/* update timers */
	if ( *fun == action_wraithform )
	    timer = &(d->character->pcdata->pulse_union.wraith.wraith_timer); 
	else
	if ( *fun == action_ambush )
	    timer = &(d->character->pcdata->pulse_union.ambush.ambush_timer); 

	/* Got the timer.  decrement it, if it's 0 or less, call action function */
	/* Then clear action function so it won't get called again, set timer to 0 */
	if ( timer != NULL && --(*timer) <= 0 )
	{
		/* Call finishing function */
	    (*(*fun))(d->character,"");
	    *timer = 0;
	    *fun = NULL;
	}
	/* We've called it, we've handled it, we've reset everything.  Should be done */
     }	

@


1.193
log
@Extensive changes to wraithform to have it proc after the timer expires.
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.192 2001/06/10 05:19:39 guerrand Exp $";
d952 1
a952 1
    if ( d->character != NULL && !IS_NPC(d->character) )
@


1.192
log
@Added notitle feature for who list.
GMAN
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.191 2001/06/01 02:46:14 guerrand Exp $";
d70 2
d930 1
d951 30
d1040 1
@


1.191
log
@Added %t == time of day for remorts and gargoyles.
GMAN
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.190 2001/05/24 14:45:25 poquah Exp $";
d3342 1
a3342 1
        "all auto immortal self someone something the you outcast loner") )
@


1.190
log
@change spam to log the spam command to log file as well as wiznet
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.189 2001/05/24 01:34:57 poquah Exp $";
d1765 3
a1767 1

@


1.189
log
@Remove my capital code dont want it in right now
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.187 2001/05/14 19:57:47 rusty Exp $";
d1457 1
d1460 3
d1464 1
d1467 3
@


1.188
log
@change looting for nonclanners
-poq
@
text
@a3373 3

  name[0] = LOWER(name[0]); /* Poq's no caps code */

d3381 4
a3384 7
         /* Poquah's not wanting any caps Code */
         return FALSE;
         
         if (adjcaps)
            cleancaps = TRUE;
         total_caps++;
         adjcaps = TRUE;
d3387 1
a3387 1
         adjcaps = FALSE;
d3390 1
a3390 1
         fIll = FALSE;
a3396 1

@


1.187
log
@BInding port 23
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.186 2001/05/14 16:16:52 mud Exp $";
d3374 3
d3384 7
a3390 4
    if (adjcaps)
        cleancaps = TRUE;
    total_caps++;
    adjcaps = TRUE;
d3393 1
a3393 1
    adjcaps = FALSE;
d3396 1
a3396 1
    fIll = FALSE;
d3403 1
@


1.186
log
@Type difference fixed
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.185 2001/05/14 16:14:27 rusty Exp $";
d312 1
a312 1

d391 3
d435 1
d437 7
a443 1
    control[1] = init_socket( 4040 );
d468 2
a469 1
    close (control[1]);
d870 2
d875 1
d902 2
d906 1
@


1.185
log
@Trying for multiple ports bound
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.184 2001/04/09 19:16:33 mud Exp $";
d805 1
a805 1
void game_loop_unix( int control )
d843 1
a843 1
  int maxdesc;
@


1.184
log
@took out b0rked ROM thing
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.183 2001/04/09 18:32:15 mud Exp $";
d329 1
a329 1
void    game_loop_unix          args( ( int control ) );
d364 1
a364 1
    int control;
d432 2
a433 2
    control = init_socket( port );
    sprintf( log_buf, "Debug 1 %d.", port );
d457 2
a458 1
    close (control);
d856 6
a861 2
  FD_SET( control, &in_set );
  maxdesc = control;
d886 4
a889 2
  if ( FD_ISSET( control, &in_set ) )
      init_descriptor( control );
@


1.183
log
@added tables.h include
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.182 2001/04/09 18:30:39 mud Exp $";
d1872 1
a1872 1
    strncpy( d->outbuf + d->outtop, txt, length );
@


1.182
log
@Applied rom 2.4 b5 and b6 patches as necessary.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.181 2001/03/25 15:20:26 mud Exp $";
d63 1
@


1.181
log
@Cranked alarm() on DNS up to 30 seconds
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.180 2001/03/21 20:00:35 mud Exp $";
d1871 1
a1871 1
    strcpy( d->outbuf + d->outtop, txt );
d3301 2
d3307 2
a3308 2
  "all auto immortal self someone something the you demise outcast warlock loner honor posse zealot matook") )
  return FALSE;
d3310 8
d3319 2
a3320 2
    || !str_suffix("rusty",name)))
  return FALSE;
d3680 2
a3681 2
    if ( (txt == NULL) || (ch->desc == NULL) ) return;

@


1.180
log
@color change from {Y to {C for AFK prompt change
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.179 2001/03/21 19:57:07 mud Exp $";
d1127 1
a1127 1
  alarm(20);
@


1.179
log
@Edited out the old bust_a_prompt() to eliminate confusion.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.178 2001/03/21 19:55:13 mud Exp $";
d1607 1
a1607 1
	sprintf( buf, "{x<{YAFK{x - %d> ", ch->pcdata->afk_counter);
d1611 1
a1611 1
	strcpy( buf, "{x<{YAFK{x> ");
@


1.178
log
@Ok put the dumb thing into the NEW bust_a_prompt()
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.177 2001/03/21 19:49:03 mud Exp $";
d1578 1
a1578 179
/*
 * Bust a prompt (player settable prompt)
 * coded by Morgenes for Aldara Mud
 *
 * Updated 

void bust_a_prompt( CHAR_DATA *ch )
{
    char buf[MAX_STRING_LENGTH];
    char buf2[MAX_STRING_LENGTH];
    const char *str;
    const char *i;
    char *point;
    char doors[MAX_INPUT_LENGTH];
    EXIT_DATA *pexit;
    bool found;
    const char *dir_name[] = {"N","E","S","W","U","D"};
    int door;
 
    point = buf;
    str = ch->prompt;
    if (str == NULL || str[0] == '\0')
    {
  sprintf( buf, "{x<%dhp %dm %dmv> ", ch->hit,ch->mana,ch->move);
  send_to_char(buf,ch);
  return;
    }

   if (IS_SET(ch->comm,COMM_AFK))
   {
     if(!IS_NPC(ch))
     {
	sprintf( buf, "{x<{YAFK{x - %d> ", ch->pcdata->afk_counter);
     }
     else
     {
	strcpy( buf, "{x<{YAFK{x> ");
     }
     send_to_char(buf,ch);
     return;
   }

   while( *str != '\0' )
   {
      if( *str != '%' )
      {
   *point++ = *str++;
   continue;
      }
      ++str;
      switch( *str )
      {
   default :
      i = " "; break;
  case 'e':
      found = FALSE;
      doors[0] = '\0';
      for (door = 0; door < 6; door++)
      {
    if ( 
       ((pexit = ch->in_room->exit[door]) != NULL)
    && (pexit ->u1.to_room != NULL)
    && ((can_see_room(ch,pexit->u1.to_room)) || (IS_AFFECTED(ch,AFF_INFRARED)))
    &&   (!IS_AFFECTED(ch,AFF_BLIND))
    &&  (!IS_SET(pexit->exit_info,EX_CLOSED))
    &&  (!IS_SET(pexit->exit_info,EX_CONCEALED))
    &&  (!IS_SET(pexit->exit_info,EX_SECRET))
       )
    {
        found = TRUE;
        strcat(doors,dir_name[door]);
    }
      }
      if (!found)
    strcat(buf,"none");
      sprintf(buf2,"%s",doors);
      i = buf2; break;
   case 'b' :
      sprintf(buf2,"[");
      for( i = 0 ; i < ( ch->hit* 100 / ch->max_hit )/ 5 ; i ++ )
	strcat(buf2,"*");
      for( i = 0; i < 20 - (ch->hit*100/ch->max_hit)/5 ; i++ )
	strcat(buf2,"-");
      strcat(buf2,"]");
      i = buf2; break;
   case 'c' :
      sprintf(buf2,"%s","\n\r");
      i = buf2; break;
   case 'h' :
      if ( is_affected(ch,gsn_rage) )
      sprintf( buf2, "???" );
      else
      sprintf( buf2, "%d", ch->hit );
      i = buf2; break;
   case 'H' :
      if ( is_affected(ch,gsn_rage) )
      sprintf( buf2, "???" );
      else
      sprintf( buf2, "%d", ch->max_hit );
      i = buf2; break;
   case 'm' :
      sprintf( buf2, "%d", ch->mana );
      i = buf2; break;
   case 'M' :
      sprintf( buf2, "%d", ch->max_mana );
      i = buf2; break;
   case 'v' :
      sprintf( buf2, "%d", ch->move );
      i = buf2; break;
   case 'V' :
      sprintf( buf2, "%d", ch->max_move );
      i = buf2; break;
   case 'w' :
      sprintf( buf2, "%ld", get_carry_weight(ch)/10 );
      i = buf2; break;
   case 'W' :
      sprintf( buf2, "%d", can_carry_w(ch)/10 );
      i = buf2; break;
   case 'n' :
      sprintf( buf2, "%d.%d", ch->carry_number/10,ch->carry_number%10 );
      i = buf2; break;
   case 'N' :
      sprintf( buf2, "%d", can_carry_n(ch) / 10 );
      i = buf2; break;
   case 'x' :
      sprintf( buf2, "%d", ch->exp );
      i = buf2; break;
   case 'X' :
      sprintf(buf2, "%d", 
      (ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp);
      i = buf2; break;
   case 'g' :
      sprintf( buf2, "%ld", ch->gold);
      i = buf2; break;
   case 's' :
      sprintf( buf2, "%ld", ch->silver);
      i = buf2; break;
   case 'S' :
      sprintf( buf2, "%d", ch->pcdata->sac);
      i = buf2; break;
   case 'a' :
         sprintf( buf2, "%d", ch->alignment );
      i = buf2; break;
   case 'r' :
      if( ch->in_room != NULL )
         sprintf( buf2, "%s", 
    ((!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT)) ||
     (!IS_AFFECTED(ch,AFF_BLIND) && !room_is_dark( ch->in_room )))
    ? ch->in_room->name : "darkness");
      else
         sprintf( buf2, " " );
      i = buf2; break;
   case 'R' :
      if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
         sprintf( buf2, "%d", ch->in_room->vnum );
      else
         sprintf( buf2, " " );
      i = buf2; break;
   case 'z' :
      if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
         sprintf( buf2, "%s", ch->in_room->area->name );
      else
         sprintf( buf2, " " );
      i = buf2; break;
   case '%' :
      sprintf( buf2, "%%" );
      i = buf2; break;
      }
      ++str;
      while( (*point = *i) != '\0' )
   ++point, ++i;
   }
   if (ch->desc)
     write_to_buffer( ch->desc, buf, point - buf );
   return;
}
*/

/* NEW Prompt command */
@


1.177
log
@Added ch->pcdata->afk_counter into prompt
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.176 2001/03/06 21:52:48 mud Exp $";
d1783 10
a1792 2
	send_to_char("{x<AFK> ",ch);
	return;
@


1.176
log
@PLR_NOOUTOFRANGE set at creation
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.175 2001/02/20 18:37:49 mud Exp $";
d1608 10
a1617 2
  send_to_char("{x<AFK> ",ch);
  return;
@


1.175
log
@More CPU priority for game version, not NICED anymore
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.174 2000/10/16 23:09:31 mud Exp $";
d3007 1
@


1.174
log
@last attack by timer
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.173 2000/09/10 17:55:44 mud Exp $";
d443 1
a443 1
    /* renice to 4 because we run on a shared machine */
d445 1
@


1.173
log
@Changed allowed names list, let people hit shapemorphs be their real
names.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.172 2000/08/28 18:09:22 mud Exp $";
d2595 1
@


1.172
log
@ bug fix in picking new diety at creation
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.171 2000/07/25 18:58:29 mud Exp $";
d3464 1
a3464 1
  "all auto immortal self someone something the you demise balance circle loner honor") )
@


1.171
log
@remove debug code
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.170 2000/07/25 18:46:01 mud Exp $";
d3080 1
a3080 2
         strcat(buf,"\n\rYour choice? ");
         write_to_buffer(d,buf,0);
@


1.170
log
@debug
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.169 2000/07/25 18:38:57 mud Exp $";
d4028 1
a4028 3
        sprintf(buf,"blind = %d\n\r",gladiator_info.blind);
	send_to_char(buf,to);
        if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind )
d4040 1
a4040 1
    if(IS_SET(vch->mhs,MHS_GLADIATOR) && gladiator_info.blind )
@


1.169
log
@working through glad bug
--poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.168 2000/07/25 18:26:06 mud Exp $";
d4028 1
a4028 1
        sprintf(buf,"blind = %d\n\r");
@


1.168
log
@commenting out what I think is caushing the glad viewing bug
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.167 2000/07/18 16:41:22 mud Exp $";
d4027 4
a4030 2
    /*
    if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind )
a4036 1
	*/
d4038 1
a4038 2
/*	}
*/
a4041 1
    /*
a4048 1
	*/
a4049 1
	  /*
a4050 1
	*/
@


1.167
log
@Gladiator blindness in act_new()
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.166 2000/07/17 22:18:54 mud Exp $";
d4027 1
d4035 1
d4037 2
a4038 1
	}
d4042 1
d4050 1
d4052 1
d4054 1
@


1.166
log
@Convert act_new() $n and $N to $l $L
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.165 2000/07/17 21:43:58 mud Exp $";
d4025 24
a4048 2
    case 'n': i = PERS( ch,  to, ooc );			 break;
    case 'N': i = PERS( vch, to, ooc );			 break;
a4080 7

    case 'l': 
        i = ch->long_descr;
	break;
    case 'L': 
        i = vch->long_descr;
	break;
@


1.165
log
@Changes to add debugging to Gladiator messages for finding
blind problems.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.164 2000/07/13 19:20:52 mud Exp $";
d1518 1
a1518 1
      if(IS_SET(victim->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE)
d4025 2
a4026 12
    case 'n': 
	if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE)
	{ i = ch->long_descr; }
	else
	{ i = PERS( ch,  to, ooc ); }
	break;
    case 'N': 
	if(IS_SET(vch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE)
	{ i = vch->long_descr; }
	else
	{ i = PERS( vch, to, ooc ); }
	break;
@


1.164
log
@fix gladiator blind on battle prompt
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.163 2000/07/13 01:27:30 mud Exp $";
d1519 1
d1522 1
d1524 1
d1527 1
d4027 1
a4027 1
           i = ch->long_descr;
d4029 1
a4029 1
	   i = PERS( ch,  to, ooc );
d4033 1
a4033 1
           i = vch->long_descr;
d4035 1
a4035 1
	   i = PERS( vch, to, ooc );
@


1.163
log
@declare gladiator
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.162 2000/07/13 01:25:20 mud Exp $";
d1518 6
a1523 2
      sprintf(buf,"%s %s \n\r", 
        IS_NPC(victim) ? victim->short_descr : victim->name,wound);
@


1.162
log
@working on blind glads
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.161 2000/07/12 23:56:24 mud Exp $";
d62 1
@


1.161
log
@more on blind glads and shpemorphed
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.160 2000/07/12 23:23:09 mud Exp $";
d4016 12
a4027 2
    case 'n': i = PERS( ch,  to, ooc );                   break;
    case 'N': i = PERS( vch, to, ooc );                   break;
d4061 1
a4061 1
    case 'l':
d4064 1
a4064 2

    case 'L':
d4067 1
@


1.160
log
@added a new act 'l' to handle shapemorphed/glads descriptions in stead of names
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.159 2000/06/23 22:30:44 mud Exp $";
d4053 4
@


1.159
log
@typo = to == fix
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.158 2000/06/23 22:14:27 mud Exp $";
d4050 4
@


1.158
log
@Added one extra char to make sure the d->character was in the
char_list at reconnect.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.157 2000/06/21 18:31:27 mud Exp $";
d3601 5
a3605 2
      if( ch = d->character )
	{ found = TRUE; break;}
@


1.157
log
@Commented out signal() calls.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.156 2000/06/21 18:30:22 mud Exp $";
d3576 1
d3599 13
d3624 1
@


1.156
log
@Commented back out the sig_crash() crap that keeps us from rebooting
automatically.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.155 2000/06/19 22:38:15 mud Exp $";
a807 1
    */
d816 1
@


1.155
log
@dont put in the first signal
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.154 2000/06/19 22:37:04 mud Exp $";
a766 1
   */
d790 1
@


1.154
log
@putting back in sig_crash, I think
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.153 2000/05/20 00:06:49 mud Exp $";
d807 2
a808 1
    signal ( SIGCLD, SIG_IGN );
@


1.153
log
@try increasing buf to 2* in void act_new
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.152 2000/04/24 12:43:14 mud Exp $";
d766 2
a789 1
   */
d807 1
a807 1
    /*signal ( SIGCLD, SIG_IGN );
d816 1
@


1.152
log
@Completely took out crash signals
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.151 2000/04/22 14:18:01 mud Exp $";
d3921 1
a3921 1
    char buf[MAX_STRING_LENGTH];
@


1.151
log
@Took the autosave at crash out and cut the
time between autosaves in half.  Should prevent
us from going into some of the CPU loops we
do.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.150 2000/04/18 20:33:48 mud Exp $";
d762 4
a768 1
  /*extern void save_corpses ( );*/
a778 3
  /* for a while we're not going to save characters on a crash
   * This should avoid the CPU looping problems.
   *
a784 3
   */
  
/*  save_corpses (); */
d788 1
d806 1
a806 1
    /*signal ( SIGCLD, SIG_IGN );*/
d815 1
@


1.150
log
@fixed act ( entries
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.149 2000/04/18 19:50:55 mud Exp $";
d775 4
a778 1
                                  
d785 1
@


1.149
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.148 2000/04/17 22:00:47 mud Exp $";
d3904 1
a3904 1
void act (const char *format, CHAR_DATA *ch, const void *arg1, const void *arg2,
@


1.148
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.147 2000/03/23 14:11:31 mud Exp $";
d1205 1
a1205 1
      act( "$n has lost $s link.", ch, NULL, NULL, TO_ROOM );
d3397 1
a3397 1
  act( "$n has entered the game.", ch, NULL, NULL, TO_ROOM );
d3427 1
a3427 1
      act("$n has entered the game.",ch->pet,NULL,NULL,TO_ROOM);
d3594 1
a3594 1
    act( "$n has reconnected.", ch, NULL, NULL, TO_ROOM );
d3676 1
a3676 1
    act( "$n has returned from the void.", ch, NULL, NULL, TO_ROOM );
d3905 1
a3905 1
    int type)
d3908 1
a3908 1
    act_new(format,ch,arg1,arg2,type,POS_RESTING);
d3912 1
a3912 1
        const void *arg2, int type, int min_pos)
d3992 2
a3993 2
    case 'n': i = PERS( ch,  to, FALSE );                   break;
    case 'N': i = PERS( vch, to, FALSE );                   break;
@


1.147
log
@ Newbies will now start with 80% in their primary weapon, so they can start
 gaining skill points right away.

 Also, added in room number in summon log line

 -Rage.
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.146 2000/03/20 23:10:54 mud Exp $";
d1483 1
a1483 1
  if ((victim = ch->fighting) != NULL && can_see(ch,victim))
d3992 2
a3993 2
    case 'n': i = PERS( ch,  to  );                         break;
    case 'N': i = PERS( vch, to  );                         break;
@


1.146
log
@move the stolen data into a steal_data with long int
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.145 2000/03/18 22:43:38 mud Exp $";
d3150 1
a3150 1
  ch->pcdata->learned[*weapon_table[weapon].gsn] = 40;
@


1.145
log
@remove debug lines, bug squashed
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.144 2000/03/18 22:22:12 mud Exp $";
d2585 4
a2588 4
    ch->killer_data[PC_STOLEN_ITEMS] = 0;
    ch->killer_data[PC_STOLEN_GOLD] = 0;
    ch->killer_data[PC_STOLEN_SILVER] = 0;
    ch->killer_data[PC_SLICES] = 0;
@


1.144
log
@debugging the hell out of it
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.143 2000/03/18 22:04:17 mud Exp $";
a3334 2
                sprintf( buf, "%s before reset",ch->name) ;
                log_string( buf );
a3335 1
    send_to_char("Did you get here? (after reset)\n\r",ch);
@


1.143
log
@debugging crash bug
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.142 2000/03/18 20:08:10 mud Exp $";
d3335 2
@


1.142
log
@da bug da bug
-poquaH
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.141 2000/03/18 20:01:02 mud Exp $";
a3320 3
  write_to_buffer( d, 
    "\n\rThings are about to get interesting.\n\r",
      0 );
a3334 4
  write_to_buffer( d, 
    "\n\rYou may be about to crash the game.\n\r",
      0 );
    send_to_char("Did you get here? (before reset)\n\r",ch);
@


1.141
log
@debug debug
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.140 2000/03/18 19:53:55 mud Exp $";
d3321 3
@


1.140
log
@debugging crash bug
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.139 2000/03/12 00:32:42 mud Exp $";
d3335 3
@


1.139
log
@new thieving data
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.138 2000/03/08 14:50:28 mud Exp $";
d3335 1
d3337 1
@


1.138
log
@add email addy to ban comment
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.137 2000/03/06 16:50:18 mud Exp $";
d2585 4
d2590 1
@


1.137
log
@apply types and change affects to use them for scondary etc
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.136 2000/03/06 15:59:19 mud Exp $";
d1146 2
@


1.136
log
@adjust affects
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.135 2000/02/29 20:55:42 mud Exp $";
d2540 1
a2540 1
        affect_remove( ch, ch->affected,TRUE );
@


1.135
log
@set last_kill to "no one" with pfresh
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.134 2000/02/25 02:20:59 mud Exp $";
d2540 1
a2540 1
        affect_remove( ch, ch->affected );
@


1.134
log
@remove mutant tag
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.133 2000/02/25 01:54:19 mud Exp $";
d2583 1
@


1.133
log
@remove all immloads properly
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.132 2000/02/25 01:20:57 mud Exp $";
d2535 2
@


1.132
log
@fix and put racial abilities fix back in
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.131 2000/02/25 00:59:51 mud Exp $";
d2553 1
d2557 1
a2557 1
       if (IS_SET(obj->extra_flags,ITEM_IMM_LOAD))
d2559 1
a2559 1
          if(obj->item_type == ITEM_CONTAINER)
d2561 2
a2562 5
             for ( obj2 = obj->contains; obj2 != NULL; obj2 = obj_next2 )
             {
                obj_next2 = obj2->next_content;
                get_obj( ch, obj2, obj );
             }
d2564 7
a2571 1
       }
@


1.131
log
@remove racaial ability fix in comm.c
remove debug lines in save.c
-poquah
----------------------------------------------------------------------
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.130 2000/02/24 19:09:23 mud Exp $";
a3139 1
  /*
d3142 1
a3142 1
      if (pc_race_table[race].skills[i] == NULL)
d3144 1
a3144 1
      group_add(ch,pc_race_table[race].skills[i],FALSE);
a3145 1
  */
@


1.130
log
@re-add racial skills at weapon pick in case the get dropped during
customization.
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.129 2000/02/23 05:32:03 mud Exp $";
d3140 1
d3147 1
@


1.129
log
@disable picking mutants as a race
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.128 2000/02/15 23:42:32 mud Exp $";
d3138 8
@


1.128
log
@debugging pfresh chars problem
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.127 2000/02/15 23:24:42 mud Exp $";
d2695 1
a2695 1
  if (race == 0 || !race_table[race].pc_race)
d2697 5
@


1.127
log
@clear specialize and species enemy with pfresh
alos try to figure out why some chars not getting pfresh set
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.126 2000/02/15 22:19:59 mud Exp $";
a2493 1
     {
d2495 1
a2495 2
        ch->trumps = 0;
     }
@


1.126
log
@pcdata is for perm_hit etc
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.125 2000/02/15 22:17:21 mud Exp $";
d2523 3
@


1.125
log
@set the logout tracker during pfresh
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.124 2000/02/15 22:06:24 mud Exp $";
d3320 1
a3320 1
	 ch->perm_hit = 20;
d3323 1
a3323 1
	 ch->perm_mana= 100;
d3326 1
a3326 1
	 ch->perm_move= 100;
@


1.124
log
@reset perm hp, mana, move with pfresh
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.123 2000/02/15 19:02:18 mud Exp $";
d2479 3
@


1.123
log
@Change Pfresh login, add CON_PREFRESH_CHAR
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.122 2000/02/12 14:33:03 mud Exp $";
d3317 1
d3320 1
d3323 1
@


1.122
log
@comm.c    fix an xp calculation bug for prefresh

lookup.c   made deity_lookup return -1 if error instead of 0 since
           0 represents Mojo
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.121 2000/02/11 20:20:40 mud Exp $";
d2351 1
a2351 125
	 /* Move all skills to old skills and reset skills */
         for ( i = 0; i < MAX_SKILL; i++ )
         {
	    ch->pcdata->old_learned[i] = ch->pcdata->learned[i];
	    ch->pcdata->learned[i] = 0;
         }

         /* Clear Groups Known so they can pick them again */
         for (i = 0; i < MAX_GROUP; i++)
         {
	    if (group_table[i].name == NULL)
	       break;
	    ch->pcdata->group_known[i] = 0;
         }

	 /* Reset Skill Points */
	 ch->skill_points = 0;
	 ch->pcdata->skill_point_timer = 0;
	 ch->pcdata->skill_point_tracker = 0;

	 /* Remove Killer,Thief and Trumps */
	 if (IS_SET(ch->act,PLR_KILLER))
	    REMOVE_BIT(ch->act,PLR_KILLER); 
	 if (IS_SET(ch->act,PLR_THIEF))
	    REMOVE_BIT(ch->act,PLR_THIEF);
	 if (IS_SET(ch->wiznet,PLR_RUFFIAN))
	 {
	    REMOVE_BIT(ch->wiznet,PLR_RUFFIAN);
	    ch->trumps = 0;
	 }

	 /* Reset Fight, Outcast and Ruffian Timers */
	 ch->timer = 0;
	 ch->pcdata->outcT = 0;
	 ch->pcdata->ruffT = 0;

         /* Reset Clan and Rank */
	 if (is_clan(ch))
	 {
	    ch->clan = 0;
	    ch->pcdata->rank = 0;
	 }
         /* calculate gained xp for refresh purposes */
         if( IS_SET(ch->act, PLR_VAMP) || 
	     IS_SET(ch->act, PLR_WERE ) ||
	     IS_SET(ch->act, PLR_MUMMY ) )
	 {
	    ch->exp += 26 * exp_per_level(ch,ch->pcdata->points);
	 }

          /* set pcdata points to zero */
	  ch->pcdata->points = 0;

         /* Remove Kit */
	 ch->kit = 0;

	 /* Remove Nodes if Any */
	 if (ch->pcdata->node != 0)
	   ch->pcdata->node = 0;

         /* Remove Shapeshifted or Shapemorphed just in case */
	 if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
	    REMOVE_BIT(ch->mhs,MHS_SHAPESHIFTED);
	 if (IS_SET(ch->mhs,MHS_SHAPEMORPHED))
	    REMOVE_BIT(ch->mhs,MHS_SHAPEMORPHED);

	 /* Remove Affects and Resists/Vulns/Imms */
         while ( ch->affected )
	    affect_remove( ch, ch->affected );
         ch->affected_by = 0;

         if (ch->imm_flags)
            ch->imm_flags = 0; 
         if (ch->res_flags)
            ch->res_flags = 0;
         if (ch->vuln_flags)
            ch->vuln_flags = 0;

         /* Remove all EQ Worn just for good measure */
	 remove_all_objs(ch);

         /* Remove all ITEM_IMM_LOAD and empty out the container
	    if its a container */
         for ( obj = ch->carrying; obj != NULL; obj = obj_next )
         {
            obj_next = obj->next_content;
            if (IS_SET(obj->extra_flags,ITEM_IMM_LOAD))
            {
	       if(obj->item_type == ITEM_CONTAINER)
	       {
                  for ( obj2 = obj->contains; obj2 != NULL; obj2 = obj_next2 )
                  {
                     obj_next2 = obj2->next_content;
                     get_obj( ch, obj2, obj );
                  }
	       }
               extract_obj(obj);
            }
         }

	 /* Clear Last Attacked By */
	 ch->pcdata->last_attacked_by = str_dup("no one");

         /* Reset Report Stats */
	 ch->killer_data[PC_ATTACKS] = 0;
	 ch->killer_data[PC_DEATHS] = 0;
	 ch->killer_data[PC_KILLS] = 0;

	 /* Clear Trains and Pracs */
	 ch->train = 0;
	 ch->practice = 0;

         write_to_buffer(d,"The following races are available:\n\r  ",0);
         for ( race = 1; race_table[race].name != NULL; race++ )
         {
            if (!race_table[race].pc_race)
               break;
            write_to_buffer(d," * ",0);
            write_to_buffer(d,race_table[race].name,0);
            write_to_buffer(d,"\n\r",0);
            write_to_buffer(d," ",1);
         }

         write_to_buffer(d," * ",0);
         write_to_buffer(d,"smurf",0);
d2353 2
a2354 5
         write_to_buffer(d," ",1);

         write_to_buffer(d,"\n\r",0);
         write_to_buffer(d,"What is your race (help for more information)? ",0);
         d->connected = CON_GET_NEW_RACE;
d2453 154
d3340 3
d3344 2
@


1.121
log
@change ITEM_DARK to ITEM_IMM_LOAD and add removal of imm loads from pfreshed char
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.120 2000/02/11 00:35:26 mud Exp $";
d2183 1
a2183 1
    int iClass,deity,race,i,weapon,iOldClass, oldLevel;
d2398 1
a2398 1
	    ch->exp += 25 * exp_per_level(ch,ch->pcdata->points);
a2403 5
	 /* Reset Level back to 0 for Creation Process */
	 /* not right now, after i calculate how many debit levels 
	    to give out */
	 /* ch->level = 0; */

d3001 1
a3001 1
      if ( deity == 0)                  
d3061 4
a3064 2
	oldLevel = ch->exp / exp_per_level(ch,ch->pcdata->points);
	if( ( ch->level < 11 ) && (oldLevel > ch->level ) )
d3066 1
a3066 1
	  oldLevel = ch->level ;
d3073 1
a3073 1
	  if ( oldLevel > 76 )
d3075 1
a3075 1
	    oldLevel = 76;
d3077 1
a3077 1
	  ch->pcdata->debit_level = oldLevel;
d3082 1
a3082 1
	 if(oldLevel > 50 )
d3084 1
a3084 1
	   oldLevel =50;
d3086 1
a3086 1
	 ch->pcdata->debit_level = oldLevel;
d3201 5
a3205 3
	 oldLevel = ch->exp / exp_per_level(ch,ch->pcdata->points);
	 if( ( ch->level < 11 ) && (oldLevel > ch->level ) )
	   oldLevel = ch->level ;
d3211 2
a3212 2
	    if ( oldLevel > 76 )
	       oldLevel = 76;
d3216 2
a3217 2
            if(oldLevel > 50 )
	       oldLevel =50;
d3219 1
a3219 1
         sprintf(buf,"Debit levels: %d\n\r",oldLevel);
@


1.120
log
@clear groups known on pfresh so you can pick during creation
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.119 2000/02/11 00:12:09 mud Exp $";
d2188 4
d2415 1
a2415 9
/* do later */
	 /* Remove Remort Status */
/*	 if (IS_SET(ch->act,PLR_VAMP))
	    REMOVE_BIT(ch->act,PLR_VAMP);
	 if (IS_SET(ch->act,PLR_WERE))
	    REMOVE_BIT(ch->act,PLR_WERE);
	 if (IS_SET(ch->act,PLR_MUMMY))
	    REMOVE_BIT(ch->act,PLR_MUMMY);
*/
d2436 19
@


1.119
log
@allow help on select class
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.118 2000/02/10 23:28:50 mud Exp $";
d2352 8
@


1.118
log
@attempt to fix the garabge on deity pick?
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.117 2000/02/10 21:17:11 mud Exp $";
d2706 1
a2706 1
     strcpy( buf, "Select a class [" );
d2739 1
a2739 1
  strcpy( buf, "Select a class [" );
d2758 21
@


1.117
log
@allow pfreshers to log into olc without being frozen
put rages code in to we can see if it really is toasty
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.116 2000/02/10 19:11:48 mud Exp $";
d2955 2
a2956 2
            "Please pick a Deity (help deity for more information):\n\r",0);
         write_to_buffer(d,"Your choice?",0);
d2966 2
a2967 3
            "Please pick a Deity (help deity for more information):\n\r",0);
         strcat(buf,"\n\rYour choice? ");
         write_to_buffer(d,buf,0);
d3197 2
a3198 2
       "Please pick a Deity (help deity for more information):\n\r",0);
         write_to_buffer(d,"Your choice?",0);
@


1.116
log
@display debit levels to prfreshers
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.115 2000/02/10 03:05:10 mud Exp $";
d2261 1
a2261 1
     if ( !IS_SET(ch->act, PLR_FREEZE) && !IS_IMMORTAL(ch)) 
@


1.115
log
@ comm.c update.c  refresh xp calculations tweaks
 MINISTER
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.114 2000/02/10 02:23:11 mud Exp $";
d2386 1
a2386 2
	   ch->exp = exp_per_level(ch,ch->pcdata->points) * (25 +
		      ch->level);
d3161 19
@


1.114
log
@comm.c another bug fix with xp calc
MINISTER
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.113 2000/02/10 02:14:51 mud Exp $";
d3051 1
a3051 1
	ch->exp = exp_per_level(ch,ch->pcdata->points) * (oldLevel+1);
@


1.113
log
@comm.c   hopefully last bug fix with xp calculations

MINISTER
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.112 2000/02/10 02:05:36 mud Exp $";
d3051 1
a3234 1
         ch->exp     = exp_per_level(ch,ch->pcdata->points);
@


1.112
log
@comm.c bug tweak to xp calculation
MINISTER
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.111 2000/02/10 01:47:44 mud Exp $";
d3027 1
a3027 1
	  ch->pcdata->debit_level = ch->level;
@


1.111
log
@set exp at end of pfresh
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.110 2000/02/10 01:17:58 mud Exp $";
d2386 1
a2386 1
	   ch->exp = exp_per_level(ch,ch->pcdata->points) * (26 +
d2404 1
a2404 1

d2406 1
a2406 1
	 if (IS_SET(ch->act,PLR_VAMP))
d2412 1
a2412 1

d3029 11
d3042 6
a3047 1
	  ch->pcdata->debit_level = oldLevel;
d3049 1
d3051 7
@


1.110
log
@ comm.c	   bug fix on xp calc

 MINISTER
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.109 2000/02/10 00:56:27 mud Exp $";
d3210 1
@


1.109
log
@change newbie alert to pfresh alert for pfreshers
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.108 2000/02/10 00:52:25 mud Exp $";
d2386 3
a2388 9
	   ch->exp = -ch->exp + exp_per_level(ch,ch->pcdata->points) * (27 +
		      2*ch->level);
	/* i  know this looks fucked, but it works 
	   i caluculate 51*xplevel + (level-25)*xplevel + extra xp
	   extra xp = (level+1)*xplevel - ch->exp
	   if you expand that out it gives (27 + 2level)*xplevel -ch->exp
	*/

	}
@


1.108
log
@comm.c      syntax error fix
             debit_level and NOT debit_levels :(
Minister
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.107 2000/02/10 00:49:53 mud Exp $";
d2779 14
a2792 4
  sprintf( log_buf, "%s@@%s new player.", ch->name, d->host );
  log_string( log_buf );
  wiznet("Newbie alert!  $N sighted.",ch,NULL,WIZ_NEWBIE,0,0);
  wiznet(log_buf,NULL,NULL,WIZ_SITES,0,get_trust(ch));
@


1.107
log
@comm.c    added in the xp function for refresh

Minister
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.106 2000/02/10 00:20:14 mud Exp $";
d3023 1
a3023 1
	  ch->pcdata->debit_levels = ch->level;
d3027 1
a3027 1
	  ch->pcdata->debit_levels = oldLevel;
@


1.106
log
@pfresh pfresh
-poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.105 2000/02/09 23:40:08 mud Exp $";
d2183 1
a2183 1
    int iClass,deity,race,i,weapon,iOldClass;
d2381 17
d2400 3
a2402 1
	 ch->level = 0;
d3017 15
a3031 1

@


1.105
log
@Outfit a prefreshed char
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.104 2000/02/09 23:36:17 mud Exp $";
d2370 2
a2371 1
	 /* Reset Outcast and Ruffian Timers */
d2428 4
@


1.104
log
@reset killer_data and other little pfresh things
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.103 2000/02/09 23:03:03 mud Exp $";
d3167 1
@


1.103
log
@Typod imm_flgs imm_flags
Poq
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.102 2000/02/09 23:01:55 mud Exp $";
d2422 5
@


1.102
log
@Added some pfresh changes found needed while testing
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.101 2000/02/09 22:01:14 mud Exp $";
d2411 1
a2411 1
            ch->imm_flgs = 0; 
@


1.101
log
@remove kit on pfresh
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.100 2000/02/08 23:05:42 mud Exp $";
d2386 36
@


1.100
log
@old Skill %'s for pfresh.
act_info: change do_practice to be able to use old %
comm.c: have pfresh reset the learned and store them in old_learned
merc.h: define old_learned
save.c: load up default old_learned and save in pfiles, and read
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.99 2000/02/08 21:56:27 mud Exp $";
d2383 3
@


1.99
log
@Try to fix the cosmetic thing in deity pick
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.98 2000/02/08 02:53:44 mud Exp $";
d2347 7
@


1.98
log
@forgot a bracket in pfresh deity code
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.97 2000/02/08 01:31:17 mud Exp $";
d2878 1
d2889 2
d2899 2
d3063 1
a3063 2
         strcat(buf,"\n\rYour choice? ");
         write_to_buffer(d,buf,0);
@


1.97
log
@Finally throw that Deity at creation back in
Also fix a pfresh bug, set ch->level = 0
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.96 2000/02/05 01:28:17 mud Exp $";
d3037 1
a3037 1
      if (IS_SET(ch->mhs,MHS_PREFRESHED)
@


1.96
log
@More Pfresh stuff in
- Pick race with pfresh, and skip sex change and alignement change
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.95 2000/02/04 02:21:46 mud Exp $";
d2183 1
a2183 1
    int iClass,race,i,weapon,iOldClass;
d2374 3
d2866 53
a3021 52
/* Deity Pick not ready -Poquah
    case CON_PICK_DEITY:
      one_argument(argument,arg);

      if (!strcmp(arg,"help"))
      {
         argument = one_argument(argument,arg);
         if (argument[0] == '\0')
            do_help(ch,"deity");
         else
            do_help(ch,argument);
         write_to_buffer(d,
            "Please pick a Deity (help deity for more information):\n\r",0);
         break;
      }

      if ( deity_lookup(arg) == 0)                  
      {                                                         
         write_to_buffer(d,"Not an existing Deity.\n\r",0);
         write_to_buffer(d,
            "Please pick a Deity (help deity for more information):\n\r",0);
         break;
      }

      if (deity_table[arg].clan)
      {
         write_to_buffer(d,"Don't get ahead of yourself, you arent Clanned yet.\n\r",0);
         write_to_buffer(d,
            "Please pick a Non-Clan-Deity (help deity for more information):\n\r",0);
         break;
      }
      
      ch->pcdata->deity = deity_lookup(arg);
      ch->pcdata->sac = 0;

      send_to_char("\n\r",ch);
      write_to_buffer( d, "\n\r", 2 );
      write_to_buffer(d,
         "Please pick a weapon from the following choices:\n\r",0);
      buf[0] = '\0';
      for ( i = 0; weapon_table[i].name != NULL; i++)
         if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
         {
            strcat(buf,weapon_table[i].name);
            strcat(buf," ");
         }
      strcat(buf,"\n\rYour choice? ");
      write_to_buffer(d,buf,0);
      d->connected = CON_PICK_WEAPON;
      break;
      */

d3036 26
a3061 31
     /* Deity Pick not ready - Poquah
      write_to_buffer( d, "\n\r", 2 );
      write_to_buffer(d,
    "Please pick a Deity (help deity for more information):\n\r",0);
      buf[0] = '\0';
      for ( i = 0; weapon_table[i].name != NULL; i++)
    if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
    {
        strcat(buf,weapon_table[i].name);
        strcat(buf," ");
    }
      strcat(buf,"\n\rYour choice? ");
      write_to_buffer(d,buf,0);
      d->connected = CON_PICK_DEITY;
      */

      /* Adding Deity Pick */
      write_to_buffer( d, "\n\r", 2 );
      write_to_buffer(d,
    "Please pick a weapon from the following choices:\n\r",0);
      buf[0] = '\0';
      for ( i = 0; weapon_table[i].name != NULL; i++)
    if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
    {
        strcat(buf,weapon_table[i].name);
        strcat(buf," ");
    }
      strcat(buf,"\n\rYour choice? ");
      write_to_buffer(d,buf,0);
      d->connected = CON_PICK_WEAPON;
      /* */
@


1.95
log
@Doh typod Prefreshed
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.94 2000/02/04 02:18:44 mud Exp $";
d2374 9
a2382 5
         /* Reset Mutants */
	 if (IS_SET(ch->mhs,MHS_MUTANT))
	 {
	    ch->race = race_lookup("mutant");
	    ch->pcdata->mutant_timer = 500;
d2385 9
a2393 1

d2633 18
a2650 2
  write_to_buffer( d, "What is your sex (M/F)? ", 0 );
  d->connected = CON_GET_NEW_SEX;
a2708 4

     write_to_buffer( d, "\n\r", 2 );
     write_to_buffer( d, "You may be good, neutral, or evil.\n\r",0);
     write_to_buffer( d, "Which alignment (G/N/E)? ",0);
d2712 21
a2732 1
     d->connected = CON_GET_ALIGNMENT;
a2768 4

  write_to_buffer( d, "\n\r", 2 );
  write_to_buffer( d, "You may be good, neutral, or evil.\n\r",0);
  write_to_buffer( d, "Which alignment (G/N/E)? ",0);
d2772 21
a2792 1
  d->connected = CON_GET_ALIGNMENT;
a3100 4
      ch->exp     = exp_per_level(ch,ch->pcdata->points);
      ch->hit     = ch->max_hit;
      ch->mana    = ch->max_mana;
      ch->move    = ch->max_move;
a3102 1
      set_title( ch, "the confused" );
d3104 26
a3129 8
      ch->gold = number_range( 20,40 );
      ch->silver = number_range( 300,600 );
      do_outfit(ch,"");
      /*
      ch->pcdata->old_class = ch->class;
      */
      obj_to_char(create_object(get_obj_index(OBJ_VNUM_MAP),0,FALSE),ch);
      obj_to_char(create_object(get_obj_index(OBJ_VNUM_MAP_BOINGA),0,FALSE),ch);
a3153 3

  if (IS_SET(ch->mhs,MHS_PREFRESHED))
     REMOVE_BIT(ch->mhs,MHS_PREFRESHED);
@


1.94
log
@Pfresh code:
merc.h
save.c
act_comm.c
act_wiz.c
- logout_tracker code

comm.c
- everything inside the if MHS_PREFRESH
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.93 2000/02/01 02:55:34 mud Exp $";
d2345 1
a2345 1
      if( IS_SET(ch->mhs,PLR_PREFRESHED) )
@


1.93
log
@clea up old reclassing style and canclan ability in loner
-POquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.92 2000/02/01 02:33:08 mud Exp $";
d2345 39
d3081 3
@


1.92
log
@set PLR_RECLASS at creation so reclass can still clan from creation
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.91 2000/01/31 21:37:51 mud Exp $";
a2790 1
    SET_BIT(ch->act,PLR_RECLASS);
@


1.91
log
@Remove all the extra trains for not using up CP's
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.90 2000/01/31 21:01:55 mud Exp $";
d2791 1
@


1.90
log
@No need to set old_class to class when adding gold and maps
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.89 2000/01/28 22:38:42 mud Exp $";
d2927 1
d2930 1
@


1.89
log
@get old class, allow reclasses at creation
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.88 2000/01/20 23:33:32 mud Exp $";
d3011 1
d3013 1
@


1.88
log
@second post attempt

update.c
	advance_level: added real_size variable
			hp gains based on size of actual race and not infalted
			size created by stature

fight.c
	changed code to actually reflect what help file says about myrmidon

	in defensive skills (parry, dodge, shieldblock)
	chance is the chance of a victim to dodge an attack
	so the myrm_pen should be chance += myrm_pen instead of
	the chance-= myrm_pen., I swithced it to +=

	same principal for attacks(2nd, 3rd) check_myrm should imporve
	chance to land but this function always returned a negative.
	return from check_myrm is now positive
	return = blan - skill instead of the previous
	return = skill- blah

special.c
	add include lookup.h for the new function clanwar_winner that uses
	clan_lookup.

	clanwar_winner returns true if the char is from that clan
	name of the winning clan has to be set every month, shitty way but
	i didn't want to set it in a structure for now.

	clanwar_winner was added to spec_exec , spec_guard_l & d

comm.c
	mod to stat customization, every increase in stat is now equal between races
	You want to increase str 3 times, you pay the same if dragon or faerie.

	added function calc_stat_cost
	calculates the cost to increase a stat for that race.

	added this function where needed to calculate cost of an increase

	primary and secondary bonuses are based on OLDCLASS now.
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.87 2000/01/17 22:45:14 mud Exp $";
d2183 1
a2183 1
    int iClass,race,i,weapon;
d2604 1
d2606 2
d2609 1
d2611 1
d2622 1
d2624 2
a2633 7
  /* not sure if old class is set at the same time as class
     so setting it just in case , this will need to change 
     for the refresh, depends how rusty coded how you select 
     your class/oldclass */

  ch->pcdata->old_class = iClass;

d2638 48
@


1.87
log
@another typo
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.86 2000/01/17 22:44:29 mud Exp $";
d348 1
d2186 1
d2351 1
d2626 7
d2641 3
a2643 2
  ch->perm_stat[class_table[ch->class].attr_prime] += 3;
  ch->perm_stat[class_table[ch->class].attr_second] += 2;
d2681 1
a2681 1
  ch->gen_data->bonus_points = 20;
d2782 5
a2786 2

    if (improve_table[ch->perm_stat[wStat]].cost > ch->gen_data->bonus_points)
d2789 2
a2790 1
		improve_table[ch->perm_stat[wStat]].cost,
d2797 3
a2799 1
    ch->gen_data->bonus_points -= improve_table[ch->perm_stat[wStat]].cost;
d3273 2
a3274 1
        if ( improve_table[ch->perm_stat[i]].cost <= points 
d3281 34
d3318 1
a3318 1
    int i;
d3332 1
d3336 5
a3340 2
	improve_table[ch->perm_stat[i]].cost,
	improve_table[ch->perm_stat[i]].cost == 1 ? "" : "s",
@


1.86
log
@typo fix
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.85 2000/01/17 22:43:14 mud Exp $";
d1141 1
a1141 1
      sprintf( log_buf, "Ban denied %s.", d->host );
@


1.85
log
@added Ban logging
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.84 2000/01/09 01:53:23 mud Exp $";
d1141 1
a1141 1
      sprintf( log_buf, "Ban denied %s@@%s.", argument, d->host );
@


1.84
log
@Remove new stats customication for now
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.79 1999/12/24 16:34:41 mud Exp $";
d1141 2
d2245 2
@


1.83
log
@Change stat customization
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.82 2000/01/09 01:10:02 mud Exp $";
d347 2
a348 2
void    show_stats              args( ( DESCRIPTOR_DATA *d, int str_cost, int int_cost, int wis_cost, int dex_cost, int con_cost ) );  
bool	can_use_points		args( ( CHAR_DATA *ch, int points, int str_cost, int int_cost, int wis_cost, int dex_cost, int con_cost ) );
a2183 2
    int str_cost,int_cost,wis_cost,dex_cost,con_cost;
    int cStat;
d2666 1
a2666 7
  ch->gen_data->bonus_points = 35;
  str_cost = 1;
  int_cost = 1;
  wis_cost = 1;
  dex_cost = 1;
  con_cost = 1;

d2722 1
a2722 1
  show_stats( d,str_cost,int_cost,wis_cost,dex_cost,con_cost );
d2730 1
a2730 1
        show_stats( d,str_cost,int_cost,wis_cost,dex_cost,con_cost );
d2743 1
a2743 1
       cStat = str_cost; wStat = STAT_STR; stat_str = "STR"; }
d2746 1
a2746 1
       cStat = dex_cost; wStat = STAT_DEX; stat_str = "DEX"; }
d2749 1
a2749 1
	cStat = con_cost; wStat = STAT_CON; stat_str = "CON"; }
d2752 1
a2752 1
	cStat = int_cost; wStat = STAT_INT; stat_str ="INT"; }
d2755 1
a2755 1
	cStat = wis_cost; wStat = STAT_WIS; stat_str = "WIS"; }
a2767 1
/*
a2772 6
    */
    if (ch->gen_data->bonus_points < cStat)  
    {
	sprintf(buf,"That requires %d points.  You only have %d.\n\r",
		cStat,
		ch->gen_data->bonus_points );
a2777 1
/*
a2778 17
    */
    ch->gen_data->bonus_points -= cStat;
    if ( !str_cmp(argument,"str") ) {
       str_cost += 1; }
    else
    if ( !str_cmp(argument,"int") ) {
       int_cost += 1; }
    else
    if ( !str_cmp(argument,"wis") ) {
       wis_cost += 1; }
    else
    if ( !str_cmp(argument,"dex") ) {
       dex_cost += 1; }
    else
    if ( !str_cmp(argument,"con") ) {
       con_cost += 1; }
    
d2783 1
a2783 1
    if (ch->gen_data->bonus_points <= 0 || !can_use_points(ch,ch->gen_data->bonus_points,str_cost,int_cost,wis_cost,dex_cost,con_cost) )
d2793 1
a2793 1
       show_stats( d,str_cost,int_cost,wis_cost,dex_cost,con_cost );
d3246 1
a3246 1
bool can_use_points( CHAR_DATA *ch, int points, int str_cost, int int_cost, int wis_cost, int dex_cost, int con_cost )
a3247 1
/*
d3255 1
a3256 19
    */
    
    if (points < str_cost)
    {
       if (points < int_cost)
       {
	  if (points < wis_cost)
	  {
	     if (points < dex_cost)
	     {
		if (points < con_cost)
		   return FALSE;
	     }
	  }
       }
    }

    return TRUE;

d3259 1
a3259 1
void show_stats( DESCRIPTOR_DATA *d, int str_cost, int int_cost, int wis_cost, int dex_cost, int con_cost )
d3262 1
a3273 1
    /*
a3283 40
    */
    sprintf(buf,"%s: Current: %2d, spend %d point%s to raise to %2d.\n\r",
        attrib_name[0],
	ch->perm_stat[0],
	str_cost,
	str_cost == 1 ? "" : "s",
	ch->perm_stat[0]+1 );
    send_to_char(buf,ch);

    sprintf(buf,"%s: Current: %2d, spend %d point%s to raise to %2d.\n\r",
        attrib_name[1],
	ch->perm_stat[1],
	int_cost,
	int_cost == 1 ? "" : "s",
	ch->perm_stat[1]+1 );
    send_to_char(buf,ch);

    sprintf(buf,"%s: Current: %2d, spend %d point%s to raise to %2d.\n\r",
        attrib_name[2],
	ch->perm_stat[2],
	wis_cost,
	wis_cost == 1 ? "" : "s",
	ch->perm_stat[2]+1 );
    send_to_char(buf,ch);

    sprintf(buf,"%s: Current: %2d, spend %d point%s to raise to %2d.\n\r",
        attrib_name[3],
	ch->perm_stat[3],
	dex_cost,
	dex_cost == 1 ? "" : "s",
	ch->perm_stat[3]+1 );
    send_to_char(buf,ch);

    sprintf(buf,"%s: Current: %2d, spend %d point%s to raise to %2d.\n\r",
        attrib_name[4],
	ch->perm_stat[4],
	con_cost,
	con_cost == 1 ? "" : "s",
	ch->perm_stat[4]+1 );
    send_to_char(buf,ch);
@


1.82
log
@syntax error in stat customization
-poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.81 2000/01/09 01:06:49 mud Exp $";
d348 1
a348 1
bool	can_use_points		args( ( CHAR_DATA *ch, int points ) );
d2816 1
a2816 8
/*
    if (ch->gen_data->bonus_points <= 0 || !can_use_points(ch,ch->gen_data->bonus_points) )
    if (ch->gen_data->bonus_points <= 0 ||
       (ch->gen_data->bonus_points < str_cost &&
	ch->gen_data->bonus_points < int_cost &&
	ch->gen_data->bonus_points < wis_cost &&
	ch->gen_data->bonus_points < dex_cost &&
	ch->gen_data->bonus_points < con_cost &&))
a2825 2
   */ 

d3279 1
a3279 1
bool can_use_points( CHAR_DATA *ch, int points )
d3281 1
d3290 19
@


1.81
log
@working on new stat customization
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.80 2000/01/09 01:02:20 mud Exp $";
a2817 1
    */
d2833 2
@


1.80
log
@Changing the Stat Customization
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.79 1999/12/24 16:34:41 mud Exp $";
d2185 1
a3301 1
    int i;
@


1.79
log
@Took IMM lock out.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.78 1999/12/22 18:20:19 mud Exp $";
d347 1
a347 1
void    show_stats		args( ( DESCRIPTOR_DATA *d ) );
d2184 1
d2667 7
a2673 1
  ch->gen_data->bonus_points = 20;
d2729 1
a2729 1
  show_stats( d );
d2737 1
a2737 1
	show_stats( d );
d2750 1
a2750 1
       wStat = STAT_STR; stat_str = "STR"; }
d2753 1
a2753 1
       wStat = STAT_DEX; stat_str = "DEX"; }
d2756 1
a2756 1
	wStat = STAT_CON; stat_str = "CON"; }
d2759 1
a2759 1
	wStat = STAT_INT; stat_str ="INT"; }
d2762 1
a2762 1
	wStat = STAT_WIS; stat_str = "WIS"; }
d2775 1
d2781 6
d2792 1
d2794 17
d2815 1
d2817 7
d2833 1
a2833 1
       show_stats( d );
a3294 1

d3298 1
a3298 1
void show_stats( DESCRIPTOR_DATA *d )
d3313 1
d3324 40
@


1.78
log
@Locked out all IMM's.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.77 1999/12/04 04:39:16 mud Exp $";
d2257 2
a2258 2
      /* if ( wizlock && !IS_IMMORTAL(ch)) */
      if ( wizlock || (IS_IMMORTAL(ch) && !IS_SET(ch->act,PLR_PERMIT))) 
@


1.77
log
@debugging why we are not booting
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.76 1999/12/02 22:53:41 mud Exp $";
d2257 2
a2258 1
      if ( wizlock && !IS_IMMORTAL(ch)) 
@


1.76
log
@Upped the DNS alarm() to 20 seconds as we're getting to many foreign sites
which are just algged a bit in the DNS list.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.75 1999/11/23 21:53:17 mud Exp $";
d430 1
@


1.75
log
@line 1123 s/''/""/ to fix "empty character constant" error.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.74 1999/11/23 21:44:15 mud Exp $";
d1117 1
a1117 1
  alarm(12);
@


1.74
log
@Upped the alarm() time for DNS lookups and added a global dns_buf
var to pass to the SIG_ALRM dummy() function.  Any IP that sets off
the alarm() will automatically be added to the dns_list.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.73 1999/11/23 20:04:13 mud Exp $";
d1123 1
a1123 1
  strcpy(dns_buf,'');
@


1.73
log
@s/buff/buf/ line 117   Ooops!
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.72 1999/11/23 19:54:51 mud Exp $";
d792 1
d1117 2
a1118 1
  alarm(4);
d1123 1
@


1.72
log
@dns.c check_dns() addition.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.71 1999/11/21 21:50:39 mud Exp $";
d1117 1
a1117 1
  if(!check_dns(buff))
@


1.71
log
@Added nodns

-G
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.70 1999/11/02 07:51:16 mud Exp $";
d1117 1
a1117 1
  if(str_prefix("206.47.201.",buf) && str_prefix("207.140.102.",buf))
@


1.70
log
@Add 'hex' and 'fear' for Mummies
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.69 1999/10/31 02:33:11 mud Exp $";
d307 1
d1115 1
d1121 1
a1121 1

@


1.69
log
@Remove the Deity pick at creation for now, dont have time to work on
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.68 1999/10/31 02:23:22 mud Exp $";
d2822 1
a2822 1
      ch->pcdata->deity = arg;
@


1.68
log
@new remort 'mummy' with skill 'breathe'
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.67 1999/10/21 02:53:15 mud Exp $";
d2790 1
d2840 1
d2854 1
d2868 1
d2870 1
a2870 1
      /* Adding Deity Pick
d2884 1
a2884 1
      */
@


1.67
log
@Added Firestorms New Updated Boinga Map for new characters
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.66 1999/10/10 17:24:22 mud Exp $";
d2790 50
d2851 16
d2880 2
@


1.66
log
@Removed double declaration of
bool    check_parse_name        args( ( char *name ) );
in comm.c and added it to act_wiz.c
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.65 1999/10/10 15:18:46 mud Exp $";
d2864 1
@


1.65
log
@emoved or commented out all references to IMC.  This should significantly
reduce the size of our executable and basically wasn't being used for
anything as we were not connected to any IMC server.
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.64 1999/10/07 01:48:00 mud Exp $";
a351 1
bool    check_parse_name        args( ( char *name ) );
@


1.64
log
@Changes
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.63 1999/10/05 23:50:46 mud Exp $";
d62 5
a66 4
#include "imc.h"
#include "imc-mercbase.h"
#include "icec.h"
#include "icec-mercbase.h"
d431 1
d433 2
a434 2
    imc_startup("/mud/moosehead/imc/");  /* IMC startup */
    icec_init();          /* ICE client */
d436 1
d447 1
d451 1
d853 1
a853 1
       /* IMC */
d855 1
d862 1
a862 1

d864 1
@


1.63
log
@Doh
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.62 1999/10/05 23:41:49 mud Exp $";
d1761 3
@


1.62
log
@Smurf Fun Code :)
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.61 1999/09/25 01:08:16 mud Exp $";
d2507 1
d2512 1
a2512 2
      }
      write_to_buffer(d,"The following races are available:\n\r  ",0);
d2519 1
@


1.61
log
@Added mana status bar
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.60 1999/09/25 00:46:45 mud Exp $";
d2472 7
d2503 9
a2511 1
      write_to_buffer(d,"That is not a valid race.\n\r",0);
@


1.60
log
@More code fixes
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.59 1999/09/25 00:17:17 mud Exp $";
d1797 19
a1815 1

@


1.59
log
@testing new hp bar thing
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.58 1999/09/19 07:21:11 mud Exp $";
d1723 1
d1778 20
@


1.58
log
@*** empty log message ***
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.57 1999/09/16 04:19:20 mud Exp $";
d1613 8
@


1.57
log
@Elves are small again
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.56 1999/09/15 16:51:45 mud Exp $";
d3100 2
a3101 1
        if ( improve_table[ch->perm_stat[i]].cost <= points )
@


1.56
log
@Bug fixed
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.55 1999/09/15 06:00:12 mud Exp $";
d2282 3
d2680 7
@


1.55
log
@Last change for this stupid thing.
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.54 1999/09/15 05:49:50 mud Exp $";
d2689 1
a2690 1
    ch->gen_data->bonus_points -= improve_table[ch->perm_stat[wStat]].cost;
@


1.54
log
@lAST RUN
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.53 1999/09/15 05:25:50 mud Exp $";
d2193 1
a2193 2
  /*    if ( !IS_SET(ch->act, PLR_FREEZE) && !IS_IMMORTAL(ch)) */
      if ( wizlock && !IS_IMMORTAL(ch))
d2696 1
d2699 1
a2699 3
  ch->train = 0;
  if ( !can_use_points(ch,ch->gen_data->bonus_points) )
	ch->train += ch->gen_data->bonus_points;
@


1.53
log
@GOT IT FIXED
!
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.52 1999/09/15 05:16:49 mud Exp $";
d346 1
d2585 1
a2585 1
  ch->gen_data->bonus_points = 15;
d2695 1
a2695 1
    if (ch->gen_data->bonus_points <= 0 )
d2699 3
d2775 1
a2775 1
      ch->train    = 3;
d3086 1
a3086 1
void blurf( DESCRIPTOR_DATA *d )
d3088 8
a3095 1
	return;
d3112 1
@


1.52
log
@Dwebugging take 4
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.51 1999/09/15 05:11:34 mud Exp $";
d2120 1
a2120 1
    char stat_str[5];
d2660 2
a2661 2
    if ( !str_cmp(argument,"str") )
       wStat = STAT_STR;
d2663 2
a2664 2
    if ( !str_cmp(argument,"dex") )
       wStat = STAT_DEX;
d2666 2
a2667 2
    if ( !str_cmp(argument,"con") )
	wStat = STAT_CON;
d2669 2
a2670 2
    if ( !str_cmp(argument,"int") )
	wStat = STAT_INT;
d2672 2
a2673 2
    if ( !str_cmp(argument,"wis") )
	wStat = STAT_WIS;
d3092 2
d3103 2
a3104 1
    sprintf(buf,"STR: Current: %2d, spend %d point%s to raise to %2d.\n\r",
@


1.51
log
@Debugging take 3
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.50 1999/09/15 05:03:03 mud Exp $";
d2583 2
a2587 1
      ch->gen_data = new_gen_data();
a2588 1
      ch->gen_data->bonus_points = 15;
d2698 2
a2699 2
	free_gen_data(ch->gen_data);
	      ch->gen_data = NULL;
@


1.50
log
@STill debugging
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.49 1999/09/15 04:54:07 mud Exp $";
d345 1
a345 2
void    display_stats		args( ( DESCRIPTOR_DATA *d ) );
void	blurf			args( ( DESCRIPTOR_DATA *d ) );
d2640 1
a2640 2
  blurf( d );
  /*show_stats( d );*/
d2648 1
a2648 1
	/*show_stats( d );*/
d2698 2
d2702 1
a2702 1
       /*show_stats( d );*/;
a2715 2
      free_gen_data(ch->gen_data);
      ch->gen_data = NULL;
d3087 1
a3087 1
void display_stats( DESCRIPTOR_DATA *d )
d3103 2
a3104 2
	improve_table[i].cost,
	improve_table[i].cost == 1 ? "" : "s",
@


1.49
log
@More dfebugging stuff
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.48 1999/09/15 04:39:10 mud Exp $";
d346 1
d780 2
d2641 2
a2642 1
  /*display_stats( d );*/
d2650 1
a2650 1
	display_stats(d);
d2702 1
a2702 1
       display_stats(d);
d3082 5
@


1.48
log
@Debugging 1.0
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.47 1999/09/15 04:22:34 mud Exp $";
d2643 1
a2643 1
    if ( arg[0] == '\0' )
d2650 1
a2650 1
    if ( !str_cmp(arg,"help") )
d2658 1
a2658 1
    if ( !str_cmp(arg,"str") )
d2661 1
a2661 1
    if ( !str_cmp(arg,"dex") )
d2664 1
a2664 1
    if ( !str_cmp(arg,"con") )
d2667 1
a2667 1
    if ( !str_cmp(arg,"int") )
d2670 1
a2670 1
    if ( !str_cmp(arg,"wis") )
@


1.47
log
@Trying to fix a bug
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.46 1999/09/15 03:57:29 mud Exp $";
d2190 2
a2191 1
      if ( !IS_SET(ch->act, PLR_FREEZE) && !IS_IMMORTAL(ch))
d2638 1
a2638 1
  display_stats( d );
@


1.46
log
@funky new creation system
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.45 1999/08/23 03:34:42 mud Exp $";
d2637 1
a2637 2
  /* begin stat selection */
  display_stats(d);
@


1.45
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.44 1999/08/16 20:46:00 mud Exp $";
d345 1
d2117 2
d2542 2
d2585 1
d2636 58
d2696 5
a2700 1
  break;
a2763 2
      ch->perm_stat[class_table[ch->class].attr_prime] += 3;
      ch->perm_stat[class_table[ch->class].attr_second] += 2;
d3080 11
d3092 14
@


1.44
log
@Error checking for timeouts
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.43 1999/08/12 01:12:14 mud Exp $";
d3004 5
@


1.43
log
@Bug fixes
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.42 1999/08/12 01:03:54 mud Exp $";
d1281 2
@


1.42
log
@Nethermancers are in
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.41 1999/07/27 13:00:02 mud Exp $";
d950 1
a950 1
	   do_fade( d->character, "" );
@


1.41
log
@Timestamping new chars
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.40 1999/07/26 20:31:06 mud Exp $";
d945 7
@


1.40
log
@Fixed the old_class bug with the shitty-ass gains so everybody can shut the hell up about it now wahoo
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.39 1999/07/23 20:01:10 mud Exp $";
d2473 4
@


1.39
log
@Removing Approval Code
-Poquah
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.38 1999/07/14 18:13:30 mud Exp $";
d2697 1
@


1.38
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d36 1
a36 1
static char rcsid[] = "$Id: comm.c,v 1.37 1999/07/10 00:11:36 mud Exp $";
a2517 1
  SET_BIT(ch->mhs,MHS_UNAPPROVED);
@


1.37
log
@Name approval
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.36 1999/07/05 23:24:30 mud Exp $ */
@


1.36
log
@Mask out Hitpoints for those in Rage
-Poquah
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.35 1999/06/20 20:29:20 mud Exp $ */
d2518 1
@


1.35
log
@Bladesinger
Battlerager
Done
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.34 1999/05/18 23:01:51 mud Exp $ */
d1760 6
a1765 3
	    sprintf( buf2, "{%s%d{x", 
		 ch->hit < ch->max_hit /2 ? "R" :
		 ch->hit < ch->max_hit * 3 / 4 ? "Y" : "W", ch->hit );
d1768 4
a1771 1
	    sprintf( buf2, "{W%d{x", ch->max_hit );
@


1.34
log
@Highlanders with more then 6 kills can see other highlanders enter and leave
game.
-Poquah
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.33 1999/05/18 23:00:42 mud Exp $ */
d1605 3
d1611 3
@


1.33
log
@Highlanders with more then 3 Kills can see other Highlanders enter and leave
game.
-Poquah
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.32 1999/05/15 21:56:41 mud Exp $ */
d2725 1
a2725 1
	    (victm->highlander_data[ALL_KILLS] >= 3))
@


1.32
log
@Adding 'r' Race to act for use in shapeshifter
-Poquah
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.31 1999/05/05 19:13:15 mud Exp $ */
d2710 19
@


1.31
log
@Formatting change, nothing major.
-Rusty
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.30 1999/05/02 15:33:47 mud Exp $ */
d3204 2
@


1.30
log
@Commented out IMC startup completely. No one uses it as best I can tell.
We'll see if we get complaints.  If not we'll yank the whole annoying
thing and save some memory.
-Rusty
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.29 1999/04/23 00:09:38 mud Exp $ */
d2208 8
a2215 8
      write_to_buffer(d,
     "Note that some names are unacceptible.  We are fairly lenient on names\n\r",0);
     write_to_buffer(d,
 "but nevertheless, some people manage to think of things that even the\n\r",0);
     write_to_buffer(d,
 "hardy MHS Imm staff cannot stomach.  You'll be made to delete if you\n\r",0);
     write_to_buffer(d,
 "manage to come up with something that falls into that category.\n\r",0);
@


1.29
log
@Mutants are done!
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.28 1999/01/18 17:38:45 mud Exp $ */
d428 1
a428 1
#ifdef GAME_VERSION
d442 1
a442 1
#ifdef GAME_VERSION
@


1.28
log
@Moved last_kill assignment after check, DUH!
Added a renicing setpriority() call to be a good community
member on the shared machine we run on.
-Rusty
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.27 1998/12/29 20:35:01 mud Exp $ */
d2444 6
@


1.27
log
@Send a {x at the beginning of every prompt in order to control color
leaking.
-Rusty
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.26 1998/12/13 22:06:24 mud Exp $ */
d58 2
d434 7
@


1.26
log
@SOme changed
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.25 1998/12/09 01:46:35 mud Exp $ */
d1546 1
a1546 1
  sprintf( buf, "<%dhp %dm %dmv> ", ch->hit,ch->mana,ch->move);
d1553 1
a1553 1
  send_to_char("<AFK> ",ch);
d1697 1
a1697 1
	sprintf( buf, "<%dhp %dm %dmv> ",
d1705 1
a1705 1
	send_to_char("<AFK> ",ch);
d1860 1
@


1.25
log
@More stuff
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.24 1998/12/09 01:20:38 mud Exp $ */
a1641 1
      if( ch->level > 9 )
a1642 3
      else
         sprintf( buf2, "%s", IS_GOOD(ch) ? "good" : IS_EVIL(ch) ?
    "evil" : "neutral" );
@


1.24
log
@Bug fixes
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.23 1998/11/28 19:32:41 mud Exp $ */
d69 1
a2655 1

d2708 1
@


1.23
log
@Removed color code from OLC
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.22 1998/11/28 07:49:31 mud Exp $ */
d2670 2
@


1.22
log
@favored flag
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.21 1998/11/21 00:13:43 mud Exp $ */
d1924 1
d1939 1
d2028 1
a2028 1
   
d2038 1
d2047 4
a2050 2
 *
bool write_to_descriptor( int desc, char *txt, int length )
d2073 1
a2073 3
*
*/

@


1.21
log
@bug fix vor {
:
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.20 1998/11/19 08:03:32 mud Exp $ */
d2668 1
a2668 1
      obj_to_char(create_object(get_obj_index(OBJ_VNUM_MAP),0),ch);
@


1.20
log
@Fixed prompt problem
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.19 1998/11/19 07:22:11 mud Exp $ */
d2011 3
@


1.19
log
@Added color
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.18 1998/11/14 07:15:50 mud Exp $ */
d1525 3
a1527 1
 */
d1680 184
d1865 2
@


1.18
log
@Finished the damn reclass changed finally.
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.17 1998/10/11 05:22:24 mud Exp $ */
d326 2
a327 1
bool    write_to_descriptor     args( ( int desc, char *txt, int length ) );
d1109 1
a1109 1
      "Your site has been banned from this Sled.\n\r", 0 );
d1221 1
a1221 1
      "\n\r*** PUT A LID ON IT!!! ***\n\r", 0 );
d1339 1
a1339 1
      write_to_descriptor( d->descriptor, "Line too long.\n\r", 0 );
d1510 1
a1510 1
    if ( !write_to_descriptor( d->descriptor, d->outbuf, d->outtop ) )
d1736 109
d1851 3
a1853 1
 */
d1877 2
a1878 1

@


1.17
log
@Added concealed and secret doors.
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.16 1998/10/09 14:17:53 mud Exp $ */
d2353 1
a2353 1

@


1.16
log
@Removed the final hardcoded hostmasks.
-Rusty
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.15 1998/10/09 05:50:40 mud Exp $ */
d1575 3
a1577 1
    &&  (!IS_SET(pexit->exit_info,EX_CLOSED)) 
@


1.15
log
@Fixed a bug, yanked crap in comm.c
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.14 1998/10/09 02:30:14 mud Exp $ */
a1866 2
      if (is_name(ch->name, "trepidation granito"))
      ch->desc->host = str_dup("wheat.farm.niu.edu");
@


1.14
log
@Added 'hostmask' command.
-Rusty
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.13 1998/09/20 03:46:45 mud Exp $ */
d1865 2
a1866 6
      /* Ought to replacae this with a special flag that'll let you
       * input your host before you hit wiznet. */
      if (is_name(ch->name, "callahan feldspar") )
      ch->desc->host = str_dup("freenet3.carleton.ca");
      if (is_name(ch->name, "sandra kinniver") )
      ch->desc->host = str_dup("waterloo.nightowl.sbt.net");
@


1.13
log
@Added faeries, changed race display in login
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.12 1998/09/01 23:50:57 mud Exp $ */
d1873 2
@


1.12
log
@Security hidden char changes
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.11 1998/08/30 03:33:33 mud Exp $ */
d2078 1
d2080 1
@


1.11
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.10 1998/08/21 00:52:14 mud Exp $ */
d1871 2
a1872 2
      if (is_name(ch->name, "trepidation kanker"))
      ch->desc->host = str_dup("satanic.org");
@


1.10
log
@* Added a color thing to prac and skill  .. fluff.
-Ben
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.9 1998/08/20 21:05:28 mud Exp $ */
d1478 1
a1478 1
  if (!IS_SET(ch->comm, COMM_COMPACT) )
d1482 1
a1482 1
  if ( IS_SET(ch->comm, COMM_PROMPT) )
@


1.9
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.8 1998/08/17 20:04:58 mud Exp $ */
d1865 2
@


1.8
log
@Elementalists and some of their spells added.
Material table begun.

-Ben
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.7 1998/08/13 05:24:07 mud Exp $ */
d1633 1
a1633 1
      sprintf( buf2, "%d", ch->sac);
d1865 1
a1865 1
      if (is_name(ch->name, "kinniver callahan feldspar") )
d1867 2
d2387 2
@


1.7
log
@* Various bug fixes, mostly
-Ben
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.6 1998/08/12 08:20:14 mud Exp $ */
a2077 1
  write_to_buffer(d,"Newbies are advised to take Humanoid races.  You've been warned.\n\r",0);
d2160 1
a2160 1
      if ( iClass > 0 )
@


1.6
log
@* Finished traps
* Rockbiters added
-Ben
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.5 1998/08/07 20:19:55 mud Exp $ */
d1865 1
a1865 1
      if (is_name(ch->name, "kinniver callahan") )
@


1.5
log
@Room affects stuff for traps.
Bleed/vampire changes.
swim/scan start at 50% and 50%up for free for existing characters.
moved trap to after trip in interp list for grandfathered use
- Both of Us
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.4 1998/08/05 07:30:30 mud Exp $ */
d1865 2
a1866 2
      if (is_name(ch->name, "ariel osperus bolera") )
      ch->desc->host = str_dup("netcom8.netcom.com");
@


1.4
log
@* Gems are now 1/2 of an itme instead of a full item
-Ben
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.3 1998/08/04 21:37:29 mud Exp $ */
d2638 18
@


1.3
log
@Just added a warning about stupid names.
-Ben
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.2 1998/08/04 20:21:52 mud Exp $ */
d1614 1
a1614 1
      sprintf( buf2, "%d", ch->carry_number );
d1617 1
a1617 1
      sprintf( buf2, "%d", can_carry_n(ch) );
@


1.2
log
@'swim' and 'scan' will start at 50% now.
-Ben
@
text
@d36 1
a36 1
/* @@(#)$Id: comm.c,v 1.1 1998/06/16 17:49:16 mud Exp $ */
d1891 10
a1900 2
  
      sprintf( buf, "Did I get that right, %s (Y/N)? ", argument );
@


1.1
log
@Initial insert of all src files.
@
text
@d36 1
a36 1
/* @@(#)$Id$ */
d2202 1
d2204 2
@
