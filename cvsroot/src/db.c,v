head	1.186;
access;
symbols;
locks; strict;
comment	@ * @;


1.186
date	2004.08.26.01.30.26;	author boogums;	state Exp;
branches;
next	1.185;

1.185
date	2004.08.01.16.33.02;	author boogums;	state Exp;
branches;
next	1.184;

1.184
date	2004.07.31.05.14.16;	author boogums;	state Exp;
branches;
next	1.183;

1.183
date	2004.07.07.04.11.03;	author boogums;	state Exp;
branches;
next	1.182;

1.182
date	2004.07.07.03.53.31;	author boogums;	state Exp;
branches;
next	1.181;

1.181
date	2004.07.07.03.36.29;	author boogums;	state Exp;
branches;
next	1.180;

1.180
date	2004.07.07.03.09.37;	author boogums;	state Exp;
branches;
next	1.179;

1.179
date	2004.07.07.02.56.51;	author boogums;	state Exp;
branches;
next	1.178;

1.178
date	2004.04.25.00.57.47;	author boogums;	state Exp;
branches;
next	1.177;

1.177
date	2003.11.27.23.09.07;	author boogums;	state Exp;
branches;
next	1.176;

1.176
date	2003.06.14.19.53.11;	author boogums;	state Exp;
branches;
next	1.175;

1.175
date	2003.02.17.21.54.50;	author ndagger;	state Exp;
branches;
next	1.174;

1.174
date	2002.12.05.05.16.57;	author boogums;	state Exp;
branches;
next	1.173;

1.173
date	2002.11.04.16.07.09;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	2002.10.13.02.55.43;	author boogums;	state Exp;
branches;
next	1.171;

1.171
date	2002.10.10.03.20.03;	author boogums;	state Exp;
branches;
next	1.170;

1.170
date	2002.10.10.03.13.19;	author boogums;	state Exp;
branches;
next	1.169;

1.169
date	2002.07.01.00.26.20;	author boogums;	state Exp;
branches;
next	1.168;

1.168
date	2002.06.03.18.30.44;	author rusty;	state Exp;
branches;
next	1.167;

1.167
date	2002.05.22.18.00.40;	author rusty;	state Exp;
branches;
next	1.166;

1.166
date	2002.04.11.03.17.37;	author boogums;	state Exp;
branches;
next	1.165;

1.165
date	2002.04.05.15.24.28;	author boogums;	state Exp;
branches;
next	1.164;

1.164
date	2001.12.08.02.08.53;	author poquah;	state Exp;
branches;
next	1.163;

1.163
date	2001.12.08.02.07.08;	author poquah;	state Exp;
branches;
next	1.162;

1.162
date	2001.12.04.17.54.51;	author rage;	state Exp;
branches;
next	1.161;

1.161
date	2001.11.29.09.38.58;	author poquah;	state Exp;
branches;
next	1.160;

1.160
date	2001.11.29.09.23.02;	author poquah;	state Exp;
branches;
next	1.159;

1.159
date	2001.11.11.17.29.11;	author rage;	state Exp;
branches;
next	1.158;

1.158
date	2001.11.11.01.01.13;	author rage;	state Exp;
branches;
next	1.157;

1.157
date	2001.10.20.19.40.44;	author rage;	state Exp;
branches;
next	1.156;

1.156
date	2001.10.19.22.10.27;	author rage;	state Exp;
branches;
next	1.155;

1.155
date	2001.10.17.03.02.46;	author boogums;	state Exp;
branches;
next	1.154;

1.154
date	2001.08.24.21.26.32;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	2001.08.05.22.47.36;	author guerrand;	state Exp;
branches;
next	1.152;

1.152
date	2001.08.04.15.54.46;	author guerrand;	state Exp;
branches;
next	1.151;

1.151
date	2001.07.30.04.51.48;	author guerrand;	state Exp;
branches;
next	1.150;

1.150
date	2001.07.29.04.54.18;	author guerrand;	state Exp;
branches;
next	1.149;

1.149
date	2001.07.27.02.14.11;	author guerrand;	state Exp;
branches;
next	1.148;

1.148
date	2001.07.15.20.01.20;	author boogums;	state Exp;
branches;
next	1.147;

1.147
date	2001.07.04.15.22.24;	author guerrand;	state Exp;
branches;
next	1.146;

1.146
date	2001.07.04.02.29.28;	author guerrand;	state Exp;
branches;
next	1.145;

1.145
date	2001.07.03.03.28.48;	author guerrand;	state Exp;
branches;
next	1.144;

1.144
date	2001.07.02.16.42.37;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	2001.06.25.20.40.03;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	2001.06.23.18.28.57;	author guerrand;	state Exp;
branches;
next	1.141;

1.141
date	2001.06.22.23.45.54;	author guerrand;	state Exp;
branches;
next	1.140;

1.140
date	2001.06.19.06.28.56;	author guerrand;	state Exp;
branches;
next	1.139;

1.139
date	2001.06.19.06.16.21;	author guerrand;	state Exp;
branches;
next	1.138;

1.138
date	2001.06.19.05.32.08;	author guerrand;	state Exp;
branches;
next	1.137;

1.137
date	2001.06.19.01.38.41;	author guerrand;	state Exp;
branches;
next	1.136;

1.136
date	2001.06.18.01.17.32;	author rage;	state Exp;
branches;
next	1.135;

1.135
date	2001.06.17.18.53.40;	author guerrand;	state Exp;
branches;
next	1.134;

1.134
date	2001.06.17.17.06.00;	author guerrand;	state Exp;
branches;
next	1.133;

1.133
date	2001.06.11.04.22.38;	author guerrand;	state Exp;
branches;
next	1.132;

1.132
date	2001.06.11.01.17.01;	author rage;	state Exp;
branches;
next	1.131;

1.131
date	2001.06.07.22.29.59;	author rage;	state Exp;
branches;
next	1.130;

1.130
date	2001.06.07.16.24.49;	author rusty;	state Exp;
branches;
next	1.129;

1.129
date	2001.06.07.15.32.08;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	2001.06.06.23.49.23;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	2001.06.06.23.20.13;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	2001.06.05.02.48.57;	author guerrand;	state Exp;
branches;
next	1.125;

1.125
date	2001.06.05.02.42.42;	author guerrand;	state Exp;
branches;
next	1.124;

1.124
date	2001.06.05.02.34.14;	author guerrand;	state Exp;
branches;
next	1.123;

1.123
date	2001.06.05.02.25.31;	author guerrand;	state Exp;
branches;
next	1.122;

1.122
date	2001.06.05.01.34.21;	author rage;	state Exp;
branches;
next	1.121;

1.121
date	2001.06.03.22.29.38;	author guerrand;	state Exp;
branches;
next	1.120;

1.120
date	2001.06.03.21.42.41;	author guerrand;	state Exp;
branches;
next	1.119;

1.119
date	2001.06.03.21.40.47;	author guerrand;	state Exp;
branches;
next	1.118;

1.118
date	2001.06.01.02.37.32;	author guerrand;	state Exp;
branches;
next	1.117;

1.117
date	2001.05.27.20.08.19;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2001.05.27.20.06.00;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	2000.10.08.18.30.16;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	2000.09.24.16.31.59;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	2000.09.11.20.27.15;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	2000.09.11.20.07.28;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	2000.09.02.22.55.55;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	2000.08.24.19.23.57;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	2000.05.29.19.43.54;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	2000.05.26.01.46.26;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	2000.05.25.03.06.06;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	2000.05.13.21.55.10;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	2000.04.14.21.24.32;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	2000.04.06.23.45.08;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	2000.04.06.23.43.01;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2000.04.06.23.35.07;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2000.03.23.19.37.14;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2000.03.23.15.16.27;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2000.03.20.22.26.49;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2000.03.15.16.24.50;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	2000.03.06.16.50.19;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	2000.03.06.15.59.19;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	2000.02.27.18.13.43;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	2000.01.21.00.53.18;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	99.12.22.17.11.30;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.12.21.23.07.49;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.12.04.04.34.25;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.11.23.21.44.16;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.11.23.19.52.13;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.11.07.02.04.31;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.11.07.01.37.44;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.11.02.22.08.24;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.11.02.07.51.18;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.10.31.02.23.24;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	99.09.28.23.20.33;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	99.09.16.18.19.53;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	99.08.23.19.19.23;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	99.08.23.03.34.42;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.08.21.21.22.46;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.08.13.18.48.32;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	99.08.12.01.03.56;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	99.08.11.05.27.32;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	99.07.24.07.06.32;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	99.07.24.06.55.25;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	99.07.24.06.24.27;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	99.07.24.06.03.32;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	99.07.24.05.55.04;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	99.07.24.05.49.04;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	99.07.24.05.28.51;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	99.07.24.05.14.54;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	99.07.24.04.59.56;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	99.07.21.15.18.06;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	99.07.21.15.15.36;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	99.07.21.07.10.39;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	99.07.21.06.31.53;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	99.07.21.06.23.07;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.07.21.06.16.57;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.07.21.06.06.08;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.07.21.06.01.38;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.07.21.05.57.14;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.07.21.05.53.42;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.07.21.05.48.36;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.07.21.05.45.38;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.07.21.05.42.35;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.07.21.05.37.28;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.07.21.05.31.20;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.07.21.05.05.28;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.07.21.03.47.32;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.07.21.03.41.34;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.07.14.18.13.33;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.07.13.07.02.10;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.07.13.06.59.35;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.07.13.06.53.26;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.07.13.06.49.49;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.07.13.04.51.47;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.07.13.02.27.54;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.07.13.02.25.13;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	99.07.13.02.21.46;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.07.12.20.49.41;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.07.12.05.13.58;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.07.12.03.59.00;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	99.07.12.03.14.56;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.07.12.02.49.17;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	99.06.20.20.29.22;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.05.26.17.58.34;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	99.05.26.03.27.30;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	99.05.12.22.19.47;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	99.05.12.22.18.05;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	99.05.12.22.16.52;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	99.05.12.22.06.03;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	99.03.24.23.22.54;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	99.03.15.17.36.14;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	99.03.14.16.56.25;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	99.01.12.20.24.27;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.12.23.16.51.32;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.12.15.22.17.21;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.12.12.01.20.53;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.12.09.00.33.19;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.12.08.23.12.08;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.12.08.01.54.11;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.12.05.21.44.04;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.11.28.07.49.32;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.11.22.10.36.35;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.11.22.08.04.43;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.11.22.02.05.13;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.11.20.15.34.37;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.10.20.00.42.30;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.10.05.09.10.25;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.10.05.06.17.40;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.30.03.33.34;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.20.21.05.30;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.17.20.05.00;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.10.19.41.21;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.10.05.32.14;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.07.20.19.56;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.05.08.14.34;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.18;	author mud;	state Exp;
branches;
next	;


desc
@@


1.186
log
@adding cone of silence stuff
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: db.c,v 1.185 2004/08/01 16:33:02 boogums Exp $";
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <math.h>
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#endif

#include "gc.h"
#include "merc.h"
#include "db.h"
#include "recycle.h"
#include "music.h"
#include "lookup.h"
#include "gladiator.h"

/* a test to see if this acually works */
#define calloc(m,n) GC_MALLOC((m)*(n))

#if defined(unix)
extern int getrlimit(int resource, struct rlimit *rlp);
/*extern int setrlimit(int resource, struct rlimit *rlp);*/
#endif

#if !defined(macintosh)
extern  int _filbuf   args( (FILE *) );
#endif

#if !defined(OLD_RAND)
long random();
/*void srandom(int seed);*/
int getpid();
time_t time(time_t *tloc);
#endif


/* externals for counting purposes */
extern  OBJ_DATA  *obj_free;
extern  CHAR_DATA *char_free;
extern  DESCRIPTOR_DATA *descriptor_free;
extern  PC_DATA   *pcdata_free;
extern  AFFECT_DATA *affect_free;

/*
 * Globals.
 */
RECIPE_DATA * recipe_first;
RECIPE_DATA * recipe_last;

CSTAT_DATA *  cstat_first;
CSTAT_DATA *  cstat_last;

HELP_DATA *   help_first;
HELP_DATA *   help_last;

SHOP_DATA *   shop_first;
SHOP_DATA *   shop_last;

NOTE_DATA *   note_free;

char      bug_buf   [2*MAX_INPUT_LENGTH];
char      dns_buf   [20];
CHAR_DATA *   char_list;
char *      help_greeting;
char      log_buf   [2*MAX_INPUT_LENGTH];
KILL_DATA   kill_table  [MAX_LEVEL];
NOTE_DATA *   note_list;
OBJ_DATA *    object_list;
TIME_INFO_DATA    time_info;
WEATHER_DATA    weather_info;
int	weapons_popped = 0;
GLADIATOR_INFO_DATA    gladiator_info;
sh_int		gsn_arcantic_lethargy;
sh_int		gsn_arcantic_alacrity;
sh_int		gsn_clarity;
sh_int		gsn_midnight_cloak;
sh_int		gsn_shield_of_thorns;
sh_int          gsn_spell_restrain;
sh_int		gsn_shield_of_brambles;
sh_int		gsn_shield_of_spikes;
sh_int		gsn_shield_of_blades;
sh_int		gsn_herbalism;
sh_int		gsn_spirit_of_boar;
sh_int		gsn_spirit_of_bear;
sh_int		gsn_spirit_of_cat;
sh_int		gsn_spirit_of_owl;
sh_int		gsn_spirit_of_wolf;
sh_int		gsn_stone_skin;
sh_int		gsn_symbol_1;
sh_int		gsn_symbol_2;
sh_int		gsn_symbol_3;
sh_int		gsn_symbol_4;
sh_int		gsn_hamstring;
sh_int		gsn_acclimate;
sh_int          gsn_honor_guard;
sh_int		gsn_enhanced_critical;
sh_int		gsn_cleave;
sh_int		gsn_bludgeon;
sh_int		gsn_steel_skin;
sh_int		gsn_diamond_skin;
sh_int		gsn_adamantite_skin;
sh_int		gsn_shield_of_faith;
sh_int		gsn_alchemy;
sh_int		gsn_annointment;
sh_int          gsn_aura_of_valor;
sh_int		gsn_riding;
sh_int		gsn_bladesong;
sh_int		gsn_rage;
sh_int		gsn_cutpurse;
sh_int		gsn_garotte;
sh_int		gsn_espionage;
sh_int		gsn_dust_storm;
sh_int		gsn_holy_chant;
sh_int		gsn_ninjitsu;
sh_int		gsn_kurijitsu;
sh_int		gsn_imbue;
sh_int		gsn_endurance;
sh_int		gsn_barbarian_rage;
sh_int		gsn_forget;
sh_int		gsn_focus;
sh_int		gsn_enervation;
sh_int		gsn_fumble;
sh_int		gsn_blur;
sh_int		gsn_spellcraft;
sh_int		gsn_sacred_guardian;
sh_int		gsn_dual_wield;
sh_int		gsn_infiltrate;
sh_int		gsn_tumbling;
sh_int      gsn_connive;
sh_int	    gsn_dae_tok;
sh_int      gsn_backstab;
sh_int      gsn_dodge;
sh_int      gsn_envenom;
sh_int      gsn_hide;
sh_int      gsn_peek;
sh_int      gsn_pick_lock;
sh_int      gsn_sneak;
sh_int      gsn_scan;
sh_int	    gsn_slice;
/* Line Below Added 29-AUG-00 by Boogums */
sh_int      gsn_kcharge;
sh_int      gsn_scribe;
sh_int      gsn_infuse;
sh_int      gsn_endow;
/* 2  Lines Below Added 23SEP00 by Boogums */
sh_int      gsn_call_mount;
sh_int      gsn_charm_animal;
/* Line below added 07OCT00 by Boogums */
sh_int      gsn_sharpen;
sh_int      gsn_swarm;
sh_int      gsn_steal;
sh_int      gsn_snatch;
sh_int	    gsn_trap;

sh_int      gsn_disarm;
sh_int      gsn_enhanced_damage;
sh_int      gsn_kick;
sh_int      gsn_parry;
sh_int      gsn_rescue;
sh_int      gsn_second_attack;
sh_int      gsn_third_attack;
sh_int		gsn_fourth_attack;

sh_int      gsn_blindness;
sh_int      gsn_charm_person;
sh_int      gsn_curse;
sh_int      gsn_invis;
sh_int      gsn_mass_invis;
sh_int      gsn_poison;
sh_int      gsn_plague;
sh_int      gsn_sleep;
sh_int      gsn_sanctuary;
sh_int      gsn_fly;
/* new gsns */

sh_int      gsn_axe;
sh_int      gsn_dagger;
sh_int      gsn_flail;
sh_int      gsn_mace;
sh_int      gsn_polearm;
sh_int      gsn_shield_block;
sh_int      gsn_spear;
sh_int      gsn_sword;
sh_int      gsn_whip;
sh_int      gsn_cuffs_of_justice;
 
sh_int      gsn_bash;
sh_int      gsn_grab;
sh_int      gsn_berserk;
sh_int	    gsn_bite;
sh_int	    gsn_bleed;
sh_int	    gsn_breathe;
sh_int      gsn_dirt;
sh_int	    gsn_fear;
sh_int      gsn_hand_to_hand;
sh_int	    gsn_hex;
sh_int      gsn_trip;
 
sh_int      gsn_fast_healing;
sh_int      gsn_haggle;
sh_int      gsn_lore;
sh_int      gsn_meditation;
sh_int      gsn_morph;
sh_int	    gsn_communion;
sh_int		gsn_nethermancy;
sh_int          gsn_nether_shield;
sh_int		gsn_magic_resistance;
sh_int		gsn_fade;
sh_int		gsn_vision;
sh_int      gsn_scrolls;
sh_int      gsn_staves;
sh_int      gsn_wands;
sh_int      gsn_swim;
sh_int      gsn_recall;
sh_int      gsn_chi;
sh_int      gsn_throw;
sh_int      gsn_kailindo;
sh_int      gsn_weave_resistance;
sh_int      gsn_insanity;
sh_int      gsn_vorpal;
sh_int	    gsn_wound_transfer;
sh_int	    gsn_protect_neutral;
sh_int	    gsn_water_breathing;
sh_int	    gsn_stonefist;
sh_int	    gsn_earthbind;
sh_int	    gsn_irradiate;
sh_int	    gsn_asphyxiate;
sh_int      gsn_confusion;
sh_int      gsn_cone_of_silence;
sh_int      gsn_blade_barrier;
sh_int	    gsn_wall_fire;
sh_int      gsn_wall_ice;
sh_int      gsn_hydrophilia;
sh_int      gsn_stalk;


/*
 * Locals.
 */
MOB_INDEX_DATA *  mob_index_hash    [MAX_KEY_HASH];
OBJ_INDEX_DATA *  obj_index_hash    [MAX_KEY_HASH];
ROOM_INDEX_DATA * room_index_hash   [MAX_KEY_HASH];
char *        string_hash       [MAX_KEY_HASH]; 

AREA_DATA *   area_first;
AREA_DATA *   area_last;

char *      string_space;
char *      top_string;
char      str_empty [1];

int     top_affect;
int     top_area;
int     top_cstat;
int     top_ed;
int     top_exit;
int     top_help;
int     top_recipe;
int     top_mob_index;
int     top_obj_index;
int     top_reset;
int     top_room;
int     top_shop;
int     mobile_count = 0;
int     newmobs = 0;
int     newobjs = 0;
long    temp_mem_count = 0;
long    perm_mem_count = 0;


/*
 * Memory management.
 * Increase MAX_STRING if you have too.
 * Tune the others only if you understand what you're doing.
 */
#define     MAX_STRING  4500000
#define     MAX_PERM_BLOCK  131072
#define     MAX_MEM_LIST  12

void *      rgFreeList  [MAX_MEM_LIST];
const long   rgSizeList  [MAX_MEM_LIST]  =
{
    16, 32, 64, 128, 256, 1024, 2048, 4096, 8192, 16384, 32768, 65536-64
};

int     nAllocString;
int     sAllocString;
int     nAllocPerm;
int     sAllocPerm;



/*
 * Semi-locals.
 */
bool      fBootDb;
FILE *      fpArea;
char      strArea[MAX_INPUT_LENGTH];



/*
 * Local booting procedures.
*/
void    init_mm         args( ( void ) );
void  load_area args( ( FILE *fp, char *file_name ) );
void  load_cstat  args( ( FILE *fp ) );
void  load_helps  args( ( FILE *fp ) );
void  load_old_mob  args( ( FILE *fp ) );
void  load_mobiles  args( ( FILE *fp ) );
void  load_old_obj  args( ( FILE *fp ) );
void  load_objects  args( ( FILE *fp ) );
void  load_recipes args( ( FILE *fp )  );
void  load_resets args( ( FILE *fp ) );
void  load_rooms  args( ( FILE *fp ) );
void  load_shops  args( ( FILE *fp ) );
void  load_socials  args( ( FILE *fp ) );
void  load_specials args( ( FILE *fp ) );
void  load_notes  args( ( void ) );
void  load_bans args( ( void ) );
void  load_dns args( ( void ) );

void  fix_exits args( ( void ) );

void  reset_area  args( ( AREA_DATA * pArea ) );

#if defined(unix)
/* RT max open files fix */
 
void maxfilelimit()
{
    struct rlimit r;
 
    getrlimit(RLIMIT_NOFILE, &r);
    r.rlim_cur = r.rlim_max;
    setrlimit(RLIMIT_NOFILE, &r);
}
#endif

AREA_NAME_DATA *area_name_first,*area_name_last;

void rename_area (char *strArea)
{
  char buf2[MAX_STRING_LENGTH],
       strBak[MAX_STRING_LENGTH],
       sbuf[MAX_STRING_LENGTH];
  char *pstr,*pstr2;
  FILE *fp;
  char *strtime;
  
  fp = fopen(strArea,"r");
  if (fp != NULL) {    /* if the file exists, rename it */
    fclose (fp);
    strcpy (buf2,strArea);
    pstr = buf2;
    pstr2 = NULL;
    while (pstr) {
      pstr2 = ++pstr;
      pstr = strchr (pstr,'.');
    }
    if (pstr2) *pstr2 = (char)NULL;
    strcat (buf2,"old");
    fp = fopen (buf2,"r");
    if (fp != NULL) {
      fclose (fp);
      unlink (buf2);
    }
    rename (strArea,buf2);
    sprintf (sbuf,"Renaming '%s' as '%s'.",strArea,buf2);
    log_string (sbuf);    
  }
  
  strcpy (strBak,strArea);
  pstr = strBak;
  pstr2 = NULL;
  while (pstr) {
    pstr2 = ++pstr;
    pstr = strchr (pstr,'.');
  }  
  if (pstr2) *pstr2 = (char)NULL;
  strcat (strBak,"bak");  
  
  fp = fopen (strArea,"r");
  if (fp != NULL) {
    fclose (fp);
    unlink (strArea);
    sprintf (sbuf,"Deleting '%s'",strArea);
    log_string (sbuf);
  }
  
  fp = fopen (strBak,"r");
  if (fp != NULL) {
    fclose (fp);
  
    rename (strBak,strArea);
    sprintf (sbuf,"Renaming '%s' as '%s'.\n",strBak,strArea);
    log_string (sbuf);
  } else {
    log_string ("Could not find backup to recopy over.");
  }
  
  strtime       = ctime( &current_time );
  strtime[strlen(strtime)-1]  = '\0';  
  
  if (fpReserve) fclose(fpReserve);
  if ( ( fp = fopen( NOTE_FILE, "a" ) ) == NULL ) {
    perror (NOTE_FILE);
  } else {  
    fprintf( fp, "Sender  MHS II~\n" );
    fprintf( fp, "Date    %s~\n", strtime );
    fprintf( fp, "Stamp   %ld\n", current_time );
    fprintf( fp, "To      immortal~\n" );
    fprintf( fp, "Subject Failed to boot '%s'~\n", strArea );
    fprintf( fp, "Text\n" );
    fprintf( fp, "Renamed '%s' as '%s'\n",strArea,buf2 );
    fprintf( fp, "If backup existed, '%s' was replaced.\n",strArea );
    fprintf( fp, "\nMHS\n~\n" );
    fclose ( fp );
  }  
  
  fpReserve = fopen( NULL_FILE, "r" );
  
  

}

void boot_db( void )
{
  /* needed to keep track of area file names */
  /* help.are and a few others don't have an AREA_DATA */
  AREA_NAME_DATA *area_name;
  char buf[MAX_STRING_LENGTH];

#if defined(unix)
    /* open file fix */
    maxfilelimit();
#endif

    /*
     * Init some data space stuff.
     */
    {
#ifdef GAME_VERSION
  if ( ( string_space = calloc( 1, MAX_STRING ) ) == NULL )
#else
  if ( ( string_space = GC_MALLOC( MAX_STRING ) ) == NULL )
#endif
  {
      bug( "Boot_db: can't alloc %d string space.", MAX_STRING );
      exit( 1 );
  }
  top_string  = string_space;
  fBootDb   = TRUE;
    }    

 sprintf(log_buf,"here1 ");  

    /*
     * Init random number generator.
     */
    {
        init_mm( );
    }

    /*
     * Set time and weather.
     */
    {
  long lhour, lday, lmonth;

  lhour   = (current_time - 650336715)
      / (PULSE_TICK / PULSE_PER_SECOND);
  time_info.hour  = lhour  % 24;
  lday    = lhour  / 24;
  time_info.day = lday   % 35;
  lmonth    = lday   / 35;
  time_info.month = lmonth % 17;
  time_info.year  = lmonth / 17;

       if ( time_info.hour <  5 ) weather_info.sunlight = SUN_DARK;
  else if ( time_info.hour <  6 ) weather_info.sunlight = SUN_RISE;
  else if ( time_info.hour < 19 ) weather_info.sunlight = SUN_LIGHT;
  else if ( time_info.hour < 20 ) weather_info.sunlight = SUN_SET;
  else                            weather_info.sunlight = SUN_DARK;

  weather_info.change = 0;
  weather_info.mmhg = 960;
  if ( time_info.month >= 7 && time_info.month <=12 )
      weather_info.mmhg += number_range( 1, 50 );
  else
      weather_info.mmhg += number_range( 1, 80 );

       if ( weather_info.mmhg <=  980 ) weather_info.sky = SKY_LIGHTNING;
  else if ( weather_info.mmhg <= 1000 ) weather_info.sky = SKY_RAINING;
  else if ( weather_info.mmhg <= 1020 ) weather_info.sky = SKY_CLOUDY;
  else                                  weather_info.sky = SKY_CLOUDLESS;

    }

    /* Set Gladiator Settings */
    gladiator_info.started = FALSE;
    gladiator_info.time_left = 0;
    gladiator_info.min_level = 0;
    gladiator_info.max_level = 0;
    gladiator_info.type = 0;
    gladiator_info.playing = 0;
    gladiator_info.team_counter = 0;
    gladiator_info.gladiator_score = 0;
    gladiator_info.barbarian_score = 0;
    gladiator_info.bet_counter = 0;

    /*
     * Assign gsn's for skills which have them.
     */
    {
  int sn;

  for ( sn = 0; sn < MAX_SKILL; sn++ )
  {
      if ( skill_table[sn].pgsn != NULL )
    *skill_table[sn].pgsn = sn;
  }
    }

    /*
     * Read in all the area files.
     */
    {
  FILE *fpList;

  if ( ( fpList = fopen( AREA_LIST, "r" ) ) == NULL )
  {
      perror( AREA_LIST );
      exit( 1 );
  }
  
  area_name_first = NULL;  
    
  for ( ; ; )
  {
    int min_vnum;
    
      strcpy( strArea, fread_word( fpList ) );
      if ( strArea[0] == '$' )
    break;

      if ( strArea[0] == '-' )
      {
    fpArea = stdin;
      }
      else
      {
    if ( ( fpArea = fopen( strArea, "r" ) ) == NULL )
    {
        perror( strArea );
        sprintf (buf,"Skipping area '%s'",strArea);
        log_string (buf);        
        continue;
    }
      }      
     
#ifdef OLC_VERSION
      area_name = alloc_perm (sizeof (AREA_NAME_DATA));
#else /*game version*/
      area_name = GC_MALLOC (sizeof (AREA_NAME_DATA));
#endif
      area_name->name = str_dup (strArea);
      if (!area_name_first) {
        area_name_first = area_name_last = area_name;
      } else {
        area_name_last->next = area_name;
        area_name->next = NULL;
        area_name_last  = area_name;
      }      

      for ( ; ; )
      {
    char *word;

    if ( fread_letter( fpArea ) != '#' )
    {
        bug( "Boot_db: # not found.", 0 );
        if ( fpArea != stdin )
          fclose( fpArea );
        fpArea = NULL;
        rename_area (strArea);        
        exit( 1 );
    }

    word = fread_word( fpArea );

         if ( word[0] == '$'               )                 break;
    else if ( !str_cmp( word, "AREA"     ) ) load_area    (fpArea,strArea);
    else if ( !str_cmp( word, "CSTAT"    ) ) load_cstat   (fpArea);
    else if ( !str_cmp( word, "HELPS"    ) ) load_helps   (fpArea);
    else if ( !str_cmp( word, "MOBOLD"   ) ) load_old_mob (fpArea);
    else if ( !str_cmp( word, "MOBILES"  ) ) load_mobiles (fpArea);
    else if ( !str_cmp( word, "OBJOLD"   ) ) load_old_obj (fpArea);
      else if ( !str_cmp( word, "OBJECTS"  ) ) load_objects (fpArea);
    else if ( !str_cmp( word, "RESETS"   ) ) load_resets  (fpArea);
    else if ( !str_cmp( word, "RECIPES"  ) ) load_recipes (fpArea);
    else if ( !str_cmp( word, "ROOMS"    ) ) load_rooms   (fpArea);
    else if ( !str_cmp( word, "SHOPS"    ) ) load_shops   (fpArea);
    else if ( !str_cmp( word, "SOCIALS"  ) ) load_socials (fpArea);
    else if ( !str_cmp( word, "SPECIALS" ) ) load_specials(fpArea);
    else
    {
        bug( "Boot_db: bad section name.", 0 );
        if ( fpArea != stdin )
          fclose( fpArea );
        fpArea = NULL;
        rename_area (strArea);                
        exit( 1 );
    }
      }

      if ( fpArea != stdin )
        fclose( fpArea );
      fpArea = NULL;
      min_vnum = get_area_min_vnum (area_last);
      if (!area_last->min_vnum_room) area_last->min_vnum_room = min_vnum;
      if (!area_last->max_vnum_room) area_last->max_vnum_room = min_vnum;
      if (!area_last->min_vnum_obj)  area_last->min_vnum_obj  = min_vnum;
      if (!area_last->max_vnum_obj)  area_last->max_vnum_obj  = min_vnum;
      if (!area_last->min_vnum_mob)  area_last->min_vnum_mob  = min_vnum;
      if (!area_last->max_vnum_mob)  area_last->max_vnum_mob  = min_vnum;
        
  }
  fclose( fpList );
    }

  area_last = NULL;

    /*
     * Fix up exits.
     * Declare db booting over.
     * Reset all areas once.
     * Load up the songs, notes and ban files.
     */
    {
  fix_exits( );
  fBootDb = FALSE;
  area_update( );
  load_notes( );
  load_bans();
  load_dns();
  /* load_songs(); */
    }

    return;
}



/*
 * Snarf an 'area' header line.
 */
void load_area( FILE *fp, char *file_name )
{
    AREA_DATA *pArea,*temp_last;     

#ifdef OLC_VERSION
    pArea   = alloc_perm( sizeof(*pArea) );
#else /*game version*/
    pArea   = GC_MALLOC( sizeof(*pArea) );    
#endif
    temp_last = area_last;
    area_last = pArea;
    pArea->file_name     = str_dup (file_name); 
    pArea->reset_first  = NULL;
    pArea->reset_last = NULL;
    fread_string(fp);
    pArea->name   = fread_string( fp );
    pArea->credits  = fread_string( fp );
    fread_number(fp);
    fread_number(fp);
    pArea->age    = 100;
    pArea->nplayer  = 0;
    pArea->empty  = FALSE;
    pArea->min_vnum_room = 
    pArea->max_vnum_room = 
    pArea->min_vnum_obj  = 
    pArea->max_vnum_obj  =     
    pArea->min_vnum_mob  = 
    pArea->max_vnum_mob  = 0;
    pArea->freeze        = FALSE;
    pArea->new_area      = FALSE;
    pArea->under_develop = (strstr (file_name,"newareas") != NULL);
    pArea->no_transport	 = FALSE;

    if ( area_first == NULL )
  area_first = pArea;
    if ( temp_last  != NULL )
  temp_last->next = pArea;
    
    pArea->next = NULL;
    top_area++;
    return;
}

/*
 * Snarf a clan stat section.
 */
void load_cstat( FILE *fp )
{
    CSTAT_DATA *cstat;
    char buf[MAX_STRING_LENGTH];
    char *word;

    for ( ; ; )
    {
#ifdef OLC_VERSION
       cstat   = alloc_perm( sizeof(*cstat) );
#else /*game version*/
       cstat   = GC_MALLOC( sizeof(*cstat) );
#endif

       word = fread_word(fp);
       if ( word[0] == '$' )
          break;
       cstat->clan = clan_lookup(word);
       cstat->kills = fread_number ( fp );

 sprintf(buf,"Cstat: %d kills %d",cstat->clan,cstat->kills);
 log_string(buf);

      if (cstat_first == NULL)
          cstat_first = cstat;
       if (cstat_last  != NULL )
          cstat_last->next = cstat;

       cstat_last = cstat;
       cstat->next = NULL;

       top_cstat++;
    }
    return;
}

void load_recipes( FILE *fp)
{
	RECIPE_DATA *recipe;
 	int i, num;
 	char test;
	
	for ( ; ; )
	{
#ifdef OLC_VERSION
		recipe = alloc_perm ( sizeof (*recipe));
#else
		recipe = GC_MALLOC( sizeof (*recipe) );
#endif
		test = fread_letter(fp);
		if (test == '$')
			break;
	
		recipe->recipe_num = fread_number(fp);
	        recipe->skill_sn = skill_lookup( fread_word(fp) );
		recipe->difficulty = fread_number(fp);
		recipe->vnum_container = fread_number(fp);
		recipe->vnum_complete = fread_number(fp);
		for ( i = 0 ; i < MAX_IN_RECIPE ; i++ )
		{
			num = fread_number(fp);
			if (num != 0 )
				recipe->vnum_parts[i] = num;
			else
				break;
		}

                if (recipe_first == NULL)
                     recipe_first = recipe;
                if (recipe_last  != NULL )
                   recipe_last->next = recipe;

                recipe_last = recipe;
		recipe->next = NULL;
		
		top_recipe++;
	}
	return;
}
/*
 * Snarf a help section.
 */
void load_helps( FILE *fp )
{
    HELP_DATA *pHelp;

    for ( ; ; )
    {
#ifdef OLC_VERSION
  pHelp   = alloc_perm( sizeof(*pHelp) );
#else /*game version*/
  pHelp   = GC_MALLOC( sizeof(*pHelp) );
#endif
  pHelp->level  = fread_number( fp );
  pHelp->keyword  = fread_string( fp );
  if ( pHelp->keyword[0] == '$' )
      break;
  pHelp->text = fread_string( fp );

  if ( !str_cmp( pHelp->keyword, "greeting" ) )
      help_greeting = pHelp->text;

  if ( help_first == NULL )
      help_first = pHelp;
  if ( help_last  != NULL )
      help_last->next = pHelp;

  help_last = pHelp;
  pHelp->next = NULL;
  top_help++;
    }

    return;
}



/*
 * Snarf a mob section.  old style 
 */
void load_old_mob( FILE *fp )
{
    MOB_INDEX_DATA *pMobIndex;
    /* for race updating */
    int race;
    char name[MAX_STRING_LENGTH];

    for ( ; ; )
    {
  sh_int vnum;
  char letter;
  int iHash;

  letter        = fread_letter( fp );
  if ( letter != '#' )
  {
      bug( "Load_old_mobiles: # not found.", 0 );
      if ( fp != stdin ) fclose( fp );
      fp = NULL;
      if (area_last)
        rename_area (area_last->file_name);              
      exit( 1 );
  }

  vnum        = fread_number( fp );
  if ( vnum == 0 )
      break;

  fBootDb = FALSE;
  if ( get_mob_index( vnum ) != NULL )
  {
      bug( "Load_old_mobiles: vnum %d duplicated.", vnum );
      if ( fp != stdin ) fclose( fp );
      fp = NULL; 
      if (area_last)
        rename_area (area_last->file_name);                    
      exit( 1 );
  }
  fBootDb = TRUE;
  
  if (area_last->min_vnum_mob == 0) {
    area_last->min_vnum_mob = vnum;
    area_last->max_vnum_mob = vnum;  
  } else {  
    if (vnum > area_last->max_vnum_mob)
      area_last->max_vnum_mob = vnum;
    if (vnum < area_last->min_vnum_mob)
      area_last->min_vnum_mob = vnum;
  }  

#ifdef OLC_VERSION
  pMobIndex     = alloc_perm( sizeof(*pMobIndex) );
#else /*game version*/
  pMobIndex     = GC_MALLOC( sizeof(*pMobIndex) );
#endif
  pMobIndex->vnum     = vnum;
  pMobIndex->new_format   = FALSE;
  pMobIndex->player_name    = fread_string( fp );
  pMobIndex->short_descr    = fread_string( fp );
  pMobIndex->long_descr   = fread_string( fp );
  pMobIndex->description    = fread_string( fp );

  pMobIndex->long_descr[0]  = UPPER(pMobIndex->long_descr[0]);
  pMobIndex->description[0] = UPPER(pMobIndex->description[0]);

  pMobIndex->act      = fread_flag( fp ) | ACT_IS_NPC;
  pMobIndex->affected_by    = fread_flag( fp );
  pMobIndex->pShop    = NULL;
  pMobIndex->alignment    = fread_number( fp );
  letter        = fread_letter( fp );
  pMobIndex->level    = fread_number( fp );

  /*
   * The unused stuff is for imps who want to use the old-style
   * stats-in-files method.
   */
            fread_number( fp ); /* Unused */
            fread_number( fp ); /* Unused */
            fread_number( fp ); /* Unused */
  /* 'd'    */      fread_letter( fp ); /* Unused */
            fread_number( fp ); /* Unused */
  /* '+'    */      fread_letter( fp ); /* Unused */
            fread_number( fp ); /* Unused */
            fread_number( fp ); /* Unused */
  /* 'd'    */      fread_letter( fp ); /* Unused */
            fread_number( fp ); /* Unused */
  /* '+'    */      fread_letter( fp ); /* Unused */
            fread_number( fp ); /* Unused */
        pMobIndex->wealth               = fread_number( fp )/20;  
  /* xp can't be used! */     fread_number( fp ); /* Unused */
  pMobIndex->start_pos    = fread_number( fp ); /* Unused */
  pMobIndex->default_pos    = fread_number( fp ); /* Unused */

    if (pMobIndex->start_pos < POS_SLEEPING)
      pMobIndex->start_pos = POS_STANDING;
  if (pMobIndex->default_pos < POS_SLEEPING)
      pMobIndex->default_pos = POS_STANDING;

  /*
   * Back to meaningful values.
   */
  pMobIndex->sex      = fread_number( fp );

      /* compute the race BS */
    one_argument(pMobIndex->player_name,name);
 
    if (name[0] == '\0' || (race =  race_lookup(name)) == 0)
    {
            /* fill in with blanks */
            pMobIndex->race = race_lookup("human");
            pMobIndex->off_flags = OFF_DODGE|OFF_DISARM|OFF_TRIP|ASSIST_VNUM;
            pMobIndex->imm_flags = 0;
            pMobIndex->res_flags = 0;
            pMobIndex->vuln_flags = 0;
            pMobIndex->form = FORM_EDIBLE|FORM_SENTIENT|FORM_BIPED|FORM_MAMMAL;
            pMobIndex->parts = PART_HEAD|PART_ARMS|PART_LEGS|PART_HEART|
                               PART_BRAINS|PART_GUTS;
      }
      else
      {
            pMobIndex->race = race;
            pMobIndex->off_flags = OFF_DODGE|OFF_DISARM|OFF_TRIP|ASSIST_RACE|
                                   race_table[race].off;
            pMobIndex->imm_flags = race_table[race].imm;
            pMobIndex->res_flags = race_table[race].res;
            pMobIndex->vuln_flags = race_table[race].vuln;
            pMobIndex->form = race_table[race].form;
            pMobIndex->parts = race_table[race].parts;
      }

  if ( letter != 'S' )
  {
      bug( "Load_old_mobiles: vnum %d non-S.", vnum );
      if ( fp != stdin ) fclose( fp );
      fp = NULL; 
      if (area_last)
        rename_area (area_last->file_name);                    
      exit( 1 );
  }

  iHash     = vnum % MAX_KEY_HASH;
  pMobIndex->next   = mob_index_hash[iHash];
  mob_index_hash[iHash] = pMobIndex;
  top_mob_index++;
  kill_table[URANGE(0, pMobIndex->level, MAX_LEVEL-1)].number++;
    }

    return;
}

/*
 * Snarf an obj section.  old style 
 */
void load_old_obj( FILE *fp )
{
    OBJ_INDEX_DATA *pObjIndex;

    for ( ; ; )
    {
  sh_int vnum;
  char letter;
  int iHash;

  letter        = fread_letter( fp );
  if ( letter != '#' )
  {
      bug( "Load_objects: # not found.", 0 );
      if ( fp != stdin ) fclose( fp );
      fp = NULL; 
      if (area_last)
        rename_area (area_last->file_name);                    
      exit( 1 );
  }

  vnum        = fread_number( fp );
  if ( vnum == 0 )
      break;

  fBootDb = FALSE;
  if ( get_obj_index( vnum ) != NULL )
  {
      bug( "Load_objects: vnum %d duplicated.", vnum );
      if ( fp != stdin ) fclose( fp );
      fp = NULL; 
      if (area_last)
        rename_area (area_last->file_name);                    
      exit( 1 );
  }
  fBootDb = TRUE;
  
  if (area_last->min_vnum_obj == 0) {
    area_last->min_vnum_obj = vnum;
    area_last->max_vnum_obj = vnum;  
  } else {  
    if (vnum > area_last->max_vnum_obj)
      area_last->max_vnum_obj = vnum;
    if (vnum < area_last->min_vnum_obj)
      area_last->min_vnum_obj = vnum;
  }    

#ifdef OLC_VERSION
  pObjIndex     = alloc_perm( sizeof(*pObjIndex) );
#else /*game version*/
  pObjIndex     = GC_MALLOC( sizeof(*pObjIndex) );
#endif
  pObjIndex->vnum     = vnum;
  pObjIndex->new_format   = FALSE;
  pObjIndex->reset_num    = 0;
  pObjIndex->name     = fread_string( fp );
  pObjIndex->short_descr    = fread_string( fp );
  pObjIndex->description    = fread_string( fp );
  /* Action description */    fread_string( fp );

  pObjIndex->short_descr[0] = LOWER(pObjIndex->short_descr[0]);
  pObjIndex->description[0] = UPPER(pObjIndex->description[0]);
  pObjIndex->material   = str_dup("");

  pObjIndex->item_type    = fread_number( fp );
  pObjIndex->extra_flags    = fread_flag( fp );
  pObjIndex->wear_flags   = fread_flag( fp );
  pObjIndex->value[0]   = fread_number( fp );
  pObjIndex->value[1]   = fread_number( fp );
  pObjIndex->value[2]   = fread_number( fp );
  pObjIndex->value[3]   = fread_number( fp );
  pObjIndex->value[4]   = 0;
  pObjIndex->level    = 0;
  pObjIndex->condition    = 100;
  pObjIndex->weight   = fread_number( fp );
  pObjIndex->cost     = fread_number( fp ); /* Unused */
  /* Cost per day */      fread_number( fp );


  if (pObjIndex->item_type == ITEM_WEAPON)
  {
      if (is_name("two",pObjIndex->name) 
      ||  is_name("two-handed",pObjIndex->name) 
      ||  is_name("claymore",pObjIndex->name))
    SET_BIT(pObjIndex->value[4],WEAPON_TWO_HANDS);
  }

  for ( ; ; )
  {
      char letter;

      letter = fread_letter( fp );

      if ( letter == 'A' )
      {
    AFFECT_DATA *paf;

#ifdef OLC_VERSION
    paf     = alloc_perm( sizeof(*paf) );
#else
    paf     = GC_MALLOC( sizeof(*paf) );
#endif
    paf->where    = TO_OBJECT;
    paf->type   = -1;
    paf->level    = 20; /* RT temp fix */
    paf->duration   = -1;
    paf->location   = fread_number( fp );
    paf->modifier   = fread_number( fp );
    paf->bitvector    = 0;
    paf->next   = pObjIndex->affected;
    pObjIndex->affected = paf;
    top_affect++;
      }

      else if ( letter == 'E' )
      {
    EXTRA_DESCR_DATA *ed;

#ifdef OLC_VERSION
    ed      = alloc_perm( sizeof(*ed) );
#else
    ed      = GC_MALLOC( sizeof(*ed) );
#endif
    ed->keyword   = fread_string( fp );
    ed->description   = fread_string( fp );
    ed->next    = pObjIndex->extra_descr;
    pObjIndex->extra_descr  = ed;
    top_ed++;
      }

      else
      {
    ungetc( letter, fp );
    break;
      }
  }

        /* fix armors */
        if (pObjIndex->item_type == ITEM_ARMOR)
        {
            pObjIndex->value[1] = pObjIndex->value[0];
            pObjIndex->value[2] = pObjIndex->value[1];
        }

  /*
   * Translate spell "slot numbers" to internal "skill numbers."
   */
  switch ( pObjIndex->item_type )
  {
  case ITEM_PILL:
  case ITEM_POTION:
  case ITEM_SCROLL:
      pObjIndex->value[1] = slot_lookup( pObjIndex->value[1] );
      pObjIndex->value[2] = slot_lookup( pObjIndex->value[2] );
      pObjIndex->value[3] = slot_lookup( pObjIndex->value[3] );
      pObjIndex->value[4] = slot_lookup( pObjIndex->value[4] );
      break;

  case ITEM_STAFF:
  case ITEM_WAND:
      pObjIndex->value[3] = slot_lookup( pObjIndex->value[3] );
      break;
  }

  iHash     = vnum % MAX_KEY_HASH;
  pObjIndex->next   = obj_index_hash[iHash];
  obj_index_hash[iHash] = pObjIndex;
  top_obj_index++;
    }

    return;
}





/*
 * Snarf a reset section.
 */
void load_resets( FILE *fp )
{
    RESET_DATA *pReset;
    bool error_found;

    if ( area_last == NULL )
    {
  bug( "Load_resets: no #AREA seen yet.", 0 );  
  exit( 1 );
    }

    for ( ; ; )
    {
  char letter;

  if ( ( letter = fread_letter( fp ) ) == 'S' )
      break;

  if ( letter == '*' )
  {
      fread_to_eol( fp );
      continue;
  }

#ifdef OLC_VERSION
  pReset    = alloc_perm( sizeof(*pReset) );
#else
  pReset    = GC_MALLOC( sizeof(*pReset) );
#endif
  pReset->command = letter;
  /* if_flag */   fread_number( fp );
  pReset->arg1  = fread_number( fp );
  pReset->arg2  = fread_number( fp );
  pReset->arg3  = (letter == 'G' || letter == 'R')
          ? 0 : fread_number( fp );
  pReset->arg4  = (letter == 'P' || letter == 'M')
          ? fread_number(fp) : 0;
        fread_to_eol( fp );
        
  error_found = FALSE;        
  /*
   * Validate parameters.
   * We're calling the index functions for the side effect.
   */
  switch ( letter )
  {
  default:
      bug( "Load_resets: bad command '%c'.", letter );
      error_found = TRUE;      
      break;
  case 'M':  
  case 'O':
  case 'P':
  case 'G':
  case 'E':
      break; 
  case 'D':
/* This is obsolete *
      if ( pReset->arg3 < 0 || pReset->arg3 > 2 )
      {
    bug( "Load_resets: 'D': bad 'locks': %d.", pReset->arg3 );
    error_found = TRUE;          
      }
 */
      break;
  case 'R':
      if ( pReset->arg2 < 0 || pReset->arg2 > 6 )
      {
    bug( "Load_resets: 'R': bad exit %d.", pReset->arg2 );
    error_found = TRUE;
      }
      break;
  }

  if (!error_found) {
    if ( area_last->reset_first == NULL )
        area_last->reset_first  = pReset;
    if ( area_last->reset_last  != NULL )
        area_last->reset_last->next = pReset;
        
    area_last->reset_last = pReset;
    pReset->next    = NULL;
    top_reset++;
  }
    }

    return;
}



/*
 * Snarf a room section.
 */
void load_rooms( FILE *fp )
{
    ROOM_INDEX_DATA *pRoomIndex;

    if ( area_last == NULL )
    {
  bug( "Load_resets: no #AREA seen yet.", 0 );
  exit( 1 );
    }

    for ( ; ; )
    {
  sh_int vnum;
  char letter;
  int door;
  int iHash;

  letter        = fread_letter( fp );
  if ( letter != '#' )
  {
      bug( "Load_rooms: # not found.", 0 );      
      if ( fp != stdin ) fclose( fp );
      fp = NULL; 
      if (area_last)
        rename_area (area_last->file_name);      
      exit( 1 );
  }

  vnum        = fread_number( fp );
  if ( vnum == 0 )
      break;

  fBootDb = FALSE;
  if ( get_room_index( vnum ) != NULL )
  {
      bug( "Load_rooms: vnum %d duplicated.", vnum );
      if ( fp != stdin ) fclose( fp );
      fp = NULL; 
      if (area_last)
        rename_area (area_last->file_name);              
      exit( 1 );
  }
  fBootDb = TRUE;
  
  if (area_last->min_vnum_room == 0) {
    area_last->min_vnum_room = vnum;
    area_last->max_vnum_room = vnum;  
  } else {  
    if (vnum > area_last->max_vnum_room)
      area_last->max_vnum_room = vnum;
    if (vnum < area_last->min_vnum_room)
      area_last->min_vnum_room = vnum;
  }      

#ifdef OLC_VERSION
  pRoomIndex      = alloc_perm( sizeof(*pRoomIndex) );
#else
  pRoomIndex      = GC_MALLOC( sizeof(*pRoomIndex) );
#endif
  pRoomIndex->owner   = str_dup("");
  pRoomIndex->people    = NULL;
  pRoomIndex->contents    = NULL;
  pRoomIndex->extra_descr   = NULL;
  pRoomIndex->area    = area_last;
  pRoomIndex->vnum    = vnum;
  pRoomIndex->name    = fread_string( fp );
  pRoomIndex->description   = fread_string( fp );
  /* Area number */     fread_number( fp );
  pRoomIndex->room_flags    = fread_flag( fp );
  /* horrible hack */
    if ( 3000 <= vnum && vnum < 3400)
     SET_BIT(pRoomIndex->room_flags,ROOM_LAW);
  pRoomIndex->sector_type   = fread_number( fp );
  pRoomIndex->light   = 0;
  for ( door = 0; door <= 5; door++ )
      pRoomIndex->exit[door] = NULL;

  /* defaults */
  pRoomIndex->heal_rate = 100;
  pRoomIndex->mana_rate = 100;
  pRoomIndex->obs_target = 0;

  for ( ; ; )
  {
      letter = fread_letter( fp );

      if ( letter == 'S' )
    break;

      if ( letter == 'H') /* healing room */
    pRoomIndex->heal_rate = fread_number(fp);
  
      else if ( letter == 'B') /* observation room */
	pRoomIndex->obs_target = fread_number(fp);

      else if ( letter == 'M') /* mana room */
    pRoomIndex->mana_rate = fread_number(fp);

     else if ( letter == 'C') /* clan */
     {
    if (pRoomIndex->clan)
      {
        bug("Load_rooms: duplicate clan fields.",0);        
      }
    pRoomIndex->clan = clan_lookup(fread_string(fp));
      }
  

      else if ( letter == 'D' )
      {
    EXIT_DATA *pexit;
    int locks;

    door = fread_number( fp );
    if ( door < 0 || door > 5 )
    {
        bug( "Fread_rooms: vnum %d has bad door number.", vnum );        
    }

#ifdef OLC_VERSION
    pexit     = alloc_perm( sizeof(*pexit) );
#else
    pexit     = GC_MALLOC( sizeof(*pexit) );
#endif
    		fread_string( fp );
    pexit->keyword    = fread_string( fp );
    pexit->exit_info  = 0;
    locks     = fread_number( fp );
    pexit->key    = fread_number( fp );
    pexit->u1.vnum    = fread_number( fp );

    if (!IS_SET(locks,EX_NEW_FORMAT) )
    {
        switch ( locks ) 
        {
        case 1: pexit->exit_info = EX_ISDOOR;                break;
        case 2: pexit->exit_info = EX_ISDOOR | EX_PICKPROOF; break;
        case 3: pexit->exit_info = EX_ISDOOR | EX_NOPASS;    break;
        case 4: pexit->exit_info = EX_ISDOOR|EX_NOPASS|EX_PICKPROOF;
          break;
        }
    }
    else
	pexit->exit_info = locks;
	
    pRoomIndex->exit[door]  = pexit;    
    top_exit++;
      }
      else if ( letter == 'E' )
      {
    EXTRA_DESCR_DATA *ed;

#ifdef OLC_VERSION
    ed      = alloc_perm( sizeof(*ed) );
#else
    ed      = GC_MALLOC( sizeof(*ed) );
#endif
    ed->keyword   = fread_string( fp );
    ed->description   = fread_string( fp );
    ed->next    = pRoomIndex->extra_descr;
    pRoomIndex->extra_descr = ed;
    top_ed++;
      }

      else if (letter == 'O')
      {
    if (pRoomIndex->owner[0] != '\0')
    {
        bug("Load_rooms: duplicate owner.",0);        
    }

    pRoomIndex->owner = fread_string(fp);
      }

      else
      {
    bug( "Load_rooms: vnum %d has flag not 'DES'.", vnum );    
      }
  }

  iHash     = vnum % MAX_KEY_HASH;
  pRoomIndex->next  = room_index_hash[iHash];
  room_index_hash[iHash]  = pRoomIndex;
  top_room++;
    }

    return;
}



/*
 * Snarf a shop section.
 */
void load_shops( FILE *fp )
{
    SHOP_DATA *pShop;

    for ( ; ; )
    {
  MOB_INDEX_DATA *pMobIndex;
  int iTrade;

#ifdef OLC_VERSION
  pShop     = alloc_perm( sizeof(*pShop) );
#else
  pShop     = GC_MALLOC( sizeof(*pShop) );
#endif
  pShop->keeper   = fread_number( fp );
  if ( pShop->keeper == 0 )
      break;
  for ( iTrade = 0; iTrade < MAX_TRADE; iTrade++ )
      pShop->buy_type[iTrade] = fread_number( fp );
  pShop->profit_buy = fread_number( fp );
  pShop->profit_sell  = fread_number( fp );
  pShop->open_hour  = fread_number( fp );
  pShop->close_hour = fread_number( fp );
          fread_to_eol( fp );
  pMobIndex   = get_mob_index( pShop->keeper );
  pMobIndex->pShop  = pShop;

  if ( shop_first == NULL )
      shop_first = pShop;
  if ( shop_last  != NULL )
      shop_last->next = pShop;

  shop_last = pShop;
  pShop->next = NULL;
  top_shop++;
    }

    return;
}


/*
 * Snarf spec proc declarations.
 */
void load_specials( FILE *fp )
{
    for ( ; ; )
    {
  MOB_INDEX_DATA *pMobIndex;
  char letter;

  switch ( letter = fread_letter( fp ) )
  {
  default:
      bug( "Load_specials: letter '%c' not *MS.", letter );
      if ( fp != stdin ) fclose( fp );
      fp = NULL; 
      if (area_last)
        rename_area (area_last->file_name);              
      exit( 1 );

  case 'S':
      return;

  case '*':
      break;

  case 'M':
      pMobIndex   = get_mob_index ( fread_number ( fp ) );
      pMobIndex->spec_fun = spec_lookup ( fread_word   ( fp ) );
      if ( pMobIndex->spec_fun == 0 )
      {
    bug( "Load_specials: 'M': vnum %d.", pMobIndex->vnum );
    if ( fp != stdin ) fclose( fp );
    fp = NULL;
    if (area_last)
      rename_area (area_last->file_name);            
    exit( 1 );
      }
      break;
  }

  fread_to_eol( fp );
    }
}


/*
 * Translate all room exits from virtual to real.
 * Has to be done after all rooms are read in.
 * Check for bad reverse exits.
 */
void fix_exits( void )
{
    /*extern const sh_int rev_dir [];*/
   /* char buf[MAX_STRING_LENGTH];*/
    ROOM_INDEX_DATA *pRoomIndex;
   /* ROOM_INDEX_DATA *to_room; */
    EXIT_DATA *pexit;
   /* EXIT_DATA *pexit_rev; */
    int iHash;
    int door;

    for ( iHash = 0; iHash < MAX_KEY_HASH; iHash++ )
    {
  for ( pRoomIndex  = room_index_hash[iHash];
        pRoomIndex != NULL;
        pRoomIndex  = pRoomIndex->next )
  {
      bool fexit;

      fexit = FALSE;
      for ( door = 0; door <= 5; door++ )
      {
    if ( ( pexit = pRoomIndex->exit[door] ) != NULL )
    {
        if ( pexit->u1.vnum <= 0 
        || get_room_index(pexit->u1.vnum) == NULL) {
      pexit->u1.to_room = NULL;
      pRoomIndex->exit[door] = NULL;
        } else {
      fexit = TRUE; 
      pexit->u1.to_room = get_room_index( pexit->u1.vnum );
        }
    }
      }
      if (!fexit)
    SET_BIT(pRoomIndex->room_flags,ROOM_NO_MOB);
  }
    }

/*
    for ( iHash = 0; iHash < MAX_KEY_HASH; iHash++ )
    {
  for ( pRoomIndex  = room_index_hash[iHash];
        pRoomIndex != NULL;
        pRoomIndex  = pRoomIndex->next )
  {
      for ( door = 0; door <= 5; door++ )
      {
    if ( ( pexit     = pRoomIndex->exit[door]       ) != NULL
    &&   ( to_room   = pexit->u1.to_room            ) != NULL
    &&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
    &&   pexit_rev->u1.to_room != pRoomIndex 
    &&   (pRoomIndex->vnum < 1200 || pRoomIndex->vnum > 1299))
    {
        sprintf( buf, "Fix_exits: %d:%d -> %d:%d -> %d.",
      pRoomIndex->vnum, door,
      to_room->vnum,    rev_dir[door],
      (pexit_rev->u1.to_room == NULL)
          ? 0 : pexit_rev->u1.to_room->vnum );
        bug( buf, 0 );
    }
      }
  }
    }
 */
    return;
}



/*
 * Repopulate areas periodically.
 */
void area_update( void )
{
    AREA_DATA *pArea;
    char buf[MAX_STRING_LENGTH];

    for ( pArea = area_first; pArea != NULL; pArea = pArea->next )
    {

  if ( ++pArea->age < 3 )
      continue;

  /*
   * Check age and reset.
   * Note: Mud School resets every 3 minutes (not 15).
   */
   
  if ( ((!pArea->empty && (pArea->nplayer == 0 || pArea->age >= 15))
  ||    pArea->age >= 31) && !pArea->freeze) 
  {
      ROOM_INDEX_DATA *pRoomIndex;
      ROOM_INDEX_DATA *honorIndex;
      ROOM_INDEX_DATA *posseIndex;
      ROOM_INDEX_DATA *posse2Index;
      ROOM_INDEX_DATA *warlockIndex;
      ROOM_INDEX_DATA *zealotIndex;
      ROOM_INDEX_DATA *zealot2Index;

      reset_area( pArea );
      sprintf(buf,"%s has just been reset.",pArea->name);
      wiznet(buf,NULL,NULL,WIZ_RESETS,0,0);

      pArea->age = number_range( 0, 3 );
      pRoomIndex = get_room_index( ROOM_VNUM_SCHOOL );
      honorIndex = get_room_index( ROOM_VNUM_HONOR_INDEX );
      posseIndex = get_room_index( ROOM_VNUM_POSSE_INDEX );
      posse2Index = get_room_index( 31603 );
      warlockIndex = get_room_index( ROOM_VNUM_WARLOCK_INDEX);
      zealotIndex = get_room_index( ROOM_VNUM_ZEALOT_INDEX );
      zealot2Index = get_room_index( 31806 );


      if (
         (pRoomIndex != NULL && pArea == pRoomIndex->area)
      || (honorIndex != NULL && pArea == honorIndex->area)
      || (posseIndex != NULL && pArea == posseIndex->area)
      || (posse2Index != NULL && pArea == posse2Index->area)
      || (warlockIndex != NULL && pArea == warlockIndex->area)
      || (zealotIndex != NULL && pArea == zealotIndex->area)
      || (zealot2Index != NULL && pArea == zealot2Index->area )
       )
        pArea->age = 15 - 2;
      else if (pArea->nplayer == 0)
        pArea->empty = TRUE;
  }


    }

    return;
}



/*
 * Reset one area.
 */
void reset_area( AREA_DATA *pArea )
{
    RESET_DATA *pReset;
    CHAR_DATA *mob;
    bool last;
    int level;

    mob   = NULL;
    last  = TRUE;
    level = 0;
    for ( pReset = pArea->reset_first; pReset != NULL; pReset = pReset->next )
    {
  ROOM_INDEX_DATA *pRoomIndex;
  MOB_INDEX_DATA *pMobIndex;
  OBJ_INDEX_DATA *pObjIndex;
  OBJ_INDEX_DATA *pObjToIndex;
  EXIT_DATA *pexit;
  OBJ_DATA *obj;
  OBJ_DATA *obj_to;
  int count, limit;

  switch ( pReset->command )
  {
  default:
      bug( "Reset_area: bad command %c.", pReset->command );
      break;

  case 'M':
      if ( ( pMobIndex = get_mob_index( pReset->arg1 ) ) == NULL )
      {
    bug( "Reset_area: 'M': bad vnum %d.", pReset->arg1 );
    continue;
      }

      if ( ( pRoomIndex = get_room_index( pReset->arg3 ) ) == NULL )
      {
    bug( "Reset_area: 'R': bad vnum %d.", pReset->arg3 );
    continue;
      }

      if ( pMobIndex->count >= pReset->arg2 )
      {
    last = FALSE;
    break;
      }

      count = 0;
      for (mob = pRoomIndex->people; mob != NULL; mob = mob->next_in_room)
    if (mob->pIndexData == pMobIndex)
    {
        count++;
        if (count >= pReset->arg4)
        {
          last = FALSE;
          break;
        }
    }

      if (count >= pReset->arg4)
    break;

      mob = create_mobile( pMobIndex );      

      /*
       * Check for pet shop.
       */
      {
    ROOM_INDEX_DATA *pRoomIndexPrev;
    pRoomIndexPrev = get_room_index( pRoomIndex->vnum - 1 );
    if ( pRoomIndexPrev != NULL
    &&   IS_SET(pRoomIndexPrev->room_flags, ROOM_PET_SHOP) )
        SET_BIT(mob->act, ACT_PET);
      }

      /* set area */
      mob->zone = pRoomIndex->area;

      char_to_room( mob, pRoomIndex );
      level = URANGE( 0, mob->level - 2, LEVEL_HERO - 1 );
      last  = TRUE;
      break;

  case 'O':
      if ( ( pObjIndex = get_obj_index( pReset->arg1 ) ) == NULL )
      {
    bug( "Reset_area: 'O': bad vnum %d.", pReset->arg1 );
    continue;
      }

      if ( ( pRoomIndex = get_room_index( pReset->arg3 ) ) == NULL )
      {
    bug( "Reset_area: 'R': bad vnum %d.", pReset->arg3 );
    continue;
      }

      if ( (pArea->nplayer > 0 && !pArea->freeze)
      ||   count_obj_list( pObjIndex, pRoomIndex->contents ) > 0 )
      {
    last = FALSE;
    break;
      }

      if (pReset->arg2 > 50) /* old format */
          limit = 6;
      else if (pReset->arg2 == -1) /* no limit */
          limit = 999;
      else
          limit = pReset->arg2;
      if ( pObjIndex->count >= limit )
      {
	last = FALSE;
	break;
      }

      obj       = create_object( pObjIndex, UMIN(number_fuzzy(level),
                   LEVEL_HERO - 1), TRUE );
      obj->cost = 0;
      obj_to_room( obj, pRoomIndex );
      last = TRUE;
      break;

  case 'P':
      if ( ( pObjIndex = get_obj_index( pReset->arg1 ) ) == NULL )
      {
    bug( "Reset_area: 'P': bad vnum %d.", pReset->arg1 );
    continue;
      }

      if ( ( pObjToIndex = get_obj_index( pReset->arg3 ) ) == NULL )
      {
    bug( "Reset_area: 'P': bad vnum %d.", pReset->arg3 );
    continue;
      }

            if (pReset->arg2 > 50) /* old format */
                limit = 6;
            else if (pReset->arg2 == -1) /* no limit */
                limit = 999;
            else
                limit = pReset->arg2;

      if ((pArea->nplayer > 0  && !pArea->freeze)
      || (obj_to = get_obj_type( pObjToIndex ) ) == NULL
      || (obj_to->in_room == NULL && !last)
      || ( pObjIndex->count >= limit && (number_range(0,2) != 0  && !pArea->freeze))
      || (count = count_obj_list(pObjIndex,obj_to->contains)) 
    > pReset->arg4 )
      {
    last = FALSE;
    break;
      }

      while (count < pReset->arg4)
      {
          obj = create_object( pObjIndex, number_fuzzy(obj_to->level), TRUE );
        obj_to_obj( obj, obj_to );
    count++;
    if (pObjIndex->count >= limit)
        break;
      }
      /* fix object lock state! */
      obj_to->value[1] = obj_to->pIndexData->value[1];
      last = TRUE;
      break;

  case 'G':
  case 'E':
      if ( ( pObjIndex = get_obj_index( pReset->arg1 ) ) == NULL )
      {
    bug( "Reset_area: 'E' or 'G': bad vnum %d.", pReset->arg1 );
    continue;
      }

      if ( !last )
    break;

      if ( mob == NULL )
      {
    bug( "Reset_area: 'E' or 'G': null mob for vnum %d.",
        pReset->arg1 );
    last = FALSE;
    break;
      }

      if ( mob->pIndexData->pShop != NULL )
      {
    int olevel = 0,i,j;

    if (!pObjIndex->new_format)
        switch ( pObjIndex->item_type )
    {
    case ITEM_PILL:
    case ITEM_POTION:
    case ITEM_SCROLL:
        olevel = 53;
        for (i = 1; i < 5; i++)
        {
      if (pObjIndex->value[i] > 0)
      {
              for (j = 0; j < MAX_CLASS; j++)
          {
        olevel = UMIN(olevel,
                 skill_table[pObjIndex->value[i]].
                 skill_level[j]);
          }
      }
        }
       
        olevel = UMAX(0,(olevel * 3 / 4) - 2);
        break;
    case ITEM_WAND:   olevel = number_range( 10, 20 ); break;
    case ITEM_STAFF:  olevel = number_range( 15, 25 ); break;
    case ITEM_ARMOR:  olevel = number_range(  5, 15 ); break;
    case ITEM_WEAPON: olevel = number_range(  5, 15 ); break;
    case ITEM_TREASURE: olevel = number_range( 10, 20 ); break;
    }

    obj = create_object( pObjIndex, olevel, TRUE );
    if( obj->item_type != ITEM_TRASH )
    SET_BIT( obj->extra_flags, ITEM_INVENTORY );
      }

      else
      {
    if (pReset->arg2 > 50) /* old format */
        limit = 6;
    else if (pReset->arg2 == -1) /* no limit */
        limit = 999;
    else
        limit = pReset->arg2;

    if (pObjIndex->count < limit || number_range(0,2) == 0 || pArea->freeze)
    {
        obj=create_object(pObjIndex,UMIN(number_fuzzy(level),
        LEVEL_HERO - 1), TRUE);
        /* error message if it is too high */
/*        if (obj->level > mob->level + 3
        ||  (obj->item_type == ITEM_WEAPON 
        &&   pReset->command == 'E' 
        &&   obj->level < mob->level -5 && obj->level < 45))
      fprintf(stderr,
          "Err: obj %s (%d) -- %d, mob %s (%d) -- %d\n",
          obj->short_descr,obj->pIndexData->vnum,obj->level,
          mob->short_descr,mob->pIndexData->vnum,mob->level); */
    }
    else
        break;
      }
      obj_to_char( obj, mob );
      if ( pReset->command == 'E' )
    equip_char( mob, obj, pReset->arg3 );
      last = TRUE;
      break;

  case 'D':
      if ( ( pRoomIndex = get_room_index( pReset->arg1 ) ) == NULL )
      {
    bug( "Reset_area: 'D': bad vnum %d.", pReset->arg1 );
    continue;
      }

      if ( ( pexit = pRoomIndex->exit[pReset->arg2] ) == NULL )
    break;

    /* may need to convert here */
    if ( IS_SET(pReset->arg3,EX_NEW_FORMAT) )
    	pexit->exit_info = pReset->arg3; /* set up exit flags */
    else
      switch ( pReset->arg3 )
      {
      case 0:
    REMOVE_BIT( pexit->exit_info, EX_CLOSED );
    REMOVE_BIT( pexit->exit_info, EX_LOCKED );
    break;

      case 1:
    SET_BIT(    pexit->exit_info, EX_CLOSED );
    REMOVE_BIT( pexit->exit_info, EX_LOCKED );
    break;

      case 2:
    SET_BIT(    pexit->exit_info, EX_CLOSED );
    SET_BIT(    pexit->exit_info, EX_LOCKED );
    break;
      }

      last = TRUE;
      break;

  case 'R':
      if ( ( pRoomIndex = get_room_index( pReset->arg1 ) ) == NULL )
      {
    bug( "Reset_area: 'R': bad vnum %d.", pReset->arg1 );
    continue;
      }

      {
    int d0;
    int d1;

    for ( d0 = 0; d0 < pReset->arg2 - 1; d0++ )
    {
        d1                   = number_range( d0, pReset->arg2-1 );
        pexit                = pRoomIndex->exit[d0];
        pRoomIndex->exit[d0] = pRoomIndex->exit[d1];
        pRoomIndex->exit[d1] = pexit;
    }
      }
      break; 
  }
    }

    return;
}

void MobIndexToInstance ( CHAR_DATA *mob, MOB_INDEX_DATA *pMobIndex )
{
  int i;
  AFFECT_DATA af;
  
  while ( mob->affected )
    affect_remove( mob, mob->affected, APPLY_PRIMARY);


    mob->pIndexData = pMobIndex;

    mob->name   = pMobIndex->player_name;
    mob->id   = get_mob_id();
    mob->short_descr  = pMobIndex->short_descr;
    mob->long_descr = pMobIndex->long_descr;
    mob->description  = pMobIndex->description;
    mob->spec_fun = pMobIndex->spec_fun;
    mob->prompt   = NULL;

    if (pMobIndex->wealth == 0)
    {
  mob->silver = 0;
  mob->gold   = 0;
    }
    else
    {
  long wealth;

  wealth = number_range(pMobIndex->wealth/2, 3 * pMobIndex->wealth/2);
  mob->gold = number_range(wealth/200,wealth/100);
  mob->silver = wealth - (mob->gold * 100);
    } 

    if (pMobIndex->new_format)
    /* load in new style */
    {
  /* read from prototype */
  mob->group    = pMobIndex->group;
  mob->act    = pMobIndex->act;
  mob->comm   = COMM_NOCHANNELS|COMM_NOSHOUT|COMM_NOTELL;
  mob->affected_by  = pMobIndex->affected_by;
  mob->alignment    = pMobIndex->alignment;
  mob->level    = pMobIndex->level;
  mob->hitroll    = pMobIndex->hitroll;
  mob->damroll    = pMobIndex->damage[DICE_BONUS];
  mob->max_hit    = dice(pMobIndex->hit[DICE_NUMBER],
               pMobIndex->hit[DICE_TYPE])
          + pMobIndex->hit[DICE_BONUS];
  mob->hit    = mob->max_hit;
  mob->max_mana   = dice(pMobIndex->mana[DICE_NUMBER],
               pMobIndex->mana[DICE_TYPE])
          + pMobIndex->mana[DICE_BONUS];
  mob->mana   = mob->max_mana;
  mob->damage[DICE_NUMBER]= pMobIndex->damage[DICE_NUMBER];
  mob->damage[DICE_TYPE]  = pMobIndex->damage[DICE_TYPE];
  mob->dam_type   = pMobIndex->dam_type;
        if (mob->dam_type == 0)
          switch(number_range(1,3))
            {
                case (1): mob->dam_type = 3;        break;  /* slash */
                case (2): mob->dam_type = 7;        break;  /* pound */
                case (3): mob->dam_type = 11;       break;  /* pierce */
            }
  for (i = 0; i < 4; i++)
      mob->armor[i] = pMobIndex->ac[i]; 
  mob->off_flags    = pMobIndex->off_flags;
  mob->imm_flags    = pMobIndex->imm_flags;
  mob->res_flags    = pMobIndex->res_flags;
  mob->vuln_flags   = pMobIndex->vuln_flags;
  mob->start_pos    = pMobIndex->start_pos;
  mob->default_pos  = pMobIndex->default_pos;
  mob->sex    = pMobIndex->sex;
        if (mob->sex == 3) /* random sex */
            mob->sex = number_range(1,2);
  mob->race   = pMobIndex->race;
  mob->form   = pMobIndex->form;
  mob->parts    = pMobIndex->parts;
  mob->size   = pMobIndex->size;
  mob->material   = str_dup(pMobIndex->material);

  /* computed on the spot */

      for (i = 0; i < MAX_STATS; i ++)
            mob->perm_stat[i] = UMIN(25,11 + mob->level/4);
            
        if (IS_SET(mob->act,ACT_WARRIOR))
        {
            mob->perm_stat[STAT_STR] += 3;
            mob->perm_stat[STAT_INT] -= 1;
            mob->perm_stat[STAT_CON] += 2;
        }
        
        if (IS_SET(mob->act,ACT_THIEF))
        {
            mob->perm_stat[STAT_DEX] += 3;
            mob->perm_stat[STAT_INT] += 1;
            mob->perm_stat[STAT_WIS] -= 1;
        }
        
        if (IS_SET(mob->act,ACT_CLERIC))
        {
            mob->perm_stat[STAT_WIS] += 3;
            mob->perm_stat[STAT_DEX] -= 1;
            mob->perm_stat[STAT_STR] += 1;
        }
        
        if (IS_SET(mob->act,ACT_MAGE))
        {
            mob->perm_stat[STAT_INT] += 3;
            mob->perm_stat[STAT_STR] -= 1;
            mob->perm_stat[STAT_DEX] += 1;
        }
        
        if (IS_SET(mob->off_flags,OFF_FAST))
            mob->perm_stat[STAT_DEX] += 2;
            
        mob->perm_stat[STAT_STR] += mob->size - SIZE_MEDIUM;
        mob->perm_stat[STAT_CON] += (mob->size - SIZE_MEDIUM) / 2;

  /* let's get some spell action */
  if (IS_AFFECTED(mob,AFF_SANCTUARY))
  {
      af.where   = TO_AFFECTS;
      af.type      = skill_lookup("sanctuary");
      af.level     = mob->level;
      af.duration  = -1;
      af.location  = APPLY_NONE;
      af.modifier  = 0;
      af.bitvector = AFF_SANCTUARY;
      affect_to_char( mob, &af );
  }

  if (IS_AFFECTED(mob,AFF_HASTE))
  {
      af.where   = TO_AFFECTS;
      af.type      = skill_lookup("haste");
          af.level     = mob->level;
            af.duration  = -1;
          af.location  = APPLY_DEX;
          af.modifier  = 1 + (mob->level >= 18) + (mob->level >= 25) + 
         (mob->level >= 32);
          af.bitvector = AFF_HASTE;
          affect_to_char( mob, &af );
  }

  if (IS_AFFECTED(mob,AFF_PROTECT_EVIL))
  {
      af.where   = TO_AFFECTS;
      af.type  = skill_lookup("protection evil");
      af.level   = mob->level;
      af.duration  = -1;
      af.location  = APPLY_SAVES;
      af.modifier  = -1;
      af.bitvector = AFF_PROTECT_EVIL;
      affect_to_char(mob,&af);
  }

        if (IS_AFFECTED(mob,AFF_PROTECT_GOOD))
        {
      af.where   = TO_AFFECTS;
            af.type      = skill_lookup("protection good");
            af.level     = mob->level;
            af.duration  = -1;
            af.location  = APPLY_SAVES;
            af.modifier  = -1;
            af.bitvector = AFF_PROTECT_GOOD;
            affect_to_char(mob,&af);
        }
    }
    else /* read in old format and convert */
    {
  mob->act    = pMobIndex->act;
  mob->affected_by  = pMobIndex->affected_by;
  mob->alignment    = pMobIndex->alignment;
  mob->level    = pMobIndex->level;
  mob->hitroll    = pMobIndex->hitroll;
  mob->damroll    = 0;
  mob->max_hit    = mob->level * 8 + number_range(
          mob->level * mob->level/4,
          mob->level * mob->level);
  mob->max_hit *= .9;
  mob->hit    = mob->max_hit;
  mob->max_mana   = 100 + dice(mob->level,10);
  mob->mana   = mob->max_mana;
  switch(number_range(1,3))
  {
      case (1): mob->dam_type = 3;  break;  /* slash */
      case (2): mob->dam_type = 7;  break;  /* pound */
      case (3): mob->dam_type = 11; break;  /* pierce */
  }
  for (i = 0; i < 3; i++)
      mob->armor[i] = interpolate(mob->level,100,-100);
  mob->armor[3]   = interpolate(mob->level,100,0);
  mob->race   = pMobIndex->race;
  mob->off_flags    = pMobIndex->off_flags;
  mob->imm_flags    = pMobIndex->imm_flags;
  mob->res_flags    = pMobIndex->res_flags;
  mob->vuln_flags   = pMobIndex->vuln_flags;
  mob->start_pos    = pMobIndex->start_pos;
  mob->default_pos  = pMobIndex->default_pos;
  mob->sex    = pMobIndex->sex;
  mob->form   = pMobIndex->form;
  mob->parts    = pMobIndex->parts;
  mob->size   = SIZE_MEDIUM;
  mob->material   = str_dup ("");

  for (i = 0; i < MAX_STATS; i ++)
    mob->perm_stat[i] = 11 + mob->level/4;
  }
  
  mob->position = mob->start_pos;

}

/*
 * Create an instance of a mobile.
 */
CHAR_DATA *create_mobile( MOB_INDEX_DATA *pMobIndex )
{
    CHAR_DATA *mob;

    mobile_count++;

    if ( pMobIndex == NULL )
    {
  bug( "Create_mobile: NULL pMobIndex.", 0 );
  exit( 1 );
    }

    mob = new_char();
    MobIndexToInstance (mob,pMobIndex);

    /* link the mob to the world list */
    mob->next   = char_list;
    char_list   = mob;
    pMobIndex->count++;
    return mob;
}

/* duplicate a mobile exactly -- except inventory */
void clone_mobile(CHAR_DATA *parent, CHAR_DATA *clone)
{
    int i;
    AFFECT_DATA *paf;

    if ( parent == NULL || clone == NULL || !IS_NPC(parent))
  return;
    
    /* start fixing values */ 
    clone->name   = str_dup(parent->name);
    clone->version  = parent->version;
    clone->short_descr  = str_dup(parent->short_descr);
    clone->long_descr = str_dup(parent->long_descr);
    clone->description  = str_dup(parent->description);
    clone->group  = parent->group;
    clone->sex    = parent->sex;
    clone->class  = parent->class;
    clone->race   = parent->race;
    clone->level  = parent->level;
    clone->trust  = 0;
    clone->timer  = parent->timer;
    clone->wait   = parent->wait;
    clone->hit    = parent->hit;
    clone->max_hit  = parent->max_hit;
    clone->mana   = parent->mana;
    clone->max_mana = parent->max_mana;
    clone->move   = parent->move;
    clone->max_move = parent->max_move;
    clone->gold   = parent->gold;
    clone->silver = parent->silver;
    clone->exp    = parent->exp;
    clone->act    = parent->act;
    clone->comm   = parent->comm;
    clone->imm_flags  = parent->imm_flags;
    clone->res_flags  = parent->res_flags;
    clone->vuln_flags = parent->vuln_flags;
    clone->invis_level  = parent->invis_level;
    clone->affected_by  = parent->affected_by;
    clone->position = parent->position;
    clone->practice = parent->practice;
    clone->train  = parent->train;
    clone->saving_throw = parent->saving_throw;
    clone->alignment  = parent->alignment;
    clone->hitroll  = parent->hitroll;
    clone->damroll  = parent->damroll;
    clone->wimpy  = parent->wimpy;
    clone->form   = parent->form;
    clone->parts  = parent->parts;
    clone->size   = parent->size;
    clone->material = str_dup(parent->material);
    clone->off_flags  = parent->off_flags;
    clone->dam_type = parent->dam_type;
    clone->start_pos  = parent->start_pos;
    clone->default_pos  = parent->default_pos;
    clone->spec_fun = parent->spec_fun;
    
    for (i = 0; i < 4; i++)
      clone->armor[i] = parent->armor[i];

    for (i = 0; i < MAX_STATS; i++)
    {
  clone->perm_stat[i] = parent->perm_stat[i];
  clone->mod_stat[i]  = parent->mod_stat[i];
    }

    for (i = 0; i < 3; i++)
  clone->damage[i]  = parent->damage[i];

    /* now add the affects */
    for (paf = parent->affected; paf != NULL; paf = paf->next)
        affect_to_char(clone,paf);

}


void ObjIndexToInstance ( OBJ_DATA *obj, OBJ_INDEX_DATA *pObjIndex, int level, bool favored )
{
  int i;
  AFFECT_DATA *paf;

  while ( obj->affected )
    affect_remove_obj ( obj, obj->affected );
  
    obj->enchanted  = FALSE;
    obj->warps 	    = 0;
    if (pObjIndex->new_format)
  obj->level = pObjIndex->level;
    else
  obj->level    = UMAX(0,level);
    obj->wear_loc = -1;

    obj->name   = pObjIndex->name;
    obj->short_descr  = pObjIndex->short_descr;
    obj->description  = pObjIndex->description;
    obj->material = str_dup(pObjIndex->material);
    obj->item_type  = pObjIndex->item_type;
    obj->extra_flags  = pObjIndex->extra_flags;
    obj->wear_flags = pObjIndex->wear_flags;
    obj->value[0] = pObjIndex->value[0];
    obj->value[1] = pObjIndex->value[1];
    obj->value[2] = pObjIndex->value[2];
    obj->value[3] = pObjIndex->value[3];
    obj->value[4] = pObjIndex->value[4];
    obj->weight   = pObjIndex->weight;

    if (level == -1 || pObjIndex->new_format)
  obj->cost = pObjIndex->cost;
    else
      obj->cost = number_fuzzy( 10 )
      * number_fuzzy( level ) * number_fuzzy( level );

    /*
     * Mess with object properties.
     */
    switch ( obj->item_type )
    {
    default:
  bug( "Read_object: vnum %d bad type.", pObjIndex->vnum );
  break;

    case ITEM_LIGHT:
  if (obj->value[2] == 999)
    obj->value[2] = -1;
  break;

    case ITEM_FURNITURE:
    case ITEM_TRASH:
    case ITEM_CONTAINER:
    case ITEM_DRINK_CON:
    case ITEM_KEY:
    case ITEM_FOOD:
    case ITEM_BOAT:
    case ITEM_CORPSE_NPC:
    case ITEM_CORPSE_PC:
    case ITEM_FOUNTAIN:
    case ITEM_MAP:
    case ITEM_CLOTHING:
    case ITEM_TRAP:
    case ITEM_PORTAL:
  if (!pObjIndex->new_format)
      obj->cost /= 5;
  break;

    case ITEM_TREASURE:
    case ITEM_WARP_STONE:
    case ITEM_ROOM_KEY:
    case ITEM_GEM:
    case ITEM_JEWELRY:
    case ITEM_GRENADE:
    case ITEM_MIXER:
    case ITEM_COMPONENT:
    case ITEM_SPELL_PAGE:
    case ITEM_PART:
    case ITEM_FORGE:
  break;

    case ITEM_JUKEBOX:
  for (i = 0; i < 5; i++)
     obj->value[i] = -1;
  break;

    case ITEM_SCROLL:
  if (level != -1 && !pObjIndex->new_format)
      obj->value[0] = number_fuzzy( obj->value[0] );
  break;

    case ITEM_WAND:
    case ITEM_STAFF:
  if (level != -1 && !pObjIndex->new_format)
  {
      obj->value[0] = number_fuzzy( obj->value[0] );
      obj->value[1] = number_fuzzy( obj->value[1] );
      obj->value[2] = obj->value[1];
  }
  if (!pObjIndex->new_format)
      obj->cost *= 2;
  break;

    case ITEM_WEAPON:
    weapons_popped++;
  if (level != -1 && !pObjIndex->new_format)
  {
      obj->value[1] = number_fuzzy( number_fuzzy( 1 * level / 4 + 2 ) );
      obj->value[2] = number_fuzzy( number_fuzzy( 3 * level / 4 + 6 ) );
  }
  /*change from 6 to 4 - poquah */
  if ( favored && (number_percent() * number_percent()) < 3 )
    {
      switch ( dice(1,10) )
      {
      case 1:
      case 2: 
      case 3:
	  if ( obj->value[4] == 0  && ( obj->value[1] > 1 && obj->value[2] > 1))
		SET_BIT( obj->value[4], WEAPON_VORPAL );
		sprintf(log_buf,"Vorpal: %s vnum %d after %d",
			obj->name,obj->pIndexData->vnum,weapons_popped);
		break;
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
		SET_BIT( obj->value[4], WEAPON_HOLY );
		sprintf(log_buf,"Holy: %s vnum %d after %d",
			obj->name,obj->pIndexData->vnum,weapons_popped);
		break;
      default:
      	SET_BIT( obj->value[4], WEAPON_FAVORED );
        sprintf(log_buf,"Favored: %s vnum %d after %d",
        obj->name,obj->pIndexData->vnum,weapons_popped);


      }
      log_string(log_buf);
      weapons_popped = 0;
    }

  break;

    case ITEM_ARMOR:
  if (level != -1 && !pObjIndex->new_format)
  {
      obj->value[0] = number_fuzzy( level / 5 + 3 );
      obj->value[1] = number_fuzzy( level / 5 + 3 );
      obj->value[2] = number_fuzzy( level / 5 + 3 );
  }
  break;

    case ITEM_POTION:
    case ITEM_PILL:
  if (level != -1 && !pObjIndex->new_format)
      obj->value[0] = number_fuzzy( number_fuzzy( obj->value[0] ) );
  break;

    case ITEM_MONEY:
  if (!pObjIndex->new_format)
      obj->value[0] = obj->cost;
  break;
    }
  
    for (paf = pObjIndex->affected; paf != NULL; paf = paf->next) 
  if ( paf->location == APPLY_SPELL_AFFECT )
      affect_to_obj(obj,paf);
}

/*
 * Create an instance of an object.
 */
OBJ_DATA *create_object( OBJ_INDEX_DATA *pObjIndex, int level, bool favored )
{
    OBJ_DATA *obj;

    if ( pObjIndex == NULL )
    {
  bug( "Create_object: NULL pObjIndex.", 0 );
  exit( 1 );
    }

    obj = new_obj();
    obj->pIndexData = pObjIndex;
    obj->in_room  = NULL;    
    obj->stolen_timer  = 0;    
    ObjIndexToInstance (obj,pObjIndex,level,favored);
  
    obj->next   = object_list;
    object_list   = obj;
    pObjIndex->count++;

    return obj;
}

/* duplicate an object exactly -- except contents */
void clone_object(OBJ_DATA *parent, OBJ_DATA *clone)
{
    int i;
    AFFECT_DATA *paf;
/*    EXTRA_DESCR_DATA *ed,*ed_new; */

    if (parent == NULL || clone == NULL)
  return;

    /* start fixing the object */
    clone->name   = str_dup(parent->name);
    clone->short_descr  = str_dup(parent->short_descr);
    clone->description  = str_dup(parent->description);
    clone->item_type  = parent->item_type;
    clone->extra_flags  = parent->extra_flags;
    clone->wear_flags = parent->wear_flags;
    clone->weight = parent->weight;
    clone->cost   = parent->cost;
    clone->level  = parent->level;
    clone->stolen_timer  = parent->stolen_timer;
    clone->condition  = parent->condition;
    clone->material = str_dup(parent->material);
    clone->timer  = parent->timer;

    for (i = 0;  i < 5; i ++)
  clone->value[i] = parent->value[i];

    /* affects */
    clone->enchanted  = parent->enchanted;
  
    for (paf = parent->affected; paf != NULL; paf = paf->next) 
  affect_to_obj(clone,paf);

    /* extended desc */
/*
    for (ed = parent->extra_descr; ed != NULL; ed = ed->next);
    {
        ed_new                  = new_extra_descr();
        ed_new->keyword     = str_dup( ed->keyword);
        ed_new->description     = str_dup( ed->description );
        ed_new->next            = clone->extra_descr;
        clone->extra_descr    = ed_new;
    }
*/

}



/*
 * Clear a new character.
 */
void clear_char( CHAR_DATA *ch )
{
    static CHAR_DATA ch_zero;
    int i;

    *ch       = ch_zero;
    ch->name      = &str_empty[0];
    ch->short_descr   = &str_empty[0];
    ch->long_descr    = &str_empty[0];
    ch->description   = &str_empty[0];
    ch->prompt                  = &str_empty[0];
    ch->logon     = current_time;
    ch->lines     = PAGELEN;
    for (i = 0; i < 4; i++)
      ch->armor[i]    = 100;
    ch->position    = POS_STANDING;
    ch->hit     = 20;
    ch->max_hit     = 20;
    ch->mana      = 100;
    ch->max_mana    = 100;
    ch->move      = 100;
    ch->max_move    = 100;
    ch->on      = NULL;
    for (i = 0; i < MAX_STATS; i ++)
    {
  ch->perm_stat[i] = 13; 
  ch->mod_stat[i] = 0;
    }
    return;
}

/*
 * Get an extra description from a list.
 */
char *get_extra_descr( const char *name, EXTRA_DESCR_DATA *ed )
{
    for ( ; ed != NULL; ed = ed->next )
    {
  if ( is_name( (char *) name, ed->keyword ) )
      return ed->description;
    }
    return NULL;
}



/*
 * Translates mob virtual number to its mob index struct.
 * Hash table lookup.
 */
MOB_INDEX_DATA *get_mob_index( int vnum )
{
    MOB_INDEX_DATA *pMobIndex;

    if (vnum <= 0) return NULL;

    for ( pMobIndex  = mob_index_hash[vnum % MAX_KEY_HASH];
    pMobIndex != NULL;
    pMobIndex  = pMobIndex->next )
    {
  if ( pMobIndex->vnum == vnum )
      return pMobIndex;
    }

    if ( fBootDb )
    {
  bug( "Get_mob_index: bad vnum %d while booting.", vnum );  
    }

    return NULL;
}

RECIPE_DATA *get_recipe_data ( int recipe_number )
{
	RECIPE_DATA *recipe;

	for ( recipe = recipe_first ; recipe != NULL ; recipe = recipe->next)
	{
		if (recipe->recipe_num == recipe_number)
		   return recipe;
	}
	return NULL;
}

/*
 * Translates mob virtual number to its obj index struct.
 * Hash table lookup.
 */
OBJ_INDEX_DATA *get_obj_index( int vnum )
{
    OBJ_INDEX_DATA *pObjIndex;

    if (vnum <= 0) return NULL;

    for ( pObjIndex  = obj_index_hash[vnum % MAX_KEY_HASH];
    pObjIndex != NULL;
    pObjIndex  = pObjIndex->next )
    {
  if ( pObjIndex->vnum == vnum )
      return pObjIndex;
    }

    if ( fBootDb )
    {
  bug( "Get_obj_index: bad vnum %d while booting.", vnum );  
    }

    return NULL;
}



/*
 * Translates mob virtual number to its room index struct.
 * Hash table lookup.
 */
ROOM_INDEX_DATA *get_room_index( int vnum )
{
    ROOM_INDEX_DATA *pRoomIndex;

    if (vnum <= 0) return NULL;

    for ( pRoomIndex  = room_index_hash[vnum % MAX_KEY_HASH];
    pRoomIndex != NULL;
    pRoomIndex  = pRoomIndex->next )
    {
  if ( pRoomIndex->vnum == vnum )
      return pRoomIndex;
    }

    if ( fBootDb )
    {
  bug( "Get_room_index: bad vnum %d while booting.", vnum );  
    }

    return NULL;
}



/*
 * Read a letter from a file.
 */
char fread_letter( FILE *fp )
{
    char c;

    do
    {
  c = getc( fp );
    }
    while ( isspace(c) );

    return c;
}



/*
 * Read a number from a file.
 */
int fread_number( FILE *fp )
{
    int number;
    bool sign;
    char c;

    do
    {
  c = getc( fp );
    }
    while ( isspace(c) );

    number = 0;

    sign   = FALSE;
    if ( c == '+' )
    {
  c = getc( fp );
    }
    else if ( c == '-' )
    {
  sign = TRUE;
  c = getc( fp );
    }

    if ( !isdigit(c) )
    {
  bug( "Fread_number: bad format.", 0 );
  if ( fp != stdin ) fclose( fp );
  fp = NULL; 
  if (area_last)
    rename_area (area_last->file_name);          
  exit( 1 );
    }

    while ( isdigit(c) )
    {
  number = number * 10 + c - '0';
  c      = getc( fp );
    }

    if ( sign )
  number = 0 - number;

    if ( c == '|' )
  number += fread_number( fp );
    else if ( c != ' ' )
  ungetc( c, fp );

    return number;
}

long fread_flag( FILE *fp)
{
    int number;
    char c;
    bool negative = FALSE;

    do
    {
  c = getc(fp);
    }
    while ( isspace(c));

    if (c == '-')
    {
  negative = TRUE;
  c = getc(fp);
    }

    number = 0;

    if (!isdigit(c))
    {
  while (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'))
  {
      number += flag_convert(c);
      c = getc(fp);
  }
    }

    while (isdigit(c))
    {
  number = number * 10 + c - '0';
  c = getc(fp);
    }

    if (c == '|')
  number += fread_flag(fp);

    else if  ( c != ' ')
  ungetc(c,fp);

    if (negative)
  return -1 * number;

    return number;
}

long flag_convert(char letter )
{
    long bitsum = 0;
    char i;

    if ('A' <= letter && letter <= 'Z') 
    {
  bitsum = 1;
  for (i = letter; i > 'A'; i--)
      bitsum *= 2;
    }
    else if ('a' <= letter && letter <= 'z')
    {
  bitsum = 67108864; /* 2^26 */
  for (i = letter; i > 'a'; i --)
      bitsum *= 2;
    }

    return bitsum;
}

/*
 * Read one word (into static buffer).
 */
char *fread_word( FILE *fp )
{
    static char word[MAX_INPUT_LENGTH];
    char *pword;
    char cEnd;

    do
    {
  cEnd = getc( fp );
    }
    while ( isspace( cEnd ) );

    if ( cEnd == '\'' || cEnd == '"' )
    {
  pword   = word;
    }
    else
    {
  word[0] = cEnd;
  pword   = word+1;
  cEnd    = ' ';
    }

    for ( ; pword < word + MAX_INPUT_LENGTH; pword++ )
    {
  *pword = getc( fp );
  if ( cEnd == ' ' ? isspace(*pword) : *pword == cEnd )
  {
      if ( cEnd == ' ' )
    ungetc( *pword, fp );
      *pword = '\0';
      return word;
  }
    }

    bug( "Fread_word: word too long.", 0 );
    if ( fp != stdin ) fclose( fp );
    fp = NULL; 
    if (area_last)
      rename_area (area_last->file_name);            
    exit( 1 );
    return NULL;
}


char *fread_string( FILE *fp )
{
    char *plast;
    char c;

    plast = top_string + sizeof(char *);
    if ( plast > &string_space[MAX_STRING - MAX_STRING_LENGTH] )
    {
  bug( "Fread_string: MAX_STRING %d exceeded.", MAX_STRING );
  exit( 1 );
    }

    /*
     * Skip blanks.
     * Read first char.
     */
    do
    {
  c = getc( fp );
    }
    while ( isspace(c) );

    if ( ( *plast++ = c ) == '~' )
  return &str_empty[0];

    for ( ;; )
    {
        /*
         * Back off the char type lookup,
         *   it was too dirty for portability.
         *   -- Furey
         */

  switch ( *plast = getc(fp) )
  {
        default:
            plast++;
            break;
 
        case EOF:
  /* temp fix */
            bug( "Fread_string: EOF", 0 );
      return NULL;
            /* exit( 1 ); */
            break;
 
        case '\n':
            plast++;
            *plast++ = '\r';
            break;
 
        case '\r':
            break;
 
        case '~':
            plast++;
      {
    union
    {
        char *  pc;
        char  rgc[sizeof(char *)];
    } u1;
    int ic;
    int iHash;
    char *pHash;
    char *pHashPrev;
    char *pString;

    plast[-1] = '\0';
    iHash     = UMIN( MAX_KEY_HASH - 1, plast - 1 - top_string );
    for ( pHash = string_hash[iHash]; pHash; pHash = pHashPrev )
    {
        for ( ic = 0; ic < sizeof(char *); ic++ )
      u1.rgc[ic] = pHash[ic];
        pHashPrev = u1.pc;
        pHash    += sizeof(char *);

        if ( top_string[sizeof(char *)] == pHash[0]
        &&   !strcmp( top_string+sizeof(char *)+1, pHash+1 ) )
      return pHash;
    }

    if ( fBootDb )
    {
        pString   = top_string;
        top_string    = plast;
        u1.pc   = string_hash[iHash];
        for ( ic = 0; ic < sizeof(char *); ic++ )
      pString[ic] = u1.rgc[ic];
        string_hash[iHash]  = pString;

        nAllocString += 1;
        sAllocString += top_string - pString;
        return pString + sizeof(char *);
    }
    else
    {
        return str_dup( top_string + sizeof(char *) );
    }
      }
  }
    }
}

char *fread_string_eol( FILE *fp )
{
    static bool char_special[256-EOF];
    char *plast;
    char c;
 
    if ( char_special[EOF-EOF] != TRUE )
    {
        char_special[EOF -  EOF] = TRUE;
        char_special['\n' - EOF] = TRUE;
        char_special['\r' - EOF] = TRUE;
    }
 
    plast = top_string + sizeof(char *);
    if ( plast > &string_space[MAX_STRING - MAX_STRING_LENGTH] )
    {
        bug( "Fread_string: MAX_STRING %d exceeded.", MAX_STRING );
        exit( 1 );
    }
 
    /*
     * Skip blanks.
     * Read first char.
     */
    do
    {
        c = getc( fp );
    }
    while ( isspace(c) );
 
    if ( ( *plast++ = c ) == '\n')
        return &str_empty[0];
 
    for ( ;; )
    {
        if ( !char_special[ ( *plast++ = getc( fp ) ) - EOF ] )
            continue;
 
        switch ( plast[-1] )
        {
        default:
            break;
 
        case EOF:
            bug( "Fread_string_eol  EOF", 0 );
            if ( fp != stdin ) fclose( fp );
            fp = NULL;
            if (area_last)
              rename_area (area_last->file_name);            
            exit( 1 );
            break;
 
        case '\n':  case '\r':
            {
                union
                {
                    char *      pc;
                    char        rgc[sizeof(char *)];
                } u1;
                int ic;
                int iHash;
                char *pHash;
                char *pHashPrev;
                char *pString;
 
                plast[-1] = '\0';
                iHash     = UMIN( MAX_KEY_HASH - 1, plast - 1 - top_string );
                for ( pHash = string_hash[iHash]; pHash; pHash = pHashPrev )
                {
                    for ( ic = 0; ic < sizeof(char *); ic++ )
                        u1.rgc[ic] = pHash[ic];
                    pHashPrev = u1.pc;
                    pHash    += sizeof(char *);
 
                    if ( top_string[sizeof(char *)] == pHash[0]
                    &&   !strcmp( top_string+sizeof(char *)+1, pHash+1 ) )
                        return pHash;
                }
 
                if ( fBootDb )
                {
                    pString             = top_string;
                    top_string          = plast;
                    u1.pc               = string_hash[iHash];
                    for ( ic = 0; ic < sizeof(char *); ic++ )
                        pString[ic] = u1.rgc[ic];
                    string_hash[iHash]  = pString;
 
                    nAllocString += 1;
                    sAllocString += top_string - pString;
                    return pString + sizeof(char *);
                }
                else
                {
                    return str_dup( top_string + sizeof(char *) );
                }
            }
        }
    }
}



/*
 * Read to end of line (for comments).
 */
void fread_to_eol( FILE *fp )
{
    char c;

    do
    {
  c = getc( fp );
    }
    while ( c != '\n' && c != '\r' );

    do
    {
  c = getc( fp );
    }
    while ( c == '\n' || c == '\r' );

    ungetc( c, fp );
    return;
}

/*
void free_mem( void *pMem, int sMem )
{
    int iList;

    for ( iList = 0; iList < MAX_MEM_LIST; iList++ )
    {
  if ( sMem <= rgSizeList[iList] )
      break;
    }

    if ( iList == MAX_MEM_LIST )
    {
  bug( "Free_mem: size %d too large.", sMem );
  exit( 1 );
    }

    * ((void **) pMem) = rgFreeList[iList];
    rgFreeList[iList]  = pMem;

    return;
} */

void free_mem( void *pMem, int sMem )
{
#ifdef OOLC_VERSION
    int iList;
    int *magic;

    pMem -= sizeof(*magic);
    magic = (int *) pMem;

    if (*magic != MAGIC_NUM)
    {
        bug("Attempt to recyle invalid memory of size %d.",sMem);
        bug((char*) pMem + sizeof(*magic),0);
        return;
    }

    *magic = 0;
    sMem += sizeof(*magic);

    for ( iList = 0; iList < MAX_MEM_LIST; iList++ )
    {
        if ( sMem <= rgSizeList[iList] )
            break;
    }
    
    if ( iList == MAX_MEM_LIST )
    {
        bug( "Free_mem: size %d too large.", sMem );
        exit( 1 );
    }
    
    * ((void **) pMem) = rgFreeList[iList];
    rgFreeList[iList]  = pMem;
#else
	GC_FREE(pMem);     
#endif
    return;
}    


/*
 * Allocate some ordinary memory,
 *   with the expectation of freeing it someday.
 *
void *alloc_mem( int sMem )
{
    void *pMem;
    int *magic;
    int iList;

    sMem += sizeof(*magic);

    for ( iList = 0; iList < MAX_MEM_LIST; iList++ )
    {
  if ( sMem <= rgSizeList[iList] )
      break;
    }

    if ( iList == MAX_MEM_LIST )
    {
  bug( "Alloc_mem: size %d too large.", sMem );
  exit( 1 );
    }

    if ( rgFreeList[iList] == NULL )
    {
  pMem              = alloc_perm( rgSizeList[iList] );
    }
    else
    {
  pMem              = rgFreeList[iList];
  rgFreeList[iList] = * ((void **) rgFreeList[iList]);
    }

    return pMem;
}
*/

/*
 * Old memory code, use GC_MALLOC instead, more stable
 *
 */
#ifdef OOLC_VERSION
void *alloc_mem( int sMem )
{
    void *pMem;
    int *magic;
    int iList;

    sMem += sizeof(*magic);

    for ( iList = 0; iList < MAX_MEM_LIST; iList++ )
    {
        if ( sMem <= rgSizeList[iList] )
            break;
    }

    if ( iList == MAX_MEM_LIST )
    {
        bug( "Alloc_mem: size %d too large.", sMem );
        exit( 1 );
    }

    if ( rgFreeList[iList] == NULL )
    { 
        pMem              = alloc_perm( rgSizeList[iList] );
    } 
    else
    { 
        pMem              = rgFreeList[iList];
        rgFreeList[iList] = * ((void **) rgFreeList[iList]);
    } 
    
    magic = (int *) pMem;
    *magic = MAGIC_NUM;
    pMem += sizeof(*magic);
      
    return pMem;
}     
#endif

/*
 * Old memory code, use GC_MALLOC instead (see the gc/ directory 
 * for more information.
 *
 */
#ifdef OLC_VERSION
void *alloc_perm( int sMem )
{
    static char *pMemPerm;
    static int iMemPerm;
    void *pMem;

    while ( sMem % sizeof(long) != 0 )
  sMem++;
    if ( sMem > MAX_PERM_BLOCK )
    {
  bug( "Alloc_perm: %d too large.", sMem );
  exit( 1 );
    }

    if ( pMemPerm == NULL || iMemPerm + sMem > MAX_PERM_BLOCK )
    {
  iMemPerm = 0;
  if ( ( pMemPerm = GC_MALLOC( MAX_PERM_BLOCK ) ) == NULL )
  {
      perror( "Alloc_perm" );
      exit( 1 );
  }
    }

    pMem        = pMemPerm + iMemPerm;
    iMemPerm   += sMem;
    nAllocPerm += 1;
    sAllocPerm += sMem;
    return pMem;
}

#endif

/*
 * Duplicate a string into dynamic memory.
 * Fread_strings are read-only and shared.
 */
char *str_dup( const char *str )
{
    char *str_new;
    
    if (str == NULL)
  return &str_empty[0];

    if ( str[0] == '\0' )
  return &str_empty[0];

    if ( str >= string_space && str < top_string )
  return (char *) str;

#ifdef OLC_VERSION
    str_new = alloc_mem( strlen(str) + 1 );
#else
    str_new = GC_MALLOC( strlen(str) );
#endif
    strncpy( str_new, str, strlen(str) );
    return str_new;
}

/*
 * Old memory code, use str_dup()  (I hope)
 *
 */
#ifdef OLC_VERSION
char *str_dup_perm( const char *str )
{       
  int len;
  char *plast;
  int ic;
  int iHash;
  char *pHash;
  char *pHashPrev;
  char *pString;  
  
  if (str == NULL)
    return NULL;

  if ( str[0] == '\0' )
    return &str_empty[0];

  if ( str >= string_space && str < top_string )
    return (char *) str;  
  
  len = strlen (str);
  
  plast = top_string + sizeof(char *);
  if ( plast > &string_space[MAX_STRING - MAX_STRING_LENGTH] )
  {
    bug( "Str_dup_perm: MAX_STRING %d exceeded.", MAX_STRING );
    exit( 1 );
  }
 
  strcpy (plast,str);
  plast += strlen (str) + 2;
  {
      union
      {
          char *      pc;
          char        rgc[sizeof(char *)];
      } u1;
 
      plast[-1] = '\0';
      iHash     = UMIN( MAX_KEY_HASH - 1, plast - 1 - top_string );
      for ( pHash = string_hash[iHash]; pHash; pHash = pHashPrev )
      {
          for ( ic = 0; ic < sizeof(char *); ic++ )
              u1.rgc[ic] = pHash[ic];
          pHashPrev = u1.pc;
          pHash    += sizeof(char *);
 
          if ( top_string[sizeof(char *)] == pHash[0]
          &&   !strcmp( top_string+sizeof(char *)+1, pHash+1 ) )
              return pHash;
      }
 
      pString             = top_string;
      top_string          = plast;
      u1.pc               = string_hash[iHash];
      for ( ic = 0; ic < sizeof(char *); ic++ )
          pString[ic] = u1.rgc[ic];
      string_hash[iHash]  = pString;
 
      nAllocString += 1;
      sAllocString += top_string - pString;
      return pString + sizeof(char *);
  }  
}
#endif

/*
 * Free a string.
 * Null is legal here to simplify callers.
 * Read-only shared strings are not touched.
 */

void free_string( char *pstr )
{
    if ( pstr == NULL
    ||   pstr == &str_empty[0]
    || ( pstr >= string_space && pstr < top_string ) )
  return;

    free_mem( pstr, strlen(pstr) + 1 );
    return;
}

int get_area_min_vnum (AREA_DATA *area)
{
  int min;
  
  min = area->min_vnum_room;
  if (area->min_vnum_obj)
    if (area->min_vnum_obj < min)
       min = area->min_vnum_obj;
  if (area->min_vnum_mob)       
    if (area->min_vnum_mob < min)
       min = area->min_vnum_mob;
     
  return min;     
}

int get_area_max_vnum (AREA_DATA *area)
{
  int max;
  
  max = area->max_vnum_room;
  if (area->max_vnum_obj > max)
     max = area->max_vnum_obj;
  if (area->max_vnum_mob > max)
     max = area->max_vnum_mob;
     
  return max;     
}


void do_areas( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char bigbuf[4*MAX_STRING_LENGTH];
    AREA_DATA *area;
    bool odd;


    if (argument[0] != '\0')
    {
  send_to_char("No argument is used with this command.\n\r",ch);
  return;
    }
  
  if (IS_IMMORTAL (ch) && IS_SET (ch->display,DISP_DISP_VNUM)) 
   {
    area = area_first;
    bigbuf[0] = '\0';
    while (area) 
    {
      int min,max;
      
      min = get_area_min_vnum (area);
      max = get_area_max_vnum (area);
      sprintf(buf,"%-39s [%5d] - [%5d]\n\r",area->name,min,max);
      strcat (bigbuf,buf);
      area = area->next;
    }
    page_to_char (bigbuf,ch);  
   }
  else
   {
    bigbuf[0] = '\0';
    area = area_first;
    odd = FALSE;
    if (IS_IMMORTAL (ch))
    send_to_char ("* denotes areas under development - IMM only.\n\r",ch);

    while (area)
     {
      if (!area->under_develop || IS_IMMORTAL(ch))
       {
        sprintf (buf,"{%s%-38s",area->under_develop ? "*":"",area->credits);
        strcat(bigbuf, buf);
        if (odd) strcat(bigbuf,"\n\r");
        odd = !odd;
       }
      area = area->next;    
     }
    page_to_char (bigbuf,ch);
   }

  return;
 }  


void do_memory( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];

    sprintf( buf, "Affects %5d\n\r", top_affect    ); send_to_char( buf, ch );
    sprintf( buf, "Areas   %5d\n\r", top_area      ); send_to_char( buf, ch );
    sprintf( buf, "Cstats  %5d\n\r", top_cstat      ); send_to_char( buf, ch );
    sprintf( buf, "ExDes   %5d\n\r", top_ed        ); send_to_char( buf, ch );
    sprintf( buf, "Exits   %5d\n\r", top_exit      ); send_to_char( buf, ch );
    sprintf( buf, "Helps   %5d\n\r", top_help      ); send_to_char( buf, ch );
    sprintf( buf, "Socials %5d\n\r", social_count  ); send_to_char( buf, ch );
    sprintf( buf, "Mobs    %5d(%d new format)\n\r", top_mob_index,newmobs ); 
    send_to_char( buf, ch );
    sprintf( buf, "(in use)%5d\n\r", mobile_count  ); send_to_char( buf, ch );
    sprintf( buf, "Objs    %5d(%d new format)\n\r", top_obj_index,newobjs ); 
    send_to_char( buf, ch );
    sprintf( buf, "Resets  %5d\n\r", top_reset     ); send_to_char( buf, ch );
    sprintf( buf, "Rooms   %5d\n\r", top_room      ); send_to_char( buf, ch );
    sprintf( buf, "Shops   %5d\n\r", top_shop      ); send_to_char( buf, ch );

    sprintf( buf, "Strings %5d strings of %7d bytes (max %d).\n\r",
  nAllocString, sAllocString, MAX_STRING );
    send_to_char( buf, ch );

#ifdef OLC_VERSION
    sprintf( buf, "Perms   %5d blocks  of %7d bytes.\n\r", 
	     nAllocPerm, sAllocPerm );
    send_to_char( buf, ch );
#endif
}

void do_eqlist( CHAR_DATA *ch, char *argument )
{
   OBJ_INDEX_DATA *pObjIndex;
   AFFECT_DATA *paf;
   FILE *fp;
   int vnum,nMatch,wcount = 0;
   char wtype[12];
   char arg1[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   char buf2[MAX_STRING_LENGTH];
   char fname[20];

   argument = one_argument(argument, arg1);

   if (arg1[0] == '\0')
   {
      send_to_char("Arguement missing see 'help eqlist'.\n\r",ch);
      return;
   }

   fclose(fpReserve);

   strcpy(fname, "eqlist.eql");

   if (!str_prefix("armor",arg1))
   {
      strcpy(fname, "armor.eql");
   }
   if (!str_prefix("weapons",arg1))
   {
      strcpy(fname, "weapons.eql");
   }

   /* open file */
   fp = fopen(fname,"w");

   if (!str_prefix("armor",arg1) || !str_prefix("all",arg1))
   {
      nMatch = 0;
      for (vnum = 0; nMatch < top_obj_index; vnum++)
         if ((pObjIndex = get_obj_index(vnum)) != NULL)
         {
            nMatch++;
if( !IS_OBJ_STAT(pObjIndex,ITEM_NOIDENTIFY))
{
            if ((pObjIndex->item_type == ITEM_ARMOR ||
		 pObjIndex->item_type == ITEM_LIGHT ||
                 pObjIndex->item_type == ITEM_CLOTHING ||
                 pObjIndex->item_type == ITEM_JEWELRY) &&
                 pObjIndex->level < 52)
	    {

   if (pObjIndex->wear_flags & ITEM_WEAR_FINGER ) strcpy(wtype, "finger");
   if (pObjIndex->wear_flags & ITEM_WEAR_NECK ) strcpy(wtype, "neck");
   if (pObjIndex->wear_flags & ITEM_WEAR_BODY ) strcpy(wtype, "torso");
   if (pObjIndex->wear_flags & ITEM_WEAR_HEAD ) strcpy(wtype, "head");
   if (pObjIndex->wear_flags & ITEM_WEAR_LEGS ) strcpy(wtype, "legs");
   if (pObjIndex->wear_flags & ITEM_WEAR_FEET ) strcpy(wtype, "feet");
   if (pObjIndex->wear_flags & ITEM_WEAR_HANDS  ) strcpy(wtype, "hands");
   if (pObjIndex->wear_flags & ITEM_WEAR_ARMS ) strcpy(wtype, "arms");
   if (pObjIndex->wear_flags & ITEM_WEAR_SHIELD ) strcpy(wtype, "shield");
   if (pObjIndex->wear_flags & ITEM_WEAR_ABOUT  ) strcpy(wtype, "body");
   if (pObjIndex->wear_flags & ITEM_WEAR_WAIST  ) strcpy(wtype, "waist");
   if (pObjIndex->wear_flags & ITEM_WEAR_WRIST  ) strcpy(wtype, "wrist");
   if (pObjIndex->wear_flags & ITEM_WIELD   ) strcpy(wtype, "wield");
   if (pObjIndex->wear_flags & ITEM_HOLD    ) strcpy(wtype, "hold");
   if (pObjIndex->wear_flags & ITEM_WEAR_FLOAT  ) strcpy(wtype, "float");
   if (pObjIndex->item_type == ITEM_LIGHT) strcpy(wtype,"light");

   strcpy(buf," ");
    for ( paf = pObjIndex->affected; paf != NULL; paf = paf->next )
    {
       if (paf->modifier > 0)
	  strcat( buf, "+");
       sprintf(buf2, "%s%d",buf,paf->modifier);
       strcpy( buf, buf2);

       strcpy(buf2,affect_loc_name( paf->location ));
       if (!str_prefix("strength",buf2))
          strcpy( buf2,"str");
       if (!str_prefix("intelligence",buf2))
          strcpy( buf2,"int");
       if (!str_prefix("wisdom",buf2))
          strcpy( buf2,"wis");
       if (!str_prefix("dexterity",buf2))
          strcpy( buf2,"dex");
       if (!str_prefix("constitution",buf2))
          strcpy( buf2,"con");
       if (!str_prefix("damage roll",buf2))
          strcpy( buf2,"dam");
       if (!str_prefix("hit roll",buf2))
          strcpy( buf2,"hit");
       if (!str_prefix("armor class",buf2))
	  strcpy( buf2,"ac");
       strcat( buf, buf2);
       strcat( buf, " ");
    }
    fprintf(fp,"%d %d \"%s\" wear=%s w=%d v=%d EF(%s) %d/%d/%d/%d AF(%s) a=\"%s\"\n", 
    pObjIndex->vnum,pObjIndex->level,pObjIndex->short_descr,
    wtype,pObjIndex->weight,pObjIndex->cost,
    extra_bit_name(pObjIndex->extra_flags),
    pObjIndex->value[0],pObjIndex->value[1],
    pObjIndex->value[2],pObjIndex->value[3],
    buf,
    pObjIndex->area->name);
            }
	 }
   }

   if (!str_prefix("weapons",arg1) || !str_prefix("all",arg1))
   {
     for (wcount = 0; wcount < 10; wcount++)
     {
       switch (wcount)
       {
          case(WEAPON_EXOTIC):
          strcpy(wtype,"exotic");
          break;
          case(WEAPON_SWORD):
          strcpy(wtype,"sword");
          break;
          case(WEAPON_DAGGER):
          strcpy(wtype,"dagger");
          break;
          case(WEAPON_SPEAR):
          strcpy(wtype,"spear");
          break;
          case(WEAPON_MACE):
          strcpy(wtype,"mace");
          break;
          case(WEAPON_AXE):
          strcpy(wtype,"axe");
          break;
          case(WEAPON_FLAIL):
          strcpy(wtype,"flail");
          break;
          case(WEAPON_WHIP):
          strcpy(wtype,"whip");
          break;
          case(WEAPON_POLEARM):
          strcpy(wtype,"polearm");
          break;
          case(WEAPON_GAROTTE):
          strcpy(wtype,"garotte");
          break;
       }
       fprintf(fp,"####\n");
       fprintf(fp,"%s\n",wtype);
      nMatch = 0;         
      for (vnum = 0; nMatch < top_obj_index; vnum++)
         if ((pObjIndex = get_obj_index(vnum)) != NULL)
	 {
            nMatch++;
            if (pObjIndex->item_type == ITEM_WEAPON &&
		pObjIndex->value[0] == wcount &&
	         pObjIndex->level < 52)
	    {
      strcpy(buf," ");
      for ( paf = pObjIndex->affected; paf != NULL; paf = paf->next )
      {
         if (paf->modifier > 0)
            strcat( buf, "+");
         sprintf(buf2, "%s%d",buf,paf->modifier);
         strcpy( buf, buf2);

       strcpy(buf2,affect_loc_name( paf->location ));
       if (!str_prefix("strength",buf2))
          strcpy( buf2,"str");
       if (!str_prefix("intelligence",buf2))
	  strcpy( buf2,"int");
       if (!str_prefix("wisdom",buf2))
          strcpy( buf2,"wis");
       if (!str_prefix("dexterity",buf2))
          strcpy( buf2,"dex");
       if (!str_prefix("constitution",buf2))
          strcpy( buf2,"con");
       if (!str_prefix("damage roll",buf2))
          strcpy( buf2,"dam");
       if (!str_prefix("hit roll",buf2))
          strcpy( buf2,"hit");
       if (!str_prefix("armor class",buf2))
	  strcpy( buf2,"ac");
       strcat( buf, buf2);
         strcat( buf, " ");
      }
        fprintf(fp,"%d %d \"%s\" w=%d v=%d madeof=\"%s\" damtype=%d EF(%s) AF(%s) WF(%s) %dD%d(%d) a=\"%s\"\n",
	   pObjIndex->vnum,pObjIndex->level,pObjIndex->short_descr,
	   pObjIndex->weight,pObjIndex->cost,
	   pObjIndex->material, pObjIndex->value[3],
	   extra_bit_name(pObjIndex->extra_flags),
	   buf,
	   weapon_bit_name(pObjIndex->value[4]),
	   pObjIndex->value[1],pObjIndex->value[2],
	   ((1 + pObjIndex->value[2]) * pObjIndex->value[1] / 2),
	   pObjIndex->area->name);
	    }
	 }
} /* IF NO_INDENT */ 
     }       
   }

   /* close file */
   fclose(fp);
}

void do_dump( CHAR_DATA *ch, char *argument )
{ 
    int count,count2,num_pcs,aff_count;
    CHAR_DATA *fch;
    MOB_INDEX_DATA *pMobIndex;
    PC_DATA *pc;
    OBJ_DATA *obj;
    OBJ_INDEX_DATA *pObjIndex;
    ROOM_INDEX_DATA *room;
    EXIT_DATA *exit;
    DESCRIPTOR_DATA *d;
    AFFECT_DATA *af;
    FILE *fp;
    int vnum,nMatch = 0;

    /* open file */
    fclose(fpReserve);
    fp = fopen("mem.dmp","w");

    /* report use of data structures */
    
    num_pcs = 0;
    aff_count = 0;

    /* mobile prototypes */
    fprintf(fp,"MobProt %4d (%8d bytes)\n",
  top_mob_index, top_mob_index * (sizeof(*pMobIndex))); 

    /* mobs */
    count = 0;  count2 = 0;
    for (fch = char_list; fch != NULL; fch = fch->next)
    {
  count++;
  if (fch->pcdata != NULL)
      num_pcs++;
  for (af = fch->affected; af != NULL; af = af->next)
      aff_count++;
    }
    for (fch = char_free; fch != NULL; fch = fch->next)
  count2++;

    fprintf(fp,"Mobs  %4d (%8d bytes), %2d free (%d bytes)\n",
  count, count * (sizeof(*fch)), count2, count2 * (sizeof(*fch)));

    /* pcdata */
    count = 0;
    for (pc = pcdata_free; pc != NULL; pc = pc->next)
  count++; 

    fprintf(fp,"Pcdata  %4d (%8d bytes), %2d free (%d bytes)\n",
  num_pcs, num_pcs * (sizeof(*pc)), count, count * (sizeof(*pc)));

    /* descriptors */
    count = 0; count2 = 0;
    for (d = descriptor_list; d != NULL; d = d->next)
  count++;
    for (d= descriptor_free; d != NULL; d = d->next)
  count2++;

    fprintf(fp, "Descs  %4d (%8d bytes), %2d free (%d bytes)\n",
  count, count * (sizeof(*d)), count2, count2 * (sizeof(*d)));

    /* object prototypes */
    for ( vnum = 0; nMatch < top_obj_index; vnum++ )
        if ( ( pObjIndex = get_obj_index( vnum ) ) != NULL )
        {
      for (af = pObjIndex->affected; af != NULL; af = af->next)
    aff_count++;
            nMatch++;
        }

    fprintf(fp,"ObjProt %4d (%8d bytes)\n",
  top_obj_index, top_obj_index * (sizeof(*pObjIndex)));


    /* objects */
    count = 0;  count2 = 0;
    for (obj = object_list; obj != NULL; obj = obj->next)
    {
  count++;
  for (af = obj->affected; af != NULL; af = af->next)
      aff_count++;
    }
    for (obj = obj_free; obj != NULL; obj = obj->next)
  count2++;

    fprintf(fp,"Objs  %4d (%8d bytes), %2d free (%d bytes)\n",
  count, count * (sizeof(*obj)), count2, count2 * (sizeof(*obj)));

    /* affects */
    count = 0;
    for (af = affect_free; af != NULL; af = af->next)
  count++;

    fprintf(fp,"Affects %4d (%8d bytes), %2d free (%d bytes)\n",
  aff_count, aff_count * (sizeof(*af)), count, count * (sizeof(*af)));

    /* rooms */
    fprintf(fp,"Rooms %4d (%8d bytes)\n",
  top_room, top_room * (sizeof(*room)));

     /* exits */
    fprintf(fp,"Exits %4d (%8d bytes)\n",
  top_exit, top_exit * (sizeof(*exit)));

    fclose(fp);

    /* start printing out mobile data */
    fp = fopen("mob.dmp","w");

    fprintf(fp,"\nMobile Analysis\n");
    fprintf(fp,  "---------------\n");
    nMatch = 0;
    for (vnum = 0; nMatch < top_mob_index; vnum++)
  if ((pMobIndex = get_mob_index(vnum)) != NULL)
  {
      nMatch++;
      fprintf(fp,"#%-4d %3d active %3d killed     %s\n",
    pMobIndex->vnum,pMobIndex->count,
    pMobIndex->killed,pMobIndex->short_descr);
  }
    fclose(fp);

    /* start printing out object data */
    fp = fopen("obj.dmp","w");

    fprintf(fp,"\nObject Analysis\n");
    fprintf(fp,  "---------------\n");
    nMatch = 0;
    for (vnum = 0; nMatch < top_obj_index; vnum++)
  if ((pObjIndex = get_obj_index(vnum)) != NULL)
  {
      nMatch++;
      fprintf(fp,"#%-4d %3d active %3d reset      %s\n",
    pObjIndex->vnum,pObjIndex->count,
    pObjIndex->reset_num,pObjIndex->short_descr);
  }

    /* close file */
    fclose(fp);
    fpReserve = fopen( NULL_FILE, "r" );
}


/*
 * Stick a little fuzz on a number.
 */
int number_fuzzy( int number )
{
    switch ( number_bits( 2 ) )
    {
    case 0:  number -= 1; break;
    case 3:  number += 1; break;
    }

    return UMAX( 1, number );
}



/*
 * Generate a random number.
 */
int number_range( int from, int to )
{
    int power;
    int number;

    if (from == 0 && to == 0)
  return 0;

    if ( ( to = to - from + 1 ) <= 1 )
  return from;

    for ( power = 2; power < to; power <<= 1 )
  ;

    while ( ( number = number_mm() & (power -1 ) ) >= to )
  ;

    return from + number;
}



/*
 * Generate a percentile roll.
 */
int number_percent( void )
{
    /* Going to try just a remainder()
    int percent;

    while ( (percent = number_mm() & (128-1) ) > 99 );

    return 1 + percent;
     */

  int foo=50;

  foo = remainder((random()>>6),100) + 50;
 
 return foo;
}



/*
 * Generate a random door.
 */
int number_door( void )
{
    int door;

    while ( ( door = number_mm() & (8-1) ) > 5)
  ;

    return door;
}

int number_bits( int width )
{
    return number_mm( ) & ( ( 1 << width ) - 1 );
}




/*
 * I've gotten too many bad reports on OS-supplied random number generators.
 * This is the Mitchell-Moore algorithm from Knuth Volume II.
 * Best to leave the constants alone unless you've read Knuth.
 * -- Furey
 */
#if defined (OLD_RAND)
static  int     rgiState[2+55];
#endif
 
void init_mm( )
{
#if defined (OLD_RAND)
    int *piState;
    int iState;
 
    piState     = &rgiState[2];
 
    piState[-2] = 55 - 55;
    piState[-1] = 55 - 24;
 
    piState[0]  = ((int) current_time) & ((1 << 30) - 1);
    piState[1]  = 1;
    for ( iState = 2; iState < 55; iState++ )
    {
        piState[iState] = (piState[iState-1] + piState[iState-2])
                        & ((1 << 30) - 1);
    }
#else
    srandom(time(NULL)^getpid());
#endif
    return;
}
 
 
 
long number_mm( void )
{
#if defined (OLD_RAND)
    int *piState;
    int iState1;
    int iState2;
    int iRand;
 
    piState             = &rgiState[2];
    iState1             = piState[-2];
    iState2             = piState[-1];
    iRand               = (piState[iState1] + piState[iState2])
                        & ((1 << 30) - 1);
    piState[iState1]    = iRand;
    if ( ++iState1 == 55 )
        iState1 = 0;
    if ( ++iState2 == 55 )
        iState2 = 0;
    piState[-2]         = iState1;
    piState[-1]         = iState2;
    return iRand >> 6;
#else
    return random() >> 6;
#endif
}


/*
 * Roll some dice.
 */
int dice( int number, int size )
{
    int idice;
    int sum;

    switch ( size )
    {
    case 0: return 0;
    case 1: return number;
    }

    for ( idice = 0, sum = 0; idice < number; idice++ )
  sum += number_range( 1, size );

    return sum;
}



/*
 * Simple linear interpolation.
 */
int interpolate( int level, int value_00, int value_32 )
{
    return value_00 + level * (value_32 - value_00) / 32;
}



/*
 * Removes the tildes from a string.
 * Used for player-entered strings that go into disk files.
 */
void smash_tilde( char *str )
{
    for ( ; *str != '\0'; str++ )
    {
  if ( *str == '~' )
      *str = '-';
    }

    return;
}



/*
 * Compare strings, case insensitive.
 * Return TRUE if different
 *   (compatibility with historical functions).
 */
bool str_cmp( const char *astr, const char *bstr )
{
    if ( astr == NULL )
    {
  bug( "Str_cmp: null astr.", 0 );
  return TRUE;
    }

    if ( bstr == NULL )
    {
  bug( "Str_cmp: null bstr.", 0 );
  return TRUE;
    }

    for ( ; *astr || *bstr; astr++, bstr++ )
    {
  if ( LOWER(*astr) != LOWER(*bstr) )
      return TRUE;
    }

    return FALSE;
}



/*
 * Compare strings, case insensitive, for prefix matching.
 * Return TRUE if astr not a prefix of bstr
 *   (compatibility with historical functions).
 */
bool str_prefix( const char *astr, const char *bstr )
{
    if ( astr == NULL )
    {
  bug( "Strn_cmp: null astr.", 0 );
  return TRUE;
    }

    if ( bstr == NULL )
    {
  bug( "Strn_cmp: null bstr.", 0 );
  return TRUE;
    }

    for ( ; *astr; astr++, bstr++ )
    {
  if ( LOWER(*astr) != LOWER(*bstr) )
      return TRUE;
    }

    return FALSE;
}



/*
 * Compare strings, case insensitive, for match anywhere.
 * Returns TRUE is astr not part of bstr.
 *   (compatibility with historical functions).
 */
bool str_infix( const char *astr, const char *bstr )
{
    int sstr1;
    int sstr2;
    int ichar;
    char c0;

    if ( ( c0 = LOWER(astr[0]) ) == '\0' )
  return FALSE;

    sstr1 = strlen(astr);
    sstr2 = strlen(bstr);

    for ( ichar = 0; ichar <= sstr2 - sstr1; ichar++ )
    {
  if ( c0 == LOWER(bstr[ichar]) && !str_prefix( astr, bstr + ichar ) )
      return FALSE;
    }

    return TRUE;
}



/*
 * Compare strings, case insensitive, for suffix matching.
 * Return TRUE if astr not a suffix of bstr
 *   (compatibility with historical functions).
 */
bool str_suffix( const char *astr, const char *bstr )
{
    int sstr1;
    int sstr2;

    sstr1 = strlen(astr);
    sstr2 = strlen(bstr);
    if ( sstr1 <= sstr2 && !str_cmp( astr, bstr + sstr2 - sstr1 ) )
  return FALSE;
    else
  return TRUE;
}



/*
 * Returns an initial-capped string.
 */
char *capitalize( const char *str )
{
    static char strcap[MAX_STRING_LENGTH];
    int i;

    for ( i = 0; str[i] != '\0'; i++ )
  strcap[i] = LOWER(str[i]);
    strcap[i] = '\0';
    strcap[0] = UPPER(strcap[0]);
    return strcap;
}


/*
 * Append a string to a file.
 */
void append_file( CHAR_DATA *ch, char *file, char *str )
{
    FILE *fp;

    if ( IS_NPC(ch) || str[0] == '\0' )
  return;

    fclose( fpReserve );
    if ( ( fp = fopen( file, "a" ) ) == NULL )
    {
  perror( file );
  send_to_char( "Could not open the file!\n\r", ch );
    }
    else
    {
  fprintf( fp, "[%5d] %s: %s\n",
      ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
  fclose( fp );
    }

    fpReserve = fopen( NULL_FILE, "r" );
    return;
}



/*
 * Reports a bug.
 */
void bug( const char *str, int param )
{
    char buf[MAX_STRING_LENGTH];

    if ( fpArea != NULL )
    {
  int iLine;
  int iChar;

  if ( fpArea == stdin )
  {
      iLine = 0;
  }
  else
  {
      iChar = ftell( fpArea );
      fseek( fpArea, 0, 0 );
      for ( iLine = 0; ftell( fpArea ) < iChar; iLine++ )
      {
    while ( getc( fpArea ) != '\n' )
        ;
      }
      fseek( fpArea, iChar, 0 );
  }

  sprintf( buf, "[*****] FILE: %s LINE: %d", strArea, iLine );
  log_string( buf );
/*
  if ( ( fp = fopen( "shutdown.txt", "a" ) ) != NULL )
  {
      fprintf( fp, "[*****] %s\n", buf );
      fclose( fp );
  }
*/
    }

    strcpy( buf, "[*****] BUG: " );
    sprintf( buf + strlen(buf), str, param );
    log_string( buf );
/* RT removed due to bug-file spamming 
    fclose( fpReserve );
    if ( ( fp = fopen( BUG_FILE, "a" ) ) != NULL )
    {
  fprintf( fp, "%s\n", buf );
  fclose( fp );
    }
    fpReserve = fopen( NULL_FILE, "r" );
*/

    return;
}



/*
 * Writes a string to the log.
 */
void log_string( const char *str )
{
    char *strtime;

    strtime                    = ctime( &current_time );
    strtime[strlen(strtime)-1] = '\0';
    fprintf( stderr, "%s :: %s\n", strtime, str );
    return;
}



/*
 * This function is here to aid in debugging.
 * If the last expression in a function is another function call,
 *   gcc likes to generate a JMP instead of a CALL.
 * This is called "tail chaining."
 * It hoses the debugger call stack for that call.
 * So I make this the last call in certain critical functions,
 *   where I really need the call stack to be right for debugging!
 *
 * If you don't understand this, then LEAVE IT ALONE.
 * Don't remove any calls to tail_chain anywhere.
 *
 * -- Furey
 */
void tail_chain( void )
{
    return;
}
@


1.185
log
@ttesting some posse resets
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.184 2004/07/31 05:14:16 boogums Exp $";
d253 1
d1659 1
d1672 1
d1682 1
a1686 1

@


1.184
log
@testing the resets code for the other clan halls
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.183 2004/07/07 04:11:03 boogums Exp $";
d1655 1
d1667 1
d1676 1
@


1.183
log
@ok the honor quick resets are in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.182 2004/07/07 03:53:31 boogums Exp $";
d1654 3
d1665 4
d1673 3
@


1.182
log
@still messing with honor
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.181 2004/07/07 03:36:29 boogums Exp $";
d1658 1
a1658 1
  
d1663 1
a1663 1
      if ( 
d1665 1
a1665 1
      || (honorIndex != NULL && pArea == honorIndex->area) 
d1668 1
a1668 1
      else if (pArea->nplayer == 0) 
@


1.181
log
@testing honor reset quickly
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.180 2004/07/07 03:09:37 boogums Exp $";
d1653 1
d1661 1
d1663 4
a1666 1
      if ( pRoomIndex != NULL && pArea == pRoomIndex->area )
a1670 8
//test for honor
      pRoomIndex = get_room_index( ROOM_VNUM_HONOR_INDEX );
      if ( pRoomIndex != NULL && pArea == pRoomIndex->area )
        pArea->age = 31 - 2;
      else if (pArea->nplayer == 0)
        pArea->empty = TRUE;

//end test
@


1.180
log
@no fuckin idea
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.179 2004/07/07 02:56:51 boogums Exp $";
d1650 2
a1651 1
  ||    pArea->age >= 31) && !pArea->freeze) {
d1660 1
d1662 1
a1662 1
    pArea->age = 15 - 2;
d1664 10
a1673 1
    pArea->empty = TRUE;
d1675 2
@


1.179
log
@testing honor hall fast resets
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.178 2004/04/25 00:57:47 boogums Exp $";
a1662 10
//adding honor clan hall resets
      pRoomIndex = get_room_index( ROOM_VNUM_HONOR );
      if ( pRoomIndex != NULL && pArea == pRoomIndex->area )
      {
        pArea->age = 15 - 2;
      }
      else if (pArea->nplayer == 0)
      {
        pArea->empty = TRUE;
      }
@


1.178
log
@ok lets try this
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.177 2003/11/27 23:09:07 boogums Exp $";
d1663 10
@


1.177
log
@adding staff crafter kit
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.176 2003/06/14 19:53:11 boogums Exp $";
d176 1
@


1.176
log
@adding the restrain spell to the infuse ability
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.175 2003/02/17 21:54:50 ndagger Exp $";
d168 1
@


1.175
log
@2/17/03 Nightdagger: basework for honor's clan skill, testing before wimpy changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.174 2002/12/05 05:16:57 boogums Exp $";
d102 1
@


1.174
log
@ok here goes the wand maker kit
and removing damage from pof while in wraith
*gulp* i hate messing with merc.h
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.173 2002/11/04 16:07:09 mud Exp $";
d128 1
@


1.173
log
@gsn_grab missed
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.172 2002/10/13 02:55:43 boogums Exp $";
d165 1
@


1.172
log
@sharpen skilll for dwarves going in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.171 2002/10/10 03:20:03 boogums Exp $";
d207 1
@


1.171
log
@ok all better now
corey
commented out the sharpen skill stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.170 2002/10/10 03:13:19 boogums Exp $";
d169 1
a169 1
//sh_int      gsn_sharpen;
@


1.170
log
@actobj interep.h merc.h wait oh shit gotta ocmment those out
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.169 2002/07/01 00:26:20 boogums Exp $";
d169 1
a169 1
sh_int      gsn_sharpen;
@


1.169
log
@ok adding the shadow stalker kit, to do some testing, will make
the kit live after tests
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.168 2002/06/03 18:30:44 rusty Exp $";
d169 1
@


1.168
log
@Setting limits on O resets
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.167 2002/05/22 18:00:40 rusty Exp $";
d250 1
@


1.167
log
@All gems end up in corpses.
All items stolen within the last 10*number_fuzzy(5) ticks go into corpses.
Items taken by steal, loot, heat metal and disarm get timers
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.166 2002/04/11 03:17:37 boogums Exp $";
d1766 12
@


1.166
log
@adding posse skill cuffs of justice
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.165 2002/04/05 15:24:28 boogums Exp $";
d2471 1
d2501 1
@


1.165
log
@5apr02
putting in the fence kit.  changes to do_sell in act_obj.c
the kit info in merc.h db.c and const.c
and a special.c change in spec_guard.  it checks to see
if the guard turns the other way cuz they're sooo cool
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.164 2001/12/08 02:08:53 poquah Exp $";
d203 1
@


1.164
log
@remove cstats stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.162 2001/12/04 17:54:51 rage Exp $";
d151 1
a151 1

@


1.163
log
@able to gate to your own charmies
@
text
@d1 1
a1 1
e***************************************************************************
d721 2
a722 2
    int i, num;
    char test;
d731 3
a733 2
       test = fread_letter(fp);
       if (test == '$')
d735 2
d738 2
a739 2
       cstat->clan = fread_number( fp );
       cstat->kills = fread_number( fp );
a2613 13

CSTAT_DATA *get_cstat_data ( int cstat_number )
{
	CSTAT_DATA *cstat;

	for ( cstat = cstat_first ; cstat != NULL ; cstat = cstat->next)
	{
		if (cstat->clan == cstat_number)
		   return cstat;
	}
	return NULL;
}

@


1.162
log
@Added in functionality to have observation rooms be part of the clan hall area instead of the target area
@
text
@d1 1
a1 1
/***************************************************************************
d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.161 2001/11/29 09:38:58 poquah Exp $";
d721 2
a722 2
    char buf[MAX_STRING_LENGTH];
    char *word;
d731 2
a732 3

       word = fread_word(fp);
       if ( word[0] == '$' )
a733 2
       cstat->clan = clan_lookup(word);
       cstat->kills = fread_number ( fp );
d735 2
a736 2
 sprintf(buf,"Cstat: %d kills %d",cstat->clan,cstat->kills);
 log_string(buf);
d2611 13
@


1.161
log
@working on cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.160 2001/11/29 09:23:02 poquah Exp $";
d1345 1
d1357 3
@


1.160
log
@add a quick and dirty cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.159 2001/11/11 17:29:11 rage Exp $";
a249 7

sh_int      honor_kills=0;
sh_int      posse_kills=0;
sh_int      warlock_kills=0;
sh_int      demise_kills=0;
sh_int      avarice_kills=0;
sh_int      zealot_kills=0;
@


1.159
log
@made some changes to wall of ice, spec_elemental_water, hydrophilia
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.158 2001/11/11 01:01:13 rage Exp $";
d249 9
@


1.158
log
@first insertion of wall of ice spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.157 2001/10/20 19:40:44 rage Exp $";
d248 1
@


1.157
log
@removed code_test ifdefs around random exits code
paladins can now take battlerager
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.156 2001/10/19 22:10:27 rage Exp $";
d247 1
@


1.156
log
@attempt to see if random romm exits works...contained within CODE_TEST ifdef's
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.155 2001/10/17 03:02:46 boogums Exp $";
a1934 1
#ifdef CODE_TEST
a1953 3
#else
      break;
#endif
@


1.155
log
@adding in the honor guard honor clan spell
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.154 2001/08/24 21:26:32 mud Exp $";
d1935 2
a1936 2
    break;
/*      if ( ( pRoomIndex = get_room_index( pReset->arg1 ) ) == NULL )
d1954 4
a1957 1
      break; */
@


1.154
log
@Increased MAX_STRING to perhaps alleave our OLC woes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.153 2001/08/05 22:47:36 guerrand Exp $";
d118 1
@


1.153
log
@Added 5 spells for warlock/witch kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.152 2001/08/04 15:54:46 guerrand Exp $";
d285 1
a285 1
#define     MAX_STRING  4000000
@


1.152
log
@IMMs no longer show up when wizi and entering portals.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.151 2001/07/30 04:51:48 guerrand Exp $";
d97 3
@


1.151
log
@Damage shield spells added.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.150 2001/07/29 04:54:18 guerrand Exp $";
d97 1
@


1.150
log
@More structure added for herbalism.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.149 2001/07/27 02:14:11 guerrand Exp $";
d97 4
@


1.149
log
@Added spirit caller kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.148 2001/07/15 20:01:20 boogums Exp $";
d97 1
@


1.148
log
@Adding the scribe do_scribe for the scribe kit
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.147 2001/07/04 15:22:24 guerrand Exp $";
d97 5
@


1.147
log
@Symbols don't stack, duration fixed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.146 2001/07/04 02:29:28 guerrand Exp $";
d149 1
@


1.146
log
@Hamstring done.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.145 2001/07/03 03:28:48 guerrand Exp $";
d98 4
@


1.145
log
@New druid spell - acclimate.
Kurjitsu will kick in a tad more often.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.144 2001/07/02 16:42:37 mud Exp $";
d98 1
@


1.144
log
@Making trash not become inventory for shopkeepers
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.143 2001/06/25 20:40:03 mud Exp $";
d98 1
@


1.143
log
@Item types and spec_words
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.142 2001/06/23 18:28:57 guerrand Exp $";
d1841 1
@


1.142
log
@Added skills and difficulties to recipes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.141 2001/06/22 23:45:54 guerrand Exp $";
d2327 5
@


1.141
log
@Added adamantite skin
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.140 2001/06/19 06:28:56 guerrand Exp $";
d746 2
@


1.140
log
@Fix is in for areas.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.139 2001/06/19 06:16:21 guerrand Exp $";
d103 1
@


1.139
log
@AReas is busted
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.138 2001/06/19 05:32:08 guerrand Exp $";
a3383 2
 send_to_char("Areas is busted.\n\r",ch);
    return;
@


1.138
log
@Improved size of area buffer to avoid crashes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.137 2001/06/19 01:38:41 guerrand Exp $";
d3383 3
@


1.137
log
@Added critical strikes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.136 2001/06/18 01:17:32 rage Exp $";
d3380 1
a3380 1
    char bigbuf[2*MAX_STRING_LENGTH];
@


1.136
log
@ Initial insertion of forging items.  Added new item type ITEM_FORGE.
 One can create "recipes" for these forges.  Each recipe is a list of
 objects that once placed inside the forge will create a bigger/better
 object.  Basically a better implementation of item parts.

-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.135 2001/06/17 18:53:40 guerrand Exp $";
d98 3
@


1.135
log
@Added steel skin and diamond skin for mage/wizard
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.134 2001/06/17 17:06:00 guerrand Exp $";
d71 3
d242 1
d297 1
d585 1
d711 1
a711 1
       if (cstat_first == NULL)
d724 41
d2562 3
d2566 7
@


1.134
log
@Fixed the haste bug in shaman drachlan special.
Added healing DOt functionality.
Added 'shield of faith' spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.133 2001/06/11 04:22:38 guerrand Exp $";
d95 2
@


1.133
log
@Fixed a little elementalist bug thereby they did 5000 damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.132 2001/06/11 01:17:01 rage Exp $";
d95 1
@


1.132
log
@added new spell "blade barrier"
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.131 2001/06/07 22:29:59 rage Exp $";
d1323 1
@


1.131
log
@Fixed up "Assemble" function a bit
Added in spells flameseek and started on wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.130 2001/06/07 16:24:49 rusty Exp $";
d213 1
@


1.130
log
@Reduced the number of favoreds to 20% instead of 60%, geeze!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.129 2001/06/07 15:32:08 mud Exp $";
d213 1
a213 1

@


1.129
log
@Changed to GC5.3 and OLC crash bug is gone
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.128 2001/06/06 23:49:23 mud Exp $";
d2303 1
a2303 1
      switch ( dice(1,20) )
@


1.128
log
@No clue why but this is the only thing that works
-rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.127 2001/06/06 23:20:13 mud Exp $";
a420 1
	GC_MALLOC(1);
@


1.127
log
@Took out 1 bite gc_malloc()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.126 2001/06/05 02:48:57 guerrand Exp $";
d421 1
@


1.126
log
@testing something with GC malloc
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.125 2001/06/05 02:42:42 guerrand Exp $";
a420 1
  /* test */ GC_MALLOC(1);
@


1.125
log
@Not sure why we're using GC in OLC, I always thought it didn't work.
Anyway, I'm going to try replacing the GC_malloc call for max-string
with something else.  Something about GC_malloc isn't working right in OLC.
I'm not sure what.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.124 2001/06/05 02:34:14 guerrand Exp $";
d42 1
a42 1
/*#define calloc(m,n) GC_MALLOC((m)*(n))*/
d421 1
d537 1
a537 1
      
@


1.124
log
@Trying to fix OLC>  Lowered string size to 40000
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.123 2001/06/05 02:25:31 guerrand Exp $";
d42 1
a42 1
#define calloc(m,n) GC_MALLOC((m)*(n))
@


1.123
log
@Increased MAX_STRING
GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.122 2001/06/05 01:34:21 rage Exp $";
d252 1
a252 1
#define     MAX_STRING  5000000
@


1.122
log
@ increased MAX_STRING to 4500000 from 400000.
this is just to attempt to get OLC back up, if it doesn't work, I'll back it out
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.121 2001/06/03 22:29:38 guerrand Exp $";
d252 1
a252 1
#define     MAX_STRING  4500000
@


1.121
log
@GMAN
More work on the flag system.
Integrating old and new flag systems for doors so we don't have to convert
everything manually.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.120 2001/06/03 21:42:41 guerrand Exp $";
d252 1
a252 1
#define     MAX_STRING  4000000
@


1.120
log
@Removed some extra error checking that would ahve short-circuited by door changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.119 2001/06/03 21:40:47 guerrand Exp $";
d1304 2
a1305 2
    pexit->exit_info  = fread_number(fp);
    /*locks     = fread_number( fp );*/
d1309 1
a1309 2
    /* This really isn't necessaryt any more **
    switch ( locks ) 
d1311 8
a1318 5
    case 1: pexit->exit_info = EX_ISDOOR;                break;
    case 2: pexit->exit_info = EX_ISDOOR | EX_PICKPROOF; break;
    case 3: pexit->exit_info = EX_ISDOOR | EX_NOPASS;    break;
    case 4: pexit->exit_info = EX_ISDOOR|EX_NOPASS|EX_PICKPROOF;
      break;
d1320 2
a1321 2
    **/

d1828 4
a1831 2
    pexit->exit_info = pReset->arg3; /* set up exit flags */
/*
a1848 1
 */
@


1.119
log
@
*holds breath*
This change should save door reset flags in their entirety, load them
that way, and then just set the exit_info in the doors to whatever
the reset value is.  Will it work?  Who knows.

I'm about to find out.
GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.118 2001/06/01 02:37:32 guerrand Exp $";
d1145 1
d1151 1
@


1.118
log
@Added special gargoyle stoneskin stuff.
GMan
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.117 2001/05/27 20:08:19 mud Exp $";
d1302 2
a1303 2
    pexit->exit_info  = 0;
    locks     = fread_number( fp );
d1307 2
a1308 1
    switch ( locks )
d1316 1
d1824 2
d1843 1
@


1.117
log
@stupid typo fix
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.116 2001/05/27 20:06:00 mud Exp $";
d94 1
a94 1

@


1.116
log
@Missing gsn declaration
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.115 2000/10/08 18:30:16 mud Exp $";
d96 1
a96 1
sh_int		gsn_aannointment;
@


1.115
log
@08OCT00 - Yahooo! adding the charm animal spell and swarm spells for the
          druid kit.  going to test now on olc.
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.114 2000/09/24 16:31:59 mud Exp $";
d96 1
@


1.114
log
@24SEP00 -
Added the charm_animal spell.  Mods made to const.c db.c mag2.c and magic.h
aaaand magic.c
Going to compile on OLC and test
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.113 2000/09/11 20:27:15 mud Exp $";
d135 2
a136 1

@


1.113
log
@random weapon flag chance reduced
myrm kit not for yinns
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.112 2000/09/11 20:07:28 mud Exp $";
d132 4
@


1.112
log
@Random number generator checkup
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.111 2000/09/02 22:55:55 mud Exp $";
d2285 1
a2285 1
  if ( favored && (number_percent() * number_percent()) <= 3 )
@


1.111
log
@02SEP00 - Added nuke_pets to update.c to get rid of the warhorses
          when the life timer expires - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.110 2000/08/24 19:23:57 mud Exp $";
d2285 1
a2285 1
  if ( favored && (number_percent() * number_percent()) <= 4 )
@


1.110
log
@adding in double xp
fixed little bug with grenades not being correctly loaded
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.109 2000/05/29 19:43:54 mud Exp $";
d130 2
a131 1

@


1.109
log
@include gladiator.h
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.108 2000/05/26 01:46:26 mud Exp $";
d2251 1
@


1.108
log
@team gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.107 2000/05/25 03:06:06 mud Exp $";
d39 1
@


1.107
log
@working on team gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.106 2000/05/13 21:55:10 mud Exp $";
d477 1
@


1.106
log
@Gladiator Combat - Intense!
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.105 2000/04/14 21:24:32 mud Exp $";
d474 3
@


1.105
log
@Testing new calloc() substitution
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.104 2000/04/06 23:45:08 mud Exp $";
d92 1
d466 8
@


1.104
log
@cstat work fun fun fun
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.103 2000/04/06 23:43:01 mud Exp $";
d40 2
@


1.103
log
@working on cstat
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.102 2000/04/06 23:35:07 mud Exp $";
d659 1
a659 1
    char word[30];
d669 1
a669 1
       word = fread_string(fp);
@


1.102
log
@Working on CSTAT
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.101 2000/03/23 19:37:14 mud Exp $";
d659 1
d669 2
a670 2
       cstat->clan = clan_lookup(fread_string(fp));
       if ( cstat->clan[0] == '$' )
d672 1
@


1.101
log
@Made more than just 0d0 weapons not get vorpal flags.  Now
# of dice and # of sides must both be > 1
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.100 2000/03/23 15:16:27 mud Exp $";
d220 1
a658 1
    char *word;
d662 5
a666 7
       word = fread_word( fp );
		    
 sprintf(buf,"Cstat: %s ",word);
 log_string(buf);
       
       if (!str_cmp(word,"$"))
	  break;
d668 4
a671 9
       if (!str_cmp(word,"Clan"))
       {
          /* Create New Cstat Index */
          cstat   = GC_MALLOC( sizeof(*cstat) );

          cstat->kills = fread_number ( fp );
 sprintf(buf,"Cstat: %d ",cstat->kills);
 log_string(buf);
          cstat->clan = clan_lookup(fread_string(fp));
d676 4
a679 4
          if (cstat_first == NULL)
             cstat_first = cstat;
          if (cstat_last  != NULL )
             cstat_last->next = cstat;
d681 2
a682 2
          cstat_last = cstat;
          cstat->next = NULL;
d684 1
a684 2
          break;
       }
d3337 1
@


1.100
log
@ Weapons that are have a v1 or v2 of 0 will no longer be flagged vorpal
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.99 2000/03/20 22:26:49 mud Exp $";
d2280 1
a2280 1
	  if ( obj->value[4] == 0  && ( obj->value[1] != 0 && obj->value[2] != 0))
@


1.99
log
@lower chance of vorpal,favors,holy poping
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.98 2000/03/15 16:24:50 mud Exp $";
d2280 1
a2280 1
	  if ( obj->value[4] == 0 )
@


1.98
log
@ Added in new defense skill "nether shield" for nethermancers

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.97 2000/03/06 16:50:19 mud Exp $";
d2272 2
a2273 1
  if ( favored && (number_percent() * number_percent()) <= 6 )
@


1.97
log
@apply types and change affects to use them for scondary etc
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.96 2000/03/06 15:59:19 mud Exp $";
d179 1
@


1.96
log
@adjust affects
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.95 2000/02/27 18:13:43 mud Exp $";
d1858 1
a1858 1
    affect_remove( mob, mob->affected, FALSE );
@


1.95
log
@ mods to weapons.eql dump, shows dam type and material type now

  Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.94 2000/01/21 00:53:18 mud Exp $";
d1858 1
a1858 1
    affect_remove( mob, mob->affected );
@


1.94
log
@Added new spelll confusion.
Confuses victims sense of direction
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.93 1999/12/22 17:11:30 mud Exp $";
d3552 1
a3552 1
        fprintf(fp,"%d %d \"%s\" w=%d v=%d EF(%s) AF(%s) WF(%s) %dD%d(%d) a=\"%s\"\n",
d3555 1
@


1.93
log
@Took out the while loop that eliminates 0% in number_percent().
People can deal...
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.92 1999/12/21 23:07:49 mud Exp $";
d200 1
@


1.92
log
@Changed number_percent() to use random() and a remainder().
Should reduce CPU calls and flatten out the distribution.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.91 1999/12/04 04:34:25 mud Exp $";
a3768 1
  bool i=FALSE;
a3769 2
 while(!i)
 {
a3770 5
  if( foo != 0 )
  {
    i = TRUE;
  }
 }
@


1.91
log
@debugging why game isnt booting
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.90 1999/11/23 21:44:16 mud Exp $";
d24 1
d3760 1
d3763 1
a3763 2
    while ( (percent = number_mm() & (128-1) ) > 99 )
  ;
d3766 15
@


1.90
log
@Upped the alarm() time for DNS lookups and added a global dns_buf
var to pass to the SIG_ALRM dummy() function.  Any IP that sets off
the alarm() will automatically be added to the dns_list.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.89 1999/11/23 19:52:13 mud Exp $";
d415 2
@


1.89
log
@Added a linked list for putting in IP's or IP blocks that should
not have their DNS checked against.  This will keep sites with crappy
DNS servers from lagging the game.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.88 1999/11/07 02:04:31 mud Exp $";
d79 1
@


1.88
log
@Toasted OLc with wear_timer in here, removed for now
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.87 1999/11/07 01:37:44 mud Exp $";
d280 1
d590 1
@


1.87
log
@More for the wear_timer, want to make it modifieable on OLC
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.86 1999/11/02 22:08:24 mud Exp $";
a957 1
  pObjIndex->wear_timer   = fread_number( fp );
a2188 1
    obj->wear_timer   = pObjIndex->wear_timer;
a2366 1
    clone->wear_timer = parent->wear_timer;
@


1.86
log
@Just added some GSN's (fade and vision) and made some minor adjustments to the vision potion effect.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.85 1999/11/02 07:51:18 mud Exp $";
d958 1
d2190 1
d2369 1
@


1.85
log
@Add 'hex' and 'fear' for Mummies
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.84 1999/10/31 02:23:24 mud Exp $";
d179 1
@


1.84
log
@new remort 'mummy' with skill 'breathe'
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.83 1999/09/28 23:20:33 mud Exp $";
d165 1
d167 1
@


1.83
log
@Myrmidon
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.82 1999/09/16 18:19:53 mud Exp $";
d163 1
@


1.82
log
@Do not print NOIDENT items into eqlists
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.81 1999/08/23 19:19:23 mud Exp $";
d135 1
@


1.81
log
@Not sure why these are changed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.80 1999/08/23 03:34:42 mud Exp $";
d3398 2
d3551 1
@


1.80
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.79 1999/08/21 21:22:46 mud Exp $";
d89 1
@


1.79
log
@Savant stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.78 1999/08/13 18:48:32 mud Exp $";
d89 1
@


1.78
log
@Basic stuff for alchemists, saves changes, magelabs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.77 1999/08/12 01:03:56 mud Exp $";
d2263 1
d2265 4
a2268 2
		SET_BIT( obj->value[4], WEAPON_VORPAL ); break;
      case 3:
d2271 7
a2277 1
		SET_BIT( obj->value[4], WEAPON_HOLY ); break;
d2280 4
a2284 3

      sprintf(log_buf,"Favored: %s vnum %d after %d",
              obj->name,obj->pIndexData->vnum,weapons_popped);
@


1.77
log
@Nethermancers are in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.76 1999/08/11 05:27:32 mud Exp $";
d171 1
@


1.76
log
@Added flag repops
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.75 1999/07/24 07:06:32 mud Exp $";
d169 3
a171 1
sh_int	    gsn_communion; 
@


1.75
log
@Squish Squish cstat
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.74 1999/07/24 06:55:25 mud Exp $";
d2256 14
a2269 1
      SET_BIT( obj->value[4], WEAPON_FAVORED );
@


1.74
log
@Tracking bug in cstat
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.73 1999/07/24 06:24:27 mud Exp $";
d644 1
a644 1
       word   = feof( fp ) ? "End" : fread_word( fp );
d648 5
a652 1
       switch ( UPPER(word[0]) )
d654 2
a655 5
          case 'C':
             if (!str_cmp(word,"Clan"))
             {
                /* Create New Cstat Index */
                cstat   = GC_MALLOC( sizeof(*cstat) );
d657 1
a657 1
                cstat->kills = fread_number ( fp );
d660 1
a660 1
                cstat->clan = clan_lookup(fread_string(fp));
d665 4
a668 4
                if (cstat_first == NULL)
		   cstat_first = cstat;
                if (cstat_last  != NULL )
                   cstat_last->next = cstat;
d670 2
a671 2
                cstat_last = cstat;
                cstat->next = NULL;
d673 1
a673 2
                break;
             }
@


1.73
log
@crashing olc constantly
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.72 1999/07/24 06:03:32 mud Exp $";
d676 1
@


1.72
log
@debugging load_cstat
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.71 1999/07/24 05:55:04 mud Exp $";
d656 3
a658 1
                /* Read First Number: Clan Number */
a659 3

                /* Read Second Number: Clan Kills */
                cstat->kills = fread_number ( fp );
@


1.71
log
@bug Bug BUg
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.70 1999/07/24 05:49:04 mud Exp $";
d639 1
d646 2
d662 2
a663 3
 sprintf(log_buf,"Cstat: %d kills %d",cstat->clan,
       cstat->kills);
 log_string(log_buf);
@


1.70
log
@Debug loading of cstat to see whats loading
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.69 1999/07/24 05:28:51 mud Exp $";
d659 2
a660 2
 sprintf(log_buf,"Cstat: %d %s kills %d",cstat->clan,
       clan_table[cstat->clan].name,cstat->kills);
@


1.69
log
@Changing load of cstat
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.68 1999/07/24 05:14:54 mud Exp $";
d658 4
@


1.68
log
@Removed a coupel unused declares in do_cstat and do_eqlist
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.67 1999/07/24 04:59:56 mud Exp $";
d654 1
a654 1
                cstat->clan = fread_number(fp);
@


1.67
log
@Cstat Adding
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.66 1999/07/21 15:18:06 mud Exp $";
a638 1
    char buf[MAX_STRING_LENGTH];
a3322 1
   OBJ_DATA *obj;
@


1.66
log
@One last touch up to eqlist and shes ready for G
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.65 1999/07/21 15:15:36 mud Exp $";
d67 3
d257 1
d528 1
d633 8
d642 31
@


1.65
log
@Man too much PERL, was trying to buf = "string" instead of strcpy
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.64 1999/07/21 07:10:39 mud Exp $";
d3354 1
a3354 1
       buf2 = affect_loc_name( paf->location );
d3442 1
a3442 1
       buf2 = affect_loc_name( paf->location );
@


1.64
log
@Shortened long Affect Locations just for my Boss
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.63 1999/07/21 06:31:53 mud Exp $";
d3356 1
a3356 1
          buf2 = "str";
d3358 1
a3358 1
          buf2 = "int";
d3360 1
a3360 1
          buf2 = "wis";
d3362 1
a3362 1
          buf2 = "dex";
d3364 1
a3364 1
          buf2 = "con";
d3366 1
a3366 1
          buf2 = "dam";
d3368 1
a3368 1
          buf2 = "hit";
d3370 1
a3370 1
	  buf2 = "ac";
d3444 1
a3444 1
          buf2 = "str";
d3446 1
a3446 1
	 buf2 = "int";
d3448 1
a3448 1
          buf2 = "wis";
d3450 1
a3450 1
          buf2 = "dex";
d3452 1
a3452 1
          buf2 = "con";
d3454 1
a3454 1
          buf2 = "dam";
d3456 1
a3456 1
          buf2 = "hit";
d3458 1
a3458 1
	  buf2 = "ac";
@


1.63
log
@Fix aaffects on weapons
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.62 1999/07/21 06:23:07 mud Exp $";
d3353 19
a3371 2
       strcat( buf, " ");
       strcat( buf, affect_loc_name( paf->location ));
d3441 19
a3459 2
         strcat( buf, " ");
         strcat( buf, affect_loc_name( paf->location ));
@


1.62
log
@Affects section added to Armor and Weapons
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.61 1999/07/21 06:16:57 mud Exp $";
d3428 1
a3428 1
        fprintf(fp,"%d %d \"%s\" w=%d v=%d EF(%s) AF() WF(%s) %dD%d(%d) a=\"%s\"\n",
d3432 1
@


1.61
log
@Think I got it
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.60 1999/07/21 06:06:08 mud Exp $";
d3351 1
a3351 1
       sprintf(buf2, "%s %d",buf,paf->modifier);
d3417 11
@


1.60
log
@Trying to fix this stupid affects
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.59 1999/07/21 06:01:38 mud Exp $";
d3288 1
a3348 1
    /*
d3352 2
a3353 2
       strcpy( buf, affect_loc_name( paf->location ));
       */
d3355 1
@


1.59
log
@twiddle
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.58 1999/07/21 05:57:14 mud Exp $";
d3345 1
@


1.58
log
@Guerrand owe me lots of sex for doing thi
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.57 1999/07/21 05:53:42 mud Exp $";
d3353 1
a3353 1
       strcat( buf, paf->location);
@


1.57
log
@bug squish squish
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.56 1999/07/21 05:48:36 mud Exp $";
a3344 1
   strcpy(buf," ");
d3351 1
a3351 1
       strcpy( buf, buf2);
@


1.56
log
@eqlist eqlist eqlist
-poqpoq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.55 1999/07/21 05:45:38 mud Exp $";
d3345 1
@


1.55
log
@Damn it
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.54 1999/07/21 05:42:35 mud Exp $";
d3287 1
a3287 2
   char buf[MAX_INPUT_LENGTH];
   char buf2[MAX_INPUT_LENGTH];
@


1.54
log
@debug crash in eqlist
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.53 1999/07/21 05:37:28 mud Exp $";
d3348 1
a3350 1
	  /*
@


1.53
log
@Fixing Affect Modifier
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.52 1999/07/21 05:31:20 mud Exp $";
d3350 1
d3353 1
@


1.52
log
@Add Modified for Affect to Eqlist
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.51 1999/07/21 05:05:28 mud Exp $";
d3288 1
d3348 1
a3348 1
       if (paf->modified > 0)
d3350 2
a3351 1
       strcat( buf, paf->modified);
@


1.51
log
@Try Affects in Armor
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.50 1999/07/21 03:47:32 mud Exp $";
d3347 4
a3350 2
       sprintf( buf, "%s",
	affect_loc_name( paf->location ));
@


1.50
log
@Declare the damn variable Poq you idiot
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.49 1999/07/21 03:41:34 mud Exp $";
d3282 1
d3287 1
a3287 1
   long acount;
d3345 6
a3350 1
    fprintf(fp,"%d %d \"%s\" wear=%s w=%d v=%d EF(%s) %d/%d/%d/%d AF() a=\"%s\"\n", 
d3356 1
@


1.49
log
@Eqlist ALL added
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.48 1999/07/14 18:13:33 mud Exp $";
d3287 1
@


1.48
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: db.c,v 1.38 1999/07/12 05:13:58 mud Exp $";
d3298 3
a3300 1
   if (!str_prefix("all",arg1))
d3302 6
a3307 2
      /* open file */
      fp = fopen("eqlist.eql","w");
d3309 2
a3310 11
      nMatch = 0;
      for (vnum = 0; nMatch < top_obj_index; vnum++)
         if ((pObjIndex = get_obj_index(vnum)) != NULL)
	 {
            nMatch++;
            if (pObjIndex->item_type == ITEM_WEAPON) 
	    {
	    }
         }
      fclose(fp);
   }
d3312 1
a3312 1
   if (!str_prefix("armor",arg1))
a3313 3
      /* open file */
      fp = fopen("armor.eql","w");
 
a3351 1
      fclose(fp);
d3354 1
a3354 1
   if (!str_prefix("weapon",arg1))
a3355 3
      /* open file */
      fp = fopen("weapons.eql","w");

a3412 1
     fclose(fp);
d3414 3
@


1.47
log
@Eqlist for armor
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.46 1999/07/13 06:59:35 mud Exp $ */
@


1.46
log
@Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.45 1999/07/13 06:53:26 mud Exp $ */
d3326 1
a3326 1
		 [ObjIndex->item_type == ITEM_LIGHT ||
@


1.45
log
@Told you I dont work well under pressure, I make typos  :P
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.44 1999/07/13 06:49:49 mud Exp $ */
a3328 1
		 (pObjIndex->wear_flags & acount) &&
@


1.44
log
@Armor EQlist
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.43 1999/07/13 04:51:47 mud Exp $ */
d3350 1
a3350 1
    fprintf(fp,"%d %d \"%s\" wear=%s w=%d v=%d EF(%s) %d\/%d\/%d\/%d AF() a=\"%s\"\n", 
a3358 1
    }
@


1.43
log
@Eqlist - Armor
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.42 1999/07/13 02:27:54 mud Exp $ */
d3286 1
d3319 1
a3319 1

d3325 6
a3330 5
            if ((pObjIndex->item_type == ITEM_LIGHT ||
		pObjIndex->item_type == ITEM_ARMOR ||
		pObjIndex->item_type == ITEM_CLOTHING ||
		pObjIndex->item_type == ITEM_JEWELRY) &&
		pObjIndex->level < 52)
d3332 19
a3350 1
    fprintf(fp,"%d %d \"%s\" w=%d v=%d EF(%s) %d\/%d\/%d\/%d AF(%s) a=\"%s\"\n", 
d3352 1
a3352 1
    pObjIndex->weight,pObjIndex->cost,
d3359 1
@


1.42
log
@opps missing ,
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.41 1999/07/13 02:25:13 mud Exp $ */
a3308 8
               fprintf(fp,"%d %d \"%s\" w=%d v=%d EF(%s) WF(%s) %dD%d(%d) a=\"%s\"\n",
	pObjIndex->vnum,pObjIndex->level,pObjIndex->short_descr,
        pObjIndex->weight,pObjIndex->cost,
        extra_bit_name(pObjIndex->extra_flags),
        weapon_bit_name(pObjIndex->value[4]),
        pObjIndex->value[1],pObjIndex->value[2],
        ((1 + pObjIndex->value[2]) * pObjIndex->value[1] / 2),
        pObjIndex->area->name);
d3314 28
d3393 1
a3393 1
        fprintf(fp,"%d %d \"%s\" w=%d v=%d EF(%s) WF(%s) %dD%d(%d) a=\"%s\"\n",
@


1.41
log
@Guerrand owes me big for this eqlist
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.40 1999/07/13 02:21:46 mud Exp $ */
d3363 1
a3363 1
       fprintf(fp,"%s\n"wtype);
@


1.40
log
@EQLIST
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.39 1999/07/12 20:49:41 mud Exp $ */
d3283 2
a3284 1
   int vnum,nMatch = 0;
@


1.39
log
@Work on EQLIST
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.38 1999/07/12 05:13:58 mud Exp $ */
d3326 37
d3369 1
d3382 2
a3383 1
      fclose(fp);
@


1.38
log
@Eqlist for All
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.37 1999/07/12 03:59:00 mud Exp $ */
d3308 1
a3308 1
               fprintf(fp,"%d %d %s w=%d v=%d EF(%s) WF(%s) %dD%d(%d) a=\n",
d3313 3
d3334 1
a3334 1
	       fprintf(fp,"%d %d %s w=%d v=%d EF(%s) WF(%s) %dD%d(%d) a=\n",
d3340 2
a3341 1
	   ((1 + pObjIndex->value[2]) * pObjIndex->value[1] / 2));
@


1.37
log
@EQLIST for Weapons
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.36 1999/07/12 03:14:56 mud Exp $ */
d3294 24
a3320 1
      fclose(fpReserve);
@


1.36
log
@Eqlist
-poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.35 1999/07/12 02:49:17 mud Exp $ */
d3305 1
a3305 1
            if ((item_type_name(pObjIndex) == ITEM_WEAPON) &&
d3310 1
a3310 1
	   get_true_weight(pObjIndex),pObjIndex->cost,
d3320 1
a3320 1
																																	}
@


1.35
log
@Eqlist generator
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.34 1999/06/20 20:29:22 mud Exp $ */
a3279 1
   int count,count2,num_pcs,aff_count;
a3281 1
   AFFECT_DATA *af;
d3305 1
a3305 1
            if ((item_type_name(pObjIndex) == ITEM WEAPON) &&
d3314 1
a3314 1
	   (1 + pObjIndex->value[2]) * pObjIndex->value[1] / 2));
@


1.34
log
@Bladesinger
Battlerager
Done
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.33 1999/05/26 17:58:34 mud Exp $ */
d3278 45
@


1.33
log
@Added ITEM_TRAP to the item type check so trap components
will not give a "bad type" bug upon loading.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.32 1999/05/26 03:27:30 mud Exp $ */
d86 2
@


1.32
log
@Changes to add in garotte item types and add the garotte
skill to assassins.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.31 1999/05/12 22:19:47 mud Exp $ */
d2161 1
@


1.31
log
@Ack variable name typo fix.
-R
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.30 1999/05/12 22:18:05 mud Exp $ */
d87 1
@


1.30
log
@Reset to 0 of weapons_popped when a favored pops.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.29 1999/05/12 22:16:52 mud Exp $ */
d2206 1
a2206 1
      log_string(buf);
@


1.29
log
@Added global weapons counter for favored.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.28 1999/05/12 22:06:03 mud Exp $ */
d2207 1
@


1.28
log
@Logging when a Favored weapon is created.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.27 1999/03/24 23:22:54 mud Exp $ */
d84 1
a2100 1
  char buf[MAX_STRING_LENGTH];
d2195 1
d2204 2
a2205 1
      sprintf(buf,"Favored: %s vnum %d",obj->name,obj->vnum);
@


1.27
log
@upped the % for ?? flag chance by .2%
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.26 1999/03/15 17:36:14 mud Exp $ */
d2100 1
d2201 1
d2203 3
@


1.26
log
@fixed 'dust storm' to actually wear off when you die
Made race based affects come back in raw_kill.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.25 1999/03/14 16:56:25 mud Exp $ */
d2199 1
a2199 1
  if ( favored && (number_percent() * number_percent()) <= 4 )
@


1.25
log
@Made those WEAPON_FAVORED flags a little less friggin common.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.24 1999/01/12 20:24:27 mud Exp $ */
d87 1
@


1.24
log
@Added stuff for wu jen kit.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.23 1998/12/23 16:51:32 mud Exp $ */
d2198 1
a2198 1
  if ( favored && number_percent() <= 2 )
@


1.23
log
@Bunch of changes for rogues, including new skill and pther improvements
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.22 1998/12/15 22:17:21 mud Exp $ */
d94 1
@


1.22
log
@Spies/Wrymslayers
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.21 1998/12/12 01:20:53 mud Exp $ */
d85 1
@


1.21
log
@Error checking
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.20 1998/12/09 00:33:19 mud Exp $ */
d85 1
@


1.20
log
@Ninjas
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.19 1998/12/08 23:12:08 mud Exp $ */
d85 1
@


1.19
log
@A
Bugs fixed.  Prophets added
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.18 1998/12/08 01:54:11 mud Exp $ */
d85 2
@


1.18
log
@barbarians are done
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.17 1998/12/05 21:44:04 mud Exp $ */
d85 1
@


1.17
log
@Kits!
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.16 1998/11/28 07:49:32 mud Exp $ */
d85 2
@


1.16
log
@favored flag
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.15 1998/11/22 10:36:35 mud Exp $ */
d93 1
@


1.15
log
@Added wizards
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.14 1998/11/22 08:04:43 mud Exp $ */
d1575 1
a1575 1
                   LEVEL_HERO - 1) );
d1614 1
a1614 1
          obj = create_object( pObjIndex, number_fuzzy(obj_to->level) );
d1677 1
a1677 1
    obj = create_object( pObjIndex, olevel );
d1693 1
a1693 1
        LEVEL_HERO - 1));
d2086 1
a2086 1
void ObjIndexToInstance ( OBJ_DATA *obj, OBJ_INDEX_DATA *pObjIndex, int level )
d2188 3
d2222 1
a2222 1
OBJ_DATA *create_object( OBJ_INDEX_DATA *pObjIndex, int level )
d2235 1
a2235 1
    ObjIndexToInstance (obj,pObjIndex,level);
@


1.14
log
@Infiltrate coded.
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.13 1998/11/22 02:05:13 mud Exp $ */
d85 4
@


1.13
log
@Crusader spells
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.12 1998/11/20 15:34:37 mud Exp $ */
d87 2
@


1.12
log
@fixed { in area command that color code messed up.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.11 1998/10/20 00:42:30 mud Exp $ */
d86 1
@


1.11
log
@Races
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.10 1998/10/05 09:10:25 mud Exp $ */
d3201 1
a3201 1
        sprintf (buf,"%s%-38s",area->under_develop ? "*":"",area->credits);
@


1.10
log
@C

Added ability to flag an entrei area as no-transport.
Set any mob in the area to act_notrans and it's automatic from there.
Saves us the annoyance of converting area files formats.
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.9 1998/10/05 06:17:40 mud Exp $ */
d87 1
@


1.9
log
@C

Added spellcraft
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.8 1998/08/30 03:33:34 mud Exp $ */
d593 1
@


1.8
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.7 1998/08/20 21:05:30 mud Exp $ */
d84 2
@


1.7
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.6 1998/08/17 20:05:00 mud Exp $ */
d3169 1
a3169 1
  if (IS_IMMORTAL (ch) && IS_SET (ch->comm,COMM_DISP_VNUM)) 
@


1.6
log
@Elementalists and some of their spells added.
Material table begun.

-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.5 1998/08/10 19:41:21 mud Exp $ */
d93 2
d141 1
a141 1
 
d158 2
@


1.5
log
@* Starter code for 'feign death'
* Protection neutral added
* Fixed bug with vampires
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.4 1998/08/10 05:32:14 mud Exp $ */
d153 3
a155 1

@


1.4
log
@* Added wound transfer spell
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.3 1998/08/07 20:19:56 mud Exp $ */
d152 1
@


1.3
log
@Room affects stuff for traps.
Bleed/vampire changes.
swim/scan start at 50% and 50%up for free for existing characters.
moved trap to after trip in interp list for grandfathered use
- Both of Us
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.2 1998/08/05 08:14:34 mud Exp $ */
d151 1
a151 1

@


1.2
log
@* Added changing weights for warp
* Also added a ->warps field to objects ... the more you warp
  something the greater the chances of blowing it up.
  -Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: db.c,v 1.1 1998/06/16 17:49:18 mud Exp $ */
d94 1
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d2076 1
a2076 1

@
