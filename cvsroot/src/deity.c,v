head	1.59;
access;
symbols;
locks; strict;
comment	@ * @;


1.59
date	2003.09.28.01.58.37;	author ndagger;	state Exp;
branches;
next	1.58;

1.58
date	2003.09.21.15.07.55;	author boogums;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.25.01.34.23;	author boogums;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.19.03.32.09;	author ndagger;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.09.01.42.00;	author ndagger;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.14.05.54.07;	author ndagger;	state Exp;
branches;
next	1.53;

1.53
date	2003.04.14.05.35.50;	author ndagger;	state Exp;
branches;
next	1.52;

1.52
date	2003.04.14.04.36.14;	author ndagger;	state Exp;
branches;
next	1.51;

1.51
date	2002.10.07.08.22.05;	author ndagger;	state Exp;
branches;
next	1.50;

1.50
date	2002.10.04.15.10.33;	author ndagger;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.22.20.01.03;	author rage;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.20.21.22.08;	author rage;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.20.21.09.08;	author rage;	state Exp;
branches;
next	1.46;

1.46
date	2001.11.28.19.09.41;	author poquah;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.28.19.08.42;	author poquah;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.08.23.16.02;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2000.09.02.02.29.59;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2000.08.16.15.26.21;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2000.08.13.04.00.30;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2000.08.12.22.56.20;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2000.08.12.18.37.53;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2000.08.12.18.26.02;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2000.08.12.04.46.01;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2000.08.12.04.36.01;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2000.08.12.04.33.39;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2000.08.11.23.21.52;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2000.08.11.23.12.27;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.11.22.53.44;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2000.05.26.00.52.53;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2000.05.26.00.35.08;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.26.00.22.21;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.25.23.47.29;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.18.19.50.55;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.12.01.48.13;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.28.18.43.31;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.18.21.01.45;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.18.19.50.23;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.18.18.47.10;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.12.14.36.34;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	99.12.14.22.06.39;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	99.12.14.22.02.39;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	99.11.03.19.52.43;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	99.10.09.17.16.42;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	99.08.23.03.34.43;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	99.08.11.02.27.12;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	99.08.10.23.00.55;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	99.07.14.18.13.36;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	99.03.03.18.43.32;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.11.22.02.05.13;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.11.17.23.20.10;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.10.19.01.39.31;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.10.18.19.42.05;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.10.18.19.40.36;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.10.18.19.12.25;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.10.18.18.59.20;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.10.18.18.57.32;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.09.22.15.56.21;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.20.21.05.30;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.20;	author mud;	state Exp;
branches;
next	;


desc
@@


1.59
log
@09/27/03 Nightdagger:  Bug fix, sac points drain again.  Good one, Boogs!
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.  Right?                                          *
 ***************************************************************************/

static char rcsid[] = "$Id: deity.c,v 1.58 2003/09/21 15:07:55 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "merc.h"
#include "tables.h"
#include "recycle.h"
#include "lookup.h"

DECLARE_DO_FUN(do_recall  );
DECLARE_DO_FUN(do_rescue  );
DECLARE_DO_FUN(do_look  );

bool recall	args( ( CHAR_DATA *ch, char *argument, bool fPray ) );

void do_pledg( CHAR_DATA *ch, char *argument )
{
   send_to_char("You must type the full command to change your pledge.\n\r",ch);
   return;
}

void do_pledge( CHAR_DATA *ch, char *argument )
{
    char arg1[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    int deity;

    argument = one_argument( argument, arg1 );

    if ( arg1[0] == '\0' )
    {
	if(ch->pcdata->deity_timer > 0 ) 
	{
          sprintf(buf, "You will change deities in %d ticks.", ch->pcdata->deity_timer);
          send_to_char(buf, ch);
        }
        else
          send_to_char( "Syntax: pledge <deity>\n\r",ch);
        
        return;
    }
/* ADDED by Nightdagger on 04/13/03 */

   if ( deity_lookup(arg1) == deity_lookup("almighty") )
   {
      send_to_char("The Almighty chooses you...you do not choose the Almighty.\n\r",ch);
      return;
   }


    /*
    if ( ch->pcdata->deity > 0 && !IS_IMMORTAL(ch) )
    {
	sprintf(buf,"You already worship %s.\n\r",
		deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,ch);
	return;
    }
     */

    if ( (deity = deity_lookup(arg1)) == -1)
    {
	send_to_char("You must pick an existing deity.  See 'help deity' for"
			" choices.\n\r",ch);
	return;
    }

    if ( !is_clan(ch) && deity_table[deity].clan)
    {
	sprintf(buf,"%s can only be worshiped by those in the clan system.\n\r",
		deity_table[deity].pname);
	send_to_char(buf,ch);
	return;
    }

    if ( ((ch->played + (int) (current_time - ch->logon)) 
	  - ch->pcdata->switched) 
		/ 3600 < 1 && !IS_IMMORTAL(ch))
    {
        sprintf(buf,"%s doubts the tenacity of your pledge.\n\r",
                deity_table[deity].pname);
        return;
    }

 /*  REMOVED by Nightdagger on 04/13/03

   if(ch->pcdata->deity != 0)
       ch->pcdata->switched = ch->played;
    ch->pcdata->new_deity = deity;
    ch->pcdata->deity_timer = 90;
    ch->pcdata->sac = 0;
    sprintf(buf,"You will be  a follower of %s in %d ticks..\n\r",deity_table[deity].pname, ch->pcdata->deity_timer);
    send_to_char(buf,ch);
    return;
*/

   sprintf(buf,"You are now a follower of %s.\n\r",deity_table[deity].pname);
   send_to_char(buf,ch);
   ch->pcdata->deity = deity;
   if ( ch->clan == clan_lookup("zealot") && ch->pcdata->deity != deity_lookup("almighty") )
   {
     send_to_char("Unbeliever!  Taste the Wrath of the Almighty!\n\r",ch);
     ch->clan = clan_lookup("outcast");
     ch->pcdata->learned[skill_lookup("annointment")] = 0;
     ch->pcdata->rank = 0;
     ch->pcdata->outcT = 2000; 
     ch->pcdata->node = 0;
     if ( IS_SET(ch->pcdata->clan_flags, CLAN_ALLOW_SANC) )
         REMOVE_BIT(ch->pcdata->clan_flags,  CLAN_ALLOW_SANC);
     char_from_room(ch);
     char_to_room(ch,get_room_index(ROOM_VNUM_MATOOK));
     clear_mount(ch);
     do_look(ch, "auto");
   }
   return;



}

bool has_gift( CHAR_DATA *ch, int gift)
{
  int gn;
  bool found = FALSE;

  if( gift == MAX_GIFTS)
	return found;

  for(gn = 0; gn < MAX_GIFT; gn++)
  {
    if(deity_table[ch->pcdata->deity].gifts[gn] == NULL)
	return found;
    if(!str_cmp(gift_table[gift].name,deity_table[ch->pcdata->deity].gifts[gn]))
	found = TRUE;
  }

  return found;
}

bool is_aligned( CHAR_DATA *ch )
{
  bool matches = FALSE;

  switch(deity_table[ch->pcdata->deity].align)
  {
   case ALIGN_NONE: matches = TRUE; break;
   case ALIGN_GOOD:
	if(IS_GOOD(ch)) matches = TRUE; break;
   case ALIGN_NEUTRAL:
	if(IS_NEUTRAL(ch)) matches = TRUE; break;
   case ALIGN_EVIL:
	if(IS_EVIL(ch)) matches = TRUE; break;
   default: return matches;
   }

   return matches;
}

void do_pray( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d; 
    int gift;
    int giftcost;

    if(IS_NPC(ch))
      return;

    argument = one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
        sprintf(buf, "%s appreciates your prayer for nothing.\n\r",
		deity_table[ch->pcdata->deity].pname);
        send_to_char( buf ,ch);
        return;
    }

/*  REMOVED by Nightdagger on 5/8/03
  if(ch->pcdata->deity_timer > 0 )
	{
	sprintf(buf, "%s is mightily upset you've started worshipping %s", deity_table[ch->pcdata->deity].pname, 
			deity_table[ch->pcdata->new_deity].pname);
        send_to_char(buf, ch);
        return;
        }
*/

  if(is_affected(ch,skill_lookup("holy silence")) )
    {
	sprintf(buf, "%s does not hear you.\n\r", deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,ch);
	return;
    }

    if ( !is_clan(ch) && deity_table[ch->pcdata->deity].clan)
    {
	sprintf(buf,"%s can only be worshiped by those in the clan system.\n\r",
		deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,ch);
	return;
    }

    if( !str_prefix(arg,"immortal"))
    {
	if (IS_SET(ch->comm,COMM_NOCHANNELS))
	{
	 send_to_char("The gods have revoked your channel priviliges.\n\r",ch);
	 return;
	}

    send_to_char("The immortals hear your prayer.\n\r",ch);

    if ( ch->pcdata->sac < 2 )
    {
	sprintf(buf,
	"You haven't given enough homage to %s to be granted that gift.\n\r",
	deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,ch);
	return;
    }
    else
    {
	ch->pcdata->sac -= 2;
    }

    for ( d = descriptor_list; d != NULL; d = d->next )                         
    {                                                                           
	if ( (d->connected == CON_PLAYING) &&
	     (IS_IMMORTAL(d->character)) &&
	     (!IS_SET(d->character->comm,COMM_NOWIZ)) &&
	     (!IS_SET(d->character->comm,COMM_QUIET))  &&
	     (d->character->ignoring != ch) )
	{
        channel_vis_status(ch,d->character);
	if(IS_SET(d->character->display,DISP_COLOR))
	    send_to_char(BOLD,d->character);
      act_new("$n prays '$t'",ch,argument,d->character,TO_VICT,POS_DEAD,FALSE);
	if(IS_SET(d->character->display,DISP_COLOR))
	    send_to_char(NORMAL,d->character);
	}
    }   	

    return;
    }

    if(ch->clan==clan_lookup("outcast") && ( ch->pcdata->outcT > 0))
    {
        send_to_char("Nothing happened.\n\r",ch);
        return;
    }

    gift = gift_lookup(arg);

    if ( !has_gift(ch,gift) )
    {
     sprintf(buf,
	     "%s can not grant you %s.\n\r",deity_table[ch->pcdata->deity].pname,
	     arg);
     send_to_char(buf,ch);
     return;
    }

    if ( !is_aligned(ch))
    {
	sprintf(buf,"%s frowns upon those of your alignment.\n\r",
		deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,ch);
	return;
    }

    if ( ((ch->played + (int) (current_time - ch->logon))
	   - ch->pcdata->switched) / 3600 < 1 && !IS_IMMORTAL(ch))
    {
	sprintf(buf,"%s is weary of your faith.\n\r",
		deity_table[ch->pcdata->deity].pname);
	return;
    }

    if ( ch->pcdata->sac < gift_table[gift].cost )
    {
	   sprintf(buf,
	"You haven't given enough homage to %s to be granted that gift.\n\r",
	   deity_table[ch->pcdata->deity].pname);
	   send_to_char(buf,ch);
	   return;
    }

/*
    if ( (!str_prefix(arg,"knowledge")) && (ch->clan==clan_lookup("zealot")) )
       ch->pcdata->sac -= 10;
    else */
       ch->pcdata->sac -= gift_table[gift].cost;


    if(ch->daze > 0 && number_percent() < 33)
      send_to_char("You lost your concentration.\n\r",ch);
    else
      give_gift(ch,gift);
    return;
}

void give_gift(CHAR_DATA *ch,int gift)
{
  char name[MAX_STRING_LENGTH];
  char arg[MAX_STRING_LENGTH];
  CHAR_DATA *gch,*nextvictim;
  AFFECT_DATA *paf,*paf_next;
  AFFECT_DATA af;
  ROOM_INDEX_DATA *room,*was_in,*now_in;
  int gain,attempt,door;
  EXIT_DATA *pexit;
       DESCRIPTOR_DATA *d;
       char buf2[MAX_STRING_LENGTH];
       char buf[MAX_STRING_LENGTH];
       bool first = TRUE;

  strcpy(name,gift_table[gift].name);

  switch ( name[0] )
  {
  case 'r': /* 3 find out which one */
	if( !str_prefix(name,"recall"))
	{
	 recall( ch, "", TRUE );
	 break;
	}

	if( !str_prefix(name,"reanimation"))
	{
	 reanimation(ch);
	 break;
	}

	if( !str_prefix(name,"random"))
	{
	 gift = number_range(2,MAX_GIFTS - 1);
	 give_gift(ch,gift);
	 break;
	}
	break;

  case 'k': /*knowledge*/
       

       for ( d = descriptor_list ; d != NULL; d = d->next)
	  {
	  if (d->character != NULL )
	    {
	    if (d->character->clan
		&& d->character->clan != clan_lookup("matook") 
		&& d->character->clan != clan_lookup("newbie") 
		&& !IS_IMMORTAL(d->character) )
            {
	      if (first)
	      {
		if (d->character->pcdata->deity != deity_lookup("almighty"))
		sprintf(buf, RED"%s is not a follower of the Almighty."NORMAL"\n\r", 
			d->character->name); 
                else
		sprintf(buf, "%s is a follower of the Almighty.\n\r", 
			d->character->name); 
		first = FALSE;
	      }
	      else
	      {
		if (d->character->pcdata->deity != deity_lookup("almighty"))
		sprintf(buf2, RED"%s is not a follower of the Almighty."NORMAL"\n\r", 
			d->character->name); 
                else
		sprintf(buf2, "%s is a follower of the Almighty.\n\r", 
			d->character->name); 
	      strcat(buf, buf2);
              }
	    }
	  }
	}
        send_to_char(buf, ch);
	break;


  case 'p': /* patience */

	for ( paf = ch->affected; paf != NULL; paf = paf_next )
	{
	 paf_next  = paf->next;
	 if ( paf->duration > 0 )
	 {
	  paf->duration++;
	  if (number_range(0,4) == 0 && paf->level > 0)
		paf->level++;
	 }
        }
	break;

  case 'n': /* nurture */
	gain_condition(ch, COND_HUNGER, 20 );
	gain_condition(ch, COND_THIRST, 20 );
	break;

  case 'm': /* meld */
	room = get_room_index(ch->in_room->vnum);
	if((gain = room->sector_type) > SECT_CITY)
	gain *= 4;
	ch->mana = UMIN(ch->max_mana,ch->mana + gain);
	ch->hit = UMIN(ch->max_hit,ch->hit + room->sector_type);
	break;

  case 'o': /* opiate */
	if(ch->pcdata->condition[COND_DRUNK] <= 15)
        {
	ch->pcdata->condition[COND_DRUNK] =
	UMIN(48,ch->pcdata->condition[COND_DRUNK] + 15);
	DAZE_STATE(ch, 5 * PULSE_VIOLENCE);
         af.where     = TO_AFFECTS;
         af.type      = skill_lookup("opiate");
         af.level   = ch->level;
         af.duration  = 2;
         af.location  = APPLY_INT;
         af.modifier  = 1 + (ch->level < 26 ? 1 : 0);
         af.bitvector = 0;
         affect_to_char( ch, &af );
         }
	 else
	 send_to_char("You're already buzzed.\n\r",ch);
         break;

  case 'b': /* bravery */
	if ( !str_prefix(name, "bravery") )
	  for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
	  {
	   if ( gch != ch && is_same_group( gch, ch ) && gch->fighting != NULL )
	    {
	     strcpy(arg,gch->name);
	     strcat(arg," xvx2");
	     do_rescue(ch,arg);
	    }
	   }

         if ( !str_prefix(name, "banishment"))
	   {
           for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
	     {
	     if(!IS_NPC(gch))
	       if ( !IS_SET (gch->mhs, MHS_BANISH) && 
		  gch->pcdata->deity != deity_lookup("almighty") &&
		  number_percent() < ch->clan == clan_lookup("zealot") ?
		  40 : 5 )
                  {
		    SET_BIT(gch->mhs, MHS_BANISH);
		  }
             }
	   }
	break;

  case 's': /* 2 find out which one */
	if( !str_prefix(name,"speed") )
	{
	 if(!IS_SET(ch->res_flags,RES_DELAY) && !is_affected(ch,skill_lookup("arcantic alacrity")) )
	 {
	  SET_BIT(ch->res_flags,RES_DELAY);
	 }
	break;
	}

	if( !str_prefix(name,"stature") 
	  && ch->size == pc_race_table[ch->race].size)
	{
	 af.where     = TO_AFFECTS;
	 af.type      = 0;
	 af.level   = ch->level;
	 af.duration  = (ch->level / 4)+1;
	 af.location  = APPLY_SIZE;
	 af.modifier  = 1;
	 af.bitvector = 0;
	 affect_to_char( ch, &af );
	 break;
	}
	break;

  case 'd': /* distraction */
	for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
	{
	 if( gch != ch && (IS_NPC(gch) || is_clan(gch)) 
	     && !IS_SET(ch->vuln_flags,VULN_DISTRACTION) )
	 {
	  af.where     = TO_VULN;
          af.type      = 0;
          af.level   = ch->level;
          af.duration  = 1;
          af.location  = APPLY_NONE;
          af.modifier  = 0;
          af.bitvector = VULN_DISTRACTION;
          affect_to_char( gch, &af );
	 }
	}
	break;

  case 'f': /* fear */
      for ( gch= ch->in_room->people; gch != NULL; gch = nextvictim )
      {
	 nextvictim = gch->next_in_room;
         if(gch != ch  && 
	      ( (is_clan(gch) && is_clan(ch) ) || IS_NPC(gch) ) )
         {
            if (IS_NPC(gch) && (IS_SET(gch->act,ACT_TRAIN)
                ||  IS_SET(gch->act,ACT_PRACTICE)
                ||  IS_SET(gch->act,ACT_IS_HEALER)
                ||  IS_SET(gch->act,ACT_NOPURGE)
                ||  IS_SET(gch->act,ACT_IS_CHANGER)))  
	       continue;

            if ( saves_spell(ch->level,gch,DAM_MENTAL))
	       continue;

            if (is_same_group(ch,gch))
	       continue;

            for ( attempt = 0; attempt < 6; attempt++ )
            {
	       door = number_door();
               was_in = gch->in_room;
	       if ( ( pexit = was_in->exit[door] ) == 0
		 ||   pexit->u1.to_room == NULL
		 ||   IS_SET(pexit->exit_info, EX_CLOSED)
		 ||   number_range(0,gch->daze) != 0
		 ||   (IS_NPC(gch)
		 &&   IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB) ) )
                 continue;

               move_char( gch, door, FALSE );
               if ( ( now_in = gch->in_room ) == was_in )
                  continue;

               gch->in_room = was_in;
               act( "$n runs in fear!", gch, NULL, NULL, TO_ROOM ,FALSE);
               gch->in_room = now_in;
               send_to_char("You run in fear.\n\r",gch);
            }
         }
      }
      break;
    
  case 't': /* transport */
	if( !( (IS_AFFECTED(ch,AFF_CURSE) || (IS_AFFECTED(ch,AFF_CURSE))) && number_percent() < 50) 
	    && !IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL) 
	    && !(ch->fighting != NULL && number_percent() < 75) )
	{
 	 room = get_random_room(ch);
	 send_to_char("You have been transported!\n\r",ch);
	 act( "$n vanishes!", ch, NULL, NULL, TO_ROOM ,FALSE);
	 if (ch->fighting != NULL) stop_fighting(ch,FALSE);
	 char_from_room( ch );
	 char_to_room( ch, room );
	 clear_mount(ch);
	 act( "$n slowly fades into existence.", ch, NULL, NULL, TO_ROOM ,FALSE);
	 do_look( ch, "auto" );
	}
	break;

  default: return;
  }
  return;
}

void reanimation(CHAR_DATA *ch)
{
  OBJ_DATA *obj,*cobj,*cobj_next;
  ROOM_INDEX_DATA *aroom= NULL;

  for ( obj = object_list; obj != NULL; obj = obj->next )
  {
    if(obj->pIndexData->vnum != OBJ_VNUM_CORPSE_PC)
	continue;

    
    if(!str_cmp(ch->name,obj->owner) && obj->timer > 0 )
	{
	 if( obj->carried_by != NULL )
	 {
	   aroom= obj->carried_by->in_room;
	 }
	 if( obj->in_room != NULL )
	 {
	   aroom= obj->in_room;
	 }
	 if( aroom != NULL && aroom->clan)
	 {
	   send_to_char("You can't reanimate into a clan hall.\n\r",ch);
	   return  ;
	 }

	 char_from_room(ch);
	 char_to_room(ch,aroom);
	 clear_mount(ch);
	 if(obj->carried_by != NULL)
	 {
	  obj_from_char( obj );
	  obj_to_room( obj, ch->in_room );
  act( "$p springs to life.", obj->carried_by, obj, NULL, TO_CHAR ,FALSE);
	  act( "$n drops $p.", obj->carried_by, obj, NULL, TO_ROOM ,FALSE);
	 }
	 for(cobj = obj->contains; cobj != NULL; cobj = cobj_next )
	 {
	  cobj_next = cobj->next_content;
	  obj_from_obj( cobj );
	  obj_to_char( cobj, ch );
	 }
	
	 send_to_char("You spring to life.\n\r",ch);
	 extract_obj( obj );
	 return;
	}
	
  }
  return;
}
	   
@


1.58
log
@removed knowledge from zealot gifts
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.57 2003/05/25 01:34:23 boogums Exp $";
d189 1
d317 1
a317 1
    else
d319 1
a319 1
*/
@


1.57
log
@ok adding MHS_CURSE
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.56 2003/05/19 03:32:09 ndagger Exp $";
d313 1
a313 1

d318 1
a318 1

@


1.56
log
@05/18/03 Nightdagger:  Fixed an oversight with pray speed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.55 2003/05/09 01:42:00 ndagger Exp $";
d569 1
a569 1
	if( !(IS_AFFECTED(ch,AFF_CURSE) && number_percent() < 50) 
@


1.55
log
@05/08/03 Nightdagger:  Bug fix in deity.c
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.54 2003/04/14 05:54:07 ndagger Exp $";
d483 1
a483 1
	 if(!IS_SET(ch->res_flags,RES_DELAY))
@


1.54
log
@04/13/03 Nightdagger:  Last (I hope) of the autoswitching stuff for deities.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.53 2003/04/14 05:35:50 ndagger Exp $";
d203 1
d211 1
@


1.53
log
@04/13/03 Nightdagger:  more autoswitch stuff...almost done
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.52 2003/04/14 04:36:14 ndagger Exp $";
d39 6
@


1.52
log
@04/13/03 Nightdagger:  First part of clan system change:  removed ability to pledge to the Almighty directly, and removed deity switch timer, pledge now switches immediately.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.51 2002/10/07 08:22:05 ndagger Exp $";
d118 15
d134 1
a134 1
  
@


1.51
log
@10/07/2002 Nightdagger:  Bug fix with sac points due to me being an idiot.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.50 2002/10/04 15:10:33 ndagger Exp $";
d60 8
d103 3
a105 1
    if(ch->pcdata->deity != 0)
d113 9
@


1.50
log
@10/04/02 Nightdagger- Zealot pray knowledge costs 10 sac now
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.49 2002/01/22 20:01:03 rage Exp $";
a263 2
        if ( (!str_prefix(arg,"knowledge")) && (ch->clan==clan_lookup("zealot")) && (ch->pcdata->sac <10) )
        { 
a268 1
        }
d270 1
@


1.49
log
@fixed bug in do_pray with new deity code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.48 2002/01/20 21:22:08 rage Exp $";
d264 3
a266 1
	sprintf(buf,
d268 4
a271 3
	deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,ch);
	return;
d274 5
a278 1
    ch->pcdata->sac -= gift_table[gift].cost;
@


1.48
log
@one more minor change to keep players from using gifts while in the process of changing deities
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.47 2002/01/20 21:09:08 rage Exp $";
d165 1
a165 1
	sprintf("%s is mightily upset you've started worshipping %s", deity_table[ch->pcdata->deity].pname, 
@


1.47
log
@changed sequence of events for switching deities
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.46 2001/11/28 19:09:41 poquah Exp $";
d162 8
@


1.46
log
@fix syntax error
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.45 2001/11/28 19:08:42 poquah Exp $";
d50 8
a57 1
        send_to_char( "Syntax: pledge <deity>\n\r",ch);
d97 2
a98 1
    ch->pcdata->deity = deity;
d100 1
a100 1
    sprintf(buf,"You now are a follower of %s.\n\r",deity_table[deity].pname);
@


1.45
log
@make newbies not appear on knowledge list
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.44 2001/01/08 23:16:02 mud Exp $";
d312 3
a314 3
		&& d->character->clan != clan_lookup("matook") &&
		&& d->character->clan != clan_lookup("newbie") &&
		!IS_IMMORTAL(d->character) )
@


1.44
log
@Can only switch deities every 1 RL hour of play.
Fixed bug with not getting gifts after 1 hour of play.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.43 2000/09/02 02:29:59 mud Exp $";
d313 1
@


1.43
log
@Better chance of banishment
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.42 2000/08/16 15:26:21 mud Exp $";
d79 9
d238 2
a239 1
    if ( (ch->played - ch->pcdata->switched) / 3600 < 1 && !IS_IMMORTAL(ch))
@


1.42
log
@ attempting to fix olist command
 fixed crash bug in with zealots being attacked by mobs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.41 2000/08/13 04:00:30 mud Exp $";
d398 1
a398 1
		  25 : 5 )
@


1.41
log
@ fixx bug in pray banishment
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.40 2000/08/12 22:56:20 mud Exp $";
d302 2
a303 1
		&& d->character->clan != clan_lookup("matook"))
@


1.40
log
@ some minor changes to Almighty gifts
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.39 2000/08/12 18:37:53 mud Exp $";
d393 2
a394 1
	     if ( !IS_SET (gch->mhs, MHS_BANISH) && !IS_NPC(gch) &&
@


1.39
log
@ bug fix in pray banish
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.38 2000/08/12 18:26:02 mud Exp $";
d317 1
a317 1
		sprintf(buf2, YELLOW"%s is not a follower of the Almighty."NORMAL"\n\r", 
d396 1
a396 1
		  50 : 30 )
@


1.38
log
@ added second deity gift for almighty, "banishment"
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.37 2000/08/12 04:46:01 mud Exp $";
d393 1
a393 1
	     if ( !IS_SET (gch->mhs, MHS_BANISH) &&
@


1.37
log
@change color to red
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.36 2000/08/12 04:36:01 mud Exp $";
d378 2
a379 3
	for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
	{
	 if ( gch != ch && is_same_group( gch, ch ) && gch->fighting != NULL )
d381 21
a401 5
	   strcpy(arg,gch->name);
	   strcat(arg," xvx2");
	   do_rescue(ch,arg);
	  }
	}
@


1.36
log
@ matookers dont end up on knowledge list
 -poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.35 2000/08/12 04:33:39 mud Exp $";
d307 1
a307 1
		sprintf(buf, YELLOW"%s is not a follower of the Almighty."NORMAL"\n\r", 
@


1.35
log
@colorize knowledge
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.34 2000/08/11 23:21:52 mud Exp $";
d303 1
d324 1
@


1.34
log
@ removed #ifdef CODE_TEST
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.33 2000/08/11 23:12:27 mud Exp $";
d301 2
a302 1
	    if (d->character->clan)
d305 6
a310 4
		sprintf(buf, "%s %s a follower of the Almighty.\n\r", 
			d->character->name, 
			d->character->pcdata->deity == deity_lookup("almighty") ?
			"is" : "is not" );
d315 6
a320 4
	      sprintf(buf2, "%s %s a follower of the Almighty.\n\r",
	      d->character->name,
	      d->character->pcdata->deity == deity_lookup("almighty") ?
	      "is" : "is not" );
@


1.33
log
@ fixed small bug in pray knowlegde
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.32 2000/08/11 22:53:44 mud Exp $";
d293 1
a293 1
#ifdef CODE_TEST 
d322 1
a322 1
#endif
@


1.32
log
@ added in "the almighty" deity
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.31 2000/05/26 00:52:53 mud Exp $";
d306 1
a306 1
			d->character->pcdata->deity == deity_lookup("the almighty") ?
d308 1
d314 1
a314 1
	      d->character->pcdata->deity == deity_lookup("the almighty") ?
@


1.31
log
@ Fixed a bug , if you reanimate and your corpse was carried
 you were sent to hassan instead of the room where the person
 carrying your corpse was located
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.30 2000/05/26 00:35:08 mud Exp $";
d264 4
d293 29
@


1.30
log
@reanimation fixes
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.29 2000/05/26 00:22:21 mud Exp $";
d486 1
a486 1
	 char_to_room(ch,obj->in_room);
@


1.29
log
@ Forgot teh case when someone is carrying the corpse while in a hall
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.28 2000/05/25 23:47:29 mud Exp $";
d461 1
d471 9
a479 1
	 if( obj->carried_by->in_room->clan || obj->in_room->clan )
@


1.28
log
@ Mods to earthbind ( can flee now, but cost you 10 extra moves per square)
 Can't reanimate into a corpse whihc is in a clan hall
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.27 2000/04/18 19:50:55 mud Exp $";
d470 1
a470 1
	 if( obj->in_room->clan )
@


1.27
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.26 2000/03/12 01:48:13 mud Exp $";
d467 1
d470 6
@


1.26
log
@poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.25 2000/02/28 18:43:31 mud Exp $";
d195 1
a195 1
	act_new("$n prays '$t'",ch,argument,d->character,TO_VICT,POS_DEAD);
d428 1
a428 1
               act( "$n runs in fear!", gch, NULL, NULL, TO_ROOM );
d443 1
a443 1
	 act( "$n vanishes!", ch, NULL, NULL, TO_ROOM );
d448 1
a448 1
	 act( "$n slowly fades into existence.", ch, NULL, NULL, TO_ROOM );
d476 2
a477 2
	  act( "$p springs to life.", obj->carried_by, obj, NULL, TO_CHAR );
	  act( "$n drops $p.", obj->carried_by, obj, NULL, TO_ROOM );
@


1.25
log
@fear does not harm groupies, go group!
and remove 2X exp
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.24 2000/02/18 21:01:45 mud Exp $";
d149 8
@


1.24
log
@remove debug lines in random
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.23 2000/02/18 19:50:23 mud Exp $";
d398 3
@


1.23
log
@max gifts - 1 in random
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.22 2000/02/18 18:47:10 mud Exp $";
a258 3
sprintf(log_buf,"DEITY: %s got %s.", ch->name,name );
bug( log_buf, 0 );

a276 2
sprintf(log_buf,"RANDOM: %s about to get %d.", ch->name,gift );
bug( log_buf, 0 );
@


1.22
log
@throw a couple log messages in to track down bug
-ppoquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.21 2000/02/12 14:36:34 mud Exp $";
d279 1
a279 1
	 gift = number_range(2,MAX_GIFTS);
@


1.21
log
@deity.c     forgot to propogate the change to deity_lookup in this file

            all instances of deity_lookup are now compatible with the new
	    error return value of -1

	    Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.20 1999/12/14 22:06:39 mud Exp $";
d259 3
d280 2
@


1.20
log
@Decalre the variable at give_gift for fear
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.19 1999/12/14 22:02:39 mud Exp $";
d64 1
a64 1
    if ( (deity = deity_lookup(arg1)) == 0)
@


1.19
log
@Fix Deity Fear now same as mummy fear code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.18 1999/11/03 19:52:43 mud Exp $";
d250 1
a250 1
  CHAR_DATA *gch;
d254 2
a255 1
  int gain;
a383 6
      CHAR_DATA *victim,*nextvictim;
      ROOM_INDEX_DATA *was_in;
      ROOM_INDEX_DATA *now_in;
      EXIT_DATA *pexit;
      int attempt, door;

@


1.18
log
@Don't allow clanners to use 'fear' on nonclanners
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.17 1999/10/09 17:16:42 mud Exp $";
d254 1
a254 1
  int gain,attempt;
d383 27
a409 11
	for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
        {
	 if( gch != ch && (gch->max_hit / (gch->wimpy+1)) <= 3 )
	  {
	    was_in = gch->in_room;
	    for ( attempt = 0; attempt < 6; attempt++ )
		{
		 EXIT_DATA *pexit;
		 int door;
		 door = number_door();
		 if ( ( pexit = was_in->exit[door] ) == 0
d413 1
a413 2
		 || (!is_clan(gch) && !IS_NPC(gch))
		 || ( IS_NPC(gch)
d415 1
a415 1
		 continue;
d417 12
a428 12
		 move_char( gch, door, FALSE );
		 if ( ( now_in = gch->in_room ) == was_in )
		 continue;

		 gch->in_room = was_in;
		 act( "$n runs in fear!", gch, NULL, NULL, TO_ROOM );
		 gch->in_room = now_in;
		 send_to_char("You run in fear.\n\r",gch);
		}
	  }
	}
	break;
@


1.17
log
@ Added in some changes to outcast.  All checks on clan outcast now include an additional check on their timre.  read the change to find out why

 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.16 1999/08/23 03:34:43 mud Exp $";
d397 1
@


1.16
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.15 1999/08/11 02:27:12 mud Exp $";
d196 1
a196 1
    if(ch->clan==clan_lookup("outcast"))
@


1.15
log
@Trying to fix a mysterious crash bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.14 1999/08/10 23:00:55 mud Exp $";
d425 1
d449 1
@


1.14
log
@Added a bit to hassan's special
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.13 1999/07/14 18:13:36 mud Exp $";
d38 2
d263 1
a263 1
	 recall( ch, NULL, TRUE );
@


1.13
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: deity.c,v 1.12 1999/03/03 18:43:32 mud Exp $";
d261 1
a261 2
	 strcpy(arg,"x2y2z2g3v4kk5");
	 do_recall(ch, arg );
@


1.12
log
@just changed a comment to show Poquah how updates work.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.11 1998/11/22 02:05:13 mud Exp $ */
@


1.11
log
@Crusader spells
@
text
@d15 1
a15 1
 *  around, comes around.                                                  *
d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.10 1998/11/17 23:20:10 mud Exp $ */
@


1.10
log
@Hopefully fixed the wholist and also added outcast changes
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.9 1998/10/19 01:39:31 mud Exp $ */
d314 1
a314 1
         af.type      = 0;
@


1.9
log
@Last few pray immortal changes
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.8 1998/10/18 19:42:05 mud Exp $ */
d192 6
@


1.8
log
@added recycle.h include for add_buf()
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.7 1998/10/18 19:40:36 mud Exp $ */
d184 1
a184 1
	    add_buf(d->character->pcdata->buffer, BOLD);
d187 1
a187 1
	    add_buf(d->character->pcdata->buffer, NORMAL);
@


1.7
log
@sac point cost for pray immortal, color and *ch verification added
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.6 1998/10/18 19:12:25 mud Exp $ */
d31 1
@


1.6
log
@added sac cost for pray immortal
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.5 1998/10/18 18:59:20 mud Exp $ */
d158 2
d182 2
d185 2
@


1.5
log
@oops, forgot tot declare the *d
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.4 1998/10/18 18:57:32 mud Exp $ */
d157 13
@


1.4
log
@Added 'pray immortal <string>' as an IMM listening channel
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.3 1998/09/22 15:56:21 mud Exp $ */
d127 1
@


1.3
log
@fixed pray crash bug
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.2 1998/08/20 21:05:30 mud Exp $ */
d147 24
@


1.2
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: deity.c,v 1.1 1998/06/16 17:49:20 mud Exp $ */
d128 3
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d52 1
a52 1
    if ( ch->deity > 0 && !IS_IMMORTAL(ch) )
d55 1
a55 1
		deity_table[ch->deity].pname);
d76 4
a79 4
    if(ch->deity != 0)
       ch->switched = ch->played;
    ch->deity = deity;
    ch->sac = 0;
d95 1
a95 1
    if(deity_table[ch->deity].gifts[gn] == NULL)
d97 1
a97 1
    if(!str_cmp(gift_table[gift].name,deity_table[ch->deity].gifts[gn]))
d108 1
a108 1
  switch(deity_table[ch->deity].align)
d134 1
a134 1
		deity_table[ch->deity].pname);
d141 1
a141 1
	sprintf(buf, "%s does not hear you.\n\r", deity_table[ch->deity].pname);
d151 1
a151 1
	     "%s can not grant you %s.\n\r",deity_table[ch->deity].pname,
d160 1
a160 1
		deity_table[ch->deity].pname);
d165 1
a165 1
    if ( (ch->played - ch->switched) / 3600 < 1 && !IS_IMMORTAL(ch))
d168 1
a168 1
		deity_table[ch->deity].pname);
d172 1
a172 1
    if ( ch->sac < gift_table[gift].cost )
d176 1
a176 1
	deity_table[ch->deity].pname);
d181 1
a181 1
    ch->sac -= gift_table[gift].cost;
@
