head	1.945;
access;
symbols;
locks; strict;
comment	@ * @;


1.945
date	2005.02.17.05.16.22;	author boogums;	state Exp;
branches;
next	1.944;

1.944
date	2004.10.25.02.48.45;	author boogums;	state Exp;
branches;
next	1.943;

1.943
date	2004.10.24.19.25.17;	author boogums;	state Exp;
branches;
next	1.942;

1.942
date	2004.08.14.01.21.50;	author boogums;	state Exp;
branches;
next	1.941;

1.941
date	2004.06.19.14.52.16;	author boogums;	state Exp;
branches;
next	1.940;

1.940
date	2004.05.02.00.54.24;	author boogums;	state Exp;
branches;
next	1.939;

1.939
date	2004.03.27.22.25.10;	author boogums;	state Exp;
branches;
next	1.938;

1.938
date	2004.03.27.16.41.46;	author boogums;	state Exp;
branches;
next	1.937;

1.937
date	2004.03.27.16.00.10;	author boogums;	state Exp;
branches;
next	1.936;

1.936
date	2004.03.27.15.51.41;	author boogums;	state Exp;
branches;
next	1.935;

1.935
date	2003.12.07.20.42.45;	author boogums;	state Exp;
branches;
next	1.934;

1.934
date	2003.11.22.15.08.32;	author boogums;	state Exp;
branches;
next	1.933;

1.933
date	2003.09.09.02.28.49;	author boogums;	state Exp;
branches;
next	1.932;

1.932
date	2003.07.19.05.31.57;	author boogums;	state Exp;
branches;
next	1.931;

1.931
date	2003.07.19.04.39.34;	author boogums;	state Exp;
branches;
next	1.930;

1.930
date	2003.07.10.16.49.56;	author ndagger;	state Exp;
branches;
next	1.929;

1.929
date	2003.07.10.16.38.12;	author ndagger;	state Exp;
branches;
next	1.928;

1.928
date	2003.06.22.04.54.29;	author boogums;	state Exp;
branches;
next	1.927;

1.927
date	2003.06.14.19.58.55;	author boogums;	state Exp;
branches;
next	1.926;

1.926
date	2003.06.14.19.53.11;	author boogums;	state Exp;
branches;
next	1.925;

1.925
date	2003.06.10.02.26.13;	author ndagger;	state Exp;
branches;
next	1.924;

1.924
date	2003.06.07.21.48.58;	author boogums;	state Exp;
branches;
next	1.923;

1.923
date	2003.05.30.02.23.05;	author ndagger;	state Exp;
branches;
next	1.922;

1.922
date	2003.05.28.23.16.28;	author ndagger;	state Exp;
branches;
next	1.921;

1.921
date	2003.05.25.15.21.45;	author boogums;	state Exp;
branches;
next	1.920;

1.920
date	2003.05.24.01.12.14;	author ndagger;	state Exp;
branches;
next	1.919;

1.919
date	2003.05.24.00.31.40;	author ndagger;	state Exp;
branches;
next	1.918;

1.918
date	2003.05.22.03.21.09;	author ndagger;	state Exp;
branches;
next	1.917;

1.917
date	2003.05.21.01.41.15;	author boogums;	state Exp;
branches;
next	1.916;

1.916
date	2003.05.20.03.12.49;	author boogums;	state Exp;
branches;
next	1.915;

1.915
date	2003.05.19.01.29.48;	author boogums;	state Exp;
branches;
next	1.914;

1.914
date	2003.05.13.04.14.40;	author ndagger;	state Exp;
branches;
next	1.913;

1.913
date	2003.05.13.03.39.39;	author ndagger;	state Exp;
branches;
next	1.912;

1.912
date	2003.05.03.03.20.21;	author boogums;	state Exp;
branches;
next	1.911;

1.911
date	2003.03.16.18.08.42;	author boogums;	state Exp;
branches;
next	1.910;

1.910
date	2003.03.11.03.48.50;	author boogums;	state Exp;
branches;
next	1.909;

1.909
date	2003.03.11.03.38.07;	author boogums;	state Exp;
branches;
next	1.908;

1.908
date	2003.03.11.03.01.14;	author boogums;	state Exp;
branches;
next	1.907;

1.907
date	2003.03.08.22.35.35;	author boogums;	state Exp;
branches;
next	1.906;

1.906
date	2003.03.08.21.42.46;	author boogums;	state Exp;
branches;
next	1.905;

1.905
date	2003.02.23.16.30.15;	author boogums;	state Exp;
branches;
next	1.904;

1.904
date	2003.02.21.04.47.23;	author boogums;	state Exp;
branches;
next	1.903;

1.903
date	2003.02.01.07.39.30;	author boogums;	state Exp;
branches;
next	1.902;

1.902
date	2003.01.28.18.50.37;	author rusty;	state Exp;
branches;
next	1.901;

1.901
date	2003.01.23.23.53.51;	author ndagger;	state Exp;
branches;
next	1.900;

1.900
date	2003.01.23.23.05.13;	author ndagger;	state Exp;
branches;
next	1.899;

1.899
date	2002.12.23.01.54.33;	author boogums;	state Exp;
branches;
next	1.898;

1.898
date	2002.12.23.00.37.28;	author boogums;	state Exp;
branches;
next	1.897;

1.897
date	2002.12.02.05.24.17;	author boogums;	state Exp;
branches;
next	1.896;

1.896
date	2002.11.28.22.11.08;	author boogums;	state Exp;
branches;
next	1.895;

1.895
date	2002.11.26.10.10.08;	author ndagger;	state Exp;
branches;
next	1.894;

1.894
date	2002.11.26.09.38.38;	author ndagger;	state Exp;
branches;
next	1.893;

1.893
date	2002.11.26.08.47.06;	author ndagger;	state Exp;
branches;
next	1.892;

1.892
date	2002.11.26.06.53.11;	author boogums;	state Exp;
branches;
next	1.891;

1.891
date	2002.11.26.05.35.26;	author boogums;	state Exp;
branches;
next	1.890;

1.890
date	2002.11.22.06.24.30;	author ndagger;	state Exp;
branches;
next	1.889;

1.889
date	2002.11.19.04.42.15;	author boogums;	state Exp;
branches;
next	1.888;

1.888
date	2002.11.16.22.52.51;	author boogums;	state Exp;
branches;
next	1.887;

1.887
date	2002.11.15.02.26.52;	author boogums;	state Exp;
branches;
next	1.886;

1.886
date	2002.11.04.16.01.01;	author rusty;	state Exp;
branches;
next	1.885;

1.885
date	2002.11.04.15.57.34;	author rusty;	state Exp;
branches;
next	1.884;

1.884
date	2002.10.28.04.57.18;	author boogums;	state Exp;
branches;
next	1.883;

1.883
date	2002.10.05.03.40.58;	author boogums;	state Exp;
branches;
next	1.882;

1.882
date	2002.10.03.03.25.34;	author boogums;	state Exp;
branches;
next	1.881;

1.881
date	2002.10.02.14.49.38;	author boogums;	state Exp;
branches;
next	1.880;

1.880
date	2002.10.02.00.34.11;	author ndagger;	state Exp;
branches;
next	1.879;

1.879
date	2002.09.20.02.42.29;	author boogums;	state Exp;
branches;
next	1.878;

1.878
date	2002.09.09.15.55.34;	author boogums;	state Exp;
branches;
next	1.877;

1.877
date	2002.09.09.15.49.11;	author boogums;	state Exp;
branches;
next	1.876;

1.876
date	2002.09.01.14.58.08;	author boogums;	state Exp;
branches;
next	1.875;

1.875
date	2002.09.01.14.55.06;	author boogums;	state Exp;
branches;
next	1.874;

1.874
date	2002.08.29.02.50.09;	author boogums;	state Exp;
branches;
next	1.873;

1.873
date	2002.06.29.03.41.31;	author boogums;	state Exp;
branches;
next	1.872;

1.872
date	2002.06.04.17.51.09;	author rusty;	state Exp;
branches;
next	1.871;

1.871
date	2002.05.30.16.31.21;	author poquah;	state Exp;
branches;
next	1.870;

1.870
date	2002.05.29.14.38.46;	author mud;	state Exp;
branches;
next	1.869;

1.869
date	2002.05.29.14.37.19;	author mud;	state Exp;
branches;
next	1.868;

1.868
date	2002.05.29.14.35.26;	author rusty;	state Exp;
branches;
next	1.867;

1.867
date	2002.05.24.15.03.13;	author rusty;	state Exp;
branches;
next	1.866;

1.866
date	2002.05.22.18.00.41;	author rusty;	state Exp;
branches;
next	1.865;

1.865
date	2002.05.21.20.20.58;	author rage;	state Exp;
branches;
next	1.864;

1.864
date	2002.05.08.14.21.51;	author rusty;	state Exp;
branches;
next	1.863;

1.863
date	2002.04.21.15.20.08;	author rusty;	state Exp;
branches;
next	1.862;

1.862
date	2002.04.21.15.08.47;	author rusty;	state Exp;
branches;
next	1.861;

1.861
date	2002.04.21.14.54.54;	author mud;	state Exp;
branches;
next	1.860;

1.860
date	2002.04.21.14.53.54;	author rusty;	state Exp;
branches;
next	1.859;

1.859
date	2002.04.18.19.33.14;	author poquah;	state Exp;
branches;
next	1.858;

1.858
date	2002.04.18.17.09.10;	author poquah;	state Exp;
branches;
next	1.857;

1.857
date	2002.04.18.16.31.33;	author poquah;	state Exp;
branches;
next	1.856;

1.856
date	2002.04.11.03.17.38;	author boogums;	state Exp;
branches;
next	1.855;

1.855
date	2002.04.05.00.59.20;	author rusty;	state Exp;
branches;
next	1.854;

1.854
date	2002.04.01.22.00.05;	author rusty;	state Exp;
branches;
next	1.853;

1.853
date	2002.04.01.21.05.44;	author rusty;	state Exp;
branches;
next	1.852;

1.852
date	2002.03.12.15.26.05;	author rusty;	state Exp;
branches;
next	1.851;

1.851
date	2002.03.12.03.38.37;	author mud;	state Exp;
branches;
next	1.850;

1.850
date	2002.03.11.09.49.23;	author rusty;	state Exp;
branches;
next	1.849;

1.849
date	2002.02.28.18.56.55;	author mud;	state Exp;
branches;
next	1.848;

1.848
date	2002.02.28.18.55.22;	author rusty;	state Exp;
branches;
next	1.847;

1.847
date	2002.02.25.17.19.42;	author poquah;	state Exp;
branches;
next	1.846;

1.846
date	2002.02.25.16.45.54;	author poquah;	state Exp;
branches;
next	1.845;

1.845
date	2002.02.25.16.44.21;	author poquah;	state Exp;
branches;
next	1.844;

1.844
date	2002.02.12.18.38.42;	author poquah;	state Exp;
branches;
next	1.843;

1.843
date	2002.02.12.18.35.54;	author poquah;	state Exp;
branches;
next	1.842;

1.842
date	2002.02.12.18.31.39;	author poquah;	state Exp;
branches;
next	1.841;

1.841
date	2002.02.11.19.38.23;	author poquah;	state Exp;
branches;
next	1.840;

1.840
date	2002.02.11.18.43.30;	author poquah;	state Exp;
branches;
next	1.839;

1.839
date	2002.02.11.18.42.18;	author poquah;	state Exp;
branches;
next	1.838;

1.838
date	2002.02.11.18.34.10;	author poquah;	state Exp;
branches;
next	1.837;

1.837
date	2002.02.10.04.14.07;	author boogums;	state Exp;
branches;
next	1.836;

1.836
date	2002.02.10.04.02.20;	author boogums;	state Exp;
branches;
next	1.835;

1.835
date	2002.01.26.16.25.27;	author rage;	state Exp;
branches;
next	1.834;

1.834
date	2002.01.20.21.09.08;	author rage;	state Exp;
branches;
next	1.833;

1.833
date	2002.01.15.04.56.47;	author boogums;	state Exp;
branches;
next	1.832;

1.832
date	2001.12.20.15.13.07;	author rage;	state Exp;
branches;
next	1.831;

1.831
date	2001.12.17.17.29.25;	author rage;	state Exp;
branches;
next	1.830;

1.830
date	2001.12.17.17.13.21;	author rage;	state Exp;
branches;
next	1.829;

1.829
date	2001.12.17.14.33.35;	author rage;	state Exp;
branches;
next	1.828;

1.828
date	2001.12.17.01.50.38;	author rage;	state Exp;
branches;
next	1.827;

1.827
date	2001.12.17.01.39.01;	author rage;	state Exp;
branches;
next	1.826;

1.826
date	2001.12.17.01.32.39;	author rage;	state Exp;
branches;
next	1.825;

1.825
date	2001.12.17.01.19.38;	author rage;	state Exp;
branches;
next	1.824;

1.824
date	2001.12.14.13.54.47;	author rage;	state Exp;
branches;
next	1.823;

1.823
date	2001.12.13.20.36.53;	author poquah;	state Exp;
branches;
next	1.822;

1.822
date	2001.12.13.17.52.42;	author poquah;	state Exp;
branches;
next	1.821;

1.821
date	2001.12.13.17.41.17;	author poquah;	state Exp;
branches;
next	1.820;

1.820
date	2001.12.13.17.10.51;	author poquah;	state Exp;
branches;
next	1.819;

1.819
date	2001.12.09.16.20.22;	author poquah;	state Exp;
branches;
next	1.818;

1.818
date	2001.12.09.16.07.38;	author poquah;	state Exp;
branches;
next	1.817;

1.817
date	2001.12.09.15.59.14;	author poquah;	state Exp;
branches;
next	1.816;

1.816
date	2001.12.09.15.54.53;	author poquah;	state Exp;
branches;
next	1.815;

1.815
date	2001.12.09.15.49.08;	author poquah;	state Exp;
branches;
next	1.814;

1.814
date	2001.12.09.15.44.46;	author poquah;	state Exp;
branches;
next	1.813;

1.813
date	2001.12.09.15.39.15;	author poquah;	state Exp;
branches;
next	1.812;

1.812
date	2001.12.09.15.22.09;	author poquah;	state Exp;
branches;
next	1.811;

1.811
date	2001.12.09.15.10.39;	author poquah;	state Exp;
branches;
next	1.810;

1.810
date	2001.12.07.19.11.59;	author poquah;	state Exp;
branches;
next	1.809;

1.809
date	2001.12.07.17.05.44;	author poquah;	state Exp;
branches;
next	1.808;

1.808
date	2001.12.06.18.43.40;	author poquah;	state Exp;
branches;
next	1.807;

1.807
date	2001.12.06.18.31.51;	author rage;	state Exp;
branches;
next	1.806;

1.806
date	2001.12.06.18.11.43;	author poquah;	state Exp;
branches;
next	1.805;

1.805
date	2001.12.06.17.45.29;	author poquah;	state Exp;
branches;
next	1.804;

1.804
date	2001.12.06.17.26.39;	author poquah;	state Exp;
branches;
next	1.803;

1.803
date	2001.12.06.17.21.43;	author poquah;	state Exp;
branches;
next	1.802;

1.802
date	2001.12.05.17.07.04;	author poquah;	state Exp;
branches;
next	1.801;

1.801
date	2001.12.05.16.44.43;	author poquah;	state Exp;
branches;
next	1.800;

1.800
date	2001.12.05.16.39.01;	author poquah;	state Exp;
branches;
next	1.799;

1.799
date	2001.12.04.17.37.29;	author poquah;	state Exp;
branches;
next	1.798;

1.798
date	2001.12.04.15.23.33;	author poquah;	state Exp;
branches;
next	1.797;

1.797
date	2001.12.03.21.42.36;	author poquah;	state Exp;
branches;
next	1.796;

1.796
date	2001.12.03.21.38.14;	author poquah;	state Exp;
branches;
next	1.795;

1.795
date	2001.12.03.18.34.54;	author poquah;	state Exp;
branches;
next	1.794;

1.794
date	2001.12.03.15.11.23;	author poquah;	state Exp;
branches;
next	1.793;

1.793
date	2001.12.03.14.33.16;	author poquah;	state Exp;
branches;
next	1.792;

1.792
date	2001.12.03.07.57.26;	author poquah;	state Exp;
branches;
next	1.791;

1.791
date	2001.12.03.07.46.24;	author poquah;	state Exp;
branches;
next	1.790;

1.790
date	2001.12.03.07.29.18;	author poquah;	state Exp;
branches;
next	1.789;

1.789
date	2001.12.03.06.48.41;	author poquah;	state Exp;
branches;
next	1.788;

1.788
date	2001.12.03.06.40.01;	author poquah;	state Exp;
branches;
next	1.787;

1.787
date	2001.12.03.06.30.15;	author poquah;	state Exp;
branches;
next	1.786;

1.786
date	2001.12.03.06.27.03;	author poquah;	state Exp;
branches;
next	1.785;

1.785
date	2001.12.03.06.03.15;	author poquah;	state Exp;
branches;
next	1.784;

1.784
date	2001.12.02.06.46.53;	author boogums;	state Exp;
branches;
next	1.783;

1.783
date	2001.12.02.05.53.03;	author boogums;	state Exp;
branches;
next	1.782;

1.782
date	2001.12.02.00.42.30;	author boogums;	state Exp;
branches;
next	1.781;

1.781
date	2001.12.02.00.33.23;	author boogums;	state Exp;
branches;
next	1.780;

1.780
date	2001.12.02.00.22.48;	author boogums;	state Exp;
branches;
next	1.779;

1.779
date	2001.12.02.00.16.33;	author boogums;	state Exp;
branches;
next	1.778;

1.778
date	2001.12.01.23.23.54;	author poquah;	state Exp;
branches;
next	1.777;

1.777
date	2001.12.01.23.16.57;	author poquah;	state Exp;
branches;
next	1.776;

1.776
date	2001.12.01.06.21.17;	author boogums;	state Exp;
branches;
next	1.775;

1.775
date	2001.12.01.06.15.49;	author boogums;	state Exp;
branches;
next	1.774;

1.774
date	2001.12.01.06.13.51;	author boogums;	state Exp;
branches;
next	1.773;

1.773
date	2001.12.01.06.01.29;	author boogums;	state Exp;
branches;
next	1.772;

1.772
date	2001.12.01.05.54.07;	author boogums;	state Exp;
branches;
next	1.771;

1.771
date	2001.11.30.17.40.10;	author poquah;	state Exp;
branches;
next	1.770;

1.770
date	2001.11.30.16.28.53;	author poquah;	state Exp;
branches;
next	1.769;

1.769
date	2001.11.30.16.19.28;	author poquah;	state Exp;
branches;
next	1.768;

1.768
date	2001.11.30.15.43.50;	author poquah;	state Exp;
branches;
next	1.767;

1.767
date	2001.11.29.17.24.10;	author poquah;	state Exp;
branches;
next	1.766;

1.766
date	2001.11.29.17.03.35;	author poquah;	state Exp;
branches;
next	1.765;

1.765
date	2001.11.29.09.53.40;	author poquah;	state Exp;
branches;
next	1.764;

1.764
date	2001.11.29.09.47.27;	author poquah;	state Exp;
branches;
next	1.763;

1.763
date	2001.11.29.09.23.02;	author poquah;	state Exp;
branches;
next	1.762;

1.762
date	2001.11.25.05.21.16;	author poquah;	state Exp;
branches;
next	1.761;

1.761
date	2001.11.25.04.51.01;	author poquah;	state Exp;
branches;
next	1.760;

1.760
date	2001.11.25.04.48.45;	author poquah;	state Exp;
branches;
next	1.759;

1.759
date	2001.11.25.04.43.13;	author poquah;	state Exp;
branches;
next	1.758;

1.758
date	2001.11.25.04.39.20;	author poquah;	state Exp;
branches;
next	1.757;

1.757
date	2001.11.25.01.33.20;	author mud;	state Exp;
branches;
next	1.756;

1.756
date	2001.11.25.01.26.38;	author rusty;	state Exp;
branches;
next	1.755;

1.755
date	2001.11.06.23.39.18;	author rage;	state Exp;
branches;
next	1.754;

1.754
date	2001.10.24.23.48.20;	author poquah;	state Exp;
branches;
next	1.753;

1.753
date	2001.10.24.23.47.07;	author poquah;	state Exp;
branches;
next	1.752;

1.752
date	2001.10.18.20.09.35;	author rusty;	state Exp;
branches;
next	1.751;

1.751
date	2001.10.17.03.02.47;	author boogums;	state Exp;
branches;
next	1.750;

1.750
date	2001.10.14.04.08.43;	author rage;	state Exp;
branches;
next	1.749;

1.749
date	2001.10.03.23.48.50;	author rage;	state Exp;
branches;
next	1.748;

1.748
date	2001.10.03.23.37.18;	author rage;	state Exp;
branches;
next	1.747;

1.747
date	2001.10.02.23.59.55;	author rage;	state Exp;
branches;
next	1.746;

1.746
date	2001.09.28.20.28.36;	author rage;	state Exp;
branches;
next	1.745;

1.745
date	2001.09.28.00.03.15;	author rage;	state Exp;
branches;
next	1.744;

1.744
date	2001.09.27.23.48.15;	author rage;	state Exp;
branches;
next	1.743;

1.743
date	2001.09.27.23.31.34;	author rage;	state Exp;
branches;
next	1.742;

1.742
date	2001.09.27.23.10.59;	author rage;	state Exp;
branches;
next	1.741;

1.741
date	2001.09.22.17.53.01;	author rage;	state Exp;
branches;
next	1.740;

1.740
date	2001.09.22.15.20.45;	author boogums;	state Exp;
branches;
next	1.739;

1.739
date	2001.09.22.15.01.01;	author boogums;	state Exp;
branches;
next	1.738;

1.738
date	2001.09.22.00.10.48;	author boogums;	state Exp;
branches;
next	1.737;

1.737
date	2001.09.21.21.41.37;	author boogums;	state Exp;
branches;
next	1.736;

1.736
date	2001.09.21.01.30.05;	author boogums;	state Exp;
branches;
next	1.735;

1.735
date	2001.09.20.03.27.43;	author boogums;	state Exp;
branches;
next	1.734;

1.734
date	2001.09.20.03.10.31;	author boogums;	state Exp;
branches;
next	1.733;

1.733
date	2001.09.12.04.19.50;	author poquah;	state Exp;
branches;
next	1.732;

1.732
date	2001.09.02.08.54.21;	author guerrand;	state Exp;
branches;
next	1.731;

1.731
date	2001.08.30.19.51.48;	author rage;	state Exp;
branches;
next	1.730;

1.730
date	2001.08.30.01.30.04;	author guerrand;	state Exp;
branches;
next	1.729;

1.729
date	2001.08.30.01.16.22;	author guerrand;	state Exp;
branches;
next	1.728;

1.728
date	2001.08.30.01.03.23;	author guerrand;	state Exp;
branches;
next	1.727;

1.727
date	2001.08.25.01.43.40;	author guerrand;	state Exp;
branches;
next	1.726;

1.726
date	2001.08.20.17.21.15;	author poquah;	state Exp;
branches;
next	1.725;

1.725
date	2001.08.20.03.04.40;	author poquah;	state Exp;
branches;
next	1.724;

1.724
date	2001.08.20.03.02.48;	author poquah;	state Exp;
branches;
next	1.723;

1.723
date	2001.08.19.20.56.23;	author guerrand;	state Exp;
branches;
next	1.722;

1.722
date	2001.08.19.20.49.01;	author guerrand;	state Exp;
branches;
next	1.721;

1.721
date	2001.08.10.01.15.53;	author poquah;	state Exp;
branches;
next	1.720;

1.720
date	2001.08.09.14.25.37;	author rusty;	state Exp;
branches;
next	1.719;

1.719
date	2001.08.08.06.01.40;	author poquah;	state Exp;
branches;
next	1.718;

1.718
date	2001.08.08.05.59.07;	author poquah;	state Exp;
branches;
next	1.717;

1.717
date	2001.08.08.05.57.50;	author poquah;	state Exp;
branches;
next	1.716;

1.716
date	2001.08.08.05.45.51;	author poquah;	state Exp;
branches;
next	1.715;

1.715
date	2001.08.07.01.55.54;	author poquah;	state Exp;
branches;
next	1.714;

1.714
date	2001.08.05.22.47.36;	author guerrand;	state Exp;
branches;
next	1.713;

1.713
date	2001.08.04.19.30.11;	author guerrand;	state Exp;
branches;
next	1.712;

1.712
date	2001.08.04.16.03.02;	author guerrand;	state Exp;
branches;
next	1.711;

1.711
date	2001.08.04.15.54.47;	author guerrand;	state Exp;
branches;
next	1.710;

1.710
date	2001.08.02.02.12.09;	author guerrand;	state Exp;
branches;
next	1.709;

1.709
date	2001.07.30.04.51.48;	author guerrand;	state Exp;
branches;
next	1.708;

1.708
date	2001.07.29.17.36.07;	author rusty;	state Exp;
branches;
next	1.707;

1.707
date	2001.07.28.19.14.42;	author guerrand;	state Exp;
branches;
next	1.706;

1.706
date	2001.07.27.02.14.11;	author guerrand;	state Exp;
branches;
next	1.705;

1.705
date	2001.07.26.00.45.19;	author guerrand;	state Exp;
branches;
next	1.704;

1.704
date	2001.07.24.03.55.34;	author guerrand;	state Exp;
branches;
next	1.703;

1.703
date	2001.07.16.16.29.21;	author guerrand;	state Exp;
branches;
next	1.702;

1.702
date	2001.07.16.16.25.15;	author guerrand;	state Exp;
branches;
next	1.701;

1.701
date	2001.07.15.16.41.29;	author guerrand;	state Exp;
branches;
next	1.700;

1.700
date	2001.07.15.07.49.57;	author guerrand;	state Exp;
branches;
next	1.699;

1.699
date	2001.07.15.03.20.15;	author guerrand;	state Exp;
branches;
next	1.698;

1.698
date	2001.07.15.00.15.36;	author guerrand;	state Exp;
branches;
next	1.697;

1.697
date	2001.07.14.17.45.55;	author guerrand;	state Exp;
branches;
next	1.696;

1.696
date	2001.07.13.01.57.59;	author guerrand;	state Exp;
branches;
next	1.695;

1.695
date	2001.07.13.00.58.57;	author guerrand;	state Exp;
branches;
next	1.694;

1.694
date	2001.07.12.00.25.55;	author rage;	state Exp;
branches;
next	1.693;

1.693
date	2001.07.10.01.56.48;	author guerrand;	state Exp;
branches;
next	1.692;

1.692
date	2001.07.08.17.14.10;	author guerrand;	state Exp;
branches;
next	1.691;

1.691
date	2001.07.05.22.15.05;	author guerrand;	state Exp;
branches;
next	1.690;

1.690
date	2001.07.04.03.10.41;	author guerrand;	state Exp;
branches;
next	1.689;

1.689
date	2001.07.04.02.49.58;	author guerrand;	state Exp;
branches;
next	1.688;

1.688
date	2001.07.04.02.43.08;	author guerrand;	state Exp;
branches;
next	1.687;

1.687
date	2001.07.04.02.29.28;	author guerrand;	state Exp;
branches;
next	1.686;

1.686
date	2001.07.04.01.36.40;	author guerrand;	state Exp;
branches;
next	1.685;

1.685
date	2001.07.04.01.21.56;	author guerrand;	state Exp;
branches;
next	1.684;

1.684
date	2001.07.03.04.32.53;	author guerrand;	state Exp;
branches;
next	1.683;

1.683
date	2001.07.03.03.28.49;	author guerrand;	state Exp;
branches;
next	1.682;

1.682
date	2001.07.03.02.00.37;	author guerrand;	state Exp;
branches;
next	1.681;

1.681
date	2001.07.02.17.17.13;	author mud;	state Exp;
branches;
next	1.680;

1.680
date	2001.07.02.04.16.43;	author guerrand;	state Exp;
branches;
next	1.679;

1.679
date	2001.06.28.05.43.47;	author guerrand;	state Exp;
branches;
next	1.678;

1.678
date	2001.06.24.19.06.48;	author guerrand;	state Exp;
branches;
next	1.677;

1.677
date	2001.06.24.04.14.58;	author guerrand;	state Exp;
branches;
next	1.676;

1.676
date	2001.06.22.23.55.41;	author guerrand;	state Exp;
branches;
next	1.675;

1.675
date	2001.06.19.04.35.36;	author guerrand;	state Exp;
branches;
next	1.674;

1.674
date	2001.06.19.04.00.31;	author guerrand;	state Exp;
branches;
next	1.673;

1.673
date	2001.06.19.03.15.05;	author guerrand;	state Exp;
branches;
next	1.672;

1.672
date	2001.06.19.02.11.32;	author guerrand;	state Exp;
branches;
next	1.671;

1.671
date	2001.06.19.01.38.41;	author guerrand;	state Exp;
branches;
next	1.670;

1.670
date	2001.06.17.22.46.25;	author guerrand;	state Exp;
branches;
next	1.669;

1.669
date	2001.06.17.18.53.40;	author guerrand;	state Exp;
branches;
next	1.668;

1.668
date	2001.06.17.17.42.55;	author guerrand;	state Exp;
branches;
next	1.667;

1.667
date	2001.06.17.17.06.00;	author guerrand;	state Exp;
branches;
next	1.666;

1.666
date	2001.06.17.00.21.26;	author guerrand;	state Exp;
branches;
next	1.665;

1.665
date	2001.06.17.00.10.05;	author guerrand;	state Exp;
branches;
next	1.664;

1.664
date	2001.06.16.15.24.14;	author rage;	state Exp;
branches;
next	1.663;

1.663
date	2001.06.14.15.50.12;	author mud;	state Exp;
branches;
next	1.662;

1.662
date	2001.06.14.15.47.17;	author mud;	state Exp;
branches;
next	1.661;

1.661
date	2001.06.12.01.46.17;	author guerrand;	state Exp;
branches;
next	1.660;

1.660
date	2001.06.12.00.12.58;	author guerrand;	state Exp;
branches;
next	1.659;

1.659
date	2001.06.12.00.10.27;	author guerrand;	state Exp;
branches;
next	1.658;

1.658
date	2001.06.12.00.05.09;	author guerrand;	state Exp;
branches;
next	1.657;

1.657
date	2001.06.11.03.39.26;	author guerrand;	state Exp;
branches;
next	1.656;

1.656
date	2001.06.11.03.27.45;	author guerrand;	state Exp;
branches;
next	1.655;

1.655
date	2001.06.11.01.17.01;	author rage;	state Exp;
branches;
next	1.654;

1.654
date	2001.06.10.20.46.13;	author guerrand;	state Exp;
branches;
next	1.653;

1.653
date	2001.06.10.03.29.32;	author guerrand;	state Exp;
branches;
next	1.652;

1.652
date	2001.06.09.19.34.46;	author guerrand;	state Exp;
branches;
next	1.651;

1.651
date	2001.06.09.06.27.39;	author guerrand;	state Exp;
branches;
next	1.650;

1.650
date	2001.06.03.19.43.03;	author guerrand;	state Exp;
branches;
next	1.649;

1.649
date	2001.06.03.19.17.15;	author guerrand;	state Exp;
branches;
next	1.648;

1.648
date	2001.06.03.18.46.10;	author guerrand;	state Exp;
branches;
next	1.647;

1.647
date	2001.06.03.18.22.46;	author guerrand;	state Exp;
branches;
next	1.646;

1.646
date	2001.06.01.04.25.14;	author guerrand;	state Exp;
branches;
next	1.645;

1.645
date	2001.06.01.04.10.37;	author guerrand;	state Exp;
branches;
next	1.644;

1.644
date	2001.06.01.03.16.59;	author guerrand;	state Exp;
branches;
next	1.643;

1.643
date	2001.05.30.23.55.26;	author guerrand;	state Exp;
branches;
next	1.642;

1.642
date	2001.05.27.20.57.14;	author rusty;	state Exp;
branches;
next	1.641;

1.641
date	2001.05.26.03.10.26;	author rage;	state Exp;
branches;
next	1.640;

1.640
date	2001.05.25.17.33.12;	author poquah;	state Exp;
branches;
next	1.639;

1.639
date	2001.05.14.15.08.32;	author rusty;	state Exp;
branches;
next	1.638;

1.638
date	2001.04.11.18.38.23;	author mud;	state Exp;
branches;
next	1.637;

1.637
date	2001.04.09.02.58.26;	author mud;	state Exp;
branches;
next	1.636;

1.636
date	2001.04.09.01.30.26;	author mud;	state Exp;
branches;
next	1.635;

1.635
date	2001.03.26.17.20.08;	author mud;	state Exp;
branches;
next	1.634;

1.634
date	2001.03.25.15.16.51;	author mud;	state Exp;
branches;
next	1.633;

1.633
date	2001.03.20.17.44.29;	author mud;	state Exp;
branches;
next	1.632;

1.632
date	2001.03.14.21.55.11;	author mud;	state Exp;
branches;
next	1.631;

1.631
date	2001.03.11.03.16.20;	author mud;	state Exp;
branches;
next	1.630;

1.630
date	2001.03.11.02.19.03;	author mud;	state Exp;
branches;
next	1.629;

1.629
date	2001.03.11.01.15.50;	author mud;	state Exp;
branches;
next	1.628;

1.628
date	2001.03.10.23.54.35;	author mud;	state Exp;
branches;
next	1.627;

1.627
date	2001.03.10.23.09.35;	author mud;	state Exp;
branches;
next	1.626;

1.626
date	2001.03.03.18.57.14;	author mud;	state Exp;
branches;
next	1.625;

1.625
date	2001.03.03.18.55.20;	author mud;	state Exp;
branches;
next	1.624;

1.624
date	2001.03.03.18.53.57;	author mud;	state Exp;
branches;
next	1.623;

1.623
date	2001.03.03.15.47.25;	author mud;	state Exp;
branches;
next	1.622;

1.622
date	2001.03.03.15.44.59;	author mud;	state Exp;
branches;
next	1.621;

1.621
date	2001.03.03.15.40.42;	author mud;	state Exp;
branches;
next	1.620;

1.620
date	2001.03.03.15.32.26;	author mud;	state Exp;
branches;
next	1.619;

1.619
date	2001.02.27.18.53.22;	author mud;	state Exp;
branches;
next	1.618;

1.618
date	2001.02.26.07.10.59;	author mud;	state Exp;
branches;
next	1.617;

1.617
date	2001.02.13.20.23.26;	author mud;	state Exp;
branches;
next	1.616;

1.616
date	2001.02.10.14.17.38;	author mud;	state Exp;
branches;
next	1.615;

1.615
date	2001.02.10.13.55.02;	author mud;	state Exp;
branches;
next	1.614;

1.614
date	2001.02.10.03.27.01;	author mud;	state Exp;
branches;
next	1.613;

1.613
date	2001.02.04.02.53.01;	author mud;	state Exp;
branches;
next	1.612;

1.612
date	2001.02.04.02.18.25;	author mud;	state Exp;
branches;
next	1.611;

1.611
date	2001.01.26.15.16.42;	author mud;	state Exp;
branches;
next	1.610;

1.610
date	2001.01.25.18.07.55;	author mud;	state Exp;
branches;
next	1.609;

1.609
date	2001.01.20.08.34.00;	author mud;	state Exp;
branches;
next	1.608;

1.608
date	2001.01.20.08.32.48;	author mud;	state Exp;
branches;
next	1.607;

1.607
date	2000.12.27.04.27.40;	author mud;	state Exp;
branches;
next	1.606;

1.606
date	2000.12.25.11.08.25;	author mud;	state Exp;
branches;
next	1.605;

1.605
date	2000.12.24.17.46.06;	author mud;	state Exp;
branches;
next	1.604;

1.604
date	2000.12.15.06.39.43;	author mud;	state Exp;
branches;
next	1.603;

1.603
date	2000.12.15.06.33.13;	author mud;	state Exp;
branches;
next	1.602;

1.602
date	2000.12.15.06.22.30;	author mud;	state Exp;
branches;
next	1.601;

1.601
date	2000.12.15.06.14.38;	author mud;	state Exp;
branches;
next	1.600;

1.600
date	2000.12.15.06.09.59;	author mud;	state Exp;
branches;
next	1.599;

1.599
date	2000.12.15.00.27.14;	author mud;	state Exp;
branches;
next	1.598;

1.598
date	2000.12.15.00.00.29;	author mud;	state Exp;
branches;
next	1.597;

1.597
date	2000.12.14.23.55.16;	author mud;	state Exp;
branches;
next	1.596;

1.596
date	2000.12.14.23.38.10;	author mud;	state Exp;
branches;
next	1.595;

1.595
date	2000.12.14.05.11.12;	author mud;	state Exp;
branches;
next	1.594;

1.594
date	2000.12.14.04.32.48;	author mud;	state Exp;
branches;
next	1.593;

1.593
date	2000.12.14.04.11.21;	author mud;	state Exp;
branches;
next	1.592;

1.592
date	2000.12.14.03.50.28;	author mud;	state Exp;
branches;
next	1.591;

1.591
date	2000.12.13.05.03.40;	author mud;	state Exp;
branches;
next	1.590;

1.590
date	2000.12.12.22.48.10;	author mud;	state Exp;
branches;
next	1.589;

1.589
date	2000.12.12.22.38.50;	author mud;	state Exp;
branches;
next	1.588;

1.588
date	2000.12.12.22.35.40;	author mud;	state Exp;
branches;
next	1.587;

1.587
date	2000.12.12.21.44.24;	author mud;	state Exp;
branches;
next	1.586;

1.586
date	2000.12.12.21.43.35;	author mud;	state Exp;
branches;
next	1.585;

1.585
date	2000.12.12.21.42.02;	author mud;	state Exp;
branches;
next	1.584;

1.584
date	2000.12.09.07.05.48;	author mud;	state Exp;
branches;
next	1.583;

1.583
date	2000.12.07.06.45.44;	author mud;	state Exp;
branches;
next	1.582;

1.582
date	2000.12.07.05.46.11;	author mud;	state Exp;
branches;
next	1.581;

1.581
date	2000.12.06.04.40.40;	author mud;	state Exp;
branches;
next	1.580;

1.580
date	2000.12.04.04.42.14;	author mud;	state Exp;
branches;
next	1.579;

1.579
date	2000.12.03.22.59.01;	author mud;	state Exp;
branches;
next	1.578;

1.578
date	2000.12.03.03.24.01;	author mud;	state Exp;
branches;
next	1.577;

1.577
date	2000.11.27.00.03.47;	author mud;	state Exp;
branches;
next	1.576;

1.576
date	2000.11.27.00.01.33;	author mud;	state Exp;
branches;
next	1.575;

1.575
date	2000.11.26.23.46.57;	author mud;	state Exp;
branches;
next	1.574;

1.574
date	2000.11.24.23.23.15;	author mud;	state Exp;
branches;
next	1.573;

1.573
date	2000.11.19.18.56.23;	author mud;	state Exp;
branches;
next	1.572;

1.572
date	2000.10.26.12.22.47;	author mud;	state Exp;
branches;
next	1.571;

1.571
date	2000.10.25.12.44.55;	author mud;	state Exp;
branches;
next	1.570;

1.570
date	2000.10.25.12.42.07;	author mud;	state Exp;
branches;
next	1.569;

1.569
date	2000.10.23.22.05.56;	author mud;	state Exp;
branches;
next	1.568;

1.568
date	2000.10.20.18.14.14;	author mud;	state Exp;
branches;
next	1.567;

1.567
date	2000.10.20.18.07.28;	author mud;	state Exp;
branches;
next	1.566;

1.566
date	2000.10.18.17.05.16;	author mud;	state Exp;
branches;
next	1.565;

1.565
date	2000.10.17.22.45.33;	author mud;	state Exp;
branches;
next	1.564;

1.564
date	2000.10.16.23.05.29;	author mud;	state Exp;
branches;
next	1.563;

1.563
date	2000.10.16.19.17.00;	author mud;	state Exp;
branches;
next	1.562;

1.562
date	2000.10.12.22.04.54;	author mud;	state Exp;
branches;
next	1.561;

1.561
date	2000.10.08.18.30.16;	author mud;	state Exp;
branches;
next	1.560;

1.560
date	2000.10.07.21.28.56;	author mud;	state Exp;
branches;
next	1.559;

1.559
date	2000.10.01.19.03.04;	author mud;	state Exp;
branches;
next	1.558;

1.558
date	2000.09.26.07.00.15;	author mud;	state Exp;
branches;
next	1.557;

1.557
date	2000.09.24.21.30.37;	author mud;	state Exp;
branches;
next	1.556;

1.556
date	2000.09.24.21.27.38;	author mud;	state Exp;
branches;
next	1.555;

1.555
date	2000.09.20.22.54.18;	author mud;	state Exp;
branches;
next	1.554;

1.554
date	2000.09.20.22.35.41;	author mud;	state Exp;
branches;
next	1.553;

1.553
date	2000.09.19.20.47.11;	author mud;	state Exp;
branches;
next	1.552;

1.552
date	2000.09.16.03.48.31;	author mud;	state Exp;
branches;
next	1.551;

1.551
date	2000.09.13.14.01.49;	author mud;	state Exp;
branches;
next	1.550;

1.550
date	2000.09.12.15.57.44;	author mud;	state Exp;
branches;
next	1.549;

1.549
date	2000.09.11.21.15.11;	author mud;	state Exp;
branches;
next	1.548;

1.548
date	2000.09.10.18.30.26;	author mud;	state Exp;
branches;
next	1.547;

1.547
date	2000.09.10.18.24.32;	author mud;	state Exp;
branches;
next	1.546;

1.546
date	2000.09.10.15.12.29;	author mud;	state Exp;
branches;
next	1.545;

1.545
date	2000.09.09.17.49.52;	author mud;	state Exp;
branches;
next	1.544;

1.544
date	2000.09.09.17.41.46;	author mud;	state Exp;
branches;
next	1.543;

1.543
date	2000.09.09.16.32.09;	author mud;	state Exp;
branches;
next	1.542;

1.542
date	2000.09.09.16.20.35;	author mud;	state Exp;
branches;
next	1.541;

1.541
date	2000.09.09.06.04.02;	author mud;	state Exp;
branches;
next	1.540;

1.540
date	2000.09.09.05.55.45;	author mud;	state Exp;
branches;
next	1.539;

1.539
date	2000.09.09.05.45.15;	author mud;	state Exp;
branches;
next	1.538;

1.538
date	2000.09.09.05.05.55;	author mud;	state Exp;
branches;
next	1.537;

1.537
date	2000.09.09.04.59.48;	author mud;	state Exp;
branches;
next	1.536;

1.536
date	2000.09.09.04.50.23;	author mud;	state Exp;
branches;
next	1.535;

1.535
date	2000.09.09.04.39.56;	author mud;	state Exp;
branches;
next	1.534;

1.534
date	2000.09.09.04.30.44;	author mud;	state Exp;
branches;
next	1.533;

1.533
date	2000.09.09.04.23.16;	author mud;	state Exp;
branches;
next	1.532;

1.532
date	2000.09.09.04.05.38;	author mud;	state Exp;
branches;
next	1.531;

1.531
date	2000.09.09.03.58.12;	author mud;	state Exp;
branches;
next	1.530;

1.530
date	2000.09.09.03.44.52;	author mud;	state Exp;
branches;
next	1.529;

1.529
date	2000.09.08.03.54.35;	author mud;	state Exp;
branches;
next	1.528;

1.528
date	2000.09.04.18.09.35;	author mud;	state Exp;
branches;
next	1.527;

1.527
date	2000.09.04.16.12.07;	author mud;	state Exp;
branches;
next	1.526;

1.526
date	2000.09.04.15.28.42;	author mud;	state Exp;
branches;
next	1.525;

1.525
date	2000.09.04.05.40.45;	author mud;	state Exp;
branches;
next	1.524;

1.524
date	2000.09.04.03.47.36;	author mud;	state Exp;
branches;
next	1.523;

1.523
date	2000.09.03.22.45.34;	author mud;	state Exp;
branches;
next	1.522;

1.522
date	2000.09.03.22.04.37;	author mud;	state Exp;
branches;
next	1.521;

1.521
date	2000.09.03.21.19.27;	author mud;	state Exp;
branches;
next	1.520;

1.520
date	2000.09.03.21.06.47;	author mud;	state Exp;
branches;
next	1.519;

1.519
date	2000.09.02.22.55.56;	author mud;	state Exp;
branches;
next	1.518;

1.518
date	2000.08.31.12.39.57;	author mud;	state Exp;
branches;
next	1.517;

1.517
date	2000.08.28.13.38.06;	author mud;	state Exp;
branches;
next	1.516;

1.516
date	2000.08.27.23.23.06;	author mud;	state Exp;
branches;
next	1.515;

1.515
date	2000.08.26.18.38.11;	author mud;	state Exp;
branches;
next	1.514;

1.514
date	2000.08.24.19.23.58;	author mud;	state Exp;
branches;
next	1.513;

1.513
date	2000.08.20.01.14.47;	author mud;	state Exp;
branches;
next	1.512;

1.512
date	2000.08.20.00.15.18;	author mud;	state Exp;
branches;
next	1.511;

1.511
date	2000.08.20.00.11.25;	author mud;	state Exp;
branches;
next	1.510;

1.510
date	2000.08.19.22.58.13;	author mud;	state Exp;
branches;
next	1.509;

1.509
date	2000.08.19.21.56.26;	author mud;	state Exp;
branches;
next	1.508;

1.508
date	2000.08.18.23.52.34;	author mud;	state Exp;
branches;
next	1.507;

1.507
date	2000.08.18.22.52.08;	author mud;	state Exp;
branches;
next	1.506;

1.506
date	2000.08.18.22.49.02;	author mud;	state Exp;
branches;
next	1.505;

1.505
date	2000.08.18.00.20.46;	author mud;	state Exp;
branches;
next	1.504;

1.504
date	2000.08.16.19.01.44;	author mud;	state Exp;
branches;
next	1.503;

1.503
date	2000.08.16.19.00.42;	author mud;	state Exp;
branches;
next	1.502;

1.502
date	2000.08.16.15.27.15;	author mud;	state Exp;
branches;
next	1.501;

1.501
date	2000.08.16.15.26.21;	author mud;	state Exp;
branches;
next	1.500;

1.500
date	2000.08.13.04.31.26;	author mud;	state Exp;
branches;
next	1.499;

1.499
date	2000.08.12.22.56.21;	author mud;	state Exp;
branches;
next	1.498;

1.498
date	2000.08.10.21.12.35;	author mud;	state Exp;
branches;
next	1.497;

1.497
date	2000.07.28.15.22.33;	author mud;	state Exp;
branches;
next	1.496;

1.496
date	2000.07.28.15.10.04;	author mud;	state Exp;
branches;
next	1.495;

1.495
date	2000.07.28.15.03.48;	author mud;	state Exp;
branches;
next	1.494;

1.494
date	2000.07.27.18.11.51;	author mud;	state Exp;
branches;
next	1.493;

1.493
date	2000.07.27.00.37.07;	author mud;	state Exp;
branches;
next	1.492;

1.492
date	2000.07.26.02.38.28;	author mud;	state Exp;
branches;
next	1.491;

1.491
date	2000.07.25.19.43.46;	author mud;	state Exp;
branches;
next	1.490;

1.490
date	2000.07.25.00.42.39;	author mud;	state Exp;
branches;
next	1.489;

1.489
date	2000.07.24.20.56.46;	author mud;	state Exp;
branches;
next	1.488;

1.488
date	2000.07.24.20.47.54;	author mud;	state Exp;
branches;
next	1.487;

1.487
date	2000.07.24.20.32.23;	author mud;	state Exp;
branches;
next	1.486;

1.486
date	2000.07.24.20.16.59;	author mud;	state Exp;
branches;
next	1.485;

1.485
date	2000.07.24.20.13.14;	author mud;	state Exp;
branches;
next	1.484;

1.484
date	2000.07.24.20.12.07;	author mud;	state Exp;
branches;
next	1.483;

1.483
date	2000.07.24.20.08.37;	author mud;	state Exp;
branches;
next	1.482;

1.482
date	2000.07.22.21.45.21;	author mud;	state Exp;
branches;
next	1.481;

1.481
date	2000.07.21.21.51.21;	author mud;	state Exp;
branches;
next	1.480;

1.480
date	2000.07.20.22.16.27;	author mud;	state Exp;
branches;
next	1.479;

1.479
date	2000.07.20.20.37.49;	author mud;	state Exp;
branches;
next	1.478;

1.478
date	2000.07.20.20.12.36;	author mud;	state Exp;
branches;
next	1.477;

1.477
date	2000.07.18.17.06.28;	author mud;	state Exp;
branches;
next	1.476;

1.476
date	2000.07.18.00.56.55;	author mud;	state Exp;
branches;
next	1.475;

1.475
date	2000.07.14.16.50.37;	author mud;	state Exp;
branches;
next	1.474;

1.474
date	2000.07.14.13.25.28;	author mud;	state Exp;
branches;
next	1.473;

1.473
date	2000.07.13.20.02.19;	author mud;	state Exp;
branches;
next	1.472;

1.472
date	2000.07.13.18.40.43;	author mud;	state Exp;
branches;
next	1.471;

1.471
date	2000.07.13.01.25.21;	author mud;	state Exp;
branches;
next	1.470;

1.470
date	2000.07.12.23.56.25;	author mud;	state Exp;
branches;
next	1.469;

1.469
date	2000.07.12.22.22.14;	author mud;	state Exp;
branches;
next	1.468;

1.468
date	2000.07.06.15.35.57;	author mud;	state Exp;
branches;
next	1.467;

1.467
date	2000.06.29.22.57.49;	author mud;	state Exp;
branches;
next	1.466;

1.466
date	2000.06.27.04.23.25;	author mud;	state Exp;
branches;
next	1.465;

1.465
date	2000.06.27.03.52.47;	author mud;	state Exp;
branches;
next	1.464;

1.464
date	2000.06.26.06.29.37;	author mud;	state Exp;
branches;
next	1.463;

1.463
date	2000.06.26.04.20.28;	author mud;	state Exp;
branches;
next	1.462;

1.462
date	2000.06.26.00.18.32;	author mud;	state Exp;
branches;
next	1.461;

1.461
date	2000.06.25.23.41.33;	author mud;	state Exp;
branches;
next	1.460;

1.460
date	2000.06.25.23.31.01;	author mud;	state Exp;
branches;
next	1.459;

1.459
date	2000.06.23.19.37.27;	author mud;	state Exp;
branches;
next	1.458;

1.458
date	2000.06.23.19.16.53;	author mud;	state Exp;
branches;
next	1.457;

1.457
date	2000.06.23.10.40.29;	author mud;	state Exp;
branches;
next	1.456;

1.456
date	2000.06.23.09.43.51;	author mud;	state Exp;
branches;
next	1.455;

1.455
date	2000.06.23.09.27.24;	author mud;	state Exp;
branches;
next	1.454;

1.454
date	2000.06.23.09.25.47;	author mud;	state Exp;
branches;
next	1.453;

1.453
date	2000.06.22.22.50.16;	author mud;	state Exp;
branches;
next	1.452;

1.452
date	2000.06.14.01.07.29;	author mud;	state Exp;
branches;
next	1.451;

1.451
date	2000.06.14.01.01.10;	author mud;	state Exp;
branches;
next	1.450;

1.450
date	2000.05.30.00.26.41;	author mud;	state Exp;
branches;
next	1.449;

1.449
date	2000.05.29.19.37.03;	author mud;	state Exp;
branches;
next	1.448;

1.448
date	2000.05.27.03.42.40;	author mud;	state Exp;
branches;
next	1.447;

1.447
date	2000.05.27.02.44.10;	author mud;	state Exp;
branches;
next	1.446;

1.446
date	2000.05.26.14.07.11;	author mud;	state Exp;
branches;
next	1.445;

1.445
date	2000.05.26.02.07.29;	author mud;	state Exp;
branches;
next	1.444;

1.444
date	2000.05.26.01.46.27;	author mud;	state Exp;
branches;
next	1.443;

1.443
date	2000.05.25.14.47.16;	author mud;	state Exp;
branches;
next	1.442;

1.442
date	2000.05.24.03.38.30;	author mud;	state Exp;
branches;
next	1.441;

1.441
date	2000.05.24.02.53.26;	author mud;	state Exp;
branches;
next	1.440;

1.440
date	2000.05.24.00.25.10;	author mud;	state Exp;
branches;
next	1.439;

1.439
date	2000.05.23.04.58.58;	author mud;	state Exp;
branches;
next	1.438;

1.438
date	2000.05.23.04.12.39;	author mud;	state Exp;
branches;
next	1.437;

1.437
date	2000.05.23.00.29.07;	author mud;	state Exp;
branches;
next	1.436;

1.436
date	2000.05.21.01.22.45;	author mud;	state Exp;
branches;
next	1.435;

1.435
date	2000.05.21.00.28.55;	author mud;	state Exp;
branches;
next	1.434;

1.434
date	2000.05.20.23.47.58;	author mud;	state Exp;
branches;
next	1.433;

1.433
date	2000.05.20.03.04.15;	author mud;	state Exp;
branches;
next	1.432;

1.432
date	2000.05.19.13.43.59;	author mud;	state Exp;
branches;
next	1.431;

1.431
date	2000.05.18.14.14.17;	author mud;	state Exp;
branches;
next	1.430;

1.430
date	2000.05.17.17.13.39;	author mud;	state Exp;
branches;
next	1.429;

1.429
date	2000.05.17.15.46.07;	author mud;	state Exp;
branches;
next	1.428;

1.428
date	2000.05.17.03.39.43;	author mud;	state Exp;
branches;
next	1.427;

1.427
date	2000.05.17.03.14.50;	author mud;	state Exp;
branches;
next	1.426;

1.426
date	2000.05.17.02.36.13;	author mud;	state Exp;
branches;
next	1.425;

1.425
date	2000.05.16.22.43.22;	author mud;	state Exp;
branches;
next	1.424;

1.424
date	2000.05.16.15.01.29;	author mud;	state Exp;
branches;
next	1.423;

1.423
date	2000.05.16.00.56.00;	author mud;	state Exp;
branches;
next	1.422;

1.422
date	2000.05.14.00.24.33;	author mud;	state Exp;
branches;
next	1.421;

1.421
date	2000.05.14.00.20.44;	author mud;	state Exp;
branches;
next	1.420;

1.420
date	2000.05.13.22.37.23;	author mud;	state Exp;
branches;
next	1.419;

1.419
date	2000.05.13.21.55.12;	author mud;	state Exp;
branches;
next	1.418;

1.418
date	2000.04.26.20.24.33;	author mud;	state Exp;
branches;
next	1.417;

1.417
date	2000.04.25.01.02.34;	author mud;	state Exp;
branches;
next	1.416;

1.416
date	2000.04.25.01.00.04;	author mud;	state Exp;
branches;
next	1.415;

1.415
date	2000.04.18.20.33.50;	author mud;	state Exp;
branches;
next	1.414;

1.414
date	2000.04.18.19.50.57;	author mud;	state Exp;
branches;
next	1.413;

1.413
date	2000.04.17.22.00.48;	author mud;	state Exp;
branches;
next	1.412;

1.412
date	2000.04.17.21.22.39;	author mud;	state Exp;
branches;
next	1.411;

1.411
date	2000.04.17.21.04.01;	author mud;	state Exp;
branches;
next	1.410;

1.410
date	2000.04.04.16.37.53;	author mud;	state Exp;
branches;
next	1.409;

1.409
date	2000.04.02.05.26.35;	author mud;	state Exp;
branches;
next	1.408;

1.408
date	2000.04.01.15.26.48;	author mud;	state Exp;
branches;
next	1.407;

1.407
date	2000.04.01.15.20.59;	author mud;	state Exp;
branches;
next	1.406;

1.406
date	2000.03.27.05.27.41;	author mud;	state Exp;
branches;
next	1.405;

1.405
date	2000.03.26.19.58.27;	author mud;	state Exp;
branches;
next	1.404;

1.404
date	2000.03.25.20.40.26;	author mud;	state Exp;
branches;
next	1.403;

1.403
date	2000.03.25.20.31.40;	author mud;	state Exp;
branches;
next	1.402;

1.402
date	2000.03.20.23.22.27;	author mud;	state Exp;
branches;
next	1.401;

1.401
date	2000.03.20.22.17.14;	author mud;	state Exp;
branches;
next	1.400;

1.400
date	2000.03.20.15.05.44;	author mud;	state Exp;
branches;
next	1.399;

1.399
date	2000.03.15.19.40.11;	author mud;	state Exp;
branches;
next	1.398;

1.398
date	2000.03.15.19.07.59;	author mud;	state Exp;
branches;
next	1.397;

1.397
date	2000.03.15.18.27.06;	author mud;	state Exp;
branches;
next	1.396;

1.396
date	2000.03.15.18.18.00;	author mud;	state Exp;
branches;
next	1.395;

1.395
date	2000.03.15.17.39.32;	author mud;	state Exp;
branches;
next	1.394;

1.394
date	2000.03.15.16.24.51;	author mud;	state Exp;
branches;
next	1.393;

1.393
date	2000.03.14.21.29.51;	author mud;	state Exp;
branches;
next	1.392;

1.392
date	2000.03.14.00.50.14;	author mud;	state Exp;
branches;
next	1.391;

1.391
date	2000.03.12.00.32.44;	author mud;	state Exp;
branches;
next	1.390;

1.390
date	2000.03.07.15.43.31;	author mud;	state Exp;
branches;
next	1.389;

1.389
date	2000.03.07.14.38.51;	author mud;	state Exp;
branches;
next	1.388;

1.388
date	2000.03.06.23.59.30;	author mud;	state Exp;
branches;
next	1.387;

1.387
date	2000.03.06.21.58.04;	author mud;	state Exp;
branches;
next	1.386;

1.386
date	2000.03.06.18.11.40;	author mud;	state Exp;
branches;
next	1.385;

1.385
date	2000.03.06.18.06.55;	author mud;	state Exp;
branches;
next	1.384;

1.384
date	2000.03.06.18.04.01;	author mud;	state Exp;
branches;
next	1.383;

1.383
date	2000.03.06.16.50.21;	author mud;	state Exp;
branches;
next	1.382;

1.382
date	2000.03.06.15.59.21;	author mud;	state Exp;
branches;
next	1.381;

1.381
date	2000.03.06.14.34.55;	author mud;	state Exp;
branches;
next	1.380;

1.380
date	2000.03.06.01.06.59;	author mud;	state Exp;
branches;
next	1.379;

1.379
date	2000.03.06.01.04.58;	author mud;	state Exp;
branches;
next	1.378;

1.378
date	2000.03.06.00.57.56;	author mud;	state Exp;
branches;
next	1.377;

1.377
date	2000.03.06.00.32.09;	author mud;	state Exp;
branches;
next	1.376;

1.376
date	2000.03.06.00.27.11;	author mud;	state Exp;
branches;
next	1.375;

1.375
date	2000.03.06.00.23.38;	author mud;	state Exp;
branches;
next	1.374;

1.374
date	2000.02.29.20.46.45;	author mud;	state Exp;
branches;
next	1.373;

1.373
date	2000.02.29.01.05.16;	author mud;	state Exp;
branches;
next	1.372;

1.372
date	2000.02.28.18.43.32;	author mud;	state Exp;
branches;
next	1.371;

1.371
date	2000.02.27.00.45.07;	author mud;	state Exp;
branches;
next	1.370;

1.370
date	2000.02.26.23.39.45;	author mud;	state Exp;
branches;
next	1.369;

1.369
date	2000.02.26.23.20.33;	author mud;	state Exp;
branches;
next	1.368;

1.368
date	2000.02.26.22.55.53;	author mud;	state Exp;
branches;
next	1.367;

1.367
date	2000.02.26.22.15.22;	author mud;	state Exp;
branches;
next	1.366;

1.366
date	2000.02.25.23.16.20;	author mud;	state Exp;
branches;
next	1.365;

1.365
date	2000.02.24.18.16.16;	author mud;	state Exp;
branches;
next	1.364;

1.364
date	2000.02.24.15.37.02;	author mud;	state Exp;
branches;
next	1.363;

1.363
date	2000.02.24.05.36.34;	author mud;	state Exp;
branches;
next	1.362;

1.362
date	2000.02.24.04.50.16;	author mud;	state Exp;
branches;
next	1.361;

1.361
date	2000.02.24.02.54.29;	author mud;	state Exp;
branches;
next	1.360;

1.360
date	2000.02.23.21.47.37;	author mud;	state Exp;
branches;
next	1.359;

1.359
date	2000.02.23.21.40.12;	author mud;	state Exp;
branches;
next	1.358;

1.358
date	2000.02.22.04.04.24;	author mud;	state Exp;
branches;
next	1.357;

1.357
date	2000.02.19.18.50.37;	author mud;	state Exp;
branches;
next	1.356;

1.356
date	2000.02.11.20.20.41;	author mud;	state Exp;
branches;
next	1.355;

1.355
date	2000.02.10.18.33.39;	author mud;	state Exp;
branches;
next	1.354;

1.354
date	2000.02.10.17.45.15;	author mud;	state Exp;
branches;
next	1.353;

1.353
date	2000.02.10.17.43.32;	author mud;	state Exp;
branches;
next	1.352;

1.352
date	2000.02.10.03.30.13;	author mud;	state Exp;
branches;
next	1.351;

1.351
date	2000.02.10.03.09.09;	author mud;	state Exp;
branches;
next	1.350;

1.350
date	2000.02.06.19.08.53;	author mud;	state Exp;
branches;
next	1.349;

1.349
date	2000.02.05.01.34.22;	author mud;	state Exp;
branches;
next	1.348;

1.348
date	2000.02.04.23.34.28;	author mud;	state Exp;
branches;
next	1.347;

1.347
date	2000.01.26.15.55.59;	author mud;	state Exp;
branches;
next	1.346;

1.346
date	2000.01.25.17.08.19;	author mud;	state Exp;
branches;
next	1.345;

1.345
date	2000.01.23.17.05.17;	author mud;	state Exp;
branches;
next	1.344;

1.344
date	2000.01.23.14.59.09;	author mud;	state Exp;
branches;
next	1.343;

1.343
date	2000.01.22.01.20.28;	author mud;	state Exp;
branches;
next	1.342;

1.342
date	2000.01.21.21.42.41;	author mud;	state Exp;
branches;
next	1.341;

1.341
date	2000.01.21.19.13.08;	author mud;	state Exp;
branches;
next	1.340;

1.340
date	2000.01.21.18.45.58;	author mud;	state Exp;
branches;
next	1.339;

1.339
date	2000.01.20.23.33.34;	author mud;	state Exp;
branches;
next	1.338;

1.338
date	99.12.26.19.05.22;	author mud;	state Exp;
branches;
next	1.337;

1.337
date	99.12.25.14.45.58;	author mud;	state Exp;
branches;
next	1.336;

1.336
date	99.12.17.00.03.47;	author mud;	state Exp;
branches;
next	1.335;

1.335
date	99.12.17.00.02.13;	author mud;	state Exp;
branches;
next	1.334;

1.334
date	99.12.14.21.48.13;	author mud;	state Exp;
branches;
next	1.333;

1.333
date	99.12.09.18.30.38;	author mud;	state Exp;
branches;
next	1.332;

1.332
date	99.12.09.18.22.15;	author mud;	state Exp;
branches;
next	1.331;

1.331
date	99.12.09.18.05.59;	author mud;	state Exp;
branches;
next	1.330;

1.330
date	99.12.09.17.58.07;	author mud;	state Exp;
branches;
next	1.329;

1.329
date	99.12.07.22.31.25;	author mud;	state Exp;
branches;
next	1.328;

1.328
date	99.12.07.22.29.19;	author mud;	state Exp;
branches;
next	1.327;

1.327
date	99.12.07.21.47.48;	author mud;	state Exp;
branches;
next	1.326;

1.326
date	99.12.07.21.44.16;	author mud;	state Exp;
branches;
next	1.325;

1.325
date	99.12.07.20.52.11;	author mud;	state Exp;
branches;
next	1.324;

1.324
date	99.12.07.19.40.10;	author mud;	state Exp;
branches;
next	1.323;

1.323
date	99.12.07.19.36.26;	author mud;	state Exp;
branches;
next	1.322;

1.322
date	99.12.06.01.18.03;	author mud;	state Exp;
branches;
next	1.321;

1.321
date	99.12.06.01.13.34;	author mud;	state Exp;
branches;
next	1.320;

1.320
date	99.12.02.21.32.23;	author mud;	state Exp;
branches;
next	1.319;

1.319
date	99.12.02.18.01.42;	author mud;	state Exp;
branches;
next	1.318;

1.318
date	99.12.01.22.13.47;	author mud;	state Exp;
branches;
next	1.317;

1.317
date	99.11.30.21.41.16;	author mud;	state Exp;
branches;
next	1.316;

1.316
date	99.11.28.23.53.40;	author mud;	state Exp;
branches;
next	1.315;

1.315
date	99.11.28.21.57.29;	author mud;	state Exp;
branches;
next	1.314;

1.314
date	99.11.28.20.22.13;	author mud;	state Exp;
branches;
next	1.313;

1.313
date	99.11.26.21.03.04;	author mud;	state Exp;
branches;
next	1.312;

1.312
date	99.11.26.19.32.04;	author mud;	state Exp;
branches;
next	1.311;

1.311
date	99.11.26.19.27.18;	author mud;	state Exp;
branches;
next	1.310;

1.310
date	99.11.26.04.50.57;	author mud;	state Exp;
branches;
next	1.309;

1.309
date	99.11.25.19.35.44;	author mud;	state Exp;
branches;
next	1.308;

1.308
date	99.11.25.19.33.19;	author mud;	state Exp;
branches;
next	1.307;

1.307
date	99.11.25.19.31.41;	author mud;	state Exp;
branches;
next	1.306;

1.306
date	99.11.25.03.48.11;	author mud;	state Exp;
branches;
next	1.305;

1.305
date	99.11.25.00.56.00;	author mud;	state Exp;
branches;
next	1.304;

1.304
date	99.11.25.00.38.30;	author mud;	state Exp;
branches;
next	1.303;

1.303
date	99.11.25.00.06.37;	author mud;	state Exp;
branches;
next	1.302;

1.302
date	99.11.24.23.58.06;	author mud;	state Exp;
branches;
next	1.301;

1.301
date	99.11.24.23.45.28;	author mud;	state Exp;
branches;
next	1.300;

1.300
date	99.11.24.23.27.04;	author mud;	state Exp;
branches;
next	1.299;

1.299
date	99.11.24.22.45.21;	author mud;	state Exp;
branches;
next	1.298;

1.298
date	99.11.24.22.04.36;	author mud;	state Exp;
branches;
next	1.297;

1.297
date	99.11.24.22.00.52;	author mud;	state Exp;
branches;
next	1.296;

1.296
date	99.11.24.16.33.52;	author mud;	state Exp;
branches;
next	1.295;

1.295
date	99.11.24.08.46.20;	author mud;	state Exp;
branches;
next	1.294;

1.294
date	99.11.24.04.17.12;	author mud;	state Exp;
branches;
next	1.293;

1.293
date	99.11.23.02.43.24;	author mud;	state Exp;
branches;
next	1.292;

1.292
date	99.11.22.02.10.44;	author mud;	state Exp;
branches;
next	1.291;

1.291
date	99.11.22.01.40.50;	author mud;	state Exp;
branches;
next	1.290;

1.290
date	99.11.20.23.47.25;	author mud;	state Exp;
branches;
next	1.289;

1.289
date	99.11.20.22.44.46;	author mud;	state Exp;
branches;
next	1.288;

1.288
date	99.11.20.22.28.31;	author mud;	state Exp;
branches;
next	1.287;

1.287
date	99.11.20.22.10.21;	author mud;	state Exp;
branches;
next	1.286;

1.286
date	99.11.20.21.59.36;	author mud;	state Exp;
branches;
next	1.285;

1.285
date	99.11.20.21.44.59;	author mud;	state Exp;
branches;
next	1.284;

1.284
date	99.11.19.19.26.18;	author mud;	state Exp;
branches;
next	1.283;

1.283
date	99.11.19.05.41.17;	author mud;	state Exp;
branches;
next	1.282;

1.282
date	99.11.19.02.06.05;	author mud;	state Exp;
branches;
next	1.281;

1.281
date	99.11.19.01.11.37;	author mud;	state Exp;
branches;
next	1.280;

1.280
date	99.11.19.01.09.31;	author mud;	state Exp;
branches;
next	1.279;

1.279
date	99.11.19.01.05.35;	author mud;	state Exp;
branches;
next	1.278;

1.278
date	99.11.16.21.25.56;	author mud;	state Exp;
branches;
next	1.277;

1.277
date	99.11.12.19.02.00;	author mud;	state Exp;
branches;
next	1.276;

1.276
date	99.11.12.17.59.08;	author mud;	state Exp;
branches;
next	1.275;

1.275
date	99.11.11.18.26.05;	author mud;	state Exp;
branches;
next	1.274;

1.274
date	99.11.09.00.22.21;	author mud;	state Exp;
branches;
next	1.273;

1.273
date	99.11.09.00.19.36;	author mud;	state Exp;
branches;
next	1.272;

1.272
date	99.11.09.00.19.00;	author mud;	state Exp;
branches;
next	1.271;

1.271
date	99.11.08.21.39.35;	author mud;	state Exp;
branches;
next	1.270;

1.270
date	99.11.08.20.02.02;	author mud;	state Exp;
branches;
next	1.269;

1.269
date	99.11.06.19.07.04;	author mud;	state Exp;
branches;
next	1.268;

1.268
date	99.11.05.18.23.58;	author mud;	state Exp;
branches;
next	1.267;

1.267
date	99.11.05.08.39.51;	author mud;	state Exp;
branches;
next	1.266;

1.266
date	99.11.05.08.30.55;	author mud;	state Exp;
branches;
next	1.265;

1.265
date	99.11.05.08.19.13;	author mud;	state Exp;
branches;
next	1.264;

1.264
date	99.11.05.03.50.59;	author mud;	state Exp;
branches;
next	1.263;

1.263
date	99.11.04.22.16.55;	author mud;	state Exp;
branches;
next	1.262;

1.262
date	99.11.04.21.43.30;	author mud;	state Exp;
branches;
next	1.261;

1.261
date	99.11.04.01.27.21;	author mud;	state Exp;
branches;
next	1.260;

1.260
date	99.11.03.22.10.13;	author mud;	state Exp;
branches;
next	1.259;

1.259
date	99.11.03.22.06.31;	author mud;	state Exp;
branches;
next	1.258;

1.258
date	99.11.03.21.35.00;	author mud;	state Exp;
branches;
next	1.257;

1.257
date	99.11.03.21.28.36;	author mud;	state Exp;
branches;
next	1.256;

1.256
date	99.11.03.20.06.08;	author mud;	state Exp;
branches;
next	1.255;

1.255
date	99.11.03.20.02.51;	author mud;	state Exp;
branches;
next	1.254;

1.254
date	99.11.03.20.00.05;	author mud;	state Exp;
branches;
next	1.253;

1.253
date	99.11.03.03.56.39;	author mud;	state Exp;
branches;
next	1.252;

1.252
date	99.11.03.02.39.29;	author mud;	state Exp;
branches;
next	1.251;

1.251
date	99.11.03.02.36.44;	author mud;	state Exp;
branches;
next	1.250;

1.250
date	99.11.03.02.29.24;	author mud;	state Exp;
branches;
next	1.249;

1.249
date	99.11.03.02.23.57;	author mud;	state Exp;
branches;
next	1.248;

1.248
date	99.11.03.02.12.49;	author mud;	state Exp;
branches;
next	1.247;

1.247
date	99.11.03.00.10.00;	author mud;	state Exp;
branches;
next	1.246;

1.246
date	99.11.02.08.05.13;	author mud;	state Exp;
branches;
next	1.245;

1.245
date	99.11.02.08.03.23;	author mud;	state Exp;
branches;
next	1.244;

1.244
date	99.11.02.08.00.14;	author mud;	state Exp;
branches;
next	1.243;

1.243
date	99.11.02.07.51.19;	author mud;	state Exp;
branches;
next	1.242;

1.242
date	99.10.31.02.23.25;	author mud;	state Exp;
branches;
next	1.241;

1.241
date	99.10.30.01.11.14;	author mud;	state Exp;
branches;
next	1.240;

1.240
date	99.10.26.16.11.08;	author mud;	state Exp;
branches;
next	1.239;

1.239
date	99.10.25.03.59.57;	author mud;	state Exp;
branches;
next	1.238;

1.238
date	99.10.18.23.13.48;	author mud;	state Exp;
branches;
next	1.237;

1.237
date	99.10.17.23.22.50;	author mud;	state Exp;
branches;
next	1.236;

1.236
date	99.10.17.22.56.43;	author mud;	state Exp;
branches;
next	1.235;

1.235
date	99.10.15.23.49.05;	author mud;	state Exp;
branches;
next	1.234;

1.234
date	99.10.15.23.47.05;	author mud;	state Exp;
branches;
next	1.233;

1.233
date	99.10.15.23.32.51;	author mud;	state Exp;
branches;
next	1.232;

1.232
date	99.10.15.01.17.29;	author mud;	state Exp;
branches;
next	1.231;

1.231
date	99.10.15.00.31.00;	author mud;	state Exp;
branches;
next	1.230;

1.230
date	99.10.14.00.02.02;	author mud;	state Exp;
branches;
next	1.229;

1.229
date	99.10.13.23.38.40;	author mud;	state Exp;
branches;
next	1.228;

1.228
date	99.10.09.17.22.19;	author mud;	state Exp;
branches;
next	1.227;

1.227
date	99.10.09.17.16.43;	author mud;	state Exp;
branches;
next	1.226;

1.226
date	99.10.08.20.16.06;	author mud;	state Exp;
branches;
next	1.225;

1.225
date	99.10.07.01.44.34;	author mud;	state Exp;
branches;
next	1.224;

1.224
date	99.10.07.01.41.43;	author mud;	state Exp;
branches;
next	1.223;

1.223
date	99.10.07.01.15.30;	author mud;	state Exp;
branches;
next	1.222;

1.222
date	99.09.30.00.35.52;	author mud;	state Exp;
branches;
next	1.221;

1.221
date	99.09.28.23.20.34;	author mud;	state Exp;
branches;
next	1.220;

1.220
date	99.09.26.19.03.20;	author mud;	state Exp;
branches;
next	1.219;

1.219
date	99.09.25.04.14.19;	author mud;	state Exp;
branches;
next	1.218;

1.218
date	99.09.18.21.46.42;	author mud;	state Exp;
branches;
next	1.217;

1.217
date	99.09.18.08.44.12;	author mud;	state Exp;
branches;
next	1.216;

1.216
date	99.09.18.08.07.05;	author mud;	state Exp;
branches;
next	1.215;

1.215
date	99.09.16.04.00.31;	author mud;	state Exp;
branches;
next	1.214;

1.214
date	99.09.14.05.16.50;	author mud;	state Exp;
branches;
next	1.213;

1.213
date	99.09.14.04.39.41;	author mud;	state Exp;
branches;
next	1.212;

1.212
date	99.09.08.20.00.01;	author mud;	state Exp;
branches;
next	1.211;

1.211
date	99.09.02.03.43.12;	author mud;	state Exp;
branches;
next	1.210;

1.210
date	99.08.27.01.26.48;	author mud;	state Exp;
branches;
next	1.209;

1.209
date	99.08.26.22.42.41;	author mud;	state Exp;
branches;
next	1.208;

1.208
date	99.08.26.16.37.54;	author mud;	state Exp;
branches;
next	1.207;

1.207
date	99.08.25.20.56.39;	author mud;	state Exp;
branches;
next	1.206;

1.206
date	99.08.25.20.17.45;	author mud;	state Exp;
branches;
next	1.205;

1.205
date	99.08.25.20.16.13;	author mud;	state Exp;
branches;
next	1.204;

1.204
date	99.08.25.19.30.24;	author mud;	state Exp;
branches;
next	1.203;

1.203
date	99.08.25.18.44.21;	author mud;	state Exp;
branches;
next	1.202;

1.202
date	99.08.25.03.05.40;	author mud;	state Exp;
branches;
next	1.201;

1.201
date	99.08.24.05.47.49;	author mud;	state Exp;
branches;
next	1.200;

1.200
date	99.08.23.22.48.19;	author mud;	state Exp;
branches;
next	1.199;

1.199
date	99.08.23.03.41.14;	author mud;	state Exp;
branches;
next	1.198;

1.198
date	99.08.23.03.34.44;	author mud;	state Exp;
branches;
next	1.197;

1.197
date	99.08.23.02.06.35;	author mud;	state Exp;
branches;
next	1.196;

1.196
date	99.08.22.17.24.28;	author mud;	state Exp;
branches;
next	1.195;

1.195
date	99.08.19.16.23.05;	author mud;	state Exp;
branches;
next	1.194;

1.194
date	99.08.19.05.31.42;	author mud;	state Exp;
branches;
next	1.193;

1.193
date	99.08.19.04.56.49;	author mud;	state Exp;
branches;
next	1.192;

1.192
date	99.08.13.21.35.52;	author mud;	state Exp;
branches;
next	1.191;

1.191
date	99.08.13.18.48.33;	author mud;	state Exp;
branches;
next	1.190;

1.190
date	99.08.12.17.41.20;	author mud;	state Exp;
branches;
next	1.189;

1.189
date	99.08.12.01.03.57;	author mud;	state Exp;
branches;
next	1.188;

1.188
date	99.08.11.20.39.23;	author mud;	state Exp;
branches;
next	1.187;

1.187
date	99.08.11.05.19.50;	author mud;	state Exp;
branches;
next	1.186;

1.186
date	99.08.11.04.55.49;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	99.08.09.22.08.27;	author mud;	state Exp;
branches;
next	1.184;

1.184
date	99.08.02.18.05.17;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	99.08.01.05.00.06;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	99.07.30.05.42.14;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	99.07.25.00.13.24;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	99.07.23.22.15.20;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	99.07.23.22.08.59;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	99.07.23.20.01.11;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	99.07.23.05.06.02;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	99.07.23.05.02.29;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	99.07.23.04.42.40;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	99.07.23.04.40.40;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	99.07.23.04.38.15;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	99.07.23.04.19.32;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	99.07.23.03.35.28;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	99.07.23.03.31.34;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	99.07.21.17.34.51;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	99.07.21.01.13.26;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	99.07.20.13.57.52;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	99.07.20.13.43.42;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	99.07.20.13.33.29;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	99.07.19.20.31.01;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	99.07.15.20.20.05;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	99.07.14.18.13.38;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	99.07.11.21.34.36;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	99.07.11.19.09.21;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	99.07.10.13.45.53;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	99.07.10.07.38.27;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	99.07.10.07.29.28;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	99.07.10.07.10.17;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	99.07.10.07.02.47;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	99.07.07.13.18.13;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	99.07.04.21.45.13;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	99.07.03.00.33.57;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	99.07.03.00.01.28;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	99.07.02.23.57.55;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	99.07.02.23.53.59;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	99.07.02.03.20.46;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	99.07.02.03.12.53;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	99.06.28.06.34.17;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	99.06.24.22.29.09;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	99.06.20.22.43.44;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	99.06.20.20.29.23;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	99.06.13.00.52.40;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	99.06.12.18.51.42;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	99.06.11.23.21.54;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	99.05.29.15.38.24;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	99.05.28.11.41.54;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	99.05.27.12.21.08;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	99.05.26.14.14.11;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	99.05.26.14.02.33;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	99.05.26.04.11.46;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	99.05.26.03.27.31;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	99.05.22.21.57.36;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	99.05.22.21.44.15;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	99.05.15.16.39.02;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	99.05.08.14.41.41;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	99.05.05.11.27.38;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	99.05.05.11.12.50;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	99.05.04.10.43.22;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	99.04.28.05.47.26;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	99.04.27.23.45.03;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	99.04.27.06.56.48;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	99.04.27.06.53.46;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	99.04.27.06.23.40;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	99.04.23.23.43.40;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	99.04.22.13.15.26;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	99.04.18.06.43.42;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	99.04.18.06.41.37;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	99.04.18.06.24.53;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	99.04.17.06.09.33;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	99.04.16.16.59.16;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	99.04.16.16.17.06;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	99.04.15.18.02.22;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	99.04.14.21.17.08;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	99.04.14.07.10.05;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	99.04.14.06.53.04;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	99.04.14.06.28.22;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	99.04.14.05.40.30;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	99.04.13.06.14.22;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	99.04.12.21.31.20;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	99.04.06.16.47.33;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	99.04.05.02.49.33;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	99.04.05.02.48.39;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	99.04.02.13.10.59;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	99.03.30.15.23.45;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	99.03.29.18.33.28;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	99.03.26.19.57.39;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	99.03.26.04.48.42;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	99.03.26.04.11.11;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	99.03.25.14.37.24;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	99.03.25.14.30.38;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	99.03.15.17.36.15;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.03.13.16.40.26;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.03.04.20.28.55;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.03.04.20.18.28;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.03.04.20.12.51;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.01.18.18.05.21;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.01.18.17.38.46;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.01.18.17.00.13;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.01.18.16.56.47;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.01.11.18.59.23;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	98.12.29.23.54.26;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	98.12.26.07.26.09;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	98.12.23.16.51.33;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	98.12.15.22.17.22;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	98.12.15.02.45.13;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	98.12.12.01.20.54;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	98.12.09.00.42.59;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	98.12.09.00.33.20;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	98.12.08.22.38.12;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	98.12.08.07.53.51;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	98.12.08.01.54.12;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	98.12.06.07.40.42;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	98.12.05.21.44.05;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	98.12.05.10.10.50;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	98.11.29.22.26.21;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	98.11.28.07.49.33;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	98.11.24.09.50.59;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	98.11.24.09.39.44;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	98.11.24.06.21.13;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	98.11.22.10.36.36;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	98.11.22.08.04.43;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	98.11.22.02.05.14;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	98.11.21.07.14.35;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	98.11.21.02.51.11;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	98.11.20.16.45.19;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	98.11.19.22.31.20;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	98.11.17.23.20.11;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	98.11.15.09.29.34;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	98.11.14.07.15.51;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	98.10.30.15.13.37;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	98.10.25.18.52.51;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	98.10.25.18.38.46;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	98.10.25.03.27.56;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	98.10.24.22.03.02;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	98.10.20.17.25.46;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	98.10.20.02.05.15;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	98.10.20.01.23.04;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	98.10.20.00.42.31;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	98.10.17.08.03.14;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	98.10.13.00.02.59;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	98.10.11.21.12.26;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	98.10.11.00.13.33;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	98.10.10.03.53.35;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	98.10.09.19.54.04;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	98.10.08.22.19.56;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	98.10.05.05.05.57;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	98.10.05.04.13.34;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	98.10.04.02.41.00;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	98.10.02.23.39.33;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	98.10.01.06.15.01;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	98.10.01.06.04.33;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	98.10.01.05.32.07;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	98.09.30.05.27.06;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.09.30.05.12.45;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.09.25.00.37.29;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.09.21.04.16.48;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.09.21.04.14.16;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.09.20.07.46.17;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.09.20.03.46.47;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.09.20.03.06.54;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.08.30.03.33.35;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.08.21.14.21.09;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.08.20.21.05.31;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.08.17.20.05.00;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.08.13.21.42.35;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.08.13.21.33.17;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.08.13.16.22.24;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.08.13.05.27.59;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.08.13.05.24.09;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.08.12.08.20.17;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.08.10.21.32.52;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.08.10.19.41.22;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.08.10.05.32.15;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.08.07.20.19.57;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.08.06.04.24.52;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.05.06.31.15;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.04.20.21.52;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.04.19.24.14;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.02.14.30.34;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.01.13.54.01;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.01.13.52.39;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.01.13.46.06;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.22;	author mud;	state Exp;
branches;
next	;


desc
@@


1.945
log
@t making it so clan guards won't attack clan guards
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  airound, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: fight.c,v 1.944 2004/10/25 02:48:45 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "merc.h"
#include "tables.h"
#include "interp.h"
#include "gladiator.h"

#define MAX_DAMAGE_MESSAGE 41

extern char * const dir_name[];
bool override;

/* command procedures needed */
DECLARE_DO_FUN(do_tail_slap );
DECLARE_DO_FUN(do_backstab  );
DECLARE_DO_FUN(do_emote   );
DECLARE_DO_FUN(do_berserk );
DECLARE_DO_FUN(do_bash    );
DECLARE_DO_FUN(do_bite    );
DECLARE_DO_FUN(do_breathe    );
DECLARE_DO_FUN(do_trip    );
DECLARE_DO_FUN(do_dirt    );
DECLARE_DO_FUN(do_fear    );
DECLARE_DO_FUN(do_flee    );
DECLARE_DO_FUN(do_hex    );
DECLARE_DO_FUN(do_kick    );
DECLARE_DO_FUN(do_disarm  );
DECLARE_DO_FUN(do_get   );
DECLARE_DO_FUN(do_recall  );
DECLARE_DO_FUN(do_yell    );
DECLARE_DO_FUN(do_sacrifice );
DECLARE_DO_FUN(do_kcharge );
DECLARE_DO_FUN(do_grab    );

int clan_lookup   args( ( const char *name ) );
/*
 * Local functions.
 */
void  kill	args( ( CHAR_DATA *ch, char *argument, bool canChange ) );
int   check_myrmidon	args( ( CHAR_DATA *ch, int sn ) );
void  flee		args( ( CHAR_DATA *ch, char *argument, bool fWimpy ) );
void  handle_critical( CHAR_DATA *ch, int *damage, int dam_type, int diceroll, int base_dam );
bool  is_safe_steal	args( ( CHAR_DATA *ch, CHAR_DATA *victim) );
bool  is_clan_guard     args( ( CHAR_DATA *victim) );
void  do_cutpurse	args( ( CHAR_DATA *ch, CHAR_DATA *victim) );
void  check_assist  args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
bool  check_scales args( ( CHAR_DATA *ch, CHAR_DATA *victim,bool fSecondary ) );
bool  check_dodge args( ( CHAR_DATA *ch, CHAR_DATA *victim, bool fSecondary ) );
bool  check_mistform args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
bool  check_kailindo args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
void  check_killer  args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
bool  check_parry args( ( CHAR_DATA *ch, CHAR_DATA *victim, bool fSecondary ) );
bool  check_shield_block args( ( CHAR_DATA *ch, CHAR_DATA *victim, bool fSecondary ) );
bool  check_nether args( ( CHAR_DATA *ch, CHAR_DATA *victim, bool fSecondary ) );
void  dam_message args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dam,
          int dt, bool immune ) );
void    dam_message_new args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dam,
                            int dt, bool immune ) );
void  death_cry args( ( CHAR_DATA *ch ) );
void  group_gain  args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
int xp_compute  args( ( CHAR_DATA *gch, CHAR_DATA *victim, 
          int total_levels ) );
bool  is_safe   args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
void  make_corpse args( ( CHAR_DATA *ch ) );
void  one_hit   args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
void    mob_hit   args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
void  raw_kill  args( ( CHAR_DATA *victim, CHAR_DATA *ch ) );
void  set_fighting  args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
void  disarm    args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );

/* Externals */
void  remove_highlander    args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );

/*
 * Utility function for rangers
 */
int is_enemy( CHAR_DATA *ch, CHAR_DATA *victim )
{
    if ( !HAS_KIT(ch,"ranger") )
	return FALSE;

    if ( victim->race != ch->species_enemy )
	return FALSE;
    else
    	return TRUE;
}

int terrain( CHAR_DATA *ch )
{
    if ( !HAS_KIT(ch,"ranger") )
       return -2;
    
    switch( ch->in_room->sector_type )
    {
    case SECT_INSIDE:
    case SECT_CITY:
	return 0;
    case SECT_FOREST:
    case SECT_HILLS:
    case SECT_MOUNTAIN:
    case SECT_FIELD:
	return 1;
    default: 
	return -1;
    }
}

/*
 * Control the fights going on.
 * Called periodically by update_handler.
 */
void violence_update( void )
{
    CHAR_DATA *ch;
    CHAR_DATA *ch_next;
    CHAR_DATA *victim;

    for ( ch = char_list; ch != NULL; ch = ch->next )
    {
  ch_next = ch->next;

  if ( !IS_NPC(ch) && HAS_KIT(ch, "barbarian") )
  {
	AFFECT_DATA af;

	if ( ch->fighting == NULL )
		ch->pcdata->barbarian = UMAX(ch->pcdata->barbarian - 1, 0 );
	else
	if ( !is_affected( ch, gsn_barbarian_rage ) && 
		number_percent() < get_skill(ch,gsn_barbarian_rage) )
	{ /** BARBARIAN RAGE!!! */
	    if ( number_percent() < ++ch->pcdata->barbarian )
	    {
	    check_improve(ch,gsn_barbarian_rage,TRUE,5);
	    af.type 	= gsn_barbarian_rage;
	    af.level	= ch->level;
	    af.where	= TO_AFFECTS;
	    af.duration	= ch->pcdata->barbarian / 2 + 3;
	    af.location	= APPLY_STR;
	    af.modifier = 3;
	    af.bitvector = 0;
	    affect_to_char( ch, &af );
	    af.location = APPLY_DAMROLL;
	    af.modifier = UMAX( 3, ch->pcdata->barbarian );
	    affect_to_char( ch, &af );
	    af.location = APPLY_AC;
	    af.modifier = ch->pcdata->barbarian * 5;
	    affect_to_char( ch, &af );
	    act("$n screams with primal fury!!",ch,NULL,NULL,TO_ROOM,FALSE); 
	    act("You scream with primal fury!!", ch,NULL,NULL,TO_CHAR,FALSE);
	    }
	}
	else
		check_improve(ch,gsn_barbarian_rage,FALSE,9);
    }

  if ( ( victim = ch->fighting ) == NULL || ch->in_room == NULL )
      continue;

  if ( (IS_AWAKE(ch)) && (ch->in_room == victim->in_room) )
      multi_hit( ch, victim, TYPE_UNDEFINED );
  else
      stop_fighting( ch, FALSE );

  if ( ( victim = ch->fighting ) == NULL )
      continue;

  /*
   * Fun for the whole family!
   */
  check_assist(ch,victim);
    }

    return;
}

/* for auto assisting */
void check_assist(CHAR_DATA *ch,CHAR_DATA *victim)
{
    CHAR_DATA *rch, *rch_next;

    if( IS_NPC(ch) && ch->pIndexData->pShop != NULL )
	return;

    for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
    {
  rch_next = rch->next_in_room;

  if (IS_AWAKE(rch) && rch->fighting == NULL && can_see(rch,victim,FALSE) )
  {

      /* quick check for ASSIST_PLAYER */
      if (!IS_NPC(ch) && IS_NPC(rch) 
      && IS_SET(rch->off_flags,ASSIST_PLAYERS)
      &&  rch->level + 6 > victim->level)
      {
    do_emote(rch,"screams and attacks!");
    multi_hit(rch,victim,TYPE_UNDEFINED);
    continue;
      }

      /* PCs next */
      if (!IS_NPC(ch) || IS_AFFECTED(ch,AFF_CHARM))
      {
    if ( ( (!IS_NPC(rch) && IS_SET(rch->act,PLR_AUTOASSIST))
    ||     IS_AFFECTED(rch,AFF_CHARM)) 
    &&   is_same_group(ch,rch) 
    &&   !is_safe(rch, victim) )
        multi_hit (rch,victim,TYPE_UNDEFINED);
    
    continue;
      }
    
      /* now check the NPC cases */
      
      if (IS_NPC(ch) && !IS_AFFECTED(ch,AFF_CHARM))
  
      {
    if ( (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALL))

    ||   (IS_NPC(rch) && rch->group && rch->group == ch->group)

    ||   (IS_NPC(rch) && rch->race == ch->race 
       && IS_SET(rch->off_flags,ASSIST_RACE))

    ||   (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALIGN)
       &&   ((IS_GOOD(rch)    && IS_GOOD(ch))
         ||  (IS_EVIL(rch)    && IS_EVIL(ch))
         ||  (IS_NEUTRAL(rch) && IS_NEUTRAL(ch)))) 

    ||   (rch->pIndexData == ch->pIndexData 
       && IS_SET(rch->off_flags,ASSIST_VNUM)))

      {
        CHAR_DATA *vch;
        CHAR_DATA *target;
        int number;

        if (number_bits(1) == 0)
      continue;
    
        target = NULL;
        number = 0;
        for (vch = ch->in_room->people; vch; vch = vch->next)
        {
      if (can_see(rch,vch,FALSE)
      &&  is_same_group(vch,victim)
      &&  number_range(0,number) == 0)
      {
          target = vch;
          number++;
      }
        }

        if (target != NULL)
        {
      do_emote(rch,"screams and attacks!");
      multi_hit(rch,target,TYPE_UNDEFINED);
        }
    } 
      }
  }
    }
}


/*
 * Do one group of attacks.
 */
void multi_hit( CHAR_DATA *ch, CHAR_DATA *victim, int dt )
{
    OBJ_DATA *wield;
    int     chance;
     int	wsn;
     int 	counter;
     int  number_of_crusaders =0;

/* commented out to stop the useless log spam
 *
   sprintf(log_buf,"%s attacking %s",ch->name,victim->name);
   log_string(log_buf);
 */

    /* decrement the wait */
    if (ch->desc == NULL)
  ch->wait = UMAX(0,ch->wait - PULSE_VIOLENCE);

    if (ch->desc == NULL)
  ch->daze = UMAX(0,ch->daze - PULSE_VIOLENCE); 

    /*no attacks for wraithform ppl */
    if (is_affected(ch, skill_lookup("wraithform")) )
    return;
/*no attacks for ppl just logged in*/
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
      return;

    /* no attacks for stunnies -- just a check */
    if (ch->position <= POS_RESTING)
  return;

    if (IS_NPC(ch))
    {
  mob_hit(ch,victim,dt);
  return;
    }
    
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
	send_to_char("(Reg) ",ch);
    one_hit( ch, victim, dt );

    if (ch->fighting != victim)
  return;

    if (is_mounted(ch) && !is_mounted(victim))
    {
       if(number_percent() < UMIN(10, get_skill(ch,gsn_riding) / 5 )) 
       {
          check_improve(ch,gsn_riding,TRUE,10);
          if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
             send_to_char("(Mnt) ",ch);
          one_hit(ch,victim,dt);
       }
       else
          check_improve(ch,gsn_riding,FALSE,10);
    }

    if (ch->fighting != victim)
  return;

    if ( ( wield = get_eq_char( ch, WEAR_WIELD ) ) != NULL &&
	 IS_WEAPON_STAT( wield, WEAPON_FAVORED ) &&
	 number_percent() < ( ch->pcdata->sac / 8 ) 
	 && (dt != gsn_backstab  ||  dt != gsn_kcharge) )
    {
	if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
		send_to_char("(Fav) ",ch);

	one_hit(ch,victim,dt);
    }

    if ( ch->fighting != victim )
    return;

    if (IS_AFFECTED(ch,AFF_HASTE) )
    {
	if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
		send_to_char("(Hst) ",ch);
	one_hit(ch,victim,dt);
    }

    if ( ch->fighting != victim )
  return;

    {
	AFFECT_DATA *paf;

    /* ONE nice backstab or kcharge, or extra regular attack */
    if ( (paf = affect_find(ch->affected,gsn_spirit_of_wolf) ) != NULL )
    {
        paf->duration--;

        if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
                send_to_char("(Wlf) ",ch);
        one_hit(ch,victim,dt);

	if ( dt == gsn_backstab || dt == gsn_kcharge )
	    paf->duration = 0;

        if ( --paf->duration <  0 )
        {
            affect_remove(ch,paf,APPLY_BOTH);
	    act("The spirit of wolf leaves you.",ch,NULL,NULL,TO_CHAR,FALSE);
        }
    }
    } /* end local declaration for 'paf' */

    if ( ch->fighting != victim || dt == gsn_backstab || dt == gsn_kcharge)
  return;
	
    number_of_crusaders = group_has_how_many_crusader( ch ) ;
    if (    number_of_crusaders 
	 && ( number_percent() < ( ch->pcdata->sac / 6) )
       )	 
    {
	    for ( counter = 1; counter <= number_of_crusaders; counter++)
	    {
		if   ( number_percent() < (100/counter) ) 
	        {
			if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
				send_to_char("(Cru) ",ch);
			one_hit(ch,victim,dt);
	        }
	    }
    }

  /*  if ( group_has_crusader( ch ) &&
     number_percent() < ( ch->pcdata->sac / 6 ) )
    {
	if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
		send_to_char("(Cru) ",ch);
	one_hit(ch,victim,dt);
    }
*/
/*Here comes the cavalier attack it goes off all the time but less than the crusader attack */
/* Added 19SEP01 Boogums*/

    if (!IS_NPC(ch) && group_has_cavalier( ch ) &&
     number_percent() < ( ch->pcdata->sac / 9 ) )
    {
        if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
                send_to_char("(Ral) ",ch);
        one_hit(ch,victim,dt);
    }

    chance = get_skill(ch,gsn_second_attack)/2;

    if (get_skill(ch,gsn_second_attack) > 1)
    {
       if ( is_affected(ch,gsn_dae_tok) )
       {
          check_improve(ch,gsn_dae_tok,TRUE,5);
          chance += UMAX(0,get_skill(ch,gsn_dae_tok)-90);
       }

	if ( is_affected(ch,gsn_spirit_of_cat) )
	    chance += ch->level/5;

       chance += check_myrmidon( ch, gsn_second_attack );

       if (IS_AFFECTED(ch,AFF_SLOW))
          chance /= 2;

       if ( number_percent( ) < chance )
       {
          if (!IS_SET(ch->display,DISP_BRIEF_COMBAT))
	     send_to_char("(2nd) ",ch);
          one_hit( ch, victim, dt );
          check_improve(ch,gsn_second_attack,TRUE,5);
          if ( ch->fighting != victim )
             return;
       }
    }

    if ( IS_AFFECTED(ch,AFF_SLOW) )
	return;

    chance = get_skill(ch,gsn_third_attack)/4;

    if (get_skill(ch,gsn_third_attack) > 1)
    {
       chance += check_myrmidon( ch, gsn_third_attack );

       if (!IS_NPC(ch) && 
	  ( ch->pcdata->old_class != class_lookup("warrior") && 
	    ch->pcdata->old_class!=class_lookup("thief")))
		chance -= ( chance / 4 );

       if ( is_affected(ch,gsn_dae_tok) )
       { 
          check_improve(ch,gsn_dae_tok,TRUE,8);
	  chance += UMAX(0,get_skill(ch,gsn_dae_tok)-90);
       }

        if ( is_affected(ch,gsn_spirit_of_cat) )
            chance += ch->level/5;

    }

    if ( number_percent( ) < chance )
    {
  if (!IS_SET(ch->display,DISP_BRIEF_COMBAT))
      send_to_char("(3rd) ",ch);
  one_hit( ch, victim, dt );
  check_improve(ch,gsn_third_attack,TRUE,6);
  if ( ch->fighting != victim )
      return;
    }


    if ( number_percent() < get_skill(ch, gsn_fourth_attack) / 4 )
    {
   if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
	send_to_char("(4th) ",ch);
	one_hit( ch, victim, dt );
	check_improve(ch,gsn_fourth_attack,TRUE,8);
	if ( ch->fighting != victim )
		return;
     }

     if (get_eq_char( ch, WEAR_SECOND ) != NULL)
     {
	int chance = get_skill(ch,gsn_dual_wield);

	if ( ch->class == class_lookup("blademaster") )
		chance = 3 * chance / 5;
	else
		chance /= 4;

        if ( is_affected(ch,gsn_spirit_of_cat) )
            chance += ch->level/5;

        if ( number_percent() <  chance )
        {

           if (!IS_SET(ch->display,DISP_BRIEF_COMBAT))
   	      send_to_char("(Dua) ",ch);
           one_hit( ch, victim, TYPE_SECONDARY );
           check_improve(ch,gsn_dual_wield,TRUE,9);
           if ( ch->fighting != victim )
             return;

           /* Favored on the secondary? 
           if ( ( wield = get_eq_char( ch, WEAR_SECOND ) ) != NULL &&
	          IS_WEAPON_STAT( wield, WEAPON_FAVORED ) &&
	          number_percent() < ( ch->pcdata->sac / 8 ) 
	          && dt != gsn_backstab )
          {
             if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
                send_to_char("(Fav) ",ch);
	     one_hit(ch,victim,dt);
          }
	  */
	}
     }
     
     /* special attack for rogues */
    if (ch->class == class_lookup("rogue")
    && get_skill(ch,gsn_cutpurse) > 1)
    do_cutpurse(ch,victim); 


    /* specialization */
    if ( IS_NPC(ch) )
	return;

    if ( ( wsn = get_weapon_sn(ch,FALSE) )  == ch->pcdata->specialize )
	if ( number_percent() < get_weapon_skill(ch,wsn) / 10 )
    {
	if (!IS_SET(ch->display,DISP_BRIEF_COMBAT))
		send_to_char("(Spe) ",ch);
		one_hit( ch, victim, dt );
	if ( ch->fighting != victim )
		return;

    }

    if ( is_affected(ch,gsn_bladesong) &&
	 (((get_skill(ch,gsn_bladesong) - 95) * 5) > number_percent()) )
     {
	if (!IS_SET(ch->display,DISP_BRIEF_COMBAT))
		send_to_char("(Bla) ",ch);
	one_hit( ch, victim, dt );
	if ( ch->fighting != victim )
		return;
     }

    if ( is_affected(ch,gsn_rage) &&
	   (((get_skill(ch,gsn_rage) - 95 ) * 5) > number_percent()) )
    {
	if (!IS_SET(ch->display,DISP_BRIEF_COMBAT))
		send_to_char("(Bat) ",ch);
	one_hit( ch, victim, dt );
	if (ch->fighting != victim )
		return;
    }

    return;
}

/* procedure for all mobile attacks */
void mob_hit (CHAR_DATA *ch, CHAR_DATA *victim, int dt)
{
    int chance,number;
    CHAR_DATA *vch, *vch_next;

    one_hit(ch,victim,dt);

    if (ch->fighting != victim)
  return;

    /* Area attack -- BALLS nasty! */
 
    if (IS_SET(ch->off_flags,OFF_AREA_ATTACK))
    {
  for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
  {
      vch_next = vch->next;
      if ((vch != victim && vch->fighting == ch))
    one_hit(ch,vch,dt);
  }
    }

    if (IS_AFFECTED(ch,AFF_HASTE) 
    ||  (IS_SET(ch->off_flags,OFF_FAST) && !IS_AFFECTED(ch,AFF_SLOW)))
  one_hit(ch,victim,dt);

    if (ch->fighting != victim || dt == gsn_backstab || dt == gsn_kcharge)
  return;

    chance = get_skill(ch,gsn_second_attack)/2;

    if (IS_AFFECTED(ch,AFF_SLOW) && !IS_SET(ch->off_flags,OFF_FAST))
  chance /= 2;

    if (number_percent() < chance)
    {
  one_hit(ch,victim,dt);
  if (ch->fighting != victim)
      return;
    }

    chance = get_skill(ch,gsn_third_attack)/4;

    if (IS_AFFECTED(ch,AFF_SLOW) && !IS_SET(ch->off_flags,OFF_FAST))
  chance = 0;

    if (number_percent() < chance)
    {
  one_hit(ch,victim,dt);
  if (ch->fighting != victim)
      return;
    } 

    /* oh boy!  Fun stuff! */

    if (ch->wait > 0)
  return;

    number = number_range(0,2);

    if (number == 1 && IS_SET(ch->act,ACT_MAGE))
    {
  /*  { mob_cast_mage(ch,victim); return; } */ ;
    }

    if (number == 2 && IS_SET(ch->act,ACT_CLERIC))
    { 
  /* { mob_cast_cleric(ch,victim); return; } */ ;
    }

    /* now for the skills */

    number = number_range(0,8);

    switch(number) 
    {
    case (0) :
  if (IS_SET(ch->off_flags,OFF_BASH))
      do_bash(ch,"");
  break;

    case (1) :
  if (IS_SET(ch->off_flags,OFF_BERSERK) && !IS_AFFECTED(ch,AFF_BERSERK))
      do_berserk(ch,"");
  break;


    case (2) :
  if (IS_SET(ch->off_flags,OFF_DISARM) 
  || (get_weapon_sn(ch,FALSE) != gsn_hand_to_hand 
  && (IS_SET(ch->act,ACT_WARRIOR)
    ||  IS_SET(ch->act,ACT_THIEF))))
      do_disarm(ch,"");
  break;

    case (3) :
  if (IS_SET(ch->off_flags,OFF_KICK))
      do_kick(ch,"");
  break;

    case (4) :
  if (IS_SET(ch->off_flags,OFF_KICK_DIRT))
      do_dirt(ch,"");
  break;

    case (5) :
  if (IS_SET(ch->off_flags,OFF_TAIL))
  {
         do_tail_slap(ch,"");
  }
  break; 

    case (6) :
  if (IS_SET(ch->off_flags,OFF_TRIP))
      do_trip(ch,"");
  break;

    case (7) :
  if (IS_SET(ch->off_flags,OFF_CRUSH))
  {
      /* do_crush(ch,"") */ ;
  }
  break;
    case (8) :
  if (IS_SET(ch->off_flags,OFF_BACKSTAB))
  {
      do_backstab(ch,"");
  }
    }
}
  

/*
 * Hit one guy once.
 */
void one_hit( CHAR_DATA *ch, CHAR_DATA *victim, int dt )
{
    OBJ_DATA *wield;
    int victim_ac;
    int thac0;
    int thac0_00;
    int thac0_32;
    int dam, base_dam = 0;
    int diceroll;
    int diceroll_save;
    int sn,skill;
    int dam_type;
    bool result;
    bool fSecondary = FALSE;

    sn = -1;


    /* just in case */
    if (victim == ch || ch == NULL || victim == NULL)
  return;

    /*
     * Can't beat a dead char!
     * Guard against weird room-leavings.
     */
    if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
  return;

    /*
     * Figure out the type of damage message.
     */
    wield = get_eq_char( ch, WEAR_WIELD );
  
    /* Use the off weapon for dual wield.  This requires that they have
       a weapon in each hand.  Minor bug: can still improve at dual wield
       regardless of whether or not you're wearing a weapon */
    if ( dt == TYPE_SECONDARY )
    {
       if ( wield == NULL )
	   return;

       if ( ( wield = get_eq_char( ch, WEAR_SECOND ) ) == NULL )
	   return;

       fSecondary = TRUE;
    }
    
    if ( dt == TYPE_UNDEFINED || dt == TYPE_SECONDARY )
    {
  dt = TYPE_HIT;
  if ( wield != NULL && wield->item_type == ITEM_WEAPON )
      dt += wield->value[3];
  else {
	if( IS_AFFECTED(ch,AFF_MORPH) )
	dt += 5;
        else if( IS_AFFECTED(ch,AFF_WEAPONRY))
	dt += 13;
        else dt += ch->dam_type;
	}
    }

    if (dt < TYPE_HIT)
      if (wield != NULL)
          dam_type = attack_table[wield->value[3]].damage;
      else {
	  if( IS_AFFECTED(ch,AFF_MORPH) )
	  dam_type = DAM_SLASH;
          else if(IS_AFFECTED(ch,AFF_WEAPONRY))
	  dam_type = DAM_MENTAL;
	  else dam_type = attack_table[ch->dam_type].damage;
	   }
    else
      dam_type = attack_table[dt - TYPE_HIT].damage;

    if (dam_type == -1)
  dam_type = DAM_BASH;

    /* get the weapon skill */
    sn = get_weapon_sn(ch,fSecondary);
    skill = 20 + get_weapon_skill(ch,sn);

	/* Races that suck with regular weapons */
    if ( ch->race == race_lookup("faerie") )
	skill -= ( skill / 4 );
			    
	/* Adjustment for druids -- removed 
    if ( ch->class == class_lookup("druid") )
	skill -= ( skill / 20 );
	**/


  /*Adjustment for Elementalist, they aren't supposed to fight good*/
  if ( ch->class == class_lookup("elementalist"))
  {  
    skill -= ( skill / number_range(15,25) );
  }

        /* Adjust for Posse Clan Skill -Boogums*/
	if ( ch->clan == clan_lookup("posse") && IS_SET(victim->act, PLR_KILLER) )
	{
	  skill += (skill * .14);
	}
	if ( ch->clan == clan_lookup("posse") && IS_SET(victim->act, PLR_THUG) )
	{
	  skill += (skill * .08);
	}
	if ( ch->clan == clan_lookup("posse") && IS_SET(victim->act, PLR_RUFFIAN) )
        {
	  skill += (skill * .05);
	}
	if ( ch->clan == clan_lookup("posse") && IS_SET(victim->act, PLR_THIEF) )
	{
	  skill += (skill * .11);
        }


 	/* Ajdust for species enemy */
    if ( is_enemy( ch, victim ) ) 
	skill += number_range( ch->level / 4, ch->level / 2 );

	/* Adjust for terrain */
    switch( terrain(ch) )
    {
    case 0:
	skill -= ( skill / 10 ); break;
    case 1:
	skill += ( skill / 10 ); break;
    default:
	break;
    }

    /*
     * Calculate to-hit-armor-class-0 versus armor.
     */
    if ( IS_NPC(ch) )
    {
  thac0_00 = 20;
  thac0_32 = -4;   /* as good as a thief */ 
  if (IS_SET(ch->act,ACT_WARRIOR))
      thac0_32 = -10;
  else if (IS_SET(ch->act,ACT_THIEF))
      thac0_32 = -4;
  else if (IS_SET(ch->act,ACT_CLERIC))
      thac0_32 = 2;
  else if (IS_SET(ch->act,ACT_MAGE))
      thac0_32 = 6;
    }
    else
    {
  thac0_00 = class_table[ch->class].thac0_00;
  thac0_32 = class_table[ch->class].thac0_32;
    }
    thac0  = interpolate( ch->level, thac0_00, thac0_32 );

    if (thac0 < 0)
        thac0 = thac0/2;

    if (thac0 < -5)
        thac0 = -5 + (thac0 + 5) / 2;

    if (fSecondary)
       thac0 -= GET_SECOND_HITROLL(ch) * skill/100;
    else
       thac0 -= GET_HITROLL(ch) * skill/100;

    thac0 += 5 * (100 - skill) / 100;

    if (dt == gsn_backstab)
  thac0 -= 10 * (100 - get_skill(ch,gsn_backstab));
    
    /*Added by Boogums 06SEP00 */
    if (dt == gsn_kcharge)
      {
	thac0 -= 10 * (100 - get_skill(ch,gsn_kcharge));
      }

    switch(dam_type)
    {
  case(DAM_PIERCE):victim_ac = GET_AC(victim,AC_PIERCE)/10; break;
  case(DAM_BASH):  victim_ac = GET_AC(victim,AC_BASH)/10;   break;
  case(DAM_SLASH): victim_ac = GET_AC(victim,AC_SLASH)/10;  break;
  default:   victim_ac = GET_AC(victim,AC_EXOTIC)/10; break;
    }; 
 
    /* Set up AC curves */
    /* For CASTER, the curve begins at -100 and hits again at -200
     * For MELEE, the curve begins at -160 and hits again at -320
     * For HYBRID, the curve begins at -130 and hits again at -260
     */
	
#define	MELEE	0
#define HYBRID	1
#define CASTER	2

	switch ( class_table[victim->class].fMana )
	{
	case MELEE:
    	    if (victim_ac < -16)
  		victim_ac = (victim_ac + 16) / 5 - 16;
     	    if (victim_ac < -32 )
		victim_ac = (victim_ac +32) / 2 - 32;
	    break;
        case CASTER:
	    if (victim_ac < -10 )
		victim_ac = (victim_ac + 10) / 5 - 10;
	    if (victim_ac < -20 )
		victim_ac = (victim_ac + 20 ) /2 - 20;
	    break;
	case HYBRID:
	    if (victim_ac < -13 )
		victim_ac = (victim_ac + 13 ) /5 - 13;
	    if (victim_ac < -26 )
		victim_ac = (victim_ac + 26 ) /2 - 26;
	    break;
	}

#undef MELEE
#undef HYBRID
#undef CASTER

    if ( !can_see( ch, victim, FALSE ) )
  victim_ac -= 4;

    if ( victim->position < POS_FIGHTING)
  victim_ac += 4;
 
    if (victim->position < POS_RESTING)
  victim_ac += 6;

    if( IS_AFFECTED(victim,AFF_WEAPONRY))
  victim_ac -= 1;

  if (ch->class == 3) 
  victim_ac += 2;

  if ( is_enemy(ch,victim) )
      victim_ac += 4;

  if ( is_mounted(ch) && !is_mounted(victim) )
  {
	victim_ac += ( victim_ac / 10 );
	if ( number_percent() < get_skill(ch,gsn_riding) )
	victim_ac += ( victim_ac / 10 );
  }

  if ( is_mounted(victim) && !is_mounted(ch) )
  {
	victim_ac -= ( victim_ac / 10 );
	if ( number_percent() < get_skill(victim,gsn_riding) )
	victim_ac -= ( victim_ac / 10 );
  }

  /* Terrain */
  switch( terrain(ch) )
  {
  case 0:	victim_ac -= 3; break;
  case 1:	victim_ac += 3; break;
  default:	break;
  }
  /* check diety and clan for Almigty */
  if ( !IS_NPC(victim)  && !IS_NPC(ch) 
      && victim->clan == clan_lookup("zealot") 
      && ch->pcdata->deity == deity_lookup("almighty")
      && !IS_SET(ch->mhs, MHS_GLADIATOR)
      && !IS_SET(victim->mhs, MHS_GLADIATOR))
	 {
	    ch->pcdata->sac = 0;
	    if (!IS_SET(ch->mhs, MHS_BANISH))
	       SET_BIT(ch->mhs, MHS_BANISH);
         }

    /*
     * The moment of excitement!
     */
    while ( ( diceroll = number_bits( 5 ) ) >= 20 ) ;

    if ( !IS_NPC(ch) && IS_SET(ch->act,PLR_WERE)  && 
	 is_affected(ch,gsn_morph) && ( ch->hit < ch->max_hit / 4 ) )
	 diceroll = 19;

    if ( diceroll == 0
    || ( diceroll != 19 && diceroll < thac0 - victim_ac ) )
    {
  /* Miss. */
  damage( ch, victim, 0, dt, dam_type, TRUE, FALSE );
  if ( is_affected(ch,gsn_fumble) && wield != NULL  && 
	!IS_OBJ_STAT(wield,ITEM_NOREMOVE) )
      if ( number_percent() > (get_curr_stat(ch,STAT_DEX)*5) )
      {
	 act("You fumble and drop your weapon!",ch,NULL,NULL,TO_CHAR,FALSE);
	 act("$N fumbles and drops $s weapon!",ch,NULL,ch,TO_ROOM,FALSE);
  	 obj_from_char( wield );
	 if ( IS_OBJ_STAT(wield,ITEM_NODROP) )
		obj_to_char( wield, ch );
	 else
		obj_to_room( wield, ch->in_room );
      } 
  tail_chain( );
  return;
    }

    diceroll_save = diceroll;

    /*
     * Hit.
     * Calc damage.
     */
    if ( IS_NPC(ch) && (!ch->pIndexData->new_format || wield == NULL))
  if (!ch->pIndexData->new_format)
  {
      dam = number_range( ch->level / 2, ch->level * 3 / 2 );
      if ( wield != NULL )
        dam += dam / 2;
  }
  else
      dam = dice(ch->damage[DICE_NUMBER],ch->damage[DICE_TYPE]);
  
    else
    {
  if (sn != -1)
      check_improve(ch,sn,TRUE,5);
  if ( wield != NULL )
  {
      if (wield->pIndexData->new_format)
	{
	dam = dice(wield->value[1],wield->value[2]);
	if( dam == (wield->value[1]*wield->value[2])
	  && IS_WEAPON_STAT(wield,WEAPON_VORPAL)  && !IS_NPC(ch) )
	  {
	  if(number_percent() < get_skill(ch,gsn_vorpal) - 4 )
		{
		damage( ch, victim, victim->hit/2, dt, dam_type, TRUE ,FALSE);
		check_improve(ch,gsn_vorpal,TRUE,1);
		}
	  else
		{
		if(!IS_NPC(ch))
		  { damage( ch, ch, ch->hit/2, dt, dam_type, TRUE ,FALSE); }
		check_improve(ch,gsn_vorpal,FALSE,2);
		}
	  }
	dam = (dam * skill)/100;
	}
      else
        dam = number_range( wield->value[1] * skill/100, 
        wield->value[2] * skill/100);

      
      /* use base damage for all adjustments */
      /* if you change anything from this point on, */
      /* be sure to use (dam += base_dam * modifier ) */
      
      base_dam = dam; 
      
      
      if (get_eq_char(ch,WEAR_SHIELD) == NULL)  /* no shield = more */
    dam += base_dam / 10;

      
      /* sharpness! */
      if (IS_WEAPON_STAT(wield,WEAPON_SHARP))
      {
    int percent;

    if ((percent = number_percent()) <= (skill / 8))
        dam += 2 * base_dam + (base_dam * 2 * percent / 100);
      }
  }
  else{
      dam = number_range( 1 + 4 * skill/100, 2 * ch->level/3 * skill/100);
      base_dam = dam;

      if( get_skill(ch,gsn_morph) > number_percent()
	  && IS_AFFECTED(ch,AFF_MORPH)) 
	dam += (base_dam * get_skill(ch,gsn_morph)) / 130;
      if( IS_AFFECTED(ch,AFF_WEAPONRY) )
	dam += base_dam/10;
      }
    }

    /* Rangers! */
    if ( is_enemy( ch, victim ) )
	dam += ( base_dam / 5 ); /* 20% hbonus */

    /*
     * Bonuses.
     */
    if ( get_skill(ch,gsn_enhanced_damage) > 0 )
    {
        diceroll = number_percent();
        if (diceroll <= get_skill(ch,gsn_enhanced_damage))
        {
            check_improve(ch,gsn_enhanced_damage,TRUE,6);
            dam += 2 * ( base_dam * diceroll/ 300);
        }
    }

    /* 
     * Kurijitsu 
     */
   if ( number_percent() < (get_skill(ch,gsn_kurijitsu)/6) )
   {
	   check_improve(ch,gsn_kurijitsu,TRUE,6);
	   diceroll = number_percent();
  	   do
  		dam += 2 * ( base_dam * diceroll/300);
	   while ( --diceroll > 95 );
   }

    if ( !IS_AWAKE(victim) )
        dam += base_dam;
     else if (victim->position < POS_FIGHTING)
        dam += base_dam / 2;

    if ( victim->fighting != ch )
       dam += base_dam / 2;

    if ( !IS_NPC(ch) && IS_SET(ch->act,PLR_WERE)  &&
	 is_affected(ch,gsn_morph) && (ch->hit < ch->max_hit/4) )
	dam += base_dam * 9/10; 

    if ( dt == gsn_backstab && wield != NULL) 
    {
      if ( wield->value[0] != 2 )
      dam += base_dam * (2 + (ch->level / 12)); 
  else 
      dam += base_dam * (2 + (ch->level / 10));

      if (ch->class == class_lookup("rogue"))
        dam += base_dam/10;

      if (ch->fighting != NULL)
	dam /= 2;

     }

     /* 6SEP00 - Adding Damage for kcharge - Boogums */
     if ( wield != NULL && !fSecondary
	&& dt == gsn_kcharge && wield->value[0] != WEAPON_POLEARM)
     {
       dam += base_dam * (2 + (ch->level / 10));
       if (ch->fighting != NULL){dam /= 2;}
     }

     if ( sn == gsn_hand_to_hand &&
	  ( ch->race == race_lookup("rockbiter") ||
	    is_affected(ch,gsn_stonefist) ) )
          dam += ch->level / 3;   

	/* so do ogres.  just not quite as much.  and giants */
    if ( sn == gsn_hand_to_hand && 
	( (ch->race == race_lookup("ogre") || ch->race == race_lookup("giant") ) ) )
	dam += ch->level / 4;	


    if(fSecondary)
       dam += GET_SECOND_DAMROLL(ch) * UMIN(100,skill) /100;
    else
       dam += GET_DAMROLL(ch) * UMIN(100,skill) /100;

    if ( dam <= 0 )
      dam = 1;


  /* Size Adjustment - Larger races do more damage  - removed
    	dam += (dam * (ch->size - 2)/10);
 */

    if ( ch->race == race_lookup("rockbiter"))
       dam += (base_dam * (ch->size -2)/10);

    /* CLass adjustment - 
       Adjust damage bsed on class and oldclass    

    if( !IS_NPC(ch))
      dam = dam * ( class_table[ch->class].dam_mod  
		  * class_table[ch->pcdata->old_class].dam_mod) /10000 ; */

    if (!IS_NPC(ch))
    {
    switch (ch->pcdata->old_class)
	{
	case CLASS_MAGE:
		dam = dam * 85 /100;
		break;
	case CLASS_THIEF:
		dam = dam * 105 / 100;
		break;
	case CLASS_WARRIOR:
		dam = dam * 110 / 100; 
		break;
	default:
	case CLASS_CLERIC:
		dam = dam * 95 / 100;
		break;
	}
    }

    if ( is_affected(ch,gsn_spirit_of_bear) )
 	dam += base_dam / 10;

/* Handle critical strikes */
    handle_critical(  ch, &dam,  dam_type, diceroll_save, base_dam );
 
    result = damage( ch, victim, dam, dt, dam_type, TRUE ,FALSE);
    
    /* but do we have a funky weapon? */
    if (result && wield != NULL)
    { 
  int dam=0;

  if ( ch->fighting == victim && is_affected(ch,gsn_midnight_cloak) && ( victim->level - ch->level ) >= -5 )
	 /* no more than 5 levels above vict */
   {
      if ( time_info.hour >= 20 || time_info.hour <= 5 )
	ch->hit++;
      if ( time_info.hour == 0 )
	ch->hit += 4;
   }

  if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_POISON))
  {
      int level;
      AFFECT_DATA *poison, af;

      if ((poison = affect_find(wield->affected,gsn_poison)) == NULL)
    level = wield->level;
      else
    level = poison->level;
  
      if (!saves_spell(level / 2,victim,DAM_POISON)) 
      {
    send_to_char("You feel poison coursing through your veins.",
        victim);
    act("$n is poisoned by the venom on $p.",
        victim,wield,NULL,TO_ROOM,FALSE);

        af.where     = TO_AFFECTS;
        af.type      = gsn_poison;
        af.level     = level * 3/4;
        af.duration  = level / 2;
        af.location  = APPLY_STR;
        af.modifier  = -1;
        af.bitvector = AFF_POISON;
        affect_join( victim, &af );
      }

      /* weaken the poison if it's temporary */
      if (poison != NULL)
      {
        poison->level = UMAX(0,poison->level - 2);
        poison->duration = UMAX(0,poison->duration - 1);
  
        if (poison->level == 0 || poison->duration == 0) {
          act("The poison on $p has worn off.",ch,wield,NULL,TO_CHAR,FALSE);
          affect_remove_obj ( wield, poison );
        }
      }
  }

      if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_NETHER))
  {
      dam = number_range( 1, wield->level /5 + 1);
      /* can only use nether if the char has the kit 
	 no damage done to char if not a nethermancer */
      if ( HAS_KIT(ch,"nethermancer") )
      {
      act("$p bleeds the soul of $n.",victim,wield,NULL,TO_ROOM,FALSE);
      act("$p bleeds your soul.",victim,wield,NULL,TO_CHAR,FALSE);
      damage(ch,victim,dam,0,DAM_NEGATIVE,FALSE,TRUE);
      ch->hit += dam /3; ch->mana += dam/3; ch->move += dam /3;
      gain_exp(ch, ( number_percent() < ( ch->level / 10 ) ) ? 1 : 0 );
      }
  }    
      if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_VAMPIRIC))
  {
      /*Make Necromancer's hit harder - Boogums*/
      if (ch->kit== kit_lookup("necromancer") )
      {
	dam = number_range(1, wield->level / 3 + 1);
      }
      if (ch->kit != kit_lookup("necromancer"))
      {
        dam = number_range(1, wield->level / 5 + 1);
      }
      act("$p draws life from $n.",victim,wield,NULL,TO_ROOM,FALSE);
      act("You feel $p drawing your life away.",
    victim,wield,NULL,TO_CHAR,FALSE);
      damage(ch,victim,dam,0,DAM_NEGATIVE,FALSE,TRUE);
      /*Gladiator's alignment doesnt change */
      if (!IS_SET(ch->mhs,MHS_GLADIATOR) &&
      !is_affected(ch, skill_lookup("indulgence"))
      /*added line below for necromancer kit, their alignment doesn't change*/
      &&
      !(ch->kit== kit_lookup("necromancer")) )
      {
         ch->alignment = UMAX(-1000,ch->alignment - 1);
      }
      ch->hit += dam/2;
  }

/*
  if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_SCION)
	&& IS_SET(victim->mhs,MHS_SAVANT) )
  {
	 OOO Sppooky no damage message 
  	ch->hit++; ch->mana++;
	victim->hit--; victim->mana--;
  }
*/

  if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FLAMING))
  {
      dam = number_range(1,wield->level / 4 + 1 );
      /* If there's a flame shield, halve the damage */
      if ( is_affected(victim,skill_lookup("flame shield")))
	dam /= 2;
      act("$n is burned by $p.",victim,wield,NULL,TO_ROOM,FALSE);
      act("$p sears your flesh.",victim,wield,NULL,TO_CHAR,FALSE);
      fire_effect( (void *) victim,wield->level/2,dam,TARGET_CHAR);
      damage(ch,victim,dam,0,DAM_FIRE,FALSE,FALSE);
  }

  if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FROST))
  {
      dam = number_range(1,wield->level / 6 + 2);
      /* If there's a frost shield, halve the damage */
      if ( is_affected(victim,skill_lookup("frost shield")))
	dam /= 2;
      act("$p freezes $n.",victim,wield,NULL,TO_ROOM,FALSE);
      act("The cold touch of $p surrounds you with ice.",
    victim,wield,NULL,TO_CHAR,FALSE);
      cold_effect(victim,wield->level/2,dam,TARGET_CHAR);
      damage(ch,victim,dam,0,DAM_COLD,FALSE,FALSE);
  }

  if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_SHOCKING))
  {
      dam = number_range(1,wield->level/5 + 2);
      /* If there's an electric shield, halve the damage */
      if ( is_affected(victim,skill_lookup("electric shield")))
	dam /= 2;
      act("$n is struck by lightning from $p.",victim,wield,NULL,TO_ROOM,FALSE);
      act("You are shocked by $p.",victim,wield,NULL,TO_CHAR,FALSE);
      shock_effect(victim,wield->level/2,dam,TARGET_CHAR);
      damage(ch,victim,dam,0,DAM_LIGHTNING,FALSE,FALSE);
  }

  if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_HOLY))
  {
      dam = number_range(1,wield->level/5 +2);
      if ( ch->class != class_lookup("paladin") )
      {
	 act("$n is consumed in holy wrath by $p.",ch,wield,NULL,TO_ROOM,FALSE);
	 act("You are consumed in holy wrath by $p.",ch,wield,NULL,TO_CHAR,FALSE);
	 damage(ch,ch,dam,0,DAM_HOLY,FALSE,FALSE);
      }
      else
      {
	 if ( ( IS_GOOD(ch) && !IS_GOOD(victim) ) ||
	      ( IS_EVIL(ch) && !IS_EVIL(victim) ) ||
	      ( IS_NEUTRAL(ch) && !IS_NEUTRAL(victim) ) )
	 {
	   ch->mana += ( dam / 2 );
	   ch->hit += ( dam / 2 );
           if ( ch->pcdata->old_class == class_lookup("warrior") )
           {
             ch->mana += ( dam / 3 );
             ch->hit += ( dam / 3 );
           }
	 }
   act("$n is consumed in holy wrath by $p.",victim,wield,NULL,TO_ROOM,FALSE);
   act("You are consumed in holy wrath by $p.",victim,wield,NULL,TO_CHAR,FALSE);
	 damage(ch,victim,dam,0,DAM_HOLY,FALSE,FALSE);
	 if ( ( IS_GOOD(ch) && IS_EVIL(victim) ) ||
	      ( IS_EVIL(ch) && IS_GOOD(victim) ) )
	      holy_effect(victim,wield->level,ch->alignment,ch);
      }
  }

  if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_STUN))
  {
    diceroll = number_percent();
    if (victim->race == race_lookup("kender"))
    diceroll = (3*diceroll)/4;
    /* faeries are easier to stun once you land the damn blow - removed
    if ( victim->race == race_lookup("faerie"))
    diceroll = (4*diceroll)/3;
	*/
    if ( diceroll >= 95 + victim->level - wield->level)
     {
    dam = number_range(1,4);
    act("$p knocks down $n.",victim,wield,NULL,TO_ROOM,FALSE);
    act("You feel dazed as $p knocks you over.",
    victim,wield,NULL,TO_CHAR,FALSE);
    damage(ch,victim,dam,0,DAM_NEGATIVE,FALSE,TRUE);
    DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
    victim->position = POS_RESTING;
      }
  }

  
    }
    tail_chain( );
    return;
}

/*
 * Inflict damage from a hit.
 */
bool damage(CHAR_DATA *ch,CHAR_DATA *victim,int dam,int dt,int dam_type, bool show, bool iOld)
{
    OBJ_DATA *corpse;
    bool immune,surprised=FALSE;
    char cdbuf[MAX_STRING_LENGTH];
    char wdbuf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    CHAR_DATA *gch,*gch_next, *kch;
    char toast[15] = "toasted";
    bool fSecondary = FALSE;
    bool kill_by_plain_mob = TRUE;
    bool fDOT = FALSE;
    int	base_dam;
    AFFECT_DATA *paf;
    bool primary_undead = FALSE;
    bool secondary_undead = FALSE;
    bool self_undead = FALSE;
 
    ROOM_INDEX_DATA *died_in_room = ch->in_room;
    //OBJ_DATA *weapon;
//moved the necromancer check into here

#ifdef COREY_TEST
  if( HAS_KIT(ch,"necromancer")  && ch->alignment < 0 )
  {
  if(
      number_percent() * number_percent() < 1       &&
      ((weapon = get_eq_char(ch,WEAR_WIELD)) != NULL) &&
      number_percent() / 2 < ch->level / (weapon->enchanted?4:2)  &&
      (!IS_SET(weapon->value[4],WEAPON_VAMPIRIC))  &&
      (!IS_SET(weapon->value[4],WEAPON_FAVORED))
    )
    {
      SET_BIT(weapon->value[4],WEAPON_VAMPIRIC);
      act("{YWICKED!{x  $p suddenly looks a bit more {Devil{x.",ch,weapon,NULL,TO_CHAR,FALSE);
      act("{YWICKED!{x  $p suddenly looks a bit more {Devil{x.",ch,weapon,NULL,TO_ROOM,FALSE);
    }
  }
#endif

     /* See if this is a damage over time source */
    if ( dt == TYPE_DOT )
	fDOT = TRUE;

    if ( victim->position == POS_DEAD )
       return FALSE;

    if (dt == TYPE_SECONDARY)
    {
       OBJ_DATA *wield;
       wield = get_eq_char( ch, WEAR_SECOND );

       fSecondary = TRUE;

       dt = TYPE_HIT;
       if ( wield != NULL && wield->item_type == ITEM_WEAPON )
          dt += wield->value[3];
       else
       {
          if( IS_AFFECTED(ch,AFF_MORPH) )
	     dt += 5;
          else if( IS_AFFECTED(ch,AFF_WEAPONRY))
	     dt += 13;
          else dt += ch->dam_type;
       }
    }

    /*
     * Stop up any residual loopholes.
     */
    if ( dam > 1200 && dt >= TYPE_HIT)
    {
       sprintf(log_buf,"Damage (%d) from %s: more than 1200 points!",dam,ch->name);
       bug( log_buf, 0 );
       dam = 1200;
       if (!IS_IMMORTAL(ch))
       {
          OBJ_DATA *obj;
	  if (fSecondary)
             obj = get_eq_char( ch, WEAR_SECOND );
	  else
             obj = get_eq_char( ch, WEAR_WIELD );

          if ( obj != NULL && !IS_WEAPON_STAT(obj,WEAPON_VORPAL) )
          {
             send_to_char("You really shouldn't cheat.\n\r",ch);
             /* 
        	extract_obj(obj);  */
          }
       }
    }

    
    /* damage reduction */
    if ( dam > 40)
       dam = (dam - 40)/2 + 40;
    if ( dam > 80)
       dam = (dam - 80)/2 + 80; 


    base_dam = dam;

    /* Damage bonus for shogun */
    if ( !IS_NPC(ch) && HAS_KIT(ch,"shogun") )
    {
	int total_groupies=0;

	/* Sword bonus */
	if ( check_hai_ruki( ch ) )
	{
	    dam += (base_dam/10);
	    check_improve(ch,skill_lookup("hai-ruki"),TRUE,10); /* only check on success */
	}

	/* player counts as 1 */
	total_groupies = count_groupies_in_room( ch );

	if ( total_groupies > 1 )
	    dam += (((100+(5*total_groupies))*base_dam/100) - base_dam);
    }
    else
    if ( shogun_in_group(ch) )
    {
	int total_groupies;

 	total_groupies = count_groupies_in_room( ch );

	if( total_groupies > 1 )
	    dam += (((100+(2*total_groupies))*base_dam/100) - base_dam);
    }
    
    if( ch->clan == clan_lookup("demise") &&
        is_affected( victim, skill_lookup("honor guard") ) 
      )
    {
         dam -= dam/4; 
    }

    if( dam_type == DAM_FIRE && 
	is_affected(victim,skill_lookup("flame shield")))
       dam /= 2;

    if( dam_type == DAM_COLD && 
	is_affected(victim,skill_lookup("frost shield")))
       dam /= 2;

    if( dam_type == DAM_LIGHTNING && 
	is_affected(victim,skill_lookup("electric shield")))
       dam /= 2;

    /* Improved damage for ogres and giants with bash weapons.
       Does (100% + 1%/2levels) extra damage AFTER the curve  */
    if ( dam_type == DAM_BASH &&
	( ch->race == race_lookup("ogre") ||
	  ch->race == race_lookup("giant") ) )
	dam = ( (ch->level / 2) + 100 ) * (UMAX(base_dam,dam)) / 100;

    /* barbarian endurance -> little randomness */
    if ( number_percent() < ( get_skill(victim,gsn_endurance) / 2 ) )
    {
	check_improve(ch,gsn_endurance,TRUE,1);
	dam = number_range(7,9) * dam / 10;
    }
    else
	check_improve(ch,gsn_endurance,FALSE,4);

   
    if ( victim != ch )
    {
  /*
   * Certain attacks are forbidden.
   * Most other attacks are returned.
   */
       if ( is_safe( ch, victim ) )
          return FALSE;
       check_killer( ch, victim );

       if ( victim->position > POS_STUNNED )
       {
          if ( ch->fighting == NULL 
	     && !is_affected(victim,skill_lookup("orb of surprise")) &&
		!fDOT )
             set_fighting( ch, victim );
       }

       if ( victim->position > POS_STUNNED && !fDOT )
       {
          if ( victim->fighting == NULL )
          {    
	     if(is_affected(victim,skill_lookup("orb of surprise")) )
	     {
	        send_to_char("Someone tried to sneak up on you, ",victim);
	        send_to_char("{GRUN!{x\n\r", victim );

	        blow_orb(victim,skill_lookup("orb of surprise"));
	        surprised = TRUE;
	        stop_fighting(victim,FALSE);
	     } 
	     else  if ( !fDOT )
	     {
                if (victim->timer <= 4 || iOld)
	           set_fighting( victim, ch );
	     }
          }
          if (victim->timer <= 4 && !surprised )
             victim->position = POS_FIGHTING;
       }

       if ( ch->fighting != NULL 
	    && is_affected(ch,skill_lookup("orb of surprise")) )
	   blow_orb(ch,skill_lookup("orb of surprise"));

  /*
   * More charm stuff.
   */
       if ( victim->master == ch )
          stop_follower( victim );
    } /* Victim is not Ch */

    /*
     * Traps?  No steenkin traps!
     * Earthbind DOES remain in effect, tho
     */
    if ( is_affected(victim,gsn_trap) )
       affect_strip( victim, gsn_trap );

    /*
     * Inviso attacks ... not.
     */
    if ( IS_AFFECTED(ch, AFF_INVISIBLE) )
    {
       affect_strip( ch, gsn_invis );
       affect_strip( ch, gsn_mass_invis );
       REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
       act( "$n fades into existence.", ch, NULL, NULL, TO_ROOM ,FALSE);
    }

    if ( IS_SET(ch->mhs, MHS_FADE ) )
    {
	REMOVE_BIT(ch->mhs,MHS_FADE);
	act("$n shimmers into existance.",ch,NULL,NULL,TO_ROOM ,FALSE);
    }
    /*
     * sneaking away ... not.
     */
    if ( IS_AFFECTED(ch, AFF_SNEAK) && 
	( ch->class != class_lookup("thief")
	 && ch->class != class_lookup("assassin") 
	 && ch->class != class_lookup("rogue")
	)
       )
    {
       affect_strip( ch, gsn_sneak  );
       REMOVE_BIT( ch->affected_by, AFF_SNEAK );
     act( "$n no longer moves silently about.", ch, NULL, NULL, TO_ROOM ,FALSE);
    }

    /*
     * No hiding.
     */
    REMOVE_BIT( ch->affected_by, AFF_HIDE );

    /*
     * Remove Shapemorph
     */
    if ( IS_SET(ch->mhs,MHS_SHAPEMORPHED))
    {
       REMOVE_BIT(ch->mhs,MHS_SHAPEMORPHED);
       send_to_char("You return to your regular appearance. Yikes!\n\r",ch);
     act( "$n returns to $s regular appearance.", ch, NULL, ch, TO_ROOM ,FALSE);
    }

    /* Reset the attack timer so they dont get disqualified */
    if(!IS_NPC(ch) && IS_SET(ch->mhs,MHS_GLADIATOR) && victim != ch )
       ch->pcdata->gladiator_attack_timer = 5;

    /*
     * Damage modifiers.
     */

//#ifdef COREYTEST

   if ( !IS_NPC(victim)
	&& IS_SET(ch->act,PLR_VAMP)
	&& IS_SET(victim->act,PLR_VAMP)
      )
      {
	self_undead = TRUE;
      }
   if ( !IS_NPC(victim)
       && IS_SET(ch->act,PLR_WERE)
       && IS_SET(victim->act,PLR_WERE)
      )
      {
        self_undead = TRUE;
      }
   if ( !IS_NPC(victim)
       && IS_SET(ch->act,PLR_MUMMY)
       && IS_SET(victim->act,PLR_MUMMY)
      )
      {
        self_undead = TRUE;
      }

   if ( HAS_KIT(ch,"vampyre hunter")
       && !IS_NPC(victim)
       && IS_SET(victim->act,PLR_VAMP)
       )
       {
        primary_undead = TRUE; 
       }
    else if ( !IS_NPC(victim) && (IS_SET(victim->act, PLR_WERE) || IS_SET(victim->act, PLR_MUMMY)) )
       {
        secondary_undead = TRUE;
       }
   if ( HAS_KIT(ch,"lycanthrope hunter")
       && !IS_NPC(victim)
       && IS_SET(victim->act,PLR_WERE)
       )
	{
	primary_undead = TRUE;
       }
    else if ( !IS_NPC(victim) && (IS_SET(victim->act, PLR_VAMP) || IS_SET(victim->act, PLR_MUMMY)) )
       {
	secondary_undead = TRUE;
       }

   if ( HAS_KIT(ch,"archeologist")
       && !IS_NPC(victim)
       && IS_SET(victim->act,PLR_MUMMY) 
       )
       {
	primary_undead = TRUE;
       }
    else if ( !IS_NPC(victim) && (IS_SET(victim->act, PLR_WERE) || IS_SET(victim->act, PLR_VAMP)) )
       {
	secondary_undead = TRUE;
       }

   if ( primary_undead == TRUE  && self_undead == FALSE)
 	{
	  dam += (( ( 125 + (ch->level/2) ) * base_dam / 100) - base_dam );
      	}
   if ( secondary_undead == TRUE && self_undead == FALSE)
	{
	  dam += (( ( 75 + (ch->level/4) ) * base_dam / 100) - base_dam );
	}

//#endif
#ifdef OLDCODEDUDE
    if ( HAS_KIT(ch,"buffy") &&
	( IS_SET(victim->act, PLR_VAMP) ||
	IS_SET(victim->act, PLR_WERE) ||
	IS_SET(victim->act, PLR_MUMMY)) &&
	!IS_NPC(victim)
       )
    {
//   sprintf(log_buf,"bef-buf:%s hit/dam:%d/%d dam: %d to %s",ch->name,ch->hitroll,ch->damroll,dam,victim->name);
//   log_string(log_buf);
	dam += (( ( 125 + (ch->level/2) ) * base_dam / 100) - base_dam );
//   sprintf(log_buf,"aft-buf:%s hit/dam:%d/%d dam: %d to %s",ch->name,ch->hitroll,ch->damroll,dam,victim->name);
//   log_string(log_buf);
    }
#endif


    if ( HAS_KIT(ch,"wyrmslayer") &&
	IS_SET(victim->form,FORM_DRAGON) )
	dam += (( ( 100 + (ch->level/2) ) * base_dam / 100) - base_dam );
   
#ifdef CODETEST
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
      {
	sprintf(log_buf,"Before remort vuln %d, ",dam);
	send_to_char(log_buf,ch);
      }
#endif

    if (IS_SET(victim->act,PLR_MUMMY) && !iOld )
    {
	OBJ_DATA *obj;
	  if (fSecondary)
             obj = get_eq_char( ch, WEAR_SECOND );
	  else
             obj = get_eq_char( ch, WEAR_WIELD );
	if ( obj != NULL && is_name("fire",obj->material) )
	   dam += ((base_dam)/5);
        else if (obj != NULL && !IS_WEAPON_STAT(obj,WEAPON_FLAMING))
	   dam = (3*dam)/4;
    }

    /* Ok, here goes teh POSSE stuff - Boogums*/
    /* This code removed by NIGHTDAGGER 

    if ( ch->clan == clan_lookup("posse") && IS_SET(victim->act, PLR_KILLER) )
    {
      dam += (base_dam * .14);
    }
    if ( ch->clan == clan_lookup("posse") && IS_SET(victim->act, PLR_THUG) )
    {
      dam += (base_dam * .08);
    }
    if ( ch->clan == clan_lookup("posse") && IS_SET(victim->act, PLR_RUFFIAN) )
    {
       dam += (base_dam * .05);
    }
    if ( ch->clan == clan_lookup("posse") && IS_SET(victim->act, PLR_THIEF) )
    {
      dam += (base_dam * .11);
    }
    End code nerf */

    if ( IS_SET(victim->act,PLR_VAMP) && !iOld )
    {
	OBJ_DATA *obj;
	  if (fSecondary)
             obj = get_eq_char( ch, WEAR_SECOND );
	  else
             obj = get_eq_char( ch, WEAR_WIELD );
	if ( obj != NULL && is_name("wood",obj->material) )
	dam += base_dam/5;
    }

    if ( IS_SET(victim->act,PLR_WERE) && !iOld )
    {
	OBJ_DATA *obj;
	  if (fSecondary)
             obj = get_eq_char( ch, WEAR_SECOND );
	  else
             obj = get_eq_char( ch, WEAR_WIELD );
	if ( obj != NULL && is_name("silver",obj->material) )
	dam += base_dam/5;
    }

#ifdef CODETEST
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
      {
	sprintf(log_buf,"after remort vuln %d\n\r",dam);
	send_to_char(log_buf,ch);
      }
#endif
    if ( victim->race == race_lookup("elf") || victim->race == race_lookup("half elf"))
    {
       OBJ_DATA *obj;
       if (fSecondary)
         obj = get_eq_char(ch, WEAR_SECOND);
       else
         obj = get_eq_char(ch, WEAR_WIELD);

       if (obj != NULL && ( is_name("iron", obj->material) || is_name("steel", obj->material)))
           dam += base_dam/5;
     }

    /* Smurfs resist two handed weapons*/ 
    if (victim->race == race_lookup("smurf"))
    {
       OBJ_DATA *obj;
       if (fSecondary)
         obj = get_eq_char(ch, WEAR_SECOND);
       else
         obj = get_eq_char(ch, WEAR_WIELD);
 
       if(obj != NULL && IS_WEAPON_STAT(obj,WEAPON_TWO_HANDS))
          dam -= (dam / 3);
    }

    immune = FALSE;

/* placed before damage skins so attacks will interrupt it */
    if ( !IS_NPC(victim) && victim->pcdata->wraith_timer > 0 )
    {
        victim->pcdata->wraith_timer = 0;
        act("Your attempt to go to wraithform is interruptd.",victim,NULL,NULL,TO_CHAR,FALSE);
	act("$n failed to go to wraithform.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if ( (paf = affect_find(victim->affected,gsn_shield_of_faith) ) != NULL )
     {
        paf->duration--;
        dam = 0;
        act("Your shield of faith protects you!",victim,NULL,NULL,TO_CHAR,FALSE);
        act("$n's shield of faith protects $m!",victim,NULL,NULL,TO_ROOM,FALSE);
        if ( --paf->duration <  0 )
        {
           affect_remove(victim,paf,APPLY_BOTH);
        act("Your shield of faith is gone.",victim,NULL,NULL,TO_CHAR,FALSE);
        act("$n's shield of faith is gone.",victim,NULL,NULL,TO_ROOM,FALSE);
        }
        return TRUE;
     }

     if ( (paf = affect_find(victim->affected,gsn_steel_skin) ) != NULL )
     {
        paf->duration--;
         dam = 0;
         act("$n's attack deflects harmlessly off your steel skin.",ch,NULL,victim,TO_VICT,FALSE);
         act("Your attack deflects harmlessly off $N's steel skin.",ch,NULL,victim,TO_CHAR,FALSE);
         act("$n's attack deflects harmlessly off $N's steel skin.",ch,NULL,victim,TO_NOTVICT,FALSE);
         if ( --paf->duration <  0 )
         {
              affect_remove(victim,paf,APPLY_BOTH);
                act("Your skin becomes flesh again.",victim,NULL,NULL,TO_CHAR,FALSE);
                act("$n's skin becomes flesh again.",victim,NULL,NULL,TO_ROOM,FALSE);
        }
        return TRUE;
    }

    if ( (paf = affect_find(victim->affected,gsn_diamond_skin) ) != NULL )
    {
        paf->duration--;
        dam = 0;
        act("$n's attack deflects harmlessly off your diamond skin.",ch,NULL,victim,TO_VICT,FALSE);
        act("Your attack deflects harmlessly off $N's diamond skin.",ch,NULL,victim,TO_CHAR,FALSE);
        act("$n's attack deflects harmlessly off $N's diamond skin.",ch,NULL,victim,TO_NOTVICT,FALSE);
        if ( --paf->duration <  0 )
        {
            affect_remove(victim,paf,APPLY_BOTH);
            act("Your skin becomes flesh again.",victim,NULL,NULL,TO_CHAR,FALSE);
            act("$n's skin becomes flesh again.",victim,NULL,NULL,TO_ROOM,FALSE);
        }
        return TRUE;
    }

    if ( (paf = affect_find(victim->affected,gsn_adamantite_skin) ) != NULL )
    {
        paf->duration--;
        dam = 0;
        act("$n's attack deflects harmlessly off your adamantite skin.",ch,NULL,victim,TO_VICT,FALSE);
        act("Your attack deflects harmlessly off $N's adamantite skin.",ch,NULL,victim,TO_CHAR,FALSE);
        act("$n's attack deflects harmlessly off $N's adamantite skin.",ch,NULL,victim,TO_NOTVICT,FALSE);
        if ( --paf->duration <  0 )
        {
            affect_remove(victim,paf,APPLY_BOTH);
            act("Your skin becomes flesh again.",victim,NULL,NULL,TO_CHAR,FALSE);
            act("$n's skin becomes flesh again.",victim,NULL,NULL,TO_ROOM,FALSE);
        }
        return TRUE;
    }


    if ( (paf = affect_find(victim->affected,gsn_acclimate) ) != NULL )
    {
	affect_remove(victim,paf,APPLY_BOTH);
	act("You are no longer attuned to your environment.",victim,NULL,NULL,TO_CHAR,FALSE);
	act("$n is no longer attuned to $s environment.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
	
    /*
     * Check for parry, and dodge.
     */
    if ( dt >= TYPE_HIT && ch != victim)
    {
	if ( check_parry( ch, victim,fSecondary ) )
	{
           /* Gladiator Spectator Channel */
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 10)
           {
              sprintf(cdbuf,"%s parries an attack from %s.",victim->name,ch->name);
              gladiator_talk(cdbuf);
           }
           return FALSE;
	}
        if ( check_mistform(ch,victim))
	{
           /* Gladiator Spectator Channel */
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 10)
           {
              sprintf(cdbuf,"What the hell was that?! %s's weapon just went right through %s.",ch->name,victim->name);
              gladiator_talk(cdbuf);
           }
           return FALSE;
	}
        if ( check_dodge( ch, victim,fSecondary ) )
	{
           /* Gladiator Spectator Channel */
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 10)
           {
              sprintf(cdbuf,"%s dodges an attack from %s.",victim->name,ch->name);
              gladiator_talk(cdbuf);
           }
           return FALSE;
	}
        if ( check_kailindo( ch, victim ) )
	{
	  if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 10)
	  {
	    sprintf(cdbuf,
	    	"%s evades an attack from %s and quickly strikes back.",
		victim->name,ch->name);
            gladiator_talk(cdbuf);
	  }
          return FALSE;
	}
        if ( check_shield_block(ch,victim,fSecondary))
	{
           /* Gladiator Spectator Channel */
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 10)
           {
              sprintf(cdbuf,"%s blocks an attack from %s with a shield.",victim->name,ch->name);
              gladiator_talk(cdbuf);
           }
           return FALSE;
	}
	if ( check_scales(ch,victim,fSecondary))
	{
           /* Gladiator Spectator Channel */
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 10)
           {
              sprintf(cdbuf,"%s wasn't strong enough to get through %s's scales.",ch->name,victim->name);
              gladiator_talk(cdbuf);
           }
	    return FALSE;
	}
	if ( check_nether( ch, victim, fSecondary) )
		   return FALSE;
    }
 
#ifdef CODETEST
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
      {
	sprintf(log_buf,"Before race vuln %d, ",dam);
	send_to_char(log_buf,ch);
      }
#endif

    if ( dam > 1 && !IS_NPC(victim) 
         &&   victim->pcdata->condition[COND_DRUNK]  > 10 )
       dam = 9 * dam / 10;

    if ( dam > 1 && IS_AFFECTED(victim, AFF_SANCTUARY) )
       dam /= 2;

    if ( dam > 1 && ( (IS_AFFECTED(victim, AFF_PROTECT_EVIL) && IS_EVIL(ch))
    ||         (IS_AFFECTED(victim, AFF_PROTECT_GOOD) && IS_GOOD(ch))
    ||	(is_affected(victim,gsn_protect_neutral) && IS_NEUTRAL(ch)) ))
       dam -= dam / 4;

    switch(check_immune(victim,dam_type))
    {
  case(IS_IMMUNE):
      immune = TRUE;
      dam = 0;
      break;
  case(IS_RESISTANT): 
      dam -= (dam / 3); 
      break;
  case(IS_VULNERABLE):
      dam += dam/3;
      break;
    }

#ifdef CODETEST
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
      {
	sprintf(log_buf,"after race vuln %d\n\r",dam);
	send_to_char(log_buf,ch);
      }
#endif

    /* Wound transfer spell */
    if ( is_affected(victim,gsn_wound_transfer)
       && ch != victim)
    {
       int count = 1;

       for ( gch = victim->in_room->people ;
	     gch != NULL ;
	     gch = gch_next )
       {
	   gch_next = gch->next_in_room;

	   if ( gch == ch || gch == victim )
		continue;

	   if ( is_same_group(gch,victim) )
	      ++count;
       }
       
       dam /= UMIN(count,iOld?3:4);
       
       for ( gch = victim->in_room->people ;
	     gch != NULL ;
	     gch = gch_next )
       {
	   gch_next = gch->next_in_room;

	   if ( gch == ch || gch== victim )
	       continue;

	   if ( is_same_group(gch,victim) )
	   {
	     /* Extra check to avoid infinate recursion */
	      if ( is_affected(gch,gsn_wound_transfer) )
	      {
		 bug("Wound transfer: gch is_affected()",0);
		 continue;
	      }
	      else
	         damage(ch,gch,dam,dt,dam_type,TRUE,iOld);
	   }
       }
    } /* wound transfer spell */

    /* Can't do negative damage */
    dam = UMAX(0,dam);

    if (show)
    {
      if(iOld)
        dam_message( ch, victim, dam, dt, immune );
      else
        dam_message_new( ch, victim, dam, dt, immune );
    }

    if (dam == 0)
       return FALSE;

    /* Handle damage shields */
    if ( is_affected(victim,gsn_shield_of_thorns) && dt >= TYPE_HIT )
    {
	ch->hit = UMAX(1,ch->hit-4);
	act("$n is injured by a shield of thorns protecting $N.",ch,NULL,victim,TO_NOTVICT,FALSE);
	act("You are injured by a shield of thorns protecting $N.",ch,NULL,victim,TO_CHAR,FALSE);
	act("$n is injured by a shield of thorns protecting you.",ch,NULL,victim,TO_VICT,FALSE);
    }

    if ( is_affected(victim,gsn_shield_of_brambles) && dt >= TYPE_HIT )
    {
        ch->hit = UMAX(1,ch->hit-8);
        act("$n is injured by a shield of brambles protecting $N.",ch,NULL,victim,TO_NOTVICT,FALSE);
        act("You are injured by a shield of brambles protecting $N.",ch,NULL,victim,TO_CHAR,FALSE);
        act("$n is injured by a shield of brambles protecting you.",ch,NULL,victim,TO_VICT,FALSE);
    }

    if ( is_affected(victim,gsn_shield_of_spikes) && dt >= TYPE_HIT )
    {
        ch->hit = UMAX(1,ch->hit-12);
        act("$n is injured by a shield of spikes protecting $N.",ch,NULL,victim,TO_NOTVICT,FALSE);
        act("You are injured by a shield of spikes protecting $N.",ch,NULL,victim,TO_CHAR,FALSE);
        act("$n is injured by a shield of spikes protecting you.",ch,NULL,victim,TO_VICT,FALSE);
    }

    if ( is_affected(victim,gsn_shield_of_blades) && dt >= TYPE_HIT )
    {
        ch->hit = UMAX(1,ch->hit-16);
        act("$n is injured by a shield of blades protecting $N.",ch,NULL,victim,TO_NOTVICT,FALSE);
        act("You are injured by a shield of blades protecting $N.",ch,NULL,victim,TO_CHAR,FALSE);
        act("$n is injured by a shield of blades protecting you.",ch,NULL,victim,TO_VICT,FALSE);
    }

    /*
     * Hurt the victim.
     * Inform the victim of his new state.
     */

    if ( victim->hit - dam < 1 &&
	  HAS_KIT(victim,"nethermancer") && 
	 number_percent() <= get_skill(victim,gsn_nethermancy) )
    {
       if( victim->mana < ( dam * 2 ) )
       {
	check_improve(victim,gsn_nethermancy,FALSE,10);
	send_to_char("Your nethermancy has failed you.\n\r",victim);
	victim->hit -= dam;
       }
       else
       {
	check_improve(victim,gsn_nethermancy,TRUE,10);
	victim->hit = 1;
	victim->mana -= ( dam * 2 );
	}
    }
    else
     /* Communion */
    if ( victim->hit - dam < 1 &&
	 !IS_NPC(victim) &&
	 number_percent() <= get_skill(victim,gsn_communion))
    {
       if( victim->pcdata->sac < dam*2 ) 
       {
 	   check_improve(victim,gsn_communion,FALSE,6);
	   send_to_char("Your communion has failed.\n\r",victim);
      	   victim->hit -= dam;
       }
       else
       {
       check_improve(victim,gsn_communion,TRUE,3);
       victim->hit = 1; /* ALWAYS set to 1 if communion works */
       victim->pcdata->sac -= dam*2; 
       }
    }
    else
       victim->hit -= dam;
      
/* 
    check_improve(victim,gsn_communion,FALSE,6);
 */

    if ( !IS_NPC(victim)
       && (victim->level >= LEVEL_IMMORTAL )
       &&   victim->hit < 1 )
       victim->hit = 1;

    update_pos( victim );

    switch( victim->position )
    {
    case POS_MORTAL:
  act( "$n is mortally wounded, and will die soon, if not aided.",
      victim, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( 
      "You are mortally wounded, and will die soon, if not aided.\n\r",
      victim );
  if (!is_clan(victim))
  {
     sprintf(cdbuf, 
        "%s has been mortally wounded by %s at %s.\n\r",
        victim->name,ch->short_descr,victim->in_room->name);
           pnet(cdbuf,NULL,NULL,PNET_MATOOK,0,0);

     stop_fighting(victim,TRUE);

     for ( d = descriptor_list; d != NULL; d = d->next )
     {
        CHAR_DATA *victm;

        victm = d->original ? d->original : d->character;

        if ( d->connected == CON_PLAYING &&
             d->character != victim &&
	     !IS_SET(victm->comm,COMM_QUIET) && !IS_NPC(victm) &&
             !str_cmp(deity_table[victm->pcdata->deity].pname,"matook"))
           send_to_char(cdbuf, victm);
     }
  }
  break;

    case POS_INCAP:
  act( "$n is incapacitated and will slowly die, if not aided.",
      victim, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char(
      "You are incapacitated and will slowly die, if not aided.\n\r",
      victim );
  if (!is_clan(victim))
  {
     sprintf(cdbuf, 
        "%s has been incapacitated by %s at %s.\n\r",
        victim->name,ch->short_descr,victim->in_room->name);
           pnet(cdbuf,NULL,NULL,PNET_MATOOK,0,0);

     stop_fighting(victim,TRUE);

     for ( d = descriptor_list; d != NULL; d = d->next )
     {
        CHAR_DATA *victm;

        victm = d->original ? d->original : d->character;

        if ( d->connected == CON_PLAYING &&
             d->character != victim &&
	     !IS_SET(victm->comm,COMM_QUIET) && !IS_NPC(victm) &&
             !str_cmp(deity_table[victm->pcdata->deity].pname,"matook"))
           send_to_char(cdbuf, victm);
     }
  }
  break;

    case POS_STUNNED:
  act( "$n is stunned, but will probably recover.",
      victim, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char("You are stunned, but will probably recover.\n\r",
      victim );
  break;
    case POS_DEAD:
  act( "$n is {RDEAD{x!!", victim, 0, 0, TO_ROOM ,FALSE);
  send_to_char( "You have been {RKILLED{x!!\n\r\n\r", victim );
  break;

    default:
  if ( dam > victim->max_hit / 4 )
       send_to_char( "That really did {YHURT{x!\n\r", victim );
  if ( victim->hit < victim->max_hit / 4 && 
	!IS_SET(victim->comm,COMM_SILENCE) )
     {
       send_to_char( "You sure are {RBLEEDING{x!\n\r", victim );
     }
  break;
    }

    /*
     * Sleep spells and extremely wounded folks.
     */
    if ( !IS_AWAKE(victim) )
       stop_fighting( victim, FALSE );

    /*
     * Payoff for killing things.
     */
    if ( victim->position == POS_DEAD )
    {
       /* Poquah's new death code DEATH POQUAH */
       /* Ch and Victim are both gladiators in Gladiator Combat */
       if (IS_SET(ch->mhs,MHS_GLADIATOR) &&
           IS_SET(victim->mhs,MHS_GLADIATOR) &&
           !IS_NPC(ch) &&
           !IS_NPC(victim) &&
           !IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH) &&  
           gladiator_info.started == TRUE)
       {
          gladiator_kill(victim,ch);  
          return TRUE;
       }
 
       /* No Die Room */
       if (IS_SET (ch->in_room->room_flags,ROOM_NODIE))
       {
          if ( !is_affected(victim,skill_lookup("withstand death")) )
          {
             raw_kill(victim,ch);
             died_in_room = ch->in_room;
             sprintf( log_buf, "%s got toasted by %s at %s [room %d]",
               (IS_NPC(victim) ? victim->short_descr : victim->name),
               (IS_NPC(ch) ? ch->short_descr : ch->name),
               died_in_room->name, died_in_room->vnum);
             log_string (log_buf);
             if (IS_NPC(victim))
               wiznet(log_buf, NULL, NULL, WIZ_MOBDEATHS, 0, 0);
             else
             {
               wiznet(log_buf, NULL, NULL, WIZ_DEATHS, 0, 0);
               if (!is_clan(victim) )
               {
                 pnet("$N died.", victim, NULL, PNET_DEATHS, 0, 0);
               }
             }
          }
          else
             raw_kill(victim,ch);

          return TRUE;
       }

       if ( !IS_NPC(victim) )
       {

          if (IS_NPC(ch) && ch->master != NULL) 
          {
             kch = ch->master;
             kill_by_plain_mob = FALSE;
          }
          else
          {
             if (!IS_NPC(ch))
             {
                kill_by_plain_mob = FALSE;
                kch = ch;
             }
             else
             {
                kill_by_plain_mob = TRUE;
                kch = ch;
             }
          }
          if (!IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH)) 
	  {        
             if (kch->clan == clan_lookup("smurf") 
                || victim->clan == clan_lookup("smurf"))
             {
                raw_kill(victim,kch);
                return TRUE;
             }

             group_gain( ch, victim );
             /*
              * Dying penalty: No Withstand
              * 2/3 way back to previous level.
              */
       
             if ( victim->exp > exp_per_level(victim,victim->pcdata->points) 
                 * victim->level ) 
               gain_exp(victim,(exp_per_level(victim,victim->pcdata->points)*victim->level - victim->exp)*2/3); 

             /* Is_clan will eliminate nonclanners giving out toast messages*/
             if (!kill_by_plain_mob && is_clan(victim))
             { /* Killed by char or Charmie */
                if(victim != kch)
                { /* victim is not char */

                   if(victim->pcdata->last_death_timer == 0)
                   { 
/* Victim has not been killed recently */
 	              if ( HAS_KIT(kch,"nethermancer") && 
		        HAS_KIT(victim,"nethermancer") &&
		        number_percent() < get_curr_stat(kch,STAT_INT) &&
		        number_percent() < kch->hit / 80 )
	              { /* give nether flag to weapon, if they have one */
	                 OBJ_DATA *weapon;

	                 if ( ( weapon = get_eq_char( kch, WEAR_WIELD ) ) != NULL )
	                 {
		            SET_BIT(weapon->value[4],WEAPON_NETHER);
	  act("$p {Yflashes{x with a {Dblack{x aura.",kch,weapon,NULL,TO_CHAR,FALSE);
	  act("$p {Yflashes{x with a {Dblack{x aura.",kch,weapon,NULL,TO_ROOM,FALSE);
                         }
	              }

	              if (str_cmp(kch->pcdata->last_kill,victim->name) &&
                         str_cmp(victim->pcdata->last_killed_by,kch->name))
                      {

                         if(kch->level + 4 < victim->level) 
                            kch->pcdata->killer_data[PC_GREATER_KILLS]++;
                         else if(kch->level > victim->level +4)
                            kch->pcdata->killer_data[PC_LOWER_KILLS]++;
                         else
                            kch->pcdata->killer_data[PC_EQUAL_KILLS]++;

                     for ( gch = char_list ; gch != NULL; gch = gch->next )
                         {
                            if(!IS_NPC(gch) && kch != gch && is_same_group(kch,gch))  
                            {    
                         if(gch->level + 4 < victim->level) 
                            gch->pcdata->killer_data[PC_GREATER_KILLS]++;
                         else if(gch->level > victim->level +4)
                            gch->pcdata->killer_data[PC_LOWER_KILLS]++;
                         else
                            gch->pcdata->killer_data[PC_EQUAL_KILLS]++;

	                    }
                         } 

	                 victim->pcdata->killer_data[PC_DEATHS] += 1 ;
                         /* update clan statistics */
                         if(kch->clan == clan_lookup("honor"))
                         {
                            honor_kills += 1;
                            if (victim->clan == clan_lookup("demise"))
                               honor_demise_kills += 1;
                         }
                         if(kch->clan == clan_lookup("posse"))
                            posse_kills += 1;
                         if(kch->clan == clan_lookup("warlock"))
                            warlock_kills += 1;
                         if(kch->clan == clan_lookup("demise"))
                            demise_kills += 1;
                         if(kch->clan == clan_lookup("zealot"))
                            zealot_kills += 1;
                         if(kch->clan == clan_lookup("avarice"))
                            avarice_kills += 1;

                         kch->pcdata->last_kill_date = current_time;
                         kch->pcdata->logins_without_kill = 0;
                         victim->pcdata->last_death_date = current_time; 
                         victim->pcdata->logins_without_death = 0;
	              }

	              if(victim->trumps == 0 && kch->level - victim->level <= 8 
	                 && !IS_SET(victim->wiznet,PLR_RUFFIAN)
	                 && !IS_SET(victim->act,PLR_DWEEB)
	                 && !IS_SET(victim->act,PLR_THIEF) 
	                 && str_cmp(kch->pcdata->last_kill,victim->name) )
	              {
                         if (kch->clan == clan_lookup("Posse") &&
                            IS_SET(victim->mhs,MHS_POSSE_ENEMY))
                         {
                            sprintf( cdbuf, "%s NO TRUMP POSSE ENEMY killing %s at %d",kch->name, victim->name,kch->in_room->vnum );
                         }
                         else
                         {
                            kch->trumps += 1 ;
                            sprintf( cdbuf, "%s trump++ killing %s at %d",kch->name,
                            victim->name,kch->in_room->vnum );
                         }
                      }
                      log_string( cdbuf );

	              kch->pcdata->last_kill = str_dup( victim->name );
	              victim->pcdata->last_killed_by = str_dup( kch->name );
	              victim->trumps = UMAX(0,victim->trumps -1);
	              if(IS_SET(victim->wiznet,PLR_RUFFIAN))
                      {
	                 REMOVE_BIT(victim->wiznet,PLR_RUFFIAN);
                         if(kch->clan == clan_lookup("posse"))
                            posse_ruffian_kills += 1;
                      }
	              if(kch->trumps >= 3 && !IS_SET(kch->act,PLR_KILLER))
                      {
	                 SET_BIT(kch->act,PLR_KILLER);
	                 send_to_char("*** You are now a KILLER! ***\n\r",kch);
	                 sprintf(wdbuf,"$N got a (KILLER) by murdering %s",victim->name);
	                 wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
                      }

                      if (IS_SET(victim->act,PLR_THIEF))
                      {
                         REMOVE_BIT(victim->act,PLR_THIEF);
                         if(kch->clan == clan_lookup("posse"))
                            posse_thief_kills += 1;
                      }
                      else
                      {
                         if(victim->trumps >=3 && IS_SET(victim->act,PLR_KILLER))
                         {
	                    victim->trumps = 2;
                            REMOVE_BIT(victim->act,PLR_KILLER);
                            if(kch->clan == clan_lookup("posse"))
                               posse_killer_kills += 1;
	                 }
	                 else
                         {
                            REMOVE_BIT(victim->act,PLR_KILLER);
                            if(kch->clan == clan_lookup("posse"))
                               posse_thug_kills += 1;
                         }
		      }

	              if (!str_cmp(victim->name,kch->pcdata->last_attacked_by))
	   	         kch->pcdata->last_attacked_by_timer = 0;

                      if (kch->clan == clan_lookup("warlock") &&
		         IS_SET(victim->mhs,MHS_WARLOCK_ENEMY))
		         REMOVE_BIT(victim->mhs,MHS_WARLOCK_ENEMY);
                      if (kch->clan == clan_lookup("zealot") &&
     		          IS_SET(victim->mhs,MHS_ZEALOT_ENEMY))
		         REMOVE_BIT(victim->mhs,MHS_ZEALOT_ENEMY);
                      if (kch->clan == clan_lookup("posse") &&
		          IS_SET(victim->mhs,MHS_POSSE_ENEMY))
		         REMOVE_BIT(victim->mhs,MHS_POSSE_ENEMY);
                      if (kch->clan == clan_lookup("honor") &&
		          IS_SET(victim->mhs,MHS_HONOR_ENEMY))
		         REMOVE_BIT(victim->mhs,MHS_HONOR_ENEMY);

                      if (victim->pcdata->bounty > 0 )
                      {
                         kch->gold += victim->pcdata->bounty ;
	                 act("You collect the bounty on $N.",kch,NULL,victim,TO_CHAR,FALSE);
	                 sprintf(log_buf,"%s collects a %ld gold bounty on %s.",
   		            kch->name, victim->pcdata->bounty, victim->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
                         pnet(log_buf,NULL,NULL,PNET_BOUNTY,0,0);
    	                 log_string(log_buf);
 	                 victim->pcdata->bounty = 0 ;
                      } 
                   } 
/* Victim has not died recently */
                } /* Victim not Ch */

                /* Set victim's death_timer so spam kills dont affect above */
                victim->pcdata->last_death_timer = 5;

               	if (((kch->hit*100)/kch->max_hit) < 10)
                   strcpy(toast,"edged out");
                if (((kch->hit*100)/kch->max_hit) >= 10)
                   strcpy(toast,"toasted");
                if (((kch->hit*100)/kch->max_hit) >= 25)
                   strcpy(toast,"trashed");
                if (((kch->hit*100)/kch->max_hit) >= 50)
                   strcpy(toast,"flattened");
                if (((kch->hit*100)/kch->max_hit) >= 75)
                   strcpy(toast,"crushed");
                if (((kch->hit*100)/kch->max_hit) >= 100)
                   strcpy(toast,"slaughtered");

                /* Charmed mob did killing */
                if (kch != ch)
                   sprintf( cdbuf, "%s{W%s{x got %s by {W%s{x controlled by {W%s{x\n\r",
                  victim->desc == NULL ? "({YLinkdead{x) " : "",
                  victim->name,toast,ch->name,kch->name);
                else
                   sprintf( cdbuf, "%s{W%s{x got %s by {W%s{x\n\r",
                  victim->desc == NULL ? "({YLinkdead{x) " : "",
                  victim->name,toast,kch->name);

                for ( d = descriptor_list; d != NULL; d = d->next )
                {
                   CHAR_DATA *victm;

                   victm = d->original ? d->original : d->character;
                   if ( d->connected == CON_PLAYING && is_clan(victm) )
                      send_to_char(cdbuf, victm);
                }
             } /* Killed by Charmed mob or player */

             raw_kill(victim,ch);

             /* Save the victims pfile to avoid people crashing us
	        to get back their EQ or duplicate items 
*/
	     save_char_obj(victim);
          } /* No withstand */
          else
          { /*Had withstand */
             /*
              * Dying penalty: No Withstand
              * 2/3 way back to previous level.
              */
             gain_exp(victim,(exp_per_level(victim,victim->pcdata->points)*victim->level - victim->exp)/4); 
                raw_kill( victim, ch );            
                return TRUE;
          } /* Had withstand */
       } /* Victim was not a NPC */
       else
       { /* Victim was a NPC */
          group_gain( ch, victim );
 
	  died_in_room = ch->in_room;
         
          raw_kill( victim,ch );

          if ( !IS_NPC(ch) )
          { /* Ch was not a NPC */ 
             OBJ_DATA *coins;

             corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 

             if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
                corpse && corpse->contains) /* exists and not empty */
                do_get( ch, "all corpse" );

             if (IS_SET(ch->act,PLR_AUTOGOLD) &&
                  corpse && corpse->contains  && /* exists and not empty */
                  !IS_SET(ch->act,PLR_AUTOLOOT))
                if ((coins = get_obj_list(ch,"gcash",corpse->contains))
                  != NULL)
                   do_get(ch, "all.gcash corpse");
            
             if ( IS_SET(ch->act, PLR_AUTOSAC) )
   	     {
                if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
                   return TRUE;  /* leave if corpse has treasure */
                else
                   do_sacrifice( ch, "corpse" );
   	     }
          } /* Ch was not a NPC */
       } /* Victim was a NPC */

       /* Now do things that need to be done with both */
       sprintf( log_buf, "%s got toasted by %s at %s [room %d]",
          (IS_NPC(victim) ? victim->short_descr : victim->name),
          (IS_NPC(ch) ? ch->short_descr : ch->name),
          died_in_room->name, died_in_room->vnum);

 
       log_string( log_buf );
       if (IS_NPC(victim))
          wiznet(log_buf,NULL,NULL,WIZ_MOBDEATHS,0,0);
       else
       {
          wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
	  if( !is_clan(victim) )
	  {
            pnet("$N died.",victim,NULL,PNET_DEATHS,0,0);
	  }
	}

	sprintf(cdbuf, "before return: %s, ch: %s", victim->name, ch->name);
	log_string(cdbuf);

       return TRUE;
    } /* If victim position = DEAD */

    if ( victim == ch )
       return TRUE;

    /*
     * Take care of link dead people.
     */
    if ( !IS_NPC(victim) && victim->desc == NULL )
    {
       if ( number_range( 0, victim->wait ) == 0 )
       {
          if (!IS_SET(victim->act,PLR_NOAUTORECALL))
	     do_recall( victim, "" );
          return TRUE;
       }
    }

    /*
     * Wimp out?
     */
    if ( IS_NPC(victim) && dam > 0 && victim->wait < PULSE_VIOLENCE / 2)
    {
       if ( ( IS_SET(victim->act, ACT_WIMPY) && number_bits( 2 ) == 0
          &&   victim->hit < victim->max_hit / 5) 
          ||   ( IS_AFFECTED(victim, AFF_CHARM) && victim->master != NULL
          &&     victim->master->in_room != victim->in_room ) )
          do_flee( victim, "" );
    }
/*02OCT02 - added the first victim->wimpy >0 below*/

    if ( !IS_NPC(victim)
       &&   victim->wimpy > 0
       &&   victim->hit > 0
       &&   (victim->hit*100)/victim->max_hit <= victim->wimpy
       &&   victim->wait < PULSE_VIOLENCE / 2 )
       flee( victim, "", TRUE );

    tail_chain( );
    return TRUE;
} /* bool damage */


void dam_message_new( CHAR_DATA *ch, CHAR_DATA *victim,int dam,int dt,bool 
immune ) {
    char buf1[256], buf2[256], buf3[256];
    const char *vp1;
    const char *vp2;
    const char *vp3;
    const char *attack;

    if (ch == NULL || victim == NULL)
  return;
  
         if ( dam ==   0 ) { vp1 = "clumsy";    vp2 = "{ymisses{x";
                             vp3 = " harmlessly."                       ;}
    else if ( dam <=   4 ) { vp1 = "clumsy";    vp2 = "{cgives{x";
                             vp3 = " a bruise."           ;}
    else if ( dam <=   8 ) { vp1 = "wobbly";    vp2 = "{chits{x";
                             vp3 = " causing scrapes."     ;}
    else if ( dam <=  12 ) { vp1 = "lucky";    vp2 = "{chits{x";
                             vp3 = " making scratches."                 ;}
    else if ( dam <=   16 ) { vp1 = "amateur";  vp2 = "{chits{x";
                             vp3 = " causing light wounds."             ;}
    else if ( dam <=   20 ) { vp1 = "amateur";    vp2 = "{cstrikes{x";
                             vp3 = ", the wound bleeds."      ;}
    else if ( dam <=   26 ) { vp1 = "competent";    vp2 = "{cstrikes{x";
                             vp3 = ", hitting an organ."      ;}
    else if ( dam <=  32 ) { vp1 = "competent";    vp2 = "{ccauses{x";
                             vp3 = " to gasp in pain."        ;}
    else if ( dam <=  38 ) { vp1 = "skillful";    vp2 = "{ccauses{x";
                             vp3 = " harm!"           ;}
    else if ( dam <=  44 ) { vp1 = "skillful";
                  vp2 = "has a {cdevastating{x effect on"; vp3 = "."        ;}
    else if (dam <=   50 ) { vp1 = "cunning";   vp2 = "{ctears{x into";
                             vp3 = ", shredding flesh."           ;}
    else if ( dam <=  60 ) { vp1 = "strong";    vp2 = "{ccauses{x";
                             vp3 = " to spurt {Rblood{x!"         ;}
    else if ( dam <=  70 ) { vp1 = "{ccalculated{x";
    vp2 = "leaves large gashes on"; vp3 = "!"            ;}
    else if ( dam <=  80 ) { vp1 = "{ccalculated{x";        vp2 = "{ctears{x";
                             vp3 = " leaving a {RGAPING{x hole!"            ;}
    else if ( dam <=  87 ) { vp1 = "well aimed";    vp2 = "{CDISEMBOWELS{x";
                             vp3 = ". Guts spill out!!"         ;}
    else if ( dam <= 94 ) { vp1 = "calm";    vp2 = "{CDISMEMBERS{x";
                             vp3 = "! {RBlood{x splatters!" ;}
    else if ( dam <= 105 ) { vp1 = "wicked";    vp2 = "{CANNIHILATES{x";
                             vp3 = "!!"           ;}
    else if ( dam <= 117 ) { vp1 = "wicked";    vp2 = "{COBLITERATES{x";
                             vp3 = " completely!! "     ;}
    else if ( dam <= 125 ) { vp1 = "barbaric";    vp2 = "{CMASSACRES{x";
                             vp3 = ". Blood flies!"       ;}
    else if ( dam <= 130 ) { vp1 = "controlled";    vp2 = "{CERADICATES{x";
                             vp3 = " to bits!!"         ;}
    else                   { vp1 = "masterful";
                vp2 = "does {RUNSPEAKABLE{x things to"; vp3 = "!"         ;}


    if ( dt == TYPE_HIT )
    {
  if (ch  == victim)
  {
      sprintf( buf1, "$n fumbles and hits $melf!");
      sprintf( buf2, "You fumble and hit yourself!");
  }
  else
  {
             sprintf( buf1, "$n's %s strike %s $N%s",vp1,vp2,vp3);
             sprintf( buf2, "Your %s strike %s $N%s",vp1,vp2,vp3);
             sprintf( buf3, "$n's %s strike %s you%s",vp1,vp2,vp3);

  }
    }
    else
    {
  if ( dt >= 0 && dt < MAX_SKILL )
      attack  = skill_table[dt].noun_damage;
  else if ( dt >= TYPE_HIT
  && dt <= TYPE_HIT + MAX_DAMAGE_MESSAGE) 
      attack  = attack_table[dt - TYPE_HIT].noun;

  else
  {
      bug( "Dam_message: bad dt %d.", dt );
      dt  = TYPE_HIT;
      attack  = attack_table[0].name;
  }

  if (immune)
  {
      if (ch == victim)
      {
    sprintf(buf1,"$n is unaffected by $s own %s.",attack);
    sprintf(buf2,"Luckily, you are immune to that.");
      }
      else
      {
        sprintf(buf1,"$N is unaffected by $n's %s!",attack);
        sprintf(buf2,"$N is unaffected by your %s!",attack);
        sprintf(buf3,"$n's %s is powerless against you.",attack);
      }
  }
  else
  {
      if (ch == victim)
      {
                sprintf( buf1, "$n's %s %s %s $m%s", vp1, attack, vp2, vp3 );
                sprintf( buf2, "Your %s %s %s you%s", vp1, attack, vp2, vp3 );

      }
      else
      {
                sprintf( buf1, "$n's %s %s %s $N%s", vp1, attack, vp2, vp3 );
                sprintf( buf2, "Your %s %s %s $N%s", vp1, attack, vp2, vp3 );
                sprintf( buf3, "$n's %s %s %s you%s",vp1, attack, vp2, vp3 );

      }
  }
    }

    if (ch == victim)
    {
  act(buf1,ch,NULL,NULL,TO_ROOM,FALSE);
  if(!(IS_SET(ch->display,DISP_BRIEF_COMBAT) && dam == 0))
  act(buf2,ch,NULL,NULL,TO_CHAR,FALSE);
    }
    else
    {
      act( buf1, ch, NULL, victim, TO_NOTVICT ,FALSE);
  if(!(IS_SET(ch->display,DISP_BRIEF_COMBAT) && dam == 0))
      act( buf2, ch, NULL, victim, TO_CHAR ,FALSE);
  if(!(IS_SET(victim->display,DISP_BRIEF_COMBAT) && dam == 0))
      act( buf3, ch, NULL, victim, TO_VICT ,FALSE);
    }
    return;
}

bool is_clan_guard(CHAR_DATA *victim)
{
  if ( IS_NPC(victim) && victim->spec_fun != 0 )
  {
    if (
         victim->spec_fun == spec_lookup("spec_honor_guard")
         || victim->spec_fun == spec_lookup("spec_demise_guard")
         || victim->spec_fun == spec_lookup("spec_posse_guard")
         || victim->spec_fun == spec_lookup("spec_zealot_guard")
         || victim->spec_fun == spec_lookup("spec_warlock_guard")
       )
       return TRUE;
  }
  return FALSE;
}
bool is_safe(CHAR_DATA *ch, CHAR_DATA *victim)
{
    if ( is_clan_guard(victim) && is_clan_guard(ch) ) return TRUE;

    if (victim->in_room == NULL || ch->in_room == NULL)
       return TRUE;

    if (victim->fighting == ch || victim == ch)
       return FALSE;

    if ((!IS_NPC(ch)) && (ch->level > LEVEL_IMMORTAL))
       return FALSE;
    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return TRUE;
    }
   if (is_clan(victim) && !IS_NPC(ch) && victim->pcdata->start_time > 0 )
   {
      send_to_char("They just got here.  Leave them alone.\n\r",ch);
      return TRUE;
   }

   if (IS_SET(victim->in_room->room_flags,ROOM_NOCOMBAT))
   {
      send_to_char("No Combat in this room.\n\r",ch);
      return TRUE;
   }

   if( is_affected(victim,skill_lookup("wraithform")) )
   {
   send_to_char("They are made of spooky, wraith-like mist.\r\n",ch);
   return TRUE;
   }

   if( is_affected(ch,skill_lookup("wraithform")) )
   {
   return TRUE;
   }


    if ( victim->passenger != NULL && is_safe(ch,victim->passenger) )
       return TRUE;

    if (IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_SET(ch->mhs,MHS_HIGHLANDER)
        && !IS_NPC(victim))
    {
       send_to_char("They are a Highlander, You are not.\n\r",ch);
       return TRUE; 
    }

    if (IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER)
        && !IS_NPC(ch) && !IS_NPC(victim))
    {
       send_to_char("You are a Highlander, They are not.\n\r",ch);
       return TRUE;
    }

    if (IS_SET(ch->mhs,MHS_HIGHLANDER) && 
        IS_SET(victim->in_room->room_flags,ROOM_HOLY_GROUND))
   {
      send_to_char("This is Holy Ground Highlander!\n\r",ch);
      return TRUE;
   }

    /* Special handling for Altirin mobs -Ben */
    if ( IS_NPC(victim) && victim->invis_level )
       return TRUE;

    if ( is_clan(victim) && victim->in_room->clan &&
         victim->in_room->clan != victim->clan )
       return FALSE;

    /* You cannot be attacked if you're in your own hall */
    if ( is_clan(ch) && ch->in_room->clan &&
	 ch->in_room->clan != ch->clan )
       return TRUE;

    /* attacking a player's creature by another player */
    if ( IS_NPC(victim)
         && victim->master != NULL 
         && victim->master->fighting != ch
         && (ch->level > (victim->master->level +8))
         && is_clan(ch) && is_clan(victim->master))
       return TRUE;

    /* killing mobiles */
    if (IS_NPC(victim))
    {
       /* safe room? */
       if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
       {
          send_to_char("Not in this room.\n\r",ch);
          return TRUE;
       }

       if (victim->pIndexData->pShop != NULL)
       {
          send_to_char("The shopkeeper wouldn't like that.\n\r",ch);
          return TRUE;
       }

       /* no killing healers, trainers, etc */
       if (IS_SET(victim->act,ACT_TRAIN)
           ||  IS_SET(victim->act,ACT_PRACTICE)
           ||  IS_SET(victim->act,ACT_IS_HEALER)
           ||  IS_SET(victim->act,ACT_IS_CHANGER))
       {
          send_to_char("I don't think Mojo would approve.\n\r",ch);
          return TRUE;
       }

       if (!IS_NPC(ch) && victim->master != NULL)
       {
          /* no pets */
          if (IS_SET(victim->act,ACT_PET) 
              && (!is_clan(victim->master) || !is_clan(ch)) )
          {
             act("But $N looks so cute and cuddly...",
  	          ch,NULL,victim,TO_CHAR,FALSE);
             return TRUE;
          }

          /* no charmed creatures unless owner */
          if (IS_AFFECTED(victim,AFF_CHARM) 
      	       && ch != victim->master
     	       && (!is_clan(victim->master) || !is_clan(ch)) )
          {
             send_to_char("You don't own that monster.\n\r",ch);
             return TRUE;
          }
       }
    }
    /* killing players */
    else
    {
       /* NPC doing the killing */
       if (IS_NPC(ch))
       {
          /* safe room check */
          if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
          {
             send_to_char("Not in this room.\n\r",ch);
             return TRUE;
          }

          /* charmed mobs and pets cannot attack players while owned */
          if (IS_AFFECTED(ch,AFF_CHARM) && ch->master != NULL
              &&  ch->master->fighting != victim)
          {
             send_to_char("Players are your friends!\n\r",ch);
             stop_fighting(ch,FALSE);
             return TRUE;
          }
       }
       /* player doing the killing */
       else
       { 
          if (IS_SET(victim->act,PLR_DWEEB))
             return FALSE;

          if (!is_clan(ch))
          {
             /*send_to_char("Join a clan if you want to kill players.\n\r",ch);*/
	     send_to_char("Join a clan if you want to sit in your hall and bitch and whine on cgoss.\r\n",ch);
             return TRUE;
          }

          if (!is_clan(victim)) 
          {
             send_to_char("They aren't in a clan, leave them alone.  It's called PK for a reason.\n\r",ch);
             return TRUE;
          }

	  if(IS_SET(ch->mhs,MHS_GLADIATOR) && (gladiator_info.type == 2 || gladiator_info.type == 3) && ch->pcdata->gladiator_team == victim->pcdata->gladiator_team)
	     return TRUE;

	  if(IS_SET(ch->mhs,MHS_GLADIATOR) && IS_SET(victim->mhs,MHS_GLADIATOR))
	     return FALSE;
	  if(IS_SET(ch->mhs,MHS_HIGHLANDER) && IS_SET(victim->mhs,MHS_HIGHLANDER))
	     return FALSE;

	  if (IS_SET(ch->act,PLR_NOOUTOFRANGE) )
	  {
   
             if ((IS_SET(ch->act,PLR_KILLER) || IS_SET(ch->act,PLR_THIEF)) &&
                 ch->level+12 < victim->level) 
             {
	       send_to_char("If you want to pick on someone that big turn "
			 "off your NoOutOfRange toggle.\n\r",ch);
	       return TRUE;
             }
             else
             {
                if (victim->level > ch->level + (ch->trumps > 0 ? 10 : 8))
                {
	           send_to_char("If you want to pick on someone that big turn "
			 "off your NoOutOfRange toggle.\n\r",ch);
	           return TRUE;
                }
             }
	  }

/*        if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF))    */
/*        This change made by Ndagger, 1/23/03                                    */
       if (!IS_SET(victim->act,PLR_KILLER))
       { 
          if  ( IS_SET(victim->act,PLR_THIEF) )
	  {
             if (victim->level + 12 < ch->level &&
		 str_cmp(ch->pcdata->last_attacked_by,victim->name))
             {
                if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                   send_to_char("Pick on someone your own size.\n\r",ch);
                return TRUE;
	     }
          }
          else
          {
	     /* Victim is a Thug or Ruffian */
             if (ch->level > victim->level + (victim->trumps > 0 ? 10 : 8) &&  
		 str_cmp(ch->pcdata->last_attacked_by,victim->name))
	     {
                if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                   send_to_char("Pick on someone your own size.\n\r",ch);
                   return TRUE;
             }
          }
       }
    /* If someone not fighting the victim casts a spell at the victim then
      add the caster to the victims last attacked by, but only if the
      character is normally outside the victim's level range */
	  if (((IS_SET(ch->act,PLR_THIEF) || IS_SET(ch->act,PLR_KILLER))
		    && ch->level+12 < victim->level ) 
	       || (ch->trumps == 0 && ch->level+8 < victim->level)
	       || (ch->trumps > 0 && ch->level+10 < victim->level ) )
	       {
		victim->pcdata->last_attacked_by = str_dup(ch->name);
		victim->pcdata->last_attacked_by_timer = 15000;
	       }

	  if (victim->clan == clan_lookup("warlock") &&
	      ch->clan != clan_lookup("warlock") &&
	      !IS_SET(ch->mhs,MHS_WARLOCK_ENEMY))
	      SET_BIT(ch->mhs,MHS_WARLOCK_ENEMY);
	  if (victim->clan == clan_lookup("zealot") &&
	      ch->clan != clan_lookup("zealot") &&
	      ch->pcdata->deity == deity_lookup("almighty") &&
	      !IS_SET(ch->mhs,MHS_ZEALOT_ENEMY))
	      SET_BIT(ch->mhs,MHS_ZEALOT_ENEMY);
	  if (victim->clan == clan_lookup("posse") &&
	      ch->clan != clan_lookup("posse") &&
	      (!IS_SET(ch->act,PLR_THIEF) && 
	       !IS_SET(ch->act,PLR_KILLER) && 
               !IS_SET(ch->wiznet,PLR_RUFFIAN) && 
	       ch->trumps == 0 ) && 
	      !IS_SET(ch->mhs,MHS_POSSE_ENEMY))
	      SET_BIT(ch->mhs,MHS_POSSE_ENEMY);
          if (victim->clan == clan_lookup("honor") &&
              (ch->clan == clan_lookup("loner") ||
               ch->clan == clan_lookup("outcast")) && 
              !IS_SET(ch->mhs,MHS_HONOR_ENEMY))
             SET_BIT(ch->mhs,MHS_HONOR_ENEMY);

       }
    }
    return FALSE;
}
 
bool is_safe_steal(CHAR_DATA *ch, CHAR_DATA *victim)
{
   if (victim->in_room == NULL || ch->in_room == NULL)
      return TRUE;

   if (victim->fighting == ch || victim == ch)
      return FALSE;

   if ((!IS_NPC(ch)) && (ch->level > LEVEL_IMMORTAL))
      return FALSE;

   if (IS_SET(victim->in_room->room_flags,ROOM_NOCOMBAT))
   {
      send_to_char("No Combat in this room.\n\r",ch);
      return TRUE;
   }
   if (is_clan(victim) && !IS_NPC(ch) && victim->pcdata->start_time > 0 )
   {
      send_to_char("You can't throw them, they just got here.\n\r",ch);
      return TRUE;
   }
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
   {
      send_to_char("Easy there sparky.  You just got here.\n\r",ch);
      return TRUE;
   }

   if (victim->passenger != NULL && is_safe_steal(ch,victim->passenger) )
      return TRUE;

   if (IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER)
        && !IS_NPC(ch) && !IS_NPC(victim))
   {
      send_to_char("You are a Highlander, They are not.\n\r",ch);
      return TRUE;
   }

   if (!IS_SET(ch->mhs,MHS_HIGHLANDER) && IS_SET(victim->mhs,MHS_HIGHLANDER)
       && !IS_NPC(victim))
   {
      send_to_char("They are a Highlander, You are not.\n\r",ch);
      return TRUE;
   }

    if (IS_SET(ch->mhs,MHS_HIGHLANDER) && 
        IS_SET(victim->in_room->room_flags,ROOM_HOLY_GROUND))
   {
      send_to_char("This is Holy Ground Highlander!\n\r",ch);
      return TRUE;
   }
   /* Special handling for Altirin mobs -Ben */
   if ( IS_NPC(victim) && victim->invis_level )
      return TRUE;

   if ( is_clan(victim) && victim->in_room->clan &&
        victim->in_room->clan != victim->clan )
      return FALSE;

   /* Infiltrators can steal from you while you are in your own hall */
   /* if (is_clan(ch) && ch->in_room->clan
       && ch->in_room->clan != ch->clan
       && number_percent() <= get_skill(ch,gsn_infiltrate))
      return FALSE;
    */ /* steal while in hall removed */
  
   /* stealing from a player's creature by another player */
   if ( IS_NPC(victim)
        && victim->master != NULL
        && victim->master->fighting != ch
        && (ch->level > (victim->master->level +8))
        && is_clan(ch) && is_clan(victim->master))
      return TRUE;

   /* stealing from mobiles */
   if (IS_NPC(victim))
   {

      /* safe room? */
      if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
      {
         send_to_char("Not in this room.\n\r",ch);
         return TRUE;
      }

      if (victim->pIndexData->pShop != NULL)
      {
         send_to_char("The shopkeeper wouldn't like that.\n\r",ch);
         return TRUE;
      }

      /* no killing healers, trainers, etc */
      if (IS_SET(victim->act,ACT_TRAIN)
          ||  IS_SET(victim->act,ACT_PRACTICE)
          ||  IS_SET(victim->act,ACT_IS_HEALER)
          ||  IS_SET(victim->act,ACT_IS_CHANGER))
      {
         send_to_char("I don't think Mojo would approve.\n\r",ch);
         return TRUE;
      }

      if (!IS_NPC(ch) && victim->master != NULL)
      {
         /* no pets */
         if (IS_SET(victim->act,ACT_PET)
             && (!is_clan(victim->master) || !is_clan(ch)) )
         {
            act("But $N looks so cute and cuddly...",
                ch,NULL,victim,TO_CHAR,FALSE);
            return TRUE;
         }

	 /* no charmed creatures unless owner */
         if (IS_AFFECTED(victim,AFF_CHARM)
             && ch != victim->master
             && (!is_clan(victim->master) || !is_clan(ch)) )
         {
            send_to_char("You don't own that monster.\n\r",ch);
            return TRUE;
         }

      }
   }
   /* stealing from players */
   else
   {
      /* NPC doing the stealing */
      if (IS_NPC(ch))
      {
         /* safe room check */
         if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
         {
            send_to_char("Not in this room.\n\r",ch);
            return TRUE;
         }

         /* charmed mobs and pets cannot steal from players while owned */
         if (IS_AFFECTED(ch,AFF_CHARM) && ch->master != NULL
            &&  ch->master->fighting != victim)
         {
            send_to_char("Players are your friends!\n\r",ch);
            stop_fighting(ch,FALSE);
            return TRUE;
         }
      }
      /* player doing the stealing */
      else
      {

         if (IS_SET(victim->act,PLR_DWEEB))
            return FALSE;

         if (!is_clan(ch))
         {
            send_to_char("Join a clan if you want to steal from players.\n\r",ch);
            return TRUE;
         }

         if (!is_clan(victim))
         {
            send_to_char("They aren't in a clan, leave them alone.\n\r",ch);
            return TRUE;
         }
 

         /* Can NOT Steal from Thieves who are 
	 greater or less then 12 levels from ch */

/*       if (IS_SET(victim->act,PLR_THIEF) || IS_SET(victim->act,PLR_KILLER))
         CAN, however, steal from KILLERS at any level!  Nightdagger 1/23/03            */
       if (!IS_SET(victim->act,PLR_KILLER))
       {
         if (IS_SET(victim->act,PLR_THIEF))
	 {
            if (victim->level + 12 < ch->level &&
		 str_cmp(ch->pcdata->last_attacked_by,victim->name))
            {
               if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                  send_to_char("Pick on someone your own size.\n\r",ch);
                  return TRUE;
            } 
         }
         else
         {
         /* Victim is a Thug or Ruffian */
            if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8)) && 
		 str_cmp(ch->pcdata->last_attacked_by,victim->name))
            {
               if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
	       {
                  send_to_char("Pick on someone your own size.\n\r",ch);
                  return TRUE;
               }
            }
    /* If someone not fighting the victim casts a spell at the victim then
      add the caster to the victims last attacked by, but only if the
      character is normally outside the victim's level range */
	  if (((IS_SET(ch->act,PLR_THIEF) || IS_SET(ch->act,PLR_KILLER))
		    && ch->level+12 < victim->level ) 
	       || (ch->trumps == 0 && ch->level+8 < victim->level)
	       || (ch->trumps > 0 && ch->level+10 < victim->level ) )
	       {
		victim->pcdata->last_attacked_by = str_dup(ch->name);
		victim->pcdata->last_attacked_by_timer = 15000;
	       }

	  if (victim->clan == clan_lookup("warlock") &&
	      ch->clan != clan_lookup("warlock") &&
	      !IS_SET(ch->mhs,MHS_WARLOCK_ENEMY))
	      SET_BIT(ch->mhs,MHS_WARLOCK_ENEMY);
	  if (victim->clan == clan_lookup("zealot") &&
	      ch->clan != clan_lookup("zealot") &&
	      ch->pcdata->deity == deity_lookup("almighty") &&
	      !IS_SET(ch->mhs,MHS_ZEALOT_ENEMY))
	      SET_BIT(ch->mhs,MHS_ZEALOT_ENEMY);
	  if (victim->clan == clan_lookup("posse") &&
	      ch->clan != clan_lookup("posse") &&
	      (!IS_SET(ch->act,PLR_THIEF) && 
	       !IS_SET(ch->act,PLR_KILLER) && 
               !IS_SET(ch->wiznet,PLR_RUFFIAN) && 
	       ch->trumps == 0 ) && 
	      !IS_SET(ch->mhs,MHS_POSSE_ENEMY))
	      SET_BIT(ch->mhs,MHS_POSSE_ENEMY);
          if (victim->clan == clan_lookup("honor") &&
              (ch->clan == clan_lookup("loner") ||
               ch->clan == clan_lookup("outcast")) && 
              !IS_SET(ch->mhs,MHS_HONOR_ENEMY))
             SET_BIT(ch->mhs,MHS_HONOR_ENEMY);
         }
       }
      }
   }
   return FALSE;
}

bool is_safe_spell(CHAR_DATA *ch, CHAR_DATA *victim, bool area , int sn )
{
    if (victim->in_room == NULL || ch->in_room == NULL)
       return TRUE;

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return TRUE;
    }
   if (is_clan(victim) && !IS_NPC(ch) && victim->pcdata->start_time > 0 )
   {
      send_to_char("They just got here.Leave them alone.\n\r",ch);
      return TRUE;
   }

    if (victim == ch && area)
       return TRUE;
    if (victim->fighting == ch || victim == ch)
       return FALSE;

    if (IS_IMMORTAL(ch) && ch->level > LEVEL_IMMORTAL && !area)
       return FALSE;

   if (IS_SET(victim->in_room->room_flags,ROOM_NOCOMBAT))
   {
      send_to_char("No Combat in this room.\n\r",ch);
      return TRUE;
   }
    if (victim->passenger != NULL && is_safe_spell(ch,victim->passenger,area, sn) )
       return TRUE;
    
    if (IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER)
        && !IS_NPC(ch) && !IS_NPC(victim))
    {
       send_to_char("You are a Highlander, They are not.\n\r",ch);
       return TRUE;
    }

    if (!IS_SET(ch->mhs,MHS_HIGHLANDER) && IS_SET(victim->mhs,MHS_HIGHLANDER)
	&& !IS_NPC(victim))
    {
       send_to_char("They are a Highlander, You are not.\n\r",ch);
       return TRUE;
    }
    if (IS_SET(ch->mhs,MHS_HIGHLANDER) && 
        IS_SET(victim->in_room->room_flags,ROOM_HOLY_GROUND))
   {
      send_to_char("This is Holy Ground Highlander!\n\r",ch);
      return TRUE;
   }

    if ( IS_NPC(victim) && victim->invis_level )
       return TRUE;

    if ( is_clan(victim) && victim->in_room->clan &&
	  victim->in_room->clan != victim->clan )
    {
       if( !IS_SET(victim->act,PLR_THIEF) )
       {
          send_to_char("You got caught infiltrating.\n\r",victim);
          SET_BIT(victim->act,PLR_THIEF);
       }
       return FALSE;
    }

    /*You can not be attacked if you're in your own hall
      unless it's by your fellow clanmates.
     */
    if(is_clan(ch) && is_clan(victim) &&
        ch->in_room->clan != ch->clan &&
        victim->in_room->clan == victim->clan)
       return TRUE;

    /* killing mobiles */
    if (IS_NPC(victim))
    {
       /* safe room? */
       if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
          return TRUE;

       if (victim->pIndexData->pShop != NULL)
          return TRUE;

       /* no killing healers, trainers, etc */
       if (IS_SET(victim->act,ACT_TRAIN)
           ||  IS_SET(victim->act,ACT_PRACTICE)
           ||  IS_SET(victim->act,ACT_IS_HEALER)
           ||  IS_SET(victim->act,ACT_IS_CHANGER))
          return TRUE;

       if (!IS_NPC(ch))
       {
          /* no pets */
          if (IS_SET(victim->act,ACT_PET))
             return TRUE;

          /* no charmed creatures unless owner */
          if (IS_AFFECTED(victim,AFF_CHARM) && (area || ch != victim->master))
             return TRUE;

          /* legal kill? -- cannot hit mob fighting non-group member */
          if (victim->fighting != NULL && !is_same_group(ch,victim->fighting))
             return TRUE;
       }
       else
       {
          /* area effect spells do not hit other mobs */
          if (area && !is_same_group(victim,ch->fighting))
             return TRUE;
       }
    }
    /* killing players */
    else
    {
       if (area && IS_IMMORTAL(victim) && victim->level > LEVEL_IMMORTAL)
          return TRUE;

       /* NPC doing the killing */
       if (IS_NPC(ch))
       {
          /* charmed mobs and pets cannot attack players while owned */
          if ( ((IS_AFFECTED(ch,AFF_CHARM)) & (ch->master != NULL))
                &&  (ch->master->fighting != victim) )
             return TRUE;
  
          /* safe room? */
          if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
             return TRUE;

          /* legal kill? -- mobs only hit players grouped with opponent*/
          if (ch->fighting != NULL && !is_same_group(ch->fighting,victim))
             return TRUE;
       }
       /* player doing the killing */
       else
       {
          if (IS_SET(victim->act,PLR_DWEEB))
             return FALSE;

          if (!is_clan(ch) && !IS_SET(ch->mhs,MHS_HIGHLANDER))
             return TRUE;

          if (!is_clan(victim) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
             return TRUE;

	  if( area && is_same_group(ch,victim) )
             return TRUE;

	  if(IS_SET(ch->mhs,MHS_GLADIATOR) && IS_SET(victim->mhs,MHS_GLADIATOR))
	     return FALSE;
	  if(IS_SET(ch->mhs,MHS_HIGHLANDER) && IS_SET(victim->mhs,MHS_HIGHLANDER))
	     return FALSE;

	  if (IS_SET(ch->act,PLR_NOOUTOFRANGE) && ch->level+8 < victim->level)
	  {  
	    send_to_char("If you want to pick on someone that big turn "
			 "off your NoOutOfRange toggle.\n\r",ch);
	    return TRUE;
	  }

          if (!IS_SET(victim->mhs,MHS_HIGHLANDER))
          {

/* Ndagger 1/23/03  if (IS_SET(victim->act,PLR_THIEF) || IS_SET(victim->act,PLR_KILLER)) */

           if (!IS_SET(victim->act,PLR_KILLER))
           {
             if (IS_SET(victim->act,PLR_THIEF))
	     {
                if (victim->level + 12 < ch->level &&
		 str_cmp(ch->pcdata->last_attacked_by,victim->name))
                {
                   if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                      send_to_char("Pick on someone your own size.\n\r",ch);
                   return TRUE;
		}
             }
             else
             {
	        /* Victim is a Thug or Ruffian */
	        if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8)) &&  
		 str_cmp(ch->pcdata->last_attacked_by,victim->name))
	        {
                   if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                      send_to_char("Pick on someone your own size.\n\r",ch);
                   return TRUE;
                }
             }
           }
    /* If someone not fighting the victim casts a spell at the victim then
      add the caster to the victims last attacked by, but only if the
      character is normally outside the victim's level range */
	  if (((IS_SET(ch->act,PLR_THIEF) || IS_SET(ch->act,PLR_KILLER))
		    && ch->level+12 < victim->level ) 
	       || (ch->trumps == 0 && ch->level+8 < victim->level)
	       || (ch->trumps > 0 && ch->level+10 < victim->level ) )
	       {
		victim->pcdata->last_attacked_by = str_dup(ch->name);
		victim->pcdata->last_attacked_by_timer = 15000;
	       }
        if ( sn != skill_lookup("faerie fog"))
          {
	  if (victim->clan == clan_lookup("warlock") &&
	      ch->clan != clan_lookup("warlock") &&
	      !IS_SET(ch->mhs,MHS_WARLOCK_ENEMY))
	      SET_BIT(ch->mhs,MHS_WARLOCK_ENEMY);
	  if (victim->clan == clan_lookup("zealot") &&
	      ch->clan != clan_lookup("zealot") &&
	      ch->pcdata->deity == deity_lookup("almighty") &&
	      !IS_SET(ch->mhs,MHS_ZEALOT_ENEMY))
	      SET_BIT(ch->mhs,MHS_ZEALOT_ENEMY);
	  if (victim->clan == clan_lookup("posse") &&
	      ch->clan != clan_lookup("posse") &&
	      (!IS_SET(ch->act,PLR_THIEF) && 
	       !IS_SET(ch->act,PLR_KILLER) && 
               !IS_SET(ch->wiznet,PLR_RUFFIAN) && 
	       ch->trumps == 0 ) && 
	      !IS_SET(ch->mhs,MHS_POSSE_ENEMY))
	      SET_BIT(ch->mhs,MHS_POSSE_ENEMY);
          if (victim->clan == clan_lookup("honor") &&
              (ch->clan == clan_lookup("loner") ||
               ch->clan == clan_lookup("outcast")) && 
              !IS_SET(ch->mhs,MHS_HONOR_ENEMY))
             SET_BIT(ch->mhs,MHS_HONOR_ENEMY);
          }
          }
       }
    }

    return FALSE;
}

/*
 * See if an attack justifies a KILLER flag.
 */
void check_killer( CHAR_DATA *ch, CHAR_DATA *victim )
{
    char buf[MAX_STRING_LENGTH],log_buf[MAX_STRING_LENGTH];
    /*
     * Follow charm thread to responsible character.
     * Attacking someone's charmed char is hostile!
     */

    if ( victim->passenger != NULL )
    {
	check_killer( ch, victim->passenger );
	return;
    }

    if ((!IS_NPC(ch) && !IS_NPC(victim)) && (ch != victim) && ch->pcdata) {
      ch->pcdata->quit_time = 4;
      if (victim->pcdata) victim->pcdata->quit_time = 4;
    }     

    if ( !IS_NPC(victim) && !IS_NPC(ch)
	 && is_affected(victim,gsn_sacred_guardian) && is_clan( victim )
         && ch != victim 
	 && ch->position != POS_FIGHTING && victim->position != POS_FIGHTING )
    {
	DESCRIPTOR_DATA *d;

	for ( d = descriptor_list ; d!= NULL ; d= d->next )
	{
	   if ( d->connected != CON_PLAYING ||
		!is_same_clan(d->character,victim) )
	       continue;

	   act("Your clanmate $N is being attacked!",
		d->character,NULL,victim,TO_CHAR,TRUE);
  	}
    }
     
    /*
     * No flags for defending your clan hall from an infiltrator.
     */
     if(!IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
     {
     if ( !IS_NPC(ch) && !IS_NPC(victim)
     && ch->in_room->clan == ch->clan
     && is_clan(victim) && is_clan(ch)
     && victim->in_room->clan != victim->clan
     && !IS_SET(victim->act,PLR_THIEF)
     && ch->in_room == victim->in_room )
     {
       send_to_char("You got caught infiltrating, THIEF!\n\r",victim);
       SET_BIT(victim->act,PLR_THIEF);
       sprintf( log_buf, "%s got a THIEF caught by %s infiltrating %d",
		victim->name,ch->name,victim->in_room->vnum );
        log_string( log_buf );
	  sprintf(buf,"$N got a THIEF caught infiltrating by %s",ch->name);
	  wiznet(buf,victim,NULL,WIZ_TRANSGRESSION,0,0);
     }
     }

    if (!IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       if(!IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
       {

/*    Change by Nightdagger on July 10th, 2003, lets see if this fixes it
      Old statement preseved here.
Sorry Ken, had to put it back in, life with out transgres is to much :)
we'll find another solution to it -corey */


          if ((!IS_NPC (ch) && !IS_NPC (victim)) && (ch != victim) &&
             (ch->position != POS_FIGHTING) 
	     && (victim->position != POS_FIGHTING))  
          /*taken out till we can find another solution
		if ((!IS_NPC(ch) && !IS_NPC(victim)) && (ch != victim))
	  */
	   {
              sprintf(buf,"$N is attempting to kill %s",victim->name);
              wiznet(buf,ch,NULL,WIZ_TRANSGRESSION,0,0);
              ch->pcdata->last_combat_date = current_time;
              ch->pcdata->logins_without_combat = 0;
              ch->pcdata->combats_since_last_login++;
              if(!IS_SET(ch->wiznet,PLR_RUFFIAN) && victim->trumps == 0
                 && !IS_SET(victim->wiznet,PLR_RUFFIAN) 
                 && !IS_SET(victim->act,PLR_DWEEB) 
                 && !IS_SET(victim->act,PLR_THIEF) )
              {
	
  		//COREY TAKE THIS OUT AND SEE IF IT FIXED FLAGS	
	//	if( !(ch->clan == clan_lookup("posse") 
		//      && IS_SET(victim->mhs,MHS_POSSE_ENEMY)) )
		//{
                 SET_BIT(ch->wiznet,PLR_RUFFIAN);
                 ch->pcdata->ruffT = 500;
                 sprintf( log_buf, "%s got a RUFFIAN attacking %s at %d",ch->name,
                    victim->name,ch->in_room->vnum );
                 log_string( log_buf );
                 sprintf(buf,"$N got a RUFFIAN by attacking %s",victim->name);
                 wiznet(buf,ch,NULL,WIZ_TRANSGRESSION,0,0);
		//}
              }
           }
        }
    }
    
    if ( IS_AFFECTED(victim, AFF_CHARM) && !IS_NPC(victim))
      stop_follower(victim);
      

    while ( IS_AFFECTED(victim, AFF_CHARM) && victim->master != NULL )
  victim = victim->master;

    /*
     * NPC's are fair game.
     * So are killers and thieves.
     */
    if ( IS_NPC(victim)
    ||   IS_SET(victim->act, PLR_KILLER)
    ||   IS_SET(victim->act, PLR_THIEF) 
    ||   IS_SET(victim->act, PLR_DWEEB) )
  return;

    /*
     * Charm-o-rama.
     */
    if ( IS_SET(ch->affected_by, AFF_CHARM) )
    {
  if ( ch->master == NULL )
  {
      char buf[MAX_STRING_LENGTH];

      sprintf( buf, "Check_killer: %s bad AFF_CHARM",
    IS_NPC(ch) ? ch->short_descr : ch->name );
      bug( buf, 0 );
      affect_strip( ch, gsn_charm_person );
      REMOVE_BIT( ch->affected_by, AFF_CHARM );
      return;
  }
/*
  send_to_char( "*** You are now a KILLER!! ***\n\r", ch->master );
    SET_BIT(ch->master->act, PLR_KILLER);
  stop_follower( ch );
*/
  return;
    }

    /*
     * NPC's are cool of course (as long as not charmed).
     * Hitting yourself is cool too (bleeding).
     * So is being immortal (Alander's idea).
     * And current killers stay as they are.
     */
    if ( IS_NPC(ch)
    ||   ch == victim
    ||   ch->level >= LEVEL_IMMORTAL
    ||   !is_clan(ch)
    ||   IS_SET(ch->act, PLR_KILLER) 
    ||   ( IS_SET(victim->affected_by, AFF_CHARM) && !IS_NPC(victim) )
       )
  return;

   if(ch->trumps >= 3)
	{
	 send_to_char( "*** You are now a KILLER!! ***\n\r", ch );
	 SET_BIT(ch->act, PLR_KILLER);
	 sprintf(buf,"$N got a (KILLER) attempting to murder %s",victim->name);
	 wiznet(buf,ch,NULL,WIZ_FLAGS,0,0);
	 save_char_obj( ch );
	 return;
	}
}



/*
 * Check for parry.
 */
bool check_parry( CHAR_DATA *ch, CHAR_DATA *victim, bool fSecondary )
{
    int chance;
    int hit ;
    OBJ_DATA *victim_wield; 
    OBJ_DATA *wield; 

    victim_wield= get_eq_char(victim,WEAR_WIELD);

    if (fSecondary && !IS_NPC(ch))
    {
       wield = get_eq_char(ch,WEAR_SECOND) ; 
       hit = ch->pcdata->second_hitroll;
    }
    else
    {
       wield = get_eq_char(ch,WEAR_WIELD) ; 
       hit = ch->hitroll;
    }

    if ( !IS_AWAKE(victim) )
  return FALSE;


    /* Shogun kit - awesome on defensive.
        Can flag-out parry anything 10% of the time
        */
    if (check_hai_ruki(victim) && number_percent() < 10 )
    {
    if(!IS_SET(victim->display,DISP_BRIEF_COMBAT))
    act( "You parry $n's attack.",  ch, NULL, victim, TO_VICT    ,FALSE);
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
    act( "$N parries your attack.", ch, NULL, victim, TO_CHAR    ,FALSE);
    check_improve(victim,gsn_parry,TRUE,6);
    return TRUE;
    }

  if (!IS_NPC(victim) && victim_wield != NULL && victim->size < SIZE_LARGE
  &&  IS_WEAPON_STAT(victim_wield,WEAPON_TWO_HANDS)
  &&  get_eq_char(victim,WEAR_SHIELD) != NULL)
  {
      send_to_char("You fumble your oversized weapon.\n\r",ch);
      obj_from_char( victim_wield);
      obj_to_char( victim_wield, victim );
      return FALSE;
  }

    chance = get_skill(victim,gsn_parry) / 2;
    if ( victim->class == class_lookup("druid") )
	  chance -= UMAX(1, chance / 5 );

    if ( ch->class == class_lookup("blademaster") )
	chance -= ( chance / 5 );

    chance += myrm_pen(ch, victim);

    /* Ranger bonus for terrain if victim */
    switch( terrain(victim) )
    {
    case 0:	chance -= ( chance / 5 );  	break;
    case 1:	chance += ( chance / 5 );	break;
    default:	break;
    }
    
    if ( victim_wield == NULL )
    {
  if (IS_NPC(victim) || IS_AFFECTED(victim,AFF_MORPH))
      chance /= 2;
  else
      return FALSE;
    }

    if (!can_see(ch,victim,FALSE))
  chance /= 2;

    if ( !IS_NPC(ch) && IS_SET(ch->act,PLR_WERE)  &&
	     is_affected(ch,gsn_morph) && ( ch->hit < ch->max_hit / 4 ) )
  chance /= 3;

    if ( is_enemy(ch,victim) )
  chance -= 5;

    if ( is_affected(ch,gsn_rage))
	chance -= (get_skill(ch, gsn_rage) /10);
   

   /* CON affects parry now, similar to size code for dodge 
      CON is your "stamina" in a fight. Favours large races
      compare to small races with low con AND forces people
      to train their con and/or wear con eq , a lower con
      for the victim as compared to the attacker will
      reduce the victims parry chance , a higher victim con
      improves the victims parry % */
   
  chance +=( (get_curr_stat(victim,STAT_CON) - get_curr_stat(ch,STAT_CON))*2 );

    /*If you know your attacker's weapon, you parry better */
    /* Also, if you know your vicitm's weapon, you hit more often */
    if (fSecondary)
       chance += get_weapon_skill(victim,get_weapon_sn(ch,TRUE))/10;
    else
       chance += get_weapon_skill(victim,get_weapon_sn(ch,FALSE))/10;

    chance -= get_weapon_skill(ch,get_weapon_sn(victim,FALSE))/10;

   /* Hitrolls */
   if (hit > 20)
     hit = (hit-20)/2 +20;
   if (hit > 40)
     hit = (hit - 40)/2 +40;

    chance -= hit;
    /*
    chance += get_weapon_skill(victim,get_weapon_sn(victim,FALSE))/4;
    */

    /* If the weapon is the secondary then harder to parry */
    if (fSecondary)
       chance -= 25; 

    if ( number_percent( ) >= chance + victim->level - ch->level )
  return FALSE;

    if(!IS_SET(victim->display,DISP_BRIEF_COMBAT))
    act( "You parry $n's attack.",  ch, NULL, victim, TO_VICT    ,FALSE);
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
    act( "$N parries your attack.", ch, NULL, victim, TO_CHAR    ,FALSE);
    check_improve(victim,gsn_parry,TRUE,6);
    return TRUE;
}

/*
 * Check for shield block.
 */
bool check_shield_block( CHAR_DATA *ch, CHAR_DATA *victim, bool fSecondary )
{
    OBJ_DATA *weapon, *shield;
    int chance;

    if ( !IS_AWAKE(victim) )
        return FALSE;


    chance = get_skill(victim,gsn_shield_block) / 5 + 3;
    if ( victim->class == class_lookup("druid") )
	  chance -= UMAX(1, chance / 5 );

    chance += myrm_pen(ch,victim);
    
    /* ranger bonus for terrain if victinm */
    switch( terrain(ch) )
    {
    case 0:	chance -= ( chance / 5 );	break;
    case 1:	chance += ( chance / 5 );	break;
    default:	break;
    }

    if ( ( shield = get_eq_char( victim, WEAR_SHIELD ) ) == NULL )
        return FALSE;

    if ( !IS_NPC(ch) && IS_SET(ch->act,PLR_WERE)  &&
	     is_affected(ch,gsn_morph) && ( ch->hit < ch->max_hit / 4 ) )
   	chance /= 3;

    if ( ch->class == class_lookup("blademaster") )
	chance -= ( chance / 5 );

    if (fSecondary)
       weapon = get_eq_char(ch,WEAR_SECOND) ; 
    else
       weapon = get_eq_char(ch,WEAR_WIELD) ; 

    if (  weapon != NULL &&
	   weapon->value[0] == WEAPON_WHIP )
	chance /= 2;
   
    if ( weapon && weapon->value[0] == WEAPON_FLAIL )
	return FALSE;

    if ( is_enemy(ch,victim))
	chance -= 5;

    /* If the weapon is the secondary then harder to block */
    if (fSecondary)
       chance -= 25; 

    if ( number_percent( ) >= chance + victim->level - ch->level )
        return FALSE;

    if(!IS_SET(victim->display,DISP_BRIEF_COMBAT))
    act( "You block $n's attack with your shield."
	,  ch, NULL, victim, TO_VICT, FALSE);
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
    act( "$N blocks your attack with a shield."
	, ch, NULL, victim, TO_CHAR, FALSE);
    check_improve(victim,gsn_shield_block,TRUE,6);
   
   if ( weapon && weapon->value[0] == WEAPON_AXE 
	&& !IS_SET(victim->mhs, MHS_GLADIATOR))
   {
    int split = 25;

     /* adjust for material type
     split = 100 - material_table[shield->material].toughness;
     */

     /* adjust for magic */
     if (  IS_OBJ_STAT(shield,ITEM_MAGIC) )
      split /= 3;

       if (  IS_OBJ_STAT(shield,ITEM_GLOW) )
       split = 2 * split / 3;

	       split -= ( get_skill(victim,gsn_shield_block) / 10 );

	       if ( number_percent()<split)
	       {/*splittheshield*/

		act("$N's shield splits in two!",ch,NULL,victim,TO_CHAR,FALSE); 
		act("Your shield splits in two!",ch,NULL,victim,TO_VICT,FALSE);
		   obj_from_char(shield);
			  extract_obj(shield);
		}
    }

    return TRUE;
}


/*
 * Check for scaled creatures
 */
bool check_scales( CHAR_DATA *ch, CHAR_DATA *victim , bool fSecondary)
{
    int chance;
    OBJ_DATA *weapon;

    if ( !IS_SET(race_table[victim->race].parts,PART_SCALES) )
	return FALSE;

    chance = victim->level / 2 + 5;
    chance += victim->size * 5;
    chance -= get_curr_stat( ch, STAT_STR ) * 2;
   
    if ( HAS_KIT(ch,"wyrmslayer") )
	return FALSE;

    if (fSecondary)
       weapon = get_eq_char(ch,WEAR_SECOND) ; 
    else
       weapon = get_eq_char(ch,WEAR_WIELD) ; 

    if (  weapon != NULL &&
	   IS_WEAPON_STAT( weapon, WEAPON_SHARP ) )
	   chance /= 3;

    chance = URANGE( 5, chance, 95 );

    if ( number_percent() > chance )
 	return FALSE;

    if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT) )
    act("Your attack is deflected harmlessly off $N's scales.",
	ch,NULL,victim,TO_CHAR,FALSE);
    if ( !IS_SET(victim->display,DISP_BRIEF_COMBAT) )
    act("$n's attack is deflected off your scales.",
	ch,NULL,victim,TO_VICT,FALSE);

    return TRUE;
}
   


bool check_mistform( CHAR_DATA *ch, CHAR_DATA *victim )
{
    int chance;
    AFFECT_DATA *paf;


    if ( !is_affected(victim, skill_lookup("mistform")) )
	return FALSE;

    chance = 50 + ( ( victim->level - ch->level ) * 5 );
    
    for ( paf = victim->affected ; paf != NULL ; paf = paf->next )
	if ( paf->type == skill_lookup("mistform") )
		break;

    if ( paf == NULL )
    {
        bug("check_mistform: no affect",0);
	return FALSE;
    }
    
    paf->duration = UMAX(0,paf->duration - 1);
    if (paf->duration == 0)
    {
      send_to_char(skill_table[paf->type].msg_off,victim);
      send_to_char("\n\r",victim);
	act("$n's misty form becomes more corporeal.",victim,NULL,NULL,TO_ROOM,FALSE);
      affect_remove(victim, paf, APPLY_BOTH );
	return FALSE;  /* paf is no longer valid */
    }

    chance += ( paf->duration / 2 );

    if ( number_percent() < chance )
    {
	act("Your attack passes through $N ineffectually.",
		ch,NULL,victim,TO_CHAR,FALSE);
	act("$n's attack passes ineffectually through you.",
		ch,NULL,victim,TO_VICT,FALSE);
	return TRUE;
    }

    return FALSE;
}


/*
 * Check for dodge.
 */
bool check_dodge( CHAR_DATA *ch, CHAR_DATA *victim, bool fSecondary )
{
    int chance;
    int hit ;

    if (fSecondary && !IS_NPC(ch))
       hit = ch->pcdata->second_hitroll;
    else
       hit = ch->hitroll;
    
    if ( !IS_AWAKE(victim) )
  	return FALSE;

    /* Shogun kit - awesome on defensive.
        Can flag-out dodge anything 10%o f the time
        */
    if (check_hai_ruki(victim) && number_percent() < 10 )
    {
    if(!IS_SET(victim->display,DISP_BRIEF_COMBAT))
    act( "You dodge $n's attack.", ch, NULL, victim, TO_VICT    ,FALSE);
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
    act( "$N dodges your attack.", ch, NULL, victim, TO_CHAR    ,FALSE);
    check_improve(victim,gsn_dodge,TRUE,6);
    return TRUE;
    }

    chance = get_skill(victim,gsn_dodge) / 2;
    
    if ( victim->class == class_lookup("druid") )
      chance -= UMAX( 1, (chance / 5) );

    chance += myrm_pen( ch, victim );

    /* rangers */
    switch( terrain(ch) )
    {
    case 0:		chance -= ( chance / 5 );	break;
    case 1:		chance += ( chance / 5 );	break;
    default:		break;
    }

    if ( victim->race == race_lookup("faerie") )
	chance = ( 4 * chance ) / 3;

    if ( ch->class == class_lookup("blademaster") )
	chance -= ( chance / 5 );

    if( IS_AFFECTED(victim,AFF_MORPH) )
	chance += victim->level/5;

/* adjust for dex/hitroll */
  chance += (2 * get_curr_stat(victim,STAT_DEX) / 3);
  
   if (hit > 20)
	hit = (hit-20)/2 +20;
   if (hit > 40)
	hit = (hit - 40)/2 +40;
  chance -= hit;

/* Adjust for size */
/* Smaller creatures can dodge bigger ones more easily */
    chance += ( ( ch->size - victim->size ) * 2 );

    if (is_affected(victim,gsn_blur))
  chance += 15;

    if ( number_percent() < get_skill(victim,gsn_tumbling) )
  chance += 10;

    if (!can_see(victim,ch,FALSE))
  chance /= 2;

    if ( !IS_NPC(ch) && IS_SET(ch->act,PLR_WERE)  &&
	     is_affected(ch,gsn_morph) && ( ch->hit < ch->max_hit / 4 ) )
   chance /= 3;

    if ( is_affected(victim,gsn_fumble) )
	chance -= 15;
   
    if (is_enemy(ch,victim))
     chance -= 5;

    if ( is_affected(ch,gsn_bladesong) )
	chance -= (get_skill(ch, gsn_bladesong) /10);

    /* If the weapon is the secondary then harder to dodge */
    if (fSecondary)
       chance -= 25; 

    if ( number_percent( ) >= chance + victim->level - ch->level )
    {
	if ( is_affected(victim,gsn_fumble) && number_percent() >
	    ( ( get_curr_stat(victim,STAT_DEX) * 2 ) +
              ( get_skill( victim, gsn_dodge ) / 2 ) ) )
	{
	    act("$N trips and falls while trying to dodge!",
		ch,NULL,victim,TO_CHAR,FALSE);
	    act("You trip and fall while trying to dodge!",
		ch,NULL,victim,TO_VICT,FALSE);
	    DAZE_STATE(victim,PULSE_VIOLENCE / 2);
	    victim->position = POS_RESTING;
	    victim->move = (UMAX(0,victim->move - 5));
	}
      return FALSE;
    }

    if(!IS_SET(victim->display,DISP_BRIEF_COMBAT))
    act( "You dodge $n's attack.", ch, NULL, victim, TO_VICT    ,FALSE);
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
    act( "$N dodges your attack.", ch, NULL, victim, TO_CHAR    ,FALSE);
    check_improve(victim,gsn_dodge,TRUE,6);
    return TRUE;
}

bool check_kailindo( CHAR_DATA *ch, CHAR_DATA *victim )
{
    int chance;

    if ( !IS_AWAKE(victim) || IS_NPC(victim) )
  return FALSE;

    chance = get_skill(victim,gsn_kailindo) / 3;

    if(chance <= 2) return FALSE;

    if( IS_AFFECTED(victim,AFF_MORPH) )
        chance += victim->level/5;

    if (!can_see(victim,ch,FALSE))
      chance /= 2;
    if( !IS_NPC(ch) 
    && ch->pcdata->old_class == class_lookup("thief") 
    && ch->class == class_lookup("monk") )
    {
      chance += number_range(5,15); 
    }

    if ( number_percent( ) >= chance + victim->level - ch->level )
        return FALSE;

    act( "You evade $n's attack and strike back.", ch, NULL, victim, TO_VICT    ,FALSE);
    act( "$N evades your attack and strikes back.", ch, NULL, victim, TO_CHAR    ,FALSE);
    one_hit( victim, ch, TYPE_UNDEFINED );
    check_improve(victim,gsn_kailindo,TRUE,6);
    return TRUE;
}


/*
 * Set position of a victim.
 */
void update_pos( CHAR_DATA *victim )
{
    if ( victim->hit > 0 )
    {
      if ( victim->position <= POS_STUNNED )
      victim->position = POS_STANDING;
  return;
    }

    if ( IS_NPC(victim) && victim->hit < 1 )
    {
  victim->position = POS_DEAD;
  return;
    }

    if ( victim->hit <= -11 )
    {
  victim->position = POS_DEAD;
  return;
    }

         if ( victim->hit <= -6 ) victim->position = POS_MORTAL;
    else if ( victim->hit <= -3 ) victim->position = POS_INCAP;
    else                          victim->position = POS_STUNNED;

    return;
}



/*
 * Start fights.
 */
void set_fighting( CHAR_DATA *ch, CHAR_DATA *victim )
{
    if ( ch->fighting != NULL )
    {
  bug( "Set_fighting: already fighting", 0 );
  return;
    }

    if ( IS_AFFECTED(ch, AFF_SLEEP) )
    {
  affect_strip( ch, gsn_sleep );
  affect_strip( ch, gsn_garotte );
    }

    if ( is_affected(ch, skill_lookup("garotte")))
       affect_strip (ch, skill_lookup("garotte"));

    if ( is_affected(ch, gsn_trap) )
    {
      affect_strip( ch, gsn_trap );
    }
    if ( is_affected(ch, skill_lookup("hold person") ) )
   affect_strip( ch, skill_lookup("hold person") ); 

    ch->fighting = victim;
    ch->position = POS_FIGHTING;

    return;
}



/*
 * Stop fights.
 *
 * Fix loophole where people can walk out mid-night
 *
void stop_fighting( CHAR_DATA *ch, bool fBoth )
{
    CHAR_DATA *fch;

    for ( fch = char_list; fch != NULL; fch = fch->next )
    {
  if ( (fch == ch) || ( fBoth && fch->fighting == ch ) )
  {
      fch->fighting = NULL;
      fch->position = IS_NPC(fch) ? ch->default_pos : POS_STANDING;
      update_pos( fch );
  }
    }

    return;
}
 */

void stop_fighting( CHAR_DATA *ch, bool fBoth )
{
    CHAR_DATA *fch;
    CHAR_DATA *och;

    ch->fighting = NULL;
    ch->position = IS_NPC(ch) ? ch->default_pos : POS_STANDING;
    update_pos( ch );

    if(fBoth)
    {
        for ( fch = char_list; fch != NULL; fch = fch->next )
        {
            if(fch->fighting == ch )
            {
    	        for(och = char_list; och!=NULL; och = och->next )
    		{
    		    if(och->fighting==fch&&och!=ch)
    		        break;
    	  	
    		}
    	
                if(!och)
    		{
    	            fch->fighting = NULL;
    	            fch->position = IS_NPC(fch) ? fch->default_pos : POS_STANDING;
    	            update_pos( fch );
    	        }
	        else//NEW SECTION, only one you need to copy over
	        {
  	            fch->fighting = och;
	        }

            }
        }
    }
    return;
}




/*
 * Make a corpse out of a character.
 */
void make_corpse( CHAR_DATA *ch )
{
    char buf[MAX_STRING_LENGTH];
    OBJ_DATA *corpse = NULL;
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    char *name;
//below taken out when the 'take the gear from the corpse' code removed
    //int pc_item_in_count = 0;
    
  if (!IS_SET (ch->form,FORM_INSTANT_DECAY)) {

    if ( IS_NPC(ch) )
    {
  name            = ch->short_descr;
  corpse          = create_object(get_obj_index(OBJ_VNUM_CORPSE_NPC), 0, FALSE);
  corpse->value[3] = ch->pIndexData->vnum;
  if (ch->life_timer) {
    corpse->timer = ch->life_timer/2+1;
  } else {
    corpse->timer   = number_range( 3, 6 );  /* original */
  }    

  if ( ch->gold > 0 )
  {
      obj_to_obj( create_money( ch->gold, ch->silver ), corpse );
      ch->gold = 0;
      ch->silver = 0;
  }
  corpse->cost = 0;
    }
    else
    {
  name    = ch->name;
  corpse    = create_object(get_obj_index(OBJ_VNUM_CORPSE_PC), 0, FALSE);
  corpse->timer = number_range( 25, 40 );
  corpse->value[4] = MAX_LOOT_ITEMS;
  REMOVE_BIT(ch->act,PLR_CANLOOT);
  if (!is_clan(ch))
      corpse->owner = str_dup(ch->name);
  else
  {
      corpse->owner = str_dup(ch->name);
      SET_BIT(corpse->extra_flags,ITEM_CLAN_CORPSE);
      if (ch->gold > 1 || ch->silver > 1)
      {
    obj_to_obj(create_money(ch->gold / 2, ch->silver/2), corpse);
    ch->gold -= ch->gold/2;
    ch->silver -= ch->silver/2;
      }
  }
    
    /*
   if(IS_SET(ch->act,PLR_DWEEB))
     SET_BIT(corpse->extra_flags,ITEM_DARK);
     */

  corpse->cost = 0;
    }

    corpse->level = ch->level;

    sprintf( buf, corpse->short_descr, name );
    corpse->short_descr = str_dup( buf );

    sprintf( buf, corpse->description, name );
    corpse->description = str_dup( buf );
    
  }

    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
    {
  bool floating = FALSE;

  obj_next = obj->next_content;

  /* drop corpse from inside other corpse to avoid fast full loot */
  if (IS_SET(obj->extra_flags,ITEM_CLAN_CORPSE))
  {
    obj_from_char(obj);
    obj_to_room(obj,ch->in_room);
    continue;
  }
#ifdef COREYCODE_REMOVED

  // PC's only lose a few items as long as they have sac points
  if(!IS_NPC(ch) && ch->pcdata->sac > 0)
  {
   if (IS_OBJ_STAT(obj,ITEM_ROT_DEATH)) /* get rid of it! */
   { 
    if (obj->contains != NULL)
    {
        OBJ_DATA *in, *in_next;

        act("$p evaporates,scattering its contents.",
      ch,obj,NULL,TO_ROOM,FALSE);
        for (in = obj->contains; in != NULL; in = in_next)
        {
      in_next = in->next_content;
      obj_from_obj(in);
      obj_to_room(in,ch->in_room);
        }
    }
     else
     {
      act("$p evaporates.",ch,obj,NULL,TO_ROOM,FALSE);
     }
     extract_obj(obj);
    }

    if( obj->item_type == ITEM_GEM || obj->stolen_timer > 0)
    {
      obj_from_char(obj);
      obj_to_obj( obj, corpse );
      continue;
    }
    if (obj->contains != NULL)
    {
        OBJ_DATA *in, *in_next;

        for (in = obj->contains; in != NULL; in = in_next)
        {
	  in_next = in->next_content;
	  if( in->item_type == ITEM_GEM || in->stolen_timer > 0)
	  {
		obj_from_obj(in);
		obj_to_obj( in, corpse );
		continue;
	  }
        }
     }
      
    if( pc_item_in_count < 4 
       && (obj->wear_loc == WEAR_WIELD || obj->enchanted ) )
    {
      obj_from_char(obj);
      obj_to_obj( obj, corpse );
      pc_item_in_count++;
      ch->pcdata->sac--;
    }
    else
    {
      obj_from_char(obj);
      obj_to_char(obj, ch);
    }
    continue;
  }
#endif
  if (obj->wear_loc == WEAR_FLOAT)
      floating = TRUE;
  obj_from_char( obj );
  if (obj->item_type == ITEM_POTION)
      obj->timer = number_range(500,1000);
  if (obj->item_type == ITEM_SCROLL)
      obj->timer = number_range(1000,2500);
  if (IS_SET(obj->extra_flags,ITEM_ROT_DEATH) && !floating)
  {
      obj->timer = number_range(5,10);
      REMOVE_BIT(obj->extra_flags,ITEM_ROT_DEATH);
  }
  REMOVE_BIT(obj->extra_flags,ITEM_VIS_DEATH);

  if ( IS_SET( obj->extra_flags, ITEM_INVENTORY ) )
      extract_obj( obj );
  else if (floating)
  {
      if (IS_OBJ_STAT(obj,ITEM_ROT_DEATH)) /* get rid of it! */
      { 
    if (obj->contains != NULL)
    {
        OBJ_DATA *in, *in_next;

        act("$p evaporates,scattering its contents.",
      ch,obj,NULL,TO_ROOM,FALSE);
        for (in = obj->contains; in != NULL; in = in_next)
        {
      in_next = in->next_content;
      obj_from_obj(in);
      obj_to_room(in,ch->in_room);
        }
     }
     else
        act("$p evaporates.",
      ch,obj,NULL,TO_ROOM,FALSE);
     extract_obj(obj);
      }
      else
      {
    act("$p falls to the floor.",ch,obj,NULL,TO_ROOM,FALSE);
    obj_to_room(obj,ch->in_room);
      }
  }
  else
   if (!IS_SET (ch->form,FORM_INSTANT_DECAY))
      obj_to_obj( obj, corpse );
   else
      obj_to_room (obj, ch->in_room );
  }
    
   if (!IS_SET (ch->form,FORM_INSTANT_DECAY)) 
    obj_to_room( corpse, ch->in_room );
   else
    act("The corpse crumbles into dust.",ch,NULL,NULL,TO_ROOM,FALSE);
   return;
}

void highlander_die( CHAR_DATA *ch, CHAR_DATA *victim )
{
  char buf[MAX_STRING_LENGTH];

   sprintf(buf,"%s kills %s in Highlander, %s before %d/%d/%d/%d/%d/%d with all=%d and real=%d",
	   ch->name,victim->name,ch->name,ch->pcdata->perm_hit,
	   ch->pcdata->perm_mana,ch->pcdata->perm_move,
	   ch->max_hit,ch->max_mana,ch->max_move,
	   ch->pcdata->highlander_data[ALL_KILLS], 
	   ch->pcdata->highlander_data[REAL_KILLS]); 
   log_string(buf);
   /* Add Victims Kills to ALL_KILLS */
   ch->pcdata->highlander_data[ALL_KILLS] += victim->pcdata->highlander_data[ALL_KILLS];

   /* Add Victim to ALL_KILLS and REAL_KILLS */
   ch->pcdata->highlander_data[ALL_KILLS] += 1;
   ch->pcdata->highlander_data[REAL_KILLS] += 1;

   /* Add Stats for Victims ALL_KILLS +1 for Victim */
   ch->pcdata->perm_hit += (victim->pcdata->highlander_data[ALL_KILLS] +1) * 100;
   ch->pcdata->perm_mana += (victim->pcdata->highlander_data[ALL_KILLS] +1) * 100; 
   ch->pcdata->perm_move += (victim->pcdata->highlander_data[ALL_KILLS] +1) * 100;
   ch->max_hit += (victim->pcdata->highlander_data[ALL_KILLS] +1) * 100;
   ch->max_mana += (victim->pcdata->highlander_data[ALL_KILLS] +1) * 100; 
   ch->max_move += (victim->pcdata->highlander_data[ALL_KILLS] +1) * 100;

   /* Zap the Winner with the Quickening */
   ch->hit /= 2;
   ch->mana /= 2;

   remove_highlander(ch,victim);
   sprintf(buf,"%s kills %s in Highlander, %s after %d/%d/%d/%d/%d/%d with all=%d and real=%d",
	   ch->name,victim->name,ch->name,ch->pcdata->perm_hit,
	   ch->pcdata->perm_mana,ch->pcdata->perm_move,
	   ch->max_hit,ch->max_mana,ch->max_move,
	   ch->pcdata->highlander_data[ALL_KILLS], 
	   ch->pcdata->highlander_data[REAL_KILLS]); 
   log_string(buf);

   return;
}

/*
 * Improved Death_cry contributed by Diavolo.
 */
void death_cry( CHAR_DATA *ch )
{
    ROOM_INDEX_DATA *was_in_room;
    char *msg;
    int door;
    int vnum;

    vnum = 0;
    msg = "You hear $n's death cry.";

    switch ( number_bits(4))
    {
    case  0: msg  = "$n hits the ground ... DEAD.";     break;
    case  1: 
    if (ch->material == 0)
    {
      msg  = "$n splatters blood on your armor.";   
      break;
    }
    case  2:              
  if (IS_SET(ch->parts,PART_GUTS))
  {
      msg = "$n spills $s guts all over the floor.";
      vnum = OBJ_VNUM_GUTS;
  }
  break;
    case  3: 
  if (IS_SET(ch->parts,PART_HEAD))
  {
      msg  = "$n's severed head plops on the ground.";
      vnum = OBJ_VNUM_SEVERED_HEAD;       
  }
  break;
    case  4: 
  if (IS_SET(ch->parts,PART_HEART))
  {
      msg  = "$n's heart is torn from $s chest.";
      vnum = OBJ_VNUM_TORN_HEART;       
  }
  break;
    case  5: 
  if (IS_SET(ch->parts,PART_ARMS))
  {
      msg  = "$n's arm is sliced from $s dead body.";
      vnum = OBJ_VNUM_SLICED_ARM;       
  }
  break;
    case  6: 
  if (IS_SET(ch->parts,PART_LEGS))
  {
      msg  = "$n's leg is sliced from $s dead body.";
      vnum = OBJ_VNUM_SLICED_LEG;       
  }
  break;
    case 7:
  if (IS_SET(ch->parts,PART_BRAINS))
  {
      msg = "$n's head is shattered, and $s brains splash all over you.";
      vnum = OBJ_VNUM_BRAINS;
  }
    }

    if(IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
      msg  = "$n's severed head plops on the ground.";
      vnum = OBJ_VNUM_SEVERED_HEAD;       
    }

    act( msg, ch, NULL, NULL, TO_ROOM ,FALSE);

    if ( vnum != 0 )
    {
  char buf[MAX_STRING_LENGTH];
  OBJ_DATA *obj;
  char *name;

  name    = IS_NPC(ch) ? ch->short_descr : ch->name;
  obj   = create_object( get_obj_index( vnum ), 0, FALSE );
  obj->timer  = number_range( 4, 7 );

  sprintf( buf, obj->short_descr, name );
  /*free_string( obj->short_descr );*/
  obj->short_descr = str_dup( buf );

  sprintf( buf, obj->description, name );
  /*free_string( obj->description );*/
  obj->description = str_dup( buf );

  if (obj->item_type == ITEM_FOOD)
  {
      if (IS_SET(ch->form,FORM_POISON))
    obj->value[3] = 1;
      else if (!IS_SET(ch->form,FORM_EDIBLE))
    obj->item_type = ITEM_TRASH;
  }

   /* The vnum i s aved on the item */
  obj->value[2] = (IS_NPC(ch) ? ch->pIndexData->vnum : 0 );

  obj_to_room( obj, ch->in_room );
    }

    if ( IS_NPC(ch) )
  msg = "You hear something's death cry.";
    else
  msg = "You hear someone's death cry.";

    was_in_room = ch->in_room;
    for ( door = 0; door <= 5; door++ )
    {
  EXIT_DATA *pexit;

  if ( ( pexit = was_in_room->exit[door] ) != NULL
  &&   pexit->u1.to_room != NULL
  &&   pexit->u1.to_room != was_in_room )
  {
      ch->in_room = pexit->u1.to_room;
      act( msg, ch, NULL, NULL, TO_ROOM ,FALSE);
  }
    }

    ch->in_room = was_in_room;

    return;
}



void raw_kill( CHAR_DATA *victim, CHAR_DATA *ch )
{
    CHAR_DATA *gch,*gch_next;
    char buf[MAX_STRING_LENGTH];
    int i;

    stop_fighting( victim, TRUE );
    death_cry( victim );

    if ( is_affected(victim,gsn_wound_transfer) )
    for ( gch = char_list ;
	  gch != NULL ;
	  gch = gch_next )
   {
	gch_next = gch->next;

	if ( gch->leader == victim )
	{
  sprintf(buf, "Your soul shatters with your link to %s.",victim->name);
  send_to_char(buf,gch);
  /* one more to avoid recursive crap */
  if ( is_affected( gch, gsn_wound_transfer ) ) /*strip it */
      affect_strip( gch, gsn_wound_transfer );
  raw_kill(gch,ch);
	}
    }

    if ( IS_NPC(victim) )
    {
  make_corpse (victim);
  victim->pIndexData->killed++;
  kill_table[URANGE(0, victim->level, MAX_LEVEL-1)].killed++;
  extract_char( victim, TRUE );
  return;
    }
    
  if (!IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))
  {
     if (IS_SET (victim->in_room->room_flags,ROOM_NODIE)
         || (ch->clan == clan_lookup("smurf") 
             || victim->clan == clan_lookup("smurf")))
     {
        act("$n disintegrates into dust.",victim,NULL,NULL,TO_ROOM,FALSE);
        char_from_room (victim);
        clear_mount( victim );
	if(IS_SET(victim->mhs,MHS_GLADIATOR) &&
	   (gladiator_info.type == 2 || gladiator_info.type == 3))
	{
           if(victim->pcdata->gladiator_team == 1)
              char_to_room(victim,get_room_index(ROOM_VNUM_TEAM_GLADIATOR));
           else
              char_to_room(victim,get_room_index(ROOM_VNUM_TEAM_BARBARIAN));
	}
	else
        {
           if (IS_SET(victim->act, PLR_DWEEB))
              char_to_room(victim,get_room_index(ROOM_VNUM_ALTAR));
           else
              char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
        }
     } 
     else 
     {
        if (IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
        {
           highlander_die( ch,victim );
           char_from_room(victim);
           clear_mount( victim );
           if (!is_clan(victim))
              char_to_room(victim,get_room_index(clan_table[0].hall));
           else
              char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
           send_to_char( "You are blasted with the {GQuickening{x!\n\r", ch);
           act("$n is blasted by the {GQuickening{x.",ch,NULL,NULL,TO_ROOM,FALSE);
        }
        else
        {	 
           make_corpse( victim );
           extract_char( victim, FALSE );
        }
     }
     while ( victim->affected )
        affect_remove( victim, victim->affected,APPLY_BOTH );

     /* victim->affected_by = victim->affected_by|race_table[victim->race].aff;*/
     victim->affected_by = race_table[victim->race].aff;

     if (IS_SET(ch->mhs, MHS_BANISH))
	REMOVE_BIT(ch->mhs, MHS_BANISH);
     for (i = 0; i < 4; i++)
        victim->armor[i]= 100;

     victim->position    = POS_RESTING;
     victim->hit         = UMAX( 1, victim->hit  );
     victim->mana        = UMIN( 20, victim->mana );
     victim->move        = UMAX( 1, victim->move );

     /*
     REMOVE_BIT(victim->act,PLR_KILLER);
     REMOVE_BIT(victim->act,PLR_THIEF);
     REMOVE_BIT(victim->act,PLR_BOUGHT_PET);
     save_char_obj( victim ); */

     return;
  }
  else
  {
     victim->position    = POS_STANDING;
     while ( victim->affected )
        affect_remove( victim, victim->affected,APPLY_BOTH );

     victim->affected_by = victim->affected_by|race_table[victim->race].aff;
     victim->hit         = victim->max_hit/8;
//COREY WITHSTAND FIX HERE
     stop_fighting(victim, TRUE);
     act("$n twitches a bit then stands up.",victim,NULL,NULL,TO_ROOM,FALSE);
     send_to_char ("A chilling wave passes over as you withstand death.\n\r",victim);
     WAIT_STATE(victim, 4);
    /* Gladiator Spectator Channel */
    if (IS_SET(victim->mhs,MHS_GLADIATOR))
    {
       sprintf(buf,"%s withstood a mighty blow from %s! He's still alive!",victim->name,ch->name);
       gladiator_talk(buf);
    }
  }
}



void group_gain( CHAR_DATA *ch, CHAR_DATA *victim )
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *gch;
    CHAR_DATA *lch;
    int xp;
    int members;
    int group_levels;

    /*
     * Monsters don't get kill xp's or alignment changes.
     * P-killing doesn't help either.
     * Dying of mortal wounds or poison doesn't give xp to anyone!
     */
    if ( victim == ch || 
	(IS_NPC(victim) && victim->pIndexData->vnum == MOB_VNUM_MIRROR_IMAGE )
       )
  return;
    
    members = 0;
    group_levels = 0;
    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
    {
  if ( is_same_group( gch, ch ) )
       {
      members++;
      if (!IS_NPC(gch)) 
	 {
	  group_levels += gch->level-(gch->level/7);
  	 }
      else
	 {
	  if (gch->level >= 6)
	   {
	    group_levels += (gch->level *3)/2;
	   }
	  else
	   {
	    group_levels += 6;
	   }
	 }
	}
    }

    if ( members == 0 )
    {
  bug( "Group_gain: members.", members );
  members = 1;
  group_levels = ch->level ;
    }

    lch = (ch->leader != NULL) ? ch->leader : ch;

    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
    {
  OBJ_DATA *obj;
  OBJ_DATA *obj_next;

  if ( !is_same_group( gch, ch ) || IS_NPC(gch))
      continue;

  xp = xp_compute( gch, victim, group_levels );
  sprintf( buf, "You receive {G%d{x experience points.\n\r", xp );
  send_to_char( buf, gch );
  gain_exp( gch, xp );

  for ( obj = gch->carrying; obj != NULL; obj = obj_next )
  {
      obj_next = obj->next_content;
      if ( obj->wear_loc == WEAR_NONE )
    continue;

      if ( ( IS_OBJ_STAT(obj, ITEM_ANTI_EVIL)    && IS_EVIL(gch)    )
      ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_GOOD)    && IS_GOOD(gch)    )
      ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(gch) ) )
      {
    act( "You are zapped by $p.", gch, obj, NULL, TO_CHAR ,FALSE);
    act( "$n is zapped by $p.",   gch, obj, NULL, TO_ROOM ,FALSE);
    obj_from_char( obj );
    obj_to_room( obj, gch->in_room );
      }
  }
    }

    return;
}



/*
 * Compute xp for a kill.
 * Also adjust alignment of killer.
 * Edit this function to change xp computations.
 */
int xp_compute( CHAR_DATA *gch, CHAR_DATA *victim, int total_levels )
{
    int xp,base_exp;
    int align,level_range;
    int change;
    AFFECT_DATA af;
    
    /* heck if they've got debit leels */
    if ( (gch->pcdata->debit_level > 0) ||  
	(gch->exp > exp_per_level(gch,gch->pcdata->points) * (gch->level + 1)))
		return 0;
   
  if ( IS_NPC(victim) && victim->spec_fun != 0 )
  {
    if ( is_clan_guard(victim) == TRUE ) 
    {
       return 0;
    }
  }

    level_range = victim->level - gch->level;
    /* compute the base exp */
    switch (level_range)
    {
  default :   base_exp =   0;   break;
  case -8 : base_exp =   2;   break;
  case -7 : base_exp =   7;   break;
  case -6 : base_exp =   13;   break;
  case -5 : base_exp =   20;   break;
  case -4 : base_exp =  26;   break;
  case -3 : base_exp =  40;   break;
  case -2 : base_exp =  60;   break;
  case -1 : base_exp =  80;   break;
  case  0 : base_exp =  100;   break;
  case  1 : base_exp =  140;   break;
  case  2 : base_exp =  180;   break;
  case  3 : base_exp = 220;   break;
  case  4 : base_exp = 280;   break;
  case  5 : base_exp = 320;   break;
    } 
    
    if (level_range > 5)
  base_exp = 320 + 30 * (level_range - 5);

    if (!IS_NPC(victim) && IS_SET(victim->act,PLR_DWEEB))
  base_exp = 0;

    /* do alignment computations */
   
    align = victim->alignment - gch->alignment;

    /*Gladiator's alignment doesnt change */
    if (IS_SET(victim->act,ACT_NOALIGN) || IS_SET(gch->mhs,MHS_GLADIATOR)
    || is_affected(gch, skill_lookup("indulgence")) )
    {
  /* no change */
    }

    else if (align > 500) /* monster is more good than slayer */
    {
  change = (align - 500) * base_exp / 500 * gch->level/total_levels; 
  change = UMAX(1,change);
        gch->alignment = UMAX(-1000,gch->alignment - change);
    }

    else if (align < -500) /* monster is more evil than slayer */
    {
  change =  ( -1 * align - 500) * base_exp/500 * gch->level/total_levels;
  change = UMAX(1,change);
  gch->alignment = UMIN(1000,gch->alignment + change);
    }

    else /* improve this someday */
    {
  change =  gch->alignment * base_exp/500 * gch->level/total_levels;  
  gch->alignment -= change;
    }
    
    /* calculate exp multiplier */
    if (IS_SET(victim->act,ACT_NOALIGN))
  xp = base_exp;

    else if (gch->alignment > 500)  /* for goodie two shoes */
    {
  if (victim->alignment < -750)
      xp = (base_exp *4)/3;
   
    else if (victim->alignment < -500)
      xp = (base_exp * 5)/4;

    else if (victim->alignment > 750)
      xp = base_exp / 3;

    else if (victim->alignment > 500)
      xp = base_exp / 2;

    else if (victim->alignment > 250)
      xp = (base_exp * 3)/4; 


  else
      xp = base_exp;
    }

    else if (gch->alignment < -500) /* for baddies */
    {
  if (victim->alignment > 750)
      xp = (base_exp * 5)/4;
  
    else if (victim->alignment > 500)
      xp = (base_exp * 11)/10; 

    else if (victim->alignment < -750)
      xp = base_exp/2;

  else if (victim->alignment < -500)
      xp = (base_exp * 3)/4;

  else if (victim->alignment < -250)
      xp = (base_exp * 9)/10;

  else
      xp = base_exp;
    }

    else if (gch->alignment > 200)  /* a little good */
    {

  if (victim->alignment < -500)
      xp = (base_exp * 6)/5;

  else if (victim->alignment > 750)
      xp = base_exp/2;

  else if (victim->alignment > 0)
      xp = (base_exp * 3)/4; 
  
  else
      xp = base_exp;
    }

    else if (gch->alignment < -200) /* a little bad */
    {
  if (victim->alignment > 500)
      xp = (base_exp * 6)/5;
 
  else if (victim->alignment < -750)
      xp = base_exp/2;

  else if (victim->alignment < 0)
      xp = (base_exp * 3)/4;

  else
      xp = base_exp;
    }

    else /* neutral */
    {

  if (victim->alignment > 500 || victim->alignment < -500)
      xp = (base_exp * 4)/3;

  else if (victim->alignment < 200 && victim->alignment > -200)
      xp = base_exp/2;

  else
      xp = base_exp;
    }

    /* more exp at the low levels */
    if (gch->level < 11)
      xp = 15 * xp / (gch->level + 4);

    /* less at high */

    if (gch->level > 40 )
  xp =  40 * xp / (gch->level -1);


    /* reduce for playing time -
       Removed */
    
    {
  /**** compute quarter-hours per level 
  time_per_level = 4 *
       (gch->played + (int) (current_time - gch->logon))/3600
       / gch->level;  

  time_per_level = URANGE(2,time_per_level,12);
  if (gch->level < 15)  
      time_per_level = UMAX(time_per_level,(15 - gch->level));
  xp = xp * time_per_level / 12;
 *****/ 
  }
   
    /* randomize the rewards */
    xp = number_range (xp * 4/5, xp * 6/5);

    /* adjust for grouping */
    if ( total_levels > gch->level)
    xp = xp * gch->level/( UMAX(1,total_levels -4) );

    /* Adjust for WIS */
    xp = ( ( 100 + get_curr_stat(gch,STAT_WIS) ) * xp ) / 100;
 
     if ( gch->clan == clan_lookup("outcast") && (gch->pcdata->outcT > 0) )
     xp /= 2;

    xp = 100 * xp / 100; /* Gradually step this down until it's about 75 */

//making clanners who kill other clanners get a boost
    if( is_clan(gch) && (!IS_NPC(victim) && is_clan(victim)) )
    {
      xp = 1.25 * xp;
    }



/* no exp for killing the same person twice */
    if (!IS_NPC(victim))
       if (!str_cmp(gch->pcdata->last_kill,victim->name))
          xp = 0;


    /* double EXP day for the 25th of each month  
    --- Dont forget to change 'override' to TRUE in act_wiz.c   
*/
    if (xp > 0 && override)
    {
       switch( number_percent() )
       {
       case 1: 
	   do_spreward(gch,"all 1");
	   break;
       case 2:
	    act("You feel a rejuvenating rush.",
		gch,NULL,NULL,TO_CHAR,FALSE);
            gch->pcdata->skill_point_timer = 0;
	    gch->pcdata->skill_point_tracker = 0;
	    break;
       case 3:
	    act("You have been rewarded by the gods instead.",
		gch,NULL,NULL,TO_CHAR,FALSE);
            gch->skill_points += 5;
	    gch->pcdata->skill_point_tracker += 5;
	    break;
       case 4:
	    act("Boogums gives you a great big hulking Bear Hug!",
		gch,NULL,NULL,TO_CHAR,FALSE);
            xp *= 3; 
	    break;
       case 5:
	    act("This space for rent, pester Slodhian alot for details.",
		gch,NULL,NULL,TO_CHAR,FALSE);
            gch->skill_points += 10;
	    xp *= 2;
	    break;
       case 6:
	    act("A shard has fallen out of the sky and bonks you on the head.",
		gch,NULL,NULL,TO_CHAR,FALSE);
            obj_to_char(create_object(get_obj_index(OBJ_VNUM_SHARD),0,FALSE),gch);
	    break;
       case 7:
	    act("Kuno, the Blue Wombat, has given you the power to heal all.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    do_restore(gch,"all");
	    break;
       case 9:
	    act("Alagaster asks 'HOW can you have any pudding if you don't eat your meat???",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 10:
	    act("KD says Quit Killing the Diploma Beast...Damn it.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 17:
	    act("Matook smiles down upon you!",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 3;
	    break;
       case 18:
	    act("Rusty hits you with his Clue Sitck.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 19:
	    act("KallaLilly plays her fiddle to a crowd of turtles...",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 21:
	    act("*Squish* goes the Communion bug and the crowd cheers!",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 3;
            gch->gold += 100;
	    break;
       case 23:
	    xp *= 2; 
            if( gch->exp + xp > (exp_per_level(gch,gch->pcdata->points) * (gch->level+1)) && gch->level < 50 )
	    {
	       act("Nightdagger thinks you deserve an extra level!",
                   gch,NULL,NULL,TO_CHAR,FALSE);
               gch->exp += exp_per_level(gch,gch->pcdata->points);
	    }
	    break;
       case 24:
	    xp *= 4;
	    act("You are a beautiful person.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    break;
       case 25:
	    xp *= 2;
	    act("Buy scrolls from Enchantrem.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    break;
       case 26:
	    xp *= 2;
	    act("Ravenclaw says, 'I wasn't cheating!'.",
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
       case 30:
	    xp *= 3;
	    act("I'm only happy when i whiiiiiine!",
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
       case 31:
	    xp *= 5;
	    act("You heard we're going to yank all the clans right?",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    break;
       case 32:
	    xp *= 2;
	    act("I suppose you want me to say something witty... just take the double exp.",
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
       case 33:
	    xp *= 3;
	    act("BriarRose really likes color restrings..",
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
       case 35:
	    xp *= 3;
	    act("*sigh* I've run out of witty things to say.",
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
       case 36:
	    xp *= 2;
	    act("Have a drink on me.",
		 gch, NULL, NULL, TO_CHAR, FALSE);
            obj_to_char(create_object(get_obj_index(4822),0,FALSE),gch);
	    break;
       case 37:
	    xp *= 2;
            affect_strip(gch,gsn_sanctuary);
            REMOVE_BIT(gch->affected_by,AFF_SANCTUARY);
            af.where     = TO_AFFECTS;
    	    af.type      = gsn_sanctuary;
    	    af.level     = 60;
            af.duration  = 20;
            af.location  = APPLY_NONE;
            af.modifier  = 0;
            af.bitvector = AFF_SANCTUARY;
            affect_to_char( gch, &af );
	    act("Nightdagger slams the door and says 'Another one.'",
		 gch, NULL, NULL, TO_CHAR, FALSE);
            act( "$n is surrounded by a white aura.", gch, NULL, NULL, TO_ROOM ,FALSE);
            send_to_char( "You are surrounded by a white aura.\n\r", gch );
            break;
       case 38:
	    xp *= 2;
            affect_strip(gch,skill_lookup("haste"));
            REMOVE_BIT(gch->affected_by, AFF_HASTE);
   	    af.where     = TO_AFFECTS;
    	    af.type      = skill_lookup("haste");
    	    af.level     = 1;
      	    af.duration  = 30;
    	    af.location  = APPLY_DEX;
    	    af.modifier  = 5;
   	    af.bitvector = AFF_HASTE;
    	    affect_to_char( gch, &af );
	    act("BriarRose asks, 'Do you have any french fried faerie wings?'",
		 gch, NULL, NULL, TO_CHAR, FALSE);
    	    send_to_char( "You feel yourself moving more quickly.\n\r", gch );
    	    act("$n is moving more quickly.",gch,NULL,NULL,TO_ROOM,FALSE);
            break;
       default:
	    xp *= 2;
	    break;
       }
    }

    if ( gch->race == race_lookup("gargoyle") && weather_info.sunlight >= SUN_RISE 
	&& weather_info.sunlight <= SUN_SET )
    {	/* up to a 25% bonus */
	xp = (100+(gch->level/2)) * xp / 100;
    }

    if ( is_affected(gch,gsn_spirit_of_owl) )
	xp = xp * (100+get_curr_stat(gch,STAT_WIS)) / 100;

    /* Gradual XP reduction. yanked - test is over
    return 57 * xp / 100;
    */
    /*OK the XP reductioon is going back in*/
    return 90 * xp / 100;


    //return xp;
}


void dam_message( CHAR_DATA *ch, CHAR_DATA *victim,int dam,int dt,bool immune )
{
    char buf1[256], buf2[256], buf3[256];
    const char *vs;
    const char *vp;
    const char *attack;
    char punct;

    if (ch == NULL || victim == NULL)
  return;

   if ( dam ==   0 ) { vs = "{ymiss{x"; vp = "{ymisses{x";    }
    else if ( dam <=   4 ) { vs = "scratch";  vp = "scratches"; }
    else if ( dam <=   8 ) { vs = "graze";  vp = "grazes";    }
    else if ( dam <=  12 ) { vs = "hit";  vp = "hits";    }
    else if ( dam <=  16 ) { vs = "injure"; vp = "injures";   }
    else if ( dam <=  20 ) { vs = "wound";  vp = "wounds";    }
    else if ( dam <=  24 ) { vs = "maul";       vp = "mauls";   }
    else if ( dam <=  28 ) { vs = "decimate"; vp = "decimates"; }
    else if ( dam <=  32 ) { vs = "devastate";  vp = "devastates";  }
    else if ( dam <=  36 ) { vs = "maim"; vp = "maims";   }
    else if ( dam <=  40 ) { vs = "MUTILATE"; vp = "MUTILATES"; }
    else if ( dam <=  44 ) { vs = "DISEMBOWEL"; vp = "DISEMBOWELS"; }
    else if ( dam <=  48 ) { vs = "DISMEMBER";  vp = "DISMEMBERS";  }
    else if ( dam <=  52 ) { vs = "MASSACRE"; vp = "MASSACRES"; }
    else if ( dam <=  56 ) { vs = "MANGLE"; vp = "MANGLES";   }
    else if ( dam <=  60 ) { vs = "*** DEMOLISH ***";
           vp = "*** DEMOLISHES ***";     }
    else if ( dam <=  75 ) { vs = "*** DEVASTATE ***";
           vp = "*** DEVASTATES ***";     }
    else if ( dam <= 100)  { vs = "=== OBLITERATE ===";
           vp = "=== OBLITERATES ===";    }
    else if ( dam <= 125)  { vs = ">>> ANNIHILATE <<<";
           vp = ">>> ANNIHILATES <<<";    }
    else if ( dam <= 150)  { vs = "<<< ERADICATE >>>";
           vp = "<<< ERADICATES >>>";     }
    else                   { vs = "do {RUNSPEAKABLE{x things to";
           vp = "does {RUNSPEAKABLE{x things to";   }

    punct   = (dam <= 24) ? '.' : '!';

    if ( dt == TYPE_HIT )
    {
  if (ch  == victim)
  {
      sprintf( buf1, "$n %s $melf%c",vp,punct);
      sprintf( buf2, "You %s yourself%c",vs,punct);
  }
  else
  {
      sprintf( buf1, "$n %s $N%c",  vp, punct );
      sprintf( buf2, "You %s $N%c", vs, punct );
      sprintf( buf3, "$n %s you%c", vp, punct );
  }
    }
    else
    {
  if ( dt >= 0 && dt < MAX_SKILL )
      attack  = skill_table[dt].noun_damage;
  else if ( dt >= TYPE_HIT
  && dt <= TYPE_HIT + MAX_DAMAGE_MESSAGE) 
      attack  = attack_table[dt - TYPE_HIT].name;
  else
  {
      bug( "Dam_message: bad dt %d.", dt );
      dt  = TYPE_HIT;
      attack  = attack_table[0].name;
  }

  if (immune)
  {
      if (ch == victim)
      {
    sprintf(buf1,"$n is unaffected by $s own %s.",attack);
    sprintf(buf2,"Luckily, you are immune to that.");
      } 
      else
      {
        sprintf(buf1,"$N is unaffected by $n's %s!",attack);
        sprintf(buf2,"$N is unaffected by your %s!",attack);
        sprintf(buf3,"$n's %s is powerless against you.",attack);
      }
  }
  else
  {
      if (ch == victim)
      {
    sprintf( buf1, "$n's %s %s $m%c",attack,vp,punct);
    sprintf( buf2, "Your %s %s you%c",attack,vp,punct);
      }
      else
      {
        sprintf( buf1, "$n's %s %s $N%c",  attack, vp, punct );
        sprintf( buf2, "Your %s %s $N%c",  attack, vp, punct );
        sprintf( buf3, "$n's %s %s you%c", attack, vp, punct );
      }
  }
    }

    if (ch == victim)
    {
  act(buf1,ch,NULL,NULL,TO_ROOM,FALSE);
  act(buf2,ch,NULL,NULL,TO_CHAR,FALSE);
    }
    else
    {
      act( buf1, ch, NULL, victim, TO_NOTVICT ,FALSE);
      act( buf2, ch, NULL, victim, TO_CHAR ,FALSE);
      act( buf3, ch, NULL, victim, TO_VICT ,FALSE);
    }

    return;
}



/*
 * Disarm a creature.
 * Caller must check for successful attack.
 */
void disarm( CHAR_DATA *ch, CHAR_DATA *victim )
{
    OBJ_DATA *obj;

    if ( ( obj = get_eq_char( victim, WEAR_WIELD ) ) == NULL )
  return;

    if ( IS_OBJ_STAT(obj,ITEM_NOREMOVE))
    {
  act("$S weapon won't budge!",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n tries to disarm you, but your weapon won't budge!",
      ch,NULL,victim,TO_VICT,FALSE);
  act("$n tries to disarm $N, but fails.",ch,NULL,victim,TO_NOTVICT,FALSE);
  return;
    }

     /* Blademasters */
    if ( number_percent() < ( get_skill(ch,gsn_disarm) / 10 )
         && !IS_OBJ_STAT(obj,ITEM_NODROP) &&
	 ch->class == class_lookup("blademaster") 
	 && (!IS_NPC(ch) && !IS_SET(ch->mhs,MHS_GLADIATOR)))
    {
       act("$n {GDISARMS{x you, and sends your weapon into $s own hands!",
	ch,NULL,victim,TO_VICT ,FALSE);
       act("You disarm $N and send $S weapon into your own hands!",
	ch,NULL,victim,TO_CHAR,FALSE);
       act("$n disarms $N and catches the weapon!",ch,NULL,victim,TO_NOTVICT,FALSE);
       obj_from_char( obj );
       obj_to_char( obj, ch ); 

       /* Primary has been disarmed move Secondary to Primary */
       /* moved to handler.c
       if ((obj = get_eq_char(victim,WEAR_SECOND)) != NULL)
       {
	  obj_from_char( obj );
	  obj_to_char( obj, victim);
	  equip_char( victim, obj, WEAR_WIELD );
       }
       */
    }
    else
    {
    act( "$n {GDISARMS{x you and sends your weapon flying!", 
   ch, NULL, victim, TO_VICT    ,FALSE);
    act( "You disarm $N!",  ch, NULL, victim, TO_CHAR    ,FALSE);
    act( "$n disarms $N!",  ch, NULL, victim, TO_NOTVICT ,FALSE);

    obj_from_char( obj );
    if ( IS_OBJ_STAT(obj,ITEM_NODROP) || IS_OBJ_STAT(obj,ITEM_INVENTORY)
	 || (!IS_NPC(victim) && IS_SET(victim->mhs,MHS_GLADIATOR)))
  obj_to_char( obj, victim );
    else
    {
  obj_to_room( obj, victim->in_room );
  obj->stolen_timer += 10 * number_fuzzy(5);
  if (IS_NPC(victim) && victim->wait == 0 && can_see_obj(victim,obj))
      get_obj(victim,obj,NULL);
    }

       /* Primary has been disarmed move Secondary to Primary */
       /* moved to handler.c
       if ((obj = get_eq_char(victim,WEAR_SECOND)) != NULL)
       {
          obj_from_char( obj );
          obj_to_char( obj, victim);
	  equip_char( victim, obj, WEAR_WIELD );
       }
       */
    }

    return;
}

void do_dae_tok( CHAR_DATA *ch, char *argument )
{
    int skill;
    AFFECT_DATA af;

    if( ch->race != race_lookup("yinn") )
	return;

    if ( is_affected(ch,gsn_dae_tok) )
    {
	send_to_char("You already did that.\n\r",ch);
	return;
    }

    if ( ch->move < 10 )
    {
	send_to_char("You must rest.\n\r",ch);
	return;
     }

     ch->move -= apply_chi(ch,10 );
     
     WAIT_STATE(ch,skill_table[gsn_dae_tok].beats);

    if ( number_percent() > ( skill = get_skill(ch,gsn_dae_tok) ) )
    {
	check_improve(ch,gsn_dae_tok,FALSE,2); 
	send_to_char("You failed.\n\r",ch);
	return;
    }
 
    check_improve(ch,gsn_dae_tok,TRUE,4);
    af.where		= TO_AFFECTS;
    af.type		= gsn_dae_tok;
    af.level		= ch->level;
    af.duration		= skill / 8;
    af.modifier		= skill / 20;
    af.location		= APPLY_HITROLL;
    af.bitvector	= 0;
    affect_to_char(ch,&af);

     af.location		= APPLY_DAMROLL;
     affect_to_char(ch,&af);

     send_to_char("You put yourself into a state of combat readiness.\n\r",ch);
     act("$n quietly utters a yinnish mantra.",ch,NULL,NULL,TO_ROOM,FALSE);
     return;
}

void do_berserk( CHAR_DATA *ch, char *argument)
{
    char buf[MAX_STRING_LENGTH];
    int chance, hp_percent;

    if ((chance = get_skill(ch,gsn_berserk)) == 0
    ||  (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BERSERK))
    ||  (!IS_NPC(ch)
    &&   ch->level < skill_level(ch,gsn_berserk)))
    {
  send_to_char("You turn red in the face, but nothing happens.\n\r",ch);
  return;
    }

    //if (IS_AFFECTED(ch,AFF_BERSERK) || is_affected(ch,gsn_berserk)
    if (is_affected(ch,gsn_berserk)
    || ( is_affected(ch,skill_lookup("frenzy")) &&
	 ch->race != race_lookup("dwarf") ) ) 
    {
  send_to_char("You get a little madder.\n\r",ch);
  return;
    }

    if (IS_AFFECTED(ch,AFF_CALM))
    {
  send_to_char("You're feeling too mellow to berserk.\n\r",ch);
  return;
    }

    if (ch->mana < 50)
    {
  send_to_char("You can't get up enough energy.\n\r",ch);
  return;
    }

    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       sprintf(buf,"%s goes berserk! The crowd goes wild!",ch->name);
       gladiator_talk(buf);
    }

    /* modifiers */

    /* fighting */
    if (ch->position == POS_FIGHTING)
  chance += 10;

    /* damage -- below 50% of hp helps, above hurts */
    hp_percent = 100 * ch->hit/ch->max_hit;
    chance += 25 - hp_percent/2;

    if (number_percent() < chance)
    {
  AFFECT_DATA af;

  WAIT_STATE(ch,PULSE_VIOLENCE);
  ch->mana -= 50;
  ch->move *= 5;
  ch->move /= UMAX(6,apply_chi(ch,10));

  /* heal a little damage */
  ch->hit += ch->level * 2;
  ch->hit = UMIN(ch->hit,ch->max_hit);

  send_to_char("Your pulse races as you are consumed by rage!\n\r",ch);
  act("$n gets a wild look in $s eyes.",ch,NULL,NULL,TO_ROOM,FALSE);
  check_improve(ch,gsn_berserk,TRUE,2);

  af.where  = TO_AFFECTS;
  af.type   = gsn_berserk;
  af.level  = ch->level;
  af.duration = number_fuzzy(ch->level / 8);
  af.modifier = UMAX(1, ch->level/5);

  if ( !IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("warrior") &&
	ch->class != class_lookup("berzerker")))
	af.modifier = UMAX(1,ch->level/7);

  if ( !IS_NPC(ch) && ( ch->pcdata->old_class == class_lookup("warrior") &&
	ch->class != class_lookup("berzerker")))
	af.modifier = UMAX(1,ch->level/5);

  if ( !IS_NPC(ch) && ( ch->class == class_lookup("berzerker")))
	af.modifier = UMAX(1,ch->level/4 + 1);
  

  af.bitvector  = AFF_BERSERK;

  af.location = APPLY_HITROLL;
  affect_to_char(ch,&af);

  af.location = APPLY_DAMROLL;
  affect_to_char(ch,&af);

  af.modifier = UMAX(10,10 * (ch->level/5));
  af.location = APPLY_AC;
  affect_to_char(ch,&af);
    }

    else
    {
  WAIT_STATE(ch,2 * PULSE_VIOLENCE);
  ch->mana -= 25;
  ch->move *= 5;
  ch->move /= UMAX(6,apply_chi(ch,10));

  send_to_char("Your pulse speeds up, but nothing happens.\n\r",ch);
  check_improve(ch,gsn_berserk,FALSE,2);
    }
}

void do_grenade( CHAR_DATA *ch, char *argument )
{
    int dam, chance;
    char arg[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *grenade;
    int iMiss;
    argument = one_argument( argument, arg );
    one_argument( argument, arg2 );

    if ( arg[0] == '\0' || argument[0] == '\0' )
    {
	send_to_char("Syntax: grenade <item> <victim>\n\r",ch);
	return;
    }

    if ( ( victim = get_char_room(ch,arg2) ) == NULL  && str_cmp(arg2,"ground"))
    {
	send_to_char("Nobody here by that name.\n\r",ch);
	return;
    }

    if ( is_safe(ch,victim) )
    {
	send_to_char("Go play with someone else, they aren't worth your time.\n\r",ch);
	return;
    }

    if ( IS_NPC(victim) && victim->fighting != NULL &&
	  !is_same_group(ch,victim->fighting))
    {
	send_to_char("No kill stealing, dammit.\n\r",ch);
	return;
    }

    if ( IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
    {
	act("But $N is your friend!",ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }

    if ( ( grenade = get_obj_carry( ch, arg ) ) == NULL )
    {
	send_to_char("You aren't carrying that.\n\r",ch);
	return;
    }

    if ( grenade->item_type != ITEM_GRENADE )
    {
       send_to_char("That isn't a grenade weapon.\n\r",ch);
       return;
    }

    check_killer( ch, victim );

    dam = dice( grenade->value[0], grenade->value[1] );
    chance = 100 - ( get_curr_stat( victim, STAT_DEX ) * 3 );
    chance += ( victim->level - ch->level ) * 5;
    chance += ( !can_see(victim,ch,FALSE) ) ? 15 : 0;
    chance *= ( IS_AWAKE(victim) ) ? 1 : 2;

    /* Miss */
    if ( number_percent() < chance )
    {
	act("$n lobs $p at $N, but misses.",ch,grenade,victim,TO_NOTVICT,FALSE);
	act("You lob $p at $N but miss.",ch,grenade,victim,TO_CHAR,FALSE);
	act("$n lobs $p at you, but misses.",ch,grenade,victim,TO_VICT,FALSE);
	/* Add handling for spaslh here */
	iMiss = TARGET_ROOM;
	obj_from_char( grenade );
	extract_obj( grenade );
    }
    else
    {
	act("You hit $N with $p!",ch,grenade,victim,TO_CHAR,FALSE);
	act("$n hits you with $p!",ch,grenade,victim,TO_VICT,FALSE);
	act("$n hits $N with $p!",ch,grenade,victim,TO_NOTVICT,FALSE);
	obj_from_char( grenade );
	extract_obj( grenade );
	damage(ch,victim,dam,grenade->value[4]+TYPE_HIT,attack_table[grenade->value[4]].damage,TRUE,FALSE);
	/* add handling for special effects here */
	iMiss = TARGET_CHAR;
    }
    /* special affects, based on damage type, hit either the character
       if the grenade hits the target, or the room, if grenade misses */
    switch ( attack_table[grenade->value[4]].damage )
    {
      case DAM_COLD:
         cold_effect(victim, grenade->value[1],dam,iMiss);
	 break;
      case DAM_FIRE:
	 fire_effect(victim, grenade->value[1],dam,iMiss);
	 break;
      case DAM_ACID:
	 acid_effect(victim,grenade->value[1],dam,iMiss);
	 break;
      case DAM_LIGHTNING:
	 shock_effect(victim,grenade->value[1],dam,iMiss);
	 break;
    }
    WAIT_STATE( ch, 6  );
    return;
}











void do_throw( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    int chance;

    one_argument(argument,arg);

    if ( (chance = get_skill(ch,gsn_throw)) == 0
    ||   (!IS_NPC(ch)
    &&    ch->level < skill_level(ch,gsn_throw)))
    {
  send_to_char("Throw? What? Huh?\n\r",ch);
  return;
    }
    if (is_mounted(ch) )
    {
    send_to_char("So, you're going to get off your horse and throw them?\r\n",ch);
    return;
    }

    if (arg[0] == '\0')
    {
  victim = ch->fighting;
  if (victim == NULL)
  {
      send_to_char("But you aren't fighting anyone!\n\r",ch);
      return;
  }
    }
    
    else if ((victim = get_char_room(ch,arg)) == NULL)
    {
  send_to_char("They aren't here.\n\r",ch);
  return;
    }

   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
   {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
   }
   if (is_clan(victim) && !IS_NPC(ch) && victim->pcdata->start_time > 0 )
   {
      send_to_char("You can't throw them, they just got here.\n\r",ch);
      return;
   }

    
    if (victim->position < POS_FIGHTING)
    {
  act("You'll have to let $M get back up first.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }
     
    if (victim == ch)
    {
  send_to_char("You try to flip over to everyone's delight.\n\r",ch);
  return;
    }
    
    if ( ch->move < (ch->level/15) )
    {
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

    if (is_safe(ch,victim))
  return;

    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if ( IS_NPC(victim) &&
  victim->fighting != NULL &&
  !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }
    
    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
    {
  act("But $N is your friend!",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }
    
  check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
        send_to_char("You bounce off an orb of touch.\n\r",ch);
        check_dispel( ch->level , victim, skill_lookup("orb of touch"));
        WAIT_STATE(ch,skill_table[gsn_throw].beats/2);
        return;
    }
    
    /* modifiers */

    /* size  and weight */
    chance -= victim->carry_weight / 200;

    /* stats */
    chance += get_curr_stat(ch,STAT_STR);
    chance -= (get_curr_stat(victim,STAT_DEX) * 4)/3;
    /* speed */
    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
        chance += 30;
    if (IS_SET(victim->off_flags,OFF_FAST) || IS_AFFECTED(victim,AFF_HASTE))
        chance -= 10;

    /* level */
    chance += 2*(ch->level - victim->level);

    /* race */
    /*
    if (victim->race == race_lookup("kender")) chance = (3*chance) / 4;
    */

    /* Dodge lowers the chance of landing throw, up to -33% */
    if (!IS_NPC(victim))
       chance -= (get_skill(victim,gsn_dodge)/3 );

    /* Always a slim chance it will land */
    if (chance < 0 )
       chance = 1; 
    
    if( victim->race == race_lookup("kender")
        && number_percent() <= victim->level)
    {
        act("You roll out of the way of $n's throw.",ch,NULL,victim,TO_VICT,FALSE);
        act("$N rolls to safety, you fall flat on your face.",ch,NULL,victim,TO_CHAR,FALSE);
        if (IS_AFFECTED(ch,AFF_SLOW))
                WAIT_STATE(ch,skill_table[gsn_throw].beats+12);
        else
                WAIT_STATE(ch,skill_table[gsn_throw].beats);
        return;
    }

    /* now the attack */
    if (number_percent() <= chance )
    {
    
  act("$n flips you to the ground with an amazing throw!",
    ch,NULL,victim,TO_VICT,FALSE);
  act("You flip $N with a throw and send $M to the ground!",
	ch,NULL,victim,TO_CHAR,FALSE);
  act("$n throws $N to the ground.", ch,NULL,victim,TO_NOTVICT,FALSE);
  check_improve(ch,gsn_throw,TRUE,1);

    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"%s throws %s to the ground! I bet that hurt.",ch->name,victim->name);
       gladiator_talk(buf);
    }
  DAZE_STATE(victim, 3 * PULSE_VIOLENCE);
  WAIT_STATE(ch,skill_table[gsn_throw].beats);
  victim->position = POS_RESTING;
  damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_throw,
      DAM_BASH,FALSE,FALSE);
 
    }
    else
    {
  damage(ch,victim,0,gsn_throw,DAM_BASH,FALSE,FALSE);
  act("You fall flat on your face!",
      ch,NULL,victim,TO_CHAR,FALSE);
  act("$n falls flat on $s face.",
      ch,NULL,victim,TO_NOTVICT,FALSE);
  act("You evade $n's throw, causing $m to fall flat on $s face.",
      ch,NULL,victim,TO_VICT,FALSE);
  check_improve(ch,gsn_throw,FALSE,1);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"%s tried to throw %s to the ground, %s eats dirt instead.",ch->name,victim->name,ch->name);
       gladiator_talk(buf);
    }
  ch->position = POS_RESTING;
  WAIT_STATE(ch,skill_table[gsn_bash].beats * 3/2);
    }
    
  return;
}


void do_tail_slap(   CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    int chance;

    one_argument(argument,arg);
 
    if (!IS_SET(race_table[ch->race].parts,PART_TAIL) )
    {
        send_to_char("You wiggle your butt.\n\r", ch);
        return;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }

    if (arg[0] == '\0')
    {
        victim = ch->fighting;
        if (victim == NULL)
        {
            send_to_char("You're not fighting anybody.\n\r",ch);
            return;
        }
    }
    else if ((victim = get_char_room(ch,arg)) == NULL)
    {
        send_to_char("They're not here.\n\r",ch);
        return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
        send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
        return;
    }
   if (is_clan(victim) && !IS_NPC(ch) && victim->pcdata->start_time > 0 )
   {
      send_to_char("They just got here.\n\r",ch);
      return;
   }


    if (victim == ch)
    {
        send_to_char("You chase your tail.\n\r",ch);
        return;
    }

    if (is_safe(ch,victim))
        return;

if( is_affected(victim,skill_lookup("wraithform")) )
{
send_to_char("Your tail passes right through their misty form.\r\n",ch);
return;
}

    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if ( IS_NPC(victim) && 
        victim->fighting != NULL && 
        !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }
    
    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
    {
      act("$N is your beloved master.",ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }

    check_killer(ch,victim);
      
    if( is_affected(victim,skill_lookup("orb of touch")) )                     
      {                                                                      
        send_to_char("You bounce off an orb of touch.\n\r",ch);                
        check_dispel( ch->level , victim, skill_lookup("orb of touch"));       
        WAIT_STATE(ch, 2*PULSE_VIOLENCE);                        
	return;
      }  


    /* Compute chance of landing the tail slap.
     * Tail slap is based on your size, level, and hours.
     * Defense is just a dodge, basically.
     */

    chance = ch->level + ( ch->size * 5 );
    chance += ( IS_NPC(ch) ? 0 : ( 2 * ch->level / 3 ) );
    chance += ( ch->hit / 100 );
    chance -= get_curr_stat(victim,STAT_DEX)*2;
    chance -= ( victim->size * 3 );
    
    if (victim->race == race_lookup("kender")) chance = (3*chance) / 4;

    chance = URANGE( 10, chance, 90 );

    if ( number_percent() < chance )
    {
        act("$n sends you to the ground with a tail slap!",
                ch,NULL,victim,TO_VICT,FALSE);
        act("You knock $N to the ground with your tail!",ch,NULL,victim,TO_CHAR,FALSE);
        act("$n knocks $N to the ground with $s tail!",
                ch,NULL,victim,TO_NOTVICT,FALSE);
       
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"%s trips up %s's feet , score one for the dragons.",ch->name,victim->name);
       gladiator_talk(buf);
    }
        DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
        WAIT_STATE(ch,2 * PULSE_VIOLENCE);
	damage(ch,victim,dice(ch->level /10+1,8),gsn_bash,DAM_BASH,FALSE,FALSE);
	/*
        victim->position = POS_RESTING;
	*/
    }

    else
    {
        WAIT_STATE(ch,2 * PULSE_VIOLENCE); 
	  act("You attempt to whip $N with your tail, but {ymiss{x.",ch,NULL,victim,TO_CHAR,FALSE);
	  act("$n attempts to whip you with $s tail, but {ymisses{x.",ch,NULL,victim,TO_VICT,FALSE);
	  act("$n attempts to whip $N with $s tail, but {ymisses{x.",ch,NULL,victim,TO_NOTVICT,FALSE);
	  damage(ch,victim,0,gsn_bash,DAM_BASH,FALSE,FALSE);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"Some dragons just can't use their tails well, %s failed to trip up %s.",ch->name,victim->name);
       gladiator_talk(buf);
    }
    }

    return;
}

void do_bash( CHAR_DATA *ch, char *argument )
{
    bool fGiant = FALSE;
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    int chance;
    char buf[MAX_STRING_LENGTH];

    one_argument(argument,arg);
 
    if ( (chance = get_skill(ch,gsn_bash)) == 0
    ||   (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BASH))
    ||   (!IS_NPC(ch)
    &&    ch->level < skill_level(ch,gsn_bash)))
    { 
  send_to_char("Bashing? What's that?\n\r",ch);
  return;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }
 
    if (arg[0] == '\0')
    {
  victim = ch->fighting;
  if (victim == NULL)
  {
      send_to_char("But you aren't fighting anyone!\n\r",ch);
      return;
  }
    }

    else if ((victim = get_char_room(ch,arg)) == NULL)
    {
  send_to_char("They aren't here.\n\r",ch);
  return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    {
        send_to_char("Easy there, sparky.  You just got here.  Read some notes and such.\n\r",ch);
        return;
    }
   if (is_clan(victim) && !IS_NPC(ch) && victim->pcdata->start_time > 0 )
   {
      send_to_char("They just got here.  Leave them alone.\n\r",ch);
      return;
   }


    if (victim->position < POS_FIGHTING)
    {
  act("You'll have to let $M get back up first.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    } 

    if (victim == ch)
    {
  send_to_char("You try to bash your brains out, but fail.\n\r",ch);
  return;
    }

    if ( ch->move < (ch->level/15) )
    {   
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

    if (is_safe(ch,victim))
  return;
    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("You bash your way through their misty form.\r\n",ch);
    return;
    }



    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if ( IS_NPC(victim) && 
  victim->fighting != NULL && 
  !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }

    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
    {
  act("But $N is your friend!",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

  check_killer(ch,victim);

    fGiant = ( ch->race == race_lookup("giant") || ch->race == race_lookup("ogre") );

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
	send_to_char("You bounce off an orb of touch.\n\r",ch);
	/* Giants and ogres get a +10% chance to dispel an orb of touch with bash */
	check_dispel( !fGiant ? ch->level : (ch->level + (ch->level/10)) , victim, skill_lookup("orb of touch"));
	if (IS_AFFECTED(ch,AFF_SLOW)) 
	    WAIT_STATE(ch,skill_table[gsn_bash].beats);
	else
	    WAIT_STATE(ch,skill_table[gsn_bash].beats/2);
	return;
    }

    /* modifiers */
    /* size  and weight */
    chance += ch->carry_weight / 250;
    chance -= victim->carry_weight / 200;

    if (!IS_NPC(ch) &&   ch->pcdata->old_class != class_lookup("warrior") )
    	chance -= 25;

    if (ch->size < victim->size)
  chance += (ch->size - victim->size) * 15;
    else
  chance += (ch->size - victim->size) * 10; 


    /* stats */
    chance += get_curr_stat(ch,STAT_STR);
    chance -= (get_curr_stat(victim,STAT_DEX) * 4)/3;
    /* speed */
    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
        chance += 10;
    if (IS_SET(victim->off_flags,OFF_FAST) || IS_AFFECTED(victim,AFF_HASTE))
        chance -= 30;

    /* level */
    chance += (ch->level - victim->level);

    /* magic */
    if ( is_affected(victim,gsn_fumble) )
    chance += 15;

    /* race */
    if (victim->race == race_lookup("kender")) chance = (3*chance) / 4;

    /* mountes */
    if ( is_mounted( victim ) && !is_mounted(ch) &&
	victim->riding->size >= ch->size )
	chance /= 2;
    
    if (!IS_NPC(victim) 
       && chance < get_skill(victim,gsn_dodge) && !is_mounted(victim) )
    { /*
        act("$n tries to bash you, but you dodge it.",ch,NULL,victim,TO_VICT,FALSE);
        act("$N dodges your bash, you fall flat on your face.",ch,NULL,victim,TO_CHAR,FALSE);
	if (IS_AFFECTED(ch,AFF_SLOW))
	    WAIT_STATE(ch,skill_table[gsn_bash].beats+12);
	else
            WAIT_STATE(ch,skill_table[gsn_bash].beats);
        return;*/
  chance -= 3 * (get_skill(victim,gsn_dodge) - chance);
    }

    if ( !IS_NPC(victim) &&  !is_mounted(victim) &&
	  ((get_skill(victim,gsn_tumbling) > 0  &&
	   (number_percent() + chance / 2) < get_skill(victim,gsn_tumbling))
	|| (victim->race == race_lookup("kender") 
	    && number_percent() <= victim->level)))
    {
	act("You roll out of the way of $n's bash.",ch,NULL,victim,TO_VICT,FALSE);
	act("$N rolls to safety, you fall flat on your face.",ch,NULL,victim,TO_CHAR,FALSE);
	check_improve(victim,gsn_tumbling,TRUE,3);
	if (IS_AFFECTED(ch,AFF_SLOW))
		WAIT_STATE(ch,skill_table[gsn_bash].beats+12);
	else
		WAIT_STATE(ch,skill_table[gsn_bash].beats);
	return;
    }

    /* 20% bonus based on level */
    if ( fGiant )
	chance += 20;

    /* now the attack */
    if (number_percent() < chance )
    {
        act("$n sends you sprawling with a powerful bash!", ch,NULL,victim,TO_VICT,FALSE);
        act("You slam into $N, and send $M flying!",ch,NULL,victim,TO_CHAR,FALSE);
        act("$n sends $N sprawling with a powerful bash.", ch,NULL,victim,TO_NOTVICT,FALSE);
        check_improve(ch,gsn_bash,TRUE,1);
	victim->position = POS_RESTING;
        if ( IS_AFFECTED(ch,AFF_SLOW))
                WAIT_STATE(ch,skill_table[gsn_bash].beats+12);
        else
                WAIT_STATE(ch,skill_table[gsn_bash].beats);

        /* Gladiator Spectator Channel */
        if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
        {
           sprintf(buf,"Somebody get the number of that wagon! %s just got slammed by %s.",victim->name,ch->name);
           gladiator_talk(buf);
        }

        if ( is_mounted(victim) ) /* knocked off horse */
  	{
  	    if ( number_percent() < get_skill(victim,gsn_riding/3) )
	    {
		act("You manage to stay on your mount.",victim,NULL,NULL,TO_CHAR,FALSE);
		act("$n manages to stay mounted.",victim,NULL,NULL,TO_ROOM,FALSE);
		DAZE_STATE(victim, PULSE_VIOLENCE);
                damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_bash, DAM_BASH,FALSE,TRUE);
		return;
	    }
  	    else
  	    {
  		act("$n falls from $s mount!",victim,NULL,NULL,TO_ROOM,FALSE);
  		act("You fall from your mount!",victim,NULL,NULL,TO_CHAR,FALSE);
		victim->riding->passenger = NULL;
		victim->riding = NULL;
		DAZE_STATE(victim, PULSE_VIOLENCE*4);
                damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_bash, DAM_BASH,FALSE,TRUE);
		return;
            }
        }

  	    if ( number_percent() + chance < get_skill(victim,gsn_tumbling) && get_skill(victim,gsn_tumbling) > 0 )
   	    {
     	 	act("$n rolls to $s feet!",victim,NULL,NULL,TO_ROOM,FALSE);
      	 	act("You roll to your feet.",victim,NULL,NULL,TO_CHAR,FALSE);
		victim->position = POS_STANDING;
      	 	check_improve(ch,gsn_tumbling,TRUE,3);
	  	DAZE_STATE(victim, PULSE_VIOLENCE);
                damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_bash, DAM_BASH,FALSE,TRUE);
	  	return;
  	    }

	/* Not mounted.  Now figure out delay - 2 or 3 rounds */
	/* Ogres/giants have enhanced chance to lay 'em out flat */
	/* Otherwise, compare STR versus some random chance. */
	chance = get_curr_stat(ch,STAT_STR) + ( fGiant ? 10 : 0 );
	if ( number_percent() < chance )
     	        DAZE_STATE( victim, PULSE_VIOLENCE*3 );
        else
    		DAZE_STATE( victim, PULSE_VIOLENCE*5/2 );
        damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_bash, DAM_BASH,FALSE,TRUE);

   }
    else
    {
  damage(ch,victim,0,gsn_bash,DAM_BASH,FALSE,FALSE);
  act("You fall flat on your face!",
      ch,NULL,victim,TO_CHAR,FALSE);
  act("$n falls flat on $s face.",
      ch,NULL,victim,TO_NOTVICT,FALSE);
  act("You evade $n's bash, causing $m to fall flat on $s face.",
      ch,NULL,victim,TO_VICT,FALSE);
  check_improve(ch,gsn_bash,FALSE,1);
  ch->position = POS_RESTING;
  if ( IS_AFFECTED(ch,AFF_SLOW) )
      WAIT_STATE(ch,skill_table[gsn_bash].beats * 2 );
  else
      WAIT_STATE(ch,skill_table[gsn_bash].beats * 3/2); 
    }

  return;
}

void do_dirt( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    int chance;
    char buf[MAX_STRING_LENGTH];

    one_argument(argument,arg);

    if ( (chance = get_skill(ch,gsn_dirt)) == 0
    ||   (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_KICK_DIRT))
    ||   (!IS_NPC(ch)
    &&    ch->level < skill_level(ch,gsn_dirt)))
    {
  send_to_char("You get your feet dirty.\n\r",ch);
  return;
    }

    if (arg[0] == '\0')
    {
  victim = ch->fighting;
  if (victim == NULL)
  {
      send_to_char("But you aren't in combat!\n\r",ch);
      return;
  }
    }

    else if ((victim = get_char_room(ch,arg)) == NULL)
    {
  send_to_char("They aren't here.\n\r",ch);
  return;
    }

    if (IS_AFFECTED(victim,AFF_BLIND))
    {
  act("$E's already been blinded.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if (victim == ch)
    {
  send_to_char("Very funny.\n\r",ch);
  return;
    }

    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("Your well kicked clods of dirt pass right through them.\r\n",ch);
    return;
    }
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }



    if (is_safe(ch,victim))
  return;
    if (IS_NPC(victim) &&
   victim->fighting != NULL && 
  !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }

    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
    {
  act("But $N is such a good friend!",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    /* modifiers */

    /* dexterity */
    chance += get_curr_stat(ch,STAT_DEX);
    chance -= 2 * get_curr_stat(victim,STAT_DEX);

    /* speed  */
    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
  chance += 10;
    if (IS_SET(victim->off_flags,OFF_FAST) || IS_AFFECTED(victim,AFF_HASTE))
  chance -= 25;
    if (!IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("warrior") &&
			 ch->pcdata->old_class != class_lookup("thief") ) )
  chance -= 25;

    /* level */
    chance += (ch->level - victim->level) * 2;

    /* sloppy hack to prevent false zeroes */
    if (chance % 5 == 0)
  chance += 1;

    /* terrain */

    switch(ch->in_room->sector_type)
    {
  case(SECT_INSIDE):    chance -= 20; break;
  case(SECT_CITY):    chance -= 10; break;
  case(SECT_FIELD):   chance +=  5; break;
  case(SECT_FOREST):        break;
  case(SECT_HILLS):       break;
  case(SECT_MOUNTAIN):    chance -= 10; break;
  case(SECT_WATER_SWIM):    chance  =  0; break;
  case(SECT_WATER_NOSWIM):  chance  =  0; break;
  case(SECT_AIR):     chance  =  0;   break;
  case(SECT_DESERT):    chance += 10;   break;
    }

    if (chance == 0)
    {
  send_to_char("There isn't any dirt to kick.\n\r",ch);
  return;
    }

  if ( ch->move < (ch->level/15) )
    {
	send_to_char("You're too exhausted.\n\r",ch);
	return;
    }

  ch->move -= apply_chi(ch,(ch->level/15));
  check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
	send_to_char("You bounce off an orb of touch.\n\r",ch);
	check_dispel( ch->level , victim, skill_lookup("orb of touch"));
	if (IS_AFFECTED(ch,AFF_SLOW)) 
	    WAIT_STATE(ch,skill_table[gsn_dirt].beats);
	else
	    WAIT_STATE(ch,skill_table[gsn_dirt].beats/2);
	return;
    }

    /* now the attack */
    if (number_percent() < chance)
    {
  AFFECT_DATA af;
  act("$n is blinded by the dirt in $s eyes!",victim,NULL,NULL,TO_ROOM,FALSE);
  act("$n kickes dirt in your eyes!",ch,NULL,victim,TO_VICT,FALSE);
        damage(ch,victim,number_range(2,5),gsn_dirt,DAM_NONE,FALSE,FALSE);
  send_to_char("You can't see a thing!\n\r",victim);
  check_improve(ch,gsn_dirt,TRUE,2);
  WAIT_STATE(ch,skill_table[gsn_dirt].beats);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent())
    {
       sprintf(buf,"%s throws sand in the eyes of %s. Very unsportsmanlike, but a good sport doesnt live long in the Arena",ch->name,victim->name);
       gladiator_talk(buf);
    }

  af.where  = TO_AFFECTS;
  af.type   = gsn_dirt;
  af.level  = ch->level;
  af.duration = 0;
  af.location = APPLY_HITROLL;
  af.modifier = -4;
  af.bitvector  = AFF_BLIND;

  affect_to_char(victim,&af);
    }
    else
    {
  damage(ch,victim,0,gsn_dirt,DAM_NONE,TRUE,FALSE);
  check_improve(ch,gsn_dirt,FALSE,2);
  WAIT_STATE(ch,skill_table[gsn_dirt].beats);
    }
}

void do_trip( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    int chance;
    char buf[MAX_STRING_LENGTH];

    one_argument(argument,arg);

    if ( (chance = get_skill(ch,gsn_trip)) == 0
    ||   (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_TRIP))
    ||   (!IS_NPC(ch) 
    && ch->level < skill_level(ch,gsn_trip)))
    {
  send_to_char("Tripping?  What's that?\n\r",ch);
  return;
    }

    if (arg[0] == '\0')
    {
  victim = ch->fighting;
  if (victim == NULL)
  {
      send_to_char("But you aren't fighting anyone!\n\r",ch);
      return;
  }
    }

    else if ((victim = get_char_room(ch,arg)) == NULL)
    {
  send_to_char("They aren't here.\n\r",ch);
  return;
    }

    if ( victim == ch )
    {
	send_to_char("Doh!  You're such a clutz!\n\r",ch);
	return;
	}

    if ( ch->move < (ch->level/15) )
    {   
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("They are made of mist.\r\n",ch);
    return;
    }
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }


    if (is_safe(ch,victim))
  return;
    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if (IS_NPC(victim) &&
   victim->fighting != NULL && 
  !is_same_group(ch,victim->fighting))
    {
  send_to_char("Kill stealing is not permitted.\n\r",ch);
  return;
    }

    if (victim->position < POS_FIGHTING)
    {
  act("$N is already down.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if (victim == ch)
    {
  send_to_char("You fall flat on your face!\n\r",ch);
  WAIT_STATE(ch,2 * skill_table[gsn_trip].beats);
  act("$n trips over $s own feet!",ch,NULL,NULL,TO_ROOM,FALSE);
  return;
    }

    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
    {
  act("$N is your beloved master.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

  check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
        send_to_char("You bounce off an orb of touch.\n\r",ch);
        check_dispel( ch->level , victim, skill_lookup("orb of touch"));
	WAIT_STATE(ch,skill_table[gsn_trip].beats/2);
        return;
    }

    /* modifiers */

    /* size */
    if (ch->size < victim->size)
        chance += (ch->size - victim->size) * 10;  /* bigger = harder to trip */

    if (!IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("warrior") &&
  			  ch->pcdata->old_class!=class_lookup("thief")))
   		chance -= 25;

    /* dex */
    chance += get_curr_stat(ch,STAT_DEX);
    chance -= get_curr_stat(victim,STAT_DEX) * 3 / 2;

    /* speed */
    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
  chance += 10;
    if (IS_SET(victim->off_flags,OFF_FAST) || IS_AFFECTED(victim,AFF_HASTE))
  chance -= 20;

    /* level */
    chance += (ch->level - victim->level) * 2;


    
    if (IS_AFFECTED(victim,AFF_FLYING))
    chance /= 2;

    /* now the attack */
    if (number_percent() < chance)
    {
  act("$n trips you and you go down!",ch,NULL,victim,TO_VICT,FALSE);
  act("You trip $N and $N goes down!",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n trips $N, sending $M to the ground.",ch,NULL,victim,TO_NOTVICT,FALSE);
  check_improve(ch,gsn_trip,TRUE,1);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"%s can't stay standing. Especially not with %s tripping.",victim->name,ch->name);
       gladiator_talk(buf);
    }

  DAZE_STATE(victim,2 * PULSE_VIOLENCE);
        WAIT_STATE(ch,skill_table[gsn_trip].beats);
  victim->position = POS_RESTING;
  damage(ch,victim,number_range(2, 2 +  2 * victim->size),gsn_trip,
      DAM_BASH,TRUE,FALSE);
    }
    else
    {
  damage(ch,victim,0,gsn_trip,DAM_BASH,TRUE,FALSE);
  WAIT_STATE(ch,skill_table[gsn_trip].beats*2/3);
  check_improve(ch,gsn_trip,FALSE,1);
    } 

  return;
}

void do_attack( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    if ( !HAS_KIT(ch,"brawler") ) {
	send_to_char("Just kill them!\n\r",ch);
	return;
    }

    one_argument( argument, arg );
    if ( (victim = get_char_room( ch, arg ) ) != NULL ) 
    {
       if (victim == ch->fighting)
       {
	  send_to_char("Don't try to cheat you are being watched.\n\r",ch);
	  return;
        }
    }


    kill( ch, argument, TRUE );
    return;
}

void do_kill( CHAR_DATA *ch, char *argument )
{
    kill( ch, argument, FALSE );
    return;
}

void kill( CHAR_DATA *ch, char *argument, bool canChange )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    char buf[MAX_STRING_LENGTH];

    one_argument( argument, arg );

    if ( canChange && ch->fighting == NULL )
    {
    send_to_char("You aren't in combat.\n\r",ch);
    return;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("You are made of mist, you can not attack.\n\r",ch);
    return;
    }

    if ( arg[0] == '\0' )
    {
  send_to_char( "Kill whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_room( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
       send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
       return;
    }

/*
    if ( !IS_NPC(victim) )
    {
        if ( !IS_SET(victim->act, PLR_KILLER)
        &&   !IS_SET(victim->act, PLR_THIEF) )
        {
            send_to_char( "You must MURDER a player.\n\r", ch );
            return;
        }
    }
*/
    if ( victim == ch )
    {
  send_to_char( "You hit yourself.  Ouch!\n\r", ch );
  multi_hit( ch, ch, TYPE_UNDEFINED );
  return;
    }
    if ( is_safe( ch, victim ) )
  return;
    if( is_affected(victim,skill_lookup("wraithform")) )
    {
      send_to_char("They are made of mist.  Your weapon goes right through them.\r\n",ch);
      return;
    }

    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if ( victim->fighting != NULL && 
  !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }

    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
    {
  act( "$N is your beloved master.", ch, NULL, victim, TO_CHAR ,FALSE);
  return;
    }

    if ( ch->position == POS_FIGHTING )
    {
	if ( !canChange ) {
  send_to_char( "You do the best you can!\n\r", ch );
  return;
	}
	else
	{
	    ch->fighting = victim;
	    act("$n focuses %s attack on $N",ch,NULL,victim,TO_NOTVICT,FALSE);
	    act("You focus your attack on $N",ch,NULL,victim,TO_CHAR,FALSE);
	    act("$n focuses %s attack on you!",ch,NULL,victim,TO_VICT,FALSE);
	}
    }

    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       sprintf(buf,"%s trades blows with %s.",ch->name,victim->name);
       gladiator_talk(buf);
    }
    WAIT_STATE( ch, 1 * PULSE_VIOLENCE );
    check_killer( ch, victim );
    multi_hit( ch, victim, TYPE_UNDEFINED );
    return;
}



void do_murde( CHAR_DATA *ch, char *argument )
{
    send_to_char( "If you want to MURDER, spell it out.\n\r", ch );
    return;
}



void do_murder( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;

    one_argument( argument, arg );

    if ( arg[0] == '\0' )
    {
  send_to_char( "Murder whom?\n\r", ch );
  return;
    }

    if (IS_AFFECTED(ch,AFF_CHARM) || (IS_NPC(ch) && IS_SET(ch->act,ACT_PET)))
  return;

    if ( ( victim = get_char_room( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( victim == ch )
    {
  send_to_char( "Suicide is a mortal sin.\n\r", ch );
  return;
    }

    if ( is_safe( ch, victim ) )
  return;

    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if (IS_NPC(victim) &&
   victim->fighting != NULL && 
  !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }

    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
    {
  act( "$N is your beloved master.", ch, NULL, victim, TO_CHAR ,FALSE);
  return;
    }

    if ( ch->position == POS_FIGHTING )
    {
  send_to_char( "You do the best you can!\n\r", ch );
  return;
    }

    WAIT_STATE( ch, 1 * PULSE_VIOLENCE );
    if (IS_NPC(ch))
  sprintf(buf, "Help! I am being attacked by %s!",ch->short_descr);
    else
    {
      if(IS_SET(ch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE) 
         sprintf( buf, "Help!  I am being attacked by %s!", ch->long_descr );
      else
         sprintf( buf, "Help!  I am being attacked by %s!", ch->name );
    }
    do_yell( victim, buf );
    check_killer( ch, victim );
    multi_hit( ch, victim, TYPE_UNDEFINED );
    return;
}



void do_backstab( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    char buf[MAX_STRING_LENGTH];
    int wait_mod = 0;
    int percent;

    one_argument( argument, arg );

    if ( IS_AFFECTED(ch,AFF_SLOW) )
	wait_mod = 12;

    if ( !IS_NPC(ch) && ch->pcdata->old_class != class_lookup("thief") )
	wait_mod += 12;

    if ( !IS_NPC(ch)
    &&   ch->level < skill_level(ch,gsn_backstab) )
    {
  send_to_char("You better leave assasinations to thieves.\n\r", ch );
  return;
    }

    if (arg[0] == '\0')
    {
        victim = ch->fighting;
        if (victim == NULL)
        {
            send_to_char("Backstab whom?\n\r",ch);
            return;
        }
    }
 
    else if ((victim = get_char_room(ch,arg)) == NULL)
    {
        send_to_char("They aren't here.\n\r",ch);
        return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

    if ( victim == ch )
    {
  send_to_char( "How can you sneak up on yourself?\n\r", ch );
  return;
    }

    if ( is_safe( ch, victim ) )
      return;

      if( is_affected(victim,skill_lookup("wraithform")) )
      {
      send_to_char("Your brilliant backstab passes through thier misty body.\r\n",ch);
      return;
      }


    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if (IS_NPC(victim) &&
   victim->fighting != NULL && 
  !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }

    if ( !IS_AFFECTED(ch,AFF_MORPH) 
	&& ( obj = get_eq_char( ch, WEAR_WIELD ) ) == NULL)
    {
  send_to_char( "You need to wield a weapon to backstab.\n\r", ch );
  return;
    }

    if ( ch->move < (ch->level/10) )
    {
	send_to_char("You're too exhausted.\n\r",ch);
	return;
    }
    ch->move -= apply_chi(ch,(ch->level/10));

    if ( victim->fighting != NULL && victim->hit < victim->max_hit / 2 )
    {
  send_to_char( "You can't hack a bigger hole into them.\n\r", ch );
  return;
    }

    if ( victim->hit < victim->max_hit / 3)
    {
  act( "$N is hurt and suspicious ... you can't sneak up.",
      ch, NULL, victim, TO_CHAR ,FALSE);
  return;
    }

    check_killer( ch, victim );

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
        send_to_char("You bounce off an orb of touch.\n\r",ch);
        check_dispel( ch->level , victim, skill_lookup("orb of touch"));
	WAIT_STATE( ch, skill_table[gsn_backstab].beats/2+wait_mod);
        return;
    }
    percent  = get_skill(ch,gsn_backstab);
    if(!IS_NPC(victim) && victim->class == class_lookup("rogue"))
	percent -= 25;

    if(!IS_NPC(ch) && ch->class == class_lookup("rogue"))
	percent += 25;

    if(!IS_NPC(ch) && (ch->class == class_lookup("rogue")))
	percent = URANGE(5,percent,100); 
    else
	percent = URANGE(5,percent,95);  


    WAIT_STATE( ch, skill_table[gsn_backstab].beats + wait_mod );
    if ( (number_percent( ) < percent )
    || ( get_skill(ch,gsn_backstab) >= 2 && !IS_AWAKE(victim) ) )
    {
  check_improve(ch,gsn_backstab,TRUE,1);
  multi_hit( ch, victim, gsn_backstab );
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"%s sticks a knife in %s's back, there goes that friendship.",ch->name,victim->name);
       gladiator_talk(buf);
    }
    }
    else
    {
  check_improve(ch,gsn_backstab,FALSE,1);
  damage( ch, victim, 0, gsn_backstab,DAM_NONE,TRUE,FALSE);
    }

    return;
}


void do_flee( CHAR_DATA *ch, char *argument )
{
   flee( ch, argument, FALSE );
   return;
}

void flee( CHAR_DATA *ch, char *argument, bool fWimpy )
{
    ROOM_INDEX_DATA *was_in;
    ROOM_INDEX_DATA *now_in;
    CHAR_DATA *victim;
    int attempt;
    char buf[MAX_STRING_LENGTH];

    if ( fWimpy && ch->daze )
	return;

    if ( ( victim = ch->fighting ) == NULL )
    {
        if ( ch->position == POS_FIGHTING )
            ch->position = POS_STANDING;
  send_to_char( "You aren't fighting anyone.\n\r", ch );
  return;
    }
    if ( is_affected(victim,skill_lookup("aura of cthon")) && number_percent() < 30 )
    {
    send_to_char( "THE HORROR!! THE HORROR of {RCthon{x freezes the blood in your veins!\n\r ", ch );
    send_to_char( "You feel the aura of Cthon around you.\r\n",victim );
    return;
    }
   
    if ( is_affected(ch,skill_lookup("restrain")) && number_percent() < 50 )
    {
    send_to_char( "{YPANIC!!!{x  You have been {BRESTRAINED{x!!!\n\r ", ch );
    return;
    }

    if( !fWimpy )
    {
      WAIT_STATE( ch, PULSE_PER_SECOND / 2 );
    }
    ch->move -= apply_chi( ch, 2 );

    was_in = ch->in_room;

    for ( attempt = 0; attempt < 6; attempt++ ) 
    {
  EXIT_DATA *pexit;
  int door;

  door = number_door( );
  if ( ( pexit = was_in->exit[door] ) == 0
  ||   pexit->u1.to_room == NULL
  ||   pexit->u1.to_room->clan
  ||   IS_SET(pexit->exit_info, EX_CLOSED)
  ||   number_range(0,ch->daze) != 0
  || ( IS_NPC(ch)
  &&   IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB) ) )
      continue;

  move_char( ch, door, FALSE );
  if ( ( now_in = ch->in_room ) == was_in )
      continue;

  ch->in_room = was_in;
  act( "$n has fled!", ch, NULL, NULL, TO_ROOM ,FALSE);
  ch->in_room = now_in;

  ch->move -= apply_chi( ch, 10 );

  if ( number_percent() < get_skill(ch,gsn_tumbling) || 
	HAS_KIT(ch,"ninja") )
  {
      check_improve(ch,gsn_tumbling,TRUE,3);
      act( "You flee $T!", ch, NULL, dir_name[door], TO_CHAR,FALSE);
  }
  else
	send_to_char("You flee from combat!\n\r", ch );

  if ( !IS_NPC(ch) )
  {
    if( (ch->class == 2 || HAS_KIT(ch,"acrobat") ||
	HAS_KIT(ch,"ninja") ) 
        && (number_percent() < 3*(ch->level/2) ) )
    send_to_char( "You snuck away safely.\n\r", ch);
  else
      {
      send_to_char( "You lost 10 exp.\n\r", ch); 
      gain_exp( ch, -10 );
      }
  }

  stop_fighting( ch, TRUE );
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"%s couldn't handle the pressure and runs off.",ch->name);
       gladiator_talk(buf);
    }
  return;
    }

    send_to_char( "PANIC! You couldn't escape!\n\r", ch );
    return;
}



void do_rescue( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH],arg2[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *fch;
    char buf[MAX_STRING_LENGTH];

    argument = one_argument( argument, arg );
    if ( arg[0] == '\0' )
    {
  send_to_char( "Rescue whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_room( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( victim == ch || victim->fighting == ch )
    {
  send_to_char( "What about fleeing instead?\n\r", ch );
  return;
    }

    if ( !IS_NPC(ch) && IS_NPC(victim) && !is_same_group(ch,victim))
    {
  send_to_char( "Doesn't need your help!\n\r", ch );
  return;
    }

    if ( ch->fighting == victim )
    {
  send_to_char( "Too late.\n\r", ch );
  return;
    }

    if ( ( fch = victim->fighting ) == NULL )
    {
  send_to_char( "That person is not fighting right now.\n\r", ch );
  return;
    }

    if ( IS_NPC(fch) && (!is_same_group(ch,victim) && !is_same_clan(ch,victim)))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }

    if (IS_SET(victim->mhs,MHS_NORESCUE))
    {
       send_to_char("They don't want to be rescued.\n\r",ch);
       return;
    }

    if ( is_safe(ch,fch))
    {
	send_to_char("They don't need your help!\n\r",ch);
	return;
    }

    check_killer(ch,fch);

    WAIT_STATE( ch, skill_table[gsn_rescue].beats );
    one_argument(argument,arg2);
    if ( number_percent( ) > get_skill(ch,gsn_rescue) && str_cmp(arg2,"xvx2"))
    {
  send_to_char( "You fail the rescue.\n\r", ch );
  check_improve(ch,gsn_rescue,FALSE,1);
  return;
    }

    act( "You rescue $N!",  ch, NULL, victim, TO_CHAR    ,FALSE);
    act( "$n rescues you!", ch, NULL, victim, TO_VICT    ,FALSE);
    act( "$n rescues $N!",  ch, NULL, victim, TO_NOTVICT ,FALSE);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) )
    {
       sprintf(buf,"It appears we have a hero in the Arena today! %s decides to rescue %s.",ch->name,victim->name);
       gladiator_talk(buf);
    }
    check_improve(ch,gsn_rescue,TRUE,1);

    stop_fighting( fch, FALSE );
    stop_fighting( victim, FALSE );
    stop_fighting( ch, FALSE );

    check_killer( ch, fch );
    set_fighting( ch, fch );
    set_fighting( fch, ch );
    return;
}



void do_kick( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char buf[MAX_STRING_LENGTH];

    if ( !IS_NPC(ch)
    &&   ch->level < skill_level(ch,gsn_kick))
    {
  send_to_char(
      "You better leave the martial arts to fighters.\n\r", ch );
  return;
    }

    if (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_KICK))
  return;

    if ( ( victim = ch->fighting ) == NULL )
    {
  send_to_char( "You aren't fighting anyone.\n\r", ch );
  return;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Cool, you kicked a cloud.\r\n",ch);
    return;
    }


    if ( ch->move < (ch->level/15) )
    {
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

  check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {   
        send_to_char("You bounce off an orb of touch.\n\r",ch);
        check_dispel( ch->level , victim, skill_lookup("orb of touch"));
	WAIT_STATE( ch, skill_table[gsn_kick].beats);
        return;
    }

    WAIT_STATE( ch, skill_table[gsn_kick].beats );
    if ( get_skill(ch,gsn_kick) > number_percent())
    {
 damage(ch,victim,number_range(2,(3*ch->level)/2),gsn_kick,DAM_BASH,TRUE,FALSE);
  check_improve(ch,gsn_kick,TRUE,1);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"Amazing! A beautiful roundhouse from %s nails %s.",ch->name,victim->name);
       gladiator_talk(buf);
    }
    }
    else
    {
  damage( ch, victim, 0, gsn_kick,DAM_BASH,TRUE,FALSE);
  check_improve(ch,gsn_kick,FALSE,1);
    }
    return;
}

void do_insanity( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;

    if ( !IS_NPC(ch)
    &&   ch->level < skill_level(ch,gsn_insanity) )
    {
  send_to_char(
      "You better just take your lithium for now.\n\r", ch );
  return;
    }

    if ( ( victim = ch->fighting ) == NULL )
    {
  send_to_char( "You aren't fighting anyone.\n\r", ch );
  return;
    }

    if ( ch->move < (ch->level/15) )
    {
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/5));
     
  check_killer(ch,victim);
     
    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
        send_to_char("You bounce off an orb of touch.\n\r",ch);
        check_dispel( ch->level , victim, skill_lookup("orb of touch"));
        WAIT_STATE( ch, skill_table[gsn_insanity].beats);
        return;
    }
    
    WAIT_STATE( ch, skill_table[gsn_insanity].beats );
    if ( get_skill(ch,gsn_insanity) > number_percent())
    {
  act("$n goes into a fit of rage directed at you!",
    ch,NULL,victim,TO_VICT,FALSE);
  act("You charge madly at $N, and flay $M!",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n charges $N looking crazed.",
    ch,NULL,victim,TO_NOTVICT,FALSE);
  damage(ch,victim,number_range(10,3*ch->level),gsn_insanity,DAM_BASH,TRUE,FALSE);
  DAZE_STATE(victim, 2* PULSE_VIOLENCE/3);
  check_improve(ch,gsn_insanity,TRUE,1);
    }
    else
    {
  act("You swing wildly and hurt yourself!", ch,NULL,victim,TO_CHAR,FALSE);
  act("$n flails widly hurting $mself.", ch,NULL,victim,TO_NOTVICT,FALSE);
  if(!IS_SET(victim->display,DISP_BRIEF_COMBAT))
 act("You narrowly escape $n's fit of insanity.", ch,NULL,victim,TO_VICT,FALSE);
  damage(ch,ch,number_range(10,3*ch->level),gsn_insanity,DAM_BASH,TRUE,FALSE);
  DAZE_STATE(ch, 2* PULSE_VIOLENCE/3);
  check_improve(ch,gsn_insanity,FALSE,2);
    }
  return;
}


void do_dbite( CHAR_DATA *ch, char *argument )
{
    	char  arg[MAX_INPUT_LENGTH]; 
	CHAR_DATA *victim;
	int bite_damage;
	int chance;

	one_argument(argument, arg);

      if ( !IS_SET(race_table[ch->race].parts,PART_FANGS) )
      {
        send_to_char("Your chompers a tad lacking for that.\n\r",ch);
        return;
      }

	if ( arg[0] == '\0' )
	{
        if ( ( victim = ch->fighting ) == NULL )
        {
        send_to_char( "Yeah, we already know you bite.\n\r", ch );
        return;
        }

	if( is_affected(ch,skill_lookup("wraithform")) )
	{
	send_to_char("Not while in wraithform.\r\n",ch);
	return;
	}

	}
	else
	if (( victim = get_char_room(ch, arg) ) == NULL )
	{
		send_to_char("That individual isn't here.\n\r", ch);
		return;
	}

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    { 
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }


        if (victim->fighting != NULL &&
	   IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
        {
           send_to_char("Honorable combat is one on one.\n\r",ch);
           return;
        }

	if ( IS_NPC(victim) &&
		victim->fighting != NULL &&
		!is_same_group(ch, victim->fighting))
	{
		send_to_char("Kill stealing is not permitted.\n\r", ch);
		return;
	}

	if (victim == ch)
	{
		send_to_char("You reach around and gnaw on your tail.\n\r",ch);
		return;
	}

	if( is_affected(victim,skill_lookup("wraithform")) )
	{
	send_to_char("Biting at a fog bank? \r\n",ch);
	return;
	}


	if ( is_safe(ch, victim))
	{
		send_to_char("Pick on somebody your own size.\n\r", ch);
		return;
	}
      if( is_affected(victim,skill_lookup("orb of touch")) )
      {
	   send_to_char("You bounce off an orb of touch.\n\r",ch);
           check_dispel( ch->level , victim, skill_lookup("orb of touch"));
           WAIT_STATE(ch,12);
	   return;
      }

        check_killer(ch,victim);
        WAIT_STATE( ch, 24 );
        bite_damage= dice(ch->size,ch->level);

	  chance = 3 * ch->level / 2;
	  chance += ch->size * 4;
	  chance -= 2 * get_curr_stat(victim,STAT_DEX) /3;
	  chance -= ( check_dodge( ch, victim,FALSE ) ? 20 : 0 );

 	if ( victim->fighting == NULL )
	{
		bite_damage *= 2;
		chance += 25;
	}

	chance = URANGE( 5, chance, 95 );

        if ( number_percent( ) < chance || !IS_AWAKE(victim) )
              damage(ch,victim,bite_damage,gsn_bite,DAM_PIERCE,TRUE,FALSE);
        else
	        damage( ch, victim, 0, gsn_bite, DAM_PIERCE,TRUE,FALSE);

        return;
}

void do_bite( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    AFFECT_DATA af;
    int sn;
    char buf[MAX_STRING_LENGTH];

    if(IS_NPC(ch))
       return;

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Mistfangs, kinky but not very effictive.\r\n",ch);
    return;
    }

    if ( ( victim = ch->fighting ) == NULL )
    {
  send_to_char( "You aren't fighting anyone.\n\r", ch );
  return;
    }

    if ( ch->move < (ch->level/15) )
    {
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }

    if ( ch->pcdata->condition[COND_FULL] > 46 )
    {
	send_to_char("You no longer crave the flesh.\n\r",ch);
	return;
    }

    ch->move -= apply_chi(ch,(ch->level/15));
     
   check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
        send_to_char("You bounce off an orb of touch.\n\r",ch);
        check_dispel( ch->level , victim, skill_lookup("orb of touch"));
	WAIT_STATE( ch, skill_table[gsn_bite].beats/2);
        return;
    }
    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("You bite air, cold, fridgid, undead air.\r\n",ch);
    return;
    }



    WAIT_STATE( ch, skill_table[gsn_bite].beats );
    if ( get_skill(ch,gsn_bite) > number_percent())
    {
  damage(ch,victim,number_range( ch->level/4, ch->level ), gsn_bite,DAM_PIERCE,TRUE,FALSE);
    if (saves_spell(ch->level-2,victim,DAM_DISEASE) ||
        (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD)))
    {
     if (ch == victim)
	send_to_char("You feel momentarily ill, but it passes.\n\r",ch);
     else
	act("$N seems to be unaffected.",ch,NULL,victim,TO_CHAR,FALSE);
    }
    else
    {
	sn = skill_lookup("plague");
	af.where     = TO_AFFECTS;
	af.type     = sn;
	af.level    = ch->level;
	af.duration  = (ch->level/10) + 1;
	af.location  = APPLY_STR;
	af.modifier  = -1;
	af.bitvector = AFF_PLAGUE;
	affect_join(victim,&af);

 	send_to_char("Your stomache turns and you feel ill.\n\r",victim);
	send_to_char("Your bite spreads the infestation.\n\r",ch);
	
        /* Gladiator Spectator Channel */
        if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
        {
           sprintf(buf,"%s sinks a pair of plague-infested rotting teeth into %s.",ch->name,victim->name); 
           gladiator_talk(buf);
        }
    }
    check_improve(ch,gsn_bite,TRUE,1);
   }
   else
   {
	damage( ch, victim, 0, gsn_bite,DAM_PIERCE,TRUE,FALSE);
	check_improve(ch,gsn_bite,FALSE,1);
   }
    return;
}    

void do_bleed( CHAR_DATA *ch, char *argument )
{
	CHAR_DATA *victim;
	int dam;
	char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];

	one_argument( argument, arg );

    if (IS_NPC(ch))
       return;

 
    if ( arg[0] == '\0' )
    {
	victim = ch->fighting;
	if ( ( victim = ch->fighting ) == NULL )
	{
	    send_to_char("You aren't fighting anybody.\n\r",ch);
	    return;
	}
    }
    else if ( ( victim = get_char_room(ch,arg) ) == NULL )
    {
	send_to_char("Who?  They aren't here.\n\r",ch);
	return;
    }
    
    if (IS_IMMORTAL(victim))
    {
	send_to_char("Don't be a dumbass.\n\r", ch);
	return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

    if ((is_clan(ch) && !is_clan(victim) && !IS_NPC(victim))
	 || (!is_clan(ch) && !IS_NPC(victim)))
    {
	send_to_char("Don't cheat...you will get caught.\n\r",ch);
	return;
    }

    if (IS_NPC(victim) && IS_SET(victim->act, ACT_UNDEAD))
    {
	send_to_char("You cannot bleed the already dead.\n\r", ch);
	return;
    }


    if ( victim == ch )
    {
	send_to_char("You taste like chicken.\n\r",ch);
	return;
    }

    if (is_safe(ch,victim))
       return;

 if ( IS_NPC(victim) &&                                     
   victim->fighting != NULL &&
    !is_same_group(ch,victim->fighting))                                         
	 {                                                                          
           send_to_char("Kill stealing is not permitted.\n\r",ch);        
	 return;                                                                
      }


    if ( ch->move < (ch->level/15) )
    {
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }

    if ( ch->pcdata->condition[COND_FULL] > 46 )
    {
	send_to_char("Your lust for blood is already satiated.\n\r",ch);
	return;
    }

    ch->move -= apply_chi(ch,(ch->level/15));

    if ( get_skill(ch,gsn_bleed) < 1 )
	return;

    check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
        send_to_char("You bounce off an orb of touch.\n\r",ch);
        check_dispel( ch->level , victim, skill_lookup("orb of touch"));
        WAIT_STATE( ch, skill_table[gsn_bleed].beats/2);
        return;
    }

    WAIT_STATE( ch, skill_table[gsn_bleed].beats );
    if ( get_skill(ch,gsn_bleed) > number_percent())
    {
	dam = number_range(ch->level/2, 5*ch->level/3);
	switch(check_immune(victim,DAM_PIERCE))
	{
	 case(IS_IMMUNE):
	  dam = 0;
	  break;
	 case(IS_RESISTANT):
	  dam -= dam/4;
	  break;
	 case(IS_VULNERABLE):
	  dam += dam/4;
	  break;
	}

	damage( ch, victim, dam, gsn_bleed, DAM_PIERCE, TRUE,FALSE);
	ch->mana += 4 * dam  / 5;
	send_to_char("You feel your lifeblood seeping from your neck.\n\r",victim);
	send_to_char("Your heart beats strong with life.\n\r",ch);
	check_improve(ch,gsn_bleed,TRUE,1);

    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 75)
    {
       sprintf(buf,"EWWW! %s drinks blood from %s. The crowd loves it!",ch->name,victim->name);
       gladiator_talk(buf);
    }

/** The higher your level, the more bleeding you need to get full
    Seems backwards, but it allows for better bleed at 51 **/

	gain_condition(ch,COND_FULL,   15 - ( ch->level / 5 ) );
	gain_condition(ch,COND_HUNGER, 15 - ( ch->level / 5 ) );
	gain_condition(ch,COND_THIRST, 15 - ( ch->level / 5 ) );

	if ( ch->pcdata->condition[COND_FULL] > 46 )
	{
	  send_to_char("Your lust for blood has been satiated.\n\r",ch);
	  return;
	}

    }
    else
    {
	send_to_char("Your teeth gnash together, {ymissing{x their target.\n\r",ch);
 	damage(ch,victim,0,gsn_bleed,DAM_PIERCE,TRUE,FALSE);
        check_improve(ch,gsn_bite,FALSE,1);
    }
  return;
}

void do_hex(CHAR_DATA *ch, char *argument)
{
    CHAR_DATA *victim;
    AFFECT_DATA af;
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];

   if(IS_NPC(ch))
     return;

   if(!IS_SET(ch->act,PLR_MUMMY))
   {
     send_to_char("You ain't no stinking Mummy!\n\r",ch);
     return;
   }

   if( is_affected(ch,skill_lookup("wraithform")) )
   {
     send_to_char("Not while in wraithform.\r\n",ch);
     return;
   }

   if ( ( victim = ch->fighting ) == NULL )
    {
       send_to_char( "You aren't fighting anyone.\n\r", ch );
       return;
    }
    one_argument( argument, arg );

    if (arg[0] != '\0')
    {
       if ( ( victim = get_char_room(ch,arg) ) == NULL )
       {
	send_to_char("Who?  They aren't here.\n\r",ch);
	return;
       }
    }
    if ( IS_NPC(victim) && victim->spec_fun != 0 )
    {
      if (
         victim->spec_fun == spec_lookup("spec_honor_guard")
         || victim->spec_fun == spec_lookup("spec_demise_guard")
         || victim->spec_fun == spec_lookup("spec_posse_guard")
         || victim->spec_fun == spec_lookup("spec_zealot_guard")
         || victim->spec_fun == spec_lookup("spec_warlock_guard")
         )
         {
           send_to_char("Clan guards of Boigna are immune to your hex.  Ha-ha.\r\n",ch);
	   return; 
         }
    }


    if (is_safe(ch,victim))
       return;
    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("Your hex does not affect them, they are pretty scary looking themselves.\r\n",ch);
    return;
    }


 if ( IS_NPC(victim) &&                                     
   victim->fighting != NULL &&
    !is_same_group(ch,victim->fighting))                                         
	 {                                                                          
           send_to_char("Kill stealing is not permitted.\n\r",ch);        
	 return;                                                                
	 }

    WAIT_STATE( ch, skill_table[gsn_hex].beats );

    if ( get_skill(ch,gsn_hex) > number_percent())
    {
       if ( saves_spell(ch->level,victim,DAM_OTHER))
       {
          send_to_char("Your hex fails.\n\r",ch);
          send_to_char("You ward off a hex.\n\r",victim);
	act( "$n makes a sign with $s fingers and wards off the hex.",
		victim, NULL, victim, TO_ROOM ,FALSE);
          return;
       }
       else
       {
          af.where     = TO_AFFECTS;
          af.type      = gsn_curse;
          af.level     = ch->level;
          af.duration  = ch->level / 3;
          af.location  = APPLY_HITROLL;
          af.modifier  = -3;
          af.bitvector = AFF_CURSE;
          affect_to_char( victim, &af );

          af.location  = APPLY_SAVING_SPELL;
          af.modifier  = 3;
          affect_to_char( victim, &af );

          send_to_char( "You have been hexed!\n\r", victim );
          act( "$n has been hexed.", victim, NULL, victim, TO_ROOM ,FALSE);
	  damage(ch,victim,0,gsn_hex,DAM_OTHER,FALSE,FALSE);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) )
    {
       sprintf(buf,"Have you ever seen a hex in action? %s is teaching %s what its all about.",ch->name,victim->name);
       gladiator_talk(buf);
    }
       }
       check_improve(ch,gsn_hex,TRUE,1);
    }
    else
    {
       send_to_char("You attempt to cast a hex but fail.\n\r",ch);
       check_improve(ch,gsn_hex,FALSE,1);
    }

    return;
}

void do_fear( CHAR_DATA *ch, char *argument )
{
   CHAR_DATA *victim,*nextvictim;
   ROOM_INDEX_DATA *was_in;
   ROOM_INDEX_DATA *now_in;
   EXIT_DATA *pexit;
   int attempt, door;
    char buf[MAX_STRING_LENGTH];

   if (IS_NPC(ch))
      return;

   if(!IS_SET(ch->act,PLR_MUMMY))
   {
     send_to_char("You ain't no stinking Mummy!\n\r",ch);
     return;
   }

   if ( ch->move < 20 )
   {   
       send_to_char("You're tired of making scary faces.\n\r",ch);
       return;
   }

    if ( ch->pcdata->condition[COND_FULL] > 46 )
    {
	send_to_char("Your desire for fear has been completed.\n\r",ch);
	return;
    }

   ch->move -= apply_chi(ch,20);

   WAIT_STATE( ch, skill_table[gsn_fear].beats );

   if ( number_percent() < get_skill(ch,gsn_fear) )
   {
      act( "$n spreads fear through the room!", ch, NULL, NULL, TO_ROOM ,FALSE);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) )
    {
       sprintf(buf,"%s is scaring everyone away!",ch->name);
       gladiator_talk(buf);
    }
      for ( victim= ch->in_room->people; victim != NULL; victim = nextvictim )
      {
	 nextvictim = victim->next_in_room;
         if(victim != ch  && 
	      ( (is_clan(victim) && is_clan(ch) ) || IS_NPC(victim) ) )
         {
            if (IS_NPC(victim) && (IS_SET(victim->act,ACT_TRAIN)
		||  victim->pIndexData->pShop != NULL
                ||  IS_SET(victim->act,ACT_PRACTICE)
                ||  IS_SET(victim->act,ACT_IS_HEALER)
                ||  IS_SET(victim->act,ACT_NOPURGE)
		||  IS_SET(victim->act, ACT_AGGRESSIVE)
                ||  IS_SET(victim->act,ACT_IS_CHANGER)))  
	       continue;

	    if(is_safe(ch,victim))
		continue;

            if ( saves_spell(ch->level,victim,DAM_MENTAL))
	       continue;
            if( is_affected(ch,skill_lookup("wraithform")) )
               continue;

	    if (is_same_group(ch,victim))
	       continue;

            if ( IS_AFFECTED(victim, AFF_SLEEP))
	       continue;

            for ( attempt = 0; attempt < 6; attempt++ )
            {
	       door = number_door();
               was_in = victim->in_room;
	       if ( ( pexit = was_in->exit[door] ) == 0
		 ||   pexit->u1.to_room == NULL
		 ||   IS_SET(pexit->exit_info, EX_CLOSED)
		 ||   number_range(0,victim->daze) != 0
		 ||   (IS_NPC(victim)
		 &&   IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB) ) )
                 continue;

               move_char( victim, door, FALSE );
               if ( ( now_in = victim->in_room ) == was_in )
                  continue;

               victim->in_room = was_in;
               act( "$n runs in fear!", victim, NULL, NULL, TO_ROOM ,FALSE);
               victim->in_room = now_in;
               send_to_char("You run in fear.\n\r",victim);
	       check_killer(ch,victim);
    if (IS_SET(ch->mhs,MHS_GLADIATOR) )
    {
       sprintf(buf,"%s hops out of the shadows and scares the hell out of %s, who runs off like a little girl.",ch->name,victim->name); 
       gladiator_talk(buf);
    }

               gain_condition(ch,COND_FULL,   15 - ( ch->level / 5 ) );
               gain_condition(ch,COND_HUNGER, 15 - ( ch->level / 5 ) );
               gain_condition(ch,COND_THIRST, 15 - ( ch->level / 5 ) );

               if ( ch->pcdata->condition[COND_FULL] > 46 )
	       {
	          send_to_char("Your fear has empowered you completely.\n\r",ch);
	          return;
	       }
            }
         }
      }
      check_improve(ch,gsn_fear,TRUE,1);
   }
   else
   {
      send_to_char("You attempt to instill fear but fail.\n\r",ch);
      check_improve(ch,gsn_fear,FALSE,1);
   }
   return;
}
    
void do_breathe( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    AFFECT_DATA af;
    int sn;
    char buf[MAX_STRING_LENGTH];

     if(IS_NPC(ch))
       return;
    
    if(!IS_SET(ch->act,PLR_MUMMY))
    {
      send_to_char( "Breathe deep, the gathering gloom...\n\r", ch );
      return;
    }

    if ( ( victim = ch->fighting ) == NULL )
    {
       send_to_char( "You aren't fighting anyone.\n\r", ch );
       return;
    }

    if ( ch->move < (ch->level/15) )
    {
       send_to_char("You're too exhausted.\n\r",ch);
       return;
    }

    ch->move -= apply_chi(ch,(ch->level/15));
    check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of turning")) )
    {
       send_to_char("Your breath bounces off an orb of turning.\n\r",ch);
       check_dispel( ch->level , victim, skill_lookup("orb of turning"));
       WAIT_STATE( ch, skill_table[gsn_breathe].beats/2);
       return;
    }

    WAIT_STATE( ch, skill_table[gsn_breathe].beats );

    if ( get_skill(ch,gsn_breathe) > number_percent())
    {
       damage(ch,victim,number_range( ch->level/4, ch->level ),
	      gsn_breathe,DAM_POISON,TRUE,FALSE);
       if (saves_spell(ch->level-2,victim,DAM_POISON) ||
          (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD)))
       {
          if (ch == victim)
	     send_to_char("You feel momentarily ill, but it passes.\n\r",ch);
          else
	     act("$N seems to be unaffected.",ch,NULL,victim,TO_CHAR,FALSE);
       }
       else
       {
          sn = skill_lookup("poison");
          af.where     = TO_AFFECTS;
          af.type     = sn;
          af.level    = ch->level;
          af.duration  = (ch->level/10) + 1;
          af.location  = APPLY_STR;
          af.modifier  = -1;
          af.bitvector = AFF_POISON;
          affect_join(victim,&af);

          send_to_char("Your feel ill from the putrescent breath.\n\r",victim);
          send_to_char("Your rancid breath spreads the poison.\n\r",ch);
        /* Gladiator Spectator Channel */
        if (IS_SET(ch->mhs,MHS_GLADIATOR))
        {
           sprintf(buf,"The stench of %s's makes %s spew chunks all over.",ch->name,victim->name); 
           gladiator_talk(buf);
        }
       }
       check_improve(ch,gsn_breathe,TRUE,1);
    }
    else
    {
       damage( ch, victim, 0, gsn_breathe,DAM_POISON,TRUE,FALSE);
       check_improve(ch,gsn_breathe,FALSE,1);
    }
    return;
}    

void do_disarm( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    int chance,hth,ch_weapon,vict_weapon,ch_vict_weapon;
    char buf[MAX_STRING_LENGTH];

    hth = 0;

    if ((chance = get_skill(ch,gsn_disarm)) == 0)
    {
  send_to_char( "You don't know how to disarm opponents.\n\r", ch );
  return;
    }

    if ( get_eq_char( ch, WEAR_WIELD ) == NULL 
    &&   ((hth = get_skill(ch,gsn_hand_to_hand)) == 0
    ||    (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_DISARM))))
    {
  send_to_char( "You must wield a weapon to disarm.\n\r", ch );
  return;
    }

    if ( ( victim = ch->fighting ) == NULL )
    {
  send_to_char( "You aren't fighting anyone.\n\r", ch );
  return;
    }

    if ( ( obj = get_eq_char( victim, WEAR_WIELD ) ) == NULL )
    {
  send_to_char( "Your opponent is not wielding a weapon.\n\r", ch );
  return;
    }

    if ( ch->move < (ch->level/15) )
    {   
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

    /* find weapon skills */
    ch_weapon = get_weapon_skill(ch,get_weapon_sn(ch,FALSE));
    vict_weapon = get_weapon_skill(victim,get_weapon_sn(victim,FALSE));
    ch_vict_weapon = get_weapon_skill(ch,get_weapon_sn(victim,FALSE));

    /* modifiers */

    /* skill */
    if ( get_eq_char(ch,WEAR_WIELD) == NULL)
  chance = chance * hth/150;
    else
  chance = chance * ch_weapon/100;

    chance += (ch_vict_weapon/2 - vict_weapon) / 2; 

    if (!IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("warrior") &&
    			 ch->pcdata->old_class!=class_lookup("thief")))
	chance -= 25;

    /* dex vs. strength */
    chance += get_curr_stat(ch,STAT_DEX);
    chance -= 2 * get_curr_stat(victim,STAT_STR);

    /* level */
    chance += (ch->level - victim->level) * 2;

    /* Spells */
    chance /= ( is_affected(victim,gsn_stonefist) ? 2 : 1 );

    /* Blademaster */
    if ( victim->class == class_lookup("blademaster") )
	chance /= 3;

     /* Battleragers and bladesingers */
    if ( is_affected(victim,gsn_rage) || is_affected(victim,gsn_bladesong) )
	chance /= 2;

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
	send_to_char("You bounce off an orb of touch.\n\r",ch);
	check_dispel( ch->level , victim, skill_lookup("orb of touch"));
	if (IS_AFFECTED(ch,AFF_SLOW)) 
	    WAIT_STATE(ch,skill_table[gsn_disarm].beats);
	else
	    WAIT_STATE(ch,skill_table[gsn_disarm].beats/2);
	return;
    }

    /* Shoguns are impossible to disarm */
    if ( check_hai_ruki(victim) )
	chance = UMIN(chance,15);

    /* and now the attack */
    if (number_percent() < chance)
    {
      WAIT_STATE( ch, skill_table[gsn_disarm].beats );
  disarm( ch, victim );
  check_improve(ch,gsn_disarm,TRUE,1);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) )
    {
       sprintf(buf,"Now that was impressive! %s just sent %s's weapon flying.",ch->name,victim->name);
       gladiator_talk(buf);
    }
    }
    else
    {
  WAIT_STATE(ch,skill_table[gsn_disarm].beats);
  act("You fail to disarm $N.",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n tries to disarm you, but fails.",ch,NULL,victim,TO_VICT,FALSE);
  act("$n tries to disarm $N, but fails.",ch,NULL,victim,TO_NOTVICT,FALSE);
  check_improve(ch,gsn_disarm,FALSE,1);
    }
    check_killer(ch,victim);
    return;
}



void do_sla( CHAR_DATA *ch, char *argument )
{
    send_to_char( "If you want to SLAY, spell it out.\n\r", ch );
    return;
}



void do_slay( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char arg[MAX_INPUT_LENGTH];

    one_argument( argument, arg );
    if ( arg[0] == '\0' )
    {
  send_to_char( "Slay whom?\n\r", ch );
  return;
    }

    if ( ( victim = get_char_room( ch, arg ) ) == NULL )
    {
  send_to_char( "They aren't here.\n\r", ch );
  return;
    }

    if ( ch == victim )
    {
  send_to_char( "Suicide is a mortal sin.\n\r", ch );
  return;
    }

    if ( !IS_NPC(victim) && victim->level >= get_trust(ch) )
    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    act( "You slay $M in cold blood!",  ch, NULL, victim, TO_CHAR    ,FALSE);
    act( "$n slays you in cold blood!", ch, NULL, victim, TO_VICT    ,FALSE);
    act( "$n slays $N in cold blood!",  ch, NULL, victim, TO_NOTVICT ,FALSE);
    raw_kill( victim,ch );
    return;
}

void do_cutpurse( CHAR_DATA *ch, CHAR_DATA *victim )
{
   int chance;
   int gold,silver;

   if(IS_SET(ch->mhs,MHS_GLADIATOR) || IS_SET(ch->mhs,MHS_HIGHLANDER))
      return;
   if(ch->clan == clan_lookup("smurf"))
     return;

   chance = get_skill(ch,gsn_cutpurse)/3;

   chance += (get_curr_stat(ch,STAT_DEX) - (get_curr_stat(victim,STAT_DEX)))*5;
   chance += (ch->level - victim->level)*2;

   if (number_percent() <= chance)
   {
act("You rip apart $N's purse and steal their gold!", ch, NULL, victim,TO_CHAR,FALSE);
act("$n rips open your purse and scoops up the coins!",ch,NULL,victim,TO_VICT,FALSE);
act("$n rips open $N's purse, and scoops up the coins!",ch,NULL,victim,TO_ROOM,FALSE);
   gold = victim->gold/25;
   victim->gold -= gold;
   ch->gold += gold;

   silver = victim->silver/20;
   victim->silver -= silver;
   ch->silver += silver;
   
   check_improve(ch,gsn_cutpurse,TRUE,3);

   return;
   }
   else
   {
   check_improve(ch,gsn_cutpurse,FALSE,6);
   return;
   }
}

void do_garotte( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    OBJ_DATA *wield;
    AFFECT_DATA af;
    bool checkfail = FALSE;
    int failroll;
    int failchance;
    int level;
    int chance;
    char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];

    one_argument(argument,arg);

    if ( !IS_NPC(ch)
    &&   ch->level < skill_level(ch,gsn_garotte) )
    {
      send_to_char( "You better stick to choking your chicken.\n\r", ch );
      return;
    }

    if ((!IS_NPC(ch) && !IS_NPC(victim)) && (ch != victim) && ch->pcdata)
    {
        ch->pcdata->quit_time = 4;
        if (victim->pcdata) victim->pcdata->quit_time = 4;
    } 


    if ( ch->fighting != NULL )
    {
      send_to_char( "You can't sneak up on anyone while you're fighting.\n\r", ch );
      return;
    }


    if( arg[0] == '\0' || (victim = get_char_room(ch,arg)) == NULL )
    {
      send_to_char("They're not here.\n\r",ch);
      return;
    }

    if(IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_NPC(victim))
    {
     send_to_char("Highlanders are immune to that.\n\r",ch);
     return;
    }

    if (victim->fighting != NULL)
    {
       send_to_char("They are too active to get a hold on.\n\r",ch);
       return;
    }
   
    if (ch == victim)
    {
     send_to_char(" You attempt to garotte yourself and fail like the pathetic miserable loser you are.\n\r", ch);
     return;
     }

    if (is_safe(ch,victim))
       return;

    if ( IS_AFFECTED(victim, AFF_SLEEP)
    ||   (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD)) )
    {
      send_to_char("Leave the sleeping and the undead in peace.\n\r",ch);
      return;
    }

    if ( ch->move < (ch->level/5) )
    {
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/5));

    /* modifiers */

    chance = get_skill(ch,gsn_garotte);

    /* stats */
    chance += get_curr_stat(ch,STAT_STR);
    chance -= get_curr_stat(victim,STAT_DEX);
    chance -= get_curr_stat(victim,STAT_CON);

    /* level */
    chance += 2 * (ch->level - victim->level);

    if (!IS_NPC(victim))
    { 
  chance -= get_skill(victim,gsn_dodge)/4;
    }
    
    switch(check_immune(victim,DAM_MENTAL))
    {            
  case IS_IMMUNE:   chance = 0;  break;
  case IS_RESISTANT:  chance -= 50;  break;
  case IS_VULNERABLE: chance += 50;  break;
    }

/*  if( is_affected(ch,gsn_sneak) || is_affected(ch,gsn_hide) ) */
  if( IS_AFFECTED(ch,AFF_SNEAK) || IS_AFFECTED(ch,AFF_HIDE) )
   {
   if( ( wield = get_eq_char( ch, WEAR_WIELD ) ) != NULL &&
       wield->value[0] == WEAPON_GAROTTE )
     {
      if ( number_percent() <= chance &&
	  dice(wield->value[1],wield->value[2]) > 2 )
      {
	 check_improve(ch,gsn_garotte,TRUE,1);
	 level = wield->level;
	 
    switch(check_immune(victim,DAM_MENTAL))
    {            
  case IS_IMMUNE:   level = 0;  break;
  case IS_RESISTANT:  level /= 2;  break;
  case IS_VULNERABLE: level += 4;  break;
    }

    af.where     = TO_AFFECTS;
    af.type      = gsn_garotte;
    af.level     = level;
    af.duration  = UMIN(level,dice(wield->value[1],wield->value[2]));
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_SLEEP;
    affect_join( victim, &af );

    if ( IS_AWAKE(victim) )
    {
  send_to_char( "You feel very lightheaded.....\n\r", victim );
  act( "$n passes out from sufocation.", victim, NULL, NULL, TO_ROOM ,FALSE);
  WAIT_STATE(ch, 24);
  victim->position = POS_SLEEPING;

        /* Gladiator Spectator Channel */
        if (IS_SET(ch->mhs,MHS_GLADIATOR))
        {
           sprintf(buf,"%s finds it hard to breath with %s's rope around their neck.",victim->name,ch->name); 
           gladiator_talk(buf);
        }
    }

      }
      else
      {
	check_improve(ch,gsn_garotte,FALSE,2);
        checkfail = TRUE;
      }
     }
   else
     {
       send_to_char("You expect to choke someone with that?\n\r",ch);
     }
   }
  else
   {
     send_to_char("You've been spotted!\n\r",ch);
     checkfail = TRUE;
   }

   if (checkfail)
   {
       REMOVE_BIT(ch->affected_by, AFF_HIDE);
       WAIT_STATE(ch, 36);
       /*  get attacker's vital statistics, whee!  */ 
       failchance = ( get_skill(ch, gsn_sneak) /3) + ( get_skill(ch, gsn_hide) /2) + ( get_curr_stat(ch, STAT_AGT) /2);

       failroll = number_percent();

       if (failroll <= failchance)
       {
         send_to_char("Phew, you escaped notice.\n\r",ch);
         return;
       }

       if ( failroll > failchance  && failroll < 95 )
       {
         send_to_char("Whoops...\n\r",ch);
         send_to_char("Someone tried to sneak up on you..\n\r", victim);
       }

       if (failroll >= 95)
       {
         send_to_char("{DUhoh,{R NOW{D you've done it!!{x\n\r",ch);
         act("$n just tried to garotte you!",ch,NULL, victim, TO_VICT, FALSE);
         sprintf(buf, "{YHelp!{C  %s{x just tried to{R garotte{x me!!", ch->name);
         do_yell(victim, buf);
       }
   }
          
  return;
}

void do_rage ( CHAR_DATA *ch, char *argument )
{
        AFFECT_DATA af;
	  OBJ_DATA *weapon;
 
        if (!HAS_KIT(ch,"battlerager"))
        {
                send_to_char("Huh?\n\r", ch);
                return;
        }
 
        if (IS_NPC(ch))
        {
                send_to_char("NPC's aren't the raging type.\n\r", ch);
                return;
        }
 
        if ( skill_level(ch,gsn_rage) > ch->level )
        {
                send_to_char("Soon...very soon.\n\r", ch);
                return;
        }
 
        if (is_affected(ch, gsn_rage))
        {
                send_to_char("More blood!  More death!  Charge!!\n\r", ch);
                return;
        }
 
        if (ch->fighting == NULL )
        {
                send_to_char("There's no one to rage upon.\n\r", ch);
                return;
        }

	if ( (weapon= get_eq_char(ch,WEAR_WIELD)) == NULL )
		return;

	switch(weapon->value[0])
	{
	case WEAPON_AXE: break;
	default:
	    send_to_char("What?  Without an axe?  What kind of dwarf are you?\n\r", ch);
	    return;
	}

        if ( number_percent() >= get_skill(ch, gsn_rage) ) 
        {
		check_improve(ch,gsn_rage,FALSE,3);
                send_to_char("The anger just isn't there.\n\r", ch);
                return;
        }
        else
        {
 
        send_to_char("Screaming a battle cry, you fly into a rage!\n\r", ch);
 
        af.where     = TO_AFFECTS;
        af.type      = gsn_rage;
        af.level     = ch->level;
        af.duration  = 1 + (ch->level / 10);
        af.modifier  = ch->level / 5;
        af.location  = APPLY_HITROLL;
        af.bitvector = 0;
        affect_to_char( ch,     &af );

	af.modifier += get_curr_stat(ch,STAT_CON) / 3; 
        af.location  = APPLY_DAMROLL;
        affect_to_char( ch,     &af );
        
        af.modifier  = 1 * ch->level;
        af.location  = APPLY_AC;
        affect_to_char( ch,     &af );

        af.where            = TO_AFFECTS; 
        af.bitvector        = 0;  
        af.location         = APPLY_DEX;
	af.modifier         = -4; 
        affect_to_char( ch, &af );       

	af.location = APPLY_HIT;
	af.modifier = ((!IS_NPC(ch) ? ch->pcdata->perm_hit : ch->max_hit) / 4);
	affect_to_char( ch,  &af );

	ch->hit += (ch->max_hit /5);
	ch->hit = UMIN(ch->hit, ch->max_hit);

	af.location = APPLY_SAVES;
	af.modifier = -4;
	affect_to_char( ch,  &af );

	if (!IS_SET(ch->imm_flags, IMM_CHARM))
	{
		af.bitvector = IMM_CHARM;
		af.where = TO_IMMUNE;
		af.location = APPLY_NONE;
		affect_to_char( ch, &af );
        }
    }
    check_improve(ch,gsn_rage,TRUE,1);
    return;
}


void do_bladesong ( CHAR_DATA *ch, char *argument )
{
        int factor;
        AFFECT_DATA af;
	OBJ_DATA *weapon;
	char arg[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];

	if (!HAS_KIT(ch,"bladesinger") )
	{
		send_to_char("Huh?\n\r",ch);
		return;
	}

	one_argument(argument,arg);
	if ( !str_cmp(arg,"stop") && is_affected(ch,gsn_bladesong))
	{
	   affect_strip(ch,gsn_bladesong);
           send_to_char("You stop performing the bladesong.\n\r",ch);
           act("$n ends his dancing blades!",ch,NULL,NULL,TO_ROOM,FALSE);
	   return;
        }

	if (is_affected(ch, gsn_bladesong))
	{
		send_to_char("You are already using the Bladesong.\n\r", ch);
		return;
	}

        if ( IS_NPC(ch) )
                return;

        if ( ch->level < skill_level(ch,gsn_bladesong) )
        {
                send_to_char("You are not yet skilled enough.\n\r", ch);
                return;
        }

        if ( ch->fighting == NULL )
        {
                send_to_char("You aren't in combat.\n\r", ch);
                return;
        }

        if ( get_eq_char( ch, WEAR_SHIELD ) != NULL )
        {
                send_to_char(
                "The bladesong cannot be performed while wearing a shield.\n\r",
                ch);
                return;
        }

        if ( (weapon = get_eq_char( ch, WEAR_WIELD )) == NULL )
                return;

        switch (weapon->value[0])
        {
                case(WEAPON_SWORD): 
                case(WEAPON_DAGGER): 
                        break;
                default:
                        send_to_char(
            "The bladesong art is only possible with swords and daggers.\n\r",
                        ch);
                        return;
        }

	if ( number_percent() > get_skill( ch, gsn_bladesong ) )
        {
	   send_to_char("You fail to make your blades dance.\n\r",ch);
                check_improve(ch,gsn_bladesong,FALSE,5);
                return;             
        }

        factor = ch->level / 6;

        af.where = TO_AFFECTS;
        af.type = gsn_bladesong;
        af.level = ch->level;
        af.duration = factor;
        af.modifier = factor;
        af.location = APPLY_HITROLL;
        af.bitvector = 0;
        affect_to_char( ch, &af );

        af.location = APPLY_DAMROLL;
        affect_to_char( ch, &af );

        af.modifier = factor * -10;
        af.location = APPLY_AC;
        affect_to_char( ch, &af );

        check_improve(ch,gsn_bladesong,TRUE,5);

        send_to_char("You begin to perform the bladesong.\n\r",ch);
	act("$n begins to make his blades dance!",ch,NULL,NULL,TO_ROOM,FALSE);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) )
    {
       sprintf(buf,"An elven bladesong is one of the deadliest maneuvers around. %s is going to open up a can of whopass with this one.",ch->name);
       gladiator_talk(buf);
    }
}

int myrm_pen( CHAR_DATA *ch, CHAR_DATA *victim )
{
    int sd;
    
    if ( !HAS_KIT(ch,"myrmidon") ) return 0;

    sd = ch->size - victim->size;

    if ( sd < 0 ) sd *= -1;

    sd *= 8 - ( ch->level / 10 );

    return ( sd );
}

int check_myrmidon( CHAR_DATA *ch, int gsn )
{
    int skill;
    int wsn;

    if ( !HAS_KIT(ch,"myrmidon") )
	return 0;

    /* no bonus if current weapon is not the one specialized in */
    if ( ( wsn = get_weapon_sn(ch,FALSE) )  != ch->pcdata->specialize )
        return 0;


   skill = get_skill(ch, gsn );
   if ( gsn == gsn_second_attack )
   	skill /=2 ; 
   else if ( gsn == gsn_third_attack ) 
	skill /=4 ; 
   else return 0;

  /* return difference always */
   return ( (100+ ch->level ) * skill / 100 - skill );
}


bool check_nether ( CHAR_DATA *ch, CHAR_DATA *victim, bool fSecondary )
{

  OBJ_DATA *shield, *weapon;
  int chance, hit; 

   
   if ( !HAS_KIT( victim, "nethermancer") )
	{
        return FALSE; 
        }

   if ( ( shield = get_eq_char( victim, WEAR_SHIELD ) ) == NULL )
	 {
	 return FALSE;
         }

   if ( get_eq_char ( victim, WEAR_SHIELD ) != NULL )
   {
      if ( shield->pIndexData->vnum != OBJ_VNUM_NETHER_SHIELD ) 
	   {
	   return FALSE;
	   }
   }
   
   if (fSecondary && !IS_NPC(ch))
       {
         weapon = get_eq_char(ch,WEAR_SECOND) ;
         hit = ch->pcdata->second_hitroll;
       }
   else
       {
	weapon = get_eq_char(ch,WEAR_WIELD) ;
        hit = ch->hitroll;
       }

  /* no avoiding nether weapons by slipping into the nether plane, they
     just follow you there and smack you */
   
   if ( weapon != NULL)
   {
   if ( HAS_KIT(ch, "nethermancer") && IS_WEAPON_STAT(weapon,WEAPON_NETHER) )
	 {
	 return FALSE;
         }
    }

   chance = get_skill( victim, gsn_nether_shield ) / 2;

   if ( ch->class == class_lookup("blademaster") )
	   chance -= ( chance / 5 );

   chance += myrm_pen(ch, victim);
   

   /* Ranger bonus for terrain if victim */
      switch( terrain(victim) )
      {
       case 0:     chance -= ( chance / 5 );       break;
       case 1:     chance += ( chance / 5 );       break;
       default:    break;
      }
    
    
    /* you int and your victims int affect your chances of hitting
       the nether before he moves to the nether plane */

    chance +=( (get_curr_stat(victim,STAT_INT) - get_curr_stat(ch,STAT_INT))*2 );
    /* Hitrolls */
    if (hit > 20)
       hit = (hit-20)/2 +20;
    if (hit > 40)
       hit = (hit - 40)/2 +40;

   chance -= hit;

   /* If the weapon is the secondary then harder to parry */
   if (fSecondary)
      chance -= 25;

   if ( number_percent( ) >= chance + victim->level - ch->level )
      {
      return FALSE;
      }
   if(!IS_SET(victim->display,DISP_BRIEF_COMBAT))
   act( "You fade to the nether plane and avoid $n's blow.",  ch, NULL, victim, TO_VICT    ,FALSE);
   if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
   act( "$N fades to the nether plane and avoids your attack.", ch, NULL, victim, TO_CHAR    ,FALSE);
   victim->mana -= 20;
   return TRUE;


}


/*STart of DO_kcharge function - started 26AUG000 by Boogums */ 
void do_kcharge( CHAR_DATA *ch, char *argument )
{

  char arg[MAX_INPUT_LENGTH];
  CHAR_DATA *victim;
  /* CHAR_DATA *victim1; */
  OBJ_DATA *obj;
  int percent;
  EXIT_DATA *pexit;
  int door;

  one_argument( argument, arg );
   if (is_clan(ch) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

  if (arg[0] == '\0')
  {
    victim = ch->fighting;
    if (victim == NULL)
      {
      send_to_char("Charge whom?\n\r",ch);
      return;
      }
  }

  else if ((victim = get_char_room(ch,arg)) == NULL)
      {
      send_to_char("They aren't here.\n\r",ch);
      return;
      }
      if( is_affected(victim,skill_lookup("wraithform")) )
      {
      send_to_char("Your skillful charge carries you through their misty form.\r\n",ch);
      return;
      }

  obj = get_eq_char( ch,WEAR_WIELD );
/* 15SEP00 - Variations on a theme:  added checks for polearm use by warrior
             and blademaster and likewse for flail by paladins and clerics.
	     Rage suggested leaving the caviler kit for something else :) 
	     -Boogums
*/

  if ( (ch->class == class_lookup("warrior")
	|| ch->class == class_lookup("blademaster"))
     && (obj == NULL || obj->value[0] != WEAPON_POLEARM) )
    {
    send_to_char( "You need to wield a polearm in order to charge.\r\n", ch );
    return;
    }

  if ( (ch->class == class_lookup("paladin")
	|| ch->class == class_lookup("cleric"))
     && ( obj == NULL || obj->value[0] != WEAPON_FLAIL) )
     {
       send_to_char( "You need to wield a flail order to charge.\r\n", ch );
       return;
     }

  if( !is_mounted(ch) )
    {
    send_to_char("You better saddle up on your handy dandy warhorse if you want to charge.\n\r",ch );
    return;
    }
/*Ok here comes the start, all sanity checks a go here goes the kcharge */

  if( is_mounted(ch) && IS_NPC(ch->riding) && ch->riding->pIndexData->vnum == MOB_VNUM_WARHORSE )
    { 

    if (is_safe( ch,victim ) ) return;
    if (IS_NPC(victim) && victim->fighting != NULL &&
        !is_same_group(ch,victim->fighting))
      {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
      }

    if (victim == ch)
      {
	 send_to_char("Charging yourself? That'd be quite the sight.\n\r",ch);
	 return;
      }

     if (is_safe(ch,victim)) return;
      
     if (victim->fighting != NULL)
       {
	 if (ch->fighting != NULL)
	 {
	 send_to_char("You are unable to charge at them.\n\r",ch);
	 return;
	 }
       }

    
    check_killer( ch, victim );

	if( is_affected(victim,skill_lookup("orb of touch")) )
          {
	    send_to_char("You bounce off an orb of touch.\n\r",ch);
	    check_dispel( ch->level , victim, skill_lookup("orb of touch"));
	    WAIT_STATE( ch, skill_table[gsn_kcharge].beats);
	    return;
          }
        
    percent = get_skill(ch,gsn_kcharge);
    if(!IS_NPC(victim) && victim->kit == kit_lookup("knight"))
      percent -= 25;

    percent = URANGE(5,percent,100);

    if ( (number_percent( ) < percent )
    || ( get_skill(ch,gsn_kcharge) >=2 && !IS_AWAKE(victim) ) )
      {
      check_improve(ch,gsn_kcharge,TRUE,1);
      WAIT_STATE( ch, skill_table[gsn_kcharge].beats);
      multi_hit( ch, victim, gsn_kcharge );
      }
    else
      {
      switch (number_range(0,1))
      {
	case 0:
        check_improve(ch,gsn_kcharge,TRUE,1);
        damage( ch,victim,0,gsn_kcharge,DAM_NONE,TRUE,FALSE);
        door = number_door();
        if ( ( pexit = victim->in_room->exit[door] ) == 0
        ||  pexit->u1.to_room == NULL
        ||  pexit->u1.to_room->clan
        ||  IS_SET(pexit->exit_info, EX_CLOSED)
        || (IS_NPC(ch)
        && IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB) ) )
        /* should stop combat only if the room is clear to move in to */
        stop_fighting(ch,TRUE);
        stop_fighting(victim,TRUE);
        act("ROFL!!! $n charges right out of the room.",ch,NULL,victim,TO_ROOM,FALSE);
        act("You charge right out of the room.",ch,NULL, victim,TO_CHAR,FALSE);
        move_char(ch, door, FALSE );
        WAIT_STATE( ch, skill_table[gsn_kcharge].beats*2);
        WAIT_STATE( victim, skill_table[gsn_kcharge].beats/2);
        break;
      case 1:
	act("$n tries to perform a beautiful charge but fails.\r\n",ch,NULL,victim,TO_ROOM,FALSE);
	act("Your charge fails.\r\n",ch,NULL, victim,TO_CHAR,FALSE);
	WAIT_STATE( ch, skill_table[gsn_kcharge].beats);
	break;
      default:
	WAIT_STATE( ch, skill_table[gsn_kcharge].beats*2);
	break;

      } /*end switch */
      return;
    }
  }
  else
  {
    send_to_char("Your squire knocks coconuts together while you charge around the room.\n\r",ch );
    return;
  }
return;

} /* End curly brace for do_kcharge */


void  handle_critical( CHAR_DATA *ch, int *damage, int dam_type, int diceroll, int base_dam )
{
    int cap;
    bool fCleave = FALSE, fBludgeon = FALSE, fEnhance = FALSE;
    int bonus;

    cap = 20; 
    /* not possible to roll a twenty, if they don't have 
		a skill or are oldclass warrior, no crit*/ 

    if ( IS_NPC(ch) && IS_SET(ch->act,ACT_WARRIOR) )
	--cap;

    if ( !IS_NPC(ch) && ch->pcdata->old_class == class_lookup("warrior") )
	--cap;

    if ( number_percent() < get_skill(ch,gsn_enhanced_critical) )
    {
	fEnhance = TRUE;
	--cap;
    }

    if ( dam_type == DAM_SLASH && number_percent() < get_skill(ch,gsn_cleave) )
    {
	fCleave = TRUE;
	--cap;
    }

    if ( dam_type == DAM_BASH && number_percent() < get_skill(ch,gsn_bludgeon) )
    {
	fBludgeon = TRUE;
	--cap;
    }

    if ( diceroll < cap )
	return;
 
    bonus = ch->level;
    if ( !fEnhance )
    {
	if ( bonus > 15 )
	    bonus = ( bonus - 20 ) / 2 + 20;
    }
    else
    {
	if ( bonus > 30 )
	    bonus = ( bonus - 30 ) / 2 + 30;
    }

    switch( diceroll )
    {
    case 19: break;
    case 18: bonus /= 2;  break;
    case 17: bonus /= 3;  break;
    default: bonus = 0; /* shouldn't have this */
    }

    if ( fEnhance )
	check_improve(ch,gsn_enhanced_critical,fEnhance,10);
  
    if ( fCleave )
	check_improve(ch,gsn_cleave,fCleave,10);
 
    if ( fBludgeon )
	check_improve(ch,gsn_bludgeon,fBludgeon,10);

    (*damage) += (100+bonus) * (base_dam) / 100;

    return;
}

void do_hamstring( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    int chance;
    char buf[MAX_STRING_LENGTH];

    one_argument(argument,arg);
 
    if ( (chance = get_skill(ch,gsn_hamstring)) == 0
    ||   (!IS_NPC(ch)
    &&    ch->level < skill_level(ch,gsn_hamstring)))
    { 
  send_to_char("Isn't hamstring a kind of sandwich?\n\r",ch);
  return;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }


    if ( arg[0] == '\0' )
    {
  send_to_char("Hamstring whom?\n\r",ch);
   return;
    }

    if ((victim = get_char_room(ch,arg)) == NULL)
    {
  send_to_char("They aren't here.\n\r",ch);
  return;
    }
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }


    if (victim == ch)
    {
  send_to_char("That'll ruin your cross-country career.\n\r",ch);
  return;
    }

    if ( ch->move < (ch->level/15) )
    {   
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->level/15));

    if (is_safe(ch,victim))
  return;
    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("You can't get past the wriathform.\r\n",ch);
    return;
    }


    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if ( IS_NPC(victim) && 
  victim->fighting != NULL && 
  !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }

    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
    {
  act("But $N is your friend!",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

  check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
	send_to_char("You bounce off an orb of touch.\n\r",ch);
	check_dispel(  ch->level , victim, skill_lookup("orb of touch"));
	if (IS_AFFECTED(ch,AFF_SLOW)) 
	    WAIT_STATE(ch,skill_table[gsn_hamstring].beats);
	else
	    WAIT_STATE(ch,skill_table[gsn_hamstring].beats/2);
	return;
    }

    chance += ch->level;
    chance -= victim->level;
    chance -= 3*(get_curr_stat(victim,STAT_STR)+get_curr_stat(victim,STAT_CON))/2;

    
    /* now the attack */
    if (number_percent() < chance )
    {
 	AFFECT_DATA af;
   
  act("$n cuts through your hamstring!  You can barely move!",
    ch,NULL,victim,TO_VICT,FALSE);
  act("You slice $N's hamstring, $E can barely move!",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n slices $N's hamstring, $E can barely move!",
    ch,NULL,victim,TO_NOTVICT,FALSE);
  check_improve(ch,gsn_hamstring,TRUE,1);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"Zoinks!  %s takes %s's legs out with a vicious slice to the hamstring!",ch->name,victim->name);
       gladiator_talk(buf);
    }

	/* strip haste */
  	if ( IS_AFFECTED(victim,AFF_HASTE) )
	    affect_strip(victim,skill_lookup("haste") );

	af.where	= TO_AFFECTS;
	af.type		= gsn_hamstring;
	af.duration	= number_percent() % 2;
	af.location	= APPLY_DEX;
	af.modifier	= ch->level / -12;
	af.level	= ch->level;
	af.bitvector	= AFF_SLOW;

	affect_to_char(victim,&af);

     damage(ch,victim,ch->level,gsn_hamstring,DAM_SLASH,FALSE,FALSE);
	victim->move /= 2;
	check_improve(ch,gsn_hamstring,TRUE,1);
    }
    else
   {
  check_improve(ch,gsn_hamstring,FALSE,1);
  act("You attempt to hamstring $N but fail.",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n tries to hamstring you but fails.",ch,NULL,victim,TO_VICT,FALSE);
  act("$n tries to hamstring $N but fails.",ch,NULL,victim,TO_NOTVICT,FALSE);
  damage(ch,victim,ch->level,gsn_hamstring,DAM_SLASH,FALSE,FALSE);
    }

 /* Wait states */
  if ( IS_AFFECTED(ch,AFF_SLOW) )
	WAIT_STATE(ch,PULSE_VIOLENCE*3);
  else
	WAIT_STATE(ch,PULSE_VIOLENCE*2);

  return;
}

void do_shieldbash( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    int chance;
    char buf[MAX_STRING_LENGTH];
    int sn;

    one_argument(argument,arg);
    sn = skill_lookup("shield bash");

    if ( (chance = get_skill(ch,sn)) == 0
    ||   (!IS_NPC(ch)
    &&    ch->level < skill_level(ch,sn)))
    {
  send_to_char("You'd probably just knock yourself out.\n\r",ch);
  return;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }

    if ( get_eq_char(ch,WEAR_SHIELD) == NULL )
    {	
	send_to_char("You're not wearing a shield.\n\r",ch);
	return;
    }

    if (arg[0] == '\0')
    {
        victim = ch->fighting;
        if (victim == NULL)
        {
            send_to_char("But you aren't fighting anyone!\n\r",ch);
            return;
        }
    }
    else if ((victim = get_char_room(ch,arg)) == NULL)
    {
        send_to_char("They aren't here.\n\r",ch);
        return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

    if (victim == ch)
    {
  send_to_char("Not one your brightest ideas.\n\r",ch);
  return;
    }

    if ( ch->move < (ch->level/15) )
    {
        send_to_char("You're too exhausted.\n\r",ch);
        return;
    }
    ch->move -= apply_chi(ch,(ch->move/3));

    if (is_safe(ch,victim))
  return;

    if( is_affected(victim,skill_lookup("wraithform")) )
    {
    send_to_char("You can't get past the wraithform.\r\n",ch);
    return;
    }

    if (victim->fighting != NULL &&
       IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Honorable combat is one on one.\n\r",ch);
       return;
    }

    if ( IS_NPC(victim) &&
  victim->fighting != NULL &&
  !is_same_group(ch,victim->fighting))
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return;
    }

    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
    {
  act("But $N is your friend!",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

  check_killer(ch,victim);

    if( is_affected(victim,skill_lookup("orb of touch")) )
    {
        send_to_char("You bounce off an orb of touch.\n\r",ch);
        check_dispel(  ch->level , victim, skill_lookup("orb of touch"));
        if (IS_AFFECTED(ch,AFF_SLOW))
            WAIT_STATE(ch,skill_table[gsn_hamstring].beats);
        else
            WAIT_STATE(ch,skill_table[gsn_hamstring].beats/2);
        return;
    }

    chance += ch->level;
    chance -= victim->level;
    chance -= get_curr_stat(victim,STAT_STR)+get_curr_stat(victim,STAT_CON);

    if ( ch->size > victim->size )
    	chance -= ( ch->size - victim->size )*3;

    /* now the attack */
    if (number_percent() < chance )
    {
        AFFECT_DATA af;

  act("$n smacks you in the face with $s shield!",
    ch,NULL,victim,TO_VICT,FALSE);
  act("You smack $N in the face with your shield!",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n smacks $N in the face with $s shield!",
    ch,NULL,victim,TO_NOTVICT,FALSE);
  check_improve(ch,sn,TRUE,1);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"*Wince*  %s clocks %s in the face with a shield!",ch->name,victim->name);
       gladiator_talk(buf);
    }

        /* strip haste */
  	DAZE_STATE(victim,PULSE_VIOLENCE);

        af.where        = TO_AFFECTS;
        af.type         = sn;
        af.duration     = 0;
        af.location     = 0;
        af.modifier     = 0;
        af.level        = ch->level;
        af.bitvector    = 0;

        affect_to_char(victim,&af);

        damage(ch,victim,ch->level,sn,DAM_SLASH,FALSE,FALSE);
        victim->move /= 2;
	check_improve(ch,sn,TRUE,1);
    }
    else
   {
  check_improve(ch,sn,FALSE,1);
  act("You miss!",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n tries to shield bash you but fails.",ch,NULL,victim,TO_VICT,FALSE);
  act("$n tries to shield bash $N but fails.",ch,NULL,victim,TO_NOTVICT,FALSE);
  damage(ch,victim,0,sn,DAM_SLASH,FALSE,FALSE);
    }

 /* Wait states */
  if ( IS_AFFECTED(ch,AFF_SLOW) )
        WAIT_STATE(ch,PULSE_VIOLENCE*2);
  else
        WAIT_STATE(ch,PULSE_VIOLENCE);

  return;
}

void do_grab( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    int chance;
    char buf[MAX_STRING_LENGTH];
    int sn;

    one_argument(argument,arg);
    sn = skill_lookup("grab");

    if ((victim = get_char_room(ch,arg)) == NULL)
    {
  send_to_char("They aren't here.\n\r",ch);
  return;
    }

    if ( (chance = get_skill(ch,sn)) == 0
    ||   (!IS_NPC(ch) && ch->level < skill_level(ch,sn))
    ||   ch->race != race_lookup("giant") 
    ||   ch->fighting != NULL 
    ||   ch == victim )
    {
  check_social( ch, "hug", "self" );
  return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

    if( is_affected(ch,skill_lookup("wraithform")) )
    {
    send_to_char("Not while in wraithform.\r\n",ch);
    return;
    }

    if ( ch->move < 40 )
    {
	send_to_char("You can't move that much.\n\r",ch);
	return;
     }
     ch->move -= apply_chi(ch,40);
}
@


1.944
log
@allowing matook's to guild
updating the is_clan_guard functoin
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.943 2004/10/24 19:25:17 boogums Exp $";
d2895 2
@


1.943
log
@taking xp away when killing guards,
making tsunami not affect guards
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.942 2004/08/14 01:21:50 boogums Exp $";
d68 1
d2878 15
a2892 1

d5029 2
a5030 7
    if ( 
         victim->spec_fun == spec_lookup("spec_honor_guard")
         || victim->spec_fun == spec_lookup("spec_demise_guard")
         || victim->spec_fun == spec_lookup("spec_posse_guard")
         || victim->spec_fun == spec_lookup("spec_zealot_guard")
         || victim->spec_fun == spec_lookup("spec_warlock_guard")  
       )
d5032 1
@


1.942
log
@reducing exp
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.941 2004/06/19 14:52:16 boogums Exp $";
d5011 12
d7952 15
@


1.941
log
@making thief/monks kailindo better
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.940 2004/05/02 00:54:24 boogums Exp $";
d5398 1
a5398 1
    //return 90 * xp / 100;
d5401 1
a5401 1
    return xp;
@


1.940
log
@new double xp stuff
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.939 2004/03/27 22:25:10 boogums Exp $";
d4243 7
a4249 1
  chance /= 2;
@


1.939
log
@t tweaking clan stuff
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.938 2004/03/27 16:41:46 boogums Exp $";
a5262 31
       case 11:
	    act("Seog says, I run quests, I am a questor, my name is Seog the questor.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 12:
	    act("Valder is still around ya know.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 13:
	    act("Smile or we'll sick Boogums on you.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 14:
	    act("BriarRose says I'm a little teapot....",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 15:
	    act("Earendil says, {YMAC'S RULE{x.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
       case 16:
	    act("You are so generous you share the wealth.",
		gch,NULL,NULL,TO_CHAR,FALSE);
            do_reward(gch,"all 500");
	    xp *= 2;
	    break;
d5264 1
a5264 1
	    act("Everybody, bow to your leader!",
a5277 5
       case 20:
	    act("Cyberdeath wonders when Boogums will finish the Church of Matook.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
a5307 10
       case 28:
	    xp *= 2;
	    act("Randal bestows the dark gift of unholy knowledge upon you.",
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
       case 29:
	    xp *= 2;
	    act("Matteo says, 'Get some sleep, you addict!'",
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
a5325 5
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
       case 34:
	    xp *= 2;
	    act("Did you know Rage likes to sniff dwarven panties?",
@


1.938
log
@making paladin change
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.937 2004/03/27 16:00:10 boogums Exp $";
d821 7
a5193 4
    /* smurf grouping extra */
    if (gch->race == race_lookup("smurf") && smurf_group_count(gch) > 1)
       xp = 3 * xp / 2; 

d5199 1
a5199 1
      xp = 115 * xp / 100;
a5252 5
       case 8:
	    act("Luria purrs contentedly in your lap!",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *= 2;
	    break;
a5319 5
       case 22:
	    act("Mindweaver says 'Let the  {YSPANKING{x BEGIN!!!!'.",
		gch,NULL,NULL,TO_CHAR,FALSE);
	    xp *=2;
	    break;
d5324 1
a5324 1
	       act("Hobkin thinks you deserve an extra level!",
a5341 5
		 gch, NULL, NULL, TO_CHAR, FALSE);
	    break;
       case 27:
	    xp *= 2;
	    act("Karag is a new Imm.  Ask him for alot of restrings.",
@


1.937
log
@warrior paladins get more of a boost when using holy weapons
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.936 2004/03/27 15:51:41 boogums Exp $";
d1389 1
a1389 1
           if ( ch->pcdata->old_class != class_lookup("warrior") )
@


1.936
log
@many changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.935 2003/12/07 20:42:45 boogums Exp $";
d1387 7
a1393 2
	 ch->mana += ( dam / 2 );
	 ch->hit += ( dam / 2 );
@


1.935
log
@making cp cap go higher
xp boost for clanners killing clanners
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.934 2003/11/22 15:08:32 boogums Exp $";
d1395 1
a1395 1
	      holy_effect(victim,wield->level,ch->alignment);
@


1.934
log
@moving check vampiric back into update.c with new parameters
also tweaked nethered weapon
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.933 2003/09/09 02:28:49 boogums Exp $";
d5186 9
a5194 1
    xp = 90 * xp / 100; /* Gradually step this down until it's about 75 */
d5450 2
a5451 1
    return 90 * xp / 100;
d5453 1
a5453 1
    //return xp;
@


1.933
log
@new message
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.932 2003/07/19 05:31:57 boogums Exp $";
d1448 1
a1448 1
    OBJ_DATA *weapon;
d1451 1
d1457 1
a1457 1
      number_percent() / 2 < ch->level / (weapon->enchanted?5:3)  &&
d1467 1
@


1.932
log
@new 2x exp message for slod
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.931 2003/07/19 04:39:34 boogums Exp $";
d3025 2
a3026 1
             send_to_char("Join a clan if you want to kill players.\n\r",ch);
d3032 1
a3032 1
             send_to_char("They aren't in a clan, leave them alone.\n\r",ch);
@


1.931
log
@we'll have to find another fix for the ruffian bug but good job ken
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.930 2003/07/10 16:49:56 ndagger Exp $";
d5219 1
a5219 1
	    act("This space for rent, pester BriarRose alot for details.",
@


1.930
log
@07/10/03 Nightdagger:  I think I squished the ruffian bug once and for all, here's hoping.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.929 2003/07/10 16:38:12 ndagger Exp $";
d3666 2
d3672 4
a3675 4
	     && (victim->position != POS_FIGHTING))  */


          if ((!IS_NPC(ch) && !IS_NPC(victim)) && (ch != victim))
@


1.929
log
@07/10/03 Nightdagger:  Changed check_killer to see if I can fix the ruffian bug.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.928 2003/06/22 04:54:29 boogums Exp $";
d3673 1
a3673 2
          if ((!IS_NPC(ch) && !IS_NPC(victim)) && (ch != victim) &&
             (ch->position != POS_FIGHTING)) 
@


1.928
log
@changing MW's 2xeps message and lowering exp some more
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.927 2003/06/14 19:58:55 boogums Exp $";
d3663 5
d3670 5
a3674 1
	     && (victim->position != POS_FIGHTING)) 
@


1.927
log
@changed restrain message
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.926 2003/06/14 19:53:11 boogums Exp $";
d5297 1
a5297 1
	    act("Mindweaver says 'Have a beer and a {YSPANKING{x!'.",
a5298 1
            obj_to_char(create_object(get_obj_index(3001),0,FALSE),gch);
d5429 1
a5429 1
    return 93 * xp / 100;
@


1.926
log
@adding the restrain spell to the infuse ability
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.925 2003/06/10 02:26:13 ndagger Exp $";
d7274 1
a7274 1
    
d7277 1
a7277 1
    send_to_char( "PANIC!!!  The CUFFS OF JUSTICE hold you fast!!!\n\r ", ch );
@


1.925
log
@06/09/03 Nightdagger:  Fixed a couple of double exp messages, added Matteo's.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.924 2003/06/07 21:48:58 boogums Exp $";
d7275 1
a7275 1
    if ( is_affected(ch,skill_lookup("cuffs of justice")) && number_percent() < 50 )
@


1.924
log
@another lower in xp_compute
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.923 2003/05/30 02:23:05 ndagger Exp $";
d5338 1
a5338 1
	    act("Be sure to tickle Volcanic if you see him.",
d5389 1
a5389 1
	    act("Nightdagger slams the door and says 'Another one one.'",
@


1.923
log
@05/29/03 Nightdagger:  All clan skills nerfed to prepare for new ones.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.922 2003/05/28 23:16:28 ndagger Exp $";
d5430 1
a5430 1
    return 96 * xp / 100;
@


1.922
log
@05/28/03 Nightdagger:  Added PK timer to garotte, since it doesn't start combat anymore
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.921 2003/05/25 15:21:45 boogums Exp $";
d1819 1
d1837 1
@


1.921
log
@fuckin breserk
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.920 2003/05/24 01:12:14 ndagger Exp $";
d8466 7
@


1.920
log
@05/23/03 Nightdagger:  I'm a fucking moron...fixed withstand wizdeath thing so it'll work
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.919 2003/05/24 00:31:40 ndagger Exp $";
d5690 2
a5691 1
    if (IS_AFFECTED(ch,AFF_BERSERK) || is_affected(ch,gsn_berserk)
@


1.919
log
@05/23/03 Nightdagger:  wiz_deaths should no longer report a withstand kill in a nodie room
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.918 2003/05/22 03:21:09 ndagger Exp $";
d2341 1
a2341 1
          if ( !is_affected(ch,skill_lookup("withstand death")) )
@


1.918
log
@05/21/03 Nightdagger:  added WIZ_DEATH output for nodie rooms
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.917 2003/05/21 01:41:15 boogums Exp $";
d2341 1
a2341 10
          raw_kill(victim,ch);
          died_in_room = ch->in_room;
          sprintf( log_buf, "%s got toasted by %s at %s [room %d]",
            (IS_NPC(victim) ? victim->short_descr : victim->name),
            (IS_NPC(ch) ? ch->short_descr : ch->name),
            died_in_room->name, died_in_room->vnum);
          log_string (log_buf);
          if (IS_NPC(victim))
            wiznet(log_buf, NULL, NULL, WIZ_MOBDEATHS, 0, 0);
          else
d2343 17
a2359 5
            wiznet(log_buf, NULL, NULL, WIZ_DEATHS, 0, 0);
            if (!is_clan(victim) )
            {
              pnet("$N died.", victim, NULL, PNET_DEATHS, 0, 0);
            }
d2361 2
a2362 2


@


1.917
log
@let the exp reduction begin!
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.916 2003/05/20 03:12:49 boogums Exp $";
d2342 19
@


1.916
log
@
looking into making flags less buggy
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.915 2003/05/19 01:29:48 boogums Exp $";
a4957 1
#ifdef COREY_TOOK_THIS_OUT_TO_TWEAK_IT 
a4977 21
#endif

    switch (level_range)
    {
  default :   base_exp =   0;   break;
  case -8 : base_exp =   2;   break;
  case -7 : base_exp =   7;   break;
  case -6 : base_exp =   13;   break;
  case -5 : base_exp =   20;   break;
  case -4 : base_exp =  26;   break;
  case -3 : base_exp =  50;   break;
  case -2 : base_exp =  65;   break;
  case -1 : base_exp =  70;   break;
  case  0 : base_exp =  90;   break;
  case  1 : base_exp =  130;   break;
  case  2 : base_exp =  170;   break;
  case  3 : base_exp = 210;   break;
  case  4 : base_exp = 270;   break;
  case  5 : base_exp = 310;   break;
    }

d5405 2
d5408 1
a5408 1
    return xp;
@


1.915
log
@tweaking exp
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.914 2003/05/13 04:14:40 ndagger Exp $";
d3653 5
a3657 3
		if( !(ch->clan == clan_lookup("posse") 
		      && IS_SET(victim->mhs,MHS_POSSE_ENEMY)) )
		{
d3665 1
a3665 1
		}
@


1.914
log
@05/12/03 Nightdagger:  Minor tweak to the tweak to garotte
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.913 2003/05/13 03:39:39 ndagger Exp $";
d4956 1
a4956 1
 
d4977 21
@


1.913
log
@05/12/03 Nightdagger:  Changed garotte, no longer aggies
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.912 2003/05/03 03:20:21 boogums Exp $";
d8576 1
a8576 1
       affect_strip(ch, gsn_hide);
@


1.912
log
@new 2xp messages
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.911 2003/03/16 18:08:42 boogums Exp $";
d8424 3
d8437 2
a8438 2
  send_to_char( "You better stick to choking your chicken.\n\r", ch );
  return;
d8443 2
a8444 2
  send_to_char( "You can't sneak up on anyone while you're fighting.\n\r", ch );
  return;
a8488 4
  check_killer(ch,victim);

  WAIT_STATE( ch, skill_table[gsn_garotte].beats );

d8545 1
d8560 1
a8560 1
	damage(ch,victim,wield->value[2],gsn_garotte,DAM_SLASH,TRUE,FALSE);
d8571 1
a8571 1
     damage( ch, victim, 0, gsn_kick,DAM_SLASH,TRUE,FALSE);
d8574 30
@


1.911
log
@making vamping harder
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.910 2003/03/11 03:48:50 boogums Exp $";
d5184 1
a5184 1
	    act("Now what did they ever do to you to deserve that?",
d5186 1
a5186 1
            gch->skill_points += 1;
d5190 1
a5190 1
	    act("A shard has fallen out of Halo's wallet into your own.",
d5215 1
a5215 1
	    act("Strife, Strife... oh what a life.",
d5235 1
a5235 1
	    act("Its not Rage's Birthday, but he's still an old fart.",
d5242 1
a5242 1
            do_reward(gch,"all 200");
d5246 1
a5246 1
	    act("Minister performs the last rites.",
d5248 1
a5248 1
	    xp *= 2;
d5251 1
a5251 1
	    act("Nimthas screams 'Eek!' and runs away.",
d5261 1
a5261 1
	    act("Tiag yells ... No Don't Say It!.",
d5272 1
a5272 1
	    act("Gillian says 'Have a beer!'.",
d5288 1
a5288 1
	    act("You spot Rage wearing a cowboy hat and samurai shirt!",
d5298 1
a5298 1
	    act("Stylee walks by, shagging a goat.",
d5303 1
a5303 1
	    act("Santiago secretes soething icky and gooey.",
d5323 1
a5323 1
	    act("'Aloha', says Poquah practicing for his trip!",
d5333 1
a5333 1
	    act("<Rent this space. Pester BriarRose alot for more details.",
d5343 1
a5343 1
	    act("Have you heard that a certain P-word yelling Immortal has returned to Boinga?",
d5348 1
a5348 1
	    act("In honor of ages gone by, enjoy this bottle and think of Poquah and Ruiner.",
@


1.910
log
@ ok made it harder
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.909 2003/03/11 03:38:07 boogums Exp $";
d1456 1
a1456 1
      number_percent() < ch->level / (weapon->enchanted?5:3)  &&
@


1.909
log
@t friggin odds
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.908 2003/03/11 03:01:14 boogums Exp $";
d1456 1
a1456 1
      number_percent() < ch->level + 5 / (weapon->enchanted?3:2)  &&
@


1.908
log
@ok vamping is now harder
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.907 2003/03/08 22:35:35 boogums Exp $";
d1454 1
a1454 1
      number_percent() * number_percent() < 5       &&
@


1.907
log
@lowered the chance
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.906 2003/03/08 21:42:46 boogums Exp $";
d1454 1
a1454 1
      number_percent() * number_percent() < 10       &&
@


1.906
log
@moved the necromancer vampiric touch check to bool damage in fight.c
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.905 2003/02/23 16:30:15 boogums Exp $";
d1454 1
a1454 1
      number_percent() * number_percent() < 25       &&
@


1.905
log
@t hmmm still not working
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.904 2003/02/21 04:47:23 boogums Exp $";
d1448 18
@


1.904
log
@ok trying to fix that withstand death thing
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.903 2003/02/01 07:39:30 boogums Exp $";
d4308 1
a4308 7
  	        //COREY THIS ONE LINE IS HTE ORIGIONAL fch->fighting = och;
                    fch->fighting = NULL;
                    fch->position = IS_NPC(fch) ? fch->default_pos : POS_STANDING;
                    update_pos( fch );
                    och->fighting = NULL;
                    och->position = IS_NPC(och) ? och->default_pos : POS_STANDING;
                    update_pos( och );
@


1.903
log
@possible fix for withstand death
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.902 2003/01/28 18:50:37 rusty Exp $";
d4308 7
a4314 1
  	        fch->fighting = och;
@


1.902
log
@lint fixes and make brief command more verbose
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.901 2003/01/23 23:53:51 ndagger Exp $";
d4815 2
@


1.901
log
@1/23/03 Nightdagger:  Fixed killer level restriction removing thingy, should work now.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.900 2003/01/23 23:05:13 ndagger Exp $";
d1692 2
a1693 2
       && IS_SET(ch->act,PLR_VAMP)
       && IS_SET(victim->act,PLR_VAMP)
@


1.900
log
@1/23/03 Nightdagger:  removed level limitations for KILLER flags in pkill
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.899 2002/12/23 01:54:33 boogums Exp $";
d3024 2
a3025 1

d3047 1
a3047 1

d3256 3
a3258 2
         CAN, however, attack KILLERS at any level!  Nightdagger 1/23/03            */

d3316 1
d3488 2
d3511 1
@


1.899
log
@buffies going out new kits going in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.898 2002/12/23 00:37:28 boogums Exp $";
d3022 4
a3025 1
          if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF))
d3253 5
a3257 1
         if (IS_SET(victim->act,PLR_THIEF) || IS_SET(victim->act,PLR_KILLER))
d3482 4
a3485 1
             if (IS_SET(victim->act,PLR_THIEF) || IS_SET(victim->act,PLR_KILLER))
@


1.898
log
@trying the buffy swap out thing on OLC
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.897 2002/12/02 05:24:17 boogums Exp $";
d1689 1
a1689 1
#ifdef COREYTEST
d1735 1
d1757 2
a1758 2
#endif

d1772 1
@


1.897
log
@turning off weather messages if brief room is togled on
more code wrapped in the wand kit
spells adjusted to be wandable and not
luria's message added to fight.c
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.896 2002/11/28 22:11:08 boogums Exp $";
d1443 4
d1688 69
@


1.896
log
@adding int eh check
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.895 2002/11/26 10:10:08 ndagger Exp $";
d5089 1
a5089 1
	    act("Firestorm is a Simp!",
d5207 1
a5207 1
	    act("BADOOF! Damn that was an experience!",
@


1.895
log
@11/26/02 Nightdagger:  added bleed to list of skills that check pkill login delay
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.894 2002/11/26 09:38:38 ndagger Exp $";
d2757 10
d3025 10
d3247 5
d5809 5
d6000 6
d6155 5
d6446 1
@


1.894
log
@11/26/02 Nightdagger:  Added throw to things that check pk login delay.  Added a failsafe to is_safe_spell for area affect spells and such.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.893 2002/11/26 08:47:06 ndagger Exp $";
d7633 6
@


1.893
log
@11/26/02 Nightdagger:  Code fixes and cleanup for pkill login delay.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.892 2002/11/26 06:53:11 boogums Exp $";
d3222 6
d3243 1
a3243 1

d5778 7
@


1.892
log
@half assed code going in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.891 2002/11/26 05:35:26 boogums Exp $";
a5935 5
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }
d5952 6
a6083 6
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

d6101 7
a6723 6
    if (is_clan(ch) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

d6735 7
a6923 6
    if (is_clan(ch) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

d6941 6
a7394 5
   if (is_clan(ch) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }
d7418 7
d9024 1
a9024 2
      send_to_char("Easy there sparky.  You just got here.  Read some notes and
such.\n\r",ch);
a9161 5
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }
d9190 6
d9338 2
a9339 1
   if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0 )
@


1.891
log
@adding a start pfight timer to combat IM scouters
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.890 2002/11/22 06:24:30 ndagger Exp $";
d317 3
d5927 1
a5927 1
        send_to_char("Huh?\n\r", ch);
d5936 5
d6083 5
d6385 5
d6559 5
d6921 6
d7392 5
d8756 5
d9017 7
d9158 5
d9332 5
@


1.890
log
@11/22/02 Nightdagger:  Added Kuno to double exp, changed Randal's message so it's cool.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.889 2002/11/19 04:42:15 boogums Exp $";
d6697 6
@


1.889
log
@added a timer to traps
user feedback for the aura of cthon spell
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.888 2002/11/16 22:52:51 boogums Exp $";
d5050 1
a5050 1
	    act("Pacifist has given you the power to heal all.",
d5163 1
a5163 1
	    act("Randal stops by, and does nothing special.",
@


1.888
log
@making it so demise actually GETS their skill and tweaked the flee
chance
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.887 2002/11/15 02:26:52 boogums Exp $";
d7036 1
a7036 1
    if ( is_affected(victim,skill_lookup("aura of cthon")) && number_percent() < 25 )
d7039 1
@


1.887
log
@adding the aura of cthon skill for demise
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.886 2002/11/04 16:01:01 rusty Exp $";
d7036 1
a7036 1
    if ( is_affected(victim,skill_lookup("aura of cthon")) && number_percent() < 40 )
@


1.886
log
@added do_grab movement cost
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.885 2002/11/04 15:57:34 rusty Exp $";
d7036 5
a7040 1

@


1.885
log
@Initial insert of Giant racial skill grab.  Just the structures and
command.  Has no affect yet.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.884 2002/10/28 04:57:18 boogums Exp $";
d9277 7
@


1.884
log
@putting bounty back in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.883 2002/10/05 03:40:58 boogums Exp $";
a55 1
/* line below added 26AUG00 by Boogums */
d57 1
d9245 33
@


1.883
log
@removing the 'keep the item in death code'
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.882 2002/10/03 03:25:34 boogums Exp $";
d2308 2
a2309 2
	  act("$p flashes with a black aura.",kch,weapon,NULL,TO_CHAR,FALSE);
	  act("$p flashes with a black aura.",kch,weapon,NULL,TO_ROOM,FALSE);
@


1.882
log
@chaning how wimpy works and updating dispel magic a bit
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.881 2002/10/02 14:49:38 boogums Exp $";
d4205 2
a4206 1
    int pc_item_in_count = 0;
d4281 1
d4345 1
a4345 1

a4395 1

@


1.881
log
@put a mummy check in do_breathe
fixed the id spelling mistake
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.880 2002/10/02 00:34:11 ndagger Exp $";
d2595 1
d2598 1
@


1.880
log
@10/01/02 Nightdagger- DWEEBS pop at temple altar now.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.879 2002/09/20 02:42:29 boogums Exp $";
d7914 6
@


1.879
log
@comm.c has my COREY code in it
fight.c has alagasters message changed
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.878 2002/09/09 15:55:34 boogums Exp $";
d4628 6
a4633 1
           char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
@


1.878
log
@made it so only nonclanners deaths tomobs appear on pnet
08sep02
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.877 2002/09/09 15:49:11 boogums Exp $";
d5052 1
a5052 1
	    act("Alagaster says POP ROCKS AND PLASTIC WRAP!!! ",
@


1.877
log
@09sep02
cleaned up spell_stalk, got rid of the unused variables
took the pnet message out of hte die part of fight.c
to big of a potential for abuse
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.876 2002/09/01 14:58:08 boogums Exp $";
d2556 4
a2559 1
          /*pnet("$N died.",victim,NULL,PNET_DEATHS,0,0);*/
@


1.876
log
@cleaning up the unused variable in firght.c
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.875 2002/09/01 14:55:06 boogums Exp $";
d2556 1
a2556 1
          pnet("$N died.",victim,NULL,PNET_DEATHS,0,0);
@


1.875
log
@tweaked the cuffs of justice affect when fleeing
tweaked out the stalk spell
testing on olc now
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.874 2002/08/29 02:50:09 boogums Exp $";
a7012 1
    int attempt_mod;
@


1.874
log
@made some changes in fight.c added some new imm messages and took
some other imm messages out
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.873 2002/06/29 03:41:31 boogums Exp $";
d7027 7
a7040 6
/*COREY PUG THE ATTEMPT HERE*/
    if (is_affected(ch,gsn_cuffs_of_justice))
	{attempt_mod = 4;}
    else
	{attempt_mod = 0;}
/*    for ( attempt = 0; attempt < 6; attempt++ ) */
d7042 1
a7042 1
    for ( attempt = attempt_mod; attempt < 6; attempt++ )
@


1.873
log
@28JUL02
minor tweak to the cuffs of justice affect on fleeing
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.872 2002/06/04 17:51:09 rusty Exp $";
d5034 1
a5034 1
	    act("A shard has fallen out of Poquah's wallet into your own.",
d5039 1
a5039 1
	    act("Dallas has given you the power to heal all.",
d5049 1
a5049 1
	    act("Prowler teaches you to do the Roxbury.",
d5054 1
a5054 1
	    act("Rage toasts you with a huge ass cup of Coffee.",
d5074 1
a5074 1
	    act("Ruiner of all things good.",
d5100 1
a5100 1
	    act("Robinhood hands you a golden arrow.",
d5125 1
a5125 1
	       act("Prowler thinks you deserve an extra level!",
d5137 1
a5137 1
	    act("Firestorm sits alone in his basement instead of going on a date, say 'SIMP!'",
d5177 1
a5177 1
	    act("<Rent this space. Pester Prowler alot for more details.",
@


1.872
log
@No MOBs vorpalling themselves
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.871 2002/05/30 16:31:21 poquah Exp $";
d7036 1
a7036 1
	{attempt_mod = 2;}
@


1.871
log
@up last_attacked_by_timer till 15000
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.870 2002/05/29 14:38:46 mud Exp $";
d1057 2
a1058 1
		damage( ch, ch, ch->hit/2, dt, dam_type, TRUE ,FALSE);
@


1.870
log
@Eliminate stupid warning without breaking things
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.869 2002/05/29 14:37:19 mud Exp $";
d2959 1
a2959 1
		victim->pcdata->last_attacked_by_timer = 15;
d3177 1
a3177 1
		victim->pcdata->last_attacked_by_timer = 15;
d3390 1
a3390 1
		victim->pcdata->last_attacked_by_timer = 15;
@


1.869
log
@Eliminate stupid warning
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.868 2002/05/29 14:35:26 rusty Exp $";
d4308 1
a4308 1
        OBJ_DATA *in, *in_next=NULL;
d4312 1
a4318 1
	  in_next = in->next_content;
@


1.868
log
@No more logging bef-buf and aft-buf
Items in bags end up in corpses.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.867 2002/05/24 15:03:13 rusty Exp $";
d4308 1
a4308 1
        OBJ_DATA *in, *in_next;
@


1.867
log
@Fixed negative moves thing with berserk skill
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.866 2002/05/22 18:00:41 rusty Exp $";
d1688 2
a1689 2
   sprintf(log_buf,"bef-buf:%s hit/dam:%d/%d dam: %d to %s",ch->name,ch->hitroll,ch->damroll,dam,victim->name);
   log_string(log_buf);
d1691 2
a1692 2
   sprintf(log_buf,"aft-buf:%s hit/dam:%d/%d dam: %d to %s",ch->name,ch->hitroll,ch->damroll,dam,victim->name);
   log_string(log_buf);
d4306 15
@


1.866
log
@All gems end up in corpses.
All items stolen within the last 10*number_fuzzy(5) ticks go into corpses.
Items taken by steal, loot, heat metal and disarm get timers
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.865 2002/05/21 20:20:58 rage Exp $";
d5536 2
a5537 2
  ch->move *= 50;
  ch->move /= UMAX(60,apply_chi(ch,100));
d5582 2
a5583 2
  ch->move *= 50;
  ch->move /= UMAX(60,apply_chi(ch,100));
@


1.865
log
@dropped potion costs for alchemy
added randomly teleporting portal for Slodhain area
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.864 2002/05/08 14:21:51 rusty Exp $";
d4300 9
a4308 4
    if(pc_item_in_count < 4 
       && (obj->wear_loc == WEAR_WIELD 
	   || obj->item_type == ITEM_GEM 
	   || obj->enchanted ) )
d5411 1
@


1.864
log
@Rotting items rot and all eq not in corpse goes into inventory in order to
unequip_char()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.863 2002/04/21 15:20:08 rusty Exp $";
d1048 1
a1048 1
	  && IS_WEAPON_STAT(wield,WEAPON_VORPAL) )
@


1.863
log
@Don't lose everything if you die, ooops
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.862 2002/04/21 15:08:47 rusty Exp $";
d4278 22
d4309 5
@


1.862
log
@Rearrange comments and {}'s in object loop to corpse in raw_kill()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.861 2002/04/21 14:54:54 mud Exp $";
a4266 1
#ifdef CODE_TEST_TOO
a4273 1
#endif
@


1.861
log
@Getting rid of stupidly placed # comment
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.860 2002/04/21 14:53:54 rusty Exp $";
d4267 1
d4275 1
d4292 1
a4292 2
else
{
d4343 1
a4343 1
}
@


1.860
log
@Only a few items go into corpse when you die.
Wielded weapon, gems and enchanted objects.
Maximum of 4 items as long as you have sac points, otherwise regular rules.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.859 2002/04/18 19:33:14 poquah Exp $";
d4275 1
a4275 1
  # PC's only lose a few items as long as they have sac points
@


1.859
log
@more gladiator changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.858 2002/04/18 17:09:10 poquah Exp $";
d4199 1
a4267 1
#ifdef CODETEST 
d4269 5
a4273 2
      obj_to_room(obj,ch->in_room);
#endif 
d4275 17
d4341 2
a4342 1
    }
@


1.858
log
@fix withstand and gladiators
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.857 2002/04/18 16:31:33 poquah Exp $";
d2899 1
a2899 1
	  if(IS_SET(ch->mhs,MHS_GLADIATOR) && (gladiator_info.type == 3 || gladiator_info.type == 4) && ch->pcdata->gladiator_team == victim->pcdata->gladiator_team)
d4549 1
a4549 1
	   (gladiator_info.type == 3 || gladiator_info.type == 4))
@


1.857
log
@fix gladiators
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.856 2002/04/11 03:17:38 boogums Exp $";
d2234 1
@


1.856
log
@adding posse skill cuffs of justice
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.855 2002/04/05 00:59:20 rusty Exp $";
d2229 10
d2270 2
a2271 12
       if (kch->clan == clan_lookup("smurf") 
           || victim->clan == clan_lookup("smurf"))
       {
          raw_kill(victim,kch);
          return TRUE;
       }
             /* Ch and Victim are both gladiators in Gladiator Combat */
             if (IS_SET(ch->mhs,MHS_GLADIATOR) &&
                 IS_SET(victim->mhs,MHS_GLADIATOR) &&
                 !IS_NPC(ch) &&
                 !IS_NPC(victim) &&
	         gladiator_info.started == TRUE)
d2273 1
a2273 1
                gladiator_kill(victim,ch);  
@


1.855
log
@Took PNET_MATOOK out of for() loop causing repeated spam
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.854 2002/04/01 22:00:05 rusty Exp $";
d6943 1
d6964 8
a6971 1
    for ( attempt = 0; attempt < 6; attempt++ )
@


1.854
log
@pnet matook option added
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.853 2002/04/01 21:05:44 rusty Exp $";
d2146 1
a2160 1
           pnet(cdbuf,NULL,NULL,PNET_MATOOK,0,0);
d2176 1
a2190 1
           pnet(cdbuf,NULL,NULL,PNET_MATOOK,0,0);
@


1.853
log
@Added pnet, wiznet like info for mortals
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.852 2002/03/12 15:26:05 rusty Exp $";
d2160 1
d2190 1
@


1.852
log
@Fixed wimpy
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.851 2002/03/12 03:38:37 mud Exp $";
d2442 1
d2546 1
d2550 1
d2552 2
a2553 1
       log_string( log_buf );
d2555 2
a2556 2
	      sprintf(cdbuf, "before return: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
@


1.851
log
@iOld damage curve removal
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.850 2002/03/11 09:49:23 rusty Exp $";
d2587 1
a2587 1
       &&   victim->hit <= victim->wimpy
@


1.850
log
@!iOld damage extra curve
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.849 2002/02/28 18:56:55 mud Exp $";
a1494 2
    if ( dam > 30 && !iOld)
       dam = (dam - 30)/2 + 30;
@


1.849
log
@fear change from is_safe_spell() to is_safe()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.848 2002/02/28 18:55:22 rusty Exp $";
d1495 2
@


1.848
log
@Fear checks is_safe_spell() and does a check_killer();
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.847 2002/02/25 17:19:42 poquah Exp $";
d7750 1
a7750 1
	    if(is_safe_spell(ch,victim))
@


1.847
log
@fix outofrange
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.846 2002/02/25 16:45:54 poquah Exp $";
d7750 3
d7784 1
@


1.846
log
@removed comment line
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.845 2002/02/25 16:44:21 poquah Exp $";
d2900 1
a2900 1
	  if (IS_SET(ch->act,PLR_NOOUTOFRANGE) && ch->level+8 < victim->level)
d2902 5
a2906 1
	    send_to_char("If you want to pick on someone that big turn "
d2908 11
a2918 1
	    return TRUE;
@


1.845
log
@fix death in glad with withstand death
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.844 2002/02/12 18:38:42 poquah Exp $";
a2490 1
             Remove while having crash problems 
@


1.844
log
@add obj != NULL check on smurf 2H resist
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.843 2002/02/12 18:35:54 poquah Exp $";
a2226 10
       /* Ch and Victim are both gladiators in Gladiator Combat */
       if (IS_SET(ch->mhs,MHS_GLADIATOR) &&
           IS_SET(victim->mhs,MHS_GLADIATOR) &&
           !IS_NPC(ch) &&
           !IS_NPC(victim) &&
	   gladiator_info.started == TRUE)
       {
          gladiator_kill(victim,ch);  
          return TRUE;
       }
d2264 11
d2489 1
d2491 1
a2491 1
             Remove while having crash problems */
@


1.843
log
@think I found the bug, checking now if it crashes olc
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.842 2002/02/12 18:31:39 poquah Exp $";
d1790 1
a1790 1
       if(IS_WEAPON_STAT(obj,WEAPON_TWO_HANDS))
@


1.842
log
@tracking down smurf combat crash bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.841 2002/02/11 19:38:23 poquah Exp $";
d1781 1
a1781 1
    /* Smurfs resist two handed weapons 
a1792 1
*/
@


1.841
log
@few new cstat stuffs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.840 2002/02/11 18:43:30 poquah Exp $";
d1781 1
a1781 1
    /* Smurfs resist two handed weapons */
d1793 1
@


1.840
log
@smurf check
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.839 2002/02/11 18:42:18 poquah Exp $";
d2336 1
d2338 3
d2382 1
d2384 3
d2396 1
d2398 3
d2407 2
d2411 1
d2413 3
@


1.839
log
@missing ch pass on smurf_grou_count
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.838 2002/02/11 18:34:10 poquah Exp $";
d4881 1
a4881 1
    if (gch->race == race_lookup("smurf") && smurf_group_count(ch) > 1)
@


1.838
log
@adding some smurf abilities
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.837 2002/02/10 04:14:07 boogums Exp $";
d4881 1
a4881 1
    if (gch->race == race_lookup("smurf") && smurf_group_count > 1)
@


1.837
log
@ok i forgot another condition, if the victim is in combat and the player
isn't they'll be able to kcharge into combat now
i think :)
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.836 2002/02/10 04:02:20 boogums Exp $";
d1781 13
d4879 4
@


1.836
log
@made a change to kcharge, they'll be able to kcharge in combat whoops
i just thought of somethign committing but will recommit in a second
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.835 2002/01/26 16:25:27 rage Exp $";
d8627 1
a8627 1
    /* if (victim->fighting != NULL)
d8629 2
d8633 1
d8635 1
a8635 1
*/
@


1.835
log
@whole mess of bug fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.834 2002/01/20 21:09:08 rage Exp $";
d8627 1
a8627 1
     if (victim->fighting != NULL)
d8632 1
@


1.834
log
@changed sequence of events for switching deities
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.833 2002/01/15 04:56:47 boogums Exp $";
d3155 1
a3155 1
bool is_safe_spell(CHAR_DATA *ch, CHAR_DATA *victim, bool area )
d3173 1
a3173 1
    if (victim->passenger != NULL && is_safe_spell(ch,victim->passenger,area) )
d3339 2
a3340 1

d3364 1
d4532 2
@


1.833
log
@ok added a check in fight.c to make sure that aggy mobs couldn't be
feared
have no idea why const.c is being updated sec
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.832 2001/12/20 15:13:07 rage Exp $";
d4556 1
@


1.832
log
@modified wait state on grenade
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.831 2001/12/17 17:29:25 rage Exp $";
d7691 1
@


1.831
log
@new bug fix for autosac not working
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.830 2001/12/17 17:13:21 rage Exp $";
d5576 1
a5576 1
    WAIT_STATE( ch, PULSE_VIOLENCE  );
@


1.830
log
@bug fix for mobs dying to themselves
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.829 2001/12/17 14:33:35 rage Exp $";
d1439 1
d2475 3
d2510 1
a2510 1
          ch->in_room->name, ch->in_room->vnum);
a2511 1
          raw_kill( victim,ch );
@


1.829
log
@ further debug attempt
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.828 2001/12/17 01:50:38 rage Exp $";
a2473 1
          raw_kill( victim,ch );
d2507 2
a2508 1
       log_string (log_buf);
@


1.828
log
@added one more debug line
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.827 2001/12/17 01:39:01 rage Exp $";
d2504 1
a2504 1
       sprintf( log_buf, "%s got %s by %s at %s [room %d]",
a2505 1
	  toast,
@


1.827
log
@another set of debug message
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.826 2001/12/17 01:32:39 rage Exp $";
a2471 2
	      sprintf(cdbuf, "beofre group_gain victim: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
a2472 2
	      sprintf(cdbuf, "afterbegroup_gain victim: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
a2474 2
	      sprintf(cdbuf, "after raw_kill victim: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
a2502 2
	      sprintf(cdbuf, "after gainexp victim: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
d2509 1
a2509 2
	      sprintf(cdbuf, "after wiznet toast message  victim: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
@


1.826
log
@more debug lines
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.825 2001/12/17 01:19:38 rage Exp $";
d2517 2
d2525 3
@


1.825
log
@insrt some debug strings for mobs sying to themselves
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.824 2001/12/14 13:54:47 rage Exp $";
a2232 2
	  sprintf(cdbuf, "Inside !IS_NPC(victim): victim: %s, ch: %s", victim->name, ch->name);
          log_string(cdbuf);
a2235 2
	    sprintf(cdbuf, "Inside !IS_NPC(victim): victim: %s, ch: %s", victim->name, ch->name);
            log_string(cdbuf);
a2240 2
	  sprintf(cdbuf, "Inside !IS_NPC(victim): victim: %s, ch: %s", victim->name, ch->name);
          log_string(cdbuf);
a2242 2
	     sprintf(cdbuf, "Inside !IS_NPC(victim): victim: %s, ch: %s", victim->name, ch->name);
             log_string(cdbuf);
a2247 2
	      sprintf(cdbuf, "Inside !IS_NPC(victim): victim: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
a2259 2
	  sprintf(cdbuf, "before groupgain: victim: %s, ch: %s", victim->name, ch->name);
          log_string(cdbuf);
a2265 2
	      sprintf(cdbuf, "beofre gain exp victim: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
a2269 2
	      sprintf(cdbuf, "after gainexp victim: %s, ch: %s", victim->name, ch->name);
              log_string(cdbuf);
d2472 2
d2475 2
d2479 2
d2509 2
@


1.824
log
@possible bug fix for mobs that get to POS_INCAP
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.823 2001/12/13 20:36:53 poquah Exp $";
d2233 3
d2238 2
d2245 2
d2249 2
d2256 2
d2270 2
d2278 2
d2284 2
@


1.823
log
@let smurfs gain exp on killing mobs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.822 2001/12/13 17:52:42 poquah Exp $";
d2143 1
a2143 1
	     !IS_SET(victm->comm,COMM_QUIET) &&
d2172 1
a2172 1
	     !IS_SET(victm->comm,COMM_QUIET) &&
d8968 1
a8968 1
    ch->move -= apply_chi(ch,(ch->level/15));
@


1.822
log
@smurfs cant steal, slice or cutpurse
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.821 2001/12/13 17:41:17 poquah Exp $";
a2223 7
       if (ch->clan == clan_lookup("smurf") 
           || victim->clan == clan_lookup("smurf"))
       {
          raw_kill(victim,ch);
          return TRUE;
       }

d2253 6
@


1.821
log
@smurf dying or killiing treat as no_die room
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.820 2001/12/13 17:10:51 poquah Exp $";
d7998 2
@


1.820
log
@sacred gaurdian doesnt send message if ch = victim
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.819 2001/12/09 16:20:22 poquah Exp $";
a2211 2
sprintf (wdbuf,"into death code we go");
log_string(wdbuf);
d2223 7
d4480 3
a4482 1
     if (IS_SET (victim->in_room->room_flags,ROOM_NODIE))
@


1.819
log
@remove debug code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.818 2001/12/09 16:07:38 poquah Exp $";
d3382 1
@


1.818
log
@debugging
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.817 2001/12/09 15:59:14 poquah Exp $";
a2234 2
sprintf (wdbuf,"here3");
log_string(wdbuf);
a2252 2
sprintf (wdbuf,"here2");
log_string(wdbuf);
a2254 6
sprintf (wdbuf,"here1");
log_string(wdbuf);
	                 sprintf(log_buf,"DEAD: Bef Grp%s kills %s by %s.",
   		            kch->name, victim->name, ch->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
log_string(log_buf);
a2255 4
	                 sprintf(log_buf,"DEAD: Aft Grp%s kills %s by %s.",
   		            kch->name, victim->name, ch->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);

a2299 4
	                 sprintf(log_buf,"DEAD: Bef group%s kills %s by %s.",
   		            kch->name, victim->name, ch->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
    	                 log_string(log_buf);
a2312 4
	                 sprintf(log_buf,"DEAD: Aft group%s kills %s by %s.",
   		            kch->name, victim->name, ch->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
    	                 log_string(log_buf);
a2427 4
	                 sprintf(log_buf,"DEAD: Bef %s kills %s by %s.",
   		            kch->name, victim->name, ch->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
    	                 log_string(log_buf);
a2436 3
	                 sprintf(log_buf,"DEAD: Aft %s kills %s by %s.",
   		            kch->name, victim->name, ch->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
a4571 4
	                 sprintf(log_buf,"DEAD: start%s kills %s.",
   		            ch->name, victim->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
log_string(log_buf);
a4605 4
	                 sprintf(log_buf,"DEAD: h1 %s kills %s.",
   		            ch->name, victim->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
log_string(log_buf);
a4613 4
	                 sprintf(log_buf,"DEAD: h2 %s kills %s.",
   		            ch->name, victim->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
log_string(log_buf);
a4636 4
	                 sprintf(log_buf,"DEAD: done %s kills %s.",
   		            ch->name, victim->name );
                         wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
log_string(log_buf);
@


1.817
log
@got one fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.816 2001/12/09 15:54:53 poquah Exp $";
d2264 1
a2264 1
             /*
a2265 1
*/
d4601 4
d4639 4
d4651 4
a4654 13
/*  if ( gch->level - lch->level >= 5 )
  {
      send_to_char( "You are too high for this group.\n\r", gch );
      continue;
  }

  if ( gch->level - lch->level <= -5 )
  {
      send_to_char( "You are too low for this group.\n\r", gch );
      continue;
  }
*/

d4678 4
@


1.816
log
@add !IS_NPC to group kr checks
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.815 2001/12/09 15:49:08 poquah Exp $";
a2318 1
/*
a2335 1
*/
@


1.815
log
@groupu stuff crashing us
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.814 2001/12/09 15:44:46 poquah Exp $";
d2322 1
a2322 1
                            if(kch != gch && is_same_group(kch,gch))  
@


1.814
log
@think its group gain
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.813 2001/12/09 15:39:15 poquah Exp $";
d2319 1
d2337 1
@


1.813
log
@more debug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.812 2001/12/09 15:22:09 poquah Exp $";
d2264 1
d2266 1
@


1.812
log
@debugging death cdode
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.811 2001/12/09 15:10:39 poquah Exp $";
d2313 4
d2330 4
@


1.811
log
@working out bug in death code with charmies
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.810 2001/12/07 19:11:59 poquah Exp $";
d2235 2
d2255 2
d2259 2
@


1.810
log
@eliminate nonclanners giving out toast messages
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.809 2001/12/07 17:05:44 poquah Exp $";
d2255 3
d2259 3
d2435 4
d2448 3
@


1.809
log
@do not save on death, hopefully to save peoples eq from crashes caused by deaths
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.808 2001/12/06 18:43:40 poquah Exp $";
d2266 2
a2267 1
             if (!kill_by_plain_mob)
@


1.808
log
@removing debug line
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.807 2001/12/06 18:31:51 rage Exp $";
d2450 1
a2450 1
	        to get back their EQ or duplicate items */
d2452 1
@


1.807
log
@bug fix in kill updates
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.806 2001/12/06 18:11:43 poquah Exp $";
a2291 6
	                 sprintf(wdbuf,"DEAD: $N %d killed %s %d ",
                                 kch->level,
                                 victim->name,
                                 victim->level);
	                 wiznet(wdbuf,kch,NULL,WIZ_DEATHS,0,0);
                      log_string( wdbuf );
a2313 6
	                 sprintf(wdbuf,"DEAD: $N %d killed %s %d  maybe not here",
                                 kch->level,
                                 victim->name,
                                 victim->level);
	                 wiznet(wdbuf,kch,NULL,WIZ_DEATHS,0,0);
                      log_string( wdbuf );
@


1.806
log
@found the hanging
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.805 2001/12/06 17:45:29 poquah Exp $";
d2306 1
a2306 1
                     for ( gch = char_list ; gch != NULL; gch_next = gch->next )
@


1.805
log
@add a log string to see if I can get to it in the log
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.804 2001/12/06 17:26:39 poquah Exp $";
a2307 2
	                    gch_next = gch->next;

@


1.804
log
@add a debug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.803 2001/12/06 17:21:43 poquah Exp $";
d2212 2
d2297 1
d2327 1
@


1.803
log
@working on why kr and cstats are not updating
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.802 2001/12/05 17:07:04 poquah Exp $";
d2319 5
@


1.802
log
@move gladiator_data and highlander_data to pcdata
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.801 2001/12/05 16:44:43 poquah Exp $";
d2290 6
@


1.801
log
@missing ending )
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.800 2001/12/05 16:39:01 poquah Exp $";
d4269 2
a4270 2
	   ch->highlander_data[ALL_KILLS], 
	   ch->highlander_data[REAL_KILLS]); 
d4273 1
a4273 1
   ch->highlander_data[ALL_KILLS] += victim->highlander_data[ALL_KILLS];
d4276 2
a4277 2
   ch->highlander_data[ALL_KILLS] += 1;
   ch->highlander_data[REAL_KILLS] += 1;
d4280 6
a4285 6
   ch->pcdata->perm_hit += (victim->highlander_data[ALL_KILLS] +1) * 100;
   ch->pcdata->perm_mana += (victim->highlander_data[ALL_KILLS] +1) * 100; 
   ch->pcdata->perm_move += (victim->highlander_data[ALL_KILLS] +1) * 100;
   ch->max_hit += (victim->highlander_data[ALL_KILLS] +1) * 100;
   ch->max_mana += (victim->highlander_data[ALL_KILLS] +1) * 100; 
   ch->max_move += (victim->highlander_data[ALL_KILLS] +1) * 100;
d4296 2
a4297 2
	   ch->highlander_data[ALL_KILLS], 
	   ch->highlander_data[REAL_KILLS]); 
@


1.800
log
@new kr stats
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.799 2001/12/04 17:37:29 poquah Exp $";
d2301 1
a2301 1
                            if(kch != gch && is_same_group(kch,gch) 
@


1.799
log
@remove final debug lines and remove a declared unused variable form rawkill
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.798 2001/12/04 15:23:33 poquah Exp $";
d2290 24
a2313 2
                         kch->killer_data[PC_KILLS] += 1 ;
	                 victim->killer_data[PC_DEATHS] += 1 ;
a3426 1
              ch->killer_data[PC_ATTACKS] += 1;
@


1.798
log
@removed debug messages
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.797 2001/12/03 21:42:36 poquah Exp $";
a2234 2
sprintf(wdbuf,"DEAD By Charmie:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a2241 2
sprintf(wdbuf,"DEAD By Player:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a2246 2
sprintf(wdbuf,"DEAD By Mob:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a2252 2
sprintf(wdbuf,"DEAD No Withstand KCH:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2265 2
sprintf(wdbuf,"DEAD False Plain Mob:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2267 2
sprintf(wdbuf,"DEAD victim not char:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2286 2
sprintf(wdbuf,"DEAD KCH: %s CH: %s Victim: %s ",kch->name,ch->name,victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a2289 2
sprintf(wdbuf,"DEAD Update stats:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2311 2
sprintf(wdbuf,"DEAD check trumps to char:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2317 2
sprintf(wdbuf,"DEAD check trumps to char could be posse:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2324 2
sprintf(wdbuf,"DEAD check trumps to char char needs trump:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2334 2
sprintf(wdbuf,"DEAD remove ruffian from victim: $N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2338 2
sprintf(wdbuf,"DEAD set killer: $N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a4417 1
    char wdbuf[MAX_STRING_LENGTH];
@


1.797
log
@extra } I think
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.796 2001/12/03 21:38:14 poquah Exp $";
a4445 2
sprintf(wdbuf,"DEAD inside raw_kill:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a4509 2
sprintf(wdbuf,"DEAD raw kill make corpse:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a4533 2
sprintf(wdbuf,"DEAD end raw kill:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
@


1.796
log
@maybe have it
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.795 2001/12/03 18:34:54 poquah Exp $";
d2417 16
a2432 16
             if (((kch->hit*100)/kch->max_hit) < 10)
                strcpy(toast,"edged out");
             if (((kch->hit*100)/kch->max_hit) >= 10)
                strcpy(toast,"toasted");
             if (((kch->hit*100)/kch->max_hit) >= 25)
                strcpy(toast,"trashed");
             if (((kch->hit*100)/kch->max_hit) >= 50)
                strcpy(toast,"flattened");
             if (((kch->hit*100)/kch->max_hit) >= 75)
                strcpy(toast,"crushed");
             if (((kch->hit*100)/kch->max_hit) >= 100)
                strcpy(toast,"slaughtered");

             /* Charmed mob did killing */
             if (kch != ch)
                sprintf( cdbuf, "%s{W%s{x got %s by {W%s{x controlled by {W%s{x\n\r",
d2435 2
a2436 2
             else
                sprintf( cdbuf, "%s{W%s{x got %s by {W%s{x\n\r",
d2440 8
a2447 9
             for ( d = descriptor_list; d != NULL; d = d->next )
             {
                CHAR_DATA *victm;

                victm = d->original ? d->original : d->character;
                if ( d->connected == CON_PLAYING && is_clan(victm) )
                   send_to_char(cdbuf, victm);
             }

a2448 1
             }
@


1.795
log
@add some code to look for storage chars
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.794 2001/12/03 15:11:23 poquah Exp $";
a2211 2
sprintf(wdbuf,"DEAD victim:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a2219 2
sprintf(wdbuf,"DEAD Gladiator:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a2226 2
sprintf(wdbuf,"DEAD NoDie Room:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a2232 2
sprintf(wdbuf,"DEAD Victim Not NPC:$N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
a2399 2
sprintf(wdbuf,"DEAD give out bounty: $N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2449 4
             else
             {
sprintf(wdbuf,"DEAD Didnt go into anything:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2451 2
sprintf(wdbuf,"DEAD raw kill: $N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2456 2
sprintf(wdbuf,"DEAD outside charmie/player: $N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2459 2
sprintf(wdbuf,"DEAD Had withstand: $N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
a2513 2
sprintf(wdbuf,"DEAD end: $N killed %s",victim->name);
wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
@


1.794
log
@fix die command, add back in last_death_timer
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.793 2001/12/03 14:33:16 poquah Exp $";
d2329 5
d3456 3
@


1.793
log
@fix reporting deaths to plain mob
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.792 2001/12/03 07:57:26 poquah Exp $";
a2288 1
/*
a2290 1
*/
a2414 1
/*
a2415 1
*/
@


1.792
log
@think I got flag problem
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.791 2001/12/03 07:46:24 poquah Exp $";
a2425 6
             } /* Killed by Charmed mob or player */
             else
             {
sprintf(wdbuf,"DEAD Didnt go into anything:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
             }
d2456 7
@


1.791
log
@almost there
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.790 2001/12/03 07:29:18 poquah Exp $";
d2345 1
d2347 3
a2349 3
                      }
                      else
                      {
d2352 4
a2355 3
                         kch->trumps += 1 ;
                         sprintf( cdbuf, "%s trump++ killing %s at %d",kch->name,
                         victim->name,kch->in_room->vnum );
@


1.790
log
@working on debuggging
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.789 2001/12/03 06:48:41 poquah Exp $";
d2288 2
d2291 3
a2293 1
                   { /* Victim has not been killed recently */
d2309 2
d2415 4
a2418 1
                   } /* Victim has not died recently */
@


1.789
log
@maybe have it
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.788 2001/12/03 06:40:01 poquah Exp $";
d2290 10
a2299 10
	           if ( HAS_KIT(kch,"nethermancer") && 
		     HAS_KIT(victim,"nethermancer") &&
		     number_percent() < get_curr_stat(kch,STAT_INT) &&
		     number_percent() < kch->hit / 80 )
	           { /* give nether flag to weapon, if they have one */
	              OBJ_DATA *weapon;

	           if ( ( weapon = get_eq_char( kch, WEAR_WIELD ) ) != NULL )
	              {
		      SET_BIT(weapon->value[4],WEAPON_NETHER);
d2302 2
a2303 2
                      }
	           }
d2305 3
a2307 3
	           if (str_cmp(kch->pcdata->last_kill,victim->name) &&
                       str_cmp(victim->pcdata->last_killed_by,kch->name))
                   {
d2310 16
a2325 16
                      kch->killer_data[PC_KILLS] += 1 ;
	              victim->killer_data[PC_DEATHS] += 1 ;
                   /* update clan statistics */
                   if(kch->clan == clan_lookup("honor"))
                      honor_kills += 1;
                   if(kch->clan == clan_lookup("posse"))
                      posse_kills += 1;
                   if(kch->clan == clan_lookup("warlock"))
                      warlock_kills += 1;
                   if(kch->clan == clan_lookup("demise"))
                      demise_kills += 1;
                   if(kch->clan == clan_lookup("zealot"))
                      zealot_kills += 1;
                   if(kch->clan == clan_lookup("avarice"))
                      avarice_kills += 1;
	           }
d2329 6
a2334 6
	           if(victim->trumps == 0 && kch->level - victim->level <= 8 
	              && !IS_SET(victim->wiznet,PLR_RUFFIAN)
	              && !IS_SET(victim->act,PLR_DWEEB)
	              && !IS_SET(victim->act,PLR_THIEF) 
	              && str_cmp(kch->pcdata->last_kill,victim->name) )
	           {
d2337 6
a2342 6
                      if (kch->clan == clan_lookup("Posse") &&
                          IS_SET(victim->mhs,MHS_POSSE_ENEMY))
                         sprintf( cdbuf, "%s NO TRUMP POSSE ENEMY killing %s at %d",kch->name, victim->name,kch->in_room->vnum );
                   }
                   else
                   {
d2345 9
a2353 9
                      kch->trumps += 1 ;
                      sprintf( cdbuf, "%s trump++ killing %s at %d",kch->name,
                      victim->name,kch->in_room->vnum );
                   }
                   log_string( cdbuf );

	           kch->pcdata->last_kill = str_dup( victim->name );
	           victim->pcdata->last_killed_by = str_dup( kch->name );
	           victim->trumps = UMAX(0,victim->trumps -1);
d2356 4
a2359 4
	           if(IS_SET(victim->wiznet,PLR_RUFFIAN))
	              REMOVE_BIT(victim->wiznet,PLR_RUFFIAN);
	           if(kch->trumps >= 3 && !IS_SET(kch->act,PLR_KILLER))
                   {
d2362 9
a2370 11
	              SET_BIT(kch->act,PLR_KILLER);
	              send_to_char("*** You are now a KILLER! ***\n\r",kch);
	              sprintf(wdbuf,"$N got a (KILLER) by murdering %s",victim->name);
	              wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
                   }

                   if (IS_SET(victim->act,PLR_THIEF))
                      REMOVE_BIT(victim->act,PLR_THIEF);
                   else
                   {
                      if(victim->trumps >=3 && IS_SET(victim->act,PLR_KILLER))
d2372 24
a2395 22
	                 victim->trumps = 2;
                         REMOVE_BIT(victim->act,PLR_KILLER);
	              }
	              else
                         REMOVE_BIT(victim->act,PLR_KILLER);
		   }

	           if (!str_cmp(victim->name,kch->pcdata->last_attacked_by))
	   	      kch->pcdata->last_attacked_by_timer = 0;

                   if (kch->clan == clan_lookup("warlock") &&
		       IS_SET(victim->mhs,MHS_WARLOCK_ENEMY))
		      REMOVE_BIT(victim->mhs,MHS_WARLOCK_ENEMY);
                   if (kch->clan == clan_lookup("zealot") &&
     		       IS_SET(victim->mhs,MHS_ZEALOT_ENEMY))
		      REMOVE_BIT(victim->mhs,MHS_ZEALOT_ENEMY);
                   if (kch->clan == clan_lookup("posse") &&
		       IS_SET(victim->mhs,MHS_POSSE_ENEMY))
		      REMOVE_BIT(victim->mhs,MHS_POSSE_ENEMY);
                   if (kch->clan == clan_lookup("honor") &&
		       IS_SET(victim->mhs,MHS_HONOR_ENEMY))
		      REMOVE_BIT(victim->mhs,MHS_HONOR_ENEMY);
d2399 11
a2409 10
                   if (victim->pcdata->bounty > 0 )
                   {
                      kch->gold += victim->pcdata->bounty ;
	              act("You collect the bounty on $N.",kch,NULL,victim,TO_CHAR,FALSE);
	              sprintf(log_buf,"%s collects a %ld gold bounty on %s.",
   		         kch->name, victim->pcdata->bounty, victim->name );
                      wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
    	              log_string(log_buf);
 	              victim->pcdata->bounty = 0 ;
                   } 
a2410 1
                } /* Victim has not died recently */
d2420 32
a2451 38
              }
                if (((kch->hit*100)/kch->max_hit) < 10)
                   strcpy(toast,"edged out");
                if (((kch->hit*100)/kch->max_hit) >= 10)
                   strcpy(toast,"toasted");
                if (((kch->hit*100)/kch->max_hit) >= 25)
                   strcpy(toast,"trashed");
                if (((kch->hit*100)/kch->max_hit) >= 50)
                   strcpy(toast,"flattened");
                if (((kch->hit*100)/kch->max_hit) >= 75)
                   strcpy(toast,"crushed");
                if (((kch->hit*100)/kch->max_hit) >= 100)
                   strcpy(toast,"slaughtered");

                /* Charmed mob did killing */
                if (kch != ch)
                   sprintf( cdbuf, "%s{W%s{x got %s by {W%s{x controlled by {W%s{x\n\r",
		      victim->desc == NULL ? "({YLinkdead{x) " : "",
		      victim->name,toast,ch->name,kch->name);
                else
                   sprintf( cdbuf, "%s{W%s{x got %s by {W%s{x\n\r",
		      victim->desc == NULL ? "({YLinkdead{x) " : "",
		      victim->name,toast,kch->name);

                for ( d = descriptor_list; d != NULL; d = d->next )
                {
                   CHAR_DATA *victm;

                   victm = d->original ? d->original : d->character;

	           /* Show toast message to ch as well 
                   if ( d->connected == CON_PLAYING &&
                      d->character != kch &&
                      is_clan(victm) )
                   */
                   if ( d->connected == CON_PLAYING && is_clan(victm) )
                      send_to_char(cdbuf, victm);
                }
d2455 1
a2455 5
                raw_kill(victim,ch);

                /* Save the victims pfile to avoid people crashing us
	           to get back their EQ or duplicate items */
	        save_char_obj(victim);
d2457 3
a2459 1
             } /* Killed by Charmed mob or player */
@


1.788
log
@blah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.787 2001/12/03 06:30:15 poquah Exp $";
d2415 7
a2421 1
                if (((kch->hit*100)/ch->max_hit) < 10)
d2423 1
a2423 1
                if (((kch->hit*100)/ch->max_hit) >= 10)
d2425 1
a2425 1
                if (((kch->hit*100)/ch->max_hit) >= 25)
d2427 1
a2427 1
                if (((kch->hit*100)/ch->max_hit) >= 50)
d2429 1
a2429 1
                if (((kch->hit*100)/ch->max_hit) >= 75)
d2431 1
a2431 1
                if (((kch->hit*100)/ch->max_hit) >= 100)
a2467 5
             else
             {
sprintf(wdbuf,"DEAD Didnt go into anything:$N killed %s",victim->name);
wiznet(wdbuf,kch,NULL,WIZ_FLAGS,0,0);
              }
@


1.787
log
@blah define balh
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.786 2001/12/03 06:27:03 poquah Exp $";
d2462 5
@


1.786
log
@more debiugggin
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.785 2001/12/03 06:03:15 poquah Exp $";
d4454 1
@


1.785
log
@add some debug lines in death code3
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.784 2001/12/02 06:46:53 boogums Exp $";
d2462 2
d4455 2
d4521 2
d4547 2
@


1.784
log
@ok there's something esle going on here
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.783 2001/12/02 05:53:03 boogums Exp $";
a2187 2
/*HEY COREY you added the line below*/
/*  raw_kill(victim,ch);*/
d2212 2
d2222 2
d2231 2
d2239 2
d2243 2
d2252 2
d2259 2
d2267 2
d2282 2
d2286 2
d2308 2
d2327 2
d2335 2
d2343 2
d2354 2
d2360 2
d2397 2
d2453 2
d2465 2
d2521 2
@


1.783
log
@let's see if this works
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.782 2001/12/02 00:42:30 boogums Exp $";
d2189 1
a2189 1
  raw_kill(victim,ch);
@


1.782
log
@putting everything back the way i found it
-coreu
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.781 2001/12/02 00:33:23 boogums Exp $";
d2188 2
@


1.781
log
@t trying something else
-boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.780 2001/12/02 00:22:48 boogums Exp $";
d4387 1
a4387 1
/*    for ( door = 0; door <= 5; door++ )
d4399 2
a4400 3
*/
/*hey corey you commntend out hgtre below line*/
    /*ch->in_room = was_in_room;*/
@


1.780
log
@weirder and weirder
-copreu
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.779 2001/12/02 00:16:33 boogums Exp $";
d4387 1
a4387 1
    for ( door = 0; door <= 5; door++ )
d4399 1
a4399 1

@


1.779
log
@ok i'm investigating stuff
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.778 2001/12/01 23:23:54 poquah Exp $";
d4399 1
@


1.778
log
@changed death_timer to last_Death_timer
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.777 2001/12/01 23:16:57 poquah Exp $";
d4293 2
a4294 2
  if (ch->material == 0)
  {
d4297 1
a4297 1
  }
d4399 2
a4400 1
    ch->in_room = was_in_room;
@


1.777
log
@working on death code bugs and new tracking fields
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.776 2001/12/01 06:21:17 boogums Exp $";
d2268 1
a2268 1
                   if(victim->pcdata->death_timer == 0)
d2379 1
a2379 1
                victim->pcdata->death_timer = 5;
@


1.776
log
@ok talking out what i did, don't seem to work
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.775 2001/12/01 06:15:49 boogums Exp $";
a2187 2
/*hey corey you added this line below*/
/*  raw_kill(victim,ch);*/
d2212 1
d2265 1
a2265 1
             {
d2267 3
a2269 1
                {
d2290 13
a2364 14
                   /* update clan statistics */
                   if(kch->clan == clan_lookup("honor"))
                      honor_kills += 1;
                   if(kch->clan == clan_lookup("posse"))
                      posse_kills += 1;
                   if(kch->clan == clan_lookup("warlock"))
                      warlock_kills += 1;
                   if(kch->clan == clan_lookup("demise"))
                      demise_kills += 1;
                   if(kch->clan == clan_lookup("zealot"))
                      zealot_kills += 1;
                   if(kch->clan == clan_lookup("avarice"))
                      avarice_kills += 1;

d2376 4
a4410 1

@


1.775
log
@ok, i thinks that THIS is the THIS
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.774 2001/12/01 06:13:51 boogums Exp $";
d2189 1
a2189 1
  raw_kill(victim,ch);
@


1.774
log
@ok i thinks THIS is where it goes
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.773 2001/12/01 06:01:29 boogums Exp $";
d2189 1
a2189 1
  raw_kill(victim,victim);
@


1.773
log
@ok that wasn't it taking it out now
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.772 2001/12/01 05:54:07 boogums Exp $";
d2188 2
@


1.772
log
@ok, i think i figured out the die bug, checking now
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.771 2001/11/30 17:40:10 poquah Exp $";
a3974 2
/*hey corey you just added this for the die bug*/
  raw_kill(victim,victim);
@


1.771
log
@add group_gain so you get exp for killing mobs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.770 2001/11/30 16:28:53 poquah Exp $";
a2184 1

d3975 2
@


1.770
log
@made sure kch was inititalized in all possible cases where it could be used
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.769 2001/11/30 16:19:28 poquah Exp $";
d2435 1
@


1.769
log
@bad declaration of kch, missing *
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.768 2001/11/30 15:43:50 poquah Exp $";
d2243 5
@


1.768
log
@change cstats and rewrite whole fight code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.767 2001/11/29 17:24:10 poquah Exp $";
d1432 1
a1432 1
    CHAR_DATA *gch,*gch_next, kch;
@


1.767
log
@finally got cstat all debugged
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.766 2001/11/29 17:03:35 poquah Exp $";
d1432 1
a1432 1
    CHAR_DATA *gch,*gch_next;
d1435 1
a1435 1
    bool fGladiatorKill = FALSE;
d2213 17
a2229 2
       if (!IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))
          group_gain( ch, victim );
d2233 4
a2236 15
          if (!IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH)) 
	  {        
             sprintf( log_buf, "%s killed by %s at %d",victim->name,
                (IS_NPC(ch) ? ch->short_descr : ch->name),ch->in_room->vnum );
             log_string( log_buf );

             /* Ch and Victim are both gladiators in Gladiator Combat */
             if (IS_SET(ch->mhs,MHS_GLADIATOR) &&
	         IS_SET(victim->mhs,MHS_GLADIATOR) &&
		 !IS_NPC(ch) &&
	         gladiator_info.started == TRUE)
	     {
		fGladiatorKill = TRUE;
                gladiator_kill(victim,ch);  
	     }
d2238 1
a2238 11
          /* Ch and Victim are both gladiators in Gladiator Combat */
	  if (fGladiatorKill)
	     return TRUE;

      /*
       * Dying penalty:
       * 2/3 way back to previous level.
       */
       
          if ( victim->exp > exp_per_level(victim,victim->pcdata->points) 
             * victim->level ) 
d2240 4
a2243 21
             if (IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH)) 
	     {
                if (!IS_SET (ch->in_room->room_flags,ROOM_NODIE)
		   && !IS_SET(ch->mhs,MHS_HIGHLANDER))
		{
                   gain_exp( victim, 
		   (exp_per_level(victim,victim->pcdata->points)
                   * victim->level - victim->exp)/4 );
		}
                raw_kill( victim, ch );            
                return TRUE;
             }
	     else 
	     {
                if (!IS_SET (ch->in_room->room_flags,ROOM_NODIE)
		   && !IS_SET(ch->mhs,MHS_HIGHLANDER))
		{
                   gain_exp( victim, 
		   (exp_per_level(victim,victim->pcdata->points)
                   * victim->level - victim->exp)*2/3 );
		}
d2246 3
d2250 8
d2259 18
a2276 1
       } /*Victim not NPC */
d2278 6
a2283 16
       if(!IS_SET(ch->mhs,MHS_HIGHLANDER) 
	 && !IS_SET(victim->mhs,MHS_HIGHLANDER))
       {
       /* tell clan members other clan members died -Rusty */
       if(is_clan(ch) && is_clan(victim) 
	  && !IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))
       {
          if(victim != ch)
          {
	  /* nethermancers */
	  if ( HAS_KIT(ch,"nethermancer") && 
		HAS_KIT(victim,"nethermancer") &&
		number_percent() < get_curr_stat(ch,STAT_INT) &&
		number_percent() < ch->hit / 80 )
	  { /* give nether flag to weapon, if they have one */
	      OBJ_DATA *weapon;
d2285 73
a2357 6
	      if ( ( weapon = get_eq_char( ch, WEAR_WIELD ) ) != NULL )
	      {
		  SET_BIT(weapon->value[4],WEAPON_NETHER);
	  act("$p flashes with a black aura.",ch,weapon,NULL,TO_CHAR,FALSE);
	  act("$p flashes with a black aura.",ch,weapon,NULL,TO_ROOM,FALSE);
	      }
d2359 34
a2392 20
	  }
	     if (str_cmp(ch->pcdata->last_kill,victim->name) &&
		 str_cmp(victim->pcdata->last_killed_by,ch->name))
             {
                ch->killer_data[PC_KILLS] += 1 ;
	        victim->killer_data[PC_DEATHS] += 1 ;

              if(ch->clan == clan_lookup("honor"))
                 honor_kills += 1;
              if(ch->clan == clan_lookup("posse"))
                 posse_kills += 1;
              if(ch->clan == clan_lookup("warlock"))
                 warlock_kills += 1;
              if(ch->clan == clan_lookup("demise"))
                 demise_kills += 1;
              if(ch->clan == clan_lookup("zealot"))
                 zealot_kills += 1;
              if(ch->clan == clan_lookup("avarice"))
                 avarice_kills += 1;
	     }
d2394 1
a2394 13
	     if(victim->trumps == 0 && ch->level - victim->level <= 8 
	       && !IS_SET(victim->wiznet,PLR_RUFFIAN)
	       && !IS_SET(victim->act,PLR_DWEEB)
	       && !IS_SET(victim->act,PLR_THIEF) 
	       && str_cmp(ch->pcdata->last_kill,victim->name) )
	     {
                if (ch->clan == clan_lookup("Posse") &&
                    IS_SET(victim->mhs,MHS_POSSE_ENEMY))
                {
                   sprintf( cdbuf, "%s NO TRUMP POSSE ENEMY killing %s at %d",ch->name,
                      victim->name,ch->in_room->vnum );
                }
                else
d2396 1
a2396 20
                   ch->trumps += 1 ;
                   sprintf( cdbuf, "%s trump++ killing %s at %d",ch->name,
                      victim->name,ch->in_room->vnum );
                }
                log_string( cdbuf );
	     }
	     /*free_string( ch->pcdata->last_kill );*/
	     ch->pcdata->last_kill = str_dup( victim->name );
	     /*free_string( ch->pcdata->last_killed_by );*/
	     victim->pcdata->last_killed_by = str_dup( ch->name );
	     victim->trumps = UMAX(0,victim->trumps -1);
	     if(IS_SET(victim->wiznet,PLR_RUFFIAN))
	        REMOVE_BIT(victim->wiznet,PLR_RUFFIAN);
	     if(ch->trumps >= 3 && !IS_SET(ch->act,PLR_KILLER))
             {
	        SET_BIT(ch->act,PLR_KILLER);
	        send_to_char("*** You are now a KILLER! ***\n\r",ch);
	        sprintf(wdbuf,"$N got a (KILLER) by murdering %s",victim->name);
	        wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
	     }
d2398 1
d2400 8
a2407 1
          } /* Victim not Ch */
d2409 1
a2409 23
if (((ch->hit*100)/ch->max_hit) < 10)
   strcpy(toast,"edged out");
if (((ch->hit*100)/ch->max_hit) >= 10)
   strcpy(toast,"toasted");
if (((ch->hit*100)/ch->max_hit) >= 25)
   strcpy(toast,"trashed");
if (((ch->hit*100)/ch->max_hit) >= 50)
   strcpy(toast,"flattened");
if (((ch->hit*100)/ch->max_hit) >= 75)
   strcpy(toast,"crushed");
if (((ch->hit*100)/ch->max_hit) >= 100)
   strcpy(toast,"slaughtered");

          sprintf( cdbuf, "%s{W%s{x got %s by {W%s{x\n\r",
		 victim->desc == NULL ? "({YLinkdead{x) " : "",
		 victim->name,toast,ch->name);
/*
          sprintf( cdbuf, "{W%s{x got toasted by {W%s{x\n\r",
		  victim->name,ch->name);
*/
          for ( d = descriptor_list; d != NULL; d = d->next )
          {
             CHAR_DATA *victm;
d2411 21
a2431 1
             victm = d->original ? d->original : d->character;
d2433 26
a2458 11
	     /* Show toast message to ch as well 
             if ( d->connected == CON_PLAYING &&
                d->character != ch &&
                is_clan(victm) )
             */
             if ( d->connected == CON_PLAYING &&
                is_clan(victm) )
                send_to_char(cdbuf, victm);
          }
       } /* If ch clan and victim clan and victim no WSD */    
       } /* If ch and victim not highlanders */  
d2460 1
d2471 1
a2471 155

	/* Savant stuff 
	if ( ch != victim && IS_SET(ch->mhs,MHS_SAVANT) &&
		IS_SET(victim->mhs,MHS_SAVANT) && !IS_NPC(ch) &&
			!IS_NPC(victim) )
	{
		OBJ_DATA *obj;
	    if ( ch->pcdata->savant > 100 &&
		 number_percent() < victim->pcdata->savant &&
		 number_percent() < ch->level &&
		 number_percent() < victim->level &&
		 (obj=get_eq_char(ch,WEAR_WIELD)) != NULL)
	    {
		SET_BIT(obj->value[4],WEAPON_SCION);
	act("$p flares with a brilliant light!",ch,obj,NULL,TO_CHAR,FALSE);
	act("$p flares with a brilliant light!",ch,obj,NULL,TO_ROOM,FALSE);
		REMOVE_BIT(ch->mhs,MHS_SAVANT);
		ch->pcdata->savant = 0;
	    }

	    REMOVE_BIT(victim->mhs,MHS_SAVANT);
	    victim->pcdata->savant = 0;
       } 
       */

       /* if charmie kills last attacked by of master, wipe last attack by */
       /* dump the flags */
       /*
       if (ch != victim && !IS_NPC(ch) && !is_same_clan(ch,victim)
          && !IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))
	  */
       if (!IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH)
	   && ch != victim
	   && ((!IS_NPC(ch) && !is_same_clan(ch,victim))
	       || (IS_NPC(ch) && ch->master != NULL 
		   && !is_same_clan(ch->master,victim)))) 
       {
	  if (!IS_NPC(ch))
	  {
	     if (!str_cmp(victim->name,ch->pcdata->last_attacked_by))
		ch->pcdata->last_attacked_by_timer = 0;

             if (ch->clan == clan_lookup("warlock") &&
		 IS_SET(victim->mhs,MHS_WARLOCK_ENEMY))
		 REMOVE_BIT(victim->mhs,MHS_WARLOCK_ENEMY);
             if (ch->clan == clan_lookup("zealot") &&
		 IS_SET(victim->mhs,MHS_ZEALOT_ENEMY))
		 REMOVE_BIT(victim->mhs,MHS_ZEALOT_ENEMY);
             if (ch->clan == clan_lookup("posse") &&
		 IS_SET(victim->mhs,MHS_POSSE_ENEMY))
		 REMOVE_BIT(victim->mhs,MHS_POSSE_ENEMY);
             if (ch->clan == clan_lookup("honor") &&
		 IS_SET(victim->mhs,MHS_HONOR_ENEMY))
		 REMOVE_BIT(victim->mhs,MHS_HONOR_ENEMY);
	  }
	  else
	  {
	     if (!str_cmp(victim->name,ch->master->pcdata->last_attacked_by))
		ch->master->pcdata->last_attacked_by_timer = 0;

             if (ch->master->clan == clan_lookup("warlock") &&
		 IS_SET(victim->mhs,MHS_WARLOCK_ENEMY))
		 REMOVE_BIT(victim->mhs,MHS_WARLOCK_ENEMY);
             if (ch->clan == clan_lookup("zealot") &&
		 IS_SET(victim->mhs,MHS_ZEALOT_ENEMY))
		 REMOVE_BIT(victim->mhs,MHS_ZEALOT_ENEMY);
             if (ch->clan == clan_lookup("posse") &&
		 IS_SET(victim->mhs,MHS_POSSE_ENEMY))
		 REMOVE_BIT(victim->mhs,MHS_POSSE_ENEMY);
             if (ch->clan == clan_lookup("honor") &&
		 IS_SET(victim->mhs,MHS_HONOR_ENEMY))
		 REMOVE_BIT(victim->mhs,MHS_HONOR_ENEMY);
	  }

          if(IS_NPC(ch))
	  {
             if (IS_SET(victim->act,PLR_THIEF))
                REMOVE_BIT(victim->act,PLR_THIEF);
             else
             {
                if(victim->trumps >=3 && IS_SET(victim->act,PLR_KILLER))
                {
	           victim->trumps = 2;
                   REMOVE_BIT(victim->act,PLR_KILLER);
	        }
	        else
                   REMOVE_BIT(victim->act,PLR_KILLER);
             }
	  }
	  else
	  {
             if(   !IS_SET(ch->mhs,MHS_HIGHLANDER)
             && !IS_SET(victim->mhs,MHS_HIGHLANDER))
             {
                if (IS_SET(victim->act,PLR_THIEF))
                   REMOVE_BIT(victim->act,PLR_THIEF);
                else
                {
                   if(victim->trumps >=3 && IS_SET(victim->act,PLR_KILLER))
                   {
	              victim->trumps = 2;
                      REMOVE_BIT(victim->act,PLR_KILLER);
	           }
	           else
                      REMOVE_BIT(victim->act,PLR_KILLER);
		}
             }
          } 
       }

       if ( !IS_NPC(victim) && victim->pcdata->bounty > 0 && ch != victim && !IS_NPC(ch) )
       {
            ch->gold += victim->pcdata->bounty ;
	    act("You collect the bounty on $N.",ch,NULL,victim,TO_CHAR,FALSE);
	    sprintf(log_buf,"%s collects a %ld gold bounty on %s.",
		ch->name, victim->pcdata->bounty, victim->name );
            wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);
 	    log_string(log_buf);
 	    victim->pcdata->bounty = 0 ;
       } 

       raw_kill( victim,ch );
  
       /* Save the victims pfile to avoid people crashing us
	  to get back their EQ or duplicate items */
       if (!IS_NPC(victim))
	  save_char_obj(victim);

        /* RT new auto commands */

       if ( !IS_NPC(ch) && IS_NPC(victim) )
       {
          OBJ_DATA *coins;

          corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 

          if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
             corpse && corpse->contains) /* exists and not empty */
             do_get( ch, "all corpse" );

          if (IS_SET(ch->act,PLR_AUTOGOLD) &&
               corpse && corpse->contains  && /* exists and not empty */
               !IS_SET(ch->act,PLR_AUTOLOOT))
             if ((coins = get_obj_list(ch,"gcash",corpse->contains))
               != NULL)
                do_get(ch, "all.gcash corpse");
            
          if ( IS_SET(ch->act, PLR_AUTOSAC) )
	  {
             if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
                return TRUE;  /* leave if corpse has treasure */
             else
                do_sacrifice( ch, "corpse" );
	  }
       } /* ch not NPC and victim is */
@


1.766
log
@continued with cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.765 2001/11/29 09:53:40 poquah Exp $";
d2303 1
a2303 7
/*
extern sh_int avarice_kills;
extern sh_int demise_kills;
extern sh_int posse_kills;
extern sh_int warlock_kills;
extern sh_int zealot_kills;
extern sh_int honor_kills;
a2305 1
*/
@


1.765
log
@remove cstat stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.764 2001/11/29 09:47:27 poquah Exp $";
d2312 1
a2322 1
*/
@


1.764
log
@error error will robisinson
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.763 2001/11/29 09:23:02 poquah Exp $";
d2301 3
a2309 2
                ch->killer_data[PC_KILLS] += 1 ;
	        victim->killer_data[PC_DEATHS] += 1 ;
d2322 1
@


1.763
log
@add a quick and dirty cstat
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.762 2001/11/25 05:21:16 poquah Exp $";
d2301 6
@


1.762
log
@show toast message to ch as well
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.761 2001/11/25 04:51:01 poquah Exp $";
d2303 12
d2351 2
@


1.761
log
@pray for compile
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.760 2001/11/25 04:48:45 poquah Exp $";
d2367 1
d2370 3
@


1.760
log
@workiohng out compile errors
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.759 2001/11/25 04:43:13 poquah Exp $";
d5112 1
a5112 1
            affect_strip(gch,spell_lookup("haste"));
d5115 1
a5115 1
    	    af.type      = spell_lookup("haste");
@


1.759
log
@add affect_data af and fix remote_bit to remove_bit for 2X exp
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.758 2001/11/25 04:39:20 poquah Exp $";
d5096 1
a5096 1
            REMOVE_BIT(gch,AFF_SANCTUARY);
d5112 2
a5113 2
            affect_strip(gch,gsn_sanctuary);
            REMOTE_BIT(gch,AFF_SANCTUARY);
d5115 1
a5115 1
    	    af.type      = gsn_haste;
@


1.758
log
@new 2X exp things
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.757 2001/11/25 01:33:20 mud Exp $";
d4693 1
d5096 1
a5096 1
            REMOTE_BIT(gch,AFF_SANCTUARY);
@


1.757
log
@Var declarations in comm.c and OOC FALSE for can_see() in fight.c
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.756 2001/11/25 01:26:38 rusty Exp $";
d5092 34
@


1.756
log
@Webpage crash/bug fixes applied
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.755 2001/11/06 23:39:18 rage Exp $";
d212 1
a212 1
  if (IS_AWAKE(rch) && rch->fighting == NULL && can_see(rch,victim) )
@


1.755
log
@added in "iron" and "steel" vuln to elves
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.754 2001/10/24 23:48:20 poquah Exp $";
d212 1
a212 1
  if (IS_AWAKE(rch) && rch->fighting == NULL)
d4660 1
a4660 1
  for ( obj = ch->carrying; obj != NULL; obj = obj_next )
d4666 3
a4668 3
      if ( ( IS_OBJ_STAT(obj, ITEM_ANTI_EVIL)    && IS_EVIL(ch)    )
      ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_GOOD)    && IS_GOOD(ch)    )
      ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch) ) )
d4670 2
a4671 2
    act( "You are zapped by $p.", ch, obj, NULL, TO_CHAR ,FALSE);
    act( "$n is zapped by $p.",   ch, obj, NULL, TO_ROOM ,FALSE);
d4673 1
a4673 1
    obj_to_room( obj, ch->in_room );
d6983 1
a6983 1
    if ( !IS_NPC(ch) && IS_NPC(victim) )
@


1.754
log
@oopsy syntax error in new 2x exp messages
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.753 2001/10/24 23:47:07 poquah Exp $";
d1768 11
@


1.753
log
@add new double exp day messages
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.752 2001/10/18 20:09:35 rusty Exp $";
d5072 1
a5072 1
	    act("Have you heard that a certain "P"-word yelling Immortal has returned to Boinga?",
@


1.752
log
@Upped the victim->pcdata->last_attacked_by_timer  from 5 to 15 ticks
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.751 2001/10/17 03:02:47 boogums Exp $";
d5054 26
@


1.751
log
@adding in the honor guard honor clan spell
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.750 2001/10/14 04:08:43 rage Exp $";
d2914 1
a2914 1
		victim->pcdata->last_attacked_by_timer = 5;
d3132 1
a3132 1
		victim->pcdata->last_attacked_by_timer = 5;
d3345 1
a3345 1
		victim->pcdata->last_attacked_by_timer = 5;
@


1.750
log
@added some stuff for water elemental stuff
small change to wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.749 2001/10/03 23:48:50 rage Exp $";
d1530 7
a1536 1

@


1.749
log
@bug fix, changed a * into a / ni damage application
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.748 2001/10/03 23:37:18 rage Exp $";
a1225 4
    /* check for blade barrier */
    if (is_affected( victim, gsn_blade_barrier))
	damage(victim, ch, dam/50, gsn_blade_barrier, DAM_SLASH, TRUE, FALSE); 
 
@


1.748
log
@changed class damage to adjust *only* on oldclass

modified damage messages to max at 120, instead of 160
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.747 2001/10/02 23:59:55 rage Exp $";
d1213 1
a1213 1
		dam = dam * 95 * 100;
@


1.747
log
@more damage code changesx..vulns moved to base damage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.746 2001/09/28 20:28:36 rage Exp $";
d1192 1
a1192 1
       Adjust damage bsed on class and oldclass */   
d1196 21
a1216 1
		  * class_table[ch->pcdata->old_class].dam_mod) /10000 ;
a1766 12
    if ( dam > 1 && !IS_NPC(victim) 
         &&   victim->pcdata->condition[COND_DRUNK]  > 10 )
       dam = 9 * dam / 10;

    if ( dam > 1 && IS_AFFECTED(victim, AFF_SANCTUARY) )
       dam /= 2;

    if ( dam > 1 && ( (IS_AFFECTED(victim, AFF_PROTECT_EVIL) && IS_EVIL(ch))
    ||         (IS_AFFECTED(victim, AFF_PROTECT_GOOD) && IS_GOOD(ch))
    ||	(is_affected(victim,gsn_protect_neutral) && IS_NEUTRAL(ch)) ))
       dam -= dam / 4;

d1926 12
d1948 1
a1948 1
      dam += iOld ? base_dam/2 : base_dam/3;
d2609 1
a2609 1
    else if ( dam <=  90 ) { vp1 = "well aimed";    vp2 = "{CDISEMBOWELS{x";
d2611 1
a2611 1
    else if ( dam <= 100 ) { vp1 = "calm";    vp2 = "{CDISMEMBERS{x";
d2613 1
a2613 1
    else if ( dam <= 115 ) { vp1 = "wicked";    vp2 = "{CANNIHILATES{x";
d2615 1
a2615 1
    else if ( dam <= 130 ) { vp1 = "wicked";    vp2 = "{COBLITERATES{x";
d2617 1
a2617 1
    else if ( dam <= 145 ) { vp1 = "barbaric";    vp2 = "{CMASSACRES{x";
d2619 1
a2619 1
    else if ( dam <= 160 ) { vp1 = "controlled";    vp2 = "{CERADICATES{x";
@


1.746
log
@more changes to damage code...missed a bit with base_dam, and adjust class modifiers
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.745 2001/09/28 00:03:15 rage Exp $";
d1113 1
a1113 2
            dam += 2 * ( base_dam * diceroll/300);
            if (ch->class == 3) dam += dam/4;
d1928 1
a1928 1
      dam += iOld ? dam/2 : dam/3;
@


1.745
log
@New version of damage code, after testing
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.743 2001/09/27 23:31:34 rage Exp $";
d1090 2
d1196 1
a1196 1
      dam += base_dam * ( class_table[ch->class].dam_mod  
@


1.744
log
@back to original fight code, with damage messages:
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.741 2001/09/22 17:53:01 rage Exp $";
d66 1
a66 1
void  handle_critical( CHAR_DATA *ch, int *damage, int dam_type, int diceroll );
d734 1
a734 1
    int dam;
d1067 8
d1076 1
a1076 1
    dam = dam * 11/10;
d1078 1
a1078 11
      /* Rockbiters rock with hand to hand  BIFF! */
      if ( sn == gsn_hand_to_hand &&
	  ( ch->race == race_lookup("rockbiter") ||
	    is_affected(ch,gsn_stonefist) ) )
          dam += ch->level / 3;   

	/* so do ogres.  just not quite as much.  and giants */
    if ( sn == gsn_hand_to_hand && 
	( (ch->race == race_lookup("ogre") || ch->race == race_lookup("giant") ) ) )
	dam += ch->level / 4;
    
d1085 1
a1085 1
        dam = 2 * dam + (dam * 2 * percent / 100);
d1092 1
a1092 1
	dam += (dam * get_skill(ch,gsn_morph)) / 130;
d1094 1
a1094 1
	dam += dam/10;
d1100 1
a1100 1
	dam += ( dam / 5 ); /* 20% hbonus */
d1111 2
a1112 2
            dam += 2 * ( dam * diceroll/300);
      if (ch->class == 3) dam += dam/4;
d1124 1
a1124 1
  		dam += 2 * ( dam * diceroll/300);
d1129 1
a1129 1
  dam *= 2;
d1131 1
a1131 1
  dam = dam * 3 / 2;
d1134 1
a1134 1
       dam = dam * 3 / 2;
d1138 1
a1138 1
	dam += dam * 9/10; 
d1143 1
a1143 1
      dam *= 2 + (ch->level / 12); 
d1145 1
a1145 1
      dam *= 2 + (ch->level / 10);
d1148 1
a1148 1
        dam *= 11/10;
d1159 1
a1159 2
       dam *= 2 + (ch->level / 10);
       dam *= 11/10;
d1161 11
a1172 1
     }
d1180 1
a1180 1
  dam = 1;
d1188 1
a1188 1
       dam += (dam * (ch->size -2)/10);
d1194 1
a1194 1
      dam = dam * ( class_table[ch->class].dam_mod  
d1198 1
a1198 1
 	dam = dam * 110 / dam;
d1201 1
a1201 1
    handle_critical(  ch, &dam,  dam_type, diceroll_save );
a2555 1
    char buf4[32];
d2559 1
a2559 4
 
  sprintf(buf4, "Damage: %d", dam);
  send_to_room(buf4, ch->in_room);
 
a2679 1

d8626 1
a8626 1
void  handle_critical( CHAR_DATA *ch, int *damage, int dam_type, int diceroll )
d8692 1
a8692 1
    (*damage) = (100+bonus) * (*damage) / 100;
@


1.743
log
@added some debug messages for damage code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.742 2001/09/27 23:10:59 rage Exp $";
d66 1
a66 1
void  handle_critical( CHAR_DATA *ch, int *damage, int dam_type, int diceroll, int base_dam );
d734 1
a734 1
    int dam, base_dam = 0;
a1066 8
      
      /* use base damage for all adjustments */
      /* if you change anything from this point on, */
      /* be sure to use (dam += base_dam * modifier ) */
      
      base_dam = dam; 
      
      
d1068 7
a1074 1
    dam += base_dam / 10;
d1076 5
a1080 1
      
d1087 1
a1087 1
        dam += 2 * base_dam + (base_dam * 2 * percent / 100);
d1094 1
a1094 1
	dam += (base_dam * get_skill(ch,gsn_morph)) / 130;
d1096 1
a1096 1
	dam += base_dam/10;
d1102 1
a1102 1
	dam += ( base_dam / 5 ); /* 20% hbonus */
d1113 2
a1114 2
            dam += 2 * ( base_dam * diceroll/300);
            if (ch->class == 3) dam += dam/4;
d1126 1
a1126 1
  		dam += 2 * ( base_dam * diceroll/300);
d1131 1
a1131 1
        dam += base_dam;
d1133 1
a1133 1
        dam += base_dam / 2;
d1136 1
a1136 1
       dam += base_dam / 2;
d1140 1
a1140 1
	dam += base_dam * 9/10; 
d1145 1
a1145 1
      dam += base_dam * (2 + (ch->level / 12)); 
d1147 1
a1147 1
      dam += base_dam * (2 + (ch->level / 10));
d1150 1
a1150 1
        dam += base_dam/10;
d1161 2
a1162 1
       dam += base_dam * (2 + (ch->level / 10));
d1164 1
a1166 11
     if ( sn == gsn_hand_to_hand &&
	  ( ch->race == race_lookup("rockbiter") ||
	    is_affected(ch,gsn_stonefist) ) )
          dam += ch->level / 3;   

	/* so do ogres.  just not quite as much.  and giants */
    if ( sn == gsn_hand_to_hand && 
	( (ch->race == race_lookup("ogre") || ch->race == race_lookup("giant") ) ) )
	dam += ch->level / 4;	


d1173 1
a1173 1
      dam = 1;
d1181 1
a1181 1
       dam += (base_dam * (ch->size -2)/10);
d1187 1
a1187 1
      dam += base_dam * ( class_table[ch->class].dam_mod  
d1191 1
a1191 1
 	dam += base_dam / 10;
d1194 1
a1194 1
    handle_critical(  ch, &dam,  dam_type, diceroll_save, base_dam );
a2550 2
    sprintf(buf4,"Damage: %d", dam);
    send_to_room(buf4, ch->in_room);
d2553 4
a2556 1
  
d2677 1
d8624 1
a8624 1
void  handle_critical( CHAR_DATA *ch, int *damage, int dam_type, int diceroll, int base_dam )
d8690 1
a8690 1
    (*damage) += (100+bonus) * (base_dam) / 100;
@


1.742
log
@first round of changes to damage code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.741 2001/09/22 17:53:01 rage Exp $";
d2556 1
d2558 2
a2682 1

@


1.741
log
@more cavalier fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.740 2001/09/22 15:20:45 boogums Exp $";
d66 1
a66 1
void  handle_critical( CHAR_DATA *ch, int *damage, int dam_type, int diceroll );
d734 1
a734 1
    int dam;
d1067 8
d1076 1
a1076 1
    dam = dam * 11/10;
d1078 1
a1078 11
      /* Rockbiters rock with hand to hand  BIFF! */
      if ( sn == gsn_hand_to_hand &&
	  ( ch->race == race_lookup("rockbiter") ||
	    is_affected(ch,gsn_stonefist) ) )
          dam += ch->level / 3;   

	/* so do ogres.  just not quite as much.  and giants */
    if ( sn == gsn_hand_to_hand && 
	( (ch->race == race_lookup("ogre") || ch->race == race_lookup("giant") ) ) )
	dam += ch->level / 4;
    
d1085 1
a1085 1
        dam = 2 * dam + (dam * 2 * percent / 100);
d1092 1
a1092 1
	dam += (dam * get_skill(ch,gsn_morph)) / 130;
d1094 1
a1094 1
	dam += dam/10;
d1100 1
a1100 1
	dam += ( dam / 5 ); /* 20% hbonus */
d1111 2
a1112 2
            dam += 2 * ( dam * diceroll/300);
      if (ch->class == 3) dam += dam/4;
d1124 1
a1124 1
  		dam += 2 * ( dam * diceroll/300);
d1129 1
a1129 1
  dam *= 2;
d1131 1
a1131 1
  dam = dam * 3 / 2;
d1134 1
a1134 1
       dam = dam * 3 / 2;
d1138 1
a1138 1
	dam += dam * 9/10; 
d1143 1
a1143 1
      dam *= 2 + (ch->level / 12); 
d1145 1
a1145 1
      dam *= 2 + (ch->level / 10);
d1148 1
a1148 1
        dam *= 11/10;
d1159 1
a1159 2
       dam *= 2 + (ch->level / 10);
       dam *= 11/10;
d1161 11
a1172 1
     }
d1180 1
a1180 1
  dam = 1;
d1188 1
a1188 1
       dam += (dam * (ch->size -2)/10);
d1194 1
a1194 1
      dam = dam * ( class_table[ch->class].dam_mod  
d1198 1
a1198 1
 	dam = dam * 110 / dam;
d1201 1
a1201 1
    handle_critical(  ch, &dam,  dam_type, diceroll_save );
d8627 1
a8627 1
void  handle_critical( CHAR_DATA *ch, int *damage, int dam_type, int diceroll )
d8693 1
a8693 1
    (*damage) = (100+bonus) * (*damage) / 100;
@


1.740
log
@yanking cavalier code it's just commented
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.739 2001/09/22 15:01:01 boogums Exp $";
a426 1
/*
a429 1

a434 1
*/
@


1.739
log
@many thanks to Rage for help on getting the cavalier kit in
trying what he suggested
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.738 2001/09/22 00:10:48 boogums Exp $";
d427 1
a427 1

d437 1
a437 1

@


1.738
log
@yanked cavalier kit, don't know why it's crashing when they login
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.737 2001/09/21 21:41:37 boogums Exp $";
d428 2
a429 2
/*
    if ( group_has_cavalier( ch ) &&
d437 1
a437 1
*/
@


1.737
log
@hmmm back to the old figure stuff out code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.736 2001/09/21 01:30:05 boogums Exp $";
d428 1
a428 1

d437 1
@


1.736
log
@tweaked the cavalier ral attack per Rage's suggestion
thanks Rage :)
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.735 2001/09/20 03:27:43 boogums Exp $";
a299 1
     int  cavalier_base =10;
d429 2
a430 4
    if (ch->kit == kit_lookup("cavalier") )
    {
	cavalier_base = 20;
    }
a431 2
    if ( group_has_cavalier( ch ) &&
	number_percent () < cavalier_base )
@


1.735
log
@19sep01
taking the ability to throw while mounted away
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.734 2001/09/20 03:10:31 boogums Exp $";
d300 1
d428 7
d436 1
a436 1
	number_percent () < (ch->pcdata->sac / 8 ) )
@


1.734
log
@19SEP01
Putting the cavalier kit in going to try on OOC
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.733 2001/09/12 04:19:50 poquah Exp $";
d5530 5
@


1.733
log
@Fix Posse enemy buf
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.732 2001/09/02 08:54:21 guerrand Exp $";
d425 10
@


1.732
log
@in
xp gins reset
xp gains reset
bug with undead flag fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.731 2001/08/30 19:51:48 rage Exp $";
d2259 12
a2270 3
                ch->trumps += 1 ;
                sprintf( cdbuf, "%s trump++ killing %s at %d",ch->name,
                   victim->name,ch->in_room->vnum );
@


1.731
log
@fix bug with mobs collecting bounties
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.730 2001/08/30 01:30:04 guerrand Exp $";
d5021 5
a5025 2
    /* Gradual XP reduction. */
    return 60 * xp / 100;
d7330 1
a7330 1
    if (IS_SET(victim->act, ACT_UNDEAD))
@


1.730
log
@Bug fix with bounty - suicide gives you the money
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.729 2001/08/30 01:16:22 guerrand Exp $";
d2434 1
a2434 1
       if ( !IS_NPC(victim) && victim->pcdata->bounty > 0 && ch != victim )
@


1.729
log
@Some enhances to logging for bounty.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.728 2001/08/30 01:03:23 guerrand Exp $";
d2434 1
a2434 1
       if ( !IS_NPC(victim) && victim->pcdata->bounty > 0 )
@


1.728
log
@Added bounty command.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.727 2001/08/25 01:43:40 guerrand Exp $";
d2441 1
@


1.727
log
@xp reduction
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.726 2001/08/20 17:21:15 poquah Exp $";
d2433 10
@


1.726
log
@fix shield block to use the 'split' instead of 'chance' variable
chance was used up in the code for successful shield block, it
wasnt meant to be used in the split calculation/check.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.725 2001/08/20 03:04:40 poquah Exp $";
d5011 1
a5011 1
    return 63 * xp / 100;
@


1.725
log
@forgot a && on honor fix
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.724 2001/08/20 03:02:48 poquah Exp $";
d3695 1
a3695 1
	       chance -= ( get_skill(victim,gsn_shield_block) / 10 );
d3697 1
a3697 1
	       if ( number_percent()<chance)
@


1.724
log
@fix Honor's enemy code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.723 2001/08/19 20:56:23 guerrand Exp $";
d2876 1
a2876 1
               ch->clan == clan_lookup("outcast"))
d3093 2
a3094 2
              (victim->clan == clan_lookup("loner") ||
               victim->clan == clan_lookup("outcast"))
@


1.723
log
@Fixed bug with midnight cloak
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.722 2001/08/19 20:49:01 guerrand Exp $";
d2875 2
d3093 2
@


1.722
log
@XP drop again.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.721 2001/08/10 01:15:53 poquah Exp $";
d1196 3
a1198 2
  if ( ch->fighting == victim && is_affected(ch,gsn_midnight_cloak) &&
       ( victim->level - ch->level ) >= -5 ) /* no more than 5 levels above vict */
d1203 1
@


1.721
log
@working on honor enemy code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.720 2001/08/09 14:25:37 rusty Exp $";
d5005 1
a5005 1
    return 66 * xp / 100;
@


1.720
log
@Chance of nethering upped a bit
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.719 2001/08/08 06:01:40 poquah Exp $";
a2872 2
              (ch->clan == clan_lookup("loner") ||
               ch->clan == clan_lookup("outcast")) && 
a3088 2
              (ch->clan == clan_lookup("loner") ||
               ch->clan == clan_lookup("outcast")) && 
@


1.719
log
@last missing &&
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.718 2001/08/08 05:59:07 poquah Exp $";
d2232 1
a2232 1
		number_percent() < ch->hit / 100 )
@


1.718
log
@missing a couple more &&
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.717 2001/08/08 05:57:50 poquah Exp $";
d3305 1
a3305 1
               ch->clan == clan_lookup("outcast")) 
@


1.717
log
@missing &&
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.716 2001/08/08 05:45:51 poquah Exp $";
d3092 1
a3092 1
               ch->clan == clan_lookup("outcast")) 
@


1.716
log
@Adding Honor's Enemy flag for Loner's and Outcasts
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.715 2001/08/07 01:55:54 poquah Exp $";
d2874 1
a2874 1
               ch->clan == clan_lookup("outcast")) 
@


1.715
log
@Move damage in bash down below the daze state of victims
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.714 2001/08/05 22:47:36 guerrand Exp $";
d2373 3
d2391 3
d2872 5
d3090 5
d3303 5
@


1.714
log
@Added 5 spells for warlock/witch kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.713 2001/08/04 19:30:11 guerrand Exp $";
a5959 1
        damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_bash, DAM_BASH,FALSE,TRUE);
d5979 1
d5989 1
d6001 1
d6013 1
@


1.713
log
@Weekly XP dump. We're down to 66% and 100% complaint free about it!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.712 2001/08/04 16:03:02 guerrand Exp $";
d1196 2
a1197 1
  if ( ch->fighting == victim && is_affected(ch,gsn_midnight_cloak) )
@


1.712
log
@Finished midnight cloak - returns hp when you strike.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.711 2001/08/04 15:54:47 guerrand Exp $";
d4987 1
a4987 1
    return 68 * xp / 100;
@


1.711
log
@IMMs no longer show up when wizi and entering portals.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.710 2001/08/02 02:12:09 guerrand Exp $";
d1199 2
@


1.710
log
@Improved 'restore mana' potion a little.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.709 2001/07/30 04:51:48 guerrand Exp $";
d1195 4
@


1.709
log
@Damage shield spells added.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.708 2001/07/29 17:36:07 rusty Exp $";
d4981 1
a4981 1
    return 70 * xp / 100;
@


1.708
log
@Fixed Posse Enemy
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.707 2001/07/28 19:14:42 guerrand Exp $";
d1969 33
@


1.707
log
@Added a few minor affects to spirit caller spells.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.706 2001/07/27 02:14:11 guerrand Exp $";
d3331 3
d3341 1
@


1.706
log
@Added spirit caller kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.705 2001/07/26 00:45:19 guerrand Exp $";
d429 1
a429 1
       if ( is_affected(ch,gsn_dae_tok))
d435 3
d473 4
d489 1
d509 3
d1179 3
a1181 1
   
@


1.705
log
@Made some changes to shieldbash involving how it targets.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.704 2001/07/24 03:55:34 guerrand Exp $";
d372 26
d400 1
a400 1

d4926 3
@


1.704
log
@Adjusted XP, removed every 5 levels crap- bad experiement.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.703 2001/07/16 16:29:21 guerrand Exp $";
a5688 2
    bool fTumble = FALSE;
    bool fMount = FALSE;
d8722 1
a8722 1
    if ( arg[0] == '\0' )
d8724 6
a8729 2
  send_to_char("Shield bash whom?\n\r",ch);
   return;
d8731 1
a8731 2

    if ((victim = get_char_room(ch,arg)) == NULL)
d8733 2
a8734 2
  send_to_char("They aren't here.\n\r",ch);
  return;
@


1.703
log
@SOme more bug fixes in bash
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.702 2001/07/16 16:25:15 guerrand Exp $";
a4900 4
    /* Every 5th level from 30 on out is harder */
    if ( gch->level % 5 == 0 && gch->level >= 30 )
	xp /= 2;

d4902 1
a4902 1
    return 75 * xp / 100;
@


1.702
log
@Extensive work on bash.  Madeit so there's a small chance of a 3-round bash,
fixed some issues with mount and tumble.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.701 2001/07/15 16:41:29 guerrand Exp $";
d5917 1
a5917 1
		victim->position = POS_FIGHTING;
@


1.701
log
@More fixes to stop fighting
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.700 2001/07/15 07:49:57 guerrand Exp $";
d5870 1
a5870 1
	chance += ( ch->level / 5 );
d5875 17
a5891 13
    
  act("$n sends you sprawling with a powerful bash!",
    ch,NULL,victim,TO_VICT,FALSE);
  act("You slam into $N, and send $M flying!",ch,NULL,victim,TO_CHAR,FALSE);
  act("$n sends $N sprawling with a powerful bash.",
    ch,NULL,victim,TO_NOTVICT,FALSE);
  check_improve(ch,gsn_bash,TRUE,1);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"Somebody get the number of that wagon! %s just got slammed by %s.",victim->name,ch->name);
       gladiator_talk(buf);
    }
d5893 19
a5911 11
  if ( is_mounted(victim) ) /* knocked off horse */
  {
  if ( number_percent() < get_skill(victim,gsn_riding/3) )
  	fMount = TRUE;
  else
  {
	fMount = FALSE;
  act("$n falls from $s mount!",victim,NULL,NULL,TO_ROOM,FALSE);
  act("You fall from your mount!",victim,NULL,NULL,TO_CHAR,FALSE);
  }
  }
d5913 18
a5930 27
  if ( number_percent() + chance < get_skill(ch,gsn_tumbling) &&
	get_skill(ch,gsn_tumbling) > 0 )
  {
      if ( is_mounted(ch) )
      {
	  ch->riding->passenger = NULL;
	  ch->riding = NULL;
      }
      fTumble = TRUE;
      act("$N rolls to $s feet!",ch,NULL,victim,TO_CHAR,FALSE);
      act("You roll to your feet.",ch,NULL,victim,TO_ROOM,FALSE);
      check_improve(ch,gsn_tumbling,TRUE,3);
  }
  else
  {
     if (is_mounted(ch))
     {
	 ch->riding->passenger = NULL;
	 ch->riding = NULL;
	 if (fMount)
	     DAZE_STATE( victim, PULSE_VIOLENCE );
	 else
	     DAZE_STATE( victim, 3 * PULSE_VIOLENCE );
     }
     else
         DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
  }
d5932 1
a5932 9
  if ( IS_AFFECTED(ch,AFF_SLOW))
      WAIT_STATE(ch,skill_table[gsn_bash].beats+12);
  else
      WAIT_STATE(ch,skill_table[gsn_bash].beats);
  if ( !fTumble )
  victim->position = POS_RESTING;
  damage(ch,victim,0,gsn_bash,DAM_BASH,FALSE,FALSE);
  
    }
@


1.700
log
@Every 5th level from 30 to 51 they'll get 1/2 XP.  This'll slow down advancement
slightly and provide milestones for characters to get past.  Also makes that
50th level a doozy.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.699 2001/07/15 03:20:15 guerrand Exp $";
d3959 5
@


1.699
log
@Fix to walking out in mid-combat.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.698 2001/07/15 00:15:36 guerrand Exp $";
d4895 5
@


1.698
log
@LIttle work on battlerager extra attack
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.697 2001/07/14 17:45:55 guerrand Exp $";
d3910 3
a3912 1
 */
d3929 36
@


1.697
log
@Fixed messages in shield bash.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.696 2001/07/13 01:57:59 guerrand Exp $";
d531 1
a531 1
	   get_skill(ch,gsn_rage) - 95 * 5 > number_percent() )
@


1.696
log
@Dropped XP to 78%
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.695 2001/07/13 00:58:57 guerrand Exp $";
d4858 1
a4858 1
    return 78 * xp / 100;
d8687 1
a8687 1
  send_to_char("Hamstring whom?\n\r",ch);
@


1.695
log
@Added 'shield bash' skill.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.694 2001/07/12 00:25:55 rage Exp $";
d4858 1
a4858 1
    return 80 * xp / 100;
@


1.694
log
@bug fix in wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.693 2001/07/10 01:56:48 guerrand Exp $";
d8634 1
d8653 160
@


1.693
log
@Killing Rage uses 25% now instead of 20%, but off perm hits.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.692 2001/07/08 17:14:10 guerrand Exp $";
d1420 1
a1420 1
    if ( HAS_KIT(ch,"shogun") )
@


1.692
log
@MOre XP drop.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.691 2001/07/05 22:15:05 guerrand Exp $";
d8011 1
a8011 1
	af.modifier = (ch->max_hit / 5);
@


1.691
log
@Made killing rage a mite easier to improve.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.690 2001/07/04 03:10:41 guerrand Exp $";
d4213 1
a4213 1
  obj->value[0] = (IS_NPC(ch) ? ch->pIndexData->vnum : 0 );
d4858 1
a4858 1
    return 82 * xp / 100;
@


1.690
log
@FIxed a minor bug with hamstring movement.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.689 2001/07/04 02:49:58 guerrand Exp $";
d4858 1
a4858 1
    return 85 * xp / 100;
d7978 1
a7978 1
		check_improve(ch,gsn_rage,FALSE,7);
d8029 1
a8029 1
    check_improve(ch,gsn_rage,TRUE,5);
@


1.689
log
@Doh!  Hamstring gives you +4 dex.  Coder mistake.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.688 2001/07/04 02:43:08 guerrand Exp $";
d8597 1
a8597 1
    chance -= 4*(get_curr_stat(victim,STAT_STR)+get_curr_stat(victim,STAT_CON))/3;
@


1.688
log
@Few enhancements for hamstring.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.687 2001/07/04 02:29:28 guerrand Exp $";
d8626 1
a8626 1
	af.modifier	= ch->level / 12;
@


1.687
log
@Hamstring done.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.686 2001/07/04 01:36:40 guerrand Exp $";
d8619 3
d8633 1
@


1.686
log
@Scrapped wraith fix 1.0 and tried again.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.685 2001/07/04 01:21:56 guerrand Exp $";
d8505 142
a8646 1
 /* to be filled in */
@


1.685
log
@Extensive changes to wraithform to have it proc after the timer expires.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.684 2001/07/03 04:32:53 guerrand Exp $";
d1695 1
a1695 1
    if ( !IS_NPC(victim) && victim->pcdata->action_function != NULL )
d1697 3
a1699 3
        victim->pcdata->action_function = NULL;
        act("Your activities are interrupted...",victim,NULL,NULL,TO_CHAR,FALSE);
        /* ignore timers... game loop won't proc it any way now */
@


1.684
log
@Minor bug fix for acclimate
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.683 2001/07/03 03:28:49 guerrand Exp $";
d1693 8
@


1.683
log
@New druid spell - acclimate.
Kurjitsu will kick in a tad more often.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.682 2001/07/03 02:00:37 guerrand Exp $";
d8493 5
@


1.682
log
@Favored hit less often  on the favored attack.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.681 2001/07/02 17:17:13 mud Exp $";
d1073 1
a1073 1
   if ( number_percent() < (get_skill(ch,gsn_kurijitsu)/10) )
d1758 7
@


1.681
log
@Make shopkeepers not autoassist
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.680 2001/07/02 04:16:43 guerrand Exp $";
d353 1
a353 1
	 number_percent() < ( ch->pcdata->sac / 6 ) 
d488 1
a488 1
	          number_percent() < ( ch->pcdata->sac / 6 ) 
@


1.680
log
@Reducd XP from 87% to 85% - weekly 2% reduction
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.679 2001/06/28 05:43:47 guerrand Exp $";
d204 3
@


1.679
log
@Fixed trip bug where you can entrance trip self.

aqVS: ----------------------------------------------------------------------
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.678 2001/06/24 19:06:48 guerrand Exp $";
d4840 1
a4840 1
    return 87 * xp / 100;
@


1.678
log
@Fixed bugs with kai ruki
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.677 2001/06/24 04:14:58 guerrand Exp $";
d6100 6
@


1.677
log
@Research adept is 95%, goes up1%per practice.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.676 2001/06/22 23:55:41 guerrand Exp $";
a1353 50
/* MOVED TO THE END OF THIS FUNCTION, BEFORE DODGE, ETC **
    if ( (paf = affect_find(victim->affected,gsn_shield_of_faith) ) != NULL )
    {
	paf->duration--;
	dam = 0;
	act("Your shield of faith protects you!",victim,NULL,NULL,TO_CHAR,FALSE);
	act("$n's shield of faith protects $m!",victim,NULL,NULL,TO_ROOM,FALSE);
   	if ( --paf->duration <  0 )
	{
	    affect_remove(victim,paf,APPLY_BOTH);
	    act("Your shield of faith is gone.",victim,NULL,NULL,TO_CHAR,FALSE);
	    act("$n's shield of faith is gone.",victim,NULL,NULL,TO_ROOM,FALSE);
	}
 	return TRUE;
    }

    if ( (paf = affect_find(victim->affected,gsn_steel_skin) ) != NULL )
    {
        paf->duration--;
        dam = 0;
        act("$n's attack deflects harmlessly off your steel skin.",ch,NULL,victim,TO_VICT,FALSE);
	act("Your attack deflects harmlessly off $N's steel skin.",ch,NULL,victim,TO_CHAR,FALSE);
	act("$n's attack deflects harmlessly off $N's steel skin.",ch,NULL,victim,TO_NOTVICT,FALSE);
        if ( --paf->duration <  0 )
        {
            affect_remove(victim,paf,APPLY_BOTH);
            act("Your skin becomes flesh again.",victim,NULL,NULL,TO_CHAR,FALSE);
            act("$n's skin becomes flesh again.",victim,NULL,NULL,TO_ROOM,FALSE);
        }
        return TRUE;
    }

    if ( (paf = affect_find(victim->affected,gsn_diamond_skin) ) != NULL )
    {
        paf->duration--;
        dam = 0;
        act("$n's attack deflects harmlessly off your diamond skin.",ch,NULL,victim,TO_VICT,FALSE);
        act("Your attack deflects harmlessly off $N's diamond skin.",ch,NULL,victim,TO_CHAR,FALSE);
        act("$n's attack deflects harmlessly off $N's diamond skin.",ch,NULL,victim,TO_NOTVICT,FALSE);
        if ( --paf->duration <  0 )
        {
            affect_remove(victim,paf,APPLY_BOTH);
            act("Your skin becomes flesh again.",victim,NULL,NULL,TO_CHAR,FALSE);
            act("$n's skin becomes flesh again.",victim,NULL,NULL,TO_ROOM,FALSE);
        }
        return TRUE;
    }
 ***/


d3381 1
d3386 8
a3393 1
        return TRUE;
d3697 8
a3704 1
        return TRUE;
@


1.676
log
@Duh duh.  I forgot to write the code for the spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.675 2001/06/19 04:35:36 guerrand Exp $";
d3431 6
d3735 6
d4875 1
a4875 1
    return 90 * xp / 100;
d7670 3
a7672 1
    /* Shoguns */
@


1.675
log
@Fixed dsamage bug, fixed bugs with crit skills, gave ele's sunburst and sonic blast
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.674 2001/06/19 04:00:31 guerrand Exp $";
d1779 16
@


1.674
log
@Fixed bug with mummy vulns.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.673 2001/06/19 03:15:05 guerrand Exp $";
d1482 1
a1482 1
	    dam += (100+(5*total_groupies))*base_dam/100;
d1492 1
a1492 1
	    dam += (100+(2*total_groupies))*base_dam/100;
d1519 1
a1519 1
	dam = number_range(7,9) * base_dam / 10;
d1647 1
a1647 1
	dam = ( 125 + (ch->level/2) ) * base_dam / 100;
d1655 1
a1655 1
	dam = ( 100 + (ch->level/2) ) * base_dam / 100;
a1656 13
/*
    if (IS_SET(victim->mhs,MHS_SAVANT) && !iOld )
    {
	OBJ_DATA *obj;
	obj = get_eq_char( ch, WEAR_WIELD );
	if ( obj != NULL && IS_WEAPON_STAT(obj,WEAPON_SCION) )
	{
		dam += ( dam / 4 );
	        if ( !IS_NPC(victim) )
		     victim->pcdata->savant = UMAX(0,victim->pcdata->savant-1);
	}
    }
*/
d1673 1
a1673 1
	   dam += (base_dam)/5;
d1705 1
a1705 1
	dam = (5*base_dam)/4;
d1716 1
a1716 1
	dam = (5*base_dam)/4;
d1729 1
a1729 1
       dam = 9 * base_dam / 10;
@


1.673
log
@Last minute adjustment to cris
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.672 2001/06/19 02:11:32 guerrand Exp $";
d1686 1
a1686 1
	   dam = (5*base_dam)/4;
d1688 1
a1688 1
	   dam = (3*base_dam)/4;
@


1.672
log
@FIx for critical strikes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.671 2001/06/19 01:38:41 guerrand Exp $";
d8464 10
a8473 2
    if ( !fEnhance && bonus > 25 )
	bonus = ( bonus - 25 ) / 2 + 25;
@


1.671
log
@Added critical strikes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.670 2001/06/17 22:46:25 guerrand Exp $";
d685 1
d971 2
d1141 1
a1141 1
    handle_critical(  ch, &dam,  dam_type, diceroll );
a8485 2
    act("You score a critical hit!",ch,NULL,NULL,TO_CHAR,FALSE);
    act("$n scores a critical hit!",ch,NULL,NULL,TO_ROOM,FALSE);
@


1.670
log
@iMoved the checks for steel skin, shield of faith, and diamond skin,
so set_Fighting will work properly.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.669 2001/06/17 18:53:40 guerrand Exp $";
d66 1
d1136 4
a1139 1
    
d8422 65
@


1.669
log
@Added steel skin and diamond skin for mage/wizard
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.668 2001/06/17 17:42:55 guerrand Exp $";
d1347 1
d1394 1
d1746 48
@


1.668
log
@Added echos for shield of faith.  Fixed gsn mistake.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.667 2001/06/17 17:06:00 guerrand Exp $";
d1361 33
@


1.667
log
@Fixed the haste bug in shaman drachlan special.
Added healing DOt functionality.
Added 'shield of faith' spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.666 2001/06/17 00:21:26 guerrand Exp $";
d1351 2
d1359 1
@


1.666
log
@Fixed a typo in backstab.
Fixed a problem with faeries.
ADjusted XP down.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.665 2001/06/17 00:10:05 guerrand Exp $";
d1345 1
d1347 11
@


1.665
log
@Fixed faerie casting level problem.
ADjusted DOT damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.664 2001/06/16 15:24:14 rage Exp $";
d4755 1
a4755 1
    return 95 * xp / 100;
d6407 1
a6407 1
      send_to_char("Your brillian backstab passes through thier misty body.\r\n",ch);
@


1.664
log
@added spell betrayal - causes skellies etc to betray their master and fight forh the other side
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.663 2001/06/14 15:50:12 mud Exp $";
d1409 30
d7550 2
a8318 1

@


1.663
log
@included interp.h in order to eliminate spurious do_FUN declarationwarnings.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.662 2001/06/14 15:47:17 mud Exp $";
d1139 2
a1140 2
    if (is_affected( victim, skill_lookup("blade barrier")))
	damage(victim, ch, dam/50, skill_lookup("blade barrier"), DAM_SLASH, TRUE, FALSE); 
@


1.662
log
@Removed excess %s format string in dam_message_new() when ch == victim
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.661 2001/06/12 01:46:17 guerrand Exp $";
d29 1
@


1.661
log
@Fixed to dmage code.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.660 2001/06/12 00:12:58 guerrand Exp $";
d2421 1
a2421 1
                sprintf( buf2, "Your %s %s %s you%s%s", vp1, attack, vp2, vp3 );
@


1.660
log
@Fixed my typo.  Dur
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.659 2001/06/12 00:10:27 guerrand Exp $";
d1425 1
a1425 1
	dam = ( (ch->level / 2) + 100 ) * base_dam / 100;
d1662 1
a1662 1
       dam -= base_dam / 4;
d1751 1
a1751 1
      dam -= base_dam/3;
d1754 1
a1754 1
      dam += iOld ? base_dam/2 : base_dam/3;
a2324 1

d2421 1
a2421 1
                sprintf( buf2, "Your %s %s %s you%s", vp1, attack, vp2, vp3 );
@


1.659
log
@Gargoyles get +1% xp during day per 2 levels.
GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.658 2001/06/12 00:05:09 guerrand Exp $";
d4719 2
a4720 2
    if ( gch->race == race_lookup("gargoyle") && weather_info.sun_light >= SUN_RISE 
	&& weather_info.sun_set <= SUN_SET )
@


1.658
log
@Fixed infiltrate bug with Shamans and DOTs.
Fixed negative damage problem
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.657 2001/06/11 03:39:26 guerrand Exp $";
d4719 6
a4724 1
    /* Gradual XP reduction */
@


1.657
log
@GMAN
Whoops.  Wrong variable name = bad compile.  Fixed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.656 2001/06/11 03:27:45 guerrand Exp $";
d1810 3
d3157 2
a3158 1
     && !IS_SET(victim->act,PLR_THIEF) )
@


1.656
log
@CHANGE TO DAMAGE FUNCTION:

Rather than compounding vulns/resists, the game will compute damage bonuses
or penalites based off the BASE DAMAGE send to the damage function, not off
the modified damage.  As it is, certain combinations of races, classes, and
kits can get 250% damage bonuses.  Regular unspeaking attacks, caps damage
through sanc with weapons.  IT's getting out of hand.

Damage will now apply bonuses and what not based on the post-curve damage
amount, rather than compounding damage bonuses and penalties.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.655 2001/06/11 01:17:01 rage Exp $";
d1343 1
a1343 1
    int	base_damage;
@


1.655
log
@added new spell "blade barrier"
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.654 2001/06/10 20:46:13 guerrand Exp $";
d1343 2
d1406 2
d1425 1
a1425 1
	dam = ( (ch->level / 2) + 100 ) * dam / 100;
d1431 1
a1431 1
	dam = number_range(7,9) * dam / 10;
d1559 1
a1559 1
	dam = ( 125 + (ch->level/2) ) * dam / 100;
d1567 1
a1567 1
	dam = ( 100 + (ch->level/2) ) * dam / 100;
d1598 1
a1598 1
	   dam = (5*dam)/4;
d1600 1
a1600 1
	   dam = (3*dam)/4;
d1607 1
a1607 1
      dam += (dam * .14);
d1611 1
a1611 1
      dam += (dam * .08);
d1615 1
a1615 1
       dam += (dam * .05);
d1619 1
a1619 1
      dam += (dam * .11);
d1630 1
a1630 1
	dam = (5*dam)/4;
d1641 1
a1641 1
	dam = (5*dam)/4;
d1654 1
a1654 1
       dam = 9 * dam / 10;
d1662 1
a1662 1
       dam -= dam / 4;
d1751 1
a1751 1
      dam -= dam/3;
d1754 1
a1754 1
      dam += iOld ? dam/2 : dam/3;
@


1.654
log
@SHaman kit is now available.
GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.653 2001/06/10 03:29:32 guerrand Exp $";
d1134 1
d1137 4
d1321 1
@


1.653
log
@Added some new features for surnames.
1. They show in who list but
2. you can toggle that off if you don'tlike it
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.652 2001/06/09 19:34:46 guerrand Exp $";
d4705 2
a4706 1
    return xp;
@


1.652
log
@GMAN
Some more bug cleanup work.  Trying to eliminate the problem with getting
battle prompts when DOT'd.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.651 2001/06/09 06:27:39 guerrand Exp $";
d1339 2
a1340 1
    fDOT = check_is_dot( dt );
@


1.651
log
@
GMAN

More bug fixing.  Found some bugs with calling 'damage' from 'dot', when
'ch' and 'victim' might be in different rooms.  Addressed these with some
work arounds.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.650 2001/06/03 19:43:03 guerrand Exp $";
d1444 1
a1444 1
       if ( victim->position > POS_STUNNED )
@


1.650
log
@GMAN
The vnum of the mob that was killed will be in brains and corpses and arms and what
 not now.  So if you kill tiamat and gest the brains of tiamat, tiamat's vnum will
be stored in value 0.  This will be used in quests in the future.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.649 2001/06/03 19:17:15 guerrand Exp $";
d1336 4
d1439 2
a1440 1
	     && !is_affected(victim,skill_lookup("orb of surprise")) )
d1457 1
a1457 1
	     else 
d1821 1
d1827 1
a1827 1
	check_improve(ch,gsn_nethermancy,TRUE,10);
d1840 1
a1840 1

d1846 1
a1846 1
       check_improve(ch,gsn_communion,TRUE,3);
d1853 4
a1856 2
       
    check_improve(ch,gsn_communion,FALSE,6);
d7814 1
d7865 2
a7866 1
    check_improve(ch,gsn_rage,TRUE,5);
@


1.649
log
@Adjusrtments to the affects of DEX< all fairly minor.
DEX to 2/3 DEX, that kind of thing.
Adjustment o despawn frequency for the phoenix
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.648 2001/06/03 18:46:10 guerrand Exp $";
d4055 3
@


1.648
log
@GMAN
Bug fix in mummy hex so it will wake up sleeprs and what not.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.647 2001/06/03 18:22:46 guerrand Exp $";
d3593 1
a3593 1
  chance += get_curr_stat(victim,STAT_DEX);
@


1.647
log
@GMAN

1. I've added an ac curve difference for melee/caster/hybrid, based ONLY on reclass/current class
2. Removed faerie vuln to stun weapons.
3. Flattened AC progression in dex_app
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.646 2001/06/01 04:25:14 guerrand Exp $";
d7185 1
@


1.646
log
@GMAN
bug fixes.  a cosmetic fix in mistform and a missing negative sign in stone skin
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.645 2001/06/01 04:10:37 guerrand Exp $";
d850 37
a886 4
  
    if (victim_ac < -15)
  victim_ac = (victim_ac + 15) / 5 - 15;
     
d1301 1
a1301 1
    /* faeries are easier to stun once you land the damn blow */
d1304 1
@


1.645
log
@GMAN
	Fixed rockbiter bonus damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.644 2001/06/01 03:16:59 guerrand Exp $";
d3498 1
a3498 1
	act("$N's misty form becomes more corporeal.",ch,NULL,victim,TO_ROOM,FALSE);
@


1.644
log
@GMAN
Changed mistform, fixed a bug, added some cosmetic echoes.
Improved the duration.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.643 2001/05/30 23:55:26 guerrand Exp $";
d1086 4
a1089 2
    /* Size Adjustment - Larger races do more damage */
    dam += dam * ((ch->size - 2)/10); 
d1092 1
a1092 1
       dam += dam * ((ch->size -2)/10);
@


1.643
log
@
SOme changes to giants and ogres to make them more playable.
G man
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.642 2001/05/27 20:57:14 rusty Exp $";
d3493 7
a3499 2
      affect_strip(ch, skill_lookup("mistform"));

d3501 1
a3501 1
    chance += paf->duration;
@


1.642
log
@Fixed the wait state for successful kcharge
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.641 2001/05/26 03:10:26 rage Exp $";
d987 5
d1369 7
d5441 1
d5533 2
d5538 2
a5539 1
	check_dispel( ch->level , victim, skill_lookup("orb of touch"));
d5613 4
@


1.641
log
@missed a change to a global, silly me..3 commits for a 5 line change *sigh*
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.640 2001/05/25 17:33:12 poquah Exp $";
d8144 1
a8144 1
      WAIT_STATE( ch, skill_table[gsn_kick].beats);
@


1.640
log
@double exp day on
-poqq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.639 2001/05/14 15:08:32 rusty Exp $";
d34 1
a34 1

d4467 1
a4467 1
    if (xp > 0)
@


1.639
log
@Pulling update from game machine
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.640 2001/04/26 19:24:42 mud Exp $";
d4466 1
d4630 2
a4631 1
	    act("An Egg has fallen out of Santa's wallet into your own.",
a4632 2
            obj_to_char(create_object(get_obj_index(OBJ_VNUM_EGG),0,FALSE),gch);
	    xp *= 2;
a4638 1
    */
@


1.638
log
@Small wait state on fleeing
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.637 2001/04/09 02:58:26 mud Exp $";
@


1.637
log
@Type on STATIC VAR declaration
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.636 2001/04/09 01:30:26 mud Exp $";
d6402 4
a6405 1
    /* WAIT_STATE( ch, PULSE_PER_SECOND / 2 ); */
@


1.636
log
@Made looting of non-treasure items limited to 4 from a corpse.
Also made group mates and stuff able to loot all from your corpse
to save your ass.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.635 2001/03/26 17:20:08 mud Exp $";
d3758 1
a3758 1
  corpse->value[4] = PC_LOOT_OBJECTS;
@


1.635
log
@Turning off double EXP day
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.634 2001/03/25 15:16:51 mud Exp $";
d3758 1
a3784 1
    /*free_string( corpse->short_descr );*/
a3787 1
    /*free_string( corpse->description );*/
@


1.634
log
@Turning on double EXP day
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.633 2001/03/20 17:44:29 mud Exp $";
a4466 1
    */
d4640 1
a4640 1
    /**/
@


1.633
log
@Fixes to last_attacked_by_timer
Earthbind a bit more difficult to cancel.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.632 2001/03/14 21:55:11 mud Exp $";
d4467 1
d4641 1
a4641 1
    */
@


1.632
log
@Increased kcharge beats and made them happen BEFORE multi_hit()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.631 2001/03/11 03:16:20 mud Exp $";
d2106 1
a2106 1
		ch->pcdata->last_attacked_by_timer = 2;
d2121 1
a2121 1
		ch->master->pcdata->last_attacked_by_timer = 2;
d2589 4
a2592 1
             victim->pcdata->last_attacked_by = str_dup(ch->name);
d2802 4
a2805 1
             victim->pcdata->last_attacked_by = str_dup(ch->name);
d3010 4
a3013 1
             victim->pcdata->last_attacked_by = str_dup(ch->name);
@


1.631
log
@adjust tail, moved damage line to after daze and removed resting
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.630 2001/03/11 02:19:03 mud Exp $";
d8134 1
a8135 1
      WAIT_STATE( ch, skill_table[gsn_kick].beats);
d8158 1
a8158 1
        WAIT_STATE( victim, skill_table[gsn_kcharge].beats);
@


1.630
log
@recompiling to try and get olc to come up
-poQ
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.629 2001/03/11 01:15:50 mud Exp $";
a5391 1
	damage(ch,victim,dice(ch->level /10+1,8),gsn_bash,DAM_BASH,FALSE,FALSE);
d5394 2
d5397 1
d5399 1
@


1.629
log
@put olc_version arond the corpse test code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.628 2001/03/10 23:54:35 mud Exp $";
d3791 1
a3791 1
#ifdef OLC_VERSION
@


1.628
log
@drop corspes from corpse work in progress
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.627 2001/03/10 23:09:35 mud Exp $";
d3791 1
d3794 1
@


1.627
log
@drop corpse form corpse
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.626 2001/03/03 18:57:14 mud Exp $";
a3791 2
  {
      obj_from_obj(obj);
a3792 1
  }
@


1.626
log
@Took out bramage() too
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.625 2001/03/03 18:55:20 mud Exp $";
d3789 8
@


1.625
log
@Last remnants of damage_old() removal
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.624 2001/03/03 18:53:57 mud Exp $";
a1278 5
}

bool bramage(CHAR_DATA *ch,CHAR_DATA *victim,int dam,int dt,int dam_type,bool show)
{
return damage(ch,victim,dam,dt,dam_type,show,FALSE);
@


1.624
log
@Took out all references to damage_old() and used iOld var in damage()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.623 2001/03/03 15:47:25 mud Exp $";
a2387 10



/*
 * Inflict damage from a hit.
bool damage_old( CHAR_DATA *ch, CHAR_DATA *victim, int dam, int dt, int 
dam_type, bool show ) {
return damage(ch,victim,dam,dt,dam_type,show,TRUE);
}
 */
@


1.623
log
@Fixed no out of range return values in is_safe() and is_safe_spell()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.622 2001/03/03 15:44:59 mud Exp $";
d1099 1
a1099 1
  int dam;
d1150 1
a1150 1
      damage_old(ch,victim,dam,0,DAM_NEGATIVE,FALSE);
d1169 1
a1169 1
      damage_old(ch,victim,dam,0,DAM_NEGATIVE,FALSE);
d1270 1
a1270 1
    damage_old(ch,victim,dam,0,DAM_NEGATIVE,FALSE);
a2392 1
 */
d2397 1
@


1.622
log
@Inserted missing )
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.621 2001/03/03 15:40:42 mud Exp $";
d2572 1
a2572 1
	    return;
d2986 1
a2986 1
	    return;
@


1.621
log
@Blow orb of suprise if you're doing damage to someone
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.620 2001/03/03 15:32:26 mud Exp $";
d1420 1
a1420 1
	    && is_affected(ch,skill_lookup("orb of surprise"))
@


1.620
log
@chi apply fix in berzerk
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.619 2001/02/27 18:53:22 mud Exp $";
d1403 1
a1403 4
	        if(IS_SET(victim->display,DISP_COLOR))
	           send_to_char( GREEN"RUN!"NORMAL"\n\r", victim );
	        else
	           send_to_char( "RUN!\n\r", victim );
d1418 4
@


1.619
log
@remove double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.618 2001/02/26 07:10:59 mud Exp $";
d4989 1
a4989 1
  ch->move /= apply_chi(ch,100);
@


1.618
log
@double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.617 2001/02/13 20:23:26 mud Exp $";
a4464 1
    */
d4638 1
@


1.617
log
@NoOutOfRange toggle stuff
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.616 2001/02/10 14:17:38 mud Exp $";
d4465 1
a4638 1
    */
@


1.616
log
@Ooops, no more fearing shopkeepers, not hex'ing.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.615 2001/02/10 13:55:02 mud Exp $";
d2567 7
d2980 7
@


1.615
log
@No more hex'ing shopkeepers
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.614 2001/02/10 03:27:01 mud Exp $";
a7057 6
   if (victim->pIndexData->pShop != NULL)
   {
      send_to_char("The shopkeeper wouldn't like that.\n\r",ch);
      return;
   }

d7172 1
@


1.614
log
@Removed unused variable
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.613 2001/02/04 02:53:01 mud Exp $";
d7038 2
a7039 2
   send_to_char("Not while in wraithform.\r\n",ch);
   return;
a7041 1

d7057 6
@


1.613
log
@03FEB01
Yahoo, the posse skill is in.  taking out the debugging messages
-Boogums

oh changes to fight.c in one_hit and damage functions
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.612 2001/02/04 02:18:25 mud Exp $";
a681 1
    int posse_bonus;
@


1.612
log
@03FEB01
Ok, here goes teh Posse clan skill
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.611 2001/01/26 15:16:42 mud Exp $";
a767 1
	  send_to_char("They have a KILLER flag! Hit em good!\n\r",ch); 
a771 1
	  send_to_char("They have a THUG flag! Hit em good!\n\r",ch);
a775 1
	  send_to_char("They have a RUFFIAN flag! Hit em good!\n\r",ch);
a779 1
	  send_to_char("They have a THIEF flag! Hit em good!\n\r",ch);
a1547 1
      send_to_char("They have a KILLER flag! Hit em hard!\n\r",ch);
a1551 1
      send_to_char("They have a THUG flag! Hit em hard!\n\r",ch);
a1555 1
       send_to_char("They have a RUFFIAN flag! Hit em hard!\n\r",ch);
a1559 1
      send_to_char("They have a THIEF flag! Hit em hard!\n\r",ch);
@


1.611
log
@removed double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.610 2001/01/25 18:07:55 mud Exp $";
d682 1
d765 23
d1546 23
@


1.610
log
@Put in double EXP
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.609 2001/01/20 08:34:00 mud Exp $";
a4412 1
     */
d4586 1
a4586 1
    /**/
@


1.609
log
@missing ,
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.608 2001/01/20 08:32:48 mud Exp $";
d4413 1
d4587 1
a4587 1
    */
@


1.608
log
@attempted fix on brawler bug
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.607 2000/12/27 04:27:40 mud Exp $";
d5972 1
a5972 1
	  send_to_char("Don't try to cheat you are being watched.\n\r"ch);
@


1.607
log
@double exp off
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.606 2000/12/25 11:08:25 mud Exp $";
d5959 3
d5967 11
d6001 1
@


1.606
log
@-Double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.605 2000/12/24 17:46:06 mud Exp $";
a4412 1
    */
d4586 1
@


1.605
log
@24dec00
Wandering thru fight.c seeing if necro code is broken
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.604 2000/12/15 06:39:43 mud Exp $";
d4413 1
d4576 6
a4586 1
    */ 
@


1.604
log
@14DEC00
found the culprit, multihit
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.603 2000/12/15 06:33:13 mud Exp $";
d1143 1
a1143 1
      else
@


1.603
log
@14DEC00
sometimes ch's are checked in is_)safe
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.602 2000/12/15 06:22:30 mud Exp $";
d309 3
@


1.602
log
@14DEC00
autoassist is trickier than i thought
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.601 2000/12/15 06:14:38 mud Exp $";
a202 8
    /*wraithform check -Boogums*/
    if (is_affected(ch,skill_lookup("wraithform")) || is_affected(victim,skill_lookup("wraithform")) ) 
    {
    send_to_char("No assisting for you while in wraithform.\r\n",ch);
    send_to_char("No assisting for you while in wraithform.\r\n",victim);
    return;
    }

d226 1
a226 2
    &&   !is_safe(rch, victim)
    &&   !is_affected(rch,skill_lookup("wraithform")) )
d2377 5
@


1.601
log
@14DEC00
whoohoo, this should get it
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.600 2000/12/15 06:09:59 mud Exp $";
d234 2
a235 1
    &&   !is_safe(rch, victim))
@


1.600
log
@14DEC00
Ok forgot the lag when they cast, it lags em before the affect takes
hold.  also had to put a check in autoassist
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.599 2000/12/15 00:27:14 mud Exp $";
d204 1
a204 1
    if (is_affected(ch,skill_lookup("wraithform")) ) 
d207 1
@


1.599
log
@CODETEST commenting of vuln displays
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.598 2000/12/15 00:00:29 mud Exp $";
d203 7
d213 1
a213 1
  
@


1.598
log
@Typo fix
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.597 2000/12/14 23:55:16 mud Exp $";
d1500 1
d1506 1
d1543 1
d1549 1
d1635 1
d1641 1
d1657 1
d1663 1
@


1.597
log
@Race vuln and remort vuln messages in long combat only
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.596 2000/12/14 23:38:10 mud Exp $";
a1504 1
 */
@


1.596
log
@Comments to prove race vuln extra damage
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.595 2000/12/14 05:11:12 mud Exp $";
d1500 5
a1504 3
/*
    sprintf(log_buf,"before remorts vuln %d\n\r",dam);
    send_to_char(log_buf,ch);
d1541 6
a1546 4
/*
    sprintf(log_buf,"after remorts vuln %d\n\r",dam);
    send_to_char(log_buf,ch);
 */
d1631 6
a1636 3

    sprintf(log_buf,"before race vuln %d\n\r",dam);
    send_to_char(log_buf,ch);
d1652 5
a1656 2
    sprintf(log_buf,"after race vuln %d\n\r",dam);
    send_to_char(log_buf,ch);
@


1.595
log
@13DEC00
Wow, did you know there was this nifty is_safe function?  Damn trees blocking
the view of the forest...
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.594 2000/12/14 04:32:48 mud Exp $";
d1628 3
d1644 3
@


1.594
log
@13DEC00
More checks for various other forms of attack
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.593 2000/12/14 04:11:21 mud Exp $";
d2350 7
@


1.593
log
@13DEC00
Yahoo, a clean compile.  Put checks in tailslap, backstab, bash, bite
aaaand that's it for now.  taking baby steps :)
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.592 2000/12/14 03:50:28 mud Exp $";
d5638 7
d5801 7
d6472 7
d6599 7
d6635 7
a6646 1

d6939 7
d6964 6
d7084 2
d7946 6
@


1.592
log
@13DEC00
Ok, i added the unwraith skill in interp.*, put a {Black Aura) in
act_info.c and modified the fight message
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.591 2000/12/13 05:03:40 mud Exp $";
d5206 6
d5236 6
d5345 7
d5390 6
d6154 7
d6656 6
d6691 6
@


1.591
log
@12DEC00
Yahoo, now testing the do_kill code
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.590 2000/12/12 22:48:10 mud Exp $";
d5942 1
a5942 1
      send_to_char("They are made of mist.\r\n",ch);
@


1.590
log
@COmmenting out damage debug
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.589 2000/12/12 22:38:50 mud Exp $";
d5904 5
d5940 5
@


1.589
log
@is_name() into remort vulns
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.588 2000/12/12 22:35:40 mud Exp $";
d1500 2
a1501 1
    sprintf(log_buf,"before remorts vuln %d",dam);
d1503 1
d1539 2
a1540 1
    sprintf(log_buf,"after remorts vuln %d",dam);
d1542 1
@


1.588
log
@is_name() change to remort vuln checks
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.587 2000/12/12 21:44:24 mud Exp $";
d1510 1
a1510 1
	if ( obj != NULL && !is_name("fire",obj->material) )
d1523 1
a1523 1
	if ( obj != NULL && !is_name("wood",obj->material) )
d1534 1
a1534 1
	if ( obj != NULL && !is_name("silver",obj->material) )
@


1.587
log
@ugh typo
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.586 2000/12/12 21:43:35 mud Exp $";
d1510 1
a1510 1
	if ( obj != NULL && !str_prefix(obj->material,"fire") )
d1523 1
a1523 1
	if ( obj != NULL && !str_prefix(obj->material,"wood") )
d1534 1
a1534 1
	if ( obj != NULL && !str_prefix(obj->material,"silver") )
@


1.586
log
@debugging remort vuln code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.585 2000/12/12 21:42:02 mud Exp $";
d1538 1
a1538 1
    send_to_char(buf,ch);
@


1.585
log
@debug for remort vulns
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.584 2000/12/09 07:05:48 mud Exp $";
d1501 1
a1501 1
    send_to_char(buf,ch);
@


1.584
log
@08DEC00
DAMN this wraithform it's gone now :)
=Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.583 2000/12/07 06:45:44 mud Exp $";
d1500 2
d1537 2
@


1.583
log
@ok got all the necromancer stuff out trying to restore order
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.582 2000/12/07 05:46:11 mud Exp $";
a1278 6
    /*ok here comes the wraithform check -Boogums*/
    /*if (IS_AFFECTED(victim, skill_lookup("wraithform")))
      {
	return FALSE;
      }
    */
a5197 6
    /*if (IS_AFFECTED(ch,skill_lookup("wraithform")))
    {
      send_to_char("You are made of mist.\r\n",ch);
      return;
    }
    */
a5221 6
    /*if (IS_AFFECTED(victim,skill_lookup("wraithform")))
    {
      send_to_char("Your tail slices through their misty form.\r\n",ch);
      return;
    }
*/
a5363 6
/*    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
  {
    send_to_char("They're made of mist, you bite air.\r\n",ch);
     return;
  }
*/
a5606 6
/*    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
    {
      send_to_char("They are made of mist, your dirt clod goes right through them.\r\n",ch);
      return;
    }
*/
a5762 6
    /*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
    {
      send_to_char("They are made of mist, you can not trip them.\r\n",ch);
      return;
    }
*/
a5878 7
/*here's a wraith form check-Boogums*/
    /*if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
    {
      send_to_char("Your made of wraith mist.  How are you going to attack them?\r\n",ch);
      return;
    }
*/
a5924 7
/*wraithform check -Boogums*/
  /*  if (IS_AFFECTED(victim,skill_lookup("wraithform")))
    {
      send_to_char("Your weapon goes through their misty form.\r\n",ch);
      return;
    }
*/
a6110 6
    /*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
    {
      send_to_char("They're made of mist, you almost stab yourself.\r\n",ch);
      return;
    }
*/
a6416 6
    /*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
	{
	      send_to_char("They are made of mist.\r\n",ch);
		    return;
			}
*/
a6556 6
	/*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
	{
          send_to_char("They're made of mist, you bite air.\r\n",ch);
          return;
        }
*/
a6617 6
    /*if( IS_AFFECTED(ch, skill_lookup("wraithform")))
    {
  send_to_char("You are made of mist, how can you bite anything?\r\n",ch);
    return;
    }
*/
a6635 6
    /*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
    {
      send_to_char("They are made of mist, you can not bite them.\r\n",ch);
      return;
    }
*/
a6708 12
    /*if (IS_AFFECTED(victim,skill_lookup("wraithform")))
    {
      send_to_char("They are made of mist.\r\n",ch);
      return;
    }
    if (IS_AFFECTED(ch,skill_lookup("wraithform")))
    {
      send_to_char("You wrap your misty arms around them and they get a chill...brrrr!\r\n",ch);
      send_to_char("Awww, isn't that sweet.  Someone gave you a wraith bearhug.\r\n",victim);
      return;
    }
*/
a6860 6
    /*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
    {
        send_to_char("They've already sold their soul, your hex has no affect.\r\n",ch);
	return;
    }
*/
a7045 6
    /*if( IS_AFFECTED(ch, skill_lookup("wraithform")))
    {
    send_to_char("You are made of mist, I'm sure they appreciate the steam bath.\r\n",ch);
    return;
    }
*/
a7053 6
    /*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
    {
      send_to_char("They are made of mist, you can not bite them.\r\n",ch);
      return;
    }
*/
a7142 6
    /*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
    {
      send_to_char("They are made of mist.\r\n",ch);
      return;
    }
*/
a7868 6
    /*if( IS_AFFECTED(victim, skill_lookup("wraithform")))
    {
      send_to_char("They're made of mist.\r\n",ch);
      return;
    }
*/
@


1.582
log
@06DEC00
Ok no AFF_WRAITHFORM had to change those to skill_lookups
compiled clean testing now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.581 2000/12/06 04:40:40 mud Exp $";
d1280 1
a1280 1
    if (IS_AFFECTED(victim, skill_lookup("wraithform")))
d1284 1
a1284 1

d5204 1
a5204 1
    if (IS_AFFECTED(ch,skill_lookup("wraithform")))
d5209 1
a5209 1

d5234 1
a5234 1
    if (IS_AFFECTED(victim,skill_lookup("wraithform")))
d5239 1
a5239 1

d5382 1
a5382 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d5387 1
a5387 1

d5631 1
a5631 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d5636 1
a5636 1

d5793 1
a5793 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d5798 1
a5798 1

d5916 1
a5916 1
    if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
d5921 1
a5921 1

d5969 1
a5969 1
    if (IS_AFFECTED(victim,skill_lookup("wraithform")))
d5974 1
a5974 1

d6161 1
a6161 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d6166 1
a6166 1

d6473 1
a6473 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d6478 1
a6478 1

d6619 1
a6619 1
	if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d6624 1
a6624 1

d6686 1
a6686 1
    if( IS_AFFECTED(ch, skill_lookup("wraithform")))
d6691 1
a6691 1

d6710 1
a6710 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d6715 1
a6715 1

d6789 1
a6789 1
    if (IS_AFFECTED(victim,skill_lookup("wraithform")))
a6793 1

d6800 1
a6800 1

d6953 1
a6953 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d6958 1
a6958 1

d7144 1
a7144 1
    if( IS_AFFECTED(ch, skill_lookup("wraithform")))
d7149 1
a7149 1

d7158 1
a7158 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d7163 1
a7163 1

d7253 1
a7253 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d7258 1
a7258 1

d7985 1
a7985 1
    if( IS_AFFECTED(victim, skill_lookup("wraithform")))
d7990 1
a7990 1

@


1.581
log
@05DEC00
Alright, me thinks i got the kit done, compiling on olc and gonna do
some testing.
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.580 2000/12/04 04:42:14 mud Exp $";
d1280 1
a1280 1
    if (IS_AFFECTED(victim, AFF_WRAITHFORM))
d5204 1
a5204 1
    if (IS_AFFECTED(ch,AFF_WRAITHFORM))
d5234 1
a5234 1
    if (IS_AFFECTED(victim,AFF_WRAITHFORM))
d5382 1
a5382 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d5631 1
a5631 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d5793 1
a5793 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d5916 1
a5916 1
    if( IS_AFFECTED(ch,AFF_WRAITHFORM) )
d5969 1
a5969 1
    if (IS_AFFECTED(victim,AFF_WRAITHFORM))
d6161 1
a6161 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d6473 1
a6473 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d6619 1
a6619 1
	if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d6686 1
a6686 1
    if( IS_AFFECTED(ch, AFF_WRAITHFORM))
d6710 1
a6710 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d6789 1
a6789 1
    if (IS_AFFECTED(victim,AFF_WRAITHFORM))
d6795 1
a6795 1
    if (IS_AFFECTED(ch,AFF_WRAITHFORM))
d6954 1
a6954 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d7145 1
a7145 1
    if( IS_AFFECTED(ch, AFF_WRAITHFORM))
d7159 1
a7159 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d7254 1
a7254 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
d7986 1
a7986 1
    if( IS_AFFECTED(victim, AFF_WRAITHFORM))
@


1.580
log
@03DEC00
Ok Briar found out i'd missed a couple things, so going to do some more
wriathform checks in dbite, tail and other racial attacks.  put everything
back to normal, updating main src now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.579 2000/12/03 22:59:01 mud Exp $";
d5204 6
d5234 6
d5382 7
d5631 5
a5767 1

d5793 5
d6161 6
d6473 6
d6686 6
d6710 7
d6788 6
d6795 6
d6954 6
d7145 6
d7159 6
d7252 6
@


1.579
log
@03DEC00
Yahoo, got the cast bug fixed and now a message if they are attacked
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.578 2000/12/03 03:24:01 mud Exp $";
d6579 6
d7897 6
@


1.578
log
@2DEC00 - Ok here goes teh necromancer kit.  changes in act_info.c act_move.c
         act_obj.c const.c figt.c mag2.c magic.c magic.h merc.h update.c
	 all sorts of cool stuff
	 -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.577 2000/11/27 00:03:47 mud Exp $";
d5939 6
@


1.577
log
@oops blundered that one taking it out
poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.576 2000/11/27 00:01:33 mud Exp $";
d1279 6
a3942 2
    /*added 06OCT00 - By Boogums 
    int spymouse_dam=0;*/
a3967 11
#ifdef CODETEST
      /*Ok here geos the check to see if it was a spymouse*/
      if ( IS_SET(victim->mhs,MHS_SPYMOUSE) )
      {
	/*Figure out how to do mega damage to the druid*/
	send_to_char("{ROUCH{x!!!  Looks like your little friend got wacked.\r\n",victim->master);
	spymouse_dam = victim->master->hit/2;
	damage(victim->master,victim,spymouse_dam,0,DAM_MENTAL,FALSE,FALSE);
      }
#endif

d5887 7
@


1.576
log
@remove double exp
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.575 2000/11/26 23:46:57 mud Exp $";
d4547 1
a4547 1
    /*
@


1.575
log
@removed the Poquah is a dumb ass line :)
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.574 2000/11/24 23:23:15 mud Exp $";
a4379 1
    */
a4545 1

d4547 1
@


1.574
log
@double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.573 2000/11/19 18:56:23 mud Exp $";
d4488 1
a4488 1
	    act("Poquah is a dumb ass.",
d4490 1
a4490 1
	    xp *= 2;
@


1.573
log
@19NOV00
Added a change to mirror image spell.  Now it does a check to see if they're
mounted on a warhorse or not.  If so, it won't allow them to cast.
Also hoping the necromancer stuff i have in fight.c doesn't affect game play :)
it *shouldn't* but you never know ;)
ttfn
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.572 2000/10/26 12:22:47 mud Exp $";
d4380 1
d4534 2
a4535 2
	    xp *= 3;
	    act("Be sure to wish SierraFlame a happy early birthday.",
a4548 1
    */ 
@


1.572
log
@ removal of double xp

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.571 2000/10/25 12:44:55 mud Exp $";
d1135 9
a1143 1
      dam = number_range(1, wield->level / 5 + 1);
d1150 5
a1154 1
      !is_affected(ch, skill_lookup("indulgence")))
d1156 1
@


1.571
log
@ fix to morph damage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.570 2000/10/25 12:42:07 mud Exp $";
d4366 1
a4366 1
    --- Dont forget to change 'override' to TRUE in act_wiz.c  */ 
d4535 1
a4535 1
    
@


1.570
log
@ adding double xp day code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.569 2000/10/23 22:05:56 mud Exp $";
d1024 1
a1024 1
	dam *= 19/10; 
@


1.569
log
@zealot and posse enemies
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.568 2000/10/20 18:14:14 mud Exp $";
d4366 1
a4366 1
    --- Dont forget to change 'override' to TRUE in act_wiz.c   
d4535 1
a4535 1
    */
@


1.568
log
@typo lokup
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.567 2000/10/20 18:07:28 mud Exp $";
d2030 6
d2045 6
d2505 13
d2715 13
d2913 13
@


1.567
log
@warlocks dont get warlock enemy bit, in case of accidents in area spealls
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.566 2000/10/18 17:05:16 mud Exp $";
d2687 1
a2687 1
	      ch->clan != clan_lokup("warlock") &&
@


1.566
log
@Added WAIT_STATE() for a kcharge success.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.565 2000/10/17 22:45:33 mud Exp $";
d2490 1
d2687 1
d2872 1
@


1.565
log
@enemies for clans , just warlock for now
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.564 2000/10/16 23:05:29 mud Exp $";
d7846 1
a7846 1
	    WAIT_STATE( ch, skill_table[gsn_kcharge].beats/2+5);
d7861 1
@


1.564
log
@last attacked by timer giving highbies a two tick chance to kill the lowbie
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.563 2000/10/16 19:17:00 mud Exp $";
d2026 4
d2035 4
d2489 4
d2684 4
d2868 4
@


1.563
log
@ added in second avarice clan skill
 fixed bug in indulgence
 added in functionality for "sanction skill"
 -rage
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.562 2000/10/12 22:04:54 mud Exp $";
d2025 1
a2025 1
   	        ch->pcdata->last_attacked_by = str_dup("no one");
d2030 1
a2030 1
   	        ch->master->pcdata->last_attacked_by = str_dup("no one");
@


1.562
log
@killing last_kill gives 0 exp
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.561 2000/10/08 18:30:16 mud Exp $";
d1141 1
a1141 1
      if (!IS_SET(ch->mhs,MHS_GLADIATOR) ||
d2638 1
@


1.561
log
@08OCT00 - Yahooo! adding the charm animal spell and swarm spells for the
          druid kit.  going to test now on olc.
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.560 2000/10/07 21:28:56 mud Exp $";
d4283 6
@


1.560
log
@fix zapped object bug not moving secondary to primary
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.559 2000/10/01 19:03:04 mud Exp $";
d3849 3
d3876 11
@


1.559
log
@01OCT00-
Modified the room exit routine.  Made it smarter.
-Boogums
(fight.c modified)
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.558 2000/09/26 07:00:15 mud Exp $";
d4597 1
d4604 1
d4625 1
d4632 1
@


1.558
log
@remove double exp
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.557 2000/09/24 21:30:37 mud Exp $";
d7720 2
a7723 13
/*
  for ( victim1 = char_list; victim1 != NULL; victim1 = victim1->next )
    if ( (is_same_group( victim1, ch ) && IS_SET(victim1->mhs,MHS_WARHORSE))
       || (is_same_group(victim1->master,ch) && IS_SET(victim1->mhs,MHS_WARHORSE)) )
    {
       count++;
    }
    if(count == 0 )
    {
      send_to_char("Your squire knocks coconuts together while you charge around the room.\n\r",ch );
      return;
    }
*/
a7739 7
/*
  if ((victim = get_char_room(ch,arg)) == NULL)
  {
    send_to_char("They aren't here. \n\r",ch);
    return;
  } 
*/
a7780 6
/*    if ( !IS_NPC(ch) && ch->level < skill_level(ch,gsn_kcharge) )
      {
	send_to_char("Your squire knocks coconuts together while you charge around the room.\n\r",ch );
	return;
      }
*/
d7819 1
a7819 7
      /*hey corey, you eeeeidiot ;) put the case select here for moving them around
      the room when they fail */
      check_improve(ch,gsn_kcharge,TRUE,1);
      damage( ch,victim,0,gsn_kcharge,DAM_NONE,TRUE,FALSE);
      stop_fighting(victim, TRUE);
      stop_fighting(ch, TRUE);
      switch (number_range(0,9))
d7822 22
a7843 10
	  act("$n charges right out of the room.",ch,NULL,victim,TO_ROOM,FALSE);
          act("You charge right out of the room.",ch,NULL, victim,TO_CHAR,FALSE);
	  move_char ( ch, DIR_NORTH, FALSE);
	  WAIT_STATE( ch, skill_table[gsn_kcharge].beats*3);
 	break;
	case 2:
	  act("$n charges right out of the room.",ch,NULL,victim,TO_ROOM,FALSE);
	  act("You charge right out of the room.",ch,NULL, victim,TO_CHAR,FALSE);
	  move_char ( ch, DIR_WEST, FALSE);
	  WAIT_STATE( ch, skill_table[gsn_kcharge].beats*3);
d7845 2
a7846 5
	case 4:
	  act("$n charges right out of the room.",ch,NULL,victim,TO_ROOM,FALSE);
	  act("You charge right out of the room.",ch,NULL, victim,TO_CHAR,FALSE);
	  move_char ( ch, DIR_SOUTH, FALSE);
	  WAIT_STATE( ch, skill_table[gsn_kcharge].beats*3);
d7848 2
a7849 15
	case 6:
	  act("$n charges right out of the room.",ch,NULL,victim,TO_ROOM,FALSE);
	  act("You charge right out of the room.",ch,NULL, victim,TO_CHAR,FALSE);
	  move_char ( ch, DIR_EAST, FALSE);
	  WAIT_STATE( ch, skill_table[gsn_kcharge].beats*3);
	break;
	case 8:
	  act("$n charges right out of the room.",ch,NULL,victim,TO_ROOM,FALSE);
	  act("You charge right out of the room.",ch,NULL, victim,TO_CHAR,FALSE);
	  move_char ( ch, DIR_DOWN, FALSE);
	  WAIT_STATE( ch, skill_table[gsn_kcharge].beats*3);
	break;
	default:
        WAIT_STATE( ch, skill_table[gsn_kcharge].beats*2);
      } 
@


1.557
log
@missing , in double exp day new lines
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.556 2000/09/24 21:27:38 mud Exp $";
a4271 1
    */
d4440 1
@


1.556
log
@double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.555 2000/09/20 22:54:18 mud Exp $";
d4427 1
a4427 1
	    act("Be sure to wish SierraFlame a happy early birthday."
d4432 1
a4432 1
	    act("BADOOF! Damn that was an experience!"
@


1.555
log
@ get rid of some ambiguous else with bracketswarnings
 -poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.554 2000/09/20 22:35:41 mud Exp $";
d4272 1
d4319 1
a4319 1
	    act("Prowler teaches you to do the Roxbury",
d4411 1
a4411 1
	    xp *= 3;
d4426 7
a4432 2
	    xp *= 2;
	    act("Falcor rocks on like a bad 80's band.",
a4440 1
    */
@


1.554
log
@charmies remove last attacked by of master as well as flags
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.553 2000/09/19 20:47:11 mud Exp $";
d2023 1
d2026 1
d2028 1
d2031 1
@


1.553
log
@ bug fix in do_group.  Commented out POq's code until I can spend time to fix
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.552 2000/09/16 03:48:31 mud Exp $";
d2010 1
d2012 1
d2015 6
d2022 8
a2029 1
	  if (!str_cmp(victim->name,ch->pcdata->last_attacked_by))
a2030 7
	     /*free_string( ch->pcdata->last_attacked_by );*/
	     ch->pcdata->last_attacked_by = str_dup("no one");
	  }

          if(   !IS_SET(ch->mhs,MHS_HIGHLANDER)
             && !IS_SET(victim->mhs,MHS_HIGHLANDER))
          {
d2042 19
@


1.552
log
@15SEP00 - Made it so do_charge checks the class of teh char.  if they're a
          warrior type they gotta use polearm.  cleric types use flail
	  -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.551 2000/09/13 14:01:49 mud Exp $";
d1024 1
a1024 1
	dam *= 2; 
@


1.551
log
@
added check for holylight to detect good/evil and see spell effects like detect magic

slightly curved damage done by morphed chars

changed sneak again to make it less effective
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.550 2000/09/12 15:57:44 mud Exp $";
d7723 5
d7729 3
a7731 1
  if (obj == NULL || obj->value[0] != WEAPON_POLEARM )
d7736 9
a7744 1
 
@


1.550
log
@Took out wield value reset on kcharge damage check in one_hit()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.549 2000/09/11 21:15:11 mud Exp $";
d978 1
a978 1
	dam += (dam * get_skill(ch,gsn_morph)) / 100;
@


1.549
log
@Moved the exit/return() up before the EXP loss for gladiators
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.548 2000/09/10 18:30:26 mud Exp $";
d1042 2
a1043 2
     wield = get_eq_char( ch,WEAR_WIELD );
     if ( dt == gsn_kcharge && wield->value[0] != WEAPON_POLEARM)
a1265 7
/* Added to see if the function damage() is even reached and attempt to
 * log the arguments passed possibly causing the crash.
  sprintf(log_buf,"%s ch  %s victim %d dam %d dt %d dam_type %d show %d iOld",
  ch->name,victim->name,dam,dt,dam_type,show,iOld);
  log_string(log_buf);
  */

d1420 5
a1424 2
    if ( IS_AFFECTED(ch, AFF_SNEAK) && ( ch->class != class_lookup("thief")
	 && ch->class != class_lookup("assassin") )
@


1.548
log
@10SEP00 - fight.c logic changed in kcharge and fixdd pointer deal too
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.547 2000/09/10 18:24:32 mud Exp $";
d1847 3
a1882 3
          /* Ch and Victim are both gladiators in Gladiator Combat */
	  if (fGladiatorKill)
	     return TRUE;
@


1.547
log
@10SEP00 - Took out warnings in mag2.c and fight.c unused vars -0 Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.546 2000/09/10 15:12:29 mud Exp $";
d7741 1
a7741 1
  if( IS_NPC(ch->riding) && is_mounted(ch) && ch->riding->pIndexData == MOB_VNUM_WARHORSE )
@


1.546
log
@10SEP00 - Added messages to the do_kcharge function for when they fail.
          The char is told they charge out of the room, the room is
	  told the char charged out of the room.  stop_fighting still
	  in place and works like a charm.
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.545 2000/09/09 17:49:52 mud Exp $";
d7685 1
a7685 1
  CHAR_DATA *victim1;
d7687 2
a7688 4
  char buf[MAX_STRING_LENGTH];
  int wait_mod = 0;
  int percent, count = 0;
  int dt;
d7690 1
a7690 1

d7702 1
d7733 7
d7741 1
a7741 1
  if( is_mounted(ch) && count != 0 )
d7842 1
a7842 1
    send_to_char("You better saddle up on your handy dandy warhorse if you want to charge.\n\r",ch );
@


1.545
log
@09SEP00 - ok all better now ()'s in place - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.544 2000/09/09 17:41:46 mud Exp $";
d7799 4
a7802 2
	move_char ( ch, DIR_NORTH, FALSE);
	WAIT_STATE( ch, skill_table[gsn_kcharge].beats*2);
d7805 4
a7808 2
	move_char ( ch, DIR_WEST, FALSE);
	WAIT_STATE( ch, skill_table[gsn_kcharge].beats*2);
d7811 4
a7814 2
	move_char ( ch, DIR_SOUTH, FALSE);
	WAIT_STATE( ch, skill_table[gsn_kcharge].beats*2);
d7817 4
a7820 2
	move_char ( ch, DIR_EAST, FALSE);
	WAIT_STATE( ch, skill_table[gsn_kcharge].beats*2);
d7823 4
a7826 2
	move_char ( ch, DIR_DOWN, FALSE);
	WAIT_STATE( ch, skill_table[gsn_kcharge].beats*2);
d7829 1
a7829 1
        WAIT_STATE( ch, skill_table[gsn_kcharge].beats);
@


1.544
log
@09SEP00 - Thanks to Rusty, the favored attack bug fixed. - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.543 2000/09/09 16:32:09 mud Exp $";
d7729 1
a7729 1
  if ( obj->value[0] == NULL || obj->value[0] != WEAPON_POLEARM )
@


1.543
log
@09SEP00 - Okies, I think kcharge is finalized :)
          -corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.542 2000/09/09 16:20:35 mud Exp $";
d346 1
a346 1
	 && dt != gsn_backstab  ||  dt != gsn_kcharge)
d7729 1
a7729 1
  if ( obj == NULL || obj->value[0] != WEAPON_POLEARM )
@


1.542
log
@09SEP00 - Ok, changed fight.c so that victim in do_kcharge wasn't getting
          reset a whole bunch.  I was sloppy, but i'm learning :).
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.541 2000/09/09 06:04:02 mud Exp $";
d7823 4
d7828 1
a7828 1
  } 
@


1.541
log
@08SEP00 - Ok, I've done enought damage for one night :).  I commented out the
code that causes kcharge to crash. - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.540 2000/09/09 05:55:45 mud Exp $";
d7685 1
d7692 13
d7735 1
a7735 13
/*  for ( victim = char_list; victim != NULL; victim = victim->next )
  if ( (is_same_group( victim, ch ) && IS_SET(victim->mhs,MHS_WARHORSE))
     || (is_same_group(victim->master,ch) && IS_SET(victim->mhs,MHS_WARHORSE)) )
     {
       count++;
     }
  if(count != 0 )
    {
      send_to_char("Your squire knocks coconuts together while you charge around the room.\n\r",ch );
      return;
    }
*/
  if( is_mounted(ch) )
@


1.540
log
@08SEP00 - Trying a different tack on the logic here.  I think i  figured
          out why kcharge crashes -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.539 2000/09/09 05:45:15 mud Exp $";
d7679 1
a7679 1
/*STart of do_kcharge function - started 26AUG000 by Boogums */ 
d7721 1
a7721 1
  for ( victim = char_list; victim != NULL; victim = victim->next )
d7727 1
a7727 1
  if(count != 0 && is_mounted(ch) )
d7729 1
a7729 1
/*      send_to_char("Your squire knocks coconuts together while you charge around the room.\n\r",ch );
d7732 1
a7732 1

d7735 1
a7735 1
*/
@


1.539
log
@08SEP00 - Another test in kcharge, i think i figured it out - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.538 2000/09/09 05:05:55 mud Exp $";
d7727 1
a7727 1
  if(count == 0)
d7729 1
a7729 1
      send_to_char("Your squire knocks coconuts together while you charge around the room.\n\r",ch );
d7733 1
a7733 1
  else  if(is_mounted(ch) && count == 1)
d7735 1
@


1.538
log
@08SEP00 -So this is a bug hunt huh? I'm pretty sure i've narrowed it down
         to where the problem is - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.537 2000/09/09 04:59:48 mud Exp $";
d7688 1
a7688 1
  int percent, count;
d7720 1
a7720 2
/*
  count = 0;
d7723 1
a7723 1
     || (is_same_group(victim->master,ch) && IS_SET(victim->mhs,MHS_WARHORSE)))
d7732 2
a7733 2
*/
   if(is_mounted(ch))
d7743 1
a7743 1
    if ( !IS_NPC(ch) && ch->level < skill_level(ch,gsn_kcharge) )
d7748 1
a7748 1

@


1.537
log
@08SEP00 - It's crashing, taking out code i aded tonight -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.536 2000/09/09 04:50:23 mud Exp $";
d7691 1
a7691 1
/*  if (arg[0] == '\0')
d7706 1
a7706 1
*/
d7712 1
@


1.536
log
@08SEP00 - Ok, the sanity checks are working right, it's in the main part
          of the kcharge code hmmm, interesting captian...fight.c tweaked
	  some more :) -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.535 2000/09/09 04:39:56 mud Exp $";
d7691 1
a7691 1
  if (arg[0] == '\0')
d7706 2
a7707 2

/*  if ((victim = get_char_room(ch,arg)) == NULL)
d7711 1
a7711 1
  } */
d7719 1
d7732 1
@


1.535
log
@08SEP00 - Wow, C's picky ;) this should take care of the kcharge crash bug
          -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.534 2000/09/09 04:30:44 mud Exp $";
d7816 1
@


1.534
log
@08SEP00 - Think I have the crash bug in kcharge fixed - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.533 2000/09/09 04:23:16 mud Exp $";
d7693 1
d7817 1
@


1.533
log
@08SEP00 - Ok, that didn't work, trying this now -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.532 2000/09/09 04:05:38 mud Exp $";
a7692 1
    victim = ch->fighting;
d7730 2
a7731 2
  /* if(is_mounted(ch))
    { */
d7816 1
a7816 1
  /* } */
@


1.532
log
@08SEP00 - And the band on... another attempt at fixing the kcharge crash bug
          -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.531 2000/09/09 03:58:12 mud Exp $";
d7691 17
a7707 1
  if ((victim = get_char_room(ch,arg)) == NULL)
d7711 1
a7711 1
  }
@


1.531
log
@08SEP00 - Ok, i think i fixed the crash bug in kcharge, K.I.S.S. is the principle
          I shall follow from now on ;)
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.530 2000/09/09 03:44:52 mud Exp $";
d7715 2
a7716 2
  if(is_mounted(ch))
    {
d7801 1
a7801 1
  }
@


1.530
log
@08SEP00 - Minor tweaks to fight.c dealing with gsn_kcharge.  Also made it
          so they HAVE to be mounted on a warhorse to kcharge (hopefully ;))
	  only file modified is fight.c -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.529 2000/09/08 03:54:35 mud Exp $";
d7715 1
a7715 1
  if(is_mounted(ch) && count == 1)
@


1.529
log
@06SEP00 - Made some changes to kcharge and fight.c going to see if i get
          those weapon attacks in now :) - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.528 2000/09/04 18:09:35 mud Exp $";
d346 1
a346 1
	 && dt != gsn_backstab  && dt != gsn_kcharge)
d7688 1
a7688 1
  int percent;
d7703 13
a7715 2

  if(is_mounted(ch))
@


1.528
log
@04SEP00 - Ok, i think i got kcharge fighrued out :) -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.527 2000/09/04 16:12:07 mud Exp $";
d346 1
a346 1
	 && dt != gsn_backstab )
d364 1
a364 1
    if ( ch->fighting != victim || dt == gsn_backstab )
d562 1
a562 1
    if (ch->fighting != victim || dt == gsn_backstab)
d814 6
d1041 10
d7689 1
d7716 1
a7716 1
	send_to_char("Your charge fails.\n\r",ch );
a7749 2
    WAIT_STATE( ch,skill_table[gsn_kcharge].beats+7 );

d7754 1
a7754 1
      multi_hit( ch,victim,gsn_kcharge );
d7758 2
d7762 27
a7788 2
      }
     
d7790 1
a7790 5
    else
      {
      send_to_char("You need to be mounted on your warhorse to charge.\r\n",ch);
      return;
      }
@


1.527
log
@04SEP00 - Ok, I think the polearm thing is taken care of in kcharge in fight.c
         -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.526 2000/09/04 15:28:42 mud Exp $";
d7681 1
a7681 1
  if ( obj == NULL || obj->item_type != WEAPON_POLEARM )
@


1.526
log
@04SEP00 - Ok, i think i got kcharge checking what it's supposed to be
checking :)  slight change made to fight.c - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.525 2000/09/04 05:40:45 mud Exp $";
d7679 7
a7696 5
    if ( obj = get_eq_char( ch,WEAR_WIELD )  != WEAPON_POLEARM) 
      {
      send_to_char( "You need to wield a polearm in order to charge.\n\r", ch );
      return;
      }
@


1.525
log
@03SEP00 - Many thanks to Rage for pointin out why it wasn't working :)
          clean compile.  changes made to fight.c and do_mount
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.524 2000/09/04 03:47:36 mud Exp $";
d7690 5
a7694 5
        if ( (obj = get_eq_char( ch,WEAR_WIELD ) ) != WEAPON_POLEARM) 
        {
          send_to_char( "You need to wield a polearm in order to charge.\n\r", ch );
          return;
        }
a7699 5
    if ((victim = get_char_room(ch,arg)) == NULL)
	{
	  send_to_char("They aren't here. \n\r",ch);
	  return;
	}
d7701 2
a7702 2
     if (victim == ch)
       {
d7705 1
a7705 1
       }
@


1.524
log
@03SEP00 - Ok got some debugging lines in.  going to test it on olc
          and see if i can get this to work :) -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.523 2000/09/03 22:45:34 mud Exp $";
d7674 5
d7690 1
a7690 3
    if ( !IS_AFFECTED(ch,AFF_MORPH)
        && ( (obj = get_eq_char( ch, WEAR_WIELD ) ) == NULL )
        || ( (obj = get_eq_char( ch,WEAR_WIELD ) ) != WEAPON_POLEARM) )
a7694 1
       send_to_char("Right before teh check to see if it fails\n\r",ch);     
a7697 1
	send_to_char("Chage failed, returning from function\n\r",ch);
d7700 1
a7700 10
    if (arg[0] == '\0')
      {
	victim = ch->fighting;
	if (victim == NULL)
	{
	  send_to_char("Charge whom?\n\r",ch);
	  return;
	}
      }
      else if ((victim = get_char_room(ch,arg)) == NULL)
@


1.523
log
@03SEP00 - Ok testing something out with kcharge, now only checking to
          see if the attacker is mounted - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.522 2000/09/03 22:04:37 mud Exp $";
d7692 1
a7692 1
      
d7696 1
@


1.522
log
@03SEP00 - Ok, i think i have the if statement in fight.c right for the
          kcharge command. - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.521 2000/09/03 21:19:27 mud Exp $";
d7675 1
a7675 1
  if(is_mounted(ch) && (ch->riding == get_mob_index(MOB_VNUM_WARHORSE) ) )
@


1.521
log
@03SEP00 - try two at the kcharge skill :) -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.520 2000/09/03 21:06:47 mud Exp $";
d7675 1
a7675 1
  if(is_mounted(ch) && (ch->riding == "warhorse" ) )
@


1.520
log
@03SEP00 - First run of kcharge skill.  Have modified db.c for gsn_kcharge
          ,the kcharge function is in fight.c.  Have modifeid const.c
	  fight.c for new skill.  Going to compile and test on olc.
	  -Corey aka Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.519 2000/09/02 22:55:56 mud Exp $";
d7675 1
a7675 1
  if(is_mounted(ch) && (ch->riding == MOB_VNUM_WARHORSE))
@


1.519
log
@02SEP00 - Added nuke_pets to update.c to get rid of the warhorses
          when the life timer expires - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.518 2000/08/31 12:39:57 mud Exp $";
d7661 3
a7663 2
/*
start of do_kcharge function - started 26AUG000 by Boogums 
d7675 1
a7675 1
  if(is_mounted(ch) && ch->riding == MOB_VNUM_WARHORSE && exit_data != NULL)
d7686 2
a7687 2
        && (obj = get_eq_char( ch, WEAR_WIELD ) ) == NULL
        || (obj = get_eq_char( ch,WEAR_WIELD ) ) != WEAPON_POLEARM) )
d7695 1
a7695 1
	send_to_char("You knock your coconuts together and trot around.\n\r",ch );
d7704 1
a7704 1
	  return:
d7726 16
d7743 1
d7745 11
d7763 4
a7766 6
    if(exit_data == NULL)
      {
      send_to_char("There is not enough room for you to charge here.\r\n",ch);
      return;
      }
} End curly brace for do_kcharge */
@


1.518
log
@ fixed bug with Almighty worshipers, Ealot and gladiators
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.517 2000/08/28 13:38:06 mud Exp $";
d7666 60
a7725 7
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    char buf[MAX_STRING_LENGTH];
    int wait_mod = 0;
    int percent;
    one_argument( argument, arg );
d7727 7
d7737 1
@


1.517
log
@ saction hall moves victim to recall

 bug fix on communion allowing negative sac points

 bug fix on sneaking mobs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.516 2000/08/27 23:23:06 mud Exp $";
d868 3
a870 1
      && ch->pcdata->deity == deity_lookup("almighty") )
@


1.516
log
@27-Aug-00 Making skill point tracker work in skills.c - Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.515 2000/08/26 18:38:11 mud Exp $";
d1689 1
a1689 1
       if( victim->pcdata->sac < dam )
@


1.515
log
@remove double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.514 2000/08/24 19:23:58 mud Exp $";
d55 2
d7659 18
@


1.514
log
@adding in double xp
fixed little bug with grenades not being correctly loaded
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.513 2000/08/20 01:14:47 mud Exp $";
d4221 1
a4221 1
    xp = 95 * xp / 100; /* Gradually step this down until it's about 75 */
d4224 1
a4224 1
    --- Dont forget to change 'override' to TRUE in act_wiz.c */  
d4388 1
@


1.513
log
@highlanders dont lose exp on death
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.512 2000/08/20 00:15:18 mud Exp $";
d4224 1
a4224 1
    --- Dont forget to change 'override' to TRUE in act_wiz.c   
d4362 20
a4387 1
    */
@


1.512
log
@debug highlander
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.511 2000/08/20 00:11:25 mud Exp $";
d1838 2
a1839 1
                if (!IS_SET (ch->in_room->room_flags,ROOM_NODIE))
d1850 2
a1851 1
                if (!IS_SET (ch->in_room->room_flags,ROOM_NODIE))
@


1.511
log
@highlander bugs and loggins some highlander stuff
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.510 2000/08/19 22:58:13 mud Exp $";
d3628 1
d3658 6
@


1.510
log
@highlander bugs
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.509 2000/08/19 21:56:26 mud Exp $";
d90 3
d3629 7
d3655 2
a3656 16
   /* Remove Stats for Victims ALL_KILLS */
   victim->pcdata->perm_hit -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->pcdata->perm_mana -= (victim->highlander_data[ALL_KILLS]) * 100; 
   victim->pcdata->perm_move -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_hit -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_mana -= (victim->highlander_data[ALL_KILLS]) * 100;
   victim->max_move -= (victim->highlander_data[ALL_KILLS]) * 100;

   /* Reset Victims Counters */
   victim->highlander_data[ALL_KILLS] = 0;
   victim->highlander_data[REAL_KILLS] = 0;

   victim->clan = victim->pcdata->save_clan;
   victim->pcdata->save_clan = 0;

   REMOVE_BIT(victim->mhs,MHS_HIGHLANDER);
@


1.509
log
@new highlander code -poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.508 2000/08/18 23:52:34 mud Exp $";
d2269 1
a2269 1
        && !IS_NPC(ch))
d2276 1
a2276 1
        IS_SET(victim->in_room->room_flags,ROOM_NOCOMBAT))
d2455 1
a2455 1
       && !IS_NPC(ch))
d2469 1
a2469 1
        IS_SET(victim->in_room->room_flags,ROOM_NOCOMBAT))
d2647 1
a2647 1
	&& !IS_NPC(ch))
d2660 1
a2660 1
        IS_SET(victim->in_room->room_flags,ROOM_NOCOMBAT))
@


1.508
log
@highlanders use temp clan, kr only shows highlandder info and fix levle limits
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.507 2000/08/18 22:52:08 mud Exp $";
d2275 7
d2468 6
d2659 6
d7165 6
@


1.507
log
@highlanders do not steal,slice, cutpurse
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.506 2000/08/18 22:49:02 mud Exp $";
d2388 2
d2746 2
d3637 3
@


1.506
log
@Highlanders Abound
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.505 2000/08/18 00:20:46 mud Exp $";
d7077 1
a7077 1
   if(IS_SET(ch->mhs,MHS_GLADIATOR))
@


1.505
log
@so gladiators dont lose exp, check the inroom of ch not victim cause
victim is already transed back to hall
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.504 2000/08/16 19:01:44 mud Exp $";
d3611 6
a3616 6
   ch->pcdata->perm_hit += (victim->highlander_data[ALL_KILLS] +1) * 5;
   ch->pcdata->perm_mana += (victim->highlander_data[ALL_KILLS] +1) * 5;
   ch->pcdata->perm_move += (victim->highlander_data[ALL_KILLS] +1) * 5;
   ch->max_hit += (victim->highlander_data[ALL_KILLS] +1) * 5;
   ch->max_mana += (victim->highlander_data[ALL_KILLS] +1) * 5;
   ch->max_move += (victim->highlander_data[ALL_KILLS] +1) * 5;
d3622 7
a3628 15
   /* Remove Stats for Victims ALL_KILLS + 1 penalty for dieing */
   victim->pcdata->perm_hit -= (victim->highlander_data[ALL_KILLS] +1) * 5;
   victim->pcdata->perm_mana -= (victim->highlander_data[ALL_KILLS] +1) * 5;
   victim->pcdata->perm_move -= (victim->highlander_data[ALL_KILLS] +1) * 5;
   victim->max_hit -= (victim->highlander_data[ALL_KILLS] +1) * 5;
   victim->max_mana -= (victim->highlander_data[ALL_KILLS] +1) * 5;
   victim->max_move -= (victim->highlander_data[ALL_KILLS] +1) * 5;

   /* Deliver Quest Prize for Victims REAL_KILLS */
   victim->pcdata->perm_hit += victim->highlander_data[REAL_KILLS] *5;
   victim->pcdata->perm_mana += victim->highlander_data[REAL_KILLS] *5;
   victim->pcdata->perm_move += victim->highlander_data[REAL_KILLS] *5;
   victim->max_hit -= victim->highlander_data[REAL_KILLS] * 5;
   victim->max_mana -= victim->highlander_data[REAL_KILLS] * 5;
   victim->max_move -= victim->highlander_data[REAL_KILLS] * 5;
@


1.504
log
@doh extra )
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.503 2000/08/16 19:00:42 mud Exp $";
d1835 1
a1835 1
                if (!IS_SET (victim->in_room->room_flags,ROOM_NODIE))
d1846 1
a1846 1
                if (!IS_SET (victim->in_room->room_flags,ROOM_NODIE))
@


1.503
log
@remove holy light in case thats whats causeing death bug
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.502 2000/08/16 15:27:15 mud Exp $";
d1703 1
a1703 1
       && (victim->level >= LEVEL_IMMORTAL ))
@


1.502
log
@ removed comments around zealot/almighty code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.501 2000/08/16 15:26:21 mud Exp $";
d1703 1
a1703 1
       && (victim->level >= LEVEL_IMMORTAL || IS_SET(victim->display,PLR_HOLYLIGHT))
@


1.501
log
@ attempting to fix olist command
 fixed crash bug in with zealots being attacked by mobs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.500 2000/08/13 04:31:26 mud Exp $";
d860 1
a860 1
  /* check diety and clan for Almigty 
a868 1
	 */
@


1.500
log
@ removed some code to punish those pledged to alimighty attacking zealots
 was crashing the game
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.499 2000/08/12 22:56:21 mud Exp $";
d861 3
a863 2
  if ( !IS_NPC(victim) && victim->clan == clan_lookup("zealot") &&
	 ch->pcdata->deity == deity_lookup("almighty") )
@


1.499
log
@ some minor changes to Almighty gifts
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.498 2000/08/10 21:12:35 mud Exp $";
d860 1
a860 1
  /* check diety and clan for Almigty */
d868 1
@


1.498
log
@put in check for nether kit at point where nethermancy is checked in dieing
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.497 2000/07/28 15:22:33 mud Exp $";
d860 8
a867 1

@


1.497
log
@Typo fix
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.496 2000/07/28 15:10:04 mud Exp $";
d1655 1
@


1.496
log
@Missing ,
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.495 2000/07/28 15:03:48 mud Exp $";
d1694 1
a1694 2
       &&   ( victim->level >= LEVEL_IMMORTAL 
	    || IS_SET(victim->display,DISP_CODER))
@


1.495
log
@Gladiator timer not reset by damaging self
added a glad message for Kailindo
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.494 2000/07/27 18:11:51 mud Exp $";
d1550 1
a1550 1
	    	"%s evades an attack from %s and quickly strikes back."
@


1.494
log
@fix nodie bug
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.493 2000/07/27 00:37:07 mud Exp $";
d1421 1
a1421 1
    if(!IS_NPC(ch) && IS_SET(ch->mhs,MHS_GLADIATOR))
d1546 10
a1555 1
           return FALSE;
d1694 2
a1695 1
       &&   ( victim->level >= LEVEL_IMMORTAL )
@


1.493
log
@adjust smaller races dodge + down a bit, adjust rockbiters damage up
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.492 2000/07/26 02:38:28 mud Exp $";
d1817 1
a1817 1
                if (IS_SET (victim->in_room->room_flags,ROOM_NODIE))
d1828 1
a1828 1
                if (IS_SET (victim->in_room->room_flags,ROOM_NODIE))
@


1.492
log
@remove double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.491 2000/07/25 19:43:46 mud Exp $";
d1031 3
d3276 1
a3276 1
    chance += ( ( ch->size - victim->size ) * 3 );
@


1.491
log
@new d-exp messages and rmeove rage joke
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.490 2000/07/25 00:42:39 mud Exp $";
a4180 1
    */
d4324 1
@


1.490
log
@putitng double exp in
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.489 2000/07/24 20:56:46 mud Exp $";
d4312 5
@


1.489
log
@double exp day bonueses testing
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.488 2000/07/24 20:47:54 mud Exp $";
d4181 1
d4309 5
a4319 1
    */
@


1.488
log
@d-day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.487 2000/07/24 20:32:23 mud Exp $";
d4301 1
a4301 1
            if( gch->exp + xp > (exp_per_level(gch,gch->pcdata->points) * (gch->level+1 )) )
d4305 1
a4305 1
               gch->pcdata->debit_level++;
a4314 6
            if( gch->exp + xp > (exp_per_level(gch,gch->pcdata->points) * (gch->level+1 )) )
	    {
	       act("Prowler thinks you deserve an extra level!",
                   gch,NULL,NULL,TO_CHAR,FALSE);
               gch->exp += exp_per_level(gch,gch->pcdata->points);
	    }
@


1.487
log
@testing dexp code
-poQ
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.486 2000/07/24 20:16:59 mud Exp $";
d4319 1
a4319 1
               gch->pcdata->debit_level++;
@


1.486
log
@double exp still
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.485 2000/07/24 20:13:14 mud Exp $";
a4180 1
    */
d4312 1
d4314 7
@


1.485
log
@missing " in double exp
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.484 2000/07/24 20:12:07 mud Exp $";
d4302 1
a4302 1
            if( gch->exp + xp > (exp_per_level(ch,ch->pcdata->points) * (ch->level+1 )) )
d4305 1
a4305 1
                   gch,NULL,NUL,TO_CHAR,FALSE);
@


1.484
log
@double exp day work
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.483 2000/07/24 20:08:37 mud Exp $";
d4304 1
a4304 1
	       act(Prowler thinks you deserve an extra level!",
@


1.483
log
@putting double exp code in olc ot test some stuff
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.482 2000/07/22 21:45:21 mud Exp $";
a4181 1
    #ifdef CODE_TEST
a4313 1
    #endif
@


1.482
log
@put a log on buffy damage so we can average/judeg whats going on
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.481 2000/07/21 21:51:21 mud Exp $";
d4181 2
d4315 1
a4315 1
    */
@


1.481
log
@attempt to fix not losing exp with mobs killing you
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.480 2000/07/20 22:16:27 mud Exp $";
d1431 3
d1435 3
@


1.480
log
@fix an old double exp problem
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.479 2000/07/20 20:37:49 mud Exp $";
d1790 1
@


1.479
log
@gladiator messages
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.478 2000/07/20 20:12:36 mud Exp $";
d4173 1
@


1.478
log
@Matookers will not hear distress crys when quiet
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.477 2000/07/18 17:06:28 mud Exp $";
d6371 1
d6432 7
d6774 1
a6774 1
       sprintf(buf,"%s takes off running! The crowd boos and laughs.",victim->name);
d6805 1
d6861 6
d7085 1
d7199 7
@


1.477
log
@changed act_new() and get_char_room() to use HOLYLIGHT settings
for can/cannot see.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.476 2000/07/18 00:56:55 mud Exp $";
d1706 1
d1735 1
@


1.476
log
@ when a gladiator quits, bets on him are removed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.475 2000/07/14 16:50:37 mud Exp $";
d2014 1
d2019 1
@


1.475
log
@ fixed bugs in blind glad code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.474 2000/07/14 13:25:28 mud Exp $";
d3094 2
a3095 1
   if ( weapon && weapon->value[0] == WEAPON_AXE )
@


1.474
log
@ Moved mistform up the defense list to be checked before dodge
 Stripped mistform affect if duration got to 0
 Non-glads can see glads all the time
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.473 2000/07/13 20:02:19 mud Exp $";
d3191 1
a3191 1
    if (paf->duartion == 0)
@


1.473
log
@fix a couple blind glad things
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.472 2000/07/13 18:40:43 mud Exp $";
d1516 1
a1516 1
        if ( check_dodge( ch, victim,fSecondary ) )
d1521 1
a1521 1
              sprintf(cdbuf,"%s dodges an attack from %s.",victim->name,ch->name);
d1526 1
a1526 3
        if ( check_kailindo( ch, victim ) )
           return FALSE;
        if ( check_shield_block(ch,victim,fSecondary))
d1531 1
a1531 1
              sprintf(cdbuf,"%s blocks an attack from %s with a shield.",victim->name,ch->name);
d1536 3
a1538 1
        if ( check_mistform(ch,victim))
d1543 1
a1543 1
              sprintf(cdbuf,"What the hell was that?! %s's weapon just went right through %s.",ch->name,victim->name);
d3191 4
@


1.472
log
@fix gladiator flee bug
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.471 2000/07/13 01:25:21 mud Exp $";
d5809 6
a5814 1
      sprintf( buf, "Help!  I am being attacked by %s!", ch->name );
@


1.471
log
@working on blind glads
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.470 2000/07/12 23:56:25 mud Exp $";
d6003 1
a6003 4
  if(IS_SET(ch->mhs,MHS_GLADIATOR))
     act( "$l has fled!", ch, NULL, NULL, TO_ROOM ,FALSE);
  else
     act( "$n has fled!", ch, NULL, NULL, TO_ROOM ,FALSE);
@


1.470
log
@more on blind glads and shpemorphed
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.469 2000/07/12 22:22:14 mud Exp $";
d6003 4
a6006 1
  act( "$n has fled!", ch, NULL, NULL, TO_ROOM ,FALSE);
@


1.469
log
@working on blind glad matches
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.468 2000/07/06 15:35:57 mud Exp $";
d7015 3
@


1.468
log
@ added in message to room for failed brew attempts
 changed min position for hide to POS_FIGHTING
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.467 2000/06/29 22:57:49 mud Exp $";
d6584 6
@


1.467
log
@gladiaators dont disarm or go over weight
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.466 2000/06/27 04:23:25 mud Exp $";
d5008 1
@


1.466
log
@ missed a gch instead of ch *sigh*
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.465 2000/06/27 03:52:47 mud Exp $";
d4441 2
a4442 1
	 ch->class == class_lookup("blademaster") )
d4468 2
a4469 1
    if ( IS_OBJ_STAT(obj,ITEM_NODROP) || IS_OBJ_STAT(obj,ITEM_INVENTORY) )
@


1.465
log
@ Added new paladin spell indulgence, keeps alignment from changing whenm cast

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.464 2000/06/26 06:29:37 mud Exp $";
d4006 1
a4006 1
    || is_affected(ch, skill_lookup("indulgence")) )
@


1.464
log
@no alignment changes for gladiators
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.463 2000/06/26 04:20:28 mud Exp $";
d1107 2
a1108 1
      if (!IS_SET(ch->mhs,MHS_GLADIATOR))
d4005 2
a4006 1
    if (IS_SET(victim->act,ACT_NOALIGN) || IS_SET(gch->mhs,MHS_GLADIATOR))
@


1.463
log
@can not faerie fog in prep room of gladiators
added withstand death message on glad spectator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.462 2000/06/26 00:18:32 mud Exp $";
d1106 3
a1108 1
      ch->alignment = UMAX(-1000,ch->alignment - 1);
d4003 2
a4004 1
    if (IS_SET(victim->act,ACT_NOALIGN))
@


1.462
log
@remove double exp code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.461 2000/06/25 23:41:33 mud Exp $";
d3840 6
@


1.461
log
@remove level restrictions from gladiators
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.460 2000/06/25 23:31:01 mud Exp $";
d4151 1
a4152 1
    */
a4270 1
	    /*
a4271 3
	    act(Prowler thinks you deserve an extra level!",
		gch,NULL,NUL,TO_CHAR,FALSE);
            gch->pcdata->debit_level++;
d4273 6
a4279 1
	    */
d4285 1
@


1.460
log
@do not lose exp in NODIE rooms on death
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.459 2000/06/23 19:37:27 mud Exp $";
d2351 3
d2706 3
@


1.459
log
@Commented out an extra line on the last change, correcting.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.458 2000/06/23 19:16:53 mud Exp $";
d1802 4
a1805 1
                gain_exp( victim, (exp_per_level(victim,victim->pcdata->points)
d1807 1
d1813 4
a1816 1
                gain_exp( victim, (exp_per_level(victim,victim->pcdata->points)
d1818 1
@


1.458
log
@Took out the free_string() calls in the death code (ie: raw_kill() )
to see if it helps with the memory problems we've been having.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.457 2000/06/23 10:40:29 mud Exp $";
d3475 1
a3475 1
    /*corpse->short_descr = str_dup( buf );*/
@


1.457
log
@ committ
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.456 2000/06/23 09:43:51 mud Exp $";
d1863 1
a1863 1
	     free_string( ch->pcdata->last_kill );
d1865 1
a1865 1
	     free_string( ch->pcdata->last_killed_by );
d1954 1
a1954 1
	     free_string( ch->pcdata->last_attacked_by );
d3474 2
a3475 2
    free_string( corpse->short_descr );
    corpse->short_descr = str_dup( buf );
d3478 1
a3478 1
    free_string( corpse->description );
d3677 1
a3677 1
  free_string( obj->short_descr );
d3681 1
a3681 1
  free_string( obj->description );
@


1.456
log
@double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.455 2000/06/23 09:27:24 mud Exp $";
d4257 1
d4264 1
@


1.455
log
@f cuken typo
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.454 2000/06/23 09:25:47 mud Exp $";
a4140 2
            gch->pcdata->debit_level++;
	    /*
d4260 2
a4261 1
            ch->pcdata->debit_level++;
a4266 1
       */
@


1.454
log
@test double exp code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.453 2000/06/22 22:50:16 mud Exp $";
d4141 1
a4141 1
            ch->pcdata->debit_level++;
@


1.453
log
@save pfile when you die to avoid duplicating items
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.452 2000/06/14 01:07:29 mud Exp $";
d4138 1
d4141 2
d4253 11
d4268 2
a4269 1
    }*/
@


1.452
log
@send mobs name to matooekrs in incap mesages
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.451 2000/06/14 01:01:10 mud Exp $";
d1978 5
@


1.451
log
@stop fighting if incap or mortal wounded and stop aggies from reattacking
this adds more use to Matooker's ability to see wounded.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.450 2000/05/30 00:26:41 mud Exp $";
d1690 2
a1691 2
        "%s is mortally wounded at %s.\n\r",
        victim->name,victim->in_room->name);
d1718 2
a1719 2
        "%s is incapacitated at %s.\n\r",
        victim->name,victim->in_room->name);
@


1.450
log
@add team stats to kr, score and stat
clean up bugs in team code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.449 2000/05/29 19:37:03 mud Exp $";
d1693 2
d1720 2
@


1.449
log
@adding new gladiator files and tteam gladiator code with gladitor code moved
out of old files.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.448 2000/05/27 03:42:40 mud Exp $";
a3760 1
           char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
@


1.448
log
@ Changed when the percentage check is done for extra crusader attacks


 In FAVOR of landing more attacks...not less

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.447 2000/05/27 02:44:10 mud Exp $";
d29 1
a88 1
void  gladiator_kill args( ( CHAR_DATA *victim, CHAR_DATA *ch ) );
d3754 2
a3755 3
	if(!IS_SET(victim->mhs,MHS_GLADIATOR))
           char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
	else
d3761 1
d3763 2
a7469 38
void gladiator_kill( CHAR_DATA *victim, CHAR_DATA *ch )
{
   char buf[MAX_STRING_LENGTH];

   REMOVE_BIT(victim->mhs, MHS_GLADIATOR);
   victim->clan = victim->pcdata->save_clan;
   victim->pcdata->save_clan = 0;
   sprintf(buf, "%s lands the killing blow on %s!", ch->name,victim->name);
   gladiator_talk(buf); 
   raw_kill( victim,ch );
   victim->hit  = victim->max_hit;
   victim->mana = victim->max_mana;
   victim->move = victim->max_move;
   update_pos(victim);
   if(gladiator_info.type == 1 || gladiator_info.type ==2)
   {
      gladiator_info.playing--;
      ch->gladiator_data[GLADIATOR_KILLS] += 1;

      if (gladiator_info.playing == 1)
      {
         sprintf(buf, "%s is victorious in the arena!", ch->name);
         gladiator_talk(buf); 

         gladiator_winner(ch);
      }
   }

   if(gladiator_info.type == 3 || gladiator_info.type == 4)
   {
      ch->gladiator_data[GLADIATOR_TEAM_KILLS] += 1;
      if(victim->pcdata->gladiator_team == 1)
	 gladiator_info.barbarian_score++;
      else
	 gladiator_info.gladiator_score++;
   }
   return;
}
@


1.447
log
@Kit Changing: REmove sepcial effects ( ennemy, spec)
Float: swim skill helps you vs floating away
Hold: casting level capped similar to sleep
Position for zap, brandish, quaff, recite set to Fighting
Check on eating pills for position at least of fighting
Snare: duration similar to hold

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.446 2000/05/26 14:07:11 mud Exp $";
d363 3
a365 5
    for ( counter = 1; counter <= number_of_crusaders; counter++)
     {
	if( (number_percent() < ( ch->pcdata->sac / 6)) &&
	    (number_percent() < (100/counter))
	  ) 
d367 9
a375 4
	if ( !IS_SET(ch->display,DISP_BRIEF_COMBAT))
		send_to_char("(Cru) ",ch);
	one_hit(ch,victim,dt);
    }
@


1.446
log
@ added in betting code to game port
 removed double xp
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.445 2000/05/26 02:07:29 mud Exp $";
d3111 1
a3111 1
    if ( HAS_KIT(victim,"wyrmslayer") )
@


1.445
log
@opps missing pcdata
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.444 2000/05/26 01:46:27 mud Exp $";
d4124 1
a4124 1
    /* double EXP day for the 25th of each month */ 
d4241 1
a4241 1
    }
@


1.444
log
@team gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.443 2000/05/25 14:47:16 mud Exp $";
d3755 1
a3755 1
           if(victim->gladiator_team == 1)
@


1.443
log
@ Turn on double xp
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.442 2000/05/24 03:38:30 mud Exp $";
d2328 3
d3751 9
a3759 1
        char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
d7475 8
a7482 2
   gladiator_info.playing--;
   ch->gladiator_data[GLADIATOR_KILLS] += 1;
d7484 10
a7493 1
   if (gladiator_info.playing == 1)
d7495 5
a7499 4
      sprintf(buf, "%s is victorious in the arena!", ch->name);
      gladiator_talk(buf); 

      gladiator_winner(ch);
@


1.442
log
@crusader mods, more attacks with more crusaders in group
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.441 2000/05/24 02:53:26 mud Exp $";
d4113 1
a4113 1
    /* double EXP day for the 25th of each month  
d4134 1
a4134 1
	    act("Big Hug!",
d4221 1
a4221 1
	    act("Janeron is a dumb ass.",
a4230 1
    */
@


1.441
log
@trap fixes, non clanners can't use it
similar to hold person now, snare puts yuou in resting position
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.440 2000/05/24 00:25:10 mud Exp $";
d288 2
d362 14
a375 1
    if ( group_has_crusader( ch ) &&
d382 1
a382 1

@


1.440
log
@force gladiators to attack eveyr 5 ticks or be disqualified
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.439 2000/05/23 04:58:58 mud Exp $";
d3344 4
@


1.439
log
@lower flee showings on spectator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.438 2000/05/23 04:12:39 mud Exp $";
d1395 4
@


1.438
log
@clean up some gladiator stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.437 2000/05/23 00:29:07 mud Exp $";
d5941 1
a5941 1
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 75)
@


1.437
log
@move gladiator kill before withstand death code inside check if withstand death I think withstand death is doing some funking thing to glads
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.436 2000/05/21 01:22:45 mud Exp $";
d6851 1
a6851 1
       sprintf(buf,"Now that was impressive! %s just sent %s weapon flying.",ch->name,victim->name);
@


1.436
log
@fix ruffian flag in gladiator
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.435 2000/05/21 00:28:55 mud Exp $";
d1209 1
d1755 9
d1789 1
a1789 5
	  if (IS_SET(ch->mhs,MHS_GLADIATOR) &&
	      IS_SET(victim->mhs,MHS_GLADIATOR) &&
	      gladiator_info.started == TRUE)
	  {
             gladiator_kill(victim,ch);  
d1791 1
a1791 1
	  }
d3718 61
a3778 55
  if (!IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH)) {
    if (IS_SET (victim->in_room->room_flags,ROOM_NODIE)) {
      act("$n disintegrates into dust.",victim,NULL,NULL,TO_ROOM,FALSE);
      char_from_room (victim);
      clear_mount( victim );
      char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
    } 
    else 
    {
      if (IS_SET(victim->mhs,MHS_HIGHLANDER) && IS_SET(ch->mhs,MHS_HIGHLANDER))
       {
	 highlander_die( ch,victim );
	 char_from_room(victim);
	 clear_mount( victim );
	 if (!is_clan(victim))
	 {
	    char_to_room(victim,get_room_index(clan_table[0].hall));
	 }
	 else
	 {
	    char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
	 }
         send_to_char( "You are blasted with the {GQuickening{x!\n\r", ch);
         act("$n is blasted by the {GQuickening{x.",ch,NULL,NULL,TO_ROOM,FALSE);
       }
       else
       {	 
          make_corpse( victim );
          extract_char( victim, FALSE );
       }
    }
    while ( victim->affected )
  affect_remove( victim, victim->affected,APPLY_BOTH );
  /* victim->affected_by = victim->affected_by|race_table[victim->race].aff;*/
  victim->affected_by = race_table[victim->race].aff;
    for (i = 0; i < 4; i++)
  victim->armor[i]= 100;
    victim->position    = POS_RESTING;
    victim->hit         = UMAX( 1, victim->hit  );
    victim->mana        = UMIN( 20, victim->mana );
    victim->move        = UMAX( 1, victim->move );
    /*
    REMOVE_BIT(victim->act,PLR_KILLER);
    REMOVE_BIT(victim->act,PLR_THIEF);
    REMOVE_BIT(victim->act,PLR_BOUGHT_PET);
    save_char_obj( victim ); */
    return;
  } else {
    victim->position    = POS_STANDING;
    while ( victim->affected )
  affect_remove( victim, victim->affected,APPLY_BOTH );
  victim->affected_by = victim->affected_by|race_table[victim->race].aff;
    victim->hit         = victim->max_hit/8;
    act("$n twitches a bit then stands up.",victim,NULL,NULL,TO_ROOM,FALSE);
    send_to_char ("A chilling wave passes over as you withstand death.\n\r",victim);
@


1.435
log
@fix gladiator update
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.434 2000/05/20 23:47:58 mud Exp $";
d2754 1
a2754 2
    if((!IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
       || !IS_SET(ch->mhs,MHS_GLADIATOR))
d2756 24
a2779 20
    if ((!IS_NPC (ch) && !IS_NPC (victim)) && (ch != victim) &&
       (ch->position != POS_FIGHTING) && (victim->position != POS_FIGHTING)
	){
      sprintf(buf,"$N is attempting to kill %s",victim->name);
      wiznet(buf,ch,NULL,WIZ_TRANSGRESSION,0,0);
	ch->killer_data[PC_ATTACKS] += 1;
	if(!IS_SET(ch->wiznet,PLR_RUFFIAN) && victim->trumps == 0
	   && !IS_SET(victim->wiznet,PLR_RUFFIAN) 
	   && !IS_SET(victim->act,PLR_DWEEB) 
	   && !IS_SET(victim->act,PLR_THIEF) )
	{
	SET_BIT(ch->wiznet,PLR_RUFFIAN);
	ch->pcdata->ruffT = 500;
        sprintf( log_buf, "%s got a RUFFIAN attacking %s at %d",ch->name,
                victim->name,ch->in_room->vnum );
        log_string( log_buf );
	  sprintf(buf,"$N got a RUFFIAN by attacking %s",victim->name);
	  wiznet(buf,ch,NULL,WIZ_TRANSGRESSION,0,0);
	}
    }
@


1.434
log
@clean up some gladiator stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.433 2000/05/20 03:04:15 mud Exp $";
a1481 1
#ifdef CODE_TEST
a1487 1
#endif
a1491 1
#ifdef CODE_TEST
a1497 1
#endif
a1503 1
#ifdef CODE_TEST
a1509 1
#endif
a1513 1
#ifdef CODE_TEST
a1519 1
#endif
a1523 1
#ifdef CODE_TEST
a1529 1
#endif
a1778 1
#ifdef CODE_TEST
a1785 1
#endif
a4467 1
#ifdef CODE_TEST
a4473 1
#endif
a4798 1
#ifdef CODE_TEST
a4804 1
#endif
a4821 1
#ifdef CODE_TEST
a4827 1
#endif
a4928 1
#ifdef CODE_TEST
a4934 1
#endif
a4946 1
#ifdef CODE_TEST
a4952 1
#endif
a5126 1
#ifdef CODE_TEST
a5132 1
#endif
a5346 1
#ifdef CODE_TEST
a5352 1
#endif
a5496 1
#ifdef CODE_TEST
a5502 1
#endif
a5617 1
#ifdef CODE_TEST
a5623 1
#endif
a5830 1
#ifdef CODE_TEST
a5836 1
#endif
a5924 1
#ifdef CODE_TEST
a5930 1
#endif
a6015 1
#ifdef CODE_TEST
a6021 1
#endif
a6079 1
#ifdef CODE_TEST
a6085 1
#endif
a6438 1
#ifdef CODE_TEST
a6444 1
#endif
a6534 1
#ifdef CODE_TEST
a6540 1
#endif
a6589 1
#ifdef CODE_TEST
a6595 1
#endif
a6637 1
#ifdef CODE_TEST
a6642 1
#endif
a6833 1
#ifdef CODE_TEST
a6838 1
#endif
a7274 1
#ifdef CODE_TEST
a7280 1
#endif
@


1.433
log
@remove ruffians for glads and pc_attacks
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.432 2000/05/19 13:43:59 mud Exp $";
d5959 1
a5959 1
    if (IS_SET(ch->mhs,MHS_GLADIATOR) )
d5961 1
a5961 1
       sprintf(buf,"%s couldn't handle the pressure and takes off running around the Arena.",ch->name);
d6479 1
a6479 1
    if (IS_SET(ch->mhs,MHS_GLADIATOR) )
@


1.432
log
@ more adjustments to alchemy, as well as removeing CODE_TES #ifdef's
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.431 2000/05/18 14:14:17 mud Exp $";
d2766 2
a2767 1
    if(!IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
d7474 1
a7474 1
   sprintf(buf, "&c%s &Rlands the killing blow on %s!", ch->name,victim->name);
d7482 1
a7482 1
      sprintf(buf, "&c%s &Ris victorious in the arena!", ch->name);
@


1.431
log
@ more changes to grenade and brew
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.430 2000/05/17 17:13:39 mud Exp $";
d4575 1
a4575 1
    if ( ( victim = get_char_room(ch,arg2) ) == NULL )
d4659 1
a4659 1
    WAIT_STATE( ch, PULSE_VIOLENCE / 2 );
@


1.430
log
@ Fixed bug in chance to hit with grenade

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.429 2000/05/17 15:46:07 mud Exp $";
d4647 1
a4647 1
         cold_effect(victim, grenade->value[0],dam,iMiss);
d4650 1
a4650 1
	 fire_effect(victim, grenade->value[0],dam,iMiss);
d4653 1
a4653 1
	 acid_effect(victim,grenade->value[0],dam,iMiss);
d4656 1
a4656 1
	 shock_effect(victim,grenade->value[0],dam,iMiss);
@


1.429
log
@ Added comments to const.c
 Added in special affects for grenades
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.428 2000/05/17 03:39:43 mud Exp $";
d4616 1
a4616 1
    chance -= ( victim->level * ch->level ) * 5;
@


1.428
log
@ Another try on damage types for grenades

 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.427 2000/05/17 03:14:50 mud Exp $";
d4565 1
a4565 1

d4627 1
d4640 18
a4658 1

@


1.427
log
@ finally got damage type right I think
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.426 2000/05/17 02:36:13 mud Exp $";
d4637 1
a4637 1
	damage(ch,victim,dam,grenade->value[4],attack_table[grenade->value[4]].damage,TRUE,FALSE);
@


1.426
log
@ changes to grenade to get damage messages showing properly
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.425 2000/05/16 22:43:22 mud Exp $";
d4637 1
a4637 1
	damage(ch,victim,dam,grenade->value[3],grenade->value[4],TRUE,FALSE);
@


1.425
log
@ Changed grenade to show damage message
 Removed all lag for IMMortals usage of commands
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.424 2000/05/16 15:01:29 mud Exp $";
d4637 1
a4637 1
	damage(ch,victim,dam,0,grenade->value[4],TRUE,FALSE);
@


1.424
log
@ Addition of alchemist kit.
 act_obj.c : added "brew" command to create potions
 const.c   : added in a couple new damaget types into attack_table
 fight.c   : grenade code for molotov cocktails
 handler.c : modified wait_state for speed potion
 mag2.c    : spells for use with alchemist potions

- Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.423 2000/05/16 00:56:00 mud Exp $";
d4637 1
a4637 1
	damage(ch,victim,dam,0,grenade->value[4],FALSE,FALSE);
@


1.423
log
@add in all the #ifdef CODE_TEST for gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.422 2000/05/14 00:24:33 mud Exp $";
d30 1
a30 1
#define MAX_DAMAGE_MESSAGE 39
d4583 1
a4583 1
	send_to_char("That's like Danny DeVito versus Godzilla.  C'mon...\n\r",ch);
@


1.422
log
@one last buf declared
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.421 2000/05/14 00:20:44 mud Exp $";
d1482 1
d1489 1
d1494 1
d1501 1
d1508 1
d1515 1
d1520 1
d1527 1
d1532 1
d1539 1
d1789 1
d1797 1
d4479 1
d4486 1
d4794 1
d4801 1
d4819 1
d4826 1
d4928 1
d4935 1
d4948 1
d4955 1
d5130 1
d5137 1
d5352 1
d5359 1
d5504 1
d5511 1
d5627 1
d5634 1
d5842 1
d5849 1
d5938 1
d5945 1
d6031 1
d6038 1
d6097 1
d6104 1
d6458 1
d6465 1
d6556 1
d6563 1
d6613 1
d6620 1
d6663 1
d6669 1
d6861 1
d6867 1
d7304 1
d7311 1
@


1.421
log
@had to declare alot of bufs in here for gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.420 2000/05/13 22:37:23 mud Exp $";
d5813 1
a5813 1
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 50)
d6062 1
a6062 1
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 50)
d7400 2
@


1.420
log
@cleaning up the declarations for gladiator talk
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.419 2000/05/13 21:55:12 mud Exp $";
d88 1
d1483 1
a1483 1
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 10)
d1485 2
a1486 2
              sprintf(buf,"%s parries an attack from %s.",victim->name,ch->name);
              gladiator_talk(buf);
d1493 1
a1493 1
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 10)
d1495 2
a1496 2
              sprintf(buf,"%s dodges an attack from %s.",victim->name,ch->name);
              gladiator_talk(buf);
d1505 1
a1505 1
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 10)
d1507 2
a1508 2
              sprintf(buf,"%s blocks an attack from %s with a shield.",victim->name,ch->name);
              gladiator_talk(buf);
d1515 1
a1515 1
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 10)
d1517 2
a1518 2
              sprintf(buf,"What the hell was that?! %s's weapon just went right through %s.",ch->name,victim->name);
              gladiator_talk(buf);
d1525 1
a1525 1
           if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 10)
d1527 2
a1528 2
              sprintf(buf,"%s wasn't strong enough to get through %s's scales.",ch->name,victim->name);
              gladiator_talk(buf);
d4435 1
d4644 1
d4820 1
d4946 1
d5189 1
d5358 1
d5522 1
d5698 1
d5841 1
d5926 1
d6020 1
d6308 1
d6455 1
d6541 1
d6723 1
d7166 1
@


1.419
log
@Gladiator Combat - Intense!
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.418 2000/04/26 20:24:33 mud Exp $";
a53 2
DECLARE_DO_FUN(do_gladiator_winner );
DECLARE_DO_FUN(do_gladiatortalk );
d1485 1
a1485 1
              do_gladiatortalk(buf);
d1495 1
a1495 1
              do_gladiatortalk(buf);
d1507 1
a1507 1
              do_gladiatortalk(buf);
d1517 1
a1517 1
              do_gladiatortalk(buf);
d1527 1
a1527 1
              do_gladiatortalk(buf);
d4469 1
a4469 1
       do_gladiatortalk(buf);
d4781 1
a4781 1
       do_gladiatortalk(buf);
d4804 1
a4804 1
       do_gladiatortalk(buf);
d4910 1
a4910 1
       do_gladiatortalk(buf);
d4928 1
a4928 1
       do_gladiatortalk(buf);
d5107 1
a5107 1
       do_gladiatortalk(buf);
d5326 1
a5326 1
       do_gladiatortalk(buf);
d5475 1
a5475 1
       do_gladiatortalk(buf);
d5595 1
a5595 1
       do_gladiatortalk(buf);
d5807 1
a5807 1
       do_gladiatortalk(buf);
d5900 1
a5900 1
       do_gladiatortalk(buf);
d5990 1
a5990 1
       do_gladiatortalk(buf);
d6053 1
a6053 1
       do_gladiatortalk(buf);
d6411 1
a6411 1
       do_gladiatortalk(buf);
d6506 1
a6506 1
       do_gladiatortalk(buf);
d6560 1
a6560 1
       do_gladiatortalk(buf);
d6607 1
a6607 1
       do_gladiatortalk(buf);
d6802 1
a6802 1
       do_gladiatortalk(buf);
d7243 1
a7243 1
       do_gladiatortalk(buf);
d7387 1
a7387 1
   do_gladiatortalk(buf); 
d7395 1
a7395 1
      do_gladiatortalk(buf); 
d7397 1
a7397 1
      do_gladiator_winner(ch);
@


1.418
log
@CSV:S Enter Log.  Lines beginning with `CVS:' are removed automatically
q
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.417 2000/04/25 01:02:34 mud Exp $";
d54 2
d1482 7
d1490 1
d1492 7
d1500 1
d1504 7
d1512 1
d1514 7
d1522 1
d1524 7
d1532 1
d1778 9
d4467 7
d4779 6
d4802 6
d4908 6
d4926 6
d5105 6
d5324 6
d5473 6
d5593 6
d5805 6
d5898 6
d5988 6
d6051 6
d6409 7
d6504 6
d6558 6
d6606 5
d6800 6
d7241 6
d7381 21
@


1.417
log
@doh typo
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.416 2000/04/25 01:00:04 mud Exp $";
a4024 1
    */
d4142 1
@


1.416
log
@Double EXP Day Code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.415 2000/04/18 20:33:50 mud Exp $";
d4136 1
a4136 1
            ch->gold += 100;
@


1.415
log
@fixed act ( entries
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.414 2000/04/18 19:50:57 mud Exp $";
d4025 1
d4054 1
d4097 1
a4097 1
	    act("Ruiner never should have cut his hair off.",
d4102 1
a4102 1
	    act("Its Rage's Birthday! He's an old fart.",
d4112 26
a4142 1
    */
@


1.414
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.413 2000/04/17 22:00:48 mud Exp $";
d3444 1
a3444 1
    act ("The corpse crumbles into dust.",ch,NULL,NULL,TO_ROOM);
d3660 1
a3660 1
      act ("$n disintegrates into dust.",victim,NULL,NULL,TO_ROOM);
d3711 1
a3711 1
    act ("$n twitches a bit then stands up.",victim,NULL,NULL,TO_ROOM);
d6691 3
a6693 3
   act ("You rip apart $N's purse and steal their gold!", ch, NULL, victim,TO_CHAR);
   act ("$n rips open your purse and scoops up the coins!",ch,NULL,victim,TO_VICT);
   act ("$n rips open $N's purse, and scoops up the coins!",ch,NULL,victim,TO_ROOM);
@


1.413
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.412 2000/04/17 21:22:39 mud Exp $";
d164 2
a165 2
	    act("$n screams with primal fury!!",ch,NULL,NULL,TO_ROOM); 
	    act("You scream with primal fury!!", ch,NULL,NULL,TO_CHAR);
d861 2
a862 2
	 act("You fumble and drop your weapon!",ch,NULL,NULL,TO_CHAR);
	 act("$N fumbles and drops $s weapon!",ch,NULL,ch,TO_ROOM);
d1041 1
a1041 1
        victim,wield,NULL,TO_ROOM);
d1060 1
a1060 1
          act("The poison on $p has worn off.",ch,wield,NULL,TO_CHAR);
d1073 2
a1074 2
      act("$p bleeds the soul of $n.",victim,wield,NULL,TO_ROOM);
      act("$p bleeds your soul.",victim,wield,NULL,TO_CHAR);
d1083 1
a1083 1
      act("$p draws life from $n.",victim,wield,NULL,TO_ROOM);
d1085 1
a1085 1
    victim,wield,NULL,TO_CHAR);
d1107 2
a1108 2
      act("$n is burned by $p.",victim,wield,NULL,TO_ROOM);
      act("$p sears your flesh.",victim,wield,NULL,TO_CHAR);
d1119 1
a1119 1
      act("$p freezes $n.",victim,wield,NULL,TO_ROOM);
d1121 1
a1121 1
    victim,wield,NULL,TO_CHAR);
d1132 2
a1133 2
      act("$n is struck by lightning from $p.",victim,wield,NULL,TO_ROOM);
      act("You are shocked by $p.",victim,wield,NULL,TO_CHAR);
d1143 2
a1144 2
	 act("$n is consumed in holy wrath by $p.",ch,wield,NULL,TO_ROOM);
	 act("You are consumed in holy wrath by $p.",ch,wield,NULL,TO_CHAR);
d1156 2
a1157 2
	 act("$n is consumed in holy wrath by $p.",victim,wield,NULL,TO_ROOM);
	 act("You are consumed in holy wrath by $p.",victim,wield,NULL,TO_CHAR);
d1176 1
a1176 1
    act("$p knocks down $n.",victim,wield,NULL,TO_ROOM);
d1178 1
a1178 1
    victim,wield,NULL,TO_CHAR);
d1359 1
a1359 1
       act( "$n fades into existence.", ch, NULL, NULL, TO_ROOM );
d1365 1
a1365 1
	act("$n shimmers into existance.",ch,NULL,NULL,TO_ROOM );
d1376 1
a1376 1
       act( "$n no longer moves silently about.", ch, NULL, NULL, TO_ROOM );
d1391 1
a1391 1
       act( "$n returns to $s regular appearance.", ch, NULL, ch, TO_ROOM );
d1619 1
a1619 1
      victim, NULL, NULL, TO_ROOM );
d1645 1
a1645 1
      victim, NULL, NULL, TO_ROOM );
d1671 1
a1671 1
      victim, NULL, NULL, TO_ROOM );
d1677 1
a1677 1
  act( "$n is {RDEAD{x!!", victim, 0, 0, TO_ROOM );
d1758 2
a1759 2
		  act("$p flashes with a black aura.",ch,weapon,NULL,TO_CHAR);
		  act("$p flashes with a black aura.",ch,weapon,NULL,TO_ROOM);
d1855 2
a1856 2
		act("$p flares with a brilliant light!",ch,obj,NULL,TO_CHAR);
		act("$p flares with a brilliant light!",ch,obj,NULL,TO_ROOM);
d2084 1
a2084 1
  act(buf1,ch,NULL,NULL,TO_ROOM);
d2086 1
a2086 1
  act(buf2,ch,NULL,NULL,TO_CHAR);
d2090 1
a2090 1
      act( buf1, ch, NULL, victim, TO_NOTVICT );
d2092 1
a2092 1
      act( buf2, ch, NULL, victim, TO_CHAR );
d2094 1
a2094 1
      act( buf3, ch, NULL, victim, TO_VICT );
d2199 1
a2199 1
  	          ch,NULL,victim,TO_CHAR);
d2380 1
a2380 1
                ch,NULL,victim,TO_CHAR);
d2679 1
a2679 1
		d->character,NULL,victim,TO_CHAR);
d2910 1
a2910 1
    act( "You parry $n's attack.",  ch, NULL, victim, TO_VICT    );
d2912 1
a2912 1
    act( "$N parries your attack.", ch, NULL, victim, TO_CHAR    );
d2976 2
a2977 2
    act( "You block $n's attack with your shield.",  ch, NULL, victim, 
TO_VICT    );
d2979 2
a2980 2
    act( "$N blocks your attack with a shield.", ch, NULL, victim, 
TO_CHAR    );
d3003 2
a3004 2
		act("$N's shield splits in two!",ch,NULL,victim,TO_CHAR); 
		act("Your shield splits in two!",ch,NULL,victim,TO_VICT);
d3048 1
a3048 1
	ch,NULL,victim,TO_CHAR);
d3051 1
a3051 1
	ch,NULL,victim,TO_VICT);
d3085 1
a3085 1
		ch,NULL,victim,TO_CHAR);
d3087 1
a3087 1
		ch,NULL,victim,TO_VICT);
d3181 1
a3181 1
		ch,NULL,victim,TO_CHAR);
d3183 1
a3183 1
		ch,NULL,victim,TO_VICT);
d3192 1
a3192 1
    act( "You dodge $n's attack.", ch, NULL, victim, TO_VICT    );
d3194 1
a3194 1
    act( "$N dodges your attack.", ch, NULL, victim, TO_CHAR    );
d3219 2
a3220 2
    act( "You evade $n's attack and strike back.", ch, NULL, victim, TO_VICT    );
    act( "$N evades your attack and strikes back.", ch, NULL, victim, TO_CHAR    );
d3415 1
a3415 1
      ch,obj,NULL,TO_ROOM);
d3425 1
a3425 1
      ch,obj,NULL,TO_ROOM);
d3430 1
a3430 1
    act("$p falls to the floor.",ch,obj,NULL,TO_ROOM);
d3566 1
a3566 1
    act( msg, ch, NULL, NULL, TO_ROOM );
d3612 1
a3612 1
      act( msg, ch, NULL, NULL, TO_ROOM );
d3681 1
a3681 1
         act("$n is blasted by the {GQuickening{x.",ch,NULL,NULL,TO_ROOM);
d3807 2
a3808 2
    act( "You are zapped by $p.", ch, obj, NULL, TO_CHAR );
    act( "$n is zapped by $p.",   ch, obj, NULL, TO_ROOM );
d4034 1
a4034 1
		gch,NULL,NULL,TO_CHAR);
d4040 1
a4040 1
		gch,NULL,NULL,TO_CHAR);
d4046 1
a4046 1
		gch,NULL,NULL,TO_CHAR);
d4051 1
a4051 1
		gch,NULL,NULL,TO_CHAR);
d4056 1
a4056 1
		gch,NULL,NULL,TO_CHAR);
d4061 1
a4061 1
		gch,NULL,NULL,TO_CHAR);
d4066 1
a4066 1
		gch,NULL,NULL,TO_CHAR);
d4071 1
a4071 1
		gch,NULL,NULL,TO_CHAR);
d4076 1
a4076 1
		gch,NULL,NULL,TO_CHAR);
d4081 1
a4081 1
		gch,NULL,NULL,TO_CHAR);
d4086 1
a4086 1
		gch,NULL,NULL,TO_CHAR);
d4091 1
a4091 1
		gch,NULL,NULL,TO_CHAR);
d4096 1
a4096 1
		gch,NULL,NULL,TO_CHAR);
d4101 1
a4101 1
		gch,NULL,NULL,TO_CHAR);
d4106 1
a4106 1
		gch,NULL,NULL,TO_CHAR);
d4222 2
a4223 2
  act(buf1,ch,NULL,NULL,TO_ROOM);
  act(buf2,ch,NULL,NULL,TO_CHAR);
d4227 3
a4229 3
      act( buf1, ch, NULL, victim, TO_NOTVICT );
      act( buf2, ch, NULL, victim, TO_CHAR );
      act( buf3, ch, NULL, victim, TO_VICT );
d4250 1
a4250 1
  act("$S weapon won't budge!",ch,NULL,victim,TO_CHAR);
d4252 2
a4253 2
      ch,NULL,victim,TO_VICT);
  act("$n tries to disarm $N, but fails.",ch,NULL,victim,TO_NOTVICT);
d4263 1
a4263 1
	ch,NULL,victim,TO_VICT );
d4265 2
a4266 2
	ch,NULL,victim,TO_CHAR);
       act("$n disarms $N and catches the weapon!",ch,NULL,victim,TO_NOTVICT);
d4281 3
a4283 3
   ch, NULL, victim, TO_VICT    );
    act( "You disarm $N!",  ch, NULL, victim, TO_CHAR    );
    act( "$n disarms $N!",  ch, NULL, victim, TO_NOTVICT );
d4352 1
a4352 1
     act("$n quietly utters a yinnish mantra.",ch,NULL,NULL,TO_ROOM);
d4413 1
a4413 1
  act("$n gets a wild look in $s eyes.",ch,NULL,NULL,TO_ROOM);
d4497 1
a4497 1
	act("But $N is your friend!",ch,NULL,victim,TO_CHAR);
d4524 3
a4526 3
	act("$n lobs $p at $N, but misses.",ch,grenade,victim,TO_NOTVICT);
	act("You lob $p at $N but miss.",ch,grenade,victim,TO_CHAR);
	act("$n lobs $p at you, but misses.",ch,grenade,victim,TO_VICT);
d4533 3
a4535 3
	act("You hit $N with $p!",ch,grenade,victim,TO_CHAR);
	act("$n hits you with $p!",ch,grenade,victim,TO_VICT);
	act("$n hits $N with $p!",ch,grenade,victim,TO_NOTVICT);
d4590 1
a4590 1
  act("You'll have to let $M get back up first.",ch,NULL,victim,TO_CHAR);
d4627 1
a4627 1
  act("But $N is your friend!",ch,NULL,victim,TO_CHAR);
d4674 2
a4675 2
        act("You roll out of the way of $n's throw.",ch,NULL,victim,TO_VICT);
        act("$N rolls to safety, you fall flat on your face.",ch,NULL,victim,TO_CHAR);
d4688 1
a4688 1
    ch,NULL,victim,TO_VICT);
d4690 2
a4691 2
	ch,NULL,victim,TO_CHAR);
  act("$n throws $N to the ground.", ch,NULL,victim,TO_NOTVICT);
d4705 1
a4705 1
      ch,NULL,victim,TO_CHAR);
d4707 1
a4707 1
      ch,NULL,victim,TO_NOTVICT);
d4709 1
a4709 1
      ch,NULL,victim,TO_VICT);
d4774 1
a4774 1
      act("$N is your beloved master.",ch,NULL,victim,TO_CHAR);
d4806 2
a4807 2
                ch,NULL,victim,TO_VICT);
        act("You knock $N to the ground with your tail!",ch,NULL,victim,TO_CHAR);
d4809 1
a4809 1
                ch,NULL,victim,TO_NOTVICT);
d4819 3
a4821 3
	  act("You attempt to whip $N with your tail, but {ymiss{x.",ch,NULL,victim,TO_CHAR);
	  act("$n attempts to whip you with $s tail, but {ymisses{x.",ch,NULL,victim,TO_VICT);
	  act("$n attempts to whip $N with $s tail, but {ymisses{x.",ch,NULL,victim,TO_NOTVICT);
d4865 1
a4865 1
  act("You'll have to let $M get back up first.",ch,NULL,victim,TO_CHAR);
d4902 1
a4902 1
  act("But $N is your friend!",ch,NULL,victim,TO_CHAR);
d4960 2
a4961 2
        act("$n tries to bash you, but you dodge it.",ch,NULL,victim,TO_VICT);
        act("$N dodges your bash, you fall flat on your face.",ch,NULL,victim,TO_CHAR);
d4976 2
a4977 2
	act("You roll out of the way of $n's bash.",ch,NULL,victim,TO_VICT);
	act("$N rolls to safety, you fall flat on your face.",ch,NULL,victim,TO_CHAR);
d4991 2
a4992 2
    ch,NULL,victim,TO_VICT);
  act("You slam into $N, and send $M flying!",ch,NULL,victim,TO_CHAR);
d4994 1
a4994 1
    ch,NULL,victim,TO_NOTVICT);
d5004 2
a5005 2
  act("$n falls from $s mount!",victim,NULL,NULL,TO_ROOM);
  act("You fall from your mount!",victim,NULL,NULL,TO_CHAR);
d5018 2
a5019 2
      act("$N rolls to $s feet!",ch,NULL,victim,TO_CHAR);
      act("You roll to your feet.",ch,NULL,victim,TO_ROOM);
d5050 1
a5050 1
      ch,NULL,victim,TO_CHAR);
d5052 1
a5052 1
      ch,NULL,victim,TO_NOTVICT);
d5054 1
a5054 1
      ch,NULL,victim,TO_VICT);
d5101 1
a5101 1
  act("$E's already been blinded.",ch,NULL,victim,TO_CHAR);
d5131 1
a5131 1
  act("But $N is such a good friend!",ch,NULL,victim,TO_CHAR);
d5203 2
a5204 2
  act("$n is blinded by the dirt in $s eyes!",victim,NULL,NULL,TO_ROOM);
  act("$n kickes dirt in your eyes!",ch,NULL,victim,TO_VICT);
d5289 1
a5289 1
  act("$N is already down.",ch,NULL,victim,TO_CHAR);
d5297 1
a5297 1
  act("$n trips over $s own feet!",ch,NULL,NULL,TO_ROOM);
d5303 1
a5303 1
  act("$N is your beloved master.",ch,NULL,victim,TO_CHAR);
d5348 3
a5350 3
  act("$n trips you and you go down!",ch,NULL,victim,TO_VICT);
  act("You trip $N and $N goes down!",ch,NULL,victim,TO_CHAR);
  act("$n trips $N, sending $M to the ground.",ch,NULL,victim,TO_NOTVICT);
d5447 1
a5447 1
  act( "$N is your beloved master.", ch, NULL, victim, TO_CHAR );
d5460 3
a5462 3
	    act("$n focuses %s attack on $N",ch,NULL,victim,TO_NOTVICT);
	    act("You focus your attack on $N",ch,NULL,victim,TO_CHAR);
	    act("$n focuses %s attack on you!",ch,NULL,victim,TO_VICT);
d5531 1
a5531 1
  act( "$N is your beloved master.", ch, NULL, victim, TO_CHAR );
d5640 1
a5640 1
      ch, NULL, victim, TO_CHAR );
d5731 1
a5731 1
  act( "$n has fled!", ch, NULL, NULL, TO_ROOM );
d5740 1
a5740 1
      act( "You flee $T!", ch, NULL, dir_name[door], TO_CHAR);
d5840 3
a5842 3
    act( "You rescue $N!",  ch, NULL, victim, TO_CHAR    );
    act( "$n rescues you!", ch, NULL, victim, TO_VICT    );
    act( "$n rescues $N!",  ch, NULL, victim, TO_NOTVICT );
d5948 2
a5949 2
    ch,NULL,victim,TO_VICT);
  act("You charge madly at $N, and flay $M!",ch,NULL,victim,TO_CHAR);
d5951 1
a5951 1
    ch,NULL,victim,TO_NOTVICT);
d5958 2
a5959 2
  act("You swing wildly and hurt yourself!", ch,NULL,victim,TO_CHAR);
  act("$n flails widly hurting $mself.", ch,NULL,victim,TO_NOTVICT);
d5961 1
a5961 1
  act("You narrowly escape $n's fit of insanity.", ch,NULL,victim,TO_VICT);
d6109 1
a6109 1
	act("$N seems to be unaffected.",ch,NULL,victim,TO_CHAR);
d6319 2
a6320 1
act( "$n makes a sign with $s fingers and wards off the hex.", victim, NULL, victim, TO_ROOM );
d6339 1
a6339 1
          act( "$n has been hexed.", victim, NULL, victim, TO_ROOM );
d6387 1
a6387 1
      act( "$n spreads fear through the room!", ch, NULL, NULL, TO_ROOM );
d6427 1
a6427 1
               act( "$n runs in fear!", victim, NULL, NULL, TO_ROOM );
d6497 1
a6497 1
	     act("$N seems to be unaffected.",ch,NULL,victim,TO_CHAR);
d6623 3
a6625 3
  act("You fail to disarm $N.",ch,NULL,victim,TO_CHAR);
  act("$n tries to disarm you, but fails.",ch,NULL,victim,TO_VICT);
  act("$n tries to disarm $N, but fails.",ch,NULL,victim,TO_NOTVICT);
d6672 3
a6674 3
    act( "You slay $M in cold blood!",  ch, NULL, victim, TO_CHAR    );
    act( "$n slays you in cold blood!", ch, NULL, victim, TO_VICT    );
    act( "$n slays $N in cold blood!",  ch, NULL, victim, TO_NOTVICT );
d6832 1
a6832 1
  act( "$n passes out from sufocation.", victim, NULL, NULL, TO_ROOM );
d6977 1
a6977 1
           act("$n ends his dancing blades!",ch,NULL,NULL,TO_ROOM);
d7053 1
a7053 1
	act("$n begins to make his blades dance!",ch,NULL,NULL,TO_ROOM);
d7181 1
a7181 1
   act( "You fade to the nether plane and avoid $n's blow.",  ch, NULL, victim, TO_VICT    );
d7183 1
a7183 1
   act( "$N fades to the nether plane and avoids your attack.", ch, NULL, victim, TO_CHAR    );
@


1.412
log
@Typo fix in kurijitsu change
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.411 2000/04/17 21:04:01 mud Exp $";
d258 1
a258 1
      if (can_see(rch,vch)
d802 1
a802 1
    if ( !can_see( ch, victim ) )
d2858 1
a2858 1
    if (!can_see(ch,victim))
d3154 1
a3154 1
    if (!can_see(victim,ch))
d3213 1
a3213 1
    if (!can_see(victim,ch))
d4518 1
a4518 1
    chance += ( !can_see(victim,ch) ) ? 15 : 0;
@


1.411
log
@Changed kurijitsu check
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.410 2000/04/04 16:37:53 mud Exp $";
d965 1
a965 1
   if ( ( number_percent() < (get_skill(ch,gsn_kurijitsu)/10) )
@


1.410
log
@ added in damage mods based on class and oldclass together

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.409 2000/04/02 05:26:35 mud Exp $";
d965 1
a965 1
   if ( (diceroll = number_percent() ) < get_skill(ch,gsn_kurijitsu) )
d968 1
@


1.409
log
@Undo April Fools
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.408 2000/04/01 15:26:48 mud Exp $";
d1011 3
a1013 1
    /* CLass adjustment - warriors and their subclasses do more damage */
d1015 2
a1016 1
      dam = dam * ( class_table[ch->class].dam_mod  ) /9 ;
@


1.408
log
@Exp double for April Fools
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.407 2000/04/01 15:20:59 mud Exp $";
a1971 8
	/* April Fool's Day */
         if ( dam ==   0 ) { vp1 = "naggy";    vp2 = "{ylambasts{x";
                             vp3 = " with much haranguing."            ;}
    else if ( dam <=  50 ) { vp1 = "sensual";    vp2 = "{ccaresses{x";
                             vp3 = ", making them horny."           ;}
    else if ( dam >  50 ) { vp1 = "rough";    vp2 = "{cspanks{x";
                             vp3 = "causing cries of \"Don't stop!\""  ;}
	 /*
a2013 1
		*/
a4020 1
     and April Fool's Day */
a4106 2
	    act("Oh, {RSHIT{x!  Look behind you.\n\rHa ha!  Made ya look!",
		gch,NULL,NULL,TO_CHAR);
d4111 1
a4111 1
    /**/
a4128 2
    /* April Fools */
    else if ( dam >=   1 ) { vs = "lick";  vp = "licks"; }
@


1.407
log
@April Fools
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.406 2000/03/27 05:27:41 mud Exp $";
d4030 1
d4117 2
d4123 1
a4123 1
    */
@


1.406
log
@ added checs for pc's only to be able to use remort skills...put checks in fear, hex, breather, bite, bleed, and morph.  Don't think I missed any.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.405 2000/03/26 19:58:27 mud Exp $";
d1972 8
d2022 1
d4138 2
@


1.405
log
@Remove Double xp day
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.404 2000/03/25 20:40:26 mud Exp $";
d6062 3
d6140 4
d6277 4
a6280 1
    if ( ( victim = ch->fighting ) == NULL )
d6453 3
@


1.404
log
@change ch to gch in xp_compute
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.403 2000/03/25 20:31:40 mud Exp $";
a4020 2
    xp *= 2; 
    */
d4111 1
@


1.403
log
@interesting doublke exp day
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.402 2000/03/20 23:22:27 mud Exp $";
d4028 1
a4028 1
	   do_spreward(ch,"all 1");
d4032 3
a4034 3
		ch,NULL,NULL,TO_CHAR);
            ch->pcdata->skill_point_timer = 0;
	    ch->pcdata->skill_point_tracker = 0;
d4038 3
a4040 3
		ch,NULL,NULL,TO_CHAR);
            ch->skill_points += 5;
	    ch->pcdata->skill_point_tracker += 5;
d4044 1
a4044 1
		ch,NULL,NULL,TO_CHAR);
d4049 2
a4050 2
		ch,NULL,NULL,TO_CHAR);
            ch->skill_points += 1;
d4054 2
a4055 2
		ch,NULL,NULL,TO_CHAR);
            obj_to_char(create_object(get_obj_index(OBJ_VNUM_MAP),0,FALSE),ch);
d4059 2
a4060 2
		ch,NULL,NULL,TO_CHAR);
	    do_restore(ch,"all");
d4064 1
a4064 1
		ch,NULL,NULL,TO_CHAR);
d4069 1
a4069 1
		ch,NULL,NULL,TO_CHAR);
d4074 1
a4074 1
		ch,NULL,NULL,TO_CHAR);
d4079 1
a4079 1
		ch,NULL,NULL,TO_CHAR);
d4084 1
a4084 1
		ch,NULL,NULL,TO_CHAR);
d4089 1
a4089 1
		ch,NULL,NULL,TO_CHAR);
d4094 1
a4094 1
		ch,NULL,NULL,TO_CHAR);
d4099 1
a4099 1
		ch,NULL,NULL,TO_CHAR);
d4104 2
a4105 2
		ch,NULL,NULL,TO_CHAR);
            do_reward(ch,"all 200");
@


1.402
log
@syntax error in fear and d to ld in mstat
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.401 2000/03/20 22:17:14 mud Exp $";
d4023 91
d6345 3
@


1.401
log
@l wield in handler.c and not have fear work on slept players in fight.c
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.400 2000/03/20 15:05:44 mud Exp $";
d6299 1
a6299 1
            if ( IS_AFFECTED(victim, AFF_SLEEP)
@


1.400
log
@ changed chances of getting a crusader attack back to 50/50 with 300 sac points as it used to be.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.399 2000/03/15 19:40:11 mud Exp $";
d6297 3
@


1.399
log
@ made final changes to nether shield, all set to go

 -Ragte.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.398 2000/03/15 19:07:59 mud Exp $";
d360 1
a360 1
     number_percent() < ( ch->pcdata->sac / 12 ) )
@


1.398
log
@ Fixed null pointer bug in nether shield when two nethers fight each other

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.397 2000/03/15 18:27:06 mud Exp $";
a1474 2
        if ( check_nether( ch, victim, fSecondary) )
	   return FALSE;
d1487 2
a6986 1
  char buf[20];
@


1.397
log
@ added in another debuger
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.396 2000/03/15 18:18:00 mud Exp $";
a7003 2
	   sprintf( buf, "Sheild: %d:", shield->pIndexData->vnum);
	   send_to_char(buf , victim);
d7021 3
a7023 1

d7028 2
@


1.396
log
@ Changed debuggin log messages

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.395 2000/03/15 17:39:32 mud Exp $";
d7002 1
a7002 1
      if ( shield->pIndexData->vnum != OBJ_VNUM_NETHER_SHIELD );
@


1.395
log
@ Added debug lines in nether check

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.394 2000/03/15 16:24:51 mud Exp $";
d6987 1
a6991 1
	send_to_char("Section 1", victim);
a6996 1
	 send_to_char("Section 2", victim);
d7004 2
a7005 1
	   send_to_char("Section 3", victim);
a7025 1
	 send_to_char("Section 4", victim);
a7062 1
      send_to_char("Section 5", victim);
@


1.394
log
@ Added in new defense skill "nether shield" for nethermancers

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.393 2000/03/14 21:29:51 mud Exp $";
d6990 2
d6993 1
d6996 2
d6999 1
d7004 2
d7007 1
d7025 2
d7028 1
a7028 1

d7063 4
a7066 2
     return FALSE;

@


1.393
log
@make were's and mummies eat specially like vamps
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.392 2000/03/14 00:50:14 mud Exp $";
d72 1
d1475 3
a1477 1
        if ( check_parry( ch, victim,fSecondary ) )
d6979 83
@


1.392
log
@fix PC_KILLS and PC_DEATHS so they dont get incrimented on spam kills
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.391 2000/03/12 00:32:44 mud Exp $";
d5980 7
a6102 1
    ch->move -= apply_chi(ch,(ch->level/15));
d6110 2
d6263 7
d6316 10
@


1.391
log
@new thieving data
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.390 2000/03/07 15:43:31 mud Exp $";
d1756 7
a1762 1
             ch->killer_data[PC_KILLS] += 1 ;
a1777 1
	     victim->killer_data[PC_DEATHS] += 1 ;
@


1.390
log
@ Moved class damage mods from damage() to one_hit so it will only apply to weapon hits.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.389 2000/03/07 14:38:51 mud Exp $";
d1770 2
@


1.389
log
@ added in a dam_mod field to the class_table.  this number is used to adjust damage based on class

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.388 2000/03/06 23:59:30 mud Exp $";
d1010 4
a1264 4

    /* damage increase based on class */
    if (!IS_NPC(ch))
       dam = dam * (class_table[ch->class].dam_mod) /10;
@


1.388
log
@only give daetok and myrmidon +chance to 2nd and 3rd if % > 1
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.387 2000/03/06 21:58:04 mud Exp $";
d1261 5
@


1.387
log
@disarm and dirt kick now hit orbb of touch
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.386 2000/03/06 18:11:40 mud Exp $";
d367 2
a368 2
    chance += check_myrmidon( ch, gsn_second_attack );
    if ( is_affected(ch,gsn_dae_tok) )
d370 7
a376 3
	check_improve(ch,gsn_dae_tok,TRUE,5);
	chance += UMAX(0,get_skill(ch,gsn_dae_tok)-90);
    }
d378 2
a379 2
    if (IS_AFFECTED(ch,AFF_SLOW))
  chance /= 2;
d381 9
a389 8
    if ( number_percent( ) < chance )
    {
  if (!IS_SET(ch->display,DISP_BRIEF_COMBAT))
	send_to_char("(2nd) ",ch);
  one_hit( ch, victim, dt );
  check_improve(ch,gsn_second_attack,TRUE,5);
  if ( ch->fighting != victim )
      return;
d396 6
a401 2
    chance += check_myrmidon( ch, gsn_third_attack );
	if (!IS_NPC(ch) && 
d406 5
a410 4
    if ( is_affected(ch,gsn_dae_tok) )
    {
	check_improve(ch,gsn_dae_tok,TRUE,8);
	chance += UMAX(0,get_skill(ch,gsn_dae_tok)-90);
@


1.386
log
@add is_npc check to parry and dodge
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.385 2000/03/06 18:06:55 mud Exp $";
d5069 11
d6437 11
@


1.385
log
@remove unused buf
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.384 2000/03/06 18:04:01 mud Exp $";
d2780 1
a2780 1
    if (fSecondary)
d3074 1
a3074 1
    if (fSecondary)
@


1.384
log
@remove debug lines in combat
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.383 2000/03/06 16:50:21 mud Exp $";
a648 1
    char buf[256];
@


1.383
log
@apply types and change affects to use them for scondary etc
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.382 2000/03/06 15:59:21 mud Exp $";
a770 3
    sprintf(buf,"Thac0 prior %d\n\r",thac0);
    send_to_char(buf,ch);

a775 3
    sprintf(buf,"Thac0 after %d\n\r",thac0);
    send_to_char(buf,ch);

a989 3
    sprintf(buf,"Dam prior %d\n\r",dam);
    send_to_char(buf,ch);

a993 3

    sprintf(buf,"Dam after %d\n\r",dam);
    send_to_char(buf,ch);
@


1.382
log
@adjust affects
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.381 2000/03/06 14:34:55 mud Exp $";
d3674 1
a3674 1
  affect_remove( victim, victim->affected,TRUE );
d3692 1
a3692 1
  affect_remove( victim, victim->affected,TRUE );
@


1.381
log
@debug lines for second hitroll stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.380 2000/03/06 01:06:59 mud Exp $";
d3674 1
a3674 1
  affect_remove( victim, victim->affected );
d3692 1
a3692 1
  affect_remove( victim, victim->affected );
@


1.380
log
@woohoo last two syntax errors
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.379 2000/03/06 01:04:58 mud Exp $";
d649 1
d771 3
d779 3
d996 3
d1003 3
@


1.379
log
@remove even more syntax issues
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.378 2000/03/06 00:57:56 mud Exp $";
d2929 1
a2929 1
    if ( ( weapon != NULL &&
d3008 1
a3008 1
    if ( ( weapon != NULL &&
@


1.378
log
@more syntax errors in dual stuff
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.377 2000/03/06 00:32:09 mud Exp $";
d2925 1
a2925 1
       weapon = get_eq_char(ch,WEAR_SECOND)
d2927 1
a2927 1
       weapon = get_eq_char(ch,WEAR_WIELD)
d3004 1
a3004 1
       weapon = get_eq_char(ch,WEAR_SECOND)
d3006 1
a3006 1
       weapon = get_eq_char(ch,WEAR_WIELD)
d6211 1
a6211 6
/*
   send_to_char("Sorry Fear is Under Construction, needs a re-write\n\r",ch);
   return;
   */

   if(!IS_SET(ch->act,PLR_MUMMY)
@


1.377
log
@removing some of the dual wield syntax erros
-pouah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.376 2000/03/06 00:27:11 mud Exp $";
d2782 1
a2782 1
       wield = get_eq_char(ch,WEAR_SECOND)
d2787 1
a2787 1
       wield = get_eq_char(ch,WEAR_WIELD)
d5912 1
a5912 1
	  chance -= ( check_dodge( ch, victim ) ? 20 : 0 );
d6216 1
a6216 1
   if(!IS_SET(ch->plr,PLR_MUMMY)
@


1.376
log
@non-mummies trying to use fear dont lose moves
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.375 2000/03/06 00:23:38 mud Exp $";
d65 2
a66 2
bool  check_scales args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
bool  check_dodge args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
d70 2
a71 2
bool  check_parry args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
bool    check_shield_block     args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
@


1.375
log
@Dual Wield changes, second_hitroll,second_damroll and increase skill points to 2 for spells
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.374 2000/02/29 20:46:45 mud Exp $";
d6218 1
a6218 1
     send_to_char("You ain't no stinking Mummy!\n\r,ch);
@


1.374
log
@sneak fix, assassin not assasin
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.373 2000/02/29 01:05:16 mud Exp $";
d434 1
d441 12
d462 1
a462 1
    /* specializatino */
d466 1
a466 1
    if ( ( wsn = get_weapon_sn(ch) )  == ch->pcdata->specialize )
d590 1
a590 1
  || (get_weapon_sn(ch) != gsn_hand_to_hand 
d648 1
d679 2
d714 1
a714 1
    sn = get_weapon_sn(ch);
d770 5
a774 1
    thac0 -= GET_HITROLL(ch) * skill/100;
d989 4
a992 1
    dam += GET_DAMROLL(ch) * UMIN(100,skill) /100;
d1188 1
d1200 20
d1231 5
a1235 1
          obj = get_eq_char( ch, WEAR_WIELD );
d1408 4
a1411 1
	obj = get_eq_char( ch, WEAR_WIELD );
d1421 4
a1424 1
	obj = get_eq_char( ch, WEAR_WIELD );
d1432 4
a1435 1
	obj = get_eq_char( ch, WEAR_WIELD );
d1459 1
a1459 1
        if ( check_parry( ch, victim ) )
d1461 1
a1461 1
        if ( check_dodge( ch, victim ) )
d1465 1
a1465 1
        if ( check_shield_block(ch,victim))
d1469 1
a1469 1
	if ( check_scales(ch,victim))
d2771 1
a2771 1
bool check_parry( CHAR_DATA *ch, CHAR_DATA *victim )
d2774 16
a2789 2
    int hit = ch->hitroll;
    OBJ_DATA *obj = get_eq_char(victim,WEAR_WIELD);
d2794 2
a2795 2
  if (!IS_NPC(victim) && obj != NULL && victim->size < SIZE_LARGE
  &&  IS_WEAPON_STAT(obj,WEAPON_TWO_HANDS)
d2799 2
a2800 2
      obj_from_char( obj );
      obj_to_char( obj, victim );
d2821 1
a2821 1
    if ( get_eq_char( victim, WEAR_WIELD ) == NULL )
a2842 1

d2853 1
a2853 1
    /*If you know your attacker's wepaon, you parry better */
d2855 6
a2860 2
    chance += get_weapon_skill(victim,get_weapon_sn(ch))/10;
    chance -= get_weapon_skill(ch,get_weapon_sn(victim))/10;
d2869 7
a2875 1
    chance += get_weapon_skill(victim,get_weapon_sn(victim))/4;
a2879 1

d2891 1
a2891 1
bool check_shield_block( CHAR_DATA *ch, CHAR_DATA *victim )
d2924 6
a2929 1
    if ( ( weapon = get_eq_char(ch,WEAR_WIELD) )   != NULL &&
d2939 4
d2988 1
a2988 1
bool check_scales( CHAR_DATA *ch, CHAR_DATA *victim )
d3003 6
a3008 1
    if ( ( weapon = get_eq_char(ch,WEAR_WIELD) ) != NULL &&
d3069 1
a3069 1
bool check_dodge( CHAR_DATA *ch, CHAR_DATA *victim )
d3072 6
a3077 1
    int hit = ch->hitroll;
d3141 4
d6216 6
d6396 3
a6398 3
    ch_weapon = get_weapon_skill(ch,get_weapon_sn(ch));
    vict_weapon = get_weapon_skill(victim,get_weapon_sn(victim));
    ch_vict_weapon = get_weapon_skill(ch,get_weapon_sn(victim));
d6899 1
a6899 1
    if ( ( wsn = get_weapon_sn(ch) )  != ch->pcdata->specialize )
@


1.373
log
@ crusader changes, 25% max instaead of 50% now
 sneak changes, removes bit unless thief or assassin
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.372 2000/02/28 18:43:32 mud Exp $";
d1303 1
a1303 1
	 && ch->class != class_lookup("assasin") )
@


1.372
log
@fear does not harm groupies, go group!
and remove 2X exp
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.371 2000/02/27 00:45:07 mud Exp $";
d359 1
a359 1
     number_percent() < ( ch->pcdata->sac / 6 ) )
d1298 11
@


1.371
log
@ another bug fix for magic missile, should stop when ch->fighting == null

 bug fix for buffy, was checking remort status on the wrong person

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.370 2000/02/26 23:39:45 mud Exp $";
d3882 2
a3883 1
    /* double EXP day for Christmas  
a3884 1
    xp *= 2; 
d6129 3
@


1.370
log
@ infiltrate back in, can't infiltrate clan halls

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.369 2000/02/26 23:20:33 mud Exp $";
d1320 4
a1323 3
	( IS_SET(ch->act, PLR_VAMP) ||
	IS_SET(ch->act, PLR_WERE) ||
	IS_SET(ch->act, PLR_MUMMY))
@


1.369
log
@i increased damge to a possible 175% for buffy instead of 150%

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.368 2000/02/26 22:55:53 mud Exp $";
d2234 1
a2234 1
   if (is_clan(ch) && ch->in_room->clan
d2238 1
@


1.368
log
@ addedd a buffy kit, similar towyrmslayer but for killing remorts

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.367 2000/02/26 22:15:22 mud Exp $";
d1324 1
a1324 1
	dam = ( 100 + (ch->level/2) ) * dam / 100;
@


1.367
log
@+25% for rouges to hit backstab, not sure why it got removed
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.366 2000/02/25 23:16:20 mud Exp $";
d1319 8
d2900 1
a2900 1
	chance /= 2;
@


1.366
log
@double exp day
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.365 2000/02/24 18:16:16 mud Exp $";
d5404 2
@


1.365
log
@Put the size code back in
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.364 2000/02/24 15:37:02 mud Exp $";
d3873 2
a3874 1
    xp *= 2;*/ 
@


1.364
log
@ Fixed mobs berskerking ug

 -Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.363 2000/02/24 05:36:34 mud Exp $";
d975 2
a976 3
   /* 
    dam += dam * ((ch->size - 2)/20); 
    */
@


1.363
log
@remove size for a minute, mobs are smoking people
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.362 2000/02/24 04:50:16 mud Exp $";
d4178 2
d4190 2
@


1.362
log
@removed the size code form damage, put in one_hit instead
-poquaH
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.361 2000/02/24 02:54:29 mud Exp $";
d975 1
d977 1
@


1.361
log
@ old class modifiers, I added curative as dependant on cleric old class
 beguiling / mage, berserk / warrior

 berserk is a little better for berserkers, 13 13 instead of 10 10

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.360 2000/02/23 21:47:37 mud Exp $";
d974 2
a1196 3
    /* Size Adjustment - Larger races do more damage */
    dam += dam * ((ch->size - 2)/20); 

@


1.360
log
@move size to before the damage curve
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.359 2000/02/23 21:40:12 mud Exp $";
d4177 10
a4186 1
  af.modifier = UMAX(1,ch->level/5);
@


1.359
log
@add size code to start od dam mods
clear last attacked by on level
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.358 2000/02/22 04:04:24 mud Exp $";
d1195 3
a1317 2
    /* Size Adjustment - Larger races do more damage */
    dam += dam * ((ch->size - 2)/20); 
a1408 4

    /* Size Adjustment - Larger races do more damage */
/*    dam += dam * ((ch->size - 2)/20); */

@


1.358
log
@ change to damage curve in fight.c from 55 120 to 40 80
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.357 2000/02/19 18:50:37 mud Exp $";
d1315 2
d1411 1
@


1.357
log
@ fight.c  changed the pen for blademasters to /5 instead of /4
	  so they have the same pen as druids

 handler.c
	changed max trainable to be similar to max attainable
	so reclasses now get +1 to both mixed reclass primaries
	instead of a +2 on a reclass primary

 magic.c
	added two more mods to saves calculations

 mag2.c
	 cahnged earthbind, 2 ticks now, lose haste NOT slow
	  and a lot less dex loss
	  more work to do with this spell, consider it a work in progress




	  MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.356 2000/02/11 20:20:41 mud Exp $";
d1196 4
a1199 4
    if ( dam > 55)
       dam = (dam - 55)/2 + 55;
    if ( dam > 120)
       dam = (dam - 120)/2 + 120; 
@


1.356
log
@change ITEM_DARK to ITEM_IMM_LOAD and add removal of imm loads from pfreshed char
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.355 2000/02/10 18:33:39 mud Exp $";
d2717 1
a2717 1
	chance -= ( chance / 4 );
d2822 1
a2822 1
	chance -= ( chance / 4 );
d2982 1
a2982 1
	chance -= ( chance / 4 );
@


1.355
log
@fix blademaster typo in parry
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.354 2000/02/10 17:45:15 mud Exp $";
d3213 1
d3216 1
@


1.354
log
@move where the victim fightin check is
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.353 2000/02/10 17:43:32 mud Exp $";
d2981 1
a2981 1
    if ( ch->class == class_lookup("blademster") )
@


1.353
log
@Can not garotte a victim who is fighting
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.352 2000/02/10 03:30:13 mud Exp $";
a6405 5
    if (victim->fighting != NULL)
    {
       send_to_char("They are too active to get a hold on.\n\r",ch);
       return;
    }
d6411 6
@


1.352
log
@Do not gain exp if you have debit levels
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.351 2000/02/10 03:09:09 mud Exp $";
d6404 6
@


1.351
log
@2* level modifier for garotte
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.350 2000/02/06 19:08:53 mud Exp $";
d3678 2
a3679 2
    if ( !IS_SET(gch->mhs,MHS_PREFRESHED) && gch->exp > 
	 exp_per_level(gch,gch->pcdata->points) * (gch->level + 1) )
@


1.350
log
@ Removed size based damage coede temporarily.
 fixe bug not letting people who rare reclasses at creation be guilded without immortal help

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.349 2000/02/05 01:34:22 mud Exp $";
d6449 1
a6449 1
    chance += (ch->level - victim->level);
@


1.349
log
@ mag2.c   mod to wall_of _wind vch_.next in room and not
	  vcn->next.

 fight.c  mod to parry.
	  rage is now a max of 10% based on level like bladesong and
	  CON is now taken into account in parry.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.348 2000/02/04 23:34:28 mud Exp $";
d1408 1
a1408 1
    dam += dam * ((ch->size - 2)/20);
@


1.348
log
@Size afecs damage done
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.347 2000/01/26 15:55:59 mud Exp $";
d2747 14
a2760 2
    if ( is_affected(ch, gsn_rage))
      chance -= 15;
@


1.347
log
@ removal of double xp

 -Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.346 2000/01/25 17:08:19 mud Exp $";
d1406 3
@


1.346
log
@ added in double xp for 25th of the month.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.345 2000/01/23 17:05:17 mud Exp $";
d3855 2
a3856 2
    /* double EXP day for Christmas */ 
    xp *= 2; 
@


1.345
log
@fight.c
	tweaked backstab damage to provide a minimum of twice damage

	from dam *= level /8
	to   dam *= 2 + level /12
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.344 2000/01/23 14:59:09 mud Exp $";
d3855 2
a3856 2
    /* double EXP day for Christmas 
    xp *= 2; */
@


1.344
log
@fight.c
	myrp_pen changed from 10-level mod to 8 - level mod
	reduces pen from a max of 25% at level 51 to 15%
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.343 2000/01/22 01:20:28 mud Exp $";
d957 1
a957 1
      dam *= (ch->level / 8); 
d959 1
a959 1
      dam *= (ch->level / 7);
@


1.343
log
@fight.c
	nether flags only benefits nethermancers, added a HAS_KIT(nethermance)
	to the WEAPON_NETHER check

	added a check to check_myrm function to verify that
	char weapon is the one that they are specialized in
	should not give a bonus if not weilding a specialized weapon

magic.c
	added checks on calm to prevent PC's from
	landing calm on each other if they are non-clanned or clanned
	so a clanner can't calm a non-clanner and vice versa
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.342 2000/01/21 21:42:41 mud Exp $";
d6706 1
a6706 1

d6713 1
a6713 1
    sd *= 10 - ( ch->level / 10 );
@


1.342
log
@ Another minor modification to parry chances
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.341 2000/01/21 19:13:08 mud Exp $";
d1024 4
d1033 1
d6721 1
d6725 5
@


1.341
log
@Lower backstab damage and chance for multi-hit in do_backstab
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.340 2000/01/21 18:45:58 mud Exp $";
d2739 4
a2742 1
    /* If you know your attacker's wepaon, you parry better */
@


1.340
log
@chances to the way hitroll affects chances to dodge and parry.

Also small change to the way bladesong is handled in check_parry()

Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.339 2000/01/20 23:33:34 mud Exp $";
d957 1
a957 1
      dam *= 2 + (ch->level / 8); 
d959 1
a959 1
      dam *= 2 + (ch->level / 7);
d964 3
a5361 2
    if(!IS_NPC(ch) && (ch->class == class_lookup("rogue")))
	 percent += 25;
d5364 6
@


1.339
log
@second post attempt

update.c
	advance_level: added real_size variable
			hp gains based on size of actual race and not infalted
			size created by stature

fight.c
	changed code to actually reflect what help file says about myrmidon

	in defensive skills (parry, dodge, shieldblock)
	chance is the chance of a victim to dodge an attack
	so the myrm_pen should be chance += myrm_pen instead of
	the chance-= myrm_pen., I swithced it to +=

	same principal for attacks(2nd, 3rd) check_myrm should imporve
	chance to land but this function always returned a negative.
	return from check_myrm is now positive
	return = blan - skill instead of the previous
	return = skill- blah

special.c
	add include lookup.h for the new function clanwar_winner that uses
	clan_lookup.

	clanwar_winner returns true if the char is from that clan
	name of the winning clan has to be set every month, shitty way but
	i didn't want to set it in a structure for now.

	clanwar_winner was added to spec_exec , spec_guard_l & d

comm.c
	mod to stat customization, every increase in stat is now equal between races
	You want to increase str 3 times, you pay the same if dragon or faerie.

	added function calc_stat_cost
	calculates the cost to increase a stat for that race.

	added this function where needed to calculate cost of an increase

	primary and secondary bonuses are based on OLDCLASS now.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.338 1999/12/26 19:05:22 mud Exp $";
d2685 1
d2742 6
a2747 1
    chance -= ch->hitroll;
d2932 2
a2933 1

d2963 6
a2968 1
  chance -= ch->hitroll;
d2994 1
a2994 1
	chance = UMIN( chance, 10 );
@


1.338
log
@take out double EXP day.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.337 1999/12/25 14:45:58 mud Exp $";
d2707 1
a2707 1
    chance -= myrm_pen(ch, victim);
d2772 1
a2772 1
    chance -= myrm_pen(ch,victim);
d2935 1
a2935 1
    chance -= myrm_pen( ch, victim );
d6701 1
a6701 1
   else if ( gsn_third_attack ) 
d6706 1
a6706 1
   return ( skill -  (100+ ch->level ) * skill / 100 );
@


1.337
log
@Double EXP day and a decent bump to grouped EXP.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.336 1999/12/17 00:03:47 mud Exp $";
d3832 2
a3833 2
    /* double EXP day for Christmas */
    xp *= 2;
@


1.336
log
@comment withing a comment cause syntax error
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.335 1999/12/17 00:02:13 mud Exp $";
d3554 1
a3554 1
	  group_levels += gch->level;
d3831 3
a3833 1
    xp = 96 * xp / 100; /* Gradually step this down until it's about 75 */
@


1.335
log
@Remove Savant and Scion stuff
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.334 1999/12/14 21:48:13 mud Exp $";
d1042 1
a1042 1
	/* OOO Sppooky no damage message */
@


1.334
log
@up the damage Mummies take from no flame weapons to 3/4 instead of 1/2
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.333 1999/12/09 18:30:38 mud Exp $";
d1038 1
d1046 1
d1312 1
d1324 1
d1725 1
a1725 1
	/* Savant stuff */
d1747 1
@


1.333
log
@Got the syntax of str_dup wrong
-PoquaD ..
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.332 1999/12/09 18:22:15 mud Exp $";
d1329 1
a1329 1
	   dam /= 2;
@


1.332
log
@Once you kill him set the last_attacked_by to 'none'
-pouqha
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.331 1999/12/09 18:05:59 mud Exp $";
d1751 1
a1751 1
	     str_dup(ch->pcdata->last_attacked_by,"none");
@


1.331
log
@Clear the last attack by properly
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.330 1999/12/09 17:58:07 mud Exp $";
d1749 1
d1751 2
@


1.330
log
@Fix attacking last attacked by
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.329 1999/12/07 22:31:25 mud Exp $";
d1748 1
a1748 2
	  if (victim->name == ch->pcdata->last_attacked_by)
	  {
a1749 1
	  }
@


1.329
log
@Removed unused variable in throw
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.328 1999/12/07 22:29:19 mud Exp $";
d2133 1
a2133 1
		 ch->pcdata->last_attacked_by != victim->name)
d2143 2
a2144 2
             if (ch->level > victim->level + (victim->trumps > 0 ? 10 : 8)
	          && ch->pcdata->last_attacked_by != victim->name )
d2317 1
a2317 1
	        ch->pcdata->last_attacked_by != victim->name)
d2327 2
a2328 2
            if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8))
                  && ch->pcdata->last_attacked_by != victim->name)
d2487 1
a2487 1
	            ch->pcdata->last_attacked_by != victim->name)
d2497 2
a2498 2
	        if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8))
	             && ch->pcdata->last_attacked_by != victim->name)
@


1.328
log
@Remove debug lines in Throw
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.327 1999/12/07 21:47:48 mud Exp $";
a4255 1
    char buf[MAX_STRING_LENGTH];
@


1.327
log
@typod change for chance
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.326 1999/12/07 21:44:16 mud Exp $";
a4257 2
    int chance1,chance2,chance3,chance4,chance5,chance6,chance7,chance8;
    int numroll;
a4340 1
    chance1 = chance;
a4342 1
    chance2 = chance;
a4344 1
    chance3 = chance;
a4345 1
    chance4 = chance;
a4348 1
    chance5 = chance;
a4350 1
    chance6 = chance;
a4353 1
    chance7 = chance;
a4362 1
    chance8 = chance;
d4381 1
a4381 6
    numroll = number_percent();
    sprintf(buf,"Chance= %d %d %d %d %d %d %d %d fin= %d number_percent= %d\n\r",
	    chance1,chance2,chance3,chance4,chance5,chance6,chance7,chance8,chance,numroll);
    send_to_char(buf,ch);

    if (numroll <= chance )
@


1.326
log
@Getting statistics on Throw
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.325 1999/12/07 20:52:11 mud Exp $";
d4343 1
a4343 1
    change1 = chance;
@


1.325
log
@Do_thor changed weight
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.324 1999/12/07 19:40:10 mud Exp $";
d4258 1
d4343 1
d4346 1
d4349 1
d4351 1
d4355 1
d4358 1
d4362 1
d4372 1
d4392 2
a4393 1
    sprintf(buf,"Chance= %d number_percent= %d",chance,numroll);
@


1.324
log
@debug throw
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.323 1999/12/07 19:36:26 mud Exp $";
d4342 1
a4342 1
    chance -= victim->carry_weight / 20;
@


1.323
log
@debug line in do_throw
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.322 1999/12/06 01:18:03 mud Exp $";
d4256 1
d4384 1
a4384 1
    send_to_char(ch,buf);
@


1.322
log
@Frogot on ; in do_trow
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.321 1999/12/06 01:13:34 mud Exp $";
d4257 1
d4381 5
a4385 1
    if (number_percent() <= chance )
@


1.321
log
@Adjusted numbers on throw
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.320 1999/12/02 21:32:23 mud Exp $";
d4365 1
a4365 1
       chance = 1
@


1.320
log
@Rework Last Attacked by to not store a pointer, but store the name instead
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.319 1999/12/02 18:01:42 mud Exp $";
d4340 1
a4340 1
    chance -= victim->carry_weight / 200;
d4352 1
a4352 1
    chance += (ch->level - victim->level);
d4355 1
d4357 9
a4365 5
    if (!IS_NPC(victim)
       && chance < get_skill(victim,gsn_dodge) )
    { 
  chance -= 3 * (get_skill(victim,gsn_dodge) - chance);
    }
d4380 1
a4380 1
    if (number_percent() < chance )
@


1.319
log
@a ROOM_NOCOMBAT, no mortals can steal, cast or attack in this room
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.318 1999/12/01 22:13:47 mud Exp $";
d1748 4
a1751 2
	  if (victim == ch->pcdata->last_attacked_by)
	     ch->pcdata->last_attacked_by = NULL;
d2133 1
a2133 1
		 ch->pcdata->last_attacked_by != victim)
d2144 1
a2144 1
	          && ch->pcdata->last_attacked_by != victim )
d2159 1
a2159 1
             victim->pcdata->last_attacked_by = ch;
d2317 1
a2317 1
	        ch->pcdata->last_attacked_by != victim)
d2328 1
a2328 1
                  && ch->pcdata->last_attacked_by != victim)
d2343 1
a2343 1
             victim->pcdata->last_attacked_by = ch;
d2487 1
a2487 1
	            ch->pcdata->last_attacked_by != victim)
d2498 1
a2498 1
	             && ch->pcdata->last_attacked_by != victim)
d2512 1
a2512 1
             victim->pcdata->last_attacked_by = ch;
@


1.318
log
@kaz^}]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
wq
q
|
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.317 1999/11/30 21:41:16 mud Exp $";
d1997 6
d2175 6
d2361 5
@


1.317
log
@Opps had trumps = 0 instead of trumps ==0
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.316 1999/11/28 23:53:40 mud Exp $";
a364 3

    if ( ch->fighting != victim )
	return;
@


1.316
log
@Had to add check to last attacked logic for no flag
-Poqiah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.315 1999/11/28 21:57:29 mud Exp $";
d2152 1
a2152 1
	       || (ch->trumps = 0 && ch->level+8 < victim->level)
d2330 1
a2330 1
	       || (ch->trumps = 0 && ch->level+8 < victim->level)
d2494 1
a2494 1
	       || (ch->trumps = 0 && ch->level+8 < victim->level)
@


1.315
log
@Dont reset last attacked by unless the person is normally out of the victims range
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.314 1999/11/28 20:22:13 mud Exp $";
d2152 1
d2330 1
d2494 1
@


1.314
log
@Fix minor last attacked by bug
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.313 1999/11/26 21:03:04 mud Exp $";
d2150 3
a2152 1
	  if (ch->level+12 < victim->level)  
d2154 1
d2327 3
a2329 1
	  if (ch->level+12 < victim->level)  
d2490 3
a2492 1
	  if (ch->level+12 < victim->level)  
@


1.313
log
@Resistances actaully affect the chance of garotte
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.312 1999/11/26 19:32:04 mud Exp $";
d2148 3
a2150 2
      add the caster to the victims last attacked by */
          if (ch->fighting != victim)
d2322 4
a2325 3
      add the caster to the victims last attacked by */
            if (ch->fighting != victim)
               victim->pcdata->last_attacked_by = ch;
d2483 4
a2486 3
      add the caster to the victims last attacked by */
             if (ch->fighting != victim)
                victim->pcdata->last_attacked_by = ch;
@


1.312
log
@syntax error missing aa {
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.311 1999/11/26 19:27:18 mud Exp $";
d6372 7
d6390 1
@


1.311
log
@Added same flag logic to is_safe_steal
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.310 1999/11/26 04:50:57 mud Exp $";
d2315 1
@


1.310
log
@removed double exp
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.309 1999/11/25 19:35:44 mud Exp $";
d2298 5
a2302 4
         if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF)) 
         {
            if (ch->level > victim->level + 12 || ch->level + 12 < victim->level ) 
	    {
d2305 2
a2306 2
               return TRUE;
	    }
d2310 3
a2312 3
            if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8)
		|| ch->level + (victim->trumps > 0 ? 10 : 8) < victim->level)
                && victim->fighting != ch )
d2316 2
a2317 1
	       return TRUE;
d2319 4
@


1.309
log
@pcdatat = pcdata
=Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.308 1999/11/25 19:33:19 mud Exp $";
a3789 1
    xp = xp * 2;
@


1.308
log
@pcdata->last_attacked_by, keep forgetting the pcdata
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.307 1999/11/25 19:31:41 mud Exp $";
d1752 1
a1752 1
	     ch->pcdatat->last_attacked_by = NULL;
@


1.307
log
@Strip the last_attacked-By if the ch kills them
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.306 1999/11/25 03:48:11 mud Exp $";
d1751 2
a1752 2
	  if (victim == ch->last_attacked_by)
	     ch->last_attacked_by = NULL;
@


1.306
log
@Double EXP day!
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.305 1999/11/25 00:56:00 mud Exp $";
d1751 3
@


1.305
log
@New Last Attacked By to allow to attack outside range
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.304 1999/11/25 00:38:30 mud Exp $";
d3787 1
@


1.304
log
@is_safe debug
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.303 1999/11/25 00:06:37 mud Exp $";
a1987 1
send_to_char ("is safe\n\r",ch);
d2144 2
a2146 2
          {
             send_to_char("2\n\r",ch);
a2147 3
          }
    else
       send_to_char("1\n\r",ch);
a2321 1
send_to_char ("is safe spell\n\r",ch);
a2326 1
send_to_char("b1\n\r",ch);
a2328 1
send_to_char("b21\n\r",ch);
a2437 1
send_to_char("b321\n\r",ch);
a2443 1
send_to_char("b4321\n\r",ch);
a2450 1
send_to_char("b54321\n\r",ch);
a2460 1
send_to_char("b64321\n\r",ch);
d2470 4
a2473 7
    if (ch->fighting != victim)
    {
       send_to_char("2\n\r",ch);
       victim->pcdata->last_attacked_by = ch;
    }
    else
       send_to_char("1\n\r",ch);
a2476 2
    /* If someone not fighting the victim casts a spell at the victim then
      add the caster to the victims last attacked by */
@


1.303
log
@debugging
-pouqha
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.302 1999/11/24 23:58:06 mud Exp $";
d2144 8
a2480 7
          }
       }
    }
    /* If someone not fighting the victim casts a spell at the victim then
      add the caster to the victims last attacked by */

    send_to_char("blah\n\r",ch);
d2488 5
a2492 1

@


1.302
log
@load up is_safe_spell with debug
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.301 1999/11/24 23:45:28 mud Exp $";
d1988 1
d2318 1
@


1.301
log
@flaggy flag flag
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.300 1999/11/24 23:27:04 mud Exp $";
d2322 1
a2322 1

d2325 1
d2435 1
d2442 1
d2450 1
d2461 1
@


1.300
log
@flag falg
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.299 1999/11/24 22:45:21 mud Exp $";
d2472 1
a2472 1

@


1.299
log
@flag
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.298 1999/11/24 22:04:36 mud Exp $";
d2472 1
d2478 3
@


1.298
log
@Change last_attack to pcdatat->last_attack where it was
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.297 1999/11/24 22:00:52 mud Exp $";
d2471 1
d2473 2
d2476 1
@


1.297
log
@Added Last_Attacked_by to track new Flag System
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.296 1999/11/24 16:33:52 mud Exp $";
d2125 1
a2125 1
		 ch->last_attacked_by != victim)
d2136 1
a2136 1
	          && ch->last_attacked_by != victim )
d2448 1
a2448 1
	            ch->last_attacked_by != victim)
d2459 1
a2459 1
	             && ch->last_attacked_by != victim)
d2472 1
a2472 1
       victim->last_attacked_by = ch;
@


1.296
log
@Stepped down exp multiplier to 96/100
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.295 1999/11/24 08:46:20 mud Exp $";
d2122 1
a2122 2
          if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF)
	      || IS_SET(ch->act,PLR_KILLER) || IS_SET(ch->act,PLR_THIEF)) 
d2124 2
a2125 1
             if (ch->level > victim->level + 12 || ch->level + 12 < victim->level )
d2135 2
a2136 1
             if (victim->trumps >= 0)
d2138 2
a2139 17
		if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8))
		    && victim->fighting != ch)
		{
                   if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                      send_to_char("Pick on someone your own size.\n\r",ch);
                   return TRUE;
		}
             }

	     /* Ch is a Thug or Ruffian */
	     if (ch->trumps >= 0)
	     {
	        if ((ch->level + (ch->trumps > 0 ? 10 : 8) < victim->level) 
                 && victim->fighting != ch )
                {
                   if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                      send_to_char("Pick on someone your own size.\n\r",ch);
a2140 1
		}
d2445 1
a2445 2
             if (IS_SET(victim->act,PLR_THIEF) || IS_SET(victim->act,PLR_KILLER)
		 || IS_SET(ch->act,PLR_THIEF) || IS_SET(ch->act,PLR_KILLER)) 
d2447 2
a2448 1
	        if (ch->level > victim->level + 12 || ch->level + 12 < victim->level)
d2458 2
a2459 1
                if (victim->trumps >= 0)
d2461 3
a2463 19
	           if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8))
		       && victim->fighting != ch)
		   {
                      if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                         send_to_char("Pick on someone your own size.\n\r",ch);
                      return TRUE;
		   }
                }

	        /* Ch is a Thug or Ruffian */
	        if (ch->trumps >= 0)
	        {
	           if ((ch->level + (ch->trumps > 0 ? 10 : 8) < victim->level) 
                     && victim->fighting != ch )
                   {
                      if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                         send_to_char("Pick on someone your own size.\n\r",ch);
                      return TRUE;
		   }
d2469 5
@


1.295
log
@Oops forgot to commit the bladmaster change no wonder they didn't notice

-G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.294 1999/11/24 04:17:12 mud Exp $";
d3807 1
a3807 1
    xp = 97 * xp / 100; /* Gradually step this down until it's about 75 */
@


1.294
log
@Fix levle restriction bug
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.293 1999/11/23 02:43:24 mud Exp $";
d428 8
a435 1
        if ( number_percent() <  get_skill(ch,gsn_dual_wield) / 2 )
@


1.293
log
@fixed savant bug
-G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.292 1999/11/22 02:10:44 mud Exp $";
d2128 1
a2128 1
             if (victim->trumps > 0)
d2140 1
a2140 1
	     if (ch->trumps > 0)
d2466 1
a2466 1
                if (victim->trumps > 0)
d2478 1
a2478 1
	        if (ch->trumps > 0)
@


1.292
log
@Add new Level for flags to is_safe_spell
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.291 1999/11/22 01:40:50 mud Exp $";
d1311 1
d1313 3
a1315 2
	if ( !IS_NPC(victim) )
		victim->pcdata->savant = UMAX(0,victim->pcdata->savant-1);
@


1.291
log
@Tweak Combat Flags, allow Thugs to attack +10 and Kilelr sto attack +12
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.290 1999/11/20 23:47:25 mud Exp $";
d2114 1
a2114 1
	      || IS_SET(ch->act,PLR_KILLER)) 
d2125 16
a2140 3
             if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8) 
		 || ch->level + (victim->trumps > 0 ? 10 : 8) < victim->level
		 || ch->level + (ch->trumps > 0 ? 10 : 8 ) < victim->level)
d2142 5
a2146 4
             {
                if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                   send_to_char("Pick on someone your own size.\n\r",ch);
                return TRUE;
d2451 2
a2452 1
             if (IS_SET(victim->act,PLR_THIEF) || IS_SET(victim->act,PLR_KILLER)) 
d2463 23
a2485 8
                if ((ch->level > victim->level + (victim->trumps > 0 ? 10 : 8) 
		     || ch->level + (victim->trumps > 0 ? 10 : 8) < victim->level)
	            && victim->fighting != ch )
                {
                   if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                      send_to_char("Pick on someone your own size.\n\r",ch);
                   return TRUE;
	        }
@


1.290
log
@ Ok Fear all cleaned up with saving throws and all
 -Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.289 1999/11/20 22:44:46 mud Exp $";
d2113 2
a2114 1
          if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF)) 
d2126 2
a2127 1
		 || ch->level + (victim->trumps > 0 ? 10 : 8) < victim->level)
@


1.289
log
@No Fear!
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.288 1999/11/20 22:28:31 mud Exp $";
d5979 10
@


1.288
log
@Closing in on cleaning up Fear
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.287 1999/11/20 22:10:21 mud Exp $";
d5982 1
a5990 1
               was_in = victim->in_room;
@


1.287
log
@Fear ME!
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.286 1999/11/20 21:59:36 mud Exp $";
a5978 1
            was_in = victim->in_room;
d5990 1
@


1.286
log
@Fear.. do do do
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.285 1999/11/20 21:44:59 mud Exp $";
d5950 1
a5950 1
   CHAR_DATA *victim,nextvictim;
a5972 1
      nextvictim = ch->in_room->people->next_in_room;
@


1.285
log
@reworking fear
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.284 1999/11/19 19:26:18 mud Exp $";
d5973 1
@


1.284
log
@New savant code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.283 1999/11/19 05:41:17 mud Exp $";
d5950 1
a5950 1
   CHAR_DATA *victim;
d5956 1
d5959 1
d5973 1
a5973 1
      for ( victim= ch->in_room->people; victim != NULL; victim = victim->next_in_room )
d5975 1
@


1.283
log
@Varioety of changes.   faerie fog stuff mostly
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.282 1999/11/19 02:06:05 mud Exp $";
d1034 8
d1305 11
a1315 1
    
d1714 23
@


1.282
log
@Working on Level limits
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.281 1999/11/19 01:11:37 mud Exp $";
d390 3
a405 3
    if (IS_AFFECTED(ch,AFF_SLOW))
  chance = 0;

d911 1
a911 1
	dam += ( dam / 10 ); /* 10% hbonus */
d943 3
a1344 2
        if ( check_scales( ch, victim ) )
           return FALSE;
d1353 2
@


1.281
log
@Add some brackets to make things && and || properly
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.280 1999/11/19 01:09:31 mud Exp $";
d2069 8
a2076 6
          if ((IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF)) 
               && (ch->level > victim->level + 12 || ch->level + 12 < victim->level ))
          {
             if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                send_to_char("Pick on someone your own size.\n\r",ch);
             return TRUE;
d2391 8
a2398 6
             if ((IS_SET(victim->act,PLR_THIEF) || IS_SET(victim->act,PLR_KILLER)) 
	         && (ch->level > victim->level + 12 || ch->level + 12 < victim->level))
             {
                if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
                   send_to_char("Pick on someone your own size.\n\r",ch);
                return TRUE;
@


1.280
log
@Coupel of syntax andmissing brackets in new cap code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.279 1999/11/19 01:05:35 mud Exp $";
d2389 1
a2389 1
             if (IS_SET(victim->act,PLR_THIEF) || IS_SET(victim->act,PLR_KILLER) 
@


1.279
log
@Cap Level on Stealing and Spell Casting/Fighting up and down
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.278 1999/11/16 21:25:56 mud Exp $";
d2236 1
a2236 1
            if (ch->level > victim->level + 12 || ch->level + 12 < victim->level)) 
d2390 1
a2390 2
	         && ((ch->level > victim->level + 12) 
		 || (ch->level+12 < victim->level))) 
@


1.278
log
@Add Killer +12 level check to is_safe_spell
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.277 1999/11/12 19:02:00 mud Exp $";
d1936 1
a1936 1
  return TRUE;
d1939 1
a1939 1
  return FALSE;
d1942 1
a1942 1
  return FALSE;
d1944 2
a1945 2
   if ( victim->passenger != NULL && is_safe(ch,victim->passenger) )
  return TRUE;
d1947 6
a1952 6
   if (IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_SET(ch->mhs,MHS_HIGHLANDER)
       && !IS_NPC(victim))
   {
      send_to_char("They are a Highlander, You are not.\n\r",ch);
      return TRUE; 
   }
d1954 6
a1959 6
   if (IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER)
       && !IS_NPC(ch))
   {
      send_to_char("You are a Highlander, They are not.\n\r",ch);
      return TRUE;
   }
d1962 2
a1963 2
   if ( IS_NPC(victim) && victim->invis_level )
   return TRUE;
d1965 3
a1967 3
   if ( is_clan(victim) && victim->in_room->clan &&
	victim->in_room->clan != victim->clan )
   return FALSE;
d1972 1
a1972 1
    return TRUE;
d1974 7
a1980 7
   /* attacking a player's creature by another player */
   if ( IS_NPC(victim)
	&& victim->master != NULL 
        && victim->master->fighting != ch
        && (ch->level > (victim->master->level +8))
        && is_clan(ch) && is_clan(victim->master))
     return TRUE;
d1985 12
d1998 9
a2006 12
  	/* safe room? */
	if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
  	{
      	send_to_char("Not in this room.\n\r",ch);
      	return TRUE;
  	}

  	if (victim->pIndexData->pShop != NULL)
 	 {
  	 send_to_char("The shopkeeper wouldn't like that.\n\r",ch);
         return TRUE;
  	 }
d2008 10
a2017 29
  	 /* no killing healers, trainers, etc */
  	 if (IS_SET(victim->act,ACT_TRAIN)
  	 ||  IS_SET(victim->act,ACT_PRACTICE)
  	 ||  IS_SET(victim->act,ACT_IS_HEALER)
  	 ||  IS_SET(victim->act,ACT_IS_CHANGER))
  	 {
  	     send_to_char("I don't think Mojo would approve.\n\r",ch);
  	     return TRUE;
  	 }

  	 if (!IS_NPC(ch) && victim->master != NULL)
  	 {
  	     /* no pets */
  	     if (IS_SET(victim->act,ACT_PET) 
                 && (!is_clan(victim->master) || !is_clan(ch)) )
  	     {
 	       act("But $N looks so cute and cuddly...",
  	       ch,NULL,victim,TO_CHAR);
  		return TRUE;
      	     }

      	    /* no charmed creatures unless owner */
     	     if (IS_AFFECTED(victim,AFF_CHARM) 
      	        && ch != victim->master
     	        && (!is_clan(victim->master) || !is_clan(ch)) )
      	      {
    	        send_to_char("You don't own that monster.\n\r",ch);
                return TRUE;
              }
d2019 7
d2027 1
d2032 9
a2040 9
  /* NPC doing the killing */
  if (IS_NPC(ch))
  {
      /* safe room check */
      if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
      {
    send_to_char("Not in this room.\n\r",ch);
    return TRUE;
      }
d2042 14
a2055 12
      /* charmed mobs and pets cannot attack players while owned */
      if (IS_AFFECTED(ch,AFF_CHARM) && ch->master != NULL
      &&  ch->master->fighting != victim)
      {
    send_to_char("Players are your friends!\n\r",ch);
    stop_fighting(ch,FALSE);
    return TRUE;
      }
  }
  /* player doing the killing */
  else
  { 
d2057 5
a2061 2
      if (IS_SET(victim->act,PLR_DWEEB))
    return FALSE;
d2063 5
a2067 5
      if (!is_clan(ch))
      {
    send_to_char("Join a clan if you want to kill players.\n\r",ch);
    return TRUE;
      }
d2069 19
a2087 21
      if (!is_clan(victim)) 
      {
    send_to_char("They aren't in a clan, leave them alone.\n\r",ch);
    return TRUE;
      }

      if (IS_SET(victim->act,PLR_THIEF))
    return FALSE;

      if (IS_SET(victim->act,PLR_KILLER) 
	  && ch->level > (victim->level + 12))
    return TRUE;

      if (ch->level > victim->level + (victim->trumps > 0 ? 10 : 8) 
	  && victim->fighting != ch )
      {
      if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
    send_to_char("Pick on someone your own size.\n\r",ch);
    return TRUE;
      }
  }
d2095 1
a2095 1
     return TRUE;
d2098 1
a2098 1
    return FALSE;
d2101 1
a2101 1
	  return FALSE;
d2103 2
a2104 2
    if (victim->passenger != NULL && is_safe_steal(ch,victim->passenger) )
	return TRUE;
d2122 1
a2122 1
    return TRUE;
d2125 1
a2125 1
    victim->in_room->clan != victim->clan )
d2128 5
a2132 5
    /* Infiltrators can steal from you while you are in your own hall */
  if (is_clan(ch) && ch->in_room->clan
  && ch->in_room->clan != ch->clan
  && number_percent() <= get_skill(ch,gsn_infiltrate))
	  return FALSE;
d2134 6
a2139 6
     /* attacking a player's creature by another player */
	 if ( IS_NPC(victim)
	 && victim->master != NULL
	 && victim->master->fighting != ch
	 && (ch->level > (victim->master->level +8))
	 && is_clan(ch) && is_clan(victim->master))
d2142 3
a2144 3
	  /* killing mobiles */
     if (IS_NPC(victim))
	  {
d2146 6
a2151 6
	  /* safe room? */
	  if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
          {
	  send_to_char("Not in this room.\n\r",ch);
	  return TRUE;
	  }
d2153 5
a2157 5
	  if (victim->pIndexData->pShop != NULL)
          {
          send_to_char("The shopkeeper wouldn't like that.\n\r",ch);
          return TRUE;
          }
d2159 9
a2167 9
       /* no killing healers, trainers, etc */
	if (IS_SET(victim->act,ACT_TRAIN)
        ||  IS_SET(victim->act,ACT_PRACTICE)
        ||  IS_SET(victim->act,ACT_IS_HEALER)
        ||  IS_SET(victim->act,ACT_IS_CHANGER))
    {
	 send_to_char("I don't think Mojo would approve.\n\r",ch);
      return TRUE;
    }
d2169 19
a2187 10
	if (!IS_NPC(ch) && victim->master != NULL)
        {
      /* no pets */
      if (IS_SET(victim->act,ACT_PET)
      && (!is_clan(victim->master) || !is_clan(ch)) )
     {
	act("But $N looks so cute and cuddly...",
       ch,NULL,victim,TO_CHAR);
       return TRUE;
     }
d2189 1
a2189 31
	/* no charmed creatures unless owner */
     if (IS_AFFECTED(victim,AFF_CHARM)
     && ch != victim->master
     && (!is_clan(victim->master) || !is_clan(ch)) )
     {
     send_to_char("You don't own that monster.\n\r",ch);
     return TRUE;
     }

 }
       }
   /* killing players */
       else
   {
     /* NPC doing the killing */
       if (IS_NPC(ch))
 {
      /* safe room check */
     if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
   {
     send_to_char("Not in this room.\n\r",ch);
   return TRUE;
}

  /* charmed mobs and pets cannot attack players while owned */
   if (IS_AFFECTED(ch,AFF_CHARM) && ch->master != NULL
   &&  ch->master->fighting != victim)
 {
     send_to_char("Players are your friends!\n\r",ch);
     stop_fighting(ch,FALSE);
     return TRUE;
d2191 2
a2192 3
     }
      /* player doing the killing */
else
d2194 22
d2217 2
a2218 2
 if (IS_SET(victim->act,PLR_DWEEB))
     return FALSE;
d2220 35
a2254 13
   if (!is_clan(ch))
 {
   send_to_char("Join a clan if you want to kill players.\n\r",ch);
   return TRUE;
 }

   if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF))
       return FALSE;

   if (!is_clan(victim))
   {
   send_to_char("They aren't in a clan, leave them alone.\n\r",ch);
   return TRUE;
d2256 1
a2256 11

   if (ch->level > victim->level + (victim->trumps > 0 ? 10 : 8)
   && victim->fighting != ch )
   {
      if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
   send_to_char("Pick on someone your own size.\n\r",ch);
	return TRUE;
   }
 }
   }
  return FALSE;
d2262 1
a2262 1
        return TRUE;
d2265 1
a2265 1
  return TRUE;
d2268 1
a2268 1
  return FALSE;
d2271 1
a2271 1
  return FALSE;
d2274 1
a2274 1
	return TRUE;
d2291 1
a2291 1
   return TRUE;
d2293 1
a2293 1
  if ( is_clan(victim) && victim->in_room->clan &&
d2295 8
a2302 8
	  {
	  if( !IS_SET(victim->act,PLR_THIEF) )
	    {
	    send_to_char("You got caught infiltrating.\n\r",victim);
	    SET_BIT(victim->act,PLR_THIEF);
	    }
	  return FALSE;
	  }
d2304 7
a2310 7
/*You can not be attacked if you're in your own hall
  unless it's by your fellow clanmates.
 */
	if(is_clan(ch) && is_clan(victim) &&
	   ch->in_room->clan != ch->clan &&
	   victim->in_room->clan == victim->clan)
		return TRUE;
d2315 3
a2317 3
  /* safe room? */
  if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
      return TRUE;
d2319 2
a2320 2
  if (victim->pIndexData->pShop != NULL)
      return TRUE;
d2322 6
a2327 6
  /* no killing healers, trainers, etc */
  if (IS_SET(victim->act,ACT_TRAIN)
  ||  IS_SET(victim->act,ACT_PRACTICE)
  ||  IS_SET(victim->act,ACT_IS_HEALER)
  ||  IS_SET(victim->act,ACT_IS_CHANGER))
      return TRUE;
d2329 20
a2348 20
  if (!IS_NPC(ch))
  {
      /* no pets */
      if (IS_SET(victim->act,ACT_PET))
      return TRUE;

      /* no charmed creatures unless owner */
      if (IS_AFFECTED(victim,AFF_CHARM) && (area || ch != victim->master))
    return TRUE;

      /* legal kill? -- cannot hit mob fighting non-group member */
      if (victim->fighting != NULL && !is_same_group(ch,victim->fighting))
    return TRUE;
  }
  else
  {
      /* area effect spells do not hit other mobs */
      if (area && !is_same_group(victim,ch->fighting))
    return TRUE;
  }
d2353 2
a2354 2
  if (area && IS_IMMORTAL(victim) && victim->level > LEVEL_IMMORTAL)
      return TRUE;
d2356 7
a2362 7
  /* NPC doing the killing */
  if (IS_NPC(ch))
  {
      /* charmed mobs and pets cannot attack players while owned */
      if ( ((IS_AFFECTED(ch,AFF_CHARM)) & (ch->master != NULL))
      &&  (ch->master->fighting != victim) )
    return TRUE;
d2364 13
a2376 3
      /* safe room? */
      if (IS_SET(victim->in_room->room_flags,ROOM_SAFE))
    return TRUE;
d2378 2
a2379 4
      /* legal kill? -- mobs only hit players grouped with opponent*/
      if (ch->fighting != NULL && !is_same_group(ch->fighting,victim))
    return TRUE;
  }
d2381 2
a2382 5
  /* player doing the killing */
  else
  {
      if (IS_SET(victim->act,PLR_DWEEB))
    return FALSE;
d2384 2
a2385 2
      if (!is_clan(ch) && !IS_SET(ch->mhs,MHS_HIGHLANDER))
    return TRUE;
d2387 22
a2408 13
      if (!is_clan(victim) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
    return TRUE;

	if( area && is_same_group(ch,victim) )
    return TRUE;

      if (!IS_SET(victim->mhs,MHS_HIGHLANDER))
      {
      if (IS_SET(victim->act,PLR_THIEF))
    return FALSE;
      if (IS_SET(victim->act,PLR_KILLER) 
	  && ch->level > (victim->level + 12))
    return TRUE;
a2409 5

      if (ch->level > victim->level + (victim->trumps > 0 ? 10 : 8) )
    return TRUE;
  }

d2413 1
@


1.277
log
@Remove Fear needs a re-write
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.276 1999/11/12 17:59:08 mud Exp $";
d2377 1
a2377 1
      if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF))
d2379 4
a2382 1
      }
@


1.276
log
@Fixed a few bugs in d-Fear

_G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.275 1999/11/11 18:26:05 mud Exp $";
d5882 3
@


1.275
log
@Fixed up some stuff in blind.
-G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.274 1999/11/09 00:22:21 mud Exp $";
d5892 1
a5892 1
   if ( get_skill(ch,gsn_fear) > number_percent())
d5895 1
a5895 1
      for ( victim= ch->in_room->people; victim != NULL; victim = ch->next_in_room )
d5897 2
a5898 2
         if(victim != ch 
            && (is_clan(victim) || (!is_clan(victim) && IS_NPC(victim))))
@


1.274
log
@doh doh typo in do_garotte
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.273 1999/11/09 00:19:36 mud Exp $";
d3693 1
a3693 1
    xp = 98 * xp / 100; /* Gradually step this down until it's about 75 */
@


1.273
log
@Add some extra 'chance' modifiers to garotte, it works way too often
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.272 1999/11/09 00:19:00 mud Exp $";
d6242 1
a6242 1
    chance -= get_curr_stat(victim,STAT_DEX;
@


1.272
log
@Add blah I see typo alread..
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.271 1999/11/08 21:39:35 mud Exp $";
d6185 1
@


1.271
log
@PLR_KILLER safe unless ch->level not > then victim->level + 12
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.270 1999/11/08 20:02:02 mud Exp $";
d6235 17
d6258 1
a6258 1
      if ( get_skill(ch,gsn_garotte) > number_percent() &&
@


1.270
log
@Thief flag only if victim is higher then 8 levels above you
Killer flag only allows +12 levels to kill you
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.269 1999/11/06 19:07:04 mud Exp $";
d2077 1
a2077 1
    return FALSE;
@


1.269
log
@Fix hex without an argument landing on first mob in room
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.268 1999/11/05 18:23:58 mud Exp $";
d2072 5
a2076 1
      if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF))
@


1.268
log
@Change hex to affect_to_char instead of affect_join
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.267 1999/11/05 08:39:51 mud Exp $";
d5811 1
a5811 1
    if ( ( victim = get_char_room(ch,arg) ) == NULL )
d5813 2
d5817 1
@


1.267
log
@ANOTHER fix.  Maybe I actually got it this time
ben
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.266 1999/11/05 08:30:55 mud Exp $";
d5848 1
a5848 1
          affect_join( victim, &af );
d5852 1
a5852 1
          affect_join( victim, &af );
@


1.266
log
@ Attack wasn't working.  Now it is.  I hope.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.265 1999/11/05 08:19:13 mud Exp $";
d4995 1
a4995 1
    if ( ch->position == POS_FIGHTING && !canChange )
d4997 1
d5000 8
@


1.265
log
@ Added brawler.
  Added some color to act_info.c and act_comm.c
  Added attack command to interp.c

  Ben
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.264 1999/11/05 03:50:59 mud Exp $";
d4995 1
a4995 1
    if ( ch->position == POS_FIGHTING )
@


1.264
log
@Add garotte strip in start_fight
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.263 1999/11/04 22:16:55 mud Exp $";
d59 1
d366 3
d455 3
d466 2
d476 2
a4382 1

d4913 6
d4920 3
d4926 6
d4936 6
@


1.263
log
@Crash bug, maybe an obj is null in Mummy check
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.262 1999/11/04 21:43:30 mud Exp $";
d2933 3
@


1.262
log
@Adjust the Riding Check improe code i put in yesterday might be a crash?
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.261 1999/11/04 01:27:21 mud Exp $";
d1290 1
a1290 1
        else if (!IS_WEAPON_STAT(obj,WEAPON_FLAMING))
@


1.261
log
@Failing the riding extra attack can hopefully still improve your riding skill
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.260 1999/11/03 22:10:13 mud Exp $";
d317 1
a317 2
    if (is_mounted(ch) && !is_mounted(victim) &&
	number_percent() < UMIN(10, get_skill(ch,gsn_riding) / 5 ) )
d319 9
a327 4
    check_improve(ch,gsn_riding,TRUE,10);
    if(!IS_SET(ch->display,DISP_BRIEF_COMBAT))
        send_to_char("(Mnt) ",ch);
    one_hit(ch,victim,dt);
a328 2
    else
       check_improve(ch,gsn_riding,FALSE,10);
d1284 1
a1284 1
    if ( IS_SET(victim->act,PLR_MUMMY) && !iOld )
@


1.260
log
@Have fear actually work on all people in room, not cascading with the first
victim to other rooms
-Poqiah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.259 1999/11/03 22:06:31 mud Exp $";
d325 2
@


1.259
log
@Add fear message to room
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.258 1999/11/03 21:35:00 mud Exp $";
d5841 1
a5841 1
      for ( victim= ch->in_room->people; victim != NULL; victim = victim->next_in_room )
@


1.258
log
@Combine 'hexes' rather then add them all
-POquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.257 1999/11/03 21:28:36 mud Exp $";
d5840 1
@


1.257
log
@Mummys take +25% dam from 'fire', normal damage from Flaming and -50% dam from others
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.256 1999/11/03 20:06:08 mud Exp $";
d5801 1
a5801 1
          affect_to_char( victim, &af );
d5805 1
a5805 1
          affect_to_char( victim, &af );
d5808 1
a5808 3
          if ( ch != victim )
             act("$N feels the hex upon them.",ch,NULL,victim,TO_CHAR);
act( "$n has been hexed.", victim, NULL, victim, TO_ROOM );
@


1.256
log
@typo'd should be victim not vicim
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.255 1999/11/03 20:02:51 mud Exp $";
d1285 3
a1287 1
	dam = (5*dam)/4;
@


1.255
log
@Damn missed the ( again
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.254 1999/11/03 20:00:05 mud Exp $";
d5843 1
a5843 1
            && (is_clan(victim) || (!is_clan(victim) && IS_NPC(vicim))))
@


1.254
log
@Fix missing ( in de_fear
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.253 1999/11/03 03:56:39 mud Exp $";
d5843 1
a5843 2
            && (is_clan(victim)
            || (!is_clan(victim) && IS_NPC(victim)))
@


1.253
log
@Add delay on Fear
Lower delay on Fear in const.c
Fix Fear to not fear nonclanners
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.252 1999/11/03 02:39:29 mud Exp $";
d5843 2
a5844 2
            && is_clan(victim)
            && !IS_NPC(victim))
d5854 1
@


1.252
log
@Odd syntax errors in fight.c
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.251 1999/11/03 02:36:44 mud Exp $";
d5829 4
a5832 4
   if ( ch->mana < 20 )
   {
      send_to_char("You're tired of making scary faces.\n\r",ch);
      return;
d5834 1
d5836 1
a5836 1
   ch->mana -= 20;
d5838 1
a5838 1
   for ( victim= ch->in_room->people; victim != NULL; victim = victim->next_in_room )
d5840 1
a5840 1
      if(victim != ch)
d5842 3
a5844 2
         was_in = victim->in_room;
         for ( attempt = 0; attempt < 6; attempt++ )
d5846 5
a5850 2
	    door = number_door();
	    if ( ( pexit = was_in->exit[door] ) == 0
a5853 1
		 || ( IS_NPC(victim)
d5855 1
a5855 1
               continue;
d5857 9
a5865 8
            move_char( victim, door, FALSE );
            if ( ( now_in = victim->in_room ) == was_in )
               continue;

            victim->in_room = was_in;
            act( "$n runs in fear!", victim, NULL, NULL, TO_ROOM );
            victim->in_room = now_in;
            send_to_char("You run in fear.\n\r",victim);
d5868 6
a5874 1

@


1.251
log
@Fix Fear, I hope
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.250 1999/11/03 02:29:24 mud Exp $";
d5839 1
a5839 1
      if(gch != ch)
@


1.250
log
@Syntax error?
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.249 1999/11/03 02:23:57 mud Exp $";
d5823 3
a5825 2
   CHAR_DATA *gch;
   ROOM_INDEX_DATA *was_in,*now_in;
d5829 9
a5837 1
   for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
a5838 4
   /*
      if( gch != ch && (gch->max_hit / (gch->wimpy+1)) <= 3 )
      {
      */
d5841 1
a5841 1
         was_in = gch->in_room;
d5848 2
a5849 2
		 ||   number_range(0,gch->daze) != 0
		 || ( IS_NPC(gch)
d5853 2
a5854 2
            move_char( gch, door, FALSE );
            if ( ( now_in = gch->in_room ) == was_in )
d5857 4
a5860 4
            gch->in_room = was_in;
            act( "$n runs in fear!", gch, NULL, NULL, TO_ROOM );
            gch->in_room = now_in;
            send_to_char("You run in fear.\n\r",gch);
@


1.249
log
@Poquah you dolt forgot the } again
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.248 1999/11/03 02:12:49 mud Exp $";
d5859 1
@


1.248
log
@Add better messging to hex and only use hex when in combat
Add check to fear to not fear the Mummy
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.247 1999/11/03 00:10:00 mud Exp $";
d5835 1
@


1.247
log
@Add failure chance to hex, and a wait state and a chance to improve
Remove Wimpy check from Fear to see if it works
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.246 1999/11/02 08:05:13 mud Exp $";
d5755 5
d5762 1
a5762 10
    if ( arg[0] == '\0' )
    {
	victim = ch->fighting;
	if ( ( victim = ch->fighting ) == NULL )
	{
	    send_to_char("You aren't fighting anybody.\n\r",ch);
	    return;
	}
    }
    else if ( ( victim = get_char_room(ch,arg) ) == NULL )
d5805 1
a5805 1
          send_to_char( "You feel unclean.\n\r", victim );
d5807 2
a5808 1
             act("$N looks very uncomfortable.",ch,NULL,victim,TO_CHAR);
d5834 1
d5856 1
a5856 2
     /* }
     */
@


1.246
log
@Missing } in do_hex
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.245 1999/11/02 08:03:23 mud Exp $";
d5783 33
a5815 1
    if ( saves_spell(ch->level,victim,DAM_OTHER))
d5817 2
a5818 2
       send_to_char("You failed.\n\r",ch);
       return;
a5820 16
    af.where     = TO_AFFECTS;
    af.type      = gsn_curse;
    af.level     = ch->level;
    af.duration  = ch->level / 3;
    af.location  = APPLY_HITROLL;
    af.modifier  = -1 * (ch->level / 8);
    af.bitvector = AFF_CURSE;
    affect_to_char( victim, &af );

    af.location  = APPLY_SAVING_SPELL;
    af.modifier  = ch->level / 8;
    affect_to_char( victim, &af );

    send_to_char( "You feel unclean.\n\r", victim );
    if ( ch != victim )
  act("$N looks very uncomfortable.",ch,NULL,victim,TO_CHAR);
d5828 2
a5829 1
   int attempt;
d5833 1
d5836 6
a5841 7
	    was_in = gch->in_room;
	    for ( attempt = 0; attempt < 6; attempt++ )
		{
		 EXIT_DATA *pexit;
		 int door;
		 door = number_door();
		 if ( ( pexit = was_in->exit[door] ) == 0
d5847 1
a5847 1
		 continue;
d5849 13
a5861 11
		 move_char( gch, door, FALSE );
		 if ( ( now_in = gch->in_room ) == was_in )
		 continue;

		 gch->in_room = was_in;
		 act( "$n runs in fear!", gch, NULL, NULL, TO_ROOM );
		 gch->in_room = now_in;
		 send_to_char("You run in fear.\n\r",gch);
		}
	  }
	}
@


1.245
log
@Declare attemp in do_fear
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.244 1999/11/02 08:00:14 mud Exp $";
d5781 1
@


1.244
log
@Declare was_in and now_in in do_fear
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.243 1999/11/02 07:51:19 mud Exp $";
d5809 1
a5809 1
   CHAR_DATE *gch;
d5811 1
@


1.243
log
@Add 'hex' and 'fear' for Mummies
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.242 1999/10/31 02:23:25 mud Exp $";
d5782 1
a5782 1
    if ( saves_spell(level,victim,DAM_OTHER))
d5790 2
a5791 2
    af.level     = level;
    af.duration  = level / 3;
d5793 1
a5793 1
    af.modifier  = -1 * (level / 8);
d5798 1
a5798 1
    af.modifier  = level / 8;
d5810 1
@


1.242
log
@new remort 'mummy' with skill 'breathe'
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.241 1999/10/30 01:11:14 mud Exp $";
d45 1
d47 1
d5749 93
@


1.241
log
@Put a eq check around the (Dua) wield check to fix a cosmetic bug if the
dual weilder wasnt wearing a seocnd weapon
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.240 1999/10/26 16:11:08 mud Exp $";
d42 1
d1278 8
d5747 67
@


1.240
log
@Remove X2 exp
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.239 1999/10/25 03:59:57 mud Exp $";
d415 1
a415 1
     if ( number_percent() <  get_skill(ch,gsn_dual_wield) / 2 )
d417 9
a425 6
   if (!IS_SET(ch->display,DISP_BRIEF_COMBAT))
   	send_to_char("(Dua) ",ch);
   one_hit( ch, victim, TYPE_SECONDARY );
   check_improve(ch,gsn_dual_wield,TRUE,9);
   if ( ch->fighting != victim )
       return;
d427 1
d447 1
a447 1
	 get_skill(ch,gsn_bladesong) - 95 * 5 > number_percent() )
@


1.239
log
@XP doubled day just for fun
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.238 1999/10/18 23:13:48 mud Exp $";
a3654 1
    xp *= 2;
@


1.238
log
@check_improve for Riding was 10,TRUE instead of TRUE,10
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.237 1999/10/17 23:22:50 mud Exp $";
d3655 1
@


1.237
log
@Changes autorescue to norescue, made more sense
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.236 1999/10/17 22:56:43 mud Exp $";
d317 1
a317 1
    check_improve(ch,gsn_riding,10,TRUE);
@


1.236
log
@Fight.c - Changed do_rescue to check for MHS_AUTORESCUE
act_info.c - Displays of AUTORESCUE
handler.c - do_autorescue created
interp.c and interp.h - defined new do_autorescue
merc.h - defined MHS_AUTORESCUE
tables.c - added autorescue
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.235 1999/10/15 23:49:05 mud Exp $";
d5291 1
a5291 1
    if (IS_SET(victim->mhs,MHS_AUTORESCUE))
d5293 1
a5293 1
       send_to_char("They don't want to be rescue.\n\r",ch);
@


1.235
log
@'act' not 'ct' missing function :P
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.234 1999/10/15 23:47:05 mud Exp $";
d5289 6
@


1.234
log
@Added messages for those in room to see morph wear off properly
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.233 1999/10/15 23:32:51 mud Exp $";
d1262 1
a1262 1
       ct( "$n returns to $s regular appearance.", ch, NULL, ch, TO_ROOM );
@


1.233
log
@Added descriptive messages when morph in or out
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.232 1999/10/15 01:17:29 mud Exp $";
d1261 2
a1262 2
       send_to_char("You return to your regular form. Yikes!\n\r",ch);
       act( "$r morphs into $n.",ch->long_descr,NULL,ch,TO_ROOM );
@


1.232
log
@Changed char_in_room to check for is_name (name) and (save_name) to avoid having
to change ch->name, cause that can get messy.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.231 1999/10/15 00:31:00 mud Exp $";
d1259 1
d1261 3
@


1.231
log
@Added return of save_name to name when fighting starts or when shapemorph return
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.230 1999/10/14 00:02:02 mud Exp $";
a1258 3
    {
       free_string( ch->name );                                                                 
       ch->name = str_dup( ch->save_name );
a1259 1
    }
@


1.230
log
@ Added a check to do_garotte for victim == ch
 to prevent people from garotting themselves


 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.229 1999/10/13 23:38:40 mud Exp $";
d1260 2
a1261 1
       ch->name = ch->save_name;
@


1.229
log
@Working on Shapemorph, added removal of shapemorph during combat, added a save_name
variable to store of the person's name and added the actual argument to the name
while morphed so you can actually attack them, I hope.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.228 1999/10/09 17:22:19 mud Exp $";
d5934 6
@


1.228
log
@Somebody fucked this up, I fixed it.
-G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.227 1999/10/09 17:16:43 mud Exp $";
d1254 9
@


1.227
log
@ Added in some changes to outcast.  All checks on clan outcast now include an additional check on their timre.  read the change to find out why

 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.226 1999/10/08 20:16:06 mud Exp $";
a1901 4
   if ( victim->riding == ch || victim->passenger == ch ||
	ch->riding == victim || ch->passenger == victim )
  return FALSE;

a2055 4
   if ( victim->riding == ch || victim->passenger == ch ||
	   ch->riding == victim || ch->passenger == victim )
	     return FALSE;

a2213 4
   if ( victim->riding == ch || victim->passenger == ch ||
	   ch->riding == victim || ch->passenger == victim )
	     return FALSE;

d3641 1
a3641 1
     if ( gch->clan == clan_lookup("outcast") && (ch->pcdata->outcT > 0) )
@


1.226
log
@Fight.c -> changed xp_compute
interp.c, interph -> added a command 'level'
merc.h -> added structure for debit_levels and define for PREFRESH
save .h -> save debit levels
update.c -> change advancement, contains do_olevel function

Coded by Ben
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.225 1999/10/07 01:44:34 mud Exp $";
d3653 1
a3653 1
     if ( gch->clan == clan_lookup("outcast") )
@


1.225
log
@Fixed Garotte
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.224 1999/10/07 01:41:43 mud Exp $";
d3464 4
@


1.224
log
@Touching
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.223 1999/10/07 01:15:30 mud Exp $";
a5921 3
    if (is_safe(ch,victim))
       return;

d5933 3
@


1.223
log
@Fix Garoote added is_safe
-Poquah
@
text
@d15 1
a15 1
 *  around, comes around.                                                  *
d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.222 1999/09/30 00:35:52 mud Exp $";
@


1.222
log
@Fixes to bleed, and zap, kill stealing bugs


Rage
:wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.221 1999/09/28 23:20:34 mud Exp $";
d5921 3
@


1.221
log
@Myrmidon
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.220 1999/09/26 19:03:20 mud Exp $";
d5644 9
@


1.220
log
@Removed 2X exp
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.219 1999/09/25 04:14:19 mud Exp $";
d56 1
d359 1
d380 1
d405 10
d2535 2
d2600 2
d2763 2
d3652 1
a3652 1
    xp = 99 * xp / 100; /* Gradually step this down until it's about 75 */
d6197 32
@


1.219
log
@2X Exp for the day
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.218 1999/09/18 21:46:42 mud Exp $";
a3633 1
    xp *= 2;
@


1.218
log
@Crahs bug fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.217 1999/09/18 08:44:12 mud Exp $";
d3634 1
@


1.217
log
@Elementalist Electric Shield
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.216 1999/09/18 08:07:05 mud Exp $";
d4504 2
a4505 2
  act("$n falls from $s mount!",ch,NULL,NULL,TO_ROOM);
  act("You fall from your mount!",ch,NULL,NULL,TO_CHAR);
@


1.216
log
@Elementalists Frost Shield
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.215 1999/09/16 04:00:31 mud Exp $";
d1024 3
d1147 4
@


1.215
log
@Various changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.214 1999/09/14 05:16:50 mud Exp $";
d1011 3
d1140 4
@


1.214
log
@Fixed grenade command
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.213 1999/09/14 04:39:41 mud Exp $";
d666 1
a666 1
	/* Adjustment for druids */
d668 2
a669 1
	skill -= ( skill / 10 );
@


1.213
log
@Minor changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.212 1999/09/08 20:00:01 mud Exp $";
d3952 2
a3953 1
   CHAR_DATA *victim;
d3957 1
d3965 1
a3965 1
    if ( ( victim = get_char_room(ch,arg) ) == NULL )
@


1.212
log
@Xp adjustment #1
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.211 1999/09/02 03:43:12 mud Exp $";
d1389 1
a1389 1
       victim->pcdata->sac -= dam; 
@


1.211
log
@Some basic bug fixes to mounted code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.210 1999/08/27 01:26:48 mud Exp $";
d3618 1
@


1.210
log
@Some checking
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.209 1999/08/26 22:42:41 mud Exp $";
d318 1
a318 1

d1874 4
d2032 4
d2193 4
@


1.209
log
@Link death stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.208 1999/08/26 16:37:54 mud Exp $";
d305 3
a307 1

d317 2
d329 6
a334 1
  one_hit(ch,victim,dt);
d340 5
a344 1
  one_hit(ch,victim,dt);
d351 5
a355 1
     one_hit(ch,victim,dt);
d369 2
d394 2
d404 2
d423 3
d427 1
d431 5
a435 1
		one_hit( ch, victim, dt );
d439 5
a443 1
		one_hit( ch, victim, dt );
@


1.208
log
@Changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.207 1999/08/25 20:56:39 mud Exp $";
d1557 3
a1559 2
          sprintf( cdbuf, "{W%s{x got %s by {W%s{x\n\r",
		  victim->name,toast,ch->name);
@


1.207
log
@Damage Function Bug Squashed!
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.206 1999/08/25 20:17:45 mud Exp $";
d1501 16
a3343 1
  xp *= 2;
@


1.206
log
@I'm bound to squish this!
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.205 1999/08/25 20:16:13 mud Exp $";
a1062 1
 */
d1066 1
a1322 1
  log_string("Section F");
a1325 1
  log_string("Section F1");
d1341 2
a1342 1
	 number_percent() <= get_skill(victim,gsn_communion) + 1 )
a1343 3
  sprintf(log_buf,"Section F2 %s victim %d hit %d dam %d comm",
	  victim->name,victim->hit,dam,get_skill(victim,gsn_communion));
  log_string(log_buf);
a1346 1
  log_string("Section F2.1");
a1351 1
  log_string("Section F2.2");
a1359 1
  log_string("Section F3");
a1361 1
  log_string("Section G");
a1659 1
  log_string("Section Z");
@


1.205
log
@Narrowed it down to Communion?
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.204 1999/08/25 19:30:24 mud Exp $";
d1347 1
a1347 1
  log_string(log_bug);
@


1.204
log
@Narrow the Debug lines down
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.203 1999/08/25 18:44:21 mud Exp $";
d1345 3
a1347 1
  log_string("Section F2");
d1350 2
d1357 1
@


1.203
log
@Add Sections Logging to damage() function to track this bug down
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.202 1999/08/25 03:05:40 mud Exp $";
a1092 2
  log_string("Section A");

a1155 1
  log_string("Section B");
a1194 1
  log_string("Section C");
a1247 1
  log_string("Section D");
a1305 1
  log_string("Section E");
d1327 1
d1345 1
d1361 1
a1425 2
  log_string("Section H");

a1461 1
  log_string("Section I");
a1543 1
  log_string("Section J");
a1598 1
  log_string("Section K");
a1654 1
  log_string("Section L");
@


1.202
log
@Change to where crash bug logging is attempted to be checked
Put the log in bool damage() as the log in multi_hit() is basically
useless.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.201 1999/08/24 05:47:49 mud Exp $";
d1093 2
d1158 1
d1198 1
d1252 1
d1311 1
d1329 1
d1367 1
d1429 2
d1467 1
d1550 1
d1606 1
d1663 1
d1672 1
@


1.201
log
@More hoping
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.200 1999/08/23 22:48:19 mud Exp $";
d282 2
d286 1
d1060 7
@


1.200
log
@Added some warnings to find crash bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.199 1999/08/23 03:41:14 mud Exp $";
d1048 1
a1048 2
bool damage(CHAR_DATA *ch,CHAR_DATA *victim,int dam,int dt,int dam_type,
      bool show, bool iOld) 
a1049 1

d3315 2
a3316 1
  xp = xp_compute( gch, victim, group_levels );  
@


1.199
log
@Fixed a typo
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.198 1999/08/23 03:34:44 mud Exp $";
d281 3
@


1.198
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.197 1999/08/23 02:06:35 mud Exp $";
d4434 1
a4434 1
	     DAZE_STAT( victim, PULSE_VIOLENCE );
@


1.197
log
@Fixing typo in disarm ch shoudl have been victim
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.196 1999/08/22 17:24:28 mud Exp $";
d305 10
d708 14
d1809 3
d1963 3
d2121 3
d2259 7
a2265 1
     
d3184 1
d3193 1
d4235 2
d4356 6
d4363 1
a4363 1
       && chance < get_skill(victim,gsn_dodge) )
d4375 1
a4375 1
    if ( !IS_NPC(victim) && 
d4402 12
d4417 6
d4424 1
a4424 1
      act("You roll to your feet.",ch,NULL,victim,TO_VICT);
d4428 14
a4441 1
  DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
d4446 1
@


1.196
log
@Fixed communion
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.195 1999/08/19 16:23:05 mud Exp $";
d5598 1
a5598 1
    if ( is_affected(ch,gsn_rage) || is_affected(ch,gsn_bladesong) )
@


1.195
log
@Give Battleragers back the -4 Dex and make the AC a + not -
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.194 1999/08/19 05:31:42 mud Exp $";
d1306 1
a1306 1
	 number_percent() <= get_skill(victim,gsn_communion) )
@


1.194
log
@Chanfges
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.193 1999/08/19 04:56:49 mud Exp $";
d5872 1
a5872 1
        af.modifier  = -1 * ch->level;
d5875 6
@


1.193
log
@Fixed stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.192 1999/08/13 21:35:52 mud Exp $";
d3819 1
a3819 1
  WAIT_STATE(ch,3 * PULSE_VIOLENCE);
@


1.192
log
@Listen command
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.191 1999/08/13 18:48:33 mud Exp $";
a4297 1
    chance -= GET_AC(victim,AC_BASH) /25;
@


1.191
log
@Basic stuff for alchemists, saves changes, magelabs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.190 1999/08/12 17:41:20 mud Exp $";
d1401 2
a1402 1
  if ( victim->hit < victim->max_hit / 4 )
@


1.190
log
@ added in a check for orb of touch in tail_slap

 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.189 1999/08/12 01:03:57 mud Exp $";
d3827 95
@


1.189
log
@Nethermancers are in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.188 1999/08/11 20:39:23 mud Exp $";
d4046 8
@


1.188
log
@Vindicator change didn't commit with the lsat one
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.187 1999/08/11 05:19:50 mud Exp $";
d911 8
a918 2
          fire_effect( (void *) victim,wield->level/2,dam,TARGET_CHAR);

d1146 6
d1288 16
@


1.187
log
@SOme more changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.186 1999/08/11 04:55:49 mud Exp $";
d343 1
a343 1
	if (!IS_NPC(ch) && !HAS_KIT(ch,"vindicator") &&
@


1.186
log
@Many many changes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.185 1999/08/09 22:08:27 mud Exp $";
d307 1
a307 1
	 number_percent() < ( ch->pcdata->sac / 3 ) 
d321 1
a321 1
     number_percent() < ( ch->pcdata->sac / 3 ) )
d365 1
a365 1
     if ( number_percent() <  get_skill(ch,gsn_dual_wield) )
d383 1
a383 1
	if ( number_percent() < get_weapon_skill(ch,wsn) / 5 ) 
@


1.185
log
@Removed all of Rusty's cheat codes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.184 1999/08/02 18:05:17 mud Exp $";
d723 1
a723 1
      if ( number_percent() > (get_curr_stat(ch,STAT_DEX)*6) )
d2357 1
a2357 1
	  chance -= 25;
d2360 1
a2360 1
	chance /= 2;
d2388 9
d2423 1
a2423 1
	  chance -= 25;
d2441 1
a2441 1
	chance /= 2;
d2579 1
a2579 1
  return FALSE;
d2582 1
d2584 1
a2584 1
      chance -= 25;
d2598 1
a2598 1
	chance /= 2;
d2635 3
a2637 2
	if ( is_affected(victim,gsn_fumble) &&
		number_percent() > (get_curr_stat(victim,STAT_DEX) * 6) )
d2643 1
a2643 1
	    DAZE_STATE(victim,PULSE_VIOLENCE);
@


1.184
log
@Can now sneak out of combat again
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.183 1999/08/01 05:00:06 mud Exp $";
d314 1
a314 1
    if (IS_AFFECTED(ch,AFF_HASTE) || IS_SET(ch->act,PLR_OLD))
a705 1
  if(IS_SET(victim->act,PLR_OLD)) victim_ac -= 5;
a1056 1
    if(IS_SET(victim->act,PLR_OLD)) dam = (3 * dam)/2;
d1298 1
a1298 1
       &&   ( victim->level >= LEVEL_IMMORTAL || IS_SET(victim->act,PLR_OLD) )
@


1.183
log
@Sneaking ends with combat now
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.182 1999/07/30 05:42:14 mud Exp $";
a1145 6

    /*
     * No Sneaking.
     */
    affect_strip( ch,gsn_sneak );
    REMOVE_BIT( ch->affected_by, AFF_SNEAK );
@


1.182
log
@Blled bug letting bleed outside levle range add is_safe
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.181 1999/07/25 00:13:24 mud Exp $";
d1146 6
@


1.181
log
@Use str_cmp for bladesong instead of str_prefix
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.180 1999/07/23 22:15:20 mud Exp $";
d5306 3
@


1.180
log
@have to use cdbuf not buf
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.179 1999/07/23 22:08:59 mud Exp $";
d5770 1
a5770 1
	if ( !str_prefix(arg,"stop") && is_affected(ch,gsn_bladesong))
@


1.179
log
@Matookers can now see mortally wounded or incapitated
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.178 1999/07/23 20:01:11 mud Exp $";
d1316 1
a1316 1
     sprintf(buf, 
d1329 1
a1329 1
           send_to_char(buf, victm);
d1342 1
a1342 1
     sprintf(buf, 
d1355 1
a1355 1
           send_to_char(buf, victm);
@


1.178
log
@Removing Approval Code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.177 1999/07/23 05:06:02 mud Exp $";
d1314 18
d1340 18
@


1.177
log
@Added a return to the bladesong stop so it doesnt keep adding it on to you
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.176 1999/07/23 05:02:29 mud Exp $";
a3424 3

     if ( IS_SET(gch->mhs,MHS_UNAPPROVED) && gch->level == 4 ) 
        xp = 0;
@


1.176
log
@ opps used affect_remove instead of affect_strip
 -Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.175 1999/07/23 04:42:40 mud Exp $";
d5742 1
@


1.175
log
@Helps if you declare arg poquah you goof
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.174 1999/07/23 04:40:40 mud Exp $";
d5739 1
a5739 1
	   affect_remove(ch,gsn_bladesong);
@


1.174
log
@My typing sucks, argument, not arguement
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.173 1999/07/23 04:38:15 mud Exp $";
d5728 1
@


1.173
log
@Bladesong Change
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.172 1999/07/23 04:19:32 mud Exp $";
d5723 1
a5723 1
void do_bladesong ( CHAR_DATA *ch, char *arguement )
@


1.172
log
@Add stop to bladesong
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.171 1999/07/23 03:35:28 mud Exp $";
d5723 1
a5723 1
void do_bladesong ( CHAR_DATA *ch, char *arg )
@


1.171
log
@doh typoed
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.170 1999/07/23 03:31:34 mud Exp $";
d5734 8
@


1.170
log
@Chars of level 4 and names unapproved receive 0 xp
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.169 1999/07/21 17:34:51 mud Exp $";
d3426 1
a3426 1
     if ( IS_SET(ch->mhs,MHS_UNAPPROVED) && gch->level == 4 ) 
d5255 1
a5255 1
	 || !is_clan(ch) && !IS_NPC(victim))
@


1.169
log
@Minor bleed bug with nonclanners bleeding each other
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.168 1999/07/21 01:13:26 mud Exp $";
d3425 3
@


1.168
log
@Fixed some stuff with fumble so everybody shuts the fuck upo
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.167 1999/07/20 13:57:52 mud Exp $";
d5251 2
a5252 1
    if (is_clan(ch) && !is_clan(victim) && !IS_NPC(victim))
@


1.167
log
@Still working on fixing bleed...lots of nasty stuff

Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.166 1999/07/20 13:43:42 mud Exp $";
d724 1
a724 1
      if ( number_percent() > (get_curr_stat(ch,STAT_DEX)*4) )
d2592 1
a2592 1
		number_percent() > (get_curr_stat(victim,STAT_DEX) * 4) )
@


1.166
log
@added some more insanity checking into bleed.. and fixed a bug with the last stuff I did :)

Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.165 1999/07/20 13:33:29 mud Exp $";
d5251 1
a5251 1
    if (is_clan(ch) && !is_clan(victim))
d5259 1
a5259 1
	send_to_char("You cannot bleed the already dead\n\r", ch);
@


1.165
log
@ made some new checking in bleed..to avoid anyone bleeding IMMs and clanners and nonclanners bleeding each other.


 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.164 1999/07/19 20:31:01 mud Exp $";
d5253 1
a5253 1
	send_to_char("Don't cheat...you will get caught.\n\r");
d5257 5
@


1.164
log
@Fixed a bug in fumble
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.163 1999/07/15 20:20:05 mud Exp $";
d5243 15
@


1.163
log
@fixed battlerager bug


Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.162 1999/07/14 18:13:38 mud Exp $";
d724 1
a724 1
      if ( number_percent() < (get_curr_stat(ch,STAT_DEX)*6) )
@


1.162
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: fight.c,v 1.161 1999/07/11 21:34:36 mud Exp $";
d5689 1
a5689 1
		af.location = IMM_CHARM;
d5691 1
@


1.161
log
@Blah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.160 1999/07/11 19:09:21 mud Exp $ */
@


1.160
log
@fixed some bugs in battle ragere, new toast messages and summon elemental

Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.159 1999/07/10 13:45:53 mud Exp $ */
d1300 1
a1300 1
       &&   victim->level >= LEVEL_IMMORTAL
@


1.159
log
@Unique Toasting messages
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.158 1999/07/10 07:38:27 mud Exp $ */
d1026 1
a1026 1
    char toast[15];
@


1.158
log
@Fix Unique Messages for Toast
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.157 1999/07/10 07:29:28 mud Exp $ */
d1428 1
a1428 1
if (((ch->hit/ch->max_hit)*100) < 10)
d1430 1
a1430 1
if (((ch->hit/ch->max_hit)*100) >= 10)
d1432 1
a1432 1
if (((ch->hit/ch->max_hit)*100) >= 25)
d1434 1
a1434 1
if (((ch->hit/ch->max_hit)*100) >= 50)
d1436 1
a1436 1
if (((ch->hit/ch->max_hit)*100) >= 75)
d1438 1
a1438 1
if (((ch->hit/ch->max_hit)*100) >= 100)
@


1.157
log
@Tweak Unique Toast messages
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.156 1999/07/10 07:10:17 mud Exp $ */
d1428 10
a1438 1
{
a1439 21
}
else if (((ch->hit/ch->max_hit)*100) >= 75)
{
   strcpy(toast,"crushed");
}
else if (((ch->hit/ch->max_hit)*100) >= 50)
{
   strcpy(toast,"flattened");
}
else if (((ch->hit/ch->max_hit)*100) >= 25)
{
   strcpy(toast,"trashed");
}
else if (((ch->hit/ch->max_hit)*100) >= 10)
{
   strcpy(toast,"toasted");
}
else if (((ch->hit/ch->max_hit)*100) < 10)
{
   strcpy(toast,"edged out");
}
@


1.156
log
@Unique Toast Messages
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.155 1999/07/10 07:02:47 mud Exp $ */
d1448 1
a1448 1
else
@


1.155
log
@Unique toast messages
-poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.154 1999/07/07 13:18:13 mud Exp $ */
d1430 1
a1430 1
   toast = "slaughtered";
d1434 1
a1434 1
   toast = "crushed";
d1438 1
a1438 1
   toast = "flattened";
d1442 1
a1442 1
   toast = "trashed";
d1446 1
a1446 1
   toast = "toasted";
d1450 1
a1450 1
   toast = "edged out";
@


1.154
log
@fixed big with battle ragers...now, your current hp as well as your max are
inflated.  Didn't make much sense otherwize.

Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.153 1999/07/04 21:45:13 mud Exp $ */
d1026 1
d1428 28
d1458 1
d1473 1
a1473 1
       sprintf( log_buf, "%s got toasted by %s at %s [room %d]",
d1475 1
@


1.153
log
@Had the chars secondary being removed instead of the victims
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.152 1999/07/03 00:33:57 mud Exp $ */
d5660 3
@


1.152
log
@Added in kender resistance to tail bash, similar to other types of bashing.

Added in some #defines for a future spell group


Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.151 1999/07/03 00:01:28 mud Exp $ */
d3561 1
a3561 1
       if ((obj = get_eq_char(ch,WEAR_SECOND)) != NULL)
d3564 2
a3565 2
	  obj_to_char( obj, ch);
	  equip_char( ch, obj, WEAR_WIELD );
d3586 1
a3586 1
       if ((obj = get_eq_char(ch,WEAR_SECOND)) != NULL)
d3589 2
a3590 2
          obj_to_char( obj, ch);
	  equip_char( ch, obj, WEAR_WIELD );
@


1.151
log
@Forogt a (
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.150 1999/07/02 23:57:55 mud Exp $ */
d3965 3
a3967 1
  
@


1.150
log
@If primary disarmed or praimary removed move secondary into primary
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.149 1999/07/02 23:53:59 mud Exp $ */
d3586 1
a3586 1
       if (obj = get_eq_char(ch,WEAR_SECOND)) != NULL)
@


1.149
log
@Move second weapon to primary when disarmed primary and when remove primary
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.148 1999/07/02 03:20:46 mud Exp $ */
d3561 1
a3561 1
       if (obj = get_eq_char(ch,WEAR_SECOND)) != NULL)
@


1.148
log
@Add action for others in room to see a bladesong start
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.147 1999/07/02 03:12:53 mud Exp $ */
d3559 8
d3584 8
@


1.147
log
@Bladesong fixes and notifications
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.146 1999/06/28 06:34:17 mud Exp $ */
d5742 1
a5742 1
	act("$n begins to make his blades dance!",victim,NULL,NULL,TO_ROOM);
@


1.146
log
@Fixed skill levels
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.145 1999/06/24 22:29:09 mud Exp $ */
a5713 3
        act("You begin to perform the bladesong.",
                        ch, NULL, NULL, TO_CHAR);
        
d5716 1
d5741 2
@


1.145
log
@Added clan notes.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.144 1999/06/20 22:43:44 mud Exp $ */
d3637 1
a3637 1
    &&   ch->level < skill_table[gsn_berserk].skill_level[ch->class]))
d3730 1
a3730 1
    &&    ch->level < skill_table[gsn_throw].skill_level[ch->class]))
d3989 1
a3989 1
    &&    ch->level < skill_table[gsn_bash].skill_level[ch->class]))
d4188 1
a4188 1
    &&    ch->level < skill_table[gsn_dirt].skill_level[ch->class]))
d4339 1
a4339 1
    && ch->level < skill_table[gsn_trip].skill_level[ch->class]))
d4641 1
a4641 1
    &&   ch->level < skill_table[gsn_backstab].skill_level[ch->class] )
d4920 1
a4920 1
    &&   ch->level < skill_table[gsn_kick].skill_level[ch->class] )
d4972 1
a4972 1
    &&   ch->level < skill_table[gsn_insanity].skill_level[ch->class] )
d5475 1
a5475 1
    &&   ch->level < skill_table[gsn_garotte].skill_level[ch->class] )
d5583 1
a5583 1
        if ( skill_table[gsn_rage].skill_level[ch->class] > ch->level )
d5679 1
a5679 1
        if ( ch->level < skill_table[gsn_bladesong].skill_level[ch->class] )
@


1.144
log
@Typo in bladesong
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.143 1999/06/20 20:29:23 mud Exp $ */
d2565 4
a2568 1
   chance -= 5;
d5723 1
a5723 1
        factor = ch->level / 12;
@


1.143
log
@Bladesinger
Battlerager
Done
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.142 1999/06/13 00:52:40 mud Exp $ */
d5661 1
a5661 1
	if (!HAS_KIT(ch,"bladesong") )
@


1.142
log
@Sharp weapons have 3* the chance of penetrating dragon scales
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.141 1999/06/12 18:51:42 mud Exp $ */
d386 8
d5357 4
d5561 179
@


1.141
log
@Fixed typo's to exhausted too exhausted
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.140 1999/06/11 23:21:54 mud Exp $ */
d2431 1
d2442 4
@


1.140
log
@Stuff I changed.  mostly updates of existing files and changes to seer
and flee.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.139 1999/05/29 15:38:24 mud Exp $ */
d3750 1
a3750 1
        send_to_char("You're to exhausted.\n\r",ch);
d4276 1
a4276 1
	send_to_char("You're to exhausted.\n\r",ch);
d4348 1
a4348 1
        send_to_char("You're to exhausted.\n\r",ch);
d4680 1
a4680 1
	send_to_char("You're to exhausted.\n\r",ch);
d4922 1
a4922 1
        send_to_char("You're to exhausted.\n\r",ch);
d4971 1
a4971 1
        send_to_char("You're to exhausted.\n\r",ch);
d5116 1
a5116 1
        send_to_char("You're to exhausted.\n\r",ch);
d5199 1
a5199 1
        send_to_char("You're to exhausted.\n\r",ch);
d5306 1
a5306 1
        send_to_char("You're to exhausted.\n\r",ch);
d5482 1
a5482 1
        send_to_char("You're to exhausted.\n\r",ch);
@


1.139
log
@Garotte comes off when combat starts.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.138 1999/05/28 11:41:54 mud Exp $ */
d903 2
d2435 1
a2435 1
    chance = victim->level;
d4755 1
a4755 1
    WAIT_STATE( ch, PULSE_PER_SECOND );
@


1.138
log
@Quicken debugging and fix a Highlander bug in Fight.c
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.137 1999/05/27 12:21:08 mud Exp $ */
d2649 1
d2651 2
@


1.137
log
@Proper check for sneak and hide affects for garotte.
Added hide affect strip to visible() command.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.136 1999/05/26 14:14:11 mud Exp $ */
d1693 2
a1694 1
   if (IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_SET(ch->mhs,MHS_HIGHLANDER))
d1700 2
a1701 1
   if (IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
d1844 2
a1845 1
   if (IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
d1851 2
a1852 1
   if (!IS_SET(ch->mhs,MHS_HIGHLANDER) && IS_SET(victim->mhs,MHS_HIGHLANDER))
d1999 2
a2000 1
    if (IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
d2006 2
a2007 1
    if (!IS_SET(ch->mhs,MHS_HIGHLANDER) && IS_SET(victim->mhs,MHS_HIGHLANDER))
@


1.136
log
@No nailing those who are already affected by sleep
or undead NPC's.  -Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.135 1999/05/26 14:02:33 mud Exp $ */
d5480 2
a5481 1
  if( is_affected(ch,gsn_sneak) || is_affected(ch,gsn_hide) )
@


1.135
log
@Making sure there is a garotte victim so they
can't practice on themselves.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.134 1999/05/26 04:11:46 mud Exp $ */
d5459 7
@


1.134
log
@garotte skill typo fixes
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.133 1999/05/26 03:27:31 mud Exp $ */
d5439 3
d5456 1
a5456 1
    if( (victim = get_char_room(ch,argument)) == NULL )
@


1.133
log
@Changes to add in garotte item types and add the garotte
skill to assassins.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.132 1999/05/22 21:57:36 mud Exp $ */
d5437 1
a5437 1
    AFFECT_DATA *af;
d5470 1
a5470 1
  if( is_affected(ch,gsn_sneak) || is_affected(gsn_hide) )
d5476 1
a5476 1
	  number_dice(wield->value[1],wield->value[2]) > 2 )
d5490 1
a5490 1
    af.duration  = UMIN(level,number_dice(wield->value[1],wield->value[2]));
@


1.132
log
@Change to bash/wmpy stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.131 1999/05/22 21:44:15 mud Exp $ */
d5432 92
@


1.131
log
@*Added flame shiel
*Fixed betstow holiness and flamesword
*Repaired a bug in shapaeshifter
*that's it
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.130 1999/05/15 16:39:02 mud Exp $ */
d56 1
d1528 1
a1528 1
       do_flee( victim, "" );
d4720 5
d4726 1
a4726 1
void do_flee( CHAR_DATA *ch, char *argument )
d4732 3
@


1.130
log
@Rangers.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.129 1999/05/08 14:41:41 mud Exp $ */
d916 4
a919 1
      dam = number_range(1,wield->level / 4 + 1);
d1047 4
@


1.129
log
@Dragon bite dmage fixed
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.128 1999/05/05 11:27:38 mud Exp $ */
d82 7
d90 25
d610 15
d685 12
d800 4
d2285 8
d2308 3
d2339 8
d2364 3
d2494 8
d2534 4
a2537 1
    
@


1.128
log
@bound dbite
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.127 1999/05/05 11:12:50 mud Exp $ */
a4956 2
        if ( victim->fighting == NULL )
		bite_damage *= 2;
@


1.127
log
@Fixed a bug in dbite
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.126 1999/05/04 10:43:22 mud Exp $ */
d4970 2
@


1.126
log
@Yanked savant code, minor adjustment todbite
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.125 1999/04/28 05:47:26 mud Exp $ */
d4964 7
a4970 1
	
@


1.125
log
@Blast a Highlander with the Quickening for Killing another Highlander
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.124 1999/04/27 23:45:03 mud Exp $ */
d4957 2
d4964 1
a4964 1
	  
@


1.124
log
@Highlanders Keep Prize for REAL_KILLS
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.123 1999/04/27 06:56:48 mud Exp $ */
d2725 4
d2937 2
@


1.123
log
@Highlanders always lose their heads on death
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.122 1999/04/27 06:53:46 mud Exp $ */
d2733 8
a2745 1

@


1.122
log
@Highlanders always lose their heads on death
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.121 1999/04/27 06:23:40 mud Exp $ */
a2708 2

      msg  = "$n's severed head plops on the ground.";
@


1.121
log
@Add max_hit,max_move, max_mana for Highlander Kills
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.120 1999/04/23 23:43:40 mud Exp $ */
d2710 2
d2808 6
@


1.120
log
@Change all PLR_HIGHLANDER to MHS_HIGHLANDER and moved under MHS bit
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.119 1999/04/22 13:15:26 mud Exp $ */
d2721 3
d2729 3
@


1.119
log
@Add message for is_safe checks
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.118 1999/04/18 06:43:42 mud Exp $ */
d1310 2
a1311 2
       if(!IS_SET(ch->act,PLR_HIGHLANDER) 
	 && !IS_SET(victim->act,PLR_HIGHLANDER))
d1376 2
a1377 2
          if(   !IS_SET(ch->act,PLR_HIGHLANDER)
             && !IS_SET(victim->act,PLR_HIGHLANDER))
d1622 1
a1622 1
   if (IS_SET(victim->act,PLR_HIGHLANDER) && !IS_SET(ch->act,PLR_HIGHLANDER))
d1628 1
a1628 1
   if (IS_SET(ch->act,PLR_HIGHLANDER) && !IS_SET(victim->act,PLR_HIGHLANDER))
d1771 1
a1771 1
   if (IS_SET(ch->act,PLR_HIGHLANDER) && !IS_SET(victim->act,PLR_HIGHLANDER))
d1777 1
a1777 1
   if (!IS_SET(ch->act,PLR_HIGHLANDER) && IS_SET(victim->act,PLR_HIGHLANDER))
d1924 1
a1924 1
    if (IS_SET(ch->act,PLR_HIGHLANDER) && !IS_SET(victim->act,PLR_HIGHLANDER))
d1930 1
a1930 1
    if (!IS_SET(ch->act,PLR_HIGHLANDER) && IS_SET(victim->act,PLR_HIGHLANDER))
d2025 1
a2025 1
      if (!is_clan(ch) && !IS_SET(ch->act,PLR_HIGHLANDER))
d2028 1
a2028 1
      if (!is_clan(victim) && !IS_SET(victim->act,PLR_HIGHLANDER))
d2034 1
a2034 1
      if (!IS_SET(victim->act,PLR_HIGHLANDER))
d2083 1
a2083 1
     if(!IS_SET(ch->act,PLR_HIGHLANDER) && !IS_SET(victim->act,PLR_HIGHLANDER))
d2101 1
a2101 1
    if(!IS_SET(ch->act,PLR_HIGHLANDER) && !IS_SET(victim->act,PLR_HIGHLANDER))
d2731 1
a2731 1
   REMOVE_BIT(victim->act,PLR_HIGHLANDER);
d2902 1
a2902 1
      if (IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d3619 1
a3619 1
       IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d3761 1
a3761 1
       IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d3878 1
a3878 1
       IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d4067 1
a4067 1
       IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d4217 1
a4217 1
       IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d4355 1
a4355 1
       IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d4429 1
a4429 1
       IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d4517 1
a4517 1
       IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
d4895 1
a4895 1
	   IS_SET(victim->act,PLR_HIGHLANDER) && IS_SET(ch->act,PLR_HIGHLANDER))
@


1.118
log
@Fix typo
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.117 1999/04/18 06:41:37 mud Exp $ */
d1623 2
d1626 1
d1629 2
d1632 1
d1772 2
d1775 1
d1778 2
d1781 1
d1925 2
d1928 1
d1931 2
d1934 1
@


1.117
log
@Highlanders do not get Flags
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.116 1999/04/18 06:24:53 mud Exp $ */
d2083 1
a2083 1
    if(!IS_SET(ch->act,PLR_HIGHLANDER) && !_IS_SET(victim->act,PLR_HIGHLANDER))
@


1.116
log
@Change Highlanders is_safe, all Highlanders will be clanned (temp)
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.115 1999/04/17 06:09:33 mud Exp $ */
d2065 2
d2081 1
d2083 2
a2084 1

d2104 1
@


1.115
log
@More Highlande stuff
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.114 1999/04/16 16:59:16 mud Exp $ */
d1622 6
d1727 1
a1727 1
      if (!is_clan(ch) && !IS_SET(ch->act,PLR_HIGHLANDER))
d1733 1
a1733 1
      if (!is_clan(victim) && !IS_SET(victim->act,PLR_HIGHLANDER))
a1738 2
      if (!IS_SET(victim->act,PLR_HIGHLANDER))
      {
a1740 1
      }
d1765 6
d1911 6
@


1.114
log
@DWEEBS corpses can be looted by anyone.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.113 1999/04/16 16:17:06 mud Exp $ */
d2674 1
d2678 10
@


1.113
log
@Yanked grouping range change, added anti "Pick on someone your own size."
spam if() checking for brief combat.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.112 1999/04/15 18:02:22 mud Exp $ */
d1322 1
d2074 1
d2588 3
@


1.112
log
@Adding Highlander vs Highlander checks to not strip flags etc
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.111 1999/04/14 21:17:08 mud Exp $ */
d1739 1
a1739 1
	  && victim->fighting != ch && !is_same_group(victim->fighting,ch) )
d1741 1
d1877 1
a1877 1
   && victim->fighting != ch && !is_same_group(victim->fighting,ch) )
d1879 1
@


1.111
log
@Honorable oneo on one combat for Highlanders
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.110 1999/04/14 07:10:05 mud Exp $ */
d951 1
a951 1
  return FALSE;
d958 11
a968 11
  sprintf(log_buf,"Damage (%d) from %s: more than 1200 points!",dam,ch->name);
  bug( log_buf, 0 );
  dam = 1200;
  if (!IS_IMMORTAL(ch))
  {
      OBJ_DATA *obj;
      obj = get_eq_char( ch, WEAR_WIELD );
      if ( obj != NULL && !IS_WEAPON_STAT(obj,WEAPON_VORPAL) )
      {
        send_to_char("You really shouldn't cheat.\n\r",ch);
        /* 
d970 2
a971 4
      }

  }

d977 1
a977 1
  dam = (dam - 55)/2 + 55;
d979 2
a980 2
  dam = (dam - 120)/2 + 120; 
	if(IS_SET(victim->act,PLR_OLD)) dam = (3 * dam)/2;
d982 1
a982 1
/* barbarian endurance -> little randomness */
d998 3
a1000 3
  if ( is_safe( ch, victim ) )
      return FALSE;
  check_killer( ch, victim );
d1002 6
a1007 6
  if ( victim->position > POS_STUNNED )
  {
      if ( ch->fighting == NULL 
	   && !is_affected(victim,skill_lookup("orb of surprise")) )
    set_fighting( ch, victim );
  }
d1009 24
a1032 19
  if ( victim->position > POS_STUNNED )
  {
      if ( victim->fighting == NULL )
       {    
	if(is_affected(victim,skill_lookup("orb of surprise")) )
	{
	 send_to_char("Someone tried to sneak up on you, ",victim);
	 if(IS_SET(victim->display,DISP_COLOR))
	 send_to_char( GREEN"RUN!"NORMAL"\n\r", victim );
	 else
	 send_to_char( "RUN!\n\r", victim );

	 blow_orb(victim,skill_lookup("orb of surprise"));
	 surprised = TRUE;
	 stop_fighting(victim,FALSE);
	} else {
      if (victim->timer <= 4 || iOld)
	set_fighting( victim, ch );
	}
a1033 3
      if (victim->timer <= 4 && !surprised )
      victim->position = POS_FIGHTING;
  }
d1038 3
a1040 3
  if ( victim->master == ch )
      stop_follower( victim );
    }
d1054 4
a1057 4
  affect_strip( ch, gsn_invis );
  affect_strip( ch, gsn_mass_invis );
  REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
  act( "$n fades into existence.", ch, NULL, NULL, TO_ROOM );
d1090 2
a1091 2
    &&   victim->pcdata->condition[COND_DRUNK]  > 10 )
  dam = 9 * dam / 10;
d1094 1
a1094 1
  dam /= 2;
d1099 1
a1099 1
  dam -= dam / 4;
a1102 1

d1109 11
a1119 11
      return FALSE;
  if ( check_scales( ch, victim ) )
      return FALSE;
  if ( check_dodge( ch, victim ) )
      return FALSE;
  if ( check_kailindo( ch, victim ) )
      return FALSE;
  if ( check_shield_block(ch,victim))
      return FALSE;
  if ( check_mistform(ch,victim))
	return FALSE;
d1175 1
a1175 1
	      damage(ch,gch,dam,dt,dam_type,TRUE,iOld);
d1178 1
a1178 1
    }
d1189 1
a1189 1
  return FALSE;
d1213 2
a1214 1
    victim->hit -= dam;
d1216 1
d1218 4
a1221 3
    &&   victim->level >= LEVEL_IMMORTAL
    &&   victim->hit < 1 )
  victim->hit = 1;
d1268 1
a1268 1
  stop_fighting( victim, FALSE );
d1275 2
a1276 2
      if (!IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))
	group_gain( ch, victim );
d1278 5
a1282 4
  if ( !IS_NPC(victim) )
  {
      if (!IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH)) {        
        sprintf( log_buf, "%s killed by %s at %d",victim->name,
d1284 2
a1285 2
        log_string( log_buf );
      }
d1292 17
a1308 13
    if ( victim->exp > exp_per_level(victim,victim->pcdata->points) 
           * victim->level ) {
      if (IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH)) {
        gain_exp( victim, (exp_per_level(victim,victim->pcdata->points)
            * victim->level - victim->exp)/4 );
        raw_kill( victim, ch );            
        return TRUE;
      } else {
        gain_exp( victim, (exp_per_level(victim,victim->pcdata->points)
            * victim->level - victim->exp)*2/3 );
      }
    }
  }
d1310 40
a1349 30
  /* tell clan members other clan members died -Rusty */
  if(is_clan(ch) && is_clan(victim) && !IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))
  {
	if(victim != ch)
	{
	ch->killer_data[PC_KILLS] += 1 ;
	if(victim->trumps == 0 && ch->level - victim->level <= 8 
	   && !IS_SET(victim->wiznet,PLR_RUFFIAN)
	   && !IS_SET(victim->act,PLR_THIEF) 
	   && str_cmp(ch->pcdata->last_kill,victim->name) )
	{
	  ch->trumps += 1 ;
          sprintf( cdbuf, "%s trump++ killing %s at %d",ch->name,
                victim->name,ch->in_room->vnum );
          log_string( cdbuf );
	}
	free_string( ch->pcdata->last_kill );
	ch->pcdata->last_kill = str_dup( victim->name );
	victim->killer_data[PC_DEATHS] += 1 ;
	victim->trumps = UMAX(0,victim->trumps -1);
	if(IS_SET(victim->wiznet,PLR_RUFFIAN))
	  REMOVE_BIT(victim->wiznet,PLR_RUFFIAN);
	if(ch->trumps >= 3 && !IS_SET(ch->act,PLR_KILLER))
	 {
	  SET_BIT(ch->act,PLR_KILLER);
	  send_to_char("*** You are now a KILLER! ***\n\r",ch);
	  sprintf(wdbuf,"$N got a (KILLER) by murdering %s",victim->name);
	  wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
	 }
	}
d1351 1
a1351 4
      sprintf( cdbuf, "{W%s{x got toasted by {W%s{x\n\r",victim->name,ch->name);
      for ( d = descriptor_list; d != NULL; d = d->next )
      {
        CHAR_DATA *victm;
d1353 7
a1359 1
        victm = d->original ? d->original : d->character;
d1361 9
a1369 8
        if ( d->connected == CON_PLAYING &&
             d->character != ch &&
             is_clan(victm) )
        {
  send_to_char(cdbuf, victm);
        }
      }
     }
d1371 8
a1378 15
        sprintf( log_buf, "%s got toasted by %s at %s [room %d]",
            (IS_NPC(victim) ? victim->short_descr : victim->name),
            (IS_NPC(ch) ? ch->short_descr : ch->name),
            ch->in_room->name, ch->in_room->vnum);
 
        if (IS_NPC(victim))
            wiznet(log_buf,NULL,NULL,WIZ_MOBDEATHS,0,0);
        else
            wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);

        /* dump the flags */
        if (ch != victim && !IS_NPC(ch) && !is_same_clan(ch,victim)
            && !IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))
        {
            if (IS_SET(victim->act,PLR_THIEF))
d1380 14
a1393 12
            else
	    {
	     if(victim->trumps >=3 && IS_SET(victim->act,PLR_KILLER))
		{
		victim->trumps = 2;
                REMOVE_BIT(victim->act,PLR_KILLER);
		}
	     else
                REMOVE_BIT(victim->act,PLR_KILLER);
	    }
        }
  	raw_kill( victim,ch );
d1397 3
a1399 3
  if ( !IS_NPC(ch) && IS_NPC(victim) )
  {
      OBJ_DATA *coins;
d1401 1
a1401 1
      corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 
d1403 10
a1412 10
      if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
     corpse && corpse->contains) /* exists and not empty */
    do_get( ch, "all corpse" );

      if (IS_SET(ch->act,PLR_AUTOGOLD) &&
          corpse && corpse->contains  && /* exists and not empty */
    !IS_SET(ch->act,PLR_AUTOLOOT))
    if ((coins = get_obj_list(ch,"gcash",corpse->contains))
         != NULL)
              do_get(ch, "all.gcash corpse");
d1414 6
a1419 6
      if ( IS_SET(ch->act, PLR_AUTOSAC) )
              if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
    return TRUE;  /* leave if corpse has treasure */
        else
    do_sacrifice( ch, "corpse" );
  }
d1421 2
a1422 2
  return TRUE;
    }
d1425 1
a1425 1
  return TRUE;
d1432 6
a1437 6
  if ( number_range( 0, victim->wait ) == 0 )
  {
      if (!IS_SET(victim->act,PLR_NOAUTORECALL))
	do_recall( victim, "" );
      return TRUE;
  }
d1445 5
a1449 5
  if ( ( IS_SET(victim->act, ACT_WIMPY) && number_bits( 2 ) == 0
  &&   victim->hit < victim->max_hit / 5) 
  ||   ( IS_AFFECTED(victim, AFF_CHARM) && victim->master != NULL
  &&     victim->master->in_room != victim->in_room ) )
      do_flee( victim, "" );
d1453 4
a1456 4
    &&   victim->hit > 0
    &&   victim->hit <= victim->wimpy
    &&   victim->wait < PULSE_VIOLENCE / 2 )
  do_flee( victim, "" );
d1460 1
a1460 1
}
d2665 10
d2676 2
@


1.110
log
@Hard code 0 in for Highlanders to repop in Matook if they were nonclanned
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.109 1999/04/14 06:53:04 mud Exp $ */
d3534 7
d3676 7
d3793 7
d3982 7
d4132 7
d4270 7
d4344 7
d4432 7
d4809 7
@


1.109
log
@Opps passing an Integer to char_to_room
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.108 1999/04/14 06:28:22 mud Exp $ */
d2646 1
a2646 1
void highlander_die( CHAR_DATA *ch )
d2820 1
a2820 1
	 highlander_die( victim );
d2824 1
a2824 1
	    char_to_room(victim,get_room_index(clan_table["loner"].hall));
@


1.108
log
@Passing ch in to raw_kill for use by Highlander Check
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.107 1999/04/14 05:40:30 mud Exp $ */
d2824 1
a2824 1
	    char_to_room(victim,ROOM_VNUM_MATOOK);
@


1.107
log
@Add Highlander_die to start, and checks if highlander kills highlander
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.106 1999/04/13 06:14:22 mud Exp $ */
d78 1
a78 1
void  raw_kill  args( ( CHAR_DATA *victim ) );
d1294 1
a1294 1
        raw_kill( victim );            
d1377 1
a1377 1
  	raw_kill( victim );
d2774 1
a2774 1
void raw_kill( CHAR_DATA *victim )
d2797 1
a2797 1
  raw_kill(gch);
d5103 1
a5103 1
    raw_kill( victim );
@


1.106
log
@Add Highlander checks for allowing Nonclanners and Clanner Highlanders
to fight with each other.
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.105 1999/04/12 21:31:20 mud Exp $ */
d2646 2
d2649 3
d2815 21
a2835 3
    } else {
      make_corpse( victim );
      extract_char( victim, FALSE );
@


1.105
log
@Attempt to allow groups to kick
the ass of lower levels in pfights
when they would normally be out of range.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.104 1999/04/06 16:47:33 mud Exp $ */
d1704 1
a1704 1
      if (!is_clan(ch))
d1710 1
a1710 4
      if (IS_SET(victim->act,PLR_KILLER) || IS_SET(victim->act,PLR_THIEF))
    return FALSE;

      if (!is_clan(victim))
d1716 6
d1973 4
a1976 1
      if (!is_clan(ch))
d1982 2
d1986 1
a1986 3

      if (!is_clan(victim))
    return TRUE;
@


1.104
log
@Strip off affects when you really die.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.103 1999/04/05 02:49:33 mud Exp $ */
d1720 1
a1720 1
	  && victim->fighting != ch )
d1857 1
a1857 1
   && victim->fighting != ch )
@


1.103
log
@same as below
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.102 1999/04/05 02:48:39 mud Exp $ */
d2810 2
a2811 1
  victim->affected_by = victim->affected_by|race_table[victim->race].aff;
@


1.102
log
@Area attacks do not hit those in your group.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.101 1999/04/02 13:10:59 mud Exp $ */
d1973 1
a1973 1
	if( is_same_group(ch,victim))
@


1.101
log
@Favored weapons don't do triple backstabs
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.100 1999/03/30 15:23:45 mud Exp $ */
d1971 3
@


1.100
log
@Added a RUFFIAN flag timer so they eventually wear off.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.99 1999/03/29 18:33:28 mud Exp $ */
d274 2
a275 1
	 number_percent() < ( ch->pcdata->sac / 3 ) )
@


1.99
log
@Make kenders bash and throw proof
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.98 1999/03/26 19:57:39 mud Exp $ */
d2048 1
@


1.98
log
@Change to make multi_hit not initiate combat on those put into a
resting position.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.97 1999/03/26 04:48:42 mud Exp $ */
d3548 12
d3817 5
a3821 2
    if ( !IS_NPC(victim) && get_skill(victim,gsn_tumbling) > 0  &&
	(number_percent() + chance / 2) < get_skill(victim,gsn_tumbling)  )
@


1.97
log
@Re-Arrange the Act in Fumble for ROOM
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.96 1999/03/26 04:11:11 mud Exp $ */
d258 1
a258 1
    if (ch->position < POS_RESTING)
@


1.96
log
@Change 2nd act on Fumble to send TO_ROOM as well as change ch to victim
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.95 1999/03/25 14:37:24 mud Exp $ */
d657 2
a658 2
	 act("You fumble and drop your weapon!",ch,NULL,victim,TO_CHAR);
	 act("$n fumbles and drops $s weapon!",victim,NULL,victim,TO_ROOM);
@


1.95
log
@Couple more do_bleed changes.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.94 1999/03/25 14:30:38 mud Exp $ */
d658 1
a658 1
	 act("$N fumbles and drops $s weapon!",ch,NULL,victim,TO_CHAR);
@


1.94
log
@bleeding only fills you if it succeeds.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.93 1999/03/15 17:36:15 mud Exp $ */
a4843 1
/*** Temporary swap of conditional code ****
d4850 6
a4855 1
 *****/
@


1.93
log
@fixed 'dust storm' to actually wear off when you die
Made race based affects come back in raw_kill.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.92 1999/03/13 16:40:26 mud Exp $ */
a4852 3
/** The higher your level, the more bleeding you need to get full
    Seems backwards, but it allows for better bleed at 51 **/

a4855 10
    gain_condition(ch,COND_FULL,   15 - ( ch->level / 5 ) );
    gain_condition(ch,COND_HUNGER, 15 - ( ch->level / 5 ) );
    gain_condition(ch,COND_THIRST, 15 - ( ch->level / 5 ) );

    if ( ch->pcdata->condition[COND_FULL] > 46 )
    {
       send_to_char("Your lust for blood has been satiated.\n\r",ch);
       return;
    }

d4888 14
@


1.92
log
@updated is_safe_spell() to handle attacking rogues and giving them THIEF
flags in hall.  -Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.91 1999/03/04 20:28:55 mud Exp $ */
d2805 1
a2805 1
   /* victim->affected_by = 0;*/
d2822 1
a2822 1
/*    victim->affected_by = 0;*/
@


1.91
log
@sacred guardian yell only at fight start, like WIZNET transgress
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.90 1999/03/04 20:18:28 mud Exp $ */
d1885 8
a1892 1
	     return FALSE;
d1894 6
a1899 3
/*Youcannotbe attackedifyou're in yourownhall*/
	if(is_clan(ch) && ch->in_room->clan &&
	   ch->in_room->clan!=ch->clan)
@


1.90
log
@arg order reversal fix
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.89 1999/03/04 20:12:51 mud Exp $ */
d1992 2
a1993 1
	 && is_affected(victim,gsn_sacred_guardian) && is_clan( victim ) )
@


1.89
log
@Fixed 'hold person' to lower victim DEX instead of raise it.
Made 'sacred guardian' only yell when attacked by a PC.
Tried to fix the THIEF flag giving thing for caught infiltrators.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.88 1999/01/18 18:05:21 mud Exp $ */
d2016 1
a2016 1
       send_to_char(victim,"You got caught infiltrating, THIEF!\n\r");
@


1.88
log
@Fixed missing logging buffer and moved around some last_kill stuff
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.87 1999/01/18 17:38:46 mud Exp $ */
d1991 2
a1992 2
    if ( !IS_NPC(victim) && is_affected(victim,gsn_sacred_guardian) &&
	 is_clan( victim ) )
d2010 2
a2011 1
     if (ch->in_room->clan == ch->clan
d2013 12
a2024 2
     && victim->in_room->clan != victim->clan)
     return;
a2035 8
          if ((!IS_IMMORTAL(victim) && (victim->in_room->clan != victim->clan)
	  && victim->in_room->clan))
	  {
	  SET_BIT(victim->act, PLR_THIEF);
	  send_to_char("****You are now a THIEF****\n\r",victim);
	  }
	else
	{
a2041 1
	}
@


1.87
log
@Moved last_kill assignment after check, DUH!
Added a renicing setpriority() call to be a good community
member on the shared machine we run on.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.86 1999/01/18 17:00:13 mud Exp $ */
d1312 1
d1314 4
a1319 3
        sprintf( cdbuf, "%s trump++ killing %s at %d",ch->name,
                victim->name,ch->in_room->vnum );
        log_string( log_buf );
@


1.86
log
@pc_data to pcdata typo fix
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.85 1999/01/18 16:56:47 mud Exp $ */
a1307 2
	free_string( ch->pcdata->last_kill );
	ch->pcdata->last_kill = str_dup( victim->name );
d1313 2
@


1.85
log
@Added last_kill to pcdata to keep from getting a KILLER by spam
killing the same person.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.84 1999/01/11 18:59:23 mud Exp $ */
d1313 1
a1313 1
	   && str_cmp(ch->pc_data->last_kill,victim->name) )
@


1.84
log
@Made tail_slap() check for charm.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.83 1998/12/29 23:54:26 mud Exp $ */
d1308 2
d1312 2
a1313 1
	   && !IS_SET(victim->act,PLR_THIEF) )
@


1.83
log
@Made some mod's to rogues.
Rremoved check in do_where
changed is_safe_steal to is_safe in do_steal and do_slice
removed wait_state reduction for rogues in steal and slice
added check to give infiltrating rogues a THIEF flag if attacked in a foreign clan hall

Rob.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.82 1998/12/26 07:26:09 mud Exp $ */
d3612 6
d3635 1
a3635 1
        act("$n sneds you to the ground with a tail slap!",
@


1.82
log
@Fighxed shield block

Crc
cvs update .
S:
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.81 1998/12/23 16:51:33 mud Exp $ */
d339 2
a340 1
    if (ch->class == class_lookup("rogue"))
d2020 9
a2028 1
	  SET_BIT(ch->wiznet,PLR_RUFFIAN);
d2034 1
@


1.81
log
@Bunch of changes for rogues, including new skill and pther improvements
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.80 1998/12/15 22:17:22 mud Exp $ */
d2157 1
d2168 1
a2168 1
    if ( get_eq_char( victim, WEAR_SHIELD ) == NULL )
d2178 7
d2195 28
@


1.80
log
@Spies/Wrymslayers
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.79 1998/12/15 02:45:13 mud Exp $ */
d56 2
d338 4
d779 4
d1723 137
d2000 8
d2285 4
d2296 1
a2296 1
    if ( number_percent() < get_skill(ch,gsn_tumbling) )
d4221 1
d4307 6
d4315 1
a4315 1
    if ( number_percent( ) < get_skill(ch,gsn_backstab)
d4980 34
@


1.79
log
@Fixed barbairan rage somewhat
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.78 1998/12/12 01:20:54 mud Exp $ */
d1057 4
d2049 4
a2052 1
    
@


1.78
log
@Error checking
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.77 1998/12/09 00:42:59 mud Exp $ */
d118 1
a118 1
	    af.modifier = URANGE( 1, ch->pcdata->barbarian , 20 ); 
d121 1
a121 1
	    af.modifier = ch->pcdata->barbarian * 2;
@


1.77
log
@one last thing for ninjas
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.76 1998/12/09 00:33:20 mud Exp $ */
d755 1
a755 1
	   while ( --diceroll > 90 );
d946 2
a947 1
  bug( "Damage: %d: more than 1200 points!", dam );
d956 2
a957 1
        extract_obj(obj);
@


1.76
log
@Ninjas
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.75 1998/12/08 22:38:12 mud Exp $ */
d4201 2
a4202 1
  if ( number_percent() < get_skill(ch,gsn_tumbling) )
d4212 2
a4213 1
    if( (ch->class == 2 || HAS_KIT(ch,"acrobat") ) 
@


1.75
log
@Fixed some bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.74 1998/12/08 07:53:51 mud Exp $ */
d746 11
@


1.74
log
@Added improvement checks for barbarians
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.73 1998/12/08 01:54:12 mud Exp $ */
d307 3
a309 2
	if (!IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("warrior") &&
	ch->pcdata->old_class!=class_lookup("thief")))
d311 1
@


1.73
log
@barbarians are done
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.72 1998/12/06 07:40:42 mud Exp $ */
d104 1
a104 1
		number_percent() < ++ch->pcdata->barbarian )
d106 3
d125 1
d127 2
d959 2
d962 3
@


1.72
log
@STUFF!
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.71 1998/12/05 21:44:05 mud Exp $ */
d96 29
d951 3
a953 1

@


1.71
log
@Kits!
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.70 1998/12/05 10:10:50 mud Exp $ */
d3512 1
a3512 1
    if ( !IS_NPC(victim) &&
d3536 2
a3537 1
  if ( number_percent() + chance < get_skill(ch,gsn_tumbling) )
@


1.70
log
@Fixing bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.69 1998/11/29 22:26:21 mud Exp $ */
d32 3
d2073 3
d3431 1
a3431 1
        send_to_char("You're to exhausted.\n\r",ch);
a3466 1

d3512 13
d3536 7
d4145 8
d4155 2
a4156 3
      send_to_char( "You flee from combat!\n\r", ch );
  if( (ch->class == 2) 
      && (number_percent() < 3*(ch->level/2) ) )
@


1.69
log
@Neat crusader stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.68 1998/11/28 07:49:33 mud Exp $ */
d1982 3
a1984 9
    chance = victim->size * 2;

    if ( !IS_NPC(victim) )
       chance += ( ( ch->played + (int)  (current_time - ch->logon) ) / 3600 ) / 50;
    else
       chance += victim->level / 2;

    if ( chance > 50 ) 
	chance = (chance-50)/2 + 50;
@


1.68
log
@favored flag
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.67 1998/11/24 09:50:59 mud Exp $ */
d237 3
d245 4
@


1.67
log
@color/bladesingers
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.66 1998/11/24 09:39:44 mud Exp $ */
d205 1
d232 5
d2227 1
a2227 1
  corpse          = create_object(get_obj_index(OBJ_VNUM_CORPSE_NPC), 0);
d2246 1
a2246 1
  corpse    = create_object(get_obj_index(OBJ_VNUM_CORPSE_PC), 0);
d2417 1
a2417 1
  obj   = create_object( get_obj_index( vnum ), 0 );
@


1.66
log
@blademaster stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.65 1998/11/24 06:21:13 mud Exp $ */
d1159 2
a1160 2
  act( "$n is DEAD!!", victim, 0, 0, TO_ROOM );
  send_to_char( "You have been KILLED!!\n\r\n\r", victim );
d1165 1
a1165 6
     {
      if(IS_SET(ch->display,DISP_COLOR))
       send_to_char( "That really did "YELLOW"HURT!"NORMAL"\n\r", victim );
      else
       send_to_char( "That really did HURT!\n\r", victim );
     }
d1240 1
a1240 1
      sprintf( cdbuf, "%s got toasted by %s\n\r",victim->name,ch->name);
d1364 1
a1364 1
   
d1367 1
a1367 1
    else if ( dam <=   4 ) { vp1 = "clumsy";    vp2 = "gives";
d1369 1
a1369 1
    else if ( dam <=   8 ) { vp1 = "wobbly";    vp2 = "hits";
d1371 1
a1371 1
    else if ( dam <=  12 ) { vp1 = "lucky";    vp2 = "hits";
d1373 1
a1373 1
    else if ( dam <=   16 ) { vp1 = "amateur";  vp2 = "hits";
d1375 1
a1375 1
    else if ( dam <=   20 ) { vp1 = "amateur";    vp2 = "strikes";
d1377 1
a1377 1
    else if ( dam <=   26 ) { vp1 = "competent";    vp2 = "strikes";
d1379 1
a1379 1
    else if ( dam <=  32 ) { vp1 = "competent";    vp2 = "causes";
d1381 1
a1381 1
    else if ( dam <=  38 ) { vp1 = "skillful";    vp2 = "causes";
d1384 2
a1385 2
                  vp2 = "has a devastating effect on"; vp3 = "."        ;}
    else if (dam <=   50 ) { vp1 = "cunning";   vp2 = "tears into";
d1387 3
a1389 3
    else if ( dam <=  60 ) { vp1 = "strong";    vp2 = "causes";
                             vp3 = " to spurt blood!"         ;}
    else if ( dam <=  70 ) { vp1 = "calculated";
d1391 3
a1393 3
    else if ( dam <=  80 ) { vp1 = "calculated";        vp2 = "tears";
                             vp3 = " leaving a GAPING hole!"            ;}
    else if ( dam <=  90 ) { vp1 = "well aimed";    vp2 = "DISEMBOWELS";
d1395 3
a1397 3
    else if ( dam <= 100 ) { vp1 = "calm";    vp2 = "DISMEMBERS";
                             vp3 = "! Blood splatters!" ;}
    else if ( dam <= 115 ) { vp1 = "wicked";    vp2 = "ANNIHILATES";
d1399 1
a1399 1
    else if ( dam <= 130 ) { vp1 = "wicked";    vp2 = "OBLITERATES";
d1401 1
a1401 1
    else if ( dam <= 145 ) { vp1 = "barbaric";    vp2 = "MASSACRES";
d1403 1
a1403 1
    else if ( dam <= 160 ) { vp1 = "controlled";    vp2 = "ERADICATES";
d2606 1
a2606 1
  sprintf( buf, "You receive %d experience points.\n\r", xp );
@


1.65
log
@Final step for dual wield
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.64 1998/11/22 10:36:36 mud Exp $ */
d2979 2
a2980 1
         && !IS_OBJ_STAT(obj,ITEM_NODROP) )
@


1.64
log
@Added wizards
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.63 1998/11/22 08:04:43 mud Exp $ */
d276 8
d462 8
d471 5
a475 1
    if ( dt == TYPE_UNDEFINED )
d1895 3
d1947 3
d2055 3
d2977 14
d3005 1
d4643 4
@


1.63
log
@Infiltrate coded.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.62 1998/11/22 02:05:14 mud Exp $ */
d572 13
a584 1
  damage( ch, victim, 0, dt, dam_type, TRUE ,FALSE);
d2036 3
d2046 3
d2050 14
a2063 1
        return FALSE;
d3440 4
@


1.62
log
@Crusader spells
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.61 1998/11/21 07:14:35 mud Exp $ */
d1488 9
d1625 9
@


1.61
log
@Garou
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.60 1998/11/21 02:51:11 mud Exp $ */
d1716 16
d2098 3
@


1.60
log
@New spells for elementalists so tehy'll shut the hell up
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.59 1998/11/20 16:45:19 mud Exp $ */
d1840 4
d1847 1
d1874 4
d1992 4
@


1.59
log
@Removed gaining exp for killing those with withstand death on.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.58 1998/11/19 22:31:20 mud Exp $ */
d3971 1
@


1.58
log
@Fixed some color problems
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.57 1998/11/17 23:20:11 mud Exp $ */
d1157 2
a1158 1
  group_gain( ch, victim );
@


1.57
log
@Hopefully fixed the wholist and also added outcast changes
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.56 1998/11/15 09:29:34 mud Exp $ */
d1141 1
a1141 4
      if(IS_SET(ch->display,DISP_COLOR))
       send_to_char( "You sure are "RED"BLEEDING"NORMAL"!\n\r", victim );
      else
       send_to_char( "You sure are BLEEDING!\n\r", victim );
d1337 1
a1337 1
         if ( dam ==   0 ) { vp1 = "clumsy";    vp2 = "misses";
d1378 1
a1378 1
                vp2 = "does UNSPEAKABLE things to"; vp3 = "!"         ;}
d2741 1
a2741 1
   if ( dam ==   0 ) { vs = "miss"; vp = "misses";    }
d2766 2
a2767 2
    else                   { vs = "do UNSPEAKABLE things to";
           vp = "does UNSPEAKABLE things to";   }
d2866 1
a2866 1
    act( "$n DISARMS you and sends your weapon flying!", 
d3239 3
a3241 3
	  act("You attempt to whip $N with your tail, but miss.",ch,NULL,victim,TO_CHAR);
	  act("$n attempts to whip you with $s tail, but misses.",ch,NULL,victim,TO_VICT);
	  act("$n attempts to whip $N with $s tail, but misses.",ch,NULL,victim,TO_NOTVICT);
d4435 1
a4435 1
	send_to_char("Your teeth gnash together, missing their target.\n\r",ch);
@


1.56
log
@minor bug fix.  aeshteic thing
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.55 1998/11/14 07:15:51 mud Exp $ */
d49 1
a49 1

d2725 3
a2727 1
  
@


1.55
log
@Finished the damn reclass changed finally.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.54 1998/10/30 15:13:37 mud Exp $ */
d1829 1
a1829 1
	  chance -= victim->level/10;
d1866 1
a1866 1
	  chance -= victim->level/10;
d1971 1
a1971 1
      chance -= victim->level / 10;
@


1.54
log
@Made mana UMIN(20,victim->mana) in raw_kill() keeping those
who die from being able to run out naked and use powerful
spells on those that just killed them.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.53 1998/10/25 18:52:51 mud Exp $ */
d256 3
d3338 3
d3488 3
d3647 4
d3846 3
d4499 4
@


1.53
log
@more of the same
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.52 1998/10/25 18:38:46 mud Exp $ */
d2404 1
a2404 1
    victim->mana        = UMAX( 1, victim->mana );
@


1.52
log
@Removal of more hours shit
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.51 1998/10/25 03:27:56 mud Exp $ */
d3214 1
a3214 1
    chance += ( IS_NPC(ch) ? 0 : (get_age(ch) / 2 ) );
@


1.51
log
@Rot-death
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.50 1998/10/24 22:03:02 mud Exp $ */
d624 1
a624 1
          dam += get_age(ch) / 5;
@


1.50
log
@a
Fixed a little vorpal bug thig
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.49 1998/10/20 17:25:46 mud Exp $ */
d2698 1
a2698 2
       Removed and replaced with a simply XP reduction for
       specific races. */
d2701 1
a2701 1
  /* compute quarter-hours per level 
d2704 1
a2704 1
       / gch->level;  */
a2705 10
        if (gch->race == race_lookup("dragon") )
		xp = ( 3 * xp ) / 4; 

	if (gch->race == race_lookup("rockbiter") )
                xp = ( 2 * xp ) / 3;

	if (gch->race == race_lookup("faerie"))
		xp = ( 3 * xp ) / 2;

/**
d2710 1
a2710 1
 **/ 
@


1.49
log
@Fixed bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.48 1998/10/20 02:05:15 mud Exp $ */
d853 3
a855 2
      send_to_char("You really shouldn't cheat.\n\r",ch);
      if (obj != NULL)
d857 2
@


1.48
log
@fixed bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.47 1998/10/20 01:23:04 mud Exp $ */
d2898 6
d2908 1
a2908 3
    }

    ch->move -= apply_chi(ch,10);
d2910 2
@


1.47
log
@improvement for dae'tok
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.46 1998/10/20 00:42:31 mud Exp $ */
d240 1
a240 1
	check_improve(ch,gsn_second_attack,5,TRUE);
d258 1
a258 1
	check_improve(ch,gsn_dae_tok,8,TRUE);
d1072 1
a1072 1
	 number_percent() < get_skill(victim,gsn_communion) )
d2898 8
d2910 1
a2910 1
	check_improve(ch,gsn_dae_tok,2,FALSE); 
d2915 1
a2915 1
    check_improve(ch,gsn_dae_tok,4,TRUE);
@


1.46
log
@Races
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.45 1998/10/17 08:03:14 mud Exp $ */
d239 2
d242 1
d257 2
d260 1
d2902 1
d2906 2
a2907 1

@


1.45
log
@Yinn changed, faeirie changes
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.44 1998/10/13 00:02:59 mud Exp $ */
d238 2
d253 2
d257 1
a257 1
  chance = 0;;
d2882 33
@


1.44
log
@Garou berserk change
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.43 1998/10/11 21:12:26 mud Exp $ */
d478 1
a478 1
	skill -= ( skill / 5 );
d790 3
@


1.43
log
@Adjusted XP curve to ogo from levels 1 to 10.
At 11 they have off-whites, good enough.

-G
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.42 1998/10/11 00:13:33 mud Exp $ */
d551 4
d653 4
@


1.42
log
@Specializatio for warriros is in
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.41 1998/10/10 03:53:35 mud Exp $ */
d2664 2
a2665 2
    if (gch->level < 6)
      xp = 10 * xp / (gch->level + 4);
@


1.41
log
@Finished implementatino of altirin undead special
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.40 1998/10/09 19:54:04 mud Exp $ */
d206 1
d262 8
@


1.40
log
@Stop following and break charm for PC's
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.39 1998/10/08 22:19:56 mud Exp $ */
d1450 4
d1579 3
@


1.39
log
@Added mistform
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.38 1998/10/05 05:05:57 mud Exp $ */
d1693 5
a1697 1
     
@


1.38
log
@C

Dbite changed to 2 rounds
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.37 1998/10/05 04:13:34 mud Exp $ */
d56 1
d962 2
a963 1

d1875 36
a1910 1
   
d4316 1
a4316 1
	dam = number_range(ch->level/2, 4*ch->level/3);
d4331 1
a4331 1
	ch->mana += 2 * dam  / 5;
@


1.37
log
@C

Changes to flee code and energy drain.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.36 1998/10/04 02:41:00 mud Exp $ */
d4130 1
a4130 1
        WAIT_STATE( ch, 12 );
@


1.36
log
@C

Changed moevment cost for fleeing
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.35 1998/10/02 23:39:33 mud Exp $ */
d3825 1
a3825 1
    ch->move -= apply_chi( ch, (ch->level / 8) );
d3849 2
@


1.35
log
@Faeries adjusted, maladictions hurt more
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.34 1998/10/01 06:15:01 mud Exp $ */
d3825 1
a3825 1
    ch->move -= apply_chi( ch, (ch->level / 2) );
@


1.34
log
@C  Fixed a bug w/ dbite
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.33 1998/10/01 06:04:33 mud Exp $ */
d467 3
a469 4
    if ( wield != NULL && ( ch->race == race_lookup("faerie") ||
			    ch->race == race_lookup("rockbiter") ) )
	skill -= ( skill / 10 ); 

@


1.33
log
@Added dbite
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.32 1998/10/01 05:32:07 mud Exp $ */
d4081 1
a4081 1
        send_to_char("Huh?\n\r", ch );
@


1.32
log
@Changes to sleep and experience
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.31 1998/09/30 05:27:06 mud Exp $ */
d4067 76
@


1.31
log
@C

Mobs can start using tail attacks agtainst PC's
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.30 1998/09/30 05:12:45 mud Exp $ */
d2457 1
a2457 1
    int time_per_level;
d2617 3
a2619 1
    /* reduce for playing time */
d2622 1
a2622 1
  /* compute quarter-hours per level */
d2625 1
a2625 1
       / gch->level;
d2628 1
a2628 1
		time_per_level /= 3;
d2631 1
a2631 1
                time_per_level /= 4;
d2634 1
a2634 1
		time_per_level *= 2;
d2636 1
d2638 1
a2638 1
  if (gch->level < 15)  /* make it a curve */
d2641 2
a2642 1
    }
d2651 1
a2651 1
    /* ADjust for WIS */
d2653 2
a2654 1
   
d3095 2
a3096 1
    chance = ch->level + ( ch->size * 5 ) + (get_age(ch) /2);
@


1.30
log
@Fixed it so NPC's with 'tail' attack will use dragon tail slap
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.29 1998/09/25 00:37:29 mud Exp $ */
d33 1
d373 1
a373 1
         do_tail(ch,"");
a3035 5
void do_tail( CHAR_DATA *ch, char *argument )
{
    do_tail_slap( ch, argument );
    return;
}
@


1.29
log
@Changed druid weapon skills.
---------------------------------------------------------------------
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.28 1998/09/21 04:16:48 mud Exp $ */
d372 1
a372 1
      /* do_tail(ch,"") */ ;
d3035 5
d3266 1
a3266 2
  damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_bash,
      DAM_BASH,FALSE,FALSE);
d3822 3
@


1.28
log
@*** empty log message ***
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.27 1998/09/21 04:14:16 mud Exp $ */
d469 5
@


1.27
log
@Asdjusted weapon skills for faeries and rockbiters
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.26 1998/09/20 07:46:17 mud Exp $ */
d467 1
a467 1
			    ch->race == race_lookup("rockbiter") )
@


1.26
log
@Fixed faerie mana gains a bit.  Tested them by advancing one to 51 with a
re-imb and it had 200 hp :)  So, gave them double mana.  Added dodge size
stuff.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.25 1998/09/20 03:46:47 mud Exp $ */
d465 4
@


1.25
log
@Added faeries, changed race display in login
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.24 1998/09/20 03:06:54 mud Exp $ */
d1885 4
@


1.24
log
@Game now uses Wisdom when computing XP/mob.  Wise chars learn more from
their work, etc.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.23 1998/08/30 03:33:35 mud Exp $ */
d1880 3
d2617 3
d2635 1
a2635 1
    
@


1.23
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.22 1998/08/21 14:21:09 mud Exp $ */
d2627 3
@


1.22
log
@I dunno
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.21 1998/08/20 21:05:31 mud Exp $ */
d855 1
a855 1
	 if(IS_SET(victim->act,PLR_COLOR))
d1087 1
a1087 1
      if(IS_SET(ch->act,PLR_COLOR))
d1094 1
a1094 1
      if(IS_SET(ch->act,PLR_COLOR))
d1402 1
a1402 1
  if(!(IS_SET(ch->comm,COMM_BRIEF) && dam == 0))
d1408 1
a1408 1
  if(!(IS_SET(ch->comm,COMM_BRIEF) && dam == 0))
d1410 1
a1410 1
  if(!(IS_SET(victim->comm,COMM_BRIEF) && dam == 0))
d1787 1
a1787 1
    if(!IS_SET(victim->comm,COMM_BRIEF))
d1789 1
a1789 1
    if(!IS_SET(ch->comm,COMM_BRIEF))
d1816 1
a1816 1
    if(!IS_SET(victim->comm,COMM_BRIEF))
d1819 1
a1819 1
    if(!IS_SET(ch->comm,COMM_BRIEF))
d1852 1
a1852 1
    if ( !IS_SET(ch->comm,COMM_BRIEF) )
d1855 1
a1855 1
    if ( !IS_SET(victim->comm,COMM_BRIEF) )
d1889 1
a1889 1
    if(!IS_SET(victim->comm,COMM_BRIEF))
d1891 1
a1891 1
    if(!IS_SET(ch->comm,COMM_BRIEF))
d4029 1
a4029 1
  if(!IS_SET(victim->comm,COMM_BRIEF))
@


1.21
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.20 1998/08/17 20:05:00 mud Exp $ */
d1148 1
a1148 1
	if(victim->pcdata->trumps == 0 && ch->level - victim->level <= 8 
d1151 1
a1151 1
	  ch->pcdata->trumps += 1 ;
d1156 1
a1156 1
	victim->pcdata->trumps = UMAX(0,victim->pcdata->trumps -1);
d1159 1
a1159 1
	if(ch->pcdata->trumps >= 3 && !IS_SET(ch->act,PLR_KILLER))
d1202 1
a1202 1
	     if(victim->pcdata->trumps >=3 && IS_SET(victim->act,PLR_KILLER))
d1204 1
a1204 1
		victim->pcdata->trumps = 2;
d1540 1
a1540 1
      if (ch->level > victim->level + (victim->pcdata->trumps > 0 ? 10 : 8) 
d1641 1
a1641 1
      if (ch->level > victim->level + (victim->pcdata->trumps > 0 ? 10 : 8) )
d1670 1
a1670 1
	if(!IS_SET(ch->wiznet,PLR_RUFFIAN) && victim->pcdata->trumps == 0
d1735 1
a1735 1
   if(ch->pcdata->trumps >= 3)
d2295 1
a2295 1
      char_to_room(victim,get_room_index(clan_table[victim->pcdata->clan].hall));
@


1.20
log
@Elementalists and some of their spells added.
Material table begun.

-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.19 1998/08/13 21:42:35 mud Exp $ */
d750 1
a750 1
	 act("You are consumed in holy wrath by $p.",victim,wield,NULL,TO_ROOM);
d881 1
d1028 18
d1047 1
d1148 1
a1148 1
	if(victim->trumps == 0 && ch->level - victim->level <= 8 
d1151 1
a1151 1
	  ch->trumps += 1 ;
d1156 1
a1156 1
	victim->trumps = UMAX(0,victim->trumps -1);
d1159 1
a1159 1
	if(ch->trumps >= 3 && !IS_SET(ch->act,PLR_KILLER))
d1202 1
a1202 1
	     if(victim->trumps >=3 && IS_SET(victim->act,PLR_KILLER))
d1204 1
a1204 1
		victim->trumps = 2;
d1540 1
a1540 1
      if (ch->level > victim->level + (victim->trumps > 0 ? 10 : 8) 
d1641 1
a1641 1
      if (ch->level > victim->level + (victim->trumps > 0 ? 10 : 8) )
d1670 1
a1670 1
	if(!IS_SET(ch->wiznet,PLR_RUFFIAN) && victim->trumps == 0
d1735 1
a1735 1
   if(ch->trumps >= 3)
d2295 1
a2295 1
      char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
d2799 2
a2800 1
    ||  is_affected(ch,skill_lookup("frenzy")))
d2808 1
a2808 1
  send_to_char("You're feeling to mellow to berserk.\n\r",ch);
@


1.19
log
@Logging THIEF flags too.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.18 1998/08/13 21:33:17 mud Exp $ */
d589 2
a590 1
	  ch->race == race_lookup("rockbiter") )
d4242 4
a4245 1
 
@


1.18
log
@added logging for ruffian flags and kill counter++
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.17 1998/08/13 16:22:24 mud Exp $ */
d1655 1
a1655 1
                victim->name),ch->in_room->vnum );
@


1.17
log
@Combined damage() and damage_old() into damage() adding
a boll at the end 'iOld' for "is old" and appropriate if()'s
for the differences.  Added FALSE bool to damage() calls in fight.c
and replaced calls with calls to bramage() in other locations.
Made damage_old() call damage() with TRUE for iOld instead of
duplicating mass amounts of code.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.16 1998/08/13 05:27:59 mud Exp $ */
d781 1
a781 1
  damage(ch,victim,dam,dt,dam_type,show,FALSE);
a1123 1
          sprintf( cdbuf, "%s got toasted by %s\n\r",victim->name,ch->name);
d1131 3
d1147 1
d1404 1
a1404 1
damage(ch,victim,dam,dt,dam_type,show,TRUE);
d1632 1
a1632 1
    char buf[MAX_STRING_LENGTH];
d1654 3
@


1.16
log
@* Another bug fix with bleed
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.15 1998/08/13 05:24:09 mud Exp $ */
d536 1
a536 1
  damage( ch, victim, 0, dt, dam_type, TRUE );
d569 1
a569 1
		damage( ch, victim, victim->hit/2, dt, dam_type, TRUE );
d574 1
a574 1
		damage( ch, ch, ch->hit/2, dt, dam_type, TRUE );
d643 1
a643 1
    result = damage( ch, victim, dam, dt, dam_type, TRUE );
d708 1
a708 1
      damage(ch,victim,dam,0,DAM_FIRE,FALSE);
d718 1
a718 1
      damage(ch,victim,dam,0,DAM_COLD,FALSE);
d727 1
a727 1
      damage(ch,victim,dam,0,DAM_LIGHTNING,FALSE);
d737 1
a737 1
	 damage(ch,ch,dam,0,DAM_HOLY,FALSE);
d750 1
a750 1
	 damage(ch,victim,dam,0,DAM_HOLY,FALSE);
d779 4
d788 1
a788 1
      bool show) 
d863 1
a863 1
      if (victim->timer <= 4)
d879 1
a879 1
     * Traps?  no steenen traps!
d904 1
a904 1
    if ( IS_SET(victim->act,PLR_VAMP) )
d912 1
a912 1
    if ( IS_SET(victim->act,PLR_WERE) )
d927 3
a929 2
    if ( dam > 1 && ((IS_AFFECTED(victim, AFF_PROTECT_EVIL) && IS_EVIL(ch) )
    ||         (IS_AFFECTED(victim, AFF_PROTECT_GOOD) && IS_GOOD(ch) )))
a931 3
    if ( dam > 1 && ( is_affected(victim,gsn_protect_neutral) && IS_NEUTRAL(ch)))
   	dam -= dam / 4;

d963 1
a963 1
      dam += dam/3;
d986 1
a986 1
       dam /= UMIN(count,4);
d1006 1
a1006 1
	      damage(ch,gch,dam,dt,dam_type,TRUE);
d1012 6
a1017 1
      dam_message_new( ch, victim, dam, dt, immune );
d1401 1
a1401 414

    OBJ_DATA *corpse;
    bool immune,surprised=FALSE;
    char cdbuf[MAX_STRING_LENGTH];
    char wdbuf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    CHAR_DATA *gch,*gch_next;

    if ( victim->position == POS_DEAD )
  return FALSE;

    /*
     * Stop up any residual loopholes.
     */

    if ( dam > 1200 && dt >= TYPE_HIT)
    {
        bug( "Damage: %d: more than 1200 points!", dam );
        dam = 1200;
        if (!IS_IMMORTAL(ch))
        {
            OBJ_DATA *obj;
            obj = get_eq_char( ch, WEAR_WIELD );
            send_to_char("You really shouldn't cheat.\n\r",ch);
            if (obj != NULL)
                extract_obj(obj);
        }
 
    }

    
    /* damage reduction */
    if ( dam > 55)
  dam = (dam - 55)/2 + 55;
    if ( dam > 120)
  dam = (dam - 120)/2 + 120; 
	if(IS_SET(victim->act,PLR_OLD)) dam = (3 * dam)/2;


   
    if ( victim != ch )
    {
  /*
   * Certain attacks are forbidden.
   * Most other attacks are returned.
   */
  if ( is_safe( ch, victim ) )
      return FALSE;
  check_killer( ch, victim );

  if ( victim->position > POS_STUNNED )
  {
      if ( ch->fighting == NULL
           && !is_affected(victim,skill_lookup("orb of surprise")) )
    set_fighting( ch, victim );
  }

  if ( victim->position > POS_STUNNED )
  {
      if ( victim->fighting == NULL )
       {
        if(is_affected(victim,skill_lookup("orb of surprise")) )
        {
         send_to_char("Someone tried to sneak up on you, ",victim);         
         if(IS_SET(victim->act,PLR_COLOR))
         send_to_char( GREEN"RUN!"NORMAL"\n\r", victim );                    
         else
         send_to_char( "RUN!\n\r", victim );                 

         blow_orb(victim,skill_lookup("orb of surprise"));
	 surprised = TRUE;
	 stop_fighting(victim,FALSE);
        } else {
        set_fighting( victim, ch );
        }
       }
      if (victim->timer <= 4 && !surprised)
        victim->position = POS_FIGHTING;
  }

  /*
   * More charm stuff.
   */
  if ( victim->master == ch )
      stop_follower( victim );
    }

    /*
     * Inviso attacks ... not.
     */
    if ( IS_AFFECTED(ch, AFF_INVISIBLE) )
    {
  affect_strip( ch, gsn_invis );
  affect_strip( ch, gsn_mass_invis );
  REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
  act( "$n fades into existence.", ch, NULL, NULL, TO_ROOM );
    }

    /*
     * No hiding.
     */
    REMOVE_BIT( ch->affected_by, AFF_HIDE );

    /*
     * Damage modifiers.
     */

    if ( dam > 1 && !IS_NPC(victim)
    &&   victim->pcdata->condition[COND_DRUNK]  > 10 )
        dam = 9 * dam / 10;
 
    if ( dam > 1 && IS_AFFECTED(victim, AFF_SANCTUARY) )
        dam /= 2;
 
    if ( dam > 1 && ((IS_AFFECTED(victim, AFF_PROTECT_EVIL) && IS_EVIL(ch) )
    ||               (IS_AFFECTED(victim, AFF_PROTECT_GOOD) && IS_GOOD(ch) )))
        dam -= dam / 4;

    immune = FALSE;


    /*
     * Check for parry, and dodge.
     */
    if ( dt >= TYPE_HIT && ch != victim)
    {
        if ( check_parry( ch, victim ) )
      return FALSE;
  if ( check_scales(ch, victim ) )
      return FALSE;
  if ( check_dodge( ch, victim ) )
      return FALSE;
  if ( check_shield_block(ch,victim))
      return FALSE;

    }

    switch(check_immune(victim,dam_type))
    {
  case(IS_IMMUNE):
      immune = TRUE;
      dam = 0;
      break;
  case(IS_RESISTANT): 
      dam -= dam/3;
      break;
  case(IS_VULNERABLE):
      dam += dam/2;
      break;
    }


    /* Wound transfer spell */
    if ( is_affected(victim,gsn_wound_transfer)
	 && ch != victim)
    {
       int count = 1;

       for ( gch = victim->in_room->people ;
             gch != NULL ;
             gch = gch_next )
       {
	   gch_next = gch->next_in_room;

           if ( gch == ch || gch == victim )
                continue;

           if ( is_same_group( gch, victim ) )
              ++count;
       }

       dam /= UMIN(count,3);

       for ( gch = victim->in_room->people ;
             gch != NULL ;
             gch = gch_next )
       {
	   gch_next = gch->next_in_room;

           if ( gch == ch || gch== victim )
             continue;

           if ( is_same_group( gch, victim ) )
           {
             /* Extra check to avoid infinate recursion */
              if ( is_affected(gch,gsn_wound_transfer) )
              {
                 bug("Wound transfer: gch is_affected()",0);
                 continue;
              }
              else
              damage_old(ch,gch,dam,dt,dam_type,TRUE);
           }
       }
    }


    if (show)
      dam_message( ch, victim, dam, dt, immune );

    if (dam == 0)
  return FALSE;

    /*
     * Hurt the victim.
     * Inform the victim of his new state.
     */
    victim->hit -= dam;
    if ( !IS_NPC(victim)
    &&   victim->level >= LEVEL_IMMORTAL
    &&   victim->hit < 1 )
  victim->hit = 1;
    update_pos( victim );

    switch( victim->position )
    {
    case POS_MORTAL:
  act( "$n is mortally wounded, and will die soon, if not aided.",
      victim, NULL, NULL, TO_ROOM );
  send_to_char( 
      "You are mortally wounded, and will die soon, if not aided.\n\r",
      victim );
  break;

    case POS_INCAP:
  act( "$n is incapacitated and will slowly die, if not aided.",
      victim, NULL, NULL, TO_ROOM );
  send_to_char(
      "You are incapacitated and will slowly die, if not aided.\n\r",
      victim );
  break;

    case POS_STUNNED:
  act( "$n is stunned, but will probably recover.",
      victim, NULL, NULL, TO_ROOM );
  send_to_char("You are stunned, but will probably recover.\n\r",
      victim );
  break;

    case POS_DEAD:
  act( "$n is DEAD!!", victim, 0, 0, TO_ROOM );
  send_to_char( "You have been KILLED!!\n\r\n\r", victim );
  break;

    default:
  if ( dam > victim->max_hit / 4 )
     {
      if(IS_SET(ch->act,PLR_COLOR))
       send_to_char( "That really did "YELLOW"HURT!"NORMAL"\n\r", victim );
      else
       send_to_char( "That really did HURT!\n\r", victim );
     }
  if ( victim->hit < victim->max_hit / 4 )
     {
      if(IS_SET(ch->act,PLR_COLOR))
       send_to_char( "You sure are "RED"BLEEDING"NORMAL"!\n\r", victim );
      else
       send_to_char( "You sure are BLEEDING!\n\r", victim );
     }
  break;
    }

    /*
     * Sleep spells and extremely wounded folks.
     */
    if ( !IS_AWAKE(victim) )
  stop_fighting( victim, FALSE );

    /*
     * Payoff for killing things.
     */
    if ( victim->position == POS_DEAD )
    {
  group_gain( ch, victim );

  if ( !IS_NPC(victim) )
  {
      sprintf( log_buf, "%s killed by %s at %d",
    victim->name,
    (IS_NPC(ch) ? ch->short_descr : ch->name),
    victim->in_room->vnum );
      log_string( log_buf );

      /*
       * Dying penalty:
       * 2/3 way back to previous level.
       */
      if ( victim->exp > exp_per_level(victim,victim->pcdata->points) 
             * victim->level )
  gain_exp( victim, (2 * (exp_per_level(victim,victim->pcdata->points)
               * victim->level - victim->exp)/3) + 50 );
  }

  /* tell clan members other clan members died -Rusty */
  if(is_clan(ch) && is_clan(victim) && !IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))
  {
          sprintf( cdbuf, "%s got toasted by %s\n\r",victim->name,ch->name);
	if(victim != ch)
	{
        victim->killer_data[PC_DEATHS] += 1 ;
	victim->trumps = UMAX(0,victim->trumps -1);
	ch->killer_data[PC_KILLS] += 1 ;
	if(victim->trumps == 0 && ch->level - victim->level <= 8 
	   && !IS_SET(victim->wiznet,PLR_RUFFIAN) 
	   && !IS_SET(victim->act,PLR_THIEF) )
	ch->trumps += 1 ;
	if(IS_SET(victim->wiznet,PLR_RUFFIAN))
	  REMOVE_BIT(victim->wiznet,PLR_RUFFIAN);
	if(ch->trumps >= 3 && !IS_SET(ch->act,PLR_KILLER))
	 {
	  SET_BIT(ch->act,PLR_KILLER);
	  send_to_char("*** You are now a KILLER! ***\n\r",ch);
	  sprintf(wdbuf,"$N got a (KILLER) by murdering %s",victim->name);
	  wiznet(wdbuf,ch,NULL,WIZ_FLAGS,0,0);
	 }
	}

      for ( d = descriptor_list; d != NULL; d = d->next )
      {
        CHAR_DATA *victm;

        victm = d->original ? d->original : d->character;

        if ( d->connected == CON_PLAYING &&
             d->character != ch &&
             is_clan(victm) )
        {
  send_to_char(cdbuf, victm);
        }
      }
     }


        sprintf( log_buf, "%s got toasted by %s at %s [room %d]",
            (IS_NPC(victim) ? victim->short_descr : victim->name),
            (IS_NPC(ch) ? ch->short_descr : ch->name),
            ch->in_room->name, ch->in_room->vnum);
 
        if (IS_NPC(victim))
            wiznet(log_buf,NULL,NULL,WIZ_MOBDEATHS,0,0);
        else
            wiznet(log_buf,NULL,NULL,WIZ_DEATHS,0,0);

  /* dump the flags */
  if (ch != victim && !IS_NPC(ch) && !is_same_clan(ch,victim)
      && !IS_SET(victim->affected_by,AFF_WITHSTAND_DEATH))            
  {
      if (IS_SET(victim->act,PLR_THIEF))
          REMOVE_BIT(victim->act,PLR_THIEF);
      else
          REMOVE_BIT(victim->act,PLR_KILLER);
  }  
  raw_kill( victim );
        /* RT new auto commands */

  if ( !IS_NPC(ch) && IS_NPC(victim) )
  {
      corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 

      if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
     corpse && corpse->contains) /* exists and not empty */
    do_get( ch, "all corpse" );

      if (IS_SET(ch->act,PLR_AUTOGOLD) &&
          corpse && corpse->contains  && /* exists and not empty */
    !IS_SET(ch->act,PLR_AUTOLOOT))
        do_get(ch, "gold corpse");
            
      if ( IS_SET(ch->act, PLR_AUTOSAC) )
              if ( IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
    return TRUE;  /* leave if corpse has treasure */
        else
    do_sacrifice( ch, "corpse" );
  }

  return TRUE;
    }

    if ( victim == ch )
  return TRUE;

    /*
     * Take care of link dead people.
     */
    if ( !IS_NPC(victim) && victim->desc == NULL )
    {
  if ( number_range( 0, victim->wait ) == 0 )
  {
    if (!IS_SET(victim->act,PLR_NOAUTORECALL))
      do_recall( victim, "" );
      return TRUE;
  }
    }

    /*
     * Wimp out?
     */
    if ( IS_NPC(victim) && dam > 0 && victim->wait < PULSE_VIOLENCE / 2)
    {
  if ( ( IS_SET(victim->act, ACT_WIMPY) && number_bits( 2 ) == 0
  &&   victim->hit < victim->max_hit / 5) 
  ||   ( IS_AFFECTED(victim, AFF_CHARM) && victim->master != NULL
  &&     victim->master->in_room != victim->in_room ) )
      do_flee( victim, "" );
    }

    if ( !IS_NPC(victim)
    &&   victim->hit > 0
    &&   victim->hit <= victim->wimpy
    &&   victim->wait < PULSE_VIOLENCE / 2 )
  do_flee( victim, "" );

    tail_chain( );
    return TRUE;
d2965 1
a2965 1
      DAM_BASH,FALSE);
d2970 1
a2970 1
  damage(ch,victim,0,gsn_throw,DAM_BASH,FALSE);
d3054 1
a3054 1
	damage(ch,victim,dice(ch->level /10+1,8)  ,gsn_bash,DAM_BASH,FALSE);
d3065 1
a3065 1
	  damage(ch,victim,0,gsn_bash,DAM_BASH,FALSE);
d3212 1
a3212 1
      DAM_BASH,FALSE);
d3217 1
a3217 1
  damage(ch,victim,0,gsn_bash,DAM_BASH,FALSE);
d3353 1
a3353 1
        damage(ch,victim,number_range(2,5),gsn_dirt,DAM_NONE,FALSE);
d3370 1
a3370 1
  damage(ch,victim,0,gsn_dirt,DAM_NONE,TRUE);
d3494 1
a3494 1
      DAM_BASH,TRUE);
d3498 1
a3498 1
  damage(ch,victim,0,gsn_trip,DAM_BASH,TRUE);
d3746 1
a3746 1
  damage( ch, victim, 0, gsn_backstab,DAM_NONE,TRUE);
d3939 1
a3939 1
  damage(ch,victim,number_range(2,(3*ch->level)/2), gsn_kick,DAM_BASH,TRUE);
d3944 1
a3944 1
  damage( ch, victim, 0, gsn_kick,DAM_BASH,TRUE);
d3993 1
a3993 1
  damage(ch,victim,number_range(10,3*ch->level),gsn_insanity,DAM_BASH,TRUE);
d4003 1
a4003 1
  damage(ch,ch,number_range(10,3*ch->level),gsn_insanity,DAM_BASH,TRUE);
d4042 1
a4042 1
  damage(ch,victim,number_range( ch->level/4, ch->level ), gsn_bite,DAM_PIERCE,TRUE);
d4070 1
a4070 1
	damage( ch, victim, 0, gsn_bite,DAM_PIERCE,TRUE);
d4157 1
a4157 1
	damage( ch, victim, dam, gsn_bleed, DAM_PIERCE, TRUE);
d4166 1
a4166 1
 	damage(ch,victim,0,gsn_bleed,DAM_PIERCE,TRUE);
@


1.15
log
@* Various bug fixes, mostly
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.14 1998/08/12 08:20:17 mud Exp $ */
d4572 2
a4573 1
	check_improve(ch,gsn_bite,FALSE,1);
@


1.14
log
@* Finished traps
* Rockbiters added
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.13 1998/08/10 21:32:52 mud Exp $ */
d3460 1
a3460 1
	damage(ch,victim,dice(5,10),gsn_bash,DAM_BASH,FALSE);
d4523 3
d4549 1
a4549 1
	dam = number_range(ch->level/2, 5*ch->level/3);
d4564 1
a4564 1
	ch->mana += dam * 3/4;
@


1.13
log
@* tail slap, and some bug fixes for it
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.12 1998/08/10 19:41:22 mud Exp $ */
d587 5
d2223 5
d2987 5
a2991 2
        if (gch->race == race_lookup("dragon"))
                time_per_level /= 3;
d4119 1
a4119 1
    if ( victim->fighting != NULL && victim->hit < victim->max_hit / 2)
d4502 6
@


1.12
log
@* Starter code for 'feign death'
* Protection neutral added
* Fixed bug with vampires
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.11 1998/08/10 05:32:15 mud Exp $ */
d3378 85
@


1.11
log
@* Added wound transfer spell
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.10 1998/08/07 20:19:57 mud Exp $ */
d53 1
d922 3
d935 2
d961 2
a962 1
    if ( is_affected(victim,gsn_wound_transfer) )
d975 1
a975 1
	   if ( gch->leader == victim )
d979 1
a979 1
       dam /= count;
d983 1
a983 1
	     gch = gch->next_in_room )
d985 2
d990 1
a990 1
	   if ( gch->leader == victim )
d1517 2
d1542 2
a1543 1
    if ( is_affected(victim,gsn_wound_transfer) )
d1556 1
a1556 1
           if ( gch->leader == victim )
d1560 1
a1560 1
       dam /= count;
d1564 1
a1564 1
             gch = gch->next_in_room )
d1566 2
d1571 1
a1571 1
           if ( gch->leader == victim )
d1580 1
a1580 1
              damage(ch,gch,dam,dt,dam_type,TRUE);
d2202 34
d2643 1
a2643 1
  send_to_char(buf,victim);
d4457 1
a4457 1
	ch->mana += dam * 1/2;
@


1.10
log
@Room affects stuff for traps.
Bleed/vampire changes.
swim/scan start at 50% and 50%up for free for existing characters.
moved trap to after trip in interp list for grandfathered use
- Both of Us
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.9 1998/08/06 04:24:52 mud Exp $ */
d786 1
d954 41
d1386 1
d1529 43
d2578 2
d2584 19
a2602 1
    
@


1.9
log
@Tons of stuff, mostly additions of holy flag for weapons.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.8 1998/08/05 06:31:15 mud Exp $ */
d868 6
d3301 4
a3304 1
	WAIT_STATE(ch,skill_table[gsn_bash].beats/2);
d3340 4
a3343 1
        WAIT_STATE(ch,skill_table[gsn_bash].beats);
d3360 4
a3363 1
  WAIT_STATE(ch,skill_table[gsn_bash].beats);
d3380 4
a3383 1
  WAIT_STATE(ch,skill_table[gsn_bash].beats * 3/2); 
d3806 1
d3810 3
d3886 1
a3886 1
	WAIT_STATE( ch, skill_table[gsn_backstab].beats/2);
d3890 1
a3890 1
    WAIT_STATE( ch, skill_table[gsn_backstab].beats );
@


1.8
log
@* Fixed wiznet notes
* Added feast/famine spells
* Changed nosferatu bleed/hunger stuff
* Upped damage on bleed
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.7 1998/08/04 20:21:52 mud Exp $ */
d723 28
a750 1
 
d2039 1
a2039 1
	  chance -= victim->level/5;
d2076 1
a2076 1
	  chance -= victim->level/5;
d2107 1
a2107 2
      chance -= victim->level/5;

d4212 1
d4214 12
a4225 1
    if ( ( victim = ch->fighting ) == NULL )
d4227 1
a4227 1
	send_to_char( "You aren't fighting anyone.\n\r", ch );
d4266 1
a4266 1
	dam = number_range(ch->level/2, 3*ch->level/2);
d4273 1
a4273 1
	  dam -= dam/3;
d4276 1
a4276 1
	  dam += dam/3;
@


1.7
log
@'swim' and 'scan' will start at 50% now.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.6 1998/08/04 19:24:14 mud Exp $ */
d4207 2
d4228 1
a4228 1
	dam = number_range(ch->level/5, ch->level);
d4243 1
a4243 1
	ch->mana += dam*2/5;
@


1.6
log
@s screen doesn't handle VI well)

Changed bleed to depend upon condition of fullness/hunger.
We're just going to test this out and see how well it works.
If it's not working out, we'll go back to the old way.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.5 1998/08/02 14:30:34 mud Exp $ */
d4207 1
a4207 1
    if ( ch->pcdata->condition[COND_FULL] > 50 )
@


1.5
log
@Druid dodge, parry and shield block reductions
removal of nofollow cancelling charm and spell_charm_person() tweeked
to accomodate PC charmings.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.4 1998/08/01 13:54:01 mud Exp $ */
d4193 1
d4200 12
@


1.4
log
@same thing, *sigh*
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.3 1998/08/01 13:52:39 mud Exp $ */
d2011 2
d2048 2
a2049 1

d2079 3
@


1.3
log
@No flag for killing a THIEF.
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.2 1998/08/01 13:46:06 mud Exp $ */
d1915 2
a1916 1
	   && !IS_SET(victim->wiznet,PLR_RUFFIAN) )
@


1.2
log
@Added RUFFIAN flag logic
@
text
@d18 1
a18 1
/* @@(#)$Id: fight.c,v 1.1 1998/06/16 17:49:22 mud Exp $ */
d1033 2
a1034 1
	   && !IS_SET(victim->wiznet,PLR_RUFFIAN) )
d1559 2
a1560 1
	   && !IS_SET(victim->wiznet,PLR_RUFFIAN) )
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d1032 3
a1034 2
	if(victim->trumps == 0 && ch->level - victim->level <= 8 )
	ch->trumps += 1 ;
d1037 2
d1557 2
a1558 1
	if(victim->trumps == 0)
d1560 2
d1912 7
@
