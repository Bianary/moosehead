head	1.110;
access;
symbols;
locks; strict;
comment	@ * @;


1.110
date	2004.06.18.23.44.19;	author ndagger;	state Exp;
branches;
next	1.109;

1.109
date	2004.06.16.01.23.49;	author ndagger;	state Exp;
branches;
next	1.108;

1.108
date	2003.06.15.04.16.46;	author boogums;	state Exp;
branches;
next	1.107;

1.107
date	2003.02.11.01.48.00;	author boogums;	state Exp;
branches;
next	1.106;

1.106
date	2002.11.28.22.11.09;	author boogums;	state Exp;
branches;
next	1.105;

1.105
date	2002.10.18.21.17.57;	author rusty;	state Exp;
branches;
next	1.104;

1.104
date	2002.04.18.19.33.14;	author poquah;	state Exp;
branches;
next	1.103;

1.103
date	2002.03.09.20.02.13;	author rusty;	state Exp;
branches;
next	1.102;

1.102
date	2002.02.25.16.57.07;	author poquah;	state Exp;
branches;
next	1.101;

1.101
date	2002.02.22.19.46.00;	author poquah;	state Exp;
branches;
next	1.100;

1.100
date	2002.02.22.19.35.14;	author poquah;	state Exp;
branches;
next	1.99;

1.99
date	2002.02.22.18.57.41;	author poquah;	state Exp;
branches;
next	1.98;

1.98
date	2002.02.22.18.53.41;	author poquah;	state Exp;
branches;
next	1.97;

1.97
date	2002.02.22.18.45.45;	author poquah;	state Exp;
branches;
next	1.96;

1.96
date	2002.02.22.18.41.58;	author poquah;	state Exp;
branches;
next	1.95;

1.95
date	2001.12.05.17.19.45;	author poquah;	state Exp;
branches;
next	1.94;

1.94
date	2001.12.05.17.07.04;	author poquah;	state Exp;
branches;
next	1.93;

1.93
date	2001.10.29.14.46.21;	author poquah;	state Exp;
branches;
next	1.92;

1.92
date	2001.10.24.22.19.49;	author poquah;	state Exp;
branches;
next	1.91;

1.91
date	2001.07.16.22.10.38;	author poquah;	state Exp;
branches;
next	1.90;

1.90
date	2001.05.16.14.37.16;	author poquah;	state Exp;
branches;
next	1.89;

1.89
date	2000.11.27.16.39.49;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	2000.10.14.23.36.25;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	2000.09.17.20.31.19;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	2000.09.17.20.27.06;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	2000.08.02.16.14.11;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	2000.08.02.13.59.01;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	2000.08.02.13.40.40;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	2000.07.28.16.57.35;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	2000.07.28.15.44.45;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	2000.07.25.12.50.21;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	2000.07.25.00.48.46;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2000.07.25.00.18.19;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	2000.07.25.00.03.48;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	2000.07.24.23.54.26;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	2000.07.24.23.31.40;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	2000.07.24.19.44.26;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	2000.07.24.18.15.34;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	2000.07.24.18.08.25;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2000.07.24.16.32.09;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2000.07.24.16.24.08;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2000.07.24.15.50.08;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2000.07.22.00.23.59;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	2000.07.21.23.32.26;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	2000.07.21.22.57.03;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	2000.07.21.22.43.53;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	2000.07.21.22.36.49;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	2000.07.21.22.24.48;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	2000.07.21.17.34.21;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	2000.07.21.00.46.58;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	2000.07.18.19.14.36;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	2000.07.18.19.04.52;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	2000.07.18.00.30.42;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	2000.07.18.00.14.49;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	2000.07.18.00.05.57;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2000.07.18.00.01.03;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2000.07.17.22.18.55;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2000.07.17.21.48.56;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2000.07.17.21.43.58;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	2000.07.16.19.15.06;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2000.07.13.02.12.30;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2000.07.13.02.04.15;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2000.07.13.02.02.42;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2000.07.13.01.57.45;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2000.07.12.22.54.08;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2000.07.12.22.22.15;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2000.07.11.03.57.56;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2000.07.08.18.20.31;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2000.07.08.05.10.27;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.08.05.05.08;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2000.07.07.21.44.18;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2000.07.04.17.50.18;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2000.06.30.00.01.30;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.29.22.17.58;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.29.22.10.46;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.29.21.29.30;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.29.18.38.21;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2000.06.29.17.53.10;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.29.15.48.33;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.29.15.41.55;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.29.15.41.09;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.29.15.28.24;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.29.15.24.30;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.29.15.19.21;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.29.14.56.19;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.29.02.45.40;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.29.02.37.22;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.29.02.04.34;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.28.22.25.45;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.28.22.23.36;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.28.21.44.16;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.28.20.46.04;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.28.00.57.12;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.27.03.33.35;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.26.06.39.42;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.26.06.24.51;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.26.05.16.40;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.25.23.36.09;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.19.00.07.39;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.30.23.51.06;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.30.00.26.42;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.29.23.28.41;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.29.23.26.36;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.29.23.22.38;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.29.23.18.28;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.29.19.57.29;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.29.19.53.44;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.29.19.48.33;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.29.19.47.12;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.29.19.37.04;	author mud;	state Exp;
branches;
next	;


desc
@@


1.110
log
@06/18/04 Nightdagger:  Code cleanup, cleaned 18 warnings from gladiator.c
@
text
@
static char rcsid[] = "$Id: gladiator.c,v 1.109 2004/06/16 01:23:49 ndagger Exp $";

#if defined(macintosh)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <unistd.h>
#include "merc.h"
#include "tables.h"
#include "gladiator.h"
#include "recycle.h"

/* the command procedures needed */
DECLARE_DO_FUN(do_look);
DECLARE_DO_FUN(do_echo);
DECLARE_DO_FUN(do_startgladiator	);
DECLARE_DO_FUN(do_endgladiator	);
DECLARE_DO_FUN(do_removegladiator	);
DECLARE_DO_FUN(do_gladiator	);
DECLARE_DO_FUN(do_gbet          );
DECLARE_DO_FUN(do_gscore        );
DECLARE_DO_FUN(do_gtscore        );
DECLARE_DO_FUN(do_skipbet        );
DECLARE_DO_FUN(do_stand   );
DECLARE_DO_FUN(do_odds   );
DECLARE_DO_FUN(do_gstatus);

/*
 * External functions.
 */
int	clan_lookup	args( (const char *name) );
void    append_note     args( (NOTE_DATA *glad_qnote)); 

/*
 * Local functions.
 */
void    gladiator_bet_resolve args( (CHAR_DATA *winner, CHAR_DATA *bettor));
void    gladiator_start_countdown args((void));
void    begin_gladiator args((void));
void    end_gladiator args((void));
void    single_update args((void));
void    team_update args((void));

void do_startgladiator(CHAR_DATA *ch, char *argument)
{
   char buf[MAX_STRING_LENGTH];
   char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
   char arg3[MAX_INPUT_LENGTH];
   char arg4[MAX_INPUT_LENGTH];
   char arg5[MAX_INPUT_LENGTH];
   char arg6[MAX_INPUT_LENGTH];
   int i1,i2,i3,i4,i6;
   DESCRIPTOR_DATA *d;

   argument = one_argument(argument, arg1);
   argument = one_argument(argument, arg2);
   argument = one_argument(argument, arg3);
   argument = one_argument(argument, arg4);
   argument = one_argument(argument, arg5);
   argument = one_argument(argument, arg6);
   if (arg1[0] == '\0' || arg2[0] == '\0' || arg3[0] == '\0' 
       || arg4[0] == '\0' || arg5[0] == '\0')
   {
      send_to_char("Syntax: startgladiator <type> <min_level> <max_level> <ticks till start> <blind/noblind> \n\r", ch);
      return;
   }

   if (gladiator_info.started == TRUE)
   {
      send_to_char("There is already a Gladiator Event going on!\n\r", ch);
      return;
   }

   if ( !is_number(arg1) || !is_number(arg2) 
	|| !is_number(arg3) || !is_number(arg4))
	{
	  send_to_char("All arguments to startgladiator are numeric.\n\r",ch);
	  return;
	}

   i1 = atoi(arg1);
   i2 = atoi(arg2);
   i3 = atoi(arg3);
   i4 = atoi(arg4);

   if ( i1 < 1 || i1 > 3 || i2 <= 0 || i2 > 51 
	|| i3 <= 0 || i3 > 60 || i4 < 3 
	|| (strcmp(arg5,"blind") && strcmp(arg5,"noblind")))
   {
      send_to_char("The type either has to be one of the following:\n\r",ch);
      send_to_char("1 - Singles Event\n\r",ch);
      send_to_char("2 - Teams Event\n\r",ch);
      send_to_char("3 - Assigned Teams Events\n\r",ch);
      send_to_char("Levels must be between 1 and 60.\n\r", ch);
      send_to_char("Minimum Start Time is 3 Ticks.\n\r",ch);
      send_to_char("blind to hide names or noblind to leave revealed.\n\r",ch);
      return;
    }

   if (i1 > 2)
   {
      send_to_char("Not finished yet, please wait.\n\r", ch);
      return;
   }
   
   if (i3 < i2)
   {
      send_to_char("Max level can not be less than the min level.\n\r", ch);
      return;
   }

   if (i1 == 2 || i1 == 3 )
   {
      if (arg6[0] == '\0')  
      {
         send_to_char("Syntax: startgladiator <type> <min_level> <max_level> <ticks till start> <blind/noblind> <ticks till end>\n\r", ch);
         return;
      }
     
      if (!is_number(arg6)) 
      {
         send_to_char("All arguments to startgladiator are numeric.\n\r",ch);
         return;
      }

      i6 = atoi(arg6);

      if (i6 < 5)
      {
	 send_to_char("Atleast give them some time to fight. Minimum 5 ticks.\n\r",ch);
	 return;
      }
      
      gladiator_info.gladiator_score = 0;
      gladiator_info.barbarian_score = 0;
      gladiator_info.team_counter = i6;
   }

   gladiator_info.started = TRUE;
   gladiator_info.type = i1;
   gladiator_info.min_level = i2;
   gladiator_info.max_level = i3;
   gladiator_info.time_left = i4;
   gladiator_info.playing = 0;
   gladiator_info.gladiator_score = 0;
   gladiator_info.barbarian_score = 0;
   gladiator_info.bet_counter = 5;
  gladiator_info.total_levels = 0;
  gladiator_info.total_plays = 0;
  gladiator_info.total_wins = 0;
  gladiator_info.num_of_glads = 0;

   if (!strcmp(arg5,"blind"))
   {
      gladiator_info.blind = TRUE;
      log_string(arg5);
   }
   else
   {
      gladiator_info.blind = FALSE;
      log_string(arg5);
   }

   sprintf(buf, "Gladiator started for levels %d to %d, %s %s combat.\n\rType 'GLADIATOR' to join. Read 'help gladiator' for more info.",
   gladiator_info.min_level, gladiator_info.max_level,
   (gladiator_info.type/2?"team":"single"),
   (gladiator_info.blind?"blind":"not blind"));
   do_echo(ch,buf);
   log_string(buf);
   for (d = descriptor_list; d != NULL; d = d->next)
   {
      if (d->character != NULL)
      {
         if (IS_SET(d->character->mhs, MHS_GLADIATOR))
            REMOVE_BIT(d->character->mhs, MHS_GLADIATOR);
	 if ( d->character->pcdata->glad_bet_amt != 0)
	   d->character->pcdata->glad_bet_amt = 0;
      }
   }
#ifdef CODETEST
   glad_qnote = new_note();
   glad_qnote->next = NULL;
   glad_qnote->sender = str_dup("Emperor Flavius Vespasian");
   glad_qnote->date = str_dup("");
   glad_qnote->to_list = str_dup("all"); 
   glad_qnote->subject = str_dup("Echoes of Eternity");
   glad_qnote->text = str_dup("");
   glad_qnote->type = NOTE_QUEST;
  
   gladbuffer = new_buf();
   add_buf(gladbuffer,glad_qnote->text);
   add_buf(gladbuffer,"On this day the crowds at the arena were entertained by:\n\r");
   free_string(glad_qnote->text);
   glad_qnote->text = str_dup(buf_string(gladbuffer));
   free_buf(gladbuffer);
#endif
}

void remove_gladiator(CHAR_DATA *victim)
{
    char buf[MAX_STRING_LENGTH];

    REMOVE_BIT(victim->mhs, MHS_GLADIATOR);
    char_from_room(victim);
    char_to_room(victim,get_room_index(clan_table[victim->clan].hall));
    victim->clan = victim->pcdata->save_clan;
    victim->pcdata->save_clan = 0;
    victim->hit  = victim->max_hit;
    victim->mana = victim->max_mana;
    victim->move = victim->max_move;
    victim->pcdata->quit_time = 0; 
    victim->position = POS_SLEEPING;
    update_pos(victim);
    do_look(victim, "auto");
    /* Check if the gladiator has started and if so if the 
      removal of this player leaves only 1 person */
    if((gladiator_info.playing == 2) && gladiator_info.time_left == 0)
    {
       DESCRIPTOR_DATA *d;

       for(d = descriptor_list; d != NULL; d = d->next)
       {
	  if (d->character != NULL)
	  {
          if (IS_SET(d->character->mhs, MHS_GLADIATOR))
          {
             sprintf(buf, "%s is victorious in the arena!", d->character->name);
             gladiator_talk(buf); 

#ifdef CODETEST
             gladbuffer = new_buf();
             add_buf(gladbuffer,glad_qnote->text);
             add_buf(gladbuffer,buf);
             free_string(glad_qnote->text);
             glad_qnote->text = str_dup(buf_string(gladbuffer));
             free_buf(gladbuffer);
#endif

             gladiator_winner(d->character);
          }
	  }
       }
    }
    gladiator_info.playing--;
    gladiator_info.num_of_glads--;
    return;
}

void do_removegladiator( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    char arg1[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];

    argument = one_argument( argument, arg1 );

    if ( arg1[0] == '\0' )
    {
        send_to_char( "Syntax: removegladiator <char name>\n\r",ch);
        return;
    }

    if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
    {
        send_to_char( "They aren't playing.\n\r", ch );
        return;
    }

    if (IS_NPC(victim))
       return;

    if (!IS_SET(victim->mhs,MHS_GLADIATOR))
    {
       send_to_char( "They are not a Gladiator.\n\r",ch);
       return;
    }

    sprintf(buf, "The Immortals have removed %s from the Event, oh the shame!",victim->name);
    gladiator_talk(buf);

#ifdef CODETEST
    gladbuffer = new_buf();
    add_buf(gladbuffer,glad_qnote->text);
    add_buf(gladbuffer,buf);
    free_string(glad_qnote->text);
    glad_qnote->text = str_dup(buf_string(gladbuffer));
    free_buf(gladbuffer);
#endif

    send_to_char("You were removed from the Arena by an immortal.\n\r",victim);
    remove_gladiator(victim);

    return;
}


void do_endgladiator( CHAR_DATA *ch, char *argument )
{
    CHAR_DATA *victim;
    DESCRIPTOR_DATA *d;
    char arg1[MAX_INPUT_LENGTH];
    char buf[MAX_STRING_LENGTH];

    argument = one_argument( argument, arg1 );

    if ( arg1[0] == '\0' )
    {
        send_to_char( "Syntax: endgladiator <victor's name or none>\n\r",ch);
        return;
    }

    if (strcmp (arg1,"none")) 
    {
       if ( ( victim = get_char_world( ch, arg1 ) ) == NULL )
       {
           send_to_char( "They aren't playing.\n\r", ch );
           return;
       }

       sprintf(buf, "The Immortals have declared %s to be victorious!",victim->name);
       gladiator_talk(buf);

#ifdef CODETEST
       gladbuffer = new_buf();
       add_buf(gladbuffer,glad_qnote->text);
       add_buf(gladbuffer,buf);
       free_string(glad_qnote->text);
       glad_qnote->text = str_dup(buf_string(gladbuffer));
       free_buf(gladbuffer);
#endif

       gladiator_winner(victim);
    }
    else
    {
       sprintf(buf, "The Immortals have declared combat over with no one the victor!");
       gladiator_talk(buf);

#ifdef CODETEST
       gladbuffer = new_buf();
       add_buf(gladbuffer,glad_qnote->text);
       add_buf(gladbuffer,buf);
       free_string(glad_qnote->text);
       glad_qnote->text = str_dup(buf_string(gladbuffer));
       free_buf(gladbuffer);
#endif

       gladiator_info.started = FALSE;
       gladiator_info.playing = 0;
       gladiator_info.time_left = 0;
       gladiator_info.min_level = 0;
       gladiator_info.max_level = 0;
       gladiator_info.type = 0;
       gladiator_info.team_counter = 0;
       gladiator_info.blind = FALSE;
       gladiator_info.gladiator_score = 0;
       gladiator_info.barbarian_score = 0;
       gladiator_info.bet_counter = 0;
       gladiator_info.bet_total = 0;

       for(d = descriptor_list; d != NULL; d = d->next)
       {
	  if(d->character != NULL)
	  {
          if (!IS_NPC(d->character))
          {
	     d->character->gold += d->character->pcdata->glad_bet_amt;
             d->character->pcdata->glad_bet_on = d->character;

             if (IS_SET(d->character->mhs, MHS_GLADIATOR))
             {
		d->character->pcdata->glad_tot_bet = 0;
                char_from_room(d->character);
                char_to_room(d->character,get_room_index(clan_table[d->character->clan].hall));
                REMOVE_BIT(d->character->mhs, MHS_GLADIATOR);
	        d->character->clan = d->character->pcdata->save_clan;
		d->character->pcdata->save_clan = 0;
                do_look(d->character, "auto");
		d->character->position = POS_SLEEPING;
		/* Tell the Glad its over incase they have channel off */
		send_to_char(buf,ch);
             }
          }
	  }
       }
    }
    return;
}

void do_skipbet ( CHAR_DATA *ch , char *argument )
{
   char buf[MAX_STRING_LENGTH];

   if(gladiator_info.time_left > 0)
   {
      send_to_char("You must wait till betting begins before you skip it.\n\r",ch);
      return;
   }

   sprintf(buf, "The Immortals have decided to skip the betting!");
   gladiator_talk(buf);
   gladiator_info.bet_counter = 0;
   begin_gladiator(); 
   return;
}

void gladiator_winner( CHAR_DATA *ch )
{
   DESCRIPTOR_DATA *d;
   char buf[MAX_STRING_LENGTH];

   if (gladiator_info.type == 1 )
      {
      ch->pcdata->gladiator_data[GLADIATOR_VICTORIES] += 1;
      sprintf(buf, "Flavius Vespasian grants you a prize of %d gold!!!\n\r", 
      gladiator_info.bet_total /10 );
      send_to_char(buf, ch);
      ch->gold += gladiator_info.bet_total /10;
      }

   for(d = descriptor_list; d != NULL; d = d->next)
   {
      if (d->character != NULL)
      {
         if (IS_SET(d->character->mhs, MHS_GLADIATOR))
         {
            char_from_room(d->character);
            char_to_room(d->character,get_room_index(clan_table[d->character->clan].hall));
            REMOVE_BIT(d->character->mhs, MHS_GLADIATOR);
	    d->character->clan = d->character->pcdata->save_clan;
            d->character->pcdata->save_clan = 0;
            do_look(d->character, "auto");
            d->character->hit  = d->character->max_hit;
            d->character->mana = d->character->max_mana;
            d->character->move = d->character->max_move;
    	    d->character->position = POS_SLEEPING;
            d->character->pcdata->quit_time = 0; 
            d->character->pcdata->sac = (d->character->class == class_lookup("paladin")) ? 600:300;
            if(d->character->class == class_lookup("crusader"))
               d->character->pcdata->sac = 400;
            if(HAS_KIT(d->character,"bishop"))
               d->character->pcdata->sac += 100;

            if ((gladiator_info.type == 2 || gladiator_info.type == 3) 
                 && ch->pcdata->gladiator_team == d->character->pcdata->gladiator_team)
	       d->character->pcdata->gladiator_data[GLADIATOR_TEAM_VICTORIES] += 1;
	 }
         if ( d->character->pcdata->glad_bet_amt != 0 )
	 {
	     if(gladiator_info.type == 1 )
	        gladiator_bet_resolve( ch, d->character);
	     else
	     {
	     /*Rage fill in the Team Bet resolve */
	     }
	   }
      }
   }

#ifdef CODETEST
   strtime       = ctime( &current_time );
   strtime[strlen(strtime)-1]  = '\0';  
   glad_qnote->date = str_dup(strtime);
   glad_qnote->date_stamp = current_time;

   append_note(glad_qnote);
   glad_qnote = NULL;
#endif

   gladiator_info.started = FALSE;
   gladiator_info.playing = 0;
   gladiator_info.time_left = 0;
   gladiator_info.min_level = 0;
   gladiator_info.max_level = 0;
   gladiator_info.type = 0;
   gladiator_info.team_counter = 0;
   gladiator_info.blind = FALSE;
   gladiator_info.gladiator_score = 0;
   gladiator_info.barbarian_score = 0;
   gladiator_info.bet_counter = 0;
   gladiator_info.bet_total = 0;
   gladiator_info.total_levels = 0;
   gladiator_info.total_plays = 0;
   gladiator_info.total_wins = 0;

   return;
}

void do_gladiator( CHAR_DATA *ch, char *argument)
{
   char arg1[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   ROOM_INDEX_DATA *location;

   if (IS_NPC(ch))
      return;

   argument = one_argument( argument, arg1 );

   if (gladiator_info.started != TRUE) 
   {
      send_to_char("There is no Gladiator Combat going!\n\r", ch);
      return;
   }
   if (is_clan(ch) && ch->pcdata->start_time > 0 )
   {
      ch->pcdata->start_time = 0;
   }
   if (ch->pcdata && ch->pcdata->quit_time > 0 && !IS_IMMORTAL (ch)) 
   {
      send_to_char ("Not while your timer exists... wait a few ticks.\n\r",ch);
      return;
   }

   if (ch->level < gladiator_info.min_level || ch->level > gladiator_info.max_level)
   {
      send_to_char("Sorry, you have not the right experience for this Combat.\n\r", ch);
      return;
   }
   if ( ch->pcdata->glad_bet_amt != 0 && ch->pcdata->glad_bet_on != ch )
      {
      send_to_char("You already bet on someone else.  Either clear\n\r", ch);
      send_to_char("your bet, or don't participate.\n\r", ch);
      return;
      }

   if (IS_SET(ch->mhs, MHS_GLADIATOR))
   {
      send_to_char("You are already a Gladiator, no turning back now.\n\r", ch);
      return;
   }

   if (gladiator_info.started == TRUE && gladiator_info.time_left < 1)
   {
      send_to_char("Hey goober its started already.\n\r", ch);
      return;
   }


      location = get_room_index(ROOM_VNUM_SINGLE_GLADIATOR);  
      act("$n goes to spill some blood in Gladiator Combat!", ch, NULL, NULL, TO_ROOM,FALSE); 
      char_from_room(ch);
      char_to_room(ch, location);
      SET_BIT(ch->mhs, MHS_GLADIATOR);
      gladiator_info.total_levels += ch->level;
      gladiator_info.total_plays += ch->pcdata->gladiator_data[GLADIATOR_PLAYS];
      gladiator_info.total_wins += ch->pcdata->gladiator_data[GLADIATOR_VICTORIES];
      ch->pcdata->save_clan = ch->clan; 
      ch->pcdata->gladiator_team = 0;
      if (!is_clan(ch))
	 ch->clan = clan_lookup("temp");
      sprintf(buf, "%s (Level %d %s) joins the Gladiators!", ch->name, ch->level, class_table[ch->class].name);
      gladiator_talk(buf);
      if (gladiator_info.blind)
      {
        free_string( ch->long_descr );                                        
        ch->long_descr = str_dup( "A Gladiator" ); 
        act("$l arrives to prove his worth!", ch, NULL, NULL, TO_ROOM,FALSE);
      }
      else
      {
        act("$n arrives to prove his worth!", ch, NULL, NULL, TO_ROOM,FALSE);
      }
      gladiator_info.playing++;
      gladiator_info.num_of_glads++;
      die_follower(ch);
      affect_strip(ch,gsn_sneak);
      do_look(ch, "auto");
      return;
}

void do_gbet ( CHAR_DATA *ch , char *argument )

{
  int amount;
  CHAR_DATA *victim;
  char arg1[MAX_INPUT_LENGTH], arg2[MAX_INPUT_LENGTH];
  char buf[MAX_STRING_LENGTH];
  argument = one_argument(argument, arg1);
  argument = one_argument(argument, arg2);
 
  if ( arg1[0] == '\0' )
    {
    send_to_char("Syntax: gbet <amount> <character>\n\r", ch);
    send_to_char("        gbet clear\n\r",ch);
    return;
    }

  if ( gladiator_info.type != 1 )
  {
    send_to_char("You may only bet on single events.  Team betting is not yet available.\n\r", ch);
    return;
  }


  if (!str_cmp(arg1, "clear"))
   {
     if (gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
     {
       send_to_char("Umm....it's a little late, the event has already begun\n\r", ch);
       return;
     }

     if (ch->pcdata->glad_bet_on)
     {
       send_to_char("Bet cleared.\n\r", ch);
       ch->gold += ch->pcdata->glad_bet_amt;
       ch->pcdata->glad_bet_on->pcdata->glad_tot_bet -= ch->pcdata->glad_bet_amt;
       ch->pcdata->glad_bet_on = ch;
       gladiator_info.bet_total -= ch->pcdata->glad_bet_amt;
       ch->pcdata->glad_bet_amt = 0;
       return;
     }
     else
     {
       send_to_char("You have no bet to clear!!\n\r", ch);
       return;
     }
    }

    if(!str_cmp(arg1, "show") && ch->pcdata->glad_bet_on != 0)
    {
    sprintf(buf,"You have placed a bet of %d gold on %s.\n\r", ch->pcdata->glad_bet_amt, ch->pcdata->glad_bet_on->name);
    send_to_char(buf, ch);
    return;

    }


  if (ch->pcdata->glad_bet_amt != 0)
  {
  send_to_char("You must clear your current bet before betting again.\n\r", ch);
  return;
   }
   
   if (gladiator_info.started != TRUE) 
   {
      send_to_char("There is no Gladiator Combat going!\n\r", ch);
      return;
   }
  
  if ( (victim = get_char_world(ch, arg2)) == NULL)
     {
     send_to_char("They aren't here.\n\r", ch);
     return;
     }

  if ( !IS_SET(victim->mhs, MHS_GLADIATOR) )
     {
     send_to_char("You can't bet on them, they aren't participating.\n\r", ch);
     return;
     }

  if (gladiator_info.started == TRUE && victim != ch 
      && IS_SET(ch->mhs, MHS_GLADIATOR))
      {
      send_to_char("If you want to bet, you have to bet on yourself. \n\r", ch);
      return;
      }
 
  if (gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
   {
      send_to_char("You may not bet after the combat has started\n\r", ch);
      return;
   }
  
  amount = atoi(arg1);
  
  if ( amount < 0 )
    {
    send_to_char("An Immortal has created [1] a beautiful jeweled egg\n\rAn Immortal gives you a beautiful jeweled egg.\n\r", ch);
    return;
    }

  if ( ch->gold < amount )
    {
    send_to_char("You can't bet that much, you don't have it in gold.\n\r",ch);
    return;
    }

  if (amount > 500)
    {
    send_to_char("Maximum Betting amount is 500 gold.\n\r",ch);
    return;
    }

  ch->pcdata->glad_bet_amt = amount;
  ch->gold -= amount;
  ch->pcdata->glad_bet_on = victim;
  gladiator_info.bet_total += amount;
  victim->pcdata->glad_tot_bet += amount;

  sprintf(buf, "You have placed a bet of %d gold on %s.\n\r", amount, victim->name);
  send_to_char(buf,ch);
  sprintf(buf, "%s bet %d on %s", ch->name, amount, victim->name);
  log_string(buf);
  return;
}

void gladiator_bet_resolve( CHAR_DATA *winner, CHAR_DATA *bettor )
{
 int odds, this_odds, payout= 0;
 char buf[MAX_STRING_LENGTH];
 
 int avg_level, gladadj, winlossavg, thiswinloss;
 

 avg_level = (gladiator_info.total_levels  * 100/
	     gladiator_info.num_of_glads ) ;

 if ( bettor->pcdata->glad_bet_on == winner  && bettor->pcdata->glad_bet_amt > 0 )
   {
    odds =( gladiator_info.num_of_glads *avg_level  /
           (winner->level));
	   

    if( winner->pcdata->gladiator_data[GLADIATOR_VICTORIES] -1  != 0  &&
	winner->pcdata->gladiator_data[GLADIATOR_PLAYS] >= 1 )
      {
       winlossavg = (gladiator_info.total_wins  * 100 /
		    gladiator_info.total_plays);
       

       thiswinloss = ((winner->pcdata->gladiator_data[GLADIATOR_VICTORIES] -1 )* 100 /
		     winner->pcdata->gladiator_data[GLADIATOR_PLAYS] );

       gladadj = (thiswinloss  * 100 / winlossavg) ;
       
       this_odds = ((odds/200) + ((odds/2)/gladadj));
	      
       this_odds = URANGE(1, this_odds, 99);

       }
    else
      {
       this_odds = URANGE(1, odds/ 100, 99);
      }
    
   payout = bettor->pcdata->glad_bet_amt * this_odds ;

   sprintf(buf,"Your bet on %s came through, at %d odds.  You won %d gold!!!!\n\r", winner->name,this_odds, payout);
   bettor->gold += payout;
   }
 else
   {
   sprintf(buf,"Your bet on %s was a waste of money.  God they suck!  Better luck next time. \n\r", bettor->pcdata->glad_bet_on->name);
   }

 send_to_char(buf,bettor);
   sprintf(buf, "Paid out %d to %s, on bet of %d, winner: %s", payout, bettor->name, bettor->pcdata->glad_bet_amt, winner->name);
   log_string(buf);
 return;
}

void gladiator_update(void)
{
   if (gladiator_info.started == TRUE)
   {
      if (gladiator_info.bet_counter > 0)
         gladiator_start_countdown();
      else
      {
	 if(gladiator_info.type == 1 )
	    single_update();
         else
	    team_update();
      }
   }
   return;
}

void gladiator_start_countdown(void)
{
   sh_int time;
   DESCRIPTOR_DATA *d;
   char buf[MAX_INPUT_LENGTH];

   time = gladiator_info.time_left - 1;
   if(gladiator_info.time_left > 0)
      gladiator_info.time_left--;
   if (time > 0)
   {
      sprintf(buf, "%d tick%s left to join the Gladiator Combat. Read 'help gladiator' for more info.", time, time == 1 ? "" : "s");
      for ( d = descriptor_list; d; d = d->next )
      {
         if ( d->connected == CON_PLAYING )
         {
            send_to_char( buf, d->character );
            send_to_char( "\n\r",   d->character );
         }
      }

      sprintf(buf, "%d %s %s signed up to fight in the Arena so far.", gladiator_info.playing, gladiator_info.playing == 1 ? "Gladiator" : "Gladiators", gladiator_info.playing == 1 ? "is" : "are");
      gladiator_talk(buf);

      if(gladiator_info.blind)
      {
      if (gladiator_info.type == 1)
      {
         sprintf(buf, "Type of Event: Levels %d - %d, Singles Blind Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      if (gladiator_info.type == 2)
      {
         sprintf(buf, "Type of Event: Levels %d - %d, Random Teams Blind Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      if (gladiator_info.type == 3)
      {
         sprintf(buf, "Type of Event: Levels %d - %d, Assigned Teams Blind Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      }
      else
      {
      if (gladiator_info.type == 1)
      {
         sprintf(buf, "Type of Event: Levels %d - %d, Singles Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      if (gladiator_info.type == 2)
      {
         sprintf(buf, "Type of Event: Levels %d - %d, Random Teams Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      if (gladiator_info.type == 3)
      {
         sprintf(buf, "Type of Event: Levels %d - %d, Assigned Teams Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      }
      gladiator_talk(buf);
   }
   else
   {  
      if (gladiator_info.playing < 2)
      {
         sprintf(buf, "Not enough people for the Event.  Gladiator Combat ended.");
         gladiator_talk(buf);
#ifdef CODETEST
       gladbuffer = new_buf();
       add_buf(gladbuffer,glad_qnote->text);
       add_buf(gladbuffer,buf);
       free_string(glad_qnote->text);
       glad_qnote->text = str_dup(buf_string(gladbuffer));
       free_buf(gladbuffer);
#endif
         end_gladiator();
         return;
      }
      else
      {
	 gladiator_info.bet_counter--;
	 if (gladiator_info.bet_counter == 0)
            begin_gladiator(); 
	 else
	 {
	    sprintf(buf,"%d Ticks of Betting until the event starts.",gladiator_info.bet_counter);
            gladiator_talk(buf);
	 }
      }
   }
   return;
}

void begin_gladiator (void)
{
   sh_int team_select;
   DESCRIPTOR_DATA *d;
   ROOM_INDEX_DATA *random;
   char buf[MAX_INPUT_LENGTH];

   sprintf(buf, "The battle begins! %d Gladiators are fighting!", gladiator_info.playing);
   gladiator_talk(buf);

   team_select = 1;
   for(d = descriptor_list; d != NULL; d = d->next)
   {
      if (d->character != NULL)
      {
         if (IS_SET(d->character->mhs, MHS_GLADIATOR))
         {
            d->character->hit  = d->character->max_hit;
            d->character->mana = d->character->max_mana;
            d->character->move = d->character->max_move;
            d->character->pcdata->gladiator_attack_timer = 5;
            update_pos(d->character);
	    if (gladiator_info.type == 1)
               d->character->pcdata->gladiator_data[GLADIATOR_PLAYS]++;
	    else
               d->character->pcdata->gladiator_data[GLADIATOR_TEAM_PLAYS]++;

            /* Default random to single player range */
            random = get_room_index(number_range(10800,10819));

            if (gladiator_info.type == 2)
            {
               d->character->pcdata->gladiator_team = team_select;
               if(team_select == 1)
                  team_select = 2; 
               else
                  team_select = 1;

               if(d->character->pcdata->gladiator_team == 1)
                  random = get_room_index(ROOM_VNUM_TEAM_GLADIATOR);
                  if (gladiator_info.blind == TRUE)
                  {
                     free_string( d->character->long_descr );                
                     d->character->long_descr = str_dup( "A Gladiator" ); 
                  }
               else
	       {
                  random = get_room_index(ROOM_VNUM_TEAM_BARBARIAN);
                  if (gladiator_info.blind == TRUE)
                  {
                     free_string( d->character->long_descr );           
                     d->character->long_descr = str_dup( "A Barbarian" ); 
                  }
	       }
            }

            char_from_room(d->character);
            char_to_room(d->character, random);
	    if (!IS_AWAKE(d->character))
	       do_stand(d->character,"");
	    else
               do_look(d->character, "auto");
         }
      }
   }

   return;
}

void end_gladiator(void)
{
   DESCRIPTOR_DATA *d;

   gladiator_info.started = FALSE;
   gladiator_info.time_left = 0;
   gladiator_info.min_level = 0;
   gladiator_info.max_level = 0;
   gladiator_info.type = 0;
   gladiator_info.playing = 0;
   gladiator_info.team_counter = 0;
   gladiator_info.blind = FALSE;
   gladiator_info.bet_counter = 0;
   gladiator_info.total_levels = 0;
   gladiator_info.total_wins = 0;
   gladiator_info.total_plays = 0;

   for(d = descriptor_list; d != NULL; d = d->next)
   {
      if (d->character != NULL)
      {
         if (IS_SET(d->character->mhs, MHS_GLADIATOR))
         {
            char_from_room(d->character);
            char_to_room(d->character, get_room_index(clan_table[d->character->clan].hall));
            d->character->clan = d->character->pcdata->save_clan;
            d->character->pcdata->save_clan = 0;
            REMOVE_BIT(d->character->mhs,MHS_GLADIATOR);
            do_look(d->character, "auto");
            d->character->position = POS_SLEEPING;
         }
      }
   }
   return;
}

void single_update(void)
{
   DESCRIPTOR_DATA *d;
   char buf[MAX_INPUT_LENGTH];

   sprintf(buf, "The battle rages on with %d Gladiators still remaining.", gladiator_info.playing);
   gladiator_talk(buf);

   for(d = descriptor_list; d != NULL; d = d->next)
   {
      if (d->character != NULL)
 {
         if (IS_SET(d->character->mhs, MHS_GLADIATOR))
         {
            d->character->pcdata->gladiator_attack_timer--;
            if(d->character->pcdata->gladiator_attack_timer == 0)
            {
	       if (is_affected(d->character,gsn_blindness) ||
		   is_affected(d->character,gsn_dust_storm) ||
                   IS_AFFECTED(d->character, AFF_SLEEP) || 
                    d->character->pcdata->quit_time != 0)
                  d->character->pcdata->gladiator_attack_timer = 5;
               else
               {
                  sprintf(buf, "%s slips into a pit full of tigers, next time %s will be more active.", d->character->name,d->character->name);
                  gladiator_talk(buf);
#ifdef CODETEST
       gladbuffer = new_buf();
       add_buf(gladbuffer,glad_qnote->text);
       add_buf(gladbuffer,buf);
       free_string(glad_qnote->text);
       glad_qnote->text = str_dup(buf_string(gladbuffer));
       free_buf(gladbuffer);
#endif
		  send_to_char("You were removed from the Arena for being inactive.\n\r",d->character);
                  remove_gladiator(d->character);
               }
            }
         }
      }
   } /* for loop through players */ 
   return;
}

void team_update(void)
{
   sh_int team_select;
   DESCRIPTOR_DATA *d;
   char buf[MAX_INPUT_LENGTH];

   sprintf(buf, "The current score is: Gladiators %d - Barbarians %d.\n\r",gladiator_info.gladiator_score,gladiator_info.barbarian_score);  
   gladiator_talk(buf);

   gladiator_info.team_counter--;

   if(gladiator_info.team_counter == 0)
   {
      if(gladiator_info.gladiator_score == gladiator_info.barbarian_score)
      {
	 gladiator_info.team_counter = 2;
         sprintf(buf," The Teams are Tied, they continue to fight!\n\r");
         gladiator_talk(buf);
	 return;
      }

      if(gladiator_info.gladiator_score > gladiator_info.barbarian_score)
      {
         sprintf(buf, "The Gladiators are victorious!\n\r");  
         team_select = 1;
      }
      else
      {
         sprintf(buf, "The Barbarians are victorious!\n\r");  
         team_select = 2;
      }
      gladiator_talk(buf);

      for(d = descriptor_list; d != NULL; d = d->next)
      {
         if (d->character != NULL)
         {
            if (IS_SET(d->character->mhs, MHS_GLADIATOR))
            {
	       send_to_char(buf,d->character);
               if(d->character->pcdata->gladiator_team == team_select)
               {
                  gladiator_winner(d->character);
		  break; 
               }
	    }
	 }
      }
   }
   return;
}

void do_gtscore ( CHAR_DATA *ch , char *argument )
{
   char buf[MAX_INPUT_LENGTH];

   if (gladiator_info.type == 1)
   {
      send_to_char("There is no Team Event on.\n\r",ch);
      return;
   }

   sprintf(buf, "The current score is: Gladiators %d - Barbarians %d. With %d ticks remaining\n\r",gladiator_info.gladiator_score,gladiator_info.barbarian_score,gladiator_info.team_counter);  
   send_to_char(buf,ch);
}

void do_gscore( CHAR_DATA *ch, char *argument )
{     
     char buf[MAX_STRING_LENGTH];
 
     if(!IS_NPC(ch))  
     { 
        sprintf(buf,"Single Events Played: %d  Victories: %d  Kills: %d \n\r "
        "Team Events Played: %d  Victories: %d  Kills: %d\n\r",
               ch->pcdata->gladiator_data[GLADIATOR_PLAYS],
               ch->pcdata->gladiator_data[GLADIATOR_VICTORIES],
               ch->pcdata->gladiator_data[GLADIATOR_KILLS],
               ch->pcdata->gladiator_data[GLADIATOR_TEAM_PLAYS],
               ch->pcdata->gladiator_data[GLADIATOR_TEAM_VICTORIES],
               ch->pcdata->gladiator_data[GLADIATOR_TEAM_KILLS]);
        send_to_char(buf,ch);
     }
     return;
}

void gladiator_left_arena( CHAR_DATA *ch, bool DidQuit )
{
   char buf[MAX_STRING_LENGTH];

   REMOVE_BIT(ch->mhs,MHS_GLADIATOR);
   ch->clan = ch->pcdata->save_clan;
   ch->pcdata->save_clan = 0;

   if(DidQuit)
   {
      char_from_room(ch);
      char_to_room(ch, get_room_index(clan_table[ch->clan].hall));
   }
   else
      ch->was_in_room = get_room_index(clan_table[ch->clan].hall);
 
   /* Check if the gladiator has started and if so if the 
      removal of this player leaves only 1 person */
   if(gladiator_info.playing == 2 && gladiator_info.time_left == 0
       && gladiator_info.type == 1)
   {
      DESCRIPTOR_DATA *d;

      for(d = descriptor_list; d != NULL; d = d->next)
      {
         if (d->character != NULL)
	 {
            if (IS_SET(d->character->mhs, MHS_GLADIATOR))
            {
               sprintf(buf, "%s is victorious in the arena!", d->character->name);
               gladiator_talk(buf); 
#ifdef CODETEST
       gladbuffer = new_buf();
       add_buf(gladbuffer,glad_qnote->text);
       add_buf(gladbuffer,buf);
       free_string(glad_qnote->text);
       glad_qnote->text = str_dup(buf_string(gladbuffer));
       free_buf(gladbuffer);
#endif
               gladiator_winner(d->character);
            }
         }
      }
   }
   gladiator_info.playing--;

}

void gladiator_kill( CHAR_DATA *victim, CHAR_DATA *ch )
{
   char buf[MAX_STRING_LENGTH];

   sprintf(buf, "%s lands the killing blow on %s!", ch->name,victim->name);
   gladiator_talk(buf); 
#ifdef CODETEST
       gladbuffer = new_buf();
       add_buf(gladbuffer,glad_qnote->text);
       add_buf(gladbuffer,buf);
       free_string(glad_qnote->text);
       glad_qnote->text = str_dup(buf_string(gladbuffer));
       free_buf(gladbuffer);
#endif
   raw_kill( victim,ch );
   if(gladiator_info.type == 1 )
   {
      REMOVE_BIT(victim->mhs, MHS_GLADIATOR);
      victim->clan = victim->pcdata->save_clan;
      victim->pcdata->save_clan = 0;
   }
   victim->hit  = victim->max_hit;
   victim->mana = victim->max_mana;
   victim->move = victim->max_move;
   victim->pcdata->quit_time = 0; 
   victim->position = POS_SLEEPING;
   victim->pcdata->sac = (victim->class == class_lookup("paladin")) ? 600:300;
   if(victim->class == class_lookup("crusader"))
      victim->pcdata->sac = 400;
   if(HAS_KIT(victim,"bishop"))
      victim->pcdata->sac += 100;
   update_pos(victim);
   if(gladiator_info.type == 1)
   {
      gladiator_info.playing--;
      if (ch != victim)
         ch->pcdata->gladiator_data[GLADIATOR_KILLS] += 1;

      if (gladiator_info.playing == 1)
      {
         DESCRIPTOR_DATA *d;
         for(d = descriptor_list; d != NULL; d = d->next)
         {
            if (d->character != NULL)
	    {
               if (IS_SET(d->character->mhs, MHS_GLADIATOR))
               {
                  sprintf(buf, "%s is victorious in the arena!", d->character->name);
                  gladiator_talk(buf); 
#ifdef CODETEST
       gladbuffer = new_buf();
       add_buf(gladbuffer,glad_qnote->text);
       add_buf(gladbuffer,buf);
       free_string(glad_qnote->text);
       glad_qnote->text = str_dup(buf_string(gladbuffer));
       free_buf(gladbuffer);
#endif

                  gladiator_winner(d->character);
               }
            }
         }
      }
   }

   if(gladiator_info.type == 2 || gladiator_info.type == 3)
   {
      ch->pcdata->gladiator_data[GLADIATOR_TEAM_KILLS] += 1;
      if(ch->pcdata->gladiator_team == 1)
	 gladiator_info.gladiator_score++;
      else
	 gladiator_info.barbarian_score++;
   }
   return;
}

void do_odds ( CHAR_DATA *ch , char *argument )
{

  DESCRIPTOR_DATA *d;
  char buf[MAX_STRING_LENGTH];
  char buf1[60];
  char buf2[10];
  int this_odds = 0;
  int odds = 0;
  int thiswinloss, gladadj, winlossavg, avg_level; 

    if(gladiator_info.started != TRUE )
    {
    send_to_char("There is no event running currently.\n\r", ch);
    return;
    }
   
   if ( gladiator_info.num_of_glads < 1 )
     {
     send_to_char("There are no gladiators yet.\n\r", ch);
     return;
     }

    sprintf(buf, "%-12s\t%-10s\t%-10s\t%-10s\n\r", "NAME", "ODDS", "PLAYED", "WON"); 
    avg_level = (gladiator_info.total_levels  * 100 )/ gladiator_info.num_of_glads;   

    for(d = descriptor_list; d != NULL; d = d->next)
      {
         if (d->character != NULL)
	 {
            if (IS_SET(d->character->mhs, MHS_GLADIATOR))
            {
             odds = (gladiator_info.num_of_glads  * avg_level /
		   ( d->character->level));
             

	     if( d->character->pcdata->gladiator_data[GLADIATOR_VICTORIES] != 0  &&
		 d->character->pcdata->gladiator_data[GLADIATOR_PLAYS] >= 1)
             {
	       winlossavg = (gladiator_info.total_wins  * 100) /
			    gladiator_info.total_plays;


	       thiswinloss = (d->character->pcdata->gladiator_data[GLADIATOR_VICTORIES] * 100  /
			     d->character->pcdata->gladiator_data[GLADIATOR_PLAYS]);
	
	       gladadj = (thiswinloss   *100 / winlossavg);
               

	       this_odds = ((odds/200) + ((odds/2)/gladadj));
	       this_odds = URANGE(1, this_odds, 99);

	       sprintf(buf2, "%7d :1", this_odds);
	     }
             else
             {
	       odds=  URANGE(1, odds/100, 99);
	       sprintf(buf2, "%7d :1", odds);
	     }

             sprintf(buf1, "%-12s\t%-10s\t%-10d\t%-10d\n\r" ,d->character->name,
	     buf2, d->character->pcdata->gladiator_data[GLADIATOR_PLAYS],
	     d->character->pcdata->gladiator_data[GLADIATOR_VICTORIES]);

	     strcat(buf, buf1);
	    }
	 }
      }

      send_to_char(buf, ch);
      return;
}


void do_gstatus( CHAR_DATA *ch, char *argument)
{
   char buf[MAX_STRING_LENGTH];
   bool fFirst;
   DESCRIPTOR_DATA *d;
   sh_int percent;

   if (IS_SET(ch->mhs,MHS_GLADIATOR))
   {
      send_to_char("Looking for every advantage you can get?.\n\r",ch);
      return;
   }

   if(gladiator_info.started != TRUE )
   {
      send_to_char("There is no event running currently.\n\r", ch);
      return;
   }

   fFirst = TRUE;
   for (d = descriptor_list; d != NULL; d = d->next)
   {
      if (d->character != NULL)
      {
         if (IS_SET(d->character->mhs, MHS_GLADIATOR))
	 {
	    if(fFirst)
	    {
               strcpy( buf, d->character->name);
	       fFirst = FALSE;
	    }
	    else
               strcat( buf, d->character->name);

            if ( d->character->max_hit > 0 )
               percent = ( 100 * d->character->hit ) / d->character->max_hit;
            else
               percent = -1;

            if (percent >= 100) 
               strcat( buf, " is in excellent condition.\n\r");
            else if (percent >= 90) 
               strcat( buf, " has a few scratches.\n\r");
            else if (percent >= 75) 
               strcat( buf," has some small wounds and bruises.\n\r");
            else if (percent >=  50) 
               strcat( buf, " has quite a few wounds.\n\r");
            else if (percent >= 30)
               strcat( buf, " has some big nasty wounds and scratches.\n\r");
            else if (percent >= 15)
               strcat ( buf, " looks pretty hurt.\n\r");
            else if (percent >= 0 )
               strcat (buf, " is in awful condition.\n\r");
            else
               strcat(buf, " is bleeding to death.\n\r");
 
            buf[0] = UPPER(buf[0]);
	 }
      }
   }
   send_to_char( buf, ch );
   return;
}

@


1.109
log
@06/15/04 Nightdagger:  Changed endglad, skipbet, and removeglad to not reveal the immortal.
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.108 2003/06/15 04:16:46 boogums Exp $";
a61 2
   NOTE_DATA *glad_qnote;
   BUFFER *gladbuffer;
a209 2
    BUFFER *gladbuffer;
    NOTE_DATA *glad_qnote;
a261 2
    BUFFER *gladbuffer;
   NOTE_DATA *glad_qnote;
a310 2
    BUFFER *gladbuffer;
   NOTE_DATA *glad_qnote;
a418 2
   char *strtime;
   NOTE_DATA *glad_qnote;
a784 2
   BUFFER *gladbuffer;
   NOTE_DATA *glad_qnote;
a976 2
   BUFFER *gladbuffer;
   NOTE_DATA *glad_qnote;
a1104 2
   BUFFER *gladbuffer;
   NOTE_DATA *glad_qnote;
a1152 2
   BUFFER *gladbuffer;
   NOTE_DATA *glad_qnote;
@


1.108
log
@endabling glda
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.107 2003/02/11 01:48:00 boogums Exp $";
d292 1
a292 1
    sprintf(buf, "%s has removed %s from the Event, oh the shame!",ch->name,victim->name);
d336 1
a336 1
       sprintf(buf, "%s has declared %s to be victorious!",ch->name,victim->name);
d352 1
a352 1
       sprintf(buf, "%s has declared combat over with no one the victor!",ch->name);
d416 1
a416 1
   sprintf(buf, "%s has decided to skip the betting!",ch->name);
@


1.107
log
@taking them out
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.106 2002/11/28 22:11:09 boogums Exp $";
a53 3
   send_to_char("Nope, they're broken\r\n",ch);
   return;
#ifdef COREYCODE
a189 1
#endif
@


1.106
log
@adding int eh check
corey
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.105 2002/10/18 21:17:57 rusty Exp $";
d54 3
d193 1
a193 1

@


1.105
log
@Moved the raw_kill() before the ganking of gladiator settings for a kill
in gladiator_kill() to keep flags from being assigned to people that
should not get them.
-Rusty
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.104 2002/04/18 19:33:14 poquah Exp $";
d523 4
@


1.104
log
@more gladiator changes
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.103 2002/03/09 20:02:13 rusty Exp $";
a1168 6
   if(gladiator_info.type == 1 )
   {
      REMOVE_BIT(victim->mhs, MHS_GLADIATOR);
      victim->clan = victim->pcdata->save_clan;
      victim->pcdata->save_clan = 0;
   }
d1180 6
@


1.103
log
@gtscore() add moved gladiator stats out of score
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.102 2002/02/25 16:57:07 poquah Exp $";
d96 1
a96 1
   if ( i1 < 1 || i1 > 6 || i2 <= 0 || i2 > 51 
d101 3
a103 6
      send_to_char("1 - Single Clanner Only\n\r",ch);
      send_to_char("2 - Single NonClanned Allowed\n\r",ch);
      send_to_char("3 - Teams Clanner Only \n\r",ch);
      send_to_char("4 - Teams NonClanned Allowed \n\r",ch);
      send_to_char("5 - Assigned Teams Clanner Only \n\r",ch);
      send_to_char("6 - Assigned Teams NonClanned Allowed \n\r",ch);
d110 6
d122 1
a122 1
   if (i1 == 3 || i1 == 4 || i1 == 5 || i1 == 6)
d176 1
a176 1
   (gladiator_info.type/3?"team":"single"),
d431 1
a431 1
   if (gladiator_info.type == 1 || gladiator_info.type == 2)
d439 1
d463 1
a463 1
            if ((gladiator_info.type == 3 || gladiator_info.type == 4) 
d469 1
a469 1
	     if(gladiator_info.type == 1 || gladiator_info.type == 2)
a553 5
   if ((gladiator_info.type == 1 || gladiator_info.type == 3) && !is_clan(ch))
   {
      send_to_char("Sorry this Event is for Clanners Only. Try Again next time.\n\r",ch);
      return;
   }
d565 1
a565 2
      if ((gladiator_info.type == 2 || gladiator_info.type == 4)
           && !is_clan(ch))
d604 1
a604 1
  if ( gladiator_info.type != 1 && gladiator_info.type != 2 )
d778 1
a778 1
	 if(gladiator_info.type == 1 || gladiator_info.type == 2)
d817 1
a817 1
         sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Single Blind Combat.", gladiator_info.min_level, gladiator_info.max_level);
d821 1
a821 1
         sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Single Blind Combat.", gladiator_info.min_level, gladiator_info.max_level);
d825 1
a825 5
         sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Team Blind Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      if (gladiator_info.type == 4)
      {
         sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Team Blind Combat.", gladiator_info.min_level, gladiator_info.max_level);
d832 1
a832 1
         sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Single Combat.", gladiator_info.min_level, gladiator_info.max_level);
d836 1
a836 1
         sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Single Combat.", gladiator_info.min_level, gladiator_info.max_level);
d840 1
a840 5
         sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Team Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      if (gladiator_info.type == 4)
      {
         sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Team Combat.", gladiator_info.min_level, gladiator_info.max_level);
d899 1
a899 1
	    if (gladiator_info.type < 3)
d907 1
a907 1
            if (gladiator_info.type == 3 || gladiator_info.type == 4)
d1084 1
a1084 1
   if (gladiator_info.type < 3)
d1133 2
a1134 2
   if((gladiator_info.playing == 2) && gladiator_info.time_left == 0
       && (gladiator_info.type == 1 || gladiator_info.type == 2))
d1169 1
a1169 1
   if(gladiator_info.type == 1 || gladiator_info.type == 2)
d1197 1
a1197 1
   if(gladiator_info.type == 1 || gladiator_info.type ==2)
d1230 1
a1230 1
   if(gladiator_info.type == 3 || gladiator_info.type == 4)
@


1.102
log
@CODETEST around glad note stuff so it doesnt crash 4000
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.101 2002/02/22 19:46:00 poquah Exp $";
d30 1
d1090 1
a1090 1
void do_gscore ( CHAR_DATA *ch , char *argument )
d1102 19
@


1.101
log
@cleaning up syntax
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.100 2002/02/22 19:35:14 poquah Exp $";
d187 1
d203 1
d239 1
d246 1
d292 1
d299 1
d336 1
d343 1
d352 1
d359 1
d474 1
d482 1
d860 1
d867 1
d1019 1
d1026 1
d1136 1
d1143 1
d1167 1
d1174 1
d1204 1
d1211 2
@


1.100
log
@removing errors from note change
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.99 2002/02/22 18:57:41 poquah Exp $";
a190 1
   glad_qnote->date_stamp = str_dup("");
d208 1
@


1.99
log
@declare append_note
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.98 2002/02/22 18:53:41 poquah Exp $";
a208 1
    NOTE_DATA *glad_qnote;
@


1.98
log
@include recycle.h
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.97 2002/02/22 18:45:45 poquah Exp $";
d39 1
@


1.97
log
@declare glad_qnote in all spots
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.96 2002/02/22 18:41:58 poquah Exp $";
d19 1
d415 1
@


1.96
log
@adding gladiator post note to gladiator
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.95 2001/12/05 17:19:45 poquah Exp $";
d207 1
d259 1
d308 1
d780 1
d980 1
d1089 1
d1137 1
@


1.95
log
@move glad_bet_on,glad_bet_amt, glad_tot_bet to pcdata
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.94 2001/12/05 17:07:04 poquah Exp $";
d59 2
d184 17
d206 1
d234 8
d257 1
d284 8
d305 1
d326 7
d340 7
d410 1
d459 8
d776 1
d842 6
d975 1
d998 6
d1083 1
d1112 6
d1130 1
d1140 6
d1175 6
d1336 1
@


1.94
log
@move gladiator_data and highlander_data to pcdata
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.93 2001/10/29 14:46:21 poquah Exp $";
d178 2
a179 2
	 if ( d->character->glad_bet_amt != 0)
	   d->character->glad_bet_amt = 0;
d314 2
a315 2
	     d->character->gold += d->character->glad_bet_amt;
             d->character->glad_bet_on = d->character;
d319 1
a319 1
		d->character->glad_tot_bet = 0;
d394 1
a394 1
         if ( d->character->glad_bet_amt != 0 )
d452 1
a452 1
   if ( ch->glad_bet_amt != 0 && ch->glad_bet_on != ch )
d542 1
a542 1
     if (ch->glad_bet_on)
d545 5
a549 5
       ch->gold += ch->glad_bet_amt;
       ch->glad_bet_on->glad_tot_bet -= ch->glad_bet_amt;
       ch->glad_bet_on = ch;
       gladiator_info.bet_total -= ch->glad_bet_amt;
       ch->glad_bet_amt = 0;
d559 1
a559 1
    if(!str_cmp(arg1, "show") && ch->glad_bet_on != 0)
d561 1
a561 1
    sprintf(buf,"You have placed a bet of %d gold on %s.\n\r", ch->glad_bet_amt, ch->glad_bet_on->name);
d568 1
a568 1
  if (ch->glad_bet_amt != 0)
d625 1
a625 1
  ch->glad_bet_amt = amount;
d627 1
a627 1
  ch->glad_bet_on = victim;
d629 1
a629 1
  victim->glad_tot_bet += amount;
d649 1
a649 1
 if ( bettor->glad_bet_on == winner  && bettor->glad_bet_amt > 0 )
d677 1
a677 1
   payout = bettor->glad_bet_amt * this_odds ;
d684 1
a684 1
   sprintf(buf,"Your bet on %s was a waste of money.  God they suck!  Better luck next time. \n\r", bettor->glad_bet_on->name);
d688 1
a688 1
   sprintf(buf, "Paid out %d to %s, on bet of %d, winner: %s", payout, bettor->name, bettor->glad_bet_amt, winner->name);
@


1.93
log
@add check for pktimer to join glads.
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.92 2001/10/24 22:19:49 poquah Exp $";
d361 1
a361 1
      ch->gladiator_data[GLADIATOR_VICTORIES] += 1;
d392 1
a392 1
	       d->character->gladiator_data[GLADIATOR_TEAM_VICTORIES] += 1;
d483 2
a484 2
      gladiator_info.total_plays += ch->gladiator_data[GLADIATOR_PLAYS];
      gladiator_info.total_wins += ch->gladiator_data[GLADIATOR_VICTORIES];
d655 2
a656 2
    if( winner->gladiator_data[GLADIATOR_VICTORIES] -1  != 0  &&
	winner->gladiator_data[GLADIATOR_PLAYS] >= 1 )
d662 2
a663 2
       thiswinloss = ((winner->gladiator_data[GLADIATOR_VICTORIES] -1 )* 100 /
		     winner->gladiator_data[GLADIATOR_PLAYS] );
d821 1
a821 1
               d->character->gladiator_data[GLADIATOR_PLAYS]++;
d823 1
a823 1
               d->character->gladiator_data[GLADIATOR_TEAM_PLAYS]++;
d1073 1
a1073 1
         ch->gladiator_data[GLADIATOR_KILLS] += 1;
d1095 1
a1095 1
      ch->gladiator_data[GLADIATOR_TEAM_KILLS] += 1;
d1140 2
a1141 2
	     if( d->character->gladiator_data[GLADIATOR_VICTORIES] != 0  &&
		 d->character->gladiator_data[GLADIATOR_PLAYS] >= 1)
d1147 2
a1148 2
	       thiswinloss = (d->character->gladiator_data[GLADIATOR_VICTORIES] * 100  /
			     d->character->gladiator_data[GLADIATOR_PLAYS]);
d1165 2
a1166 2
	     buf2, d->character->gladiator_data[GLADIATOR_PLAYS],
	     d->character->gladiator_data[GLADIATOR_VICTORIES]);
@


1.92
log
@putting glads back in, still working on re-write though
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.91 2001/07/16 22:10:38 poquah Exp $";
d439 5
@


1.91
log
@working on new glad types, gladitors turned off for now
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.90 2001/05/16 14:37:16 poquah Exp $";
a58 3

   send_to_char("Gladiator is under construction, new types coming in.\n\r",ch);
   return;
@


1.90
log
@walking through new checking in process, changed a comment line :)
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.89 2000/11/27 16:39:49 mud Exp $";
d60 3
d94 1
a94 1
   if ( i1 < 1 || i1 > 4 || i2 <= 0 || i2 > 51 
d103 2
d117 1
a117 1
   if (i1 == 3 || i1 == 4)
d138 1
a138 1

@


1.89
log
@put people to sleep after gladiator
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.88 2000/10/14 23:36:25 mud Exp $";
d20 1
a20 1
/* command procedures needed */
@


1.88
log
@maximum gbet of 500
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.87 2000/09/17 20:31:19 mud Exp $";
d195 1
d324 1
d380 1
d889 1
d1055 1
@


1.87
log
@restore winners sac points as well
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.86 2000/09/17 20:27:06 mud Exp $";
d606 6
@


1.86
log
@restore victims sac points
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.85 2000/08/02 16:14:11 mud Exp $";
d379 6
@


1.85
log
@ More bug fixes for odds
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.84 2000/08/02 13:59:01 mud Exp $";
d1039 5
@


1.84
log
@ found last(I hope) bug in betting
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.83 2000/08/02 13:40:40 mud Exp $";
d652 1
a652 1
       this_odds = URANGE(1, odds, 99);
@


1.83
log
@ more changes to betting code
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.82 2000/07/28 16:57:35 mud Exp $";
d624 2
a625 2
 avg_level = (gladiator_info.num_of_glads /
	     gladiator_info.total_levels ) ;
d629 1
a629 1
    odds =( gladiator_info.num_of_glads *avg_level  * 100 /
a652 1
      this_odds = odds;
@


1.82
log
@ more changes to betting code
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.81 2000/07/28 15:44:45 mud Exp $";
d629 1
a629 1
    odds =( gladiator_info.num_of_glads *avg_level  /
d636 1
a636 1
       winlossavg = (gladiator_info.total_wins /
a638 1
       winlossavg = UMAX(1, winlossavg);
d640 1
a640 1
       thiswinloss = (winner->gladiator_data[GLADIATOR_VICTORIES] -1 /
d643 1
a643 1
       gladadj = (thiswinloss / winlossavg) ;
d645 1
a645 3
       gladadj = UMAX(1, gladadj);

       this_odds = ((odds/2) + ((odds/2)/gladadj));
d1132 1
a1132 1
	       odds=  URANGE(1, odds, 99);
@


1.81
log
@ test of new code for glad betting
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.80 2000/07/25 12:50:21 mud Exp $";
d1103 1
a1103 1
    avg_level = (gladiator_info.num_of_glads  * 100 )/ gladiator_info.total_levels;   
d1125 1
a1125 1
	       gladadj = (thiswinloss  / winlossavg);
d1128 1
a1128 1
	       this_odds = ((odds/2) + ((odds/2)/gladadj));
@


1.80
log
@ more fiixes for div by zero errors
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.79 2000/07/25 00:48:46 mud Exp $";
d1103 1
a1103 1
    avg_level = (gladiator_info.num_of_glads / gladiator_info.total_levels);   
a1113 1
	     odds = UMAX(1, odds);
d1118 2
a1119 2
	       winlossavg = (gladiator_info.total_wins /
			    gladiator_info.total_plays);
a1120 1
               winlossavg = UMAX(1, winlossavg);
d1122 1
a1122 1
	       thiswinloss = (d->character->gladiator_data[GLADIATOR_VICTORIES] /
d1125 1
a1125 1
	       gladadj = (thiswinloss / winlossavg);
a1126 1
	       gladadj = UMAX(1, gladadj);
@


1.79
log
@ fixed Poq's attempt at fixing the wholist
 I hope I fixed div by 0 error
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.78 2000/07/25 00:18:19 mud Exp $";
d633 2
a634 1
    if( winner->gladiator_data[GLADIATOR_VICTORIES] -1  != 0)
d638 2
d642 1
a642 1
		     winner->gladiator_data[GLADIATOR_PLAYS] -1);
d645 2
d1113 2
d1116 2
a1117 2

	     if( d->character->gladiator_data[GLADIATOR_VICTORIES] != 0)
d1122 2
d1128 2
@


1.78
log
@ another div by 0 bug
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.77 2000/07/25 00:03:48 mud Exp $";
d625 1
a625 1
	     gladiator_info.total_levels ) *100;
d629 3
a631 2
    odds =( gladiator_info.num_of_glads /
          ( (winner->level)*100  / avg_level ))* 100;
d636 1
a636 1
		    gladiator_info.total_plays)*100;
d639 1
a639 1
		     winner->gladiator_data[GLADIATOR_PLAYS] -1)*100;
d641 5
a645 1
       gladadj = (thiswinloss / winlossavg) *100;
a646 2
       this_odds = ((odds/2) + ((odds/2)/gladadj))*100;
	       
d650 1
d654 1
a654 1
   payout = bettor->glad_bet_amt *( this_odds /100);
d656 1
a656 1
   sprintf(buf,"Your bet on %s came through, at %d odds.  You won %d gold!!!!\n\r", winner->name,this_odds/100, payout);
d1098 1
a1098 1
    avg_level = (gladiator_info.num_of_glads / gladiator_info.total_levels)*100;   
d1107 1
a1107 1
		   ( d->character->level*100) )*100;
d1113 1
a1113 1
			    gladiator_info.total_plays)*100;
d1116 1
a1116 1
			     d->character->gladiator_data[GLADIATOR_PLAYS])*100;
d1118 4
a1121 1
	       gladadj = (thiswinloss / winlossavg)*100;
d1123 1
a1123 3
	       this_odds = ((odds/2) + ((odds/2)/gladadj))*100;
	       
	       sprintf(buf2, "%7d :1", this_odds/100);
d1127 2
a1128 1
	       sprintf(buf2, "%7d :1", odds/100);
@


1.77
log
@ found bug, fixed
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.76 2000/07/24 23:54:26 mud Exp $";
d1102 2
a1103 2
             odds = (gladiator_info.num_of_glads /
		   ( d->character->level*100 / avg_level ))*100;
@


1.76
log
@ another try to fix div by 0 error
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.75 2000/07/24 23:31:40 mud Exp $";
d148 4
@


1.75
log
@ fixed another division by 0 bug
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.74 2000/07/24 19:44:26 mud Exp $";
d1083 1
a1083 1
   if ( gladiator_info.num_of_glads == 0 )
@


1.74
log
@restore a gladitor on removal
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.73 2000/07/24 18:15:34 mud Exp $";
d1082 6
@


1.73
log
@ i adjusting odds clacs
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.72 2000/07/24 18:08:25 mud Exp $";
d187 5
@


1.72
log
@ adjusted payout calcs to use integer math and 2 decimal places
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.71 2000/07/24 16:32:09 mud Exp $";
d1079 1
a1079 1
    avg_level = gladiator_info.num_of_glads / gladiator_info.total_levels;   
d1087 2
a1088 2
             odds = gladiator_info.num_of_glads /
		   ( d->character->level / avg_level );
d1093 2
a1094 2
	       winlossavg = gladiator_info.total_wins /
			    gladiator_info.total_plays;
d1096 2
a1097 2
	       thiswinloss = d->character->gladiator_data[GLADIATOR_VICTORIES] /
			     d->character->gladiator_data[GLADIATOR_PLAYS];
d1099 1
a1099 1
	       gladadj = thiswinloss / winlossavg;
d1101 1
a1101 1
	       this_odds = (odds/2)*(1 + (1/gladadj));
d1103 1
a1103 1
	       sprintf(buf2, "%7d :1", this_odds);
d1107 1
a1107 1
	       sprintf(buf2, "%7d :1", odds);
@


1.71
log
@ still fixing div by 0 in resolve
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.70 2000/07/24 16:24:08 mud Exp $";
d615 2
a616 2
 avg_level = gladiator_info.num_of_glads /
	     gladiator_info.total_levels ;
d620 2
a621 2
    odds = gladiator_info.num_of_glads /
          ( winner->level / avg_level );
d625 2
a626 2
       winlossavg = gladiator_info.total_wins /
		    gladiator_info.total_plays;
d628 2
a629 2
       thiswinloss = winner->gladiator_data[GLADIATOR_VICTORIES] -1 /
		     winner->gladiator_data[GLADIATOR_PLAYS] -1;
d631 1
a631 1
       gladadj = thiswinloss / winlossavg;
d633 1
a633 1
       this_odds = (odds/2)*(1 + (1/gladadj));
d641 1
a641 1
   payout = bettor->glad_bet_amt + (bettor->glad_bet_amt * this_odds );
d643 1
a643 1
   sprintf(buf,"Your bet on %s came through, at %d odds.  You won %d gold!!!!\n\r", winner->name,odds, payout);
@


1.70
log
@ removed division by 0 error in glad bet resolve
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.69 2000/07/24 15:50:08 mud Exp $";
d615 2
a616 2
 avg_level = gladiator_info.total_levels /
	     gladiator_info.num_of_glads ;
@


1.69
log
@ modified betting algorithm.  now use handicapping
 took out Poq's small modifiction to DWEEB flag
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.68 2000/07/22 00:23:59 mud Exp $";
d208 1
d478 1
d1005 1
@


1.68
log
@remove debug code
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.67 2000/07/21 23:32:26 mud Exp $";
d397 3
d456 3
d607 1
a607 1
 int odds, payout= 0;
d609 6
a614 2
 int tot_bet = 0;
 int denom;
d618 24
a641 9
   tot_bet = winner->glad_tot_bet;
   tot_bet += 1;
   denom = winner->gladiator_data[GLADIATOR_VICTORIES] +
	   (winner->gladiator_data[GLADIATOR_KILLS] / 10);
   denom = UMAX(denom, 1);
   odds = winner->gladiator_data[GLADIATOR_PLAYS] / denom;
   odds = URANGE(1,odds,99);
   payout = ((bettor->glad_bet_amt)*odds);
   sprintf(buf,"Your bet on %s came through, at %d:1 odds.  You won %d gold!!!!\n\r", winner->name,odds, payout);
d842 3
d875 1
a875 1
      {
a1064 2
  int total =0;
  int tot_bet = 0;
d1066 2
d1076 2
a1077 2
    total = gladiator_info.bet_total;
    
d1084 22
a1105 7
	     tot_bet = d->character->glad_tot_bet;
	     tot_bet += 1;
	     this_odds =( d->character->gladiator_data[GLADIATOR_PLAYS]/
			 1 + d->character->gladiator_data[GLADIATOR_VICTORIES] +
			 ( d->character->gladiator_data[GLADIATOR_KILLS] /10));
             this_odds = URANGE(1,this_odds,99);
        
a1106 1
	     sprintf(buf2, "%7d :1", this_odds);
@


1.67
log
@increase gladiator_data to 6, maybe thats it
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.66 2000/07/21 22:57:03 mud Exp $";
a300 2
 sprintf(buf, "2: %d events!",ch->gladiator_data[GLADIATOR_TEAM_PLAYS]);
 send_to_char(buf,ch);
a302 2
 sprintf(buf, "3: %d events!",ch->gladiator_data[GLADIATOR_TEAM_PLAYS]);
 send_to_char(buf,ch);
@


1.66
log
@more debuggigng
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.65 2000/07/21 22:43:53 mud Exp $";
a281 2
 sprintf(buf, "1: %d events!",ch->gladiator_data[GLADIATOR_TEAM_PLAYS]);
 send_to_char(buf,ch);
a296 2
 sprintf(buf, "2: %d events!",ch->gladiator_data[GLADIATOR_TEAM_PLAYS]);
 send_to_char(buf,ch);
d301 1
a301 1
 sprintf(buf, "2.5: %d events!",ch->gladiator_data[GLADIATOR_TEAM_PLAYS]);
a302 1
 /*
a304 1
	     */
a309 2
 sprintf(buf, "4: %d events!",ch->gladiator_data[GLADIATOR_TEAM_PLAYS]);
 send_to_char(buf,ch);
a323 2
 sprintf(buf, "5: %d events!",ch->gladiator_data[GLADIATOR_TEAM_PLAYS]);
 send_to_char(buf,ch);
@


1.65
log
@continue the debug
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.64 2000/07/21 22:36:49 mud Exp $";
d307 1
d310 1
@


1.64
log
@debug glad prob
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.63 2000/07/21 22:24:48 mud Exp $";
d305 2
@


1.63
log
@hunting on gladiator team events
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.62 2000/07/21 17:34:21 mud Exp $";
d282 2
d299 2
d307 2
d312 2
d328 2
@


1.62
log
@ fixed another bug with glads quitting and bet refunding
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.61 2000/07/21 00:46:58 mud Exp $";
d757 4
a760 1
            d->character->gladiator_data[GLADIATOR_PLAYS]++;
@


1.61
log
@gladiators slept do not drift into tigers
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.60 2000/07/18 19:14:36 mud Exp $";
d396 1
@


1.60
log
@ glad winners will now get 10% of total amount bet
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.59 2000/07/18 19:04:52 mud Exp $";
d851 1
@


1.59
log
@ changed calculation of gladiator payouts
 now based on wins, plays, kills instead of betting amounts
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.58 2000/07/18 00:30:42 mud Exp $";
d343 1
d346 1
d348 5
a352 1

@


1.58
log
@fix gstatus to display more then just one char
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.57 2000/07/18 00:14:49 mud Exp $";
d597 1
a597 2
 int total = gladiator_info.bet_total;
 //odds = UMAX((gladiator_info.bet_total/(winner->glad_tot_bet +1 )), 1);
d603 5
a607 1
   odds = URANGE(1,total/tot_bet,99);
a610 2
   sprintf(buf, "Paid out %d to %s, on bet of %d, winner: %s", payout, bettor->name, bettor->glad_bet_amt, winner->name);
   log_string(buf);
d618 2
d1047 4
a1050 1
             this_odds = URANGE(1,total/tot_bet,99);
@


1.57
log
@changed gstat to gstatus
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.56 2000/07/18 00:05:57 mud Exp $";
d1065 1
d1081 1
d1088 7
a1094 1
            strcpy( buf, d->character->name);
@


1.56
log
@tweak gstat to only work if event is running
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.55 2000/07/18 00:01:03 mud Exp $";
d32 1
a32 1
DECLARE_DO_FUN(do_gstat);
d1062 1
a1062 1
void do_gstat( CHAR_DATA *ch, char *argument)
@


1.55
log
@adding gstat command
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.54 2000/07/17 22:18:55 mud Exp $";
d1071 6
@


1.54
log
@Convert act_new() $n and $N to $l $L
-Rusty
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.53 2000/07/17 21:48:56 mud Exp $";
d32 1
d1059 51
@


1.53
log
@s/log_buf/log_string/g
-Rusty
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.52 2000/07/17 21:43:58 mud Exp $";
d452 1
a452 1
      if (gladiator_info.blind == TRUE)
d454 7
a460 2
         free_string( ch->long_descr );                                        
         ch->long_descr = str_dup( "A Gladiator" ); 
a461 1
      act("$n arrives to prove his worth!", ch, NULL, NULL, TO_ROOM,FALSE);
d660 1
a660 1
      if(gladiator_info.blind == TRUE)
@


1.52
log
@Changes to add debugging to Gladiator messages for finding
blind problems.
-Rusty
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.51 2000/07/16 19:15:06 mud Exp $";
d151 1
a151 1
      log_buf(arg5);
d156 1
a156 1
      log_buf(arg5);
d164 1
a164 1
   log_buf(buf);
@


1.51
log
@bug fix glad
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.50 2000/07/13 02:12:30 mud Exp $";
d149 1
d151 2
d154 1
d156 2
d159 4
a162 1
   sprintf(buf, "Gladiator combat started for levels %d to %d.  Type 'GLADIATOR' to join. Read 'help gladiator' for more info.", gladiator_info.min_level, gladiator_info.max_level);
d164 1
@


1.50
log
@move define gladiator up to not have bug
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.49 2000/07/13 02:04:15 mud Exp $";
d969 2
a970 1
      ch->gladiator_data[GLADIATOR_KILLS] += 1;
d974 13
a986 4
         sprintf(buf, "%s is victorious in the arena!", ch->name);
         gladiator_talk(buf); 

         gladiator_winner(ch);
@


1.49
log
@missing closing }
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.48 2000/07/13 02:02:42 mud Exp $";
a441 4
      act("$n arrives to prove his worth!", ch, NULL, NULL, TO_ROOM,FALSE);
      gladiator_info.playing++;
      die_follower(ch);
      affect_strip(ch,gsn_sneak);
d447 4
@


1.48
log
@displey blind or not in announcemnets
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.47 2000/07/13 01:57:45 mud Exp $";
d663 1
@


1.47
log
@fix blind events for team glads
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.46 2000/07/12 22:54:08 mud Exp $";
d646 20
d681 1
@


1.46
log
@fix blind/noblind setting, and attempt to not have you hit yourself as glad.
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.45 2000/07/12 22:22:15 mud Exp $";
d725 5
d731 1
d733 6
@


1.45
log
@working on blind glad matches
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.44 2000/07/11 03:57:56 mud Exp $";
d148 1
a148 1
   if (strcmp(arg5,"blind"))
d449 1
a449 1
         ch->long_descr = str_dup( "A Gladiator is here." ); 
@


1.44
log
@ fixed bug in odds, and in gbet show
 :wq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.43 2000/07/08 18:20:31 mud Exp $";
d446 5
@


1.43
log
@ fixed bug with max odds
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.42 2000/07/08 05:10:27 mud Exp $";
d502 1
d504 1
d584 1
a584 1
   odds = UMIN(UMAX(total/tot_bet,1),99);
d980 1
a980 1
             this_odds = UMIN(UMAX(total/tot_bet,1), 99);
@


1.42
log
@ maxed odds at 99:1,
 added in some log lines
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.41 2000/07/08 05:05:08 mud Exp $";
d451 1
d582 1
a582 1
   odds = UMAX(UMAX(total/tot_bet,1),99);
d978 1
a978 1
             this_odds = UMAX(UMAX(total/tot_bet,1), 99);
@


1.41
log
@ fixed bug win betting -ve amount of gold
 added in gbet show
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.40 2000/07/07 21:44:18 mud Exp $";
d581 1
a581 1
   odds = UMAX(total/tot_bet,1);
d977 1
a977 1
             this_odds = UMAX(total/tot_bet,1);
@


1.40
log
@ fixed bugs in gbet, added in some log line
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.39 2000/07/04 17:50:18 mud Exp $";
d498 7
d543 6
@


1.39
log
@ no level restrictions on trans'ing mobs, still there for transing PC's

 modified potion costs for alchemists

 fixed a couple bugs in gladiator betting.
 added in check to stop betting when event is a team event
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.38 2000/06/30 00:01:30 mud Exp $";
d475 1
a475 1
     if (gladiator_info.started == TRUE && gladiator_info.time_left < 1)
d551 2
d572 2
@


1.38
log
@was an extra bracket in gbet
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.37 2000/06/29 22:17:58 mud Exp $";
d264 1
a264 1
       gladiator_winner(ch);
d291 1
a294 1
		d->character->glad_bet_on = d->character;
d466 7
a473 1
   if (ch->glad_bet_on)
d475 22
a496 13
   send_to_char("Bet cleared.\n\r", ch);
   ch->gold += ch->glad_bet_amt;
   ch->glad_bet_on->glad_tot_bet -= ch->glad_bet_amt;
   ch->glad_bet_on = ch;
   gladiator_info.bet_total -= ch->glad_bet_amt;
   ch->glad_bet_amt = 0;
   return;
   }
   else
   {
   send_to_char("You have no bet to clear!!\n\r", ch);
   return;
   }
d528 2
a529 1
   if (gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
d963 1
a963 1
	     sprintf(buf2, "%-7d :1", this_odds);
@


1.37
log
@ fixed payout, was paying too much
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.36 2000/06/29 22:10:46 mud Exp $";
a464 2

  }
@


1.36
log
@ put last change in the wrong sopt...fixed.
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.35 2000/06/29 21:29:30 mud Exp $";
d553 1
a553 1
   payout = ((bettor->glad_bet_amt)*odds)+ bettor->glad_bet_amt;
@


1.35
log
@ removed stupid Guerrand asskicking skill
 Fixed bug that didn't refund money when you change bets
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.34 2000/06/29 18:38:21 mud Exp $";
a465 4
  if (ch->glad_bet_amt != 0)
  {
  send_to_char("You must clear your current bet before betting again.\n\r", ch);
  return;
d485 6
@


1.34
log
@ More bug fiexes in gladiator betting resolution
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.33 2000/06/29 17:53:10 mud Exp $";
d466 6
d478 1
@


1.33
log
@ Fixed some bugs in gladiator betting
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.32 2000/06/29 15:48:33 mud Exp $";
d535 3
a537 2

 odds = UMAX((gladiator_info.bet_total/(winner->glad_tot_bet +1 )), 1);
d541 3
d545 1
a545 1
   sprintf(buf,"Your bet on %s came through, you won %d gold!!!!\n\r", winner->name, payout);
@


1.32
log
@ added in fix for bettor not getting right amount for winning
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.31 2000/06/29 15:41:55 mud Exp $";
d282 1
d290 2
d294 2
@


1.31
log
@ removal of CODE_TEST ifdef's
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.30 2000/06/29 15:41:09 mud Exp $";
d535 1
a535 1
   payout = (bettor->glad_bet_amt)*odds;
@


1.30
log
@ Final changes to bet code
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.29 2000/06/29 15:28:24 mud Exp $";
a901 1
#ifdef CODE_TEST
a942 1
#endif
@


1.29
log
@ still fixing bugs in betting code
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.28 2000/06/29 15:24:30 mud Exp $";
d528 1
a528 1
 int odds;
d531 1
a531 1
 odds = 2; // for now, pay out 1:1
d535 3
a537 2
   bettor->gold += (bettor->glad_bet_amt)*(gladiator_info.bet_total/(winner->glad_tot_bet +1 ));
   sprintf(buf,"Your bet on %s came through, you won %d gold!!!!\n\r", winner->name, bettor->glad_bet_amt);
d929 2
a930 1
             this_odds = total/tot_bet;
@


1.28
log
@ Added total bets into gbet
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.27 2000/06/29 15:19:21 mud Exp $";
d519 1
@


1.27
log
@ Another attmept to fix odds();
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.26 2000/06/29 14:56:19 mud Exp $";
d518 1
@


1.26
log
@ Attmept to fix bug in do_odds
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.25 2000/06/29 02:45:40 mud Exp $";
d906 3
d917 2
a918 1
      for(d = descriptor_list; d != NULL; d = d->next)
d924 5
a928 1
	     sprintf(buf2, "%8d:1", total/(d->character->glad_tot_bet+1));
@


1.25
log
@ added in codetest flags in do_odds until I get it working
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.24 2000/06/29 02:37:22 mud Exp $";
d533 1
a533 1
   bettor->gold += (bettor->glad_bet_amt)*(gladiator_info.bet_total/winner->glad_tot_bet);
d903 1
a903 1
  char buf1[MAX_STRING_LENGTH];
d912 1
a912 1
    sprintf(buf, "%-10s\t%-10s\t%-10s\t%-10s\n\r", "NAME", "ODDS", "PLAYED", "WON"); 
d920 2
a921 2
	     sprintf(buf2, "%8d:1", total/d->character->glad_tot_bet);
             sprintf(buf1, "%-10s\t%-10s\t%-10d\t%-10d\n\r" ,d->character->name,
@


1.24
log
@ added odds calculation to bet winnings
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.23 2000/06/29 02:04:34 mud Exp $";
d899 1
d932 1
@


1.23
log
@ Added in gladiator betting, with dynamic odds calculation
 -Rage
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.22 2000/06/28 22:25:45 mud Exp $";
d533 1
a533 1
   bettor->gold += (bettor->glad_bet_amt)*odds;
d905 6
@


1.22
log
@declare do_stand
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.21 2000/06/28 22:23:36 mud Exp $";
d31 1
d462 1
d466 2
d469 6
d895 30
@


1.21
log
@more more gladiator
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.20 2000/06/28 21:44:16 mud Exp $";
d30 1
d345 1
a345 1
            victim->pcdata->quit_time = 0; 
@


1.20
log
@fixing ties in team glad
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.19 2000/06/28 20:46:04 mud Exp $";
d341 4
d660 4
a663 1
            do_look(d->character, "auto");
d859 1
@


1.19
log
@small glad changes
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.18 2000/06/28 00:57:12 mud Exp $";
d746 1
a746 1
	 gladiator_info.team_counter == 2;
@


1.18
log
@gladiator stuff
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.17 2000/06/27 03:33:35 mud Exp $";
d229 1
d295 2
d309 6
d721 1
@


1.17
log
@fix commands
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.16 2000/06/26 06:39:42 mud Exp $";
d309 1
a319 12
   gladiator_info.started = FALSE;
   gladiator_info.playing = 0;
   gladiator_info.time_left = 0;
   gladiator_info.min_level = 0;
   gladiator_info.max_level = 0;
   gladiator_info.type = 0;
   gladiator_info.team_counter = 0;
   gladiator_info.blind = FALSE;
   gladiator_info.gladiator_score = 0;
   gladiator_info.barbarian_score = 0;
   gladiator_info.bet_counter = 0;

d347 13
d416 1
d705 1
d734 8
d744 1
a744 1
         sprintf(buf, "The Gladiators are victorious!.\n\r");  
d749 1
a749 1
         sprintf(buf, "The Barbarians are victorious!.\n\r");  
d760 1
a760 2
sprintf(buf,"Checking %s as team %d against winner %d",d->character->name,d->character->pcdata->gladiator_team, team_select); 
gladiator_talk(buf);
a762 2
sprintf(buf,"Sending %s into gladiator_winner",d->character->name); 
gladiator_talk(buf);
@


1.16
log
@itweaking gladiator
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.15 2000/06/26 06:24:51 mud Exp $";
d28 2
a44 2
void    gscore args( (CHAR_DATA *ch));
void    skipbet args( (CHAR_DATA *ch));
d302 1
a302 1
void do_skipbet( CHAR_DATA *ch )
d764 1
a764 1
void do_gscore( CHAR_DATA *ch )
@


1.15
log
@add gscore and skipbet, and display ticks left in gscore
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.14 2000/06/26 05:16:40 mud Exp $";
a27 2
DECLARE_DO_FUN(do_skipbet);
DECLARE_DO_FUN(do_gscore);
d43 2
d302 1
a302 1
void do_skipbet( CHAR_DATA *ch, char *argument )
d304 2
@


1.14
log
@team glad assign temp clan
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.13 2000/06/25 23:36:09 mud Exp $";
d28 2
d302 8
d760 14
@


1.13
log
@fix stat to show glad stats, adjust glad_plays counter it may not be working
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.12 2000/06/19 00:07:39 mud Exp $";
d402 2
a403 1
      if (gladiator_info.type == 2 && !is_clan(ch))
@


1.12
log
@fix gladiaotr score being backwards
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.11 2000/05/30 23:51:06 mud Exp $";
d610 1
a610 1
            d->character->gladiator_data[GLADIATOR_PLAYS] += 1;
@


1.11
log
@attempt to fix glad crash bug?
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.10 2000/05/30 00:26:42 mud Exp $";
d824 1
a824 1
      if(victim->pcdata->gladiator_team == 1)
@


1.10
log
@add team stats to kr, score and stat
clean up bugs in team code
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.9 2000/05/29 23:28:41 mud Exp $";
d742 1
a742 1
                  d = NULL;
@


1.9
log
@declare random
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.8 2000/05/29 23:26:36 mud Exp $";
d332 1
a332 1
         && ch->pcdata->gladiator_team == d->character->pcdata->gladiator_team)
d335 2
a336 2
	 if ( d->character->glad_bet_amt != 0 )
	   {
d735 2
d739 2
d794 6
a799 3
   REMOVE_BIT(victim->mhs, MHS_GLADIATOR);
   victim->clan = victim->pcdata->save_clan;
   victim->pcdata->save_clan = 0;
@


1.8
log
@bugs in gladiator
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.7 2000/05/29 23:22:38 mud Exp $";
d592 1
@


1.7
log
@declare local functions
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.6 2000/05/29 23:18:28 mud Exp $";
a506 6
   char buf[MAX_STRING_LENGTH];
   DESCRIPTOR_DATA *d;
   ROOM_INDEX_DATA *random;
   sh_int time;
   sh_int team_select;

d526 1
d592 1
d673 1
d707 1
@


1.6
log
@modularizing gladiator
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.5 2000/05/29 19:57:29 mud Exp $";
d38 5
@


1.5
log
@clean up some errors in gladitor
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.4 2000/05/29 19:53:44 mud Exp $";
d508 24
a531 1
   if (gladiator_info.time_left > 0)
d533 2
a534 2
      time = gladiator_info.time_left - 1;
      if (time > 0)
d536 1
a536 2
         sprintf(buf, "%d tick%s left to join the Gladiator Combat. Read 'help gladiator' for more info.", time, time == 1 ? "" : "s");
         for ( d = descriptor_list; d; d = d->next )
d538 2
a539 5
            if ( d->connected == CON_PLAYING )
            {
                 send_to_char( buf, d->character );
                 send_to_char( "\n\r",   d->character );
            }
d541 1
d543 2
a544 2
         sprintf(buf, "%d %s %s signed up to fight in the Arena so far.", gladiator_info.playing, gladiator_info.playing == 1 ? "Gladiator" : "Gladiators", gladiator_info.playing == 1 ? "is" : "are");
         gladiator_talk(buf);
d546 23
a568 16
         if (gladiator_info.type == 1)
         {
            sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Single Combat.", gladiator_info.min_level, gladiator_info.max_level);
         }
         if (gladiator_info.type == 2)
         {
            sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Single Combat.", gladiator_info.min_level, gladiator_info.max_level);
         }
         if (gladiator_info.type == 3)
         {
            sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Team Combat.", gladiator_info.min_level, gladiator_info.max_level);
         }
         if (gladiator_info.type == 4)
         {
            sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Team Combat.", gladiator_info.min_level, gladiator_info.max_level);
         }
d570 2
d574 28
a601 2
      {  
         if (gladiator_info.playing < 2)
d603 6
a608 2
            sprintf(buf, "Not enough people for the Event.  Gladiator Combat ended.");
            gladiator_talk(buf);
d610 2
a611 9
            gladiator_info.started = FALSE;
            gladiator_info.time_left = 0;
            gladiator_info.min_level = 0;
            gladiator_info.max_level = 0;
            gladiator_info.type = 0;
            gladiator_info.playing = 0;
	    gladiator_info.team_counter = 0;
	    gladiator_info.blind = FALSE;
	    gladiator_info.bet_counter = 0;
d613 1
a613 1
            for(d = descriptor_list; d != NULL; d = d->next)
d615 10
a624 12
	       if (d->character != NULL)
	       {
               if (IS_SET(d->character->mhs, MHS_GLADIATOR))
               {
                  char_from_room(d->character);
                  char_to_room(d->character, get_room_index(clan_table[d->character->clan].hall));
                  d->character->clan = d->character->pcdata->save_clan;
                  d->character->pcdata->save_clan = 0;
                  REMOVE_BIT(d->character->mhs,MHS_GLADIATOR);
                  do_look(d->character, "auto");
               }
	       }
d626 4
a629 1
	    return;
d631 25
a655 1
         else
d657 6
a662 40
            sprintf(buf, "The battle begins! %d Gladiators are fighting!", gladiator_info.playing);
            gladiator_talk(buf);

            team_select = 1;
            for(d = descriptor_list; d != NULL; d = d->next)
            {
	       if (d->character != NULL)
	       {
               if (IS_SET(d->character->mhs, MHS_GLADIATOR))
               {
                  d->character->hit  = d->character->max_hit;
                  d->character->mana = d->character->max_mana;
                  d->character->move = d->character->max_move;
		  d->character->pcdata->gladiator_attack_timer = 5;
                  update_pos(d->character);
                  d->character->gladiator_data[GLADIATOR_PLAYS] += 1;

                  /* Default random to single player range */
                  random = get_room_index(number_range(10800,10819));

		  if (gladiator_info.type == 3 || gladiator_info.type == 4)
		  {
		     d->character->pcdata->gladiator_team = team_select;
		     if(team_select == 1)
		        team_select = 2; 
		     else
			team_select = 1;

		     if(d->character->pcdata->gladiator_team == 1)
			random = get_room_index(ROOM_VNUM_TEAM_GLADIATOR);
		     else
			random = get_room_index(ROOM_VNUM_TEAM_BARBARIAN);
		  }

                  char_from_room(d->character);
                  char_to_room(d->character, random);
                  do_look(d->character, "auto");
               }
	       }
	    }
a664 1
      gladiator_info.time_left--;
d666 11
a676 1
   else
d678 1
a678 1
      if (gladiator_info.started == TRUE)
d680 4
a683 6
	 if(gladiator_info.type == 1 || gladiator_info.type == 2)
	 {
            sprintf(buf, "The battle rages on with %d Gladiators still remaining.", gladiator_info.playing);
            gladiator_talk(buf);

            for(d = descriptor_list; d != NULL; d = d->next)
d685 4
a688 1
               if (d->character != NULL)
d690 3
a692 16
                  if (IS_SET(d->character->mhs, MHS_GLADIATOR))
                  {
                     d->character->pcdata->gladiator_attack_timer--;
                     if(d->character->pcdata->gladiator_attack_timer == 0)
		     {
		        if (is_affected(d->character,gsn_blindness) ||
			    d->character->pcdata->quit_time != 0)
                           d->character->pcdata->gladiator_attack_timer = 5;
                        else
                        {
                           sprintf(buf, "%s slips into a pit full of tigers, next time %s will be more active.", d->character->name,d->character->name);
                           gladiator_talk(buf);
                           remove_gladiator(d->character);
                        }
                     }
                  }
d694 6
a699 2
            } /* for loop through players */ 
	 } /* if type 1 or 2 */
d701 4
a704 4
	 if (gladiator_info.type == 3 || gladiator_info.type == 4)
	 {
            sprintf(buf, "The current score is: Gladiators %d - Barbarians %d.\n\r",gladiator_info.gladiator_score,gladiator_info.barbarian_score);  
            gladiator_talk(buf);
d706 2
a707 1
	    gladiator_info.team_counter--;
d709 1
a709 6
	    if(gladiator_info.team_counter == 0)
	    {
	       if(gladiator_info.gladiator_score > gladiator_info.barbarian_score)
		  team_select = 1;
	       else
		  team_select = 2;
d711 21
a731 1
               for(d = descriptor_list; d != NULL; d = d->next)
d733 2
a734 11
                  if (d->character != NULL)
                  {
                     if (IS_SET(d->character->mhs, MHS_GLADIATOR))
                     {
                        if(d->character->pcdata->gladiator_team == team_select)
			{
			   gladiator_winner(d->character);
			   d = NULL;
			}
		     }
		  }
d738 1
a738 1
      } /* if event started */
@


1.4
log
@added blind to gladiator_info structure and added do_lookup, do_echo and clan_lookup
to defines in gladiator.c
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.3 2000/05/29 19:48:33 mud Exp $";
d326 1
a326 1
            if (gladiator_info.type == 3 || gladiator_info.type == 4
a328 1

d332 1
a332 1
	     if(gladiator_info.type == 1 || gladiator_info.type = 2)
d597 2
a598 2
		  if (gladiator_info.type == 1 || gladiator_info.type == 2)
                     random = get_room_index(number_range(10800,10819));
@


1.3
log
@declare buf in gladiator_left_arena
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.2 2000/05/29 19:47:12 mud Exp $";
d21 2
d28 5
@


1.2
log
@missing )
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.1 2000/05/29 19:37:04 mud Exp $";
d688 1
@


1.1
log
@adding new gladiator files and tteam gladiator code with gladitor code moved
out of old files.
-poq
@
text
@d2 1
a2 1
static char rcsid[] = "$Id: gladiator.c,v 1.3 2000/04/18 19:51:08 mud Exp $";
d76 1
a76 1
	|| (strcmp(arg5,"blind") && strcmp(arg5,"noblind"))
@
