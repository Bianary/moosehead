head	1.235;
access;
symbols;
locks; strict;
comment	@ * @;


1.235
date	2004.03.27.15.51.41;	author boogums;	state Exp;
branches;
next	1.234;

1.234
date	2003.10.20.20.41.59;	author rusty;	state Exp;
branches;
next	1.233;

1.233
date	2003.10.08.00.49.27;	author ndagger;	state Exp;
branches;
next	1.232;

1.232
date	2003.09.26.04.07.12;	author boogums;	state Exp;
branches;
next	1.231;

1.231
date	2003.05.25.17.41.44;	author boogums;	state Exp;
branches;
next	1.230;

1.230
date	2003.05.25.14.32.21;	author boogums;	state Exp;
branches;
next	1.229;

1.229
date	2003.05.25.01.34.23;	author boogums;	state Exp;
branches;
next	1.228;

1.228
date	2002.11.03.21.11.17;	author boogums;	state Exp;
branches;
next	1.227;

1.227
date	2002.10.02.01.24.41;	author ndagger;	state Exp;
branches;
next	1.226;

1.226
date	2002.09.20.15.21.05;	author boogums;	state Exp;
branches;
next	1.225;

1.225
date	2002.04.21.15.20.08;	author rusty;	state Exp;
branches;
next	1.224;

1.224
date	2002.04.01.21.07.25;	author mud;	state Exp;
branches;
next	1.223;

1.223
date	2002.04.01.21.05.44;	author rusty;	state Exp;
branches;
next	1.222;

1.222
date	2002.03.09.19.14.28;	author rusty;	state Exp;
branches;
next	1.221;

1.221
date	2002.02.26.21.09.52;	author poquah;	state Exp;
branches;
next	1.220;

1.220
date	2002.02.11.20.06.55;	author poquah;	state Exp;
branches;
next	1.219;

1.219
date	2002.02.11.18.38.37;	author poquah;	state Exp;
branches;
next	1.218;

1.218
date	2002.02.11.18.34.10;	author poquah;	state Exp;
branches;
next	1.217;

1.217
date	2001.12.15.02.41.39;	author poquah;	state Exp;
branches;
next	1.216;

1.216
date	2001.12.14.15.48.52;	author poquah;	state Exp;
branches;
next	1.215;

1.215
date	2001.12.13.17.56.23;	author poquah;	state Exp;
branches;
next	1.214;

1.214
date	2001.11.25.01.26.38;	author rusty;	state Exp;
branches;
next	1.213;

1.213
date	2001.11.15.03.10.32;	author poquah;	state Exp;
branches;
next	1.212;

1.212
date	2001.11.10.21.42.16;	author rage;	state Exp;
branches;
next	1.211;

1.211
date	2001.11.10.19.13.43;	author rage;	state Exp;
branches;
next	1.210;

1.210
date	2001.11.10.18.38.25;	author rage;	state Exp;
branches;
next	1.209;

1.209
date	2001.09.23.20.25.04;	author rage;	state Exp;
branches;
next	1.208;

1.208
date	2001.08.30.01.03.23;	author guerrand;	state Exp;
branches;
next	1.207;

1.207
date	2001.08.24.00.42.18;	author guerrand;	state Exp;
branches;
next	1.206;

1.206
date	2001.08.08.05.45.51;	author poquah;	state Exp;
branches;
next	1.205;

1.205
date	2001.07.13.01.57.13;	author guerrand;	state Exp;
branches;
next	1.204;

1.204
date	2001.06.28.03.41.34;	author guerrand;	state Exp;
branches;
next	1.203;

1.203
date	2001.06.18.01.17.32;	author rage;	state Exp;
branches;
next	1.202;

1.202
date	2001.06.18.01.02.33;	author guerrand;	state Exp;
branches;
next	1.201;

1.201
date	2001.06.17.00.10.05;	author guerrand;	state Exp;
branches;
next	1.200;

1.200
date	2001.06.11.03.44.01;	author guerrand;	state Exp;
branches;
next	1.199;

1.199
date	2001.06.11.00.04.03;	author rage;	state Exp;
branches;
next	1.198;

1.198
date	2001.06.10.03.30.10;	author guerrand;	state Exp;
branches;
next	1.197;

1.197
date	2001.06.09.19.34.46;	author guerrand;	state Exp;
branches;
next	1.196;

1.196
date	2001.06.09.06.27.40;	author guerrand;	state Exp;
branches;
next	1.195;

1.195
date	2001.06.09.03.56.59;	author guerrand;	state Exp;
branches;
next	1.194;

1.194
date	2001.06.07.04.15.41;	author guerrand;	state Exp;
branches;
next	1.193;

1.193
date	2001.06.03.22.44.22;	author guerrand;	state Exp;
branches;
next	1.192;

1.192
date	2001.06.03.17.38.39;	author guerrand;	state Exp;
branches;
next	1.191;

1.191
date	2001.06.03.17.15.10;	author guerrand;	state Exp;
branches;
next	1.190;

1.190
date	2001.05.26.00.33.57;	author rage;	state Exp;
branches;
next	1.189;

1.189
date	2001.04.09.18.30.39;	author mud;	state Exp;
branches;
next	1.188;

1.188
date	2001.03.27.19.43.30;	author mud;	state Exp;
branches;
next	1.187;

1.187
date	2001.03.05.20.42.48;	author mud;	state Exp;
branches;
next	1.186;

1.186
date	2001.02.10.17.35.31;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	2001.02.10.17.11.05;	author mud;	state Exp;
branches;
next	1.184;

1.184
date	2001.01.30.16.04.17;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2001.01.24.19.33.35;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	2000.12.15.00.19.05;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	2000.10.25.12.42.08;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	2000.10.23.22.05.57;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	2000.10.17.22.45.34;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	2000.10.07.21.32.08;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	2000.10.07.21.30.52;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	2000.10.07.21.28.57;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	2000.09.13.14.01.50;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	2000.09.11.19.26.31;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	2000.09.11.18.56.26;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	2000.09.10.17.55.44;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	2000.09.02.03.27.37;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	2000.08.29.14.47.28;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	2000.08.29.14.21.56;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	2000.08.29.14.10.30;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	2000.08.29.13.48.57;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	2000.08.28.13.38.07;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	2000.08.25.16.47.06;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	2000.08.23.13.38.05;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	2000.08.23.13.26.27;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	2000.08.18.22.49.03;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	2000.08.17.17.18.01;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	2000.08.17.14.29.28;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	2000.07.25.19.45.32;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	2000.07.25.16.41.15;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	2000.07.25.16.38.13;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	2000.07.21.20.08.04;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	2000.07.21.20.04.43;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	2000.07.18.17.06.29;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	2000.07.14.13.25.29;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	2000.07.12.22.54.09;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	2000.07.12.22.28.40;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	2000.07.12.22.22.16;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	2000.07.12.21.24.57;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	2000.06.29.22.57.50;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	2000.06.18.20.39.28;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	2000.06.18.20.38.05;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	2000.06.18.20.36.05;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	2000.05.24.02.53.27;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	2000.05.20.01.12.21;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	2000.05.16.22.46.11;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	2000.05.16.22.43.23;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	2000.05.16.21.26.29;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	2000.05.16.15.01.30;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	2000.04.22.02.45.33;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	2000.04.18.19.50.59;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	2000.04.18.03.05.07;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	2000.04.17.23.46.56;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	2000.04.17.22.00.49;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	2000.04.17.19.44.59;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	2000.04.17.19.43.11;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	2000.04.15.17.00.34;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	2000.03.23.00.41.36;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	2000.03.20.22.17.15;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	2000.03.18.22.43.40;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	2000.03.18.22.34.17;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	2000.03.18.22.29.13;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	2000.03.18.22.22.13;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	2000.03.18.19.24.15;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	2000.03.18.19.08.33;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	2000.03.18.01.20.35;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	2000.03.18.00.49.22;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	2000.03.16.17.39.14;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	2000.03.15.22.14.33;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	2000.03.15.01.33.36;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	2000.03.15.01.31.19;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2000.03.15.01.17.06;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	2000.03.14.01.43.24;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	2000.03.14.00.30.20;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	2000.03.14.00.28.59;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	2000.03.14.00.25.15;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	2000.03.12.00.32.45;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	2000.03.10.22.21.56;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	2000.03.10.01.32.28;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	2000.03.10.00.18.30;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	2000.03.09.19.33.22;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	2000.03.06.17.40.55;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	2000.03.06.17.35.31;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	2000.03.06.17.24.13;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	2000.03.06.17.00.25;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	2000.03.06.16.53.49;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	2000.03.06.16.18.29;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	2000.03.06.15.59.22;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	2000.03.06.14.36.41;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	2000.03.06.14.34.56;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	2000.03.06.01.44.38;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	2000.03.06.01.09.18;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	2000.03.06.00.23.40;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	2000.02.27.18.16.06;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	2000.02.27.17.21.30;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	2000.02.25.01.57.36;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	2000.02.20.08.30.07;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	2000.02.20.07.50.34;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	2000.02.20.07.45.15;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	2000.02.20.07.12.56;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	2000.02.20.07.04.47;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	2000.02.20.07.02.04;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	2000.02.20.03.46.19;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	2000.02.20.03.25.29;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	2000.02.20.03.13.20;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	2000.02.20.02.56.45;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	2000.02.20.02.38.59;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	2000.02.20.02.15.07;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	2000.02.20.00.36.49;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2000.02.19.18.50.39;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	2000.02.18.08.02.01;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	2000.02.18.07.02.47;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	2000.02.15.21.38.10;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	2000.02.15.21.36.47;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	2000.02.15.20.53.21;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	2000.02.15.15.16.20;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	2000.02.15.15.13.09;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	2000.02.12.22.11.35;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	2000.02.12.21.41.13;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	2000.02.11.20.20.42;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	99.12.17.23.13.40;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	99.11.19.19.26.19;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	99.11.07.00.56.01;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	99.11.02.22.08.25;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	99.10.21.02.22.25;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	99.10.21.02.10.02;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.10.21.02.06.23;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.10.17.23.22.51;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.10.17.22.56.44;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.10.15.21.27.21;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.10.15.20.17.58;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.10.15.01.19.27;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.10.15.01.17.31;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.10.02.00.09.06;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.08.23.03.34.45;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.08.12.01.30.04;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.08.12.01.12.15;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.08.12.01.03.59;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.08.11.04.55.50;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.08.09.22.08.28;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.07.14.18.13.41;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.06.28.06.34.18;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.06.24.02.33.58;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.06.17.15.41.10;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.06.17.15.36.10;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.06.17.15.15.54;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.05.26.03.27.32;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	99.05.16.04.42.55;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.05.13.21.02.19;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.04.26.07.58.15;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.04.24.12.38.53;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	99.04.23.23.43.41;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.04.12.02.54.44;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	99.03.29.19.12.13;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.03.28.09.32.26;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	99.03.27.23.55.33;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	98.12.23.16.51.34;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.12.13.22.51.48;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.12.12.02.44.40;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.12.12.01.36.53;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.12.12.01.20.55;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.12.09.08.50.25;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.12.09.08.32.16;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.12.09.00.33.21;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.12.08.01.54.13;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.12.05.09.29.59;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.12.02.18.51.14;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.12.02.09.06.38;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.11.28.09.21.50;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.11.28.07.49.34;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.11.22.10.36.37;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.11.22.08.45.29;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.11.22.08.04.44;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.10.30.03.01.53;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.10.25.18.42.13;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.10.12.20.57.25;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.10.11.00.13.34;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.08.30.03.33.35;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.08.21.14.21.10;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.20.21.05.32;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.13.05.24.10;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.12.08.20.18;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.10.19.41.23;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.07.20.19.58;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.05.07.30.31;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.07.29.05.32.35;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.24;	author mud;	state Exp;
branches;
next	;


desc
@@


1.235
log
@many changes
@
text
@/**************************************************************************r
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: handler.c,v 1.234 2003/10/20 20:41:59 rusty Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "merc.h"
#include "magic.h"
#include "recycle.h"
#include "tables.h"
#include "gladiator.h"

/* command procedures needed */
DECLARE_DO_FUN(do_return  );
DECLARE_DO_FUN(do_look  );



/*
 * Local functions.
 */
void  affect_modify args( ( CHAR_DATA *ch, AFFECT_DATA *paf, bool fAdd, int AppType ) );
void  destruct_trade args( ( TRADE_DATA *trade, bool ifree ) );
void  add_prev_owner args( ( OBJ_DATA *obj, CHAR_DATA *ch) );
/*
 * External functions.
 */
int	clan_lookup	args( (const char *name) );

void clear_mount( CHAR_DATA *ch )
{
    if ( ch->riding != NULL )
    {
	ch->riding->passenger = NULL;
	ch->riding = NULL;
    }

    if ( ch->passenger != NULL )
    {
	ch->passenger->riding = NULL;
	ch->passenger = NULL;
    }

    return;
}


bool is_mounted( CHAR_DATA *ch )
{
    return ( ch->riding == NULL ? FALSE : TRUE );
}

int get_sac_points( CHAR_DATA *ch, int points )
{
   	int max = 300;

	/* last minute */
	if (IS_NPC(ch))
		return 0;

	points /= 2;

	if ( ch->class == class_lookup("paladin") )
		max *= 2;

	if ( HAS_KIT(ch,"bishop") )
	{
		max += 100;
		points = 5 * points / 3;
	}

	if ( ch->pcdata->sac + points < max )
		return points;
	else
		return ( max - ch->pcdata->sac );
}

void wait_state(CHAR_DATA *ch, int npulse)
{
  if(IS_SET(ch->res_flags,RES_DELAY))
    {
     npulse /= 2;
     REMOVE_BIT(ch->res_flags,RES_DELAY);
    }

  if(is_affected(ch, skill_lookup("speed")))
    {
      if ( !is_affected(ch,gsn_arcantic_alacrity) )
      {
        npulse /= 2;
      }
    }

  ch->wait = (IS_IMMORTAL(ch) ?  0 : UMAX(ch->wait, npulse));
  if(IS_SET(ch->act, PLR_DWEEB))
  {
	// double for DWEEBs
	ch->wait *= 2;
  }
  return;
}

bool has_boat(CHAR_DATA *ch)
{
    OBJ_DATA *obj;
    bool found = FALSE;

    if ( IS_IMMORTAL(ch) )
	found = TRUE;
    else
    {
     for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
       {
     if ( obj->item_type == ITEM_BOAT )
     {
         found = TRUE;
         break;
     }
       }
    }

    return found;
}

/* friend stuff -- for NPC's mostly */
bool is_friend(CHAR_DATA *ch,CHAR_DATA *victim)
{
    if (is_same_group(ch,victim))
  return TRUE;

    
    if (!IS_NPC(ch))
  return FALSE;

    if (!IS_NPC(victim))
    {
  if (IS_SET(ch->off_flags,ASSIST_PLAYERS))
      return TRUE;
  else
      return FALSE;
    }

    if (IS_AFFECTED(ch,AFF_CHARM))
  return FALSE;

    if (IS_SET(ch->off_flags,ASSIST_ALL))
  return TRUE;

    if (ch->group && ch->group == victim->group)
  return TRUE;

    if (IS_SET(ch->off_flags,ASSIST_VNUM) 
    &&  ch->pIndexData == victim->pIndexData)
  return TRUE;

    if (IS_SET(ch->off_flags,ASSIST_RACE) && ch->race == victim->race)
  return TRUE;
     
    if (IS_SET(ch->off_flags,ASSIST_ALIGN)
    &&  !IS_SET(ch->act,ACT_NOALIGN) && !IS_SET(victim->act,ACT_NOALIGN)
    &&  ((IS_GOOD(ch) && IS_GOOD(victim))
    ||   (IS_EVIL(ch) && IS_EVIL(victim))
    ||   (IS_NEUTRAL(ch) && IS_NEUTRAL(victim))))
  return TRUE;

    return FALSE;
}

/* returns number of people on an object */
int count_users(OBJ_DATA *obj)
{
    CHAR_DATA *fch;
    int count = 0;

    if (obj->in_room == NULL)
  return 0;

    for (fch = obj->in_room->people; fch != NULL; fch = fch->next_in_room)
  if (fch->on == obj)
      count++;

    return count;
}
     
/* returns material number */
int material_lookup (const char *name)
{
    return 0;
}

/* returns race number */
int race_lookup (const char *name)
{
   int race;

   for ( race = 0; race_table[race].name != NULL; race++)
   {
  if (LOWER(name[0]) == LOWER(race_table[race].name[0])
  &&  !str_prefix( name,race_table[race].name))
      return race;
   }

   return 0;
} 

int liq_lookup (const char *name)
{
    int liq;

    for ( liq = 0; liq_table[liq].liq_name != NULL; liq++)
    {
  if (LOWER(name[0]) == LOWER(liq_table[liq].liq_name[0])
  && !str_prefix(name,liq_table[liq].liq_name))
      return liq;
    }

    return -1;
}

int weapon_lookup (const char *name)
{
    int type;

    for (type = 0; weapon_table[type].name != NULL; type++)
    {
  if (LOWER(name[0]) == LOWER(weapon_table[type].name[0])
  &&  !str_prefix(name,weapon_table[type].name))
      return type;
    }
 
    return -1;
}

int weapon_type (const char *name)
{
    int type;
 
    for (type = 0; weapon_table[type].name != NULL; type++)
    {
        if (LOWER(name[0]) == LOWER(weapon_table[type].name[0])
        &&  !str_prefix(name,weapon_table[type].name))
            return weapon_table[type].type;
    }
 
    return WEAPON_EXOTIC;
}


int item_lookup(const char *name)
{
    int type;

    for (type = 0; item_table[type].name != NULL; type++)
    {
        if (LOWER(name[0]) == LOWER(item_table[type].name[0])
        &&  !str_prefix(name,item_table[type].name))
            return item_table[type].type;
    }
 
    return -1;
}

char *item_name(int item_type)
{
    int type;

    for (type = 0; item_table[type].name != NULL; type++)
  if (item_type == item_table[type].type)
      return item_table[type].name;
    return "none";
}

char *weapon_name( int weapon_type)
{
    int type;
 
    for (type = 0; weapon_table[type].name != NULL; type++)
        if (weapon_type == weapon_table[type].type)
            return weapon_table[type].name;
    return "exotic";
}

int attack_lookup  (const char *name)
{
    int att;

    for ( att = 0; attack_table[att].name != NULL; att++)
    {
  if (LOWER(name[0]) == LOWER(attack_table[att].name[0])
  &&  !str_prefix(name,attack_table[att].name))
      return att;
    }

    return 0;
}

/* returns a flag for wiznet */
long wiznet_lookup (const char *name)
{
    int flag;

    for (flag = 0; wiznet_table[flag].name != NULL; flag++)
    {
  if (LOWER(name[0]) == LOWER(wiznet_table[flag].name[0])
  && !str_prefix(name,wiznet_table[flag].name))
      return flag;
    }

    return -1;
}

/* returns a flag for pnet */
long pnet_lookup (const char *name)
{
    int flag;

    for (flag = 0; pnet_table[flag].name != NULL; flag++)
    {
  if (LOWER(name[0]) == LOWER(pnet_table[flag].name[0])
  && !str_prefix(name,pnet_table[flag].name))
      return flag;
    }

    return -1;
}

int kit_lookup(const char *name)
{
    int kit;

    for ( kit = 0 ; kit_table[kit].name != NULL ; kit++ )
    {
	if (LOWER(name[0]) == LOWER(kit_table[kit].name[0])
	&&	!str_prefix( name,kit_table[kit].name))
		return kit;
    }

    return -1;
}

/* returns class number */
int class_lookup (const char *name)
{
   int class;
 
   for ( class = 0; class < MAX_CLASS; class++)
   {
        if (LOWER(name[0]) == LOWER(class_table[class].name[0])
        &&  !str_prefix( name,class_table[class].name))
            return class;
   }
 
   return -1;
}

/* for immunity, vulnerabiltiy, and resistant
   the 'globals' (magic and weapons) may be overriden
   three other cases -- wood, silver, and iron -- are checked in fight.c */

int check_immune(CHAR_DATA *ch, int dam_type)
{
    int immune, def;
    int bit;

    immune = -1;
    def = IS_NORMAL;

    if (dam_type == DAM_NONE)
  return immune;

    if (dam_type <= 3)
    {
  if (IS_SET(ch->imm_flags,IMM_WEAPON))
      def = IS_IMMUNE;
  else if (IS_SET(ch->res_flags,RES_WEAPON))
      def = IS_RESISTANT;
  else if (IS_SET(ch->vuln_flags,VULN_WEAPON))
      def = IS_VULNERABLE;
    }
    else /* magical attack */
    { 
  if (IS_SET(ch->imm_flags,IMM_MAGIC))
      def = IS_IMMUNE;
  else if (IS_SET(ch->res_flags,RES_MAGIC))
      def = IS_RESISTANT;
  else if (IS_SET(ch->vuln_flags,VULN_MAGIC))
      def = IS_VULNERABLE;
    }

    /* set bits to check -- VULN etc. must ALL be the same or this will fail */
    switch (dam_type)
    {
  case(DAM_BASH):   bit = IMM_BASH;   break;
  case(DAM_PIERCE): bit = IMM_PIERCE; break;
  case(DAM_SLASH):  bit = IMM_SLASH;  break;
  case(DAM_FIRE):   bit = IMM_FIRE;   break;
  case(DAM_COLD):   bit = IMM_COLD;   break;
  case(DAM_LIGHTNING):  bit = IMM_LIGHTNING;  break;
  case(DAM_ACID):   bit = IMM_ACID;   break;
  case(DAM_POISON): bit = IMM_POISON; break;
  case(DAM_NEGATIVE): bit = IMM_NEGATIVE; break;
  case(DAM_HOLY):   bit = IMM_HOLY;   break;
  case(DAM_ENERGY): bit = IMM_ENERGY; break;
  case(DAM_MENTAL): bit = IMM_MENTAL; break;
  case(DAM_DISEASE):  bit = IMM_DISEASE;  break;
  case(DAM_DROWNING): bit = IMM_DROWNING; break;
  case(DAM_LIGHT):  bit = IMM_LIGHT;  break;
  case(DAM_CHARM):  bit = IMM_CHARM;  break;
  case(DAM_SOUND):  bit = IMM_SOUND;  break;
  default:    return def;
    }

    if (IS_SET(ch->imm_flags,bit))
  immune = IS_IMMUNE;
    else if (IS_SET(ch->res_flags,bit) && immune != IS_IMMUNE)
  immune = IS_RESISTANT;
    else if (IS_SET(ch->vuln_flags,bit))
    {
  if (immune == IS_IMMUNE)
      immune = IS_RESISTANT;
  else if (immune == IS_RESISTANT)
      immune = IS_NORMAL;
  else
      immune = IS_VULNERABLE;
    } 

    if (immune == -1)
  return def;
    else
        return immune;
}

bool is_clan(CHAR_DATA *ch)
{
    return ( clan_table[ch->clan].true_clan );
}

bool is_same_clan(CHAR_DATA *ch, CHAR_DATA *victim)
{
    if (clan_table[ch->clan].independent && clan_table[ch->clan].true_clan)
  return FALSE;
    else 
  return (ch->clan == victim->clan);
}

/* checks mob format */
bool is_old_mob(CHAR_DATA *ch)
{
    if (ch->pIndexData == NULL)
  return FALSE;
    else if (ch->pIndexData->new_format)
  return FALSE;
    return TRUE;
}
 
/* for returning skill information */
int get_skill(CHAR_DATA *ch, int sn)
{
    int skill;

    if (sn == -1) /* shorthand for level based skills */
    {
  skill = ch->level * 5 / 2;
    }

    else if (sn < -1 || sn > MAX_SKILL)
    {
  bug("Bad sn %d in get_skill.",sn);
  skill = 0;
    }

    else if (!IS_NPC(ch))
    {
  if (ch->level < skill_level(ch,sn) )
      skill = 0;
  else
      skill = ch->pcdata->learned[sn];
    }

    else /* mobiles */
    {


        if (skill_table[sn].spell_fun != spell_null)
      skill = 40 + 2 * ch->level;

  else if (sn == gsn_sneak || sn == gsn_hide)
      skill = ch->level * 2 + 20;

        else if ((sn == gsn_dodge && IS_SET(ch->off_flags,OFF_DODGE))
  ||       (sn == gsn_parry && IS_SET(ch->off_flags,OFF_PARRY)))
      skill = ch->level * 2;

  else if (sn == gsn_shield_block)
      skill = 10 + 2 * ch->level;

  else if (sn == gsn_second_attack 
  && (IS_SET(ch->act,ACT_WARRIOR) || IS_SET(ch->act,ACT_THIEF)))
      skill = 10 + 3 * ch->level;

  else if (sn == gsn_third_attack && IS_SET(ch->act,ACT_WARRIOR))
      skill = 4 * ch->level - 40;

  else if (sn == gsn_hand_to_hand)
      skill = 40 + 2 * ch->level;

  else if (sn == gsn_trip && IS_SET(ch->off_flags,OFF_TRIP))
      skill = 10 + 3 * ch->level;

  else if (sn == gsn_bash && IS_SET(ch->off_flags,OFF_BASH))
      skill = 10 + 3 * ch->level;

  else if (sn == gsn_disarm 
       &&  (IS_SET(ch->off_flags,OFF_DISARM) 
       ||   IS_SET(ch->act,ACT_WARRIOR)
       ||   IS_SET(ch->act,ACT_THIEF)))
      skill = 20 + 3 * ch->level;

  else if (sn == gsn_berserk && IS_SET(ch->off_flags,OFF_BERSERK))
      skill = 3 * ch->level;

  else if (sn == gsn_kick)
      skill = 10 + 3 * ch->level;

  else if (sn == gsn_backstab && IS_SET(ch->act,ACT_THIEF))
      skill = 20 + 2 * ch->level;

    else if (sn == gsn_rescue)
      skill = 40 + ch->level; 

  else if (sn == gsn_recall)
      skill = 40 + ch->level;

  else if (sn == gsn_sword
  ||  sn == gsn_dagger
  ||  sn == gsn_spear
  ||  sn == gsn_mace
  ||  sn == gsn_axe
  ||  sn == gsn_flail
  ||  sn == gsn_whip
  ||  sn == gsn_polearm)
      skill = 40 + 5 * ch->level / 2;

  else 
     skill = 0;
    }

    if (ch->daze > 0)
    {
  if (skill_table[sn].spell_fun != spell_null)
      if (ch->clan == clan_lookup("warlock"))
	 skill = (skill/2) + (skill/10); 
      else
         skill /= 2;
  else
      skill = 2 * skill / 3;
    }

    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
  skill = 9 * skill / 10;

    if ( is_affected(ch,gsn_forget) )
	skill -= (number_range(5,UMAX(15,skill/2)));

    return URANGE(0,skill,100);
}

/* for returning weapon information */
int get_weapon_sn(CHAR_DATA *ch, bool fSecondary)
{
    OBJ_DATA *wield;
    int sn;

    if (fSecondary)
       wield = get_eq_char( ch, WEAR_SECOND );
    else
       wield = get_eq_char( ch, WEAR_WIELD );

    if (wield == NULL || wield->item_type != ITEM_WEAPON)
        sn = gsn_hand_to_hand;
    else switch (wield->value[0])
    {
        default :               sn = -1;                break;
        case(WEAPON_SWORD):     sn = gsn_sword;         break;
        case(WEAPON_DAGGER):    sn = gsn_dagger;        break;
        case(WEAPON_SPEAR):     sn = gsn_spear;         break;
        case(WEAPON_MACE):      sn = gsn_mace;          break;
        case(WEAPON_AXE):       sn = gsn_axe;           break;
        case(WEAPON_FLAIL):     sn = gsn_flail;         break;
        case(WEAPON_WHIP):      sn = gsn_whip;          break;
        case(WEAPON_POLEARM):   sn = gsn_polearm;       break;
        case(WEAPON_GAROTTE):   sn = gsn_whip;	        break;
   }
   return sn;
}

int get_weapon_skill(CHAR_DATA *ch, int sn)
{
     int skill;

     /* -1 is exotic */
    if (IS_NPC(ch))
    {
  if (sn == -1)
      skill = 2 * ch->level;
  else if (sn == gsn_hand_to_hand)
      skill = 40 + 2 * ch->level;
  else 
      skill = 40 + 5 * ch->level / 2;
    }
    
    else
    {
  if (sn == -1)
      skill = 3 * ch->level;
  else
  {
      skill = ch->pcdata->learned[sn];
      if ( sn == ch->pcdata->specialize )
		skill += skill / 4;
  }
    }

    if ( IS_NPC(ch) )
	return URANGE(0,skill,100);
    else
    return ( sn == -1 ? URANGE(0,skill,100) : URANGE(0,skill,125) );

} 


/* used to de-screw characters */
void reset_char(CHAR_DATA *ch)
{
     int loc,mod,stat;
     OBJ_DATA *obj;
     AFFECT_DATA *af;
     int i;

     if (IS_NPC(ch))
  return;

    if (ch->pcdata->perm_hit == 0 
    ||  ch->pcdata->perm_mana == 0
    ||  ch->pcdata->perm_move == 0
    ||  ch->pcdata->last_level == 0)
    {
    /* do a FULL reset */
  for (loc = 0; loc < MAX_WEAR; loc++)
  {
      obj = get_eq_char(ch,loc);
      if (obj == NULL)
    continue;
      if (!obj->enchanted)
      for ( af = obj->pIndexData->affected; af != NULL; af = af->next )
      {
    mod = af->modifier;
    switch(af->location)
    {
        case APPLY_SEX: ch->sex   -= mod;
          if (ch->sex < 0 || ch->sex >2)
              ch->sex = IS_NPC(ch) ?
            0 :
            ch->pcdata->true_sex;
                  break;
        case APPLY_MANA:  ch->max_mana  -= mod;   break;
        case APPLY_HIT: ch->max_hit -= mod;   break;
        case APPLY_MOVE:  ch->max_move  -= mod;   break;
    }
      }

            for ( af = obj->affected; af != NULL; af = af->next )
            {
                mod = af->modifier;
                switch(af->location)
                {
                    case APPLY_SEX:     ch->sex         -= mod;         break;
                    case APPLY_MANA:    ch->max_mana    -= mod;         break;
                    case APPLY_HIT:     ch->max_hit     -= mod;         break;
                    case APPLY_MOVE:    ch->max_move    -= mod;         break;
                }
            }
  }
  /* now reset the permanent stats */
  ch->pcdata->perm_hit  = ch->max_hit;
  ch->pcdata->perm_mana   = ch->max_mana;
  ch->pcdata->perm_move = ch->max_move;
  ch->pcdata->last_level  = ch->played/3600;
  if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
  {
    if (ch->sex > 0 && ch->sex < 3)
            ch->pcdata->true_sex  = ch->sex;
    else
        ch->pcdata->true_sex  = 0;
  }

    }

    /* now restore the character to his/her true condition */
    for (stat = 0; stat < MAX_STATS; stat++)
  ch->mod_stat[stat] = 0;

    if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
  ch->pcdata->true_sex = 0; 
    ch->sex   = ch->pcdata->true_sex;
    ch->max_hit   = ch->pcdata->perm_hit;
    ch->max_mana  = ch->pcdata->perm_mana;
    ch->max_move  = ch->pcdata->perm_move;
   
    for (i = 0; i < 4; i++)
      ch->armor[i]  = 100;

    ch->hitroll   = 0;
    ch->damroll   = 0;
    ch->saving_throw  = 0;
    ch->pcdata->second_hitroll   = 0;
    ch->pcdata->second_damroll   = 0;

    /* now start adding back the effects */
    for (loc = 0; loc < MAX_WEAR; loc++)
    {
        obj = get_eq_char(ch,loc);
        if (obj == NULL)
            continue;
        for (i = 0; i < 4; i++)
           ch->armor[i] -= apply_ac( obj, loc, i );

        if (!obj->enchanted)
	{
           for ( af = obj->pIndexData->affected; af != NULL; af = af->next )
           {
              mod = af->modifier;
              switch(af->location)
              {
	 	 case APPLY_REFLEX_SAVE: ch->saves[SAVE_REFLEX] += mod; break;
		 case APPLY_FORTITUDE_SAVE: ch->saves[SAVE_FORTITUDE] += mod; break;
		 case APPLY_WILLPOWER_SAVE: ch->saves[SAVE_WILLPOWER] += mod; break;
                 case APPLY_STR:   ch->mod_stat[STAT_STR]  += mod; break;
                 case APPLY_DEX:   ch->mod_stat[STAT_DEX]  += mod; break;
                 case APPLY_INT:   ch->mod_stat[STAT_INT]  += mod; break;
                 case APPLY_WIS:   ch->mod_stat[STAT_WIS]  += mod; break;
                 case APPLY_CON:   ch->mod_stat[STAT_CON]  += mod; break;
                 case APPLY_AGT:   ch->mod_stat[STAT_AGT]  += mod; break;
                 case APPLY_END:   ch->mod_stat[STAT_END]  += mod; break;
                 case APPLY_SOC:   ch->mod_stat[STAT_SOC]  += mod; break;

                 case APPLY_SEX:   ch->sex     += mod; break;
                 case APPLY_MANA:  ch->max_mana    += mod; break;
                 case APPLY_HIT:   ch->max_hit   += mod; break;
                 case APPLY_MOVE:  ch->max_move    += mod; break;

                 case APPLY_AC:    
                    for (i = 0; i < 4; i ++)
                       ch->armor[i] += mod; 
                    break;

                 case APPLY_HITROLL: 
	            if (loc == WEAR_SECOND)
                       ch->pcdata->second_hitroll   += mod; 
	            else if (loc == WEAR_WIELD) 
                       ch->hitroll   += mod; 
	            else
	            {
                       ch->pcdata->second_hitroll   += mod; 
                       ch->hitroll   += mod; 
	            }
	            break;
		    
                 case APPLY_DAMROLL: 
                    if (loc == WEAR_SECOND)
	               ch->pcdata->second_damroll   += mod;
	            else if (loc == WEAR_WIELD)  
	               ch->damroll   += mod; 
                    else
	            {
	               ch->pcdata->second_damroll   += mod;
	               ch->damroll   += mod; 
	            }
                    break;
  
                 case APPLY_SAVES:   ch->saving_throw += mod; break;
                 case APPLY_SAVING_ROD:    ch->saving_throw += mod; break;
                 case APPLY_SAVING_PETRI:  ch->saving_throw += mod; break;
                 case APPLY_SAVING_BREATH:   ch->saving_throw += mod; break;
                 case APPLY_SAVING_SPELL:  ch->saving_throw += mod; break;
                 case APPLY_SIZE:  ch->size += mod; break;
              }
           }
	}
 
        for ( af = obj->affected; af != NULL; af = af->next )
        {
           mod = af->modifier;
           switch(af->location)
           {
              case APPLY_REFLEX_SAVE: ch->saves[SAVE_REFLEX] += mod; break;
              case APPLY_FORTITUDE_SAVE: ch->saves[SAVE_FORTITUDE] += mod; break;
              case APPLY_WILLPOWER_SAVE: ch->saves[SAVE_WILLPOWER] += mod; break;

              case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
              case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
              case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
              case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
              case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
              case APPLY_AGT:	      ch->mod_stat[STAT_AGT]  += mod; break;
              case APPLY_END:         ch->mod_stat[STAT_END]  += mod; break;
              case APPLY_SOC:         ch->mod_stat[STAT_SOC]  += mod; break;
 
              case APPLY_SEX:         ch->sex                 += mod; break;
              case APPLY_MANA:        ch->max_mana            += mod; break;
              case APPLY_HIT:         ch->max_hit             += mod; break;
              case APPLY_MOVE:        ch->max_move            += mod; break;
 
              case APPLY_AC:
                 for (i = 0; i < 4; i ++)
                    ch->armor[i] += mod;
                 break;
              case APPLY_HITROLL:
                 if (loc == WEAR_SECOND)
                    ch->pcdata->second_hitroll   += mod; 
                 else if (loc == WEAR_WIELD) 
                    ch->hitroll   += mod; 
                 else
                 {
                    ch->pcdata->second_hitroll   += mod; 
                    ch->hitroll   += mod; 
                 }
                 break;
              case APPLY_DAMROLL:     
                 if (loc == WEAR_SECOND)
                    ch->pcdata->second_damroll   += mod; 
                 else if (loc == WEAR_WIELD) 
                    ch->damroll   += mod; 
                 else
                 {
                    ch->pcdata->second_damroll   += mod; 
                    ch->damroll   += mod; 
                 }
                 break;
 
              case APPLY_SAVES:         ch->saving_throw += mod; break;
              case APPLY_SAVING_ROD:          ch->saving_throw += mod; break;
              case APPLY_SAVING_PETRI:        ch->saving_throw += mod; break;
              case APPLY_SAVING_BREATH:       ch->saving_throw += mod; break;
              case APPLY_SAVING_SPELL:        ch->saving_throw += mod; break;
           } 
        }
     }
  
    /* now add back spell effects */
    for (af = ch->affected; af != NULL; af = af->next)
    {
        mod = af->modifier;
        switch(af->location)
        {
                 case APPLY_REFLEX_SAVE: ch->saves[SAVE_REFLEX] += mod; break;
                 case APPLY_FORTITUDE_SAVE: ch->saves[SAVE_FORTITUDE] += mod; break;
                 case APPLY_WILLPOWER_SAVE: ch->saves[SAVE_WILLPOWER] += mod; break;

                case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
                case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
                case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
                case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
                case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
                case APPLY_AGT:         ch->mod_stat[STAT_AGT]  += mod; break;
                case APPLY_END:         ch->mod_stat[STAT_END]  += mod; break;
                case APPLY_SOC:         ch->mod_stat[STAT_SOC]  += mod; break;
 
                case APPLY_SEX:         ch->sex                 += mod; break;
                case APPLY_MANA:        ch->max_mana            += mod; break;
                case APPLY_HIT:         ch->max_hit             += mod; break;
                case APPLY_MOVE:        ch->max_move            += mod; break;
 
                case APPLY_AC:
                    for (i = 0; i < 4; i ++)
                        ch->armor[i] += mod;
                    break;
                case APPLY_HITROLL:     
		    ch->hitroll             += mod; 
		    ch->pcdata->second_hitroll             += mod; 
		    break;
                case APPLY_DAMROLL:     
		    ch->damroll             += mod; 
		    ch->pcdata->second_damroll             += mod; 
		    break;
 
                case APPLY_SAVES:         ch->saving_throw += mod; break;
                case APPLY_SAVING_ROD:          ch->saving_throw += mod; break;
                case APPLY_SAVING_PETRI:        ch->saving_throw += mod; break;
                case APPLY_SAVING_BREATH:       ch->saving_throw += mod; break;
                case APPLY_SAVING_SPELL:        ch->saving_throw += mod; break;
		case APPLY_SIZE:	ch->size += mod; break;
        } 
    }

    /* make sure sex is RIGHT!!!! */
    if (ch->sex < 0 || ch->sex > 2)
  ch->sex = ch->pcdata->true_sex;
}

/*
 * Retrieve a character's trusted level for permission checking.
 */
int get_trust( CHAR_DATA *ch )
{  
   
    if ( (ch->desc != NULL) && (ch->desc->original != NULL) )
         
    return ch->desc->original->level;
   
    if ( (ch->trust != 0) && (IS_SET(ch->comm,COMM_TRUE_TRUST)) )
  return ch->trust;

    if ( (IS_NPC(ch)) && (ch->level >= LEVEL_HERO) )
  return LEVEL_HERO - 1;
    else 
  return ch->level;
}


/*
 * Retrieve a character's age.
 */
int get_age( CHAR_DATA *ch )
{
    return 17 + ( ch->played + (int) (current_time - ch->logon) ) / 72000;
}

/* command for retrieving stats */
int get_curr_stat( CHAR_DATA *ch, int stat )
{
    int max;

    if (IS_NPC(ch) || ch->level > LEVEL_IMMORTAL)
  max = 25;

    else
    {
  max = pc_race_table[ch->race].max_stats[stat] + 4;

  if ( (ch->class <= class_lookup("warrior")) 
       || ( ch->class >= class_lookup("elementalist")))
  {
     if (class_table[ch->class].attr_prime == stat)
        max += 2;
  }
  else
  {
     if (class_table[class_table[ch->class].allowed[0]].attr_prime == stat
	 || class_table[class_table[ch->class].allowed[1]].attr_prime == stat) 
	max += 1;
  }

  if ( ch->race == race_lookup("human") || ch->race == race_lookup("goblin") 
	|| ch->race == race_lookup("half-elf") )
      max += 1;

  if ( ch->race == race_lookup("rockbiter") && stat == STAT_WIS )
      max += ch->level / 5;

/*
  if ( stat == STAT_DEX &&
	(  ch->race == race_lookup("rockbiter")
	|| ch->race == race_lookup("ogre")
	|| ch->race == race_lookup("giant") ))
      max += 4;
*/

  max = UMIN(max,25);
    }
  
    return URANGE(3,ch->perm_stat[stat] + ch->mod_stat[stat], max);
}

/* command for returning max training score */
int get_max_train( CHAR_DATA *ch, int stat )
{
    int max;

    if (IS_NPC(ch) || ch->level > LEVEL_IMMORTAL)
  return 25;

    max = pc_race_table[ch->race].max_stats[stat];
  if ( (ch->class <= class_lookup("warrior")) 
       || ( ch->class >= class_lookup("elementalist")))
  {
     if (class_table[ch->class].attr_prime == stat)
        max += 2;
  }
  else
  {
     if (class_table[class_table[ch->class].allowed[0]].attr_prime == stat
	 || class_table[class_table[ch->class].allowed[1]].attr_prime == stat) 
	max += 1;
  }
    if (class_table[ch->class].attr_prime == stat)
  if ( ch->race == race_lookup("human") || ch->race == race_lookup("goblin") 
	|| ch->race == race_lookup("half-elf") )
      max += 1;

    if ( stat == STAT_WIS && ch->race == race_lookup("rockbiter") )
       max += ch->level / 5;

    return UMIN(max,25);
}
   
  
/*
 * Retrieve a character's carry capacity.
 */
int can_carry_n( CHAR_DATA *ch )
{
    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
  return 10000;

    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
  return 0;
  
   if ( IS_NPC(ch) )
    return ( 10 * (MAX_WEAR +  2 * get_curr_stat(ch,STAT_DEX) + ch->level) );
   if ( ch->pcdata->logout_tracker != 0 )
    return ( 10 * (MAX_WEAR +  2 * 25 + 60));
   else
    return ( 10 * (MAX_WEAR +  2 * get_curr_stat(ch,STAT_DEX) + ch->level) );
}



/*
 * Retrieve a character's carry capacity.
 */
int can_carry_w( CHAR_DATA *ch )
{
    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
  return 10000000;

    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
  return 0;
  if ( IS_NPC(ch) )
    return str_app[get_curr_stat(ch,STAT_STR)].carry * 10 + ch->level * 25;
  if (ch->pcdata->logout_tracker != 0 || IS_SET(ch->mhs,MHS_GLADIATOR))
    return str_app[25].carry * 10 + (60*25);
  else
    return str_app[get_curr_stat(ch,STAT_STR)].carry * 10 + ch->level * 25;
}



/*
 * See if a string is one of the names of an object.
 */
/*
bool is_name( const char *str, char *namelist )
{
    char name[MAX_INPUT_LENGTH];

    for ( ; ; )
    {
  namelist = one_argument( namelist, name );
  if ( name[0] == '\0' )
      return FALSE;
  if ( !str_cmp( str, name ))
      return TRUE;
    }
}
*/

bool is_name ( char *str, char *namelist )
{
    char name[MAX_INPUT_LENGTH], part[MAX_INPUT_LENGTH];
    char *list, *string;


    string = str;
    /* we need ALL parts of string to match part of namelist */
    for ( ; ; )  /* start parsing string */
    {
  str = one_argument(str,part);

  if (part[0] == '\0' )
      return TRUE;

  /* check to see if this is part of namelist */
  list = namelist;
  for ( ; ; )  /* start parsing namelist */
  {
      list = one_argument(list,name);
      if (name[0] == '\0')  /* this name was not found */
    return FALSE;

      if (!str_prefix(string,name))
    return TRUE; /* full pattern match */

      if (!str_prefix(part,name))
    break;
  }
    }
}

bool is_exact_name ( char *str, char *namelist )
{
    char name[MAX_INPUT_LENGTH], part[MAX_INPUT_LENGTH];
    char *list, *string;


    string = str;
    /* we need ALL parts of string to match part of namelist */
    for ( ; ; )  /* start parsing string */
    {
  str = one_argument(str,part);

  if (part[0] == '\0' )
      return TRUE;

  /* check to see if this is part of namelist */
  list = namelist;
  for ( ; ; )  /* start parsing namelist */
  {
      list = one_argument(list,name);
      if (name[0] == '\0')  /* this name was not found */
    return FALSE;

      if (!strcmp(string,name))
    return TRUE; /* full pattern match */

      if (!strcmp(part,name))
    break;
  }
    }
}
/* enchanted stuff for eq */
void affect_enchant(OBJ_DATA *obj)
{
    /* okay, move all the old flags into new vectors if we have to */
    if (!obj->enchanted)
    {
        AFFECT_DATA *paf, *af_new;
        obj->enchanted = TRUE;

        for (paf = obj->pIndexData->affected;
             paf != NULL; paf = paf->next)
        {
      af_new = new_affect();

            af_new->next = obj->affected;
            obj->affected = af_new;
 
      af_new->where = paf->where;
            af_new->type        = UMAX(0,paf->type);
            af_new->level       = paf->level;
            af_new->duration    = paf->duration;
            af_new->location    = paf->location;
            af_new->modifier    = paf->modifier;
            af_new->bitvector   = paf->bitvector;
        }
    }
}
           

/*
 * Apply or remove an affect to a character.
 */
void affect_modify( CHAR_DATA *ch, AFFECT_DATA *paf, bool fAdd, int AppType)
{
    OBJ_DATA *wield;
    int mod,i;
 
    /* DOTs just handle damage. */
    if ( paf->where == DAMAGE_OVER_TIME )
	return;

    mod = paf->modifier;

    if ( fAdd )
    {
  switch (paf->where)
  {
  case TO_AFFECTS:
      SET_BIT(ch->affected_by, paf->bitvector);
      break;
  case TO_IMMUNE:
      SET_BIT(ch->imm_flags,paf->bitvector);
      break;
  case TO_RESIST:
      SET_BIT(ch->res_flags,paf->bitvector);
      break;
  case TO_VULN:
      SET_BIT(ch->vuln_flags,paf->bitvector);
      break;
  }
    }
    else
    {
        switch (paf->where)
        {
        case TO_AFFECTS:
            REMOVE_BIT(ch->affected_by, paf->bitvector);
            break;
        case TO_IMMUNE:
            REMOVE_BIT(ch->imm_flags,paf->bitvector);
            break;
        case TO_RESIST:
            REMOVE_BIT(ch->res_flags,paf->bitvector);
            break;
        case TO_VULN:
            REMOVE_BIT(ch->vuln_flags,paf->bitvector);
            break;
        }
  mod = 0 - mod;
    }

    switch ( paf->location )
    {
    default:
  bug( "Affect_modify: unknown location %d.", paf->location );
  return;

    case APPLY_NONE:            break;
    case APPLY_REFLEX_SAVE: ch->saves[SAVE_REFLEX] += mod; break;
    case APPLY_FORTITUDE_SAVE: ch->saves[SAVE_FORTITUDE] += mod; break;
    case APPLY_WILLPOWER_SAVE: ch->saves[SAVE_WILLPOWER] += mod; break;

    case APPLY_STR:           ch->mod_stat[STAT_STR]  += mod; break;
    case APPLY_DEX:           ch->mod_stat[STAT_DEX]  += mod; break;
    case APPLY_INT:           ch->mod_stat[STAT_INT]  += mod; break;
    case APPLY_WIS:           ch->mod_stat[STAT_WIS]  += mod; break;
    case APPLY_CON:           ch->mod_stat[STAT_CON]  += mod; break;
    case APPLY_AGT:           ch->mod_stat[STAT_AGT]  += mod; break;
    case APPLY_END:           ch->mod_stat[STAT_END]  += mod; break;
    case APPLY_SOC:           ch->mod_stat[STAT_SOC]  += mod; break;
    case APPLY_SEX:           ch->sex     += mod; break;
    case APPLY_CLASS:           break;
    case APPLY_LEVEL:           break;
    case APPLY_AGE:           break;
    case APPLY_HEIGHT:            break;
    case APPLY_WEIGHT:            break;
    case APPLY_MANA:          ch->max_mana    += mod; break;
    case APPLY_HIT:           ch->max_hit   += mod; break;
    case APPLY_MOVE:          ch->max_move    += mod; break;
    case APPLY_GOLD:            break;
    case APPLY_EXP:           break;
    case APPLY_AC:
        for (i = 0; i < 4; i ++)
            ch->armor[i] += mod;
        break;
    case APPLY_HITROLL:       
	if (AppType == APPLY_PRIMARY || AppType == APPLY_BOTH)
	   ch->hitroll   += mod; 
	if(!IS_NPC(ch) && (AppType == APPLY_SECONDARY || AppType == APPLY_BOTH))
	   ch->pcdata->second_hitroll   += mod; 
	break;
    case APPLY_DAMROLL:       
	if (AppType == APPLY_PRIMARY || AppType == APPLY_BOTH)
	   ch->damroll   += mod; 
	if(!IS_NPC(ch) && (AppType == APPLY_SECONDARY || AppType == APPLY_BOTH))
	   ch->pcdata->second_damroll   += mod; 
	break;
    case APPLY_SAVES:   ch->saving_throw    += mod; break;
    case APPLY_SAVING_ROD:    ch->saving_throw    += mod; break;
    case APPLY_SAVING_PETRI:  ch->saving_throw    += mod; break;
    case APPLY_SAVING_BREATH: ch->saving_throw    += mod; break;
    case APPLY_SAVING_SPELL:  ch->saving_throw    += mod; break;
    case APPLY_SIZE:  ch->size    += mod; break;
    case APPLY_SPELL_AFFECT:            break;
    }

    /*
     * Check for weapon wielding.
     * Guard against recursion (for weapons with affects).
     */
    if ( !IS_NPC(ch) && ( wield = get_eq_char( ch, WEAR_WIELD ) ) != NULL
    &&   get_obj_weight(wield) > (str_app[get_curr_stat(ch,STAT_STR)].wield*10))
    {
  static int depth;

  if ( depth == 0 )
  {
      depth++;
      act( "You drop $p.", ch, wield, NULL, TO_CHAR ,FALSE);
      act( "$n drops $p.", ch, wield, NULL, TO_ROOM ,FALSE);
      obj_from_char( wield );
      obj_to_room( wield, ch->in_room );
      depth--;
  }
    }

    return;
}


/* find an effect in an affect list */
AFFECT_DATA  *affect_find(AFFECT_DATA *paf, int sn)
{
    AFFECT_DATA *paf_find;
    
    for ( paf_find = paf; paf_find != NULL; paf_find = paf_find->next )
    {
        if ( paf_find->type == sn )
  return paf_find;
    }

    return NULL;
}

/* fix object affects when removing one */
void affect_check(CHAR_DATA *ch,int where,int vector)
{
    AFFECT_DATA *paf;
    OBJ_DATA *obj;

    if (where == TO_OBJECT || where == TO_WEAPON || vector == 0 || where == DAMAGE_OVER_TIME )
  return;

    for (paf = ch->affected; paf != NULL; paf = paf->next)
  if (paf->where == where && paf->bitvector == vector)
  {
      switch (where)
      {
          case TO_AFFECTS:
        SET_BIT(ch->affected_by,vector);
        break;
          case TO_IMMUNE:
        SET_BIT(ch->imm_flags,vector);   
        break;
          case TO_RESIST:
        SET_BIT(ch->res_flags,vector);
        break;
          case TO_VULN:
        SET_BIT(ch->vuln_flags,vector);
        break;
      }
      return;
  }

    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
    {
  if (obj->wear_loc == -1)
      continue;

            for (paf = obj->affected; paf != NULL; paf = paf->next)
            if (paf->where == where && paf->bitvector == vector)
            {
                switch (where)
                {
                    case TO_AFFECTS:
                        SET_BIT(ch->affected_by,vector);
                        break;
                    case TO_IMMUNE:
                        SET_BIT(ch->imm_flags,vector);
                        break;
                    case TO_RESIST:
                        SET_BIT(ch->res_flags,vector);
                        break;
                    case TO_VULN:
                        SET_BIT(ch->vuln_flags,vector);
                  
                }
                return;
            }

        if (obj->enchanted)
      continue;

        for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next)
            if (paf->where == where && paf->bitvector == vector)
            {
                switch (where)
                {
                    case TO_AFFECTS:
                        SET_BIT(ch->affected_by,vector);
                        break;
                    case TO_IMMUNE:
                        SET_BIT(ch->imm_flags,vector);
                        break;
                    case TO_RESIST:
                        SET_BIT(ch->res_flags,vector);
                        break;
                    case TO_VULN:
                        SET_BIT(ch->vuln_flags,vector);
                        break;
                }
                return;
            }
    }
}

/*
 * Link an affect to a room
 */
void affect_to_room( ROOM_INDEX_DATA *room, AFFECT_DATA *paf )
{
    AFFECT_DATA *paf_new;

    paf_new = new_affect();

    *paf_new = *paf;   
    VALIDATE(paf_new);
    paf_new->next = room->affected;
    room->affected = paf_new;

    /* This may not be needed, depending on how this is handled **
    raffect_modify( room, paf_new, TRUE );  **/
    return;
}

/*
 * Ensure that only trap of a given kind is in the room
 */
bool check_trap( ROOM_INDEX_DATA *room, int trap )
{
    AFFECT_DATA *paf;

    for ( paf = room->affected ; paf != NULL ; paf = paf->next )
	if ( paf->type == gsn_trap && paf->location == trap )
		return TRUE;

    return FALSE;
}

/*
 * Give an affect to a char.
 */
void affect_to_char( CHAR_DATA *ch, AFFECT_DATA *paf )
{
    AFFECT_DATA *paf_new;

    paf_new = new_affect();

    *paf_new    = *paf;
    VALIDATE(paf_new);
    paf_new->next = ch->affected;
    ch->affected  = paf_new;

    affect_modify( ch, paf_new, TRUE, APPLY_BOTH);
    return;
}

/* give an affect to an object */
void affect_to_obj(OBJ_DATA *obj, AFFECT_DATA *paf)
{
    AFFECT_DATA *paf_new;

    paf_new = new_affect();

    *paf_new    = *paf;
    VALIDATE(paf_new);
    paf_new->next = obj->affected;
    obj->affected = paf_new;

    /* apply any affect vectors to the object's extra_flags */
    if (paf->bitvector)
        switch (paf->where)
        {
        case TO_OBJECT:
          SET_BIT(obj->extra_flags,paf->bitvector);
      break;
        case TO_WEAPON:
      if (obj->item_type == ITEM_WEAPON)
          SET_BIT(obj->value[4],paf->bitvector);
      break;
        }
    

    return;
}

void raffect_remove( ROOM_INDEX_DATA *room, AFFECT_DATA *paf )
{
    if ( room->affected == NULL )
    {
   bug( "RAffect_remove: no affect.",0);
   return;
    }

    if ( paf == room->affected )
    {
    room->affected = paf->next;
    }
    else
    {
    AFFECT_DATA *prev;

    for ( prev = room->affected ; prev != NULL ; prev = prev->next )
    {
	if ( prev->next == paf )
	{
	prev->next = paf->next;
	break;
	}
    }

    if ( prev == NULL )
    {
    bug("RAffect_remove: cannot find affect.", 0);
    return;
    }
    }
    free_affect(paf);

    return;
}

/*
 * Remove an affect from a char.
 */
void affect_remove( CHAR_DATA *ch, AFFECT_DATA *paf, int AppType)
{
    int where;
    int vector;

    if ( ch->affected == NULL )
    {
  bug( "Affect_remove: no affect.", 0 );
  return;
    }

    affect_modify( ch, paf, FALSE, AppType);
    where = paf->where;
    vector = paf->bitvector;

    if ( paf == ch->affected )
    {
  ch->affected  = paf->next;
    }
    else
    {
  AFFECT_DATA *prev;

  for ( prev = ch->affected; prev != NULL; prev = prev->next )
  {
      if ( prev->next == paf )
      {
    prev->next = paf->next;
    break;
      }
  }

  if ( prev == NULL )
  {
      bug( "Affect_remove: cannot find paf.", 0 );
      return;
  }
    }

    if ( !IS_NPC(ch)  &&  paf->type == gsn_barbarian_rage )
	ch->pcdata->barbarian = -10;

    free_affect(paf);

    affect_check(ch,where,vector);
    return;
}

void affect_remove_obj( OBJ_DATA *obj, AFFECT_DATA *paf)
{
    int where, vector;
    if ( obj->affected == NULL )
    {
        bug( "Affect_remove_object: no affect.", 0 );
        return;
    }

    if (obj->carried_by != NULL && obj->wear_loc != -1)
  affect_modify( obj->carried_by, paf, FALSE, APPLY_BOTH );

    where = paf->where;
    vector = paf->bitvector;

    /* remove flags from the object if needed */
    if (paf->bitvector)
  switch( paf->where)
        {
        case TO_OBJECT:
            REMOVE_BIT(obj->extra_flags,paf->bitvector);
            break;
        case TO_WEAPON:
            if (obj->item_type == ITEM_WEAPON)
                REMOVE_BIT(obj->value[4],paf->bitvector);
            break;
        }

    if ( paf == obj->affected )
    {
        obj->affected    = paf->next;
    }
    else
    {
        AFFECT_DATA *prev;

        for ( prev = obj->affected; prev != NULL; prev = prev->next )
        {
            if ( prev->next == paf )
            {
                prev->next = paf->next;
                break;
            }
        }

        if ( prev == NULL )
        {
            bug( "Affect_remove_object: cannot find paf.", 0 );
            return;
        }
    }

    free_affect(paf);

    if (obj->carried_by != NULL && obj->wear_loc != -1)
  affect_check(obj->carried_by,where,vector);
    return;
}



/*
 * Strip all affects of a given sn.
 */
void affect_strip( CHAR_DATA *ch, int sn )
{
    AFFECT_DATA *paf;
    AFFECT_DATA *paf_next;

    for ( paf = ch->affected; paf != NULL; paf = paf_next )
    {
  paf_next = paf->next;
  if ( paf->type == sn )
      affect_remove( ch, paf,APPLY_BOTH);
    }

    return;
}



/*
 * Return true if a char is affected by a spell.
 */
bool is_affected( CHAR_DATA *ch, int sn )
{
    AFFECT_DATA *paf;

    for ( paf = ch->affected; paf != NULL; paf = paf->next )
    {
  if ( paf->type == sn )
      return TRUE;
    }

    return FALSE;
}

bool is_room_affected ( ROOM_INDEX_DATA *room, int sn )
{
	AFFECT_DATA *paf;
	
	for ( paf = room->affected; paf!= NULL; paf = paf->next )
	{
		if (paf->type == sn )
			return TRUE;
	}
	return FALSE;
} 

/*
 * Add or enhance an affect.
 */
void affect_join( CHAR_DATA *ch, AFFECT_DATA *paf )
{
    AFFECT_DATA *paf_old;
    bool found;

    found = FALSE;
    for ( paf_old = ch->affected; paf_old != NULL; paf_old = paf_old->next )
    {
  if ( paf_old->type == paf->type )
  {
      paf->level = (paf->level += paf_old->level) / 2;
      paf->duration += paf_old->duration;
      paf->modifier += paf_old->modifier;
      affect_remove( ch, paf_old, APPLY_BOTH);
      break;
  }
    }

    affect_to_char( ch, paf );
    return;
}



/*
 * Move a char out of a room.
 */
void char_from_room( CHAR_DATA *ch )
{
    OBJ_DATA *obj;

    if ( ch->in_room == NULL )
    {
  bug( "Char_from_room: NULL.", 0 );
  return;
    }

    if ( is_room_affected(ch->in_room, gsn_wall_fire))
           damage( ch, ch, dice(10,10), gsn_wall_fire ,DAM_FIRE,TRUE,TRUE);	

    if ( !IS_NPC(ch) )
  --ch->in_room->area->nplayer;

    if ( ( obj = get_eq_char( ch, WEAR_LIGHT ) ) != NULL
    &&   obj->item_type == ITEM_LIGHT
    &&   obj->value[2] != 0
    &&   ch->in_room->light > 0 )
  --ch->in_room->light;

    if ( ch == ch->in_room->people )
    {
  ch->in_room->people = ch->next_in_room;
    }
    else
    {
  CHAR_DATA *prev;

  for ( prev = ch->in_room->people; prev; prev = prev->next_in_room )
  {
      if ( prev->next_in_room == ch )
      {
    prev->next_in_room = ch->next_in_room;
    break;
      }
  }

  if ( prev == NULL )
      bug( "Char_from_room: ch not found.", 0 );
    }

    /* If this person is involved with a trade, it needs to be completely
     * cancelled */
    if ( ch->trade != NULL )
	destruct_trade( ch->trade, TRUE );

    ch->in_room      = NULL;
    ch->next_in_room = NULL;
    ch->on       = NULL;  /* sanity check! */
    return;
}



/*
 * Move a char into a room.
 */
void char_to_room( CHAR_DATA *ch, ROOM_INDEX_DATA *pRoomIndex )
{
    OBJ_DATA *obj;
    AFFECT_DATA *paf, *paf_next;

    if ( pRoomIndex == NULL )
    {
  ROOM_INDEX_DATA *room;

  bug( "Char_to_room: NULL.", 0 );
  
  if ((room = get_room_index(ROOM_VNUM_TEMPLE)) != NULL)
      char_to_room(ch,room);
  
  return;
    }

    ch->in_room   = pRoomIndex;
    ch->next_in_room  = pRoomIndex->people;
    pRoomIndex->people  = ch;

    if ( !IS_NPC(ch) )
    {
  if (ch->in_room->area->empty)
  {
      ch->in_room->area->empty = FALSE;
      ch->in_room->area->age = 0;
  }
  ++ch->in_room->area->nplayer;
    }

    if ( ( obj = get_eq_char( ch, WEAR_LIGHT ) ) != NULL
    &&   obj->item_type == ITEM_LIGHT
    &&   obj->value[2] != 0 )
  ++ch->in_room->light;
  
    /*
     * No hiding.
     */
    if( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_HIDE)) 
	REMOVE_BIT( ch->affected_by, AFF_HIDE );

/**
    if (IS_AFFECTED(ch,AFF_PLAGUE))
    {
        AFFECT_DATA *af, plague;
        CHAR_DATA *vch;
        
        for ( af = ch->affected; af != NULL; af = af->next )
        {
            if (af->type == gsn_plague)
                break;
        }
        
        if (af == NULL)
        {
            REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
            return;
        }
        
        if (af->level == 1)
            return;
        
  plague.where    = TO_AFFECTS;
        plague.type     = gsn_plague;
        plague.level    = af->level - 1; 
        plague.duration   = number_range(1,2 * plague.level);
        plague.location   = APPLY_STR;
        plague.modifier   = -5;
        plague.bitvector  = AFF_PLAGUE;
        
        for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
        {
            if (!saves_spell(plague.level - 2,vch,DAM_DISEASE) 
      &&  !IS_IMMORTAL(vch) &&
              !IS_AFFECTED(vch,AFF_PLAGUE) && number_bits(6) == 0)
            {
              send_to_char("You feel hot and feverish.\n\r",vch);
              act("$n shivers and looks very ill.",vch,NULL,NULL,TO_ROOM,FALSE);
              affect_join(vch,&plague);
            }
        }
    }
***/

    /*
     * handle room affects 
     */
    for ( paf = pRoomIndex->affected ; paf != NULL ; paf = paf_next )
    {
	paf_next = paf->next;

	/* Affect exception handling: traps */
	if ( paf->type == gsn_trap )
	{
	  if ( is_clan(ch)  )
	      trap_effect( ch, paf );

	  continue;
        }

/***
	if ( ( IS_SET( paf->bitvector, AFF_CLANNER ) && !is_clan(ch) ) ||
	     ( !IS_SET( paf->bitvector, AFF_CLANNER ) && is_clan(ch) ) )
	     continue;

	affect_to_char( ch, paf );
 ****/
    }
	     
    return;
}



/*
 * Give an obj to a char.
 */
void obj_to_char( OBJ_DATA *obj, CHAR_DATA *ch )
{
    obj->next_content  = ch->carrying;
    ch->carrying   = obj;
    obj->carried_by  = ch;
    obj->in_room   = NULL;
    obj->in_obj    = NULL;
    ch->carry_number  += get_obj_number( obj );
    ch->carry_weight  += get_obj_weight( obj );
}



/*
 * Take an obj from its character.
 */
void obj_from_char( OBJ_DATA *obj )
{
    CHAR_DATA *ch;

    if ( ( ch = obj->carried_by ) == NULL )
    {
  bug( "Obj_from_char: null ch.", 0 );
  return;
    }

    if ( obj->wear_loc != WEAR_NONE )
  unequip_char( ch, obj );

    if ( ch->carrying == obj )
    {
  ch->carrying = obj->next_content;
    }
    else
    {
  OBJ_DATA *prev;

  for ( prev = ch->carrying; prev != NULL; prev = prev->next_content )
  {
      if ( prev->next_content == obj )
      {
    prev->next_content = obj->next_content;
    break;
      }
  }

  if ( prev == NULL )
      bug( "Obj_from_char: obj not in list.", 0 );
    }
 
  if (!IS_NPC(obj->carried_by)  && !IS_IMMORTAL(obj->carried_by) )
      obj->prev_owner  = str_dup(obj->carried_by->name);

    obj->carried_by  = NULL;
    obj->next_content  = NULL;
    ch->carry_number  -= get_obj_number( obj );
    ch->carry_weight  -= get_obj_weight( obj );
    return;
}



/*
 * Find the ac value of an obj, including position effect.
 */
int apply_ac( OBJ_DATA *obj, int iWear, int type )
{
  CHAR_DATA *ch = obj->carried_by;
  bool sam = ((ch->class == class_lookup("samurai")) ? TRUE : FALSE);
  bool dwarf = ((ch->race == race_lookup("dwarf")) ? TRUE : FALSE);

  if(ch->class == class_lookup("monk"))
    {
	if(obj->item_type == ITEM_CLOTHING)
	return (obj->level / 3);

      if ( obj->value[4] != 0 || ch->level <= 10 )
	{
        switch ( iWear )
        {
      case WEAR_HEAD: return 2 * ((400/UMAX(10,get_obj_weight(obj)))+(ch->level/8)+1);
      case WEAR_ARMS: return (400/UMAX(10,get_obj_weight(obj)))+(ch->level/8)+1;
      case WEAR_BODY: return 3 * ((400/UMAX(10,get_obj_weight(obj)))+(ch->level/8)+1);
      case WEAR_WAIST:  return (400/UMAX(10,get_obj_weight(obj)))+(ch->level/8)+1;
      case WEAR_LEGS: return 2 * ((400/UMAX(10,get_obj_weight(obj)))+(ch->level/8)+1);
      default:	return 1;
	}
      }
      else
      {
        switch ( iWear )
        {
      case WEAR_HEAD: return 2 * ((400/UMAX(10,get_obj_weight(obj)))+(ch->level/8));
      case WEAR_ARMS: return (400/UMAX(10,get_obj_weight(obj)))+(ch->level/8);
      case WEAR_BODY: return 3 * ((400/UMAX(10,get_obj_weight(obj)))+(ch->level/8));
      case WEAR_WAIST:  return (400/UMAX(10,get_obj_weight(obj)))+(ch->level/8);
      case WEAR_LEGS: return 2 * ((400/UMAX(10,get_obj_weight(obj)))+(ch->level/8));
      default: return 1;
	}
      }
     }
	
    if ( obj->item_type != ITEM_ARMOR )
  return 0;

  if ( obj->value[4] != 0 || ch->level <= 10 )
  {
    switch ( iWear )
    {
    case WEAR_BODY: return (dwarf?4:3) * obj->value[type];
    case WEAR_HEAD: return (dwarf?3:2) * obj->value[type];
    case WEAR_LEGS: return (dwarf?3:2) * obj->value[type];
    case WEAR_FEET: return (sam?2:1) * obj->value[type];
    case WEAR_HANDS:  return (sam?2:1) * obj->value[type];
    case WEAR_ARMS: return (sam?2:1) * obj->value[type];
    case WEAR_SHIELD: return    (dwarf?2:1) * obj->value[type];
    case WEAR_FINGER_L: return     0;
    case WEAR_FINGER_R: return     0;
    case WEAR_NECK_1: return     obj->value[type];
    case WEAR_NECK_2: return     obj->value[type];
    case WEAR_ABOUT:  return (dwarf?3:2) * obj->value[type];
    case WEAR_WAIST:  return (sam?2:1) * obj->value[type];
    case WEAR_WRIST_L:  return    (dwarf?2:1)* obj->value[type];
    case WEAR_WRIST_R:  return     (dwarf?2:1)*obj->value[type];
    case WEAR_HOLD: return     obj->value[type];
    }
  }
  else
  {
    switch ( iWear )
    {
    case WEAR_BODY: return (dwarf?4:3) * (obj->value[type] -1);
    case WEAR_HEAD: return (dwarf?3:2) * (obj->value[type] -1);
    case WEAR_LEGS: return (dwarf?3:2) * (obj->value[type] -1);
    case WEAR_FEET: return (sam?2:1) * (obj->value[type] -1);
    case WEAR_HANDS: return (sam?2:1) * (obj->value[type] -1);
    case WEAR_ARMS: return (sam?2:1) * (obj->value[type] -1);
    case WEAR_SHIELD: return     (dwarf?2:1)*(obj->value[type] -1);
    case WEAR_FINGER_L: return     0;
    case WEAR_FINGER_R: return     0;               
    case WEAR_NECK_1: return     (obj->value[type] -1);
    case WEAR_NECK_2: return     (obj->value[type] -1);
    case WEAR_ABOUT:  return (dwarf?3:2) * (obj->value[type] -1);
    case WEAR_WAIST:  return (sam?2:1) * (obj->value[type] -1);
    case WEAR_WRIST_L:  return     (dwarf?2:1)*(obj->value[type] -1);
    case WEAR_WRIST_R:  return     (dwarf?2:1)*(obj->value[type] -1);
    case WEAR_HOLD: return     (obj->value[type] -1);
    }
  }
    return 0;
}



/*
 * Find a piece of eq on a character.
 */
OBJ_DATA *get_eq_char( CHAR_DATA *ch, int iWear )
{
    OBJ_DATA *obj;

    if (ch == NULL)
  return NULL;

    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
    {
  if (ch == NULL)
  {
    return NULL;
  }
  if ( obj->wear_loc == iWear )
      return obj;
    }

    return NULL;
}



/*
 * Equip a char with an obj.
 */
void equip_char( CHAR_DATA *ch, OBJ_DATA *obj, int iWear )
{
    AFFECT_DATA *paf;
    ROOM_INDEX_DATA *pRoomIndex;
    int i;
    int AppType;
    char buf[MAX_STRING_LENGTH];

    AppType = APPLY_BOTH; 

    if (iWear == WEAR_SECOND)
       AppType = APPLY_SECONDARY;

    if (iWear == WEAR_WIELD)
       AppType = APPLY_PRIMARY;

    if ( get_eq_char( ch, iWear ) != NULL )
    {
  bug( "Equip_char: already equipped (%d).", iWear );
  return;
    }

    if ( ( IS_OBJ_STAT(obj, ITEM_ANTI_EVIL)    && IS_EVIL(ch)    )
    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_GOOD)    && IS_GOOD(ch)    )
    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_NEUTRAL) && IS_NEUTRAL(ch) ) )
    {
  /*
   * Thanks to Morgenes for the bug fix here!
   */
  act( "You are zapped by $p and drop it.", ch, obj, NULL, TO_CHAR ,FALSE);
  act( "$n is zapped by $p and drops it.",  ch, obj, NULL, TO_ROOM ,FALSE);
  obj_from_char( obj );
  obj_to_room( obj, ch->in_room );
  return;
    }

    for (i = 0; i < 4; i++)
      ch->armor[i]        -= apply_ac( obj, iWear,i );
    obj->wear_loc  = iWear;

    if (!obj->enchanted)
  for ( paf = obj->pIndexData->affected; paf != NULL; paf = paf->next )
      if ( paf->location != APPLY_SPELL_AFFECT )
          affect_modify( ch, paf, TRUE, AppType );
    for ( paf = obj->affected; paf != NULL; paf = paf->next )
  if ( paf->location == APPLY_SPELL_AFFECT )
          affect_to_char ( ch, paf );
  else
      affect_modify( ch, paf, TRUE, AppType );

    if ( obj->item_type == ITEM_LIGHT
    &&   obj->value[2] != 0
    &&   ch->in_room != NULL )
  ++ch->in_room->light;

    if( IS_OBJ_STAT(obj, ITEM_TELEPORT) && (obj->item_type != ITEM_ARMOR)
	&& (obj->value[0] > 0 || obj->value[1] == -1) )
      {
        pRoomIndex = get_room_index(obj->value[4]);

       if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
	||   IS_AFFECTED(ch, AFF_CURSE)
        ||   is_affected(ch,gsn_morph)
	||   IS_SET(ch->act, PLR_DWEEB) )
	{
	 sprintf(buf,"%s has forsaken you.\n\r",deity_table[ch->pcdata->deity].pname);
	 send_to_char(buf,ch);
	 return;
	}

        if( pRoomIndex != NULL && !room_is_private(ch,pRoomIndex) )
         {
          if(ch->fighting != NULL)
	   {
	    if(number_percent() <= obj->level*2)
	     {
	      stop_fighting(ch,FALSE);
	      send_to_char("You lose 25 exp for leaving combat.\n\r",ch);
              gain_exp(ch,-25);
	     }
	    else
	     { return; }
	   }
          act( "$n flickers and phases.", ch, NULL, NULL, TO_ROOM ,FALSE);
          char_from_room(ch);
	  clear_mount(ch);
          char_to_room(ch,pRoomIndex);
          send_to_char("You flicker and phase.\n\r",ch);
          act("$n phases in.",ch,NULL,NULL,TO_ROOM,FALSE);
          do_look(ch,"auto");
	  obj->value[0]--;
         }
	}

    return;
}



/*
 * Unequip a char with an obj.
 */
void unequip_char( CHAR_DATA *ch, OBJ_DATA *obj )
{
    AFFECT_DATA *paf = NULL;
    AFFECT_DATA *lpaf = NULL;
    AFFECT_DATA *lpaf_next = NULL;
    int i;
    int AppType;

    AppType = APPLY_BOTH;

    if (obj->wear_loc == WEAR_SECOND)
       AppType = APPLY_SECONDARY;

    if (obj->wear_loc == WEAR_WIELD)
       AppType = APPLY_PRIMARY;

    if ( obj->wear_loc == WEAR_NONE )
    {
  bug( "Unequip_char: already unequipped.", 0 );
  return;
    }

    for (i = 0; i < 4; i++)
      ch->armor[i]  += apply_ac( obj, obj->wear_loc,i );
    obj->wear_loc  = -1;

    if (!obj->enchanted)
    {
  for ( paf = obj->pIndexData->affected; paf != NULL; paf = paf->next )
  {
      if ( paf->location == APPLY_SPELL_AFFECT )
      {
          for ( lpaf = ch->affected; lpaf != NULL; lpaf = lpaf_next )
          {
        lpaf_next = lpaf->next;
        if ((lpaf->type == paf->type) &&
            (lpaf->level == paf->level) &&
            (lpaf->location == APPLY_SPELL_AFFECT))
        {
            affect_remove( ch, lpaf, AppType);
      lpaf_next = NULL;
        }
          }
      }
      else
      {
          affect_modify( ch, paf, FALSE, AppType );
    affect_check(ch,paf->where,paf->bitvector);
      }
  }
    }

    for ( paf = obj->affected; paf != NULL; paf = paf->next )
  if ( paf->location == APPLY_SPELL_AFFECT )
  {
      bug ( "Norm-Apply: %d", 0 );
      for ( lpaf = ch->affected; lpaf != NULL; lpaf = lpaf_next )
      {
    lpaf_next = lpaf->next;
    if ((lpaf->type == paf->type) &&
        (lpaf->level == paf->level) &&
        (lpaf->location == APPLY_SPELL_AFFECT))
    {
        bug ( "location = %d", lpaf->location );
        bug ( "type = %d", lpaf->type );
        affect_remove( ch, lpaf, AppType);
        lpaf_next = NULL;
    }
      }
  }
  else
  {
      affect_modify( ch, paf, FALSE, AppType );
      affect_check(ch,paf->where,paf->bitvector); 
  }

    if ( obj->item_type == ITEM_LIGHT
    &&   obj->value[2] != 0
    &&   ch->in_room != NULL
    &&   ch->in_room->light > 0 )
  --ch->in_room->light;

    /* Primary has been disarmed move Secondary to Primary */
    if (AppType == APPLY_PRIMARY)
    {
       if ((obj = get_eq_char(ch,WEAR_SECOND)) != NULL)
       {
 	  obj_from_char( obj );
 	  obj_to_char( obj, ch);
	  equip_char( ch, obj, WEAR_WIELD );
       }
    }

    /* readd racial affects to restore incase lost on item remove */
    ch->affected_by = ch->affected_by|race_table[ch->race].aff;

    return;
}



/*
 * Count occurrences of an obj in a list.
 */
int count_obj_list( OBJ_INDEX_DATA *pObjIndex, OBJ_DATA *list )
{
    OBJ_DATA *obj;
    int nMatch;

    nMatch = 0;
    for ( obj = list; obj != NULL; obj = obj->next_content )
    {
  if ( obj->pIndexData == pObjIndex )
      nMatch++;
    }

    return nMatch;
}



/*
 * Move an obj out of a room.
 */
void obj_from_room( OBJ_DATA *obj )
{
    ROOM_INDEX_DATA *in_room;
    CHAR_DATA *ch;

    if ( ( in_room = obj->in_room ) == NULL )
    {
  bug( "obj_from_room: NULL.", 0 );
  return;
    }

    for (ch = in_room->people; ch != NULL; ch = ch->next_in_room)
  if (ch->on == obj)
      ch->on = NULL;

    if ( obj == in_room->contents )
    {
  in_room->contents = obj->next_content;
    }
    else
    {
  OBJ_DATA *prev;

  for ( prev = in_room->contents; prev; prev = prev->next_content )
  {
      if ( prev->next_content == obj )
      {
    prev->next_content = obj->next_content;
    break;
      }
  }

  if ( prev == NULL )
  {
      bug( "Obj_from_room: obj not found.", 0 );
      return;
  }
    }

    obj->in_room      = NULL;
    obj->next_content = NULL;
    return;
}



/*
 * Move an obj into a room.
 */
void obj_to_room( OBJ_DATA *obj, ROOM_INDEX_DATA *pRoomIndex )
{
    obj->next_content   = pRoomIndex->contents;
    pRoomIndex->contents  = obj;
    obj->in_room    = pRoomIndex;
    obj->carried_by   = NULL;
    obj->in_obj     = NULL;
    return;
}



/*
 * Move an object into an object.
 */
void obj_to_obj( OBJ_DATA *obj, OBJ_DATA *obj_to )
{
    obj->next_content   = obj_to->contains;
    obj_to->contains    = obj;
    obj->in_obj     = obj_to;
    obj->in_room    = NULL;
    obj->carried_by   = NULL;
    if (obj_to->pIndexData->vnum == OBJ_VNUM_PIT)
        obj->cost = 0; 

    for ( ; obj_to != NULL; obj_to = obj_to->in_obj )
    {
  if ( obj_to->carried_by != NULL )
  {
      obj_to->carried_by->carry_number += get_obj_number( obj );
      obj_to->carried_by->carry_weight += get_obj_weight( obj )
    * WEIGHT_MULT(obj_to) / 100;
  }
    }

    return;
}



/*
 * Move an object out of an object.
 */
void obj_from_obj( OBJ_DATA *obj )
{
    OBJ_DATA *obj_from;

    if ( ( obj_from = obj->in_obj ) == NULL )
    {
  bug( "Obj_from_obj: null obj_from.", 0 );
  return;
    }

    if ( obj == obj_from->contains )
    {
  obj_from->contains = obj->next_content;
    }
    else
    {
  OBJ_DATA *prev;

  for ( prev = obj_from->contains; prev; prev = prev->next_content )
  {
      if ( prev->next_content == obj )
      {
    prev->next_content = obj->next_content;
    break;
      }
  }

  if ( prev == NULL )
  {
      bug( "Obj_from_obj: obj not found.", 0 );
      return;
  }
    }

    obj->next_content = NULL;
    obj->in_obj       = NULL;

    for ( ; obj_from != NULL; obj_from = obj_from->in_obj )
    {
  if ( obj_from->carried_by != NULL )
  {
      obj_from->carried_by->carry_number -= get_obj_number( obj );
      obj_from->carried_by->carry_weight -= get_obj_weight( obj ) 
    * WEIGHT_MULT(obj_from) / 100;
  }
    }

    return;
}



/*
 * Extract an obj from the world.
 */
void extract_obj( OBJ_DATA *obj )
{
    OBJ_DATA *obj_content;
    OBJ_DATA *obj_next;

    if ( obj->in_room != NULL )
  obj_from_room( obj );
    else if ( obj->carried_by != NULL )
  obj_from_char( obj );
    else if ( obj->in_obj != NULL )
  obj_from_obj( obj );

    for ( obj_content = obj->contains; obj_content; obj_content = obj_next )
    {
  obj_next = obj_content->next_content;
  extract_obj( obj_content );
    }

    if ( object_list == obj )
    {
  object_list = obj->next;
    }
    else
    {
  OBJ_DATA *prev;

  for ( prev = object_list; prev != NULL; prev = prev->next )
  {
      if ( prev->next == obj )
      {
    prev->next = obj->next;
    break;
      }
  }

  if ( prev == NULL )
  {
      bug( "Extract_obj: obj %d not found.", obj->pIndexData->vnum );
      return;
  }
    }

    --obj->pIndexData->count;
    free_obj(obj);
    return;
}



/*
 * Extract a char from the world.
 */
void extract_char( CHAR_DATA *ch, bool fPull )
{
    CHAR_DATA *wch;
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;

    if ( ch->in_room == NULL )
    {
  bug( "Extract_char: NULL.", 0 );
  return;
    }
    
    nuke_pets(ch);
    ch->pet = NULL; /* just in case */

    if ( fPull )

  die_follower( ch );
  die_ignore(ch);
    
    stop_fighting( ch, TRUE );

  if(IS_NPC(ch) || (!IS_NPC(ch) && ch->pcdata->sac <= 0))
  {
    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
    {
  obj_next = obj->next_content;
  extract_obj( obj );
    }
  }
    
    char_from_room( ch );
    clear_mount(ch);

    /* MM send them to Clan Hall on death */
    if ( !fPull )
    {
        if (IS_SET(ch->act, PLR_DWEEB))
           char_to_room(ch,get_room_index(ROOM_VNUM_ALTAR));
        else
           char_to_room(ch,get_room_index(clan_table[ch->clan].hall));
  return;
    }

    if ( IS_NPC(ch) )
  --ch->pIndexData->count;

    if ( ch->desc != NULL && ch->desc->original != NULL )
    {
  do_return( ch, "" );
  ch->desc = NULL;
    }

    for ( wch = char_list; wch != NULL; wch = wch->next )
    {
  if ( wch->reply == ch )
      wch->reply = NULL;
    }

    if ( ch == char_list )
    {
       char_list = ch->next;
    }
    else
    {
  CHAR_DATA *prev;

  for ( prev = char_list; prev != NULL; prev = prev->next )
  {
      if ( prev->next == ch )
      {
    prev->next = ch->next;
    break;
      }
  }

  if ( prev == NULL )
  {
      bug( "Extract_char: char not found.", 0 );
      return;
  }
    }

    if ( ch->desc != NULL )
  ch->desc->character = NULL;
    free_char( ch );
    return;
}



/*
 * Find a char in the room.
 */
CHAR_DATA *get_char_room( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *rch,*wch;
    int number;
    int count;

    if (atoi (argument))
      number = number_argument( argument, arg );
    else {
      one_argument (argument,arg);
      number = 0;
    }
    count  = 0;
    if ( !str_cmp( arg, "self" ) )
        return ch;

    wch = NULL;
    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
    {
        if ( !can_see( ch, rch, FALSE ))
	   continue;

	if(IS_SET(rch->mhs,MHS_SHAPEMORPHED))
	{
	  if(is_name( arg, rch->long_descr ) || is_name( arg, rch->name ) )
	  {
	    if (number)
	    {
	      if ( ++count == number )
	        return rch;
	    }
	    else
	    {
	      return rch;
	    }
	  }
	  else
	  {
	    continue;
	  }
	}

	if(IS_SET(rch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE
	       && rch != ch)
	{
	  if(!IS_NPC(ch) && !IS_SET(ch->act, PLR_HOLYLIGHT))
	  {
	    if(!is_name( arg, rch->long_descr ) )
	      continue;
	  }
        }
	else
	{
	  if(!is_name( arg, rch->name ) )
            continue;
	}

        if (number)
	{
           if ( ++count == number ) 
              return rch;
        }
	else
	{
           if (IS_NPC (rch)) return rch;
           if (!wch) wch = rch;
        }
    }

    return wch;
}

/*
 * Lookup a character by ID
 */
CHAR_DATA *get_char_by_id( long id )
{
    CHAR_DATA *ch;

    for ( ch = char_list ; ch != NULL ; ch = ch->next )
	if ( ch->id == id )
		return ch;

    return NULL;
}

/*
 * Find a char in the world.
 */
CHAR_DATA *get_char_world( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    CHAR_DATA *wch;
    int number;
    int count;

    if ( ( wch = get_char_room( ch, argument ) ) != NULL )
  return wch;

    number = number_argument( argument, arg );
    count  = 0;
    for ( wch = char_list; wch != NULL ; wch = wch->next )
    {
  if ( wch->in_room == NULL || !can_see( ch, wch, FALSE ) 
  ||   !is_name( arg, wch->name ) )
      continue;
  if ( ++count == number )
      return wch;
    }

    return NULL;
}



/*
 * Find some object with a given index data.
 * Used by area-reset 'P' command.
 */
OBJ_DATA *get_obj_type( OBJ_INDEX_DATA *pObjIndex )
{
    OBJ_DATA *obj;

    for ( obj = object_list; obj != NULL; obj = obj->next )
    {
  if ( obj->pIndexData == pObjIndex )
      return obj;
    }

    return NULL;
}


/*
 * Find an obj in a list.
 */
OBJ_DATA *get_obj_list( CHAR_DATA *ch, char *argument, OBJ_DATA *list )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int number;
    int count;

    number = number_argument( argument, arg );
    count  = 0;
    for ( obj = list; obj != NULL; obj = obj->next_content )
    {
  if ( can_see_obj( ch, obj ) && is_name( arg, obj->name ) )
  {
      if ( ++count == number )
    return obj;
  }
    }

    return NULL;
}


OBJ_DATA *find_obj_carry( CHAR_DATA *thief, CHAR_DATA *victim, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int number;
    int count;

    number = number_argument( argument, arg );
    count  = 0;
    
    for ( obj = victim->carrying; obj != NULL; obj = obj->next_content )
    {
  	if (        obj->wear_loc == WEAR_NONE
              &&   (can_see_obj( thief, obj ) )
              &&   is_name( arg, obj->name ) )
	      {
      		if ( ++count == number )
	  		return obj;
	      }
    }

    return NULL;
}

OBJ_DATA *find_obj_wear( CHAR_DATA *thief, CHAR_DATA *victim, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int number;
    int count;

    number = number_argument( argument, arg );
    count  = 0;

 for ( obj = victim->carrying; obj != NULL; obj = obj->next_content )
  {
  if (        obj->wear_loc != WEAR_NONE
    &&   (can_see_obj( thief, obj ) )
    &&   is_name( arg, obj->name ) )
      {
      if ( ++count == number )
      return obj;
      }
    }

  return NULL;
}


/*
 * Find an obj in player's inventory.
 */
OBJ_DATA *get_obj_carry( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int number;
    int count;

    number = number_argument( argument, arg );
    count  = 0;
    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
    {
  if ( obj->wear_loc == WEAR_NONE
  &&   (can_see_obj( ch, obj ) ) 
  &&   is_name( arg, obj->name ) )
  {
      if ( ++count == number )
    return obj;
  }
    }

    return NULL;
}



/*
 * Find an obj in player's equipment.
 */
OBJ_DATA *get_obj_wear( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int number;
    int count;

    number = number_argument( argument, arg );
    count  = 0;
    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
    {
  if ( obj->wear_loc != WEAR_NONE
  &&   can_see_obj( ch, obj )
  &&   is_name( arg, obj->name ) )
  {
      if ( ++count == number )
    return obj;
  }
    }

    return NULL;
}



/*
 * Find an obj in the room or in inventory.
 */
OBJ_DATA *get_obj_here( CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *obj;

    obj = get_obj_list( ch, argument, ch->in_room->contents );
    if ( obj != NULL )
  return obj;

    if ( ( obj = get_obj_carry( ch, argument ) ) != NULL )
  return obj;

    if ( ( obj = get_obj_wear( ch, argument ) ) != NULL )
  return obj;

    return NULL;
}



/*
 * Find an obj in the world.
 */
OBJ_DATA *get_obj_world( CHAR_DATA *ch, char *argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *obj;
    int number;
    int count;

    if ( ( obj = get_obj_here( ch, argument ) ) != NULL )
  return obj;

    number = number_argument( argument, arg );
    count  = 0;
    for ( obj = object_list; obj != NULL; obj = obj->next )
    {
  if ( can_see_obj( ch, obj ) && is_name( arg, obj->name ) )
  {
      if ( ++count == number )
    return obj;
  }
    }

    return NULL;
}

/* deduct cost from a character */

void deduct_cost(CHAR_DATA *ch, int cost)
{
    int silver = 0, gold = 0;

    silver = UMIN(ch->silver,cost); 

    if (silver < cost)
    {
  gold = ((cost - silver + 99) / 100);
  silver = cost - 100 * gold;
    }

    ch->gold -= gold;
    ch->silver -= silver;

    if (ch->gold < 0)
    {
  bug("deduct costs: gold %d < 0",ch->gold);
  ch->gold = 0;
    }
    if (ch->silver < 0)
    {
  bug("deduct costs: silver %d < 0",ch->silver);
  ch->silver = 0;
    }
}   
/*
 * Create a 'money' obj.
 */
OBJ_DATA *create_money( int gold, int silver )
{
    char buf[MAX_STRING_LENGTH];
    OBJ_DATA *obj;

    if ( gold < 0 || silver < 0 || (gold == 0 && silver == 0) )
    {
  bug( "Create_money: zero or negative money.",UMIN(gold,silver));
  gold = UMAX(1,gold);
  silver = UMAX(1,silver);
    }

    if (gold == 0 && silver == 1)
    {
  obj = create_object( get_obj_index( OBJ_VNUM_SILVER_ONE ), 0, FALSE );
    }
    else if (gold == 1 && silver == 0)
    {
  obj = create_object( get_obj_index( OBJ_VNUM_GOLD_ONE), 0, FALSE );
    }
    else if (silver == 0)
    {
        obj = create_object( get_obj_index( OBJ_VNUM_GOLD_SOME ), 0, FALSE );
        sprintf( buf, obj->short_descr, gold );
        free_string( obj->short_descr );
        obj->short_descr        = str_dup( buf );
        obj->value[1]           = gold;
        obj->cost               = gold;
  obj->weight   = gold/5;
    }
    else if (gold == 0)
    {
        obj = create_object( get_obj_index( OBJ_VNUM_SILVER_SOME ), 0, FALSE );
        sprintf( buf, obj->short_descr, silver );
        free_string( obj->short_descr );
        obj->short_descr        = str_dup( buf );
        obj->value[0]           = silver;
        obj->cost               = silver;
  obj->weight   = silver/20;
    }
 
    else
    {
  obj = create_object( get_obj_index( OBJ_VNUM_COINS ), 0, FALSE );
  sprintf( buf, obj->short_descr, silver, gold );
  free_string( obj->short_descr );
  obj->short_descr  = str_dup( buf );
  obj->value[0]   = silver;
  obj->value[1]   = gold;
  obj->cost   = 100 * gold + silver;
  obj->weight   = gold / 5 + silver / 20;
    }

    return obj;
}



/*
 * Return # of objects which an object counts as.
 * Thanks to Tony Chamberlain for the correct recursive code here.
 */
int get_obj_number( OBJ_DATA *obj )
{
    int number;

    if (obj->item_type == ITEM_CONTAINER || obj->item_type == ITEM_MONEY)
        number = 0;
    else
        number = 10;

    if ( obj->item_type == ITEM_GEM )  
	number = 5;

    for ( obj = obj->contains; obj != NULL; obj = obj->next_content )
    {

        number +=   get_obj_number( obj );
 }
    return number;
}


/*
 * Return weight of an object, including weight of contents.
 */
int get_obj_weight( OBJ_DATA *obj )
{
    int weight;
    OBJ_DATA *tobj;

    weight = obj->weight;
    for ( tobj = obj->contains; tobj != NULL; tobj = tobj->next_content )
  weight += get_obj_weight( tobj ) * WEIGHT_MULT(obj) / 100;

    return weight;
}

int get_true_weight(OBJ_DATA *obj)
{
    int weight;
 
    weight = obj->weight;
    for ( obj = obj->contains; obj != NULL; obj = obj->next_content )
        weight += get_obj_weight( obj );
 
    return weight;
}

/*
 * True if room is dark.
 */
bool room_is_dark( ROOM_INDEX_DATA *pRoomIndex )
{
    if ( pRoomIndex->light > 0 )
  return FALSE;

    if ( IS_SET(pRoomIndex->room_flags, ROOM_DARK) )
  return TRUE;

    if ( pRoomIndex->sector_type == SECT_INSIDE
    ||   pRoomIndex->sector_type == SECT_CITY )
  return FALSE;

    if ( weather_info.sunlight == SUN_SET
    ||   weather_info.sunlight == SUN_DARK )
  return TRUE;

    return FALSE;
}


bool is_room_owner(CHAR_DATA *ch, ROOM_INDEX_DATA *room)
{
    if (room->owner == NULL || room->owner[0] == '\0')
  return FALSE;
    if (IS_IMMORTAL(ch) && !is_name(ch->name,room->owner) )
	{
	 return is_name("immortal",room->owner);
	}
    return is_name(ch->name,room->owner);
}

/*
 * True if room is private.
 */
bool room_is_private( CHAR_DATA *ch,ROOM_INDEX_DATA *pRoomIndex )
{
    CHAR_DATA *rch;
    int count;


    if (pRoomIndex->owner != NULL && pRoomIndex->owner[0] != '\0')
  return TRUE;

    count = 0;
    for ( rch = pRoomIndex->people; rch != NULL; rch = rch->next_in_room )
  count++;

    if ( IS_SET(pRoomIndex->room_flags, ROOM_PRIVATE)  
    && (count >= 2 || IS_SET(ch->mhs,MHS_HIGHLANDER)))
  return TRUE;

    if ( IS_SET(pRoomIndex->room_flags, ROOM_SOLITARY) 
    && (count >= 1 || IS_SET(ch->mhs,MHS_HIGHLANDER)))
  return TRUE;
    
    if ( IS_SET(pRoomIndex->room_flags, ROOM_IMP_ONLY) )
  return TRUE;

    if ( IS_SET(pRoomIndex->room_flags, ROOM_NOCLAN) 
    && (is_clan(ch) || IS_SET(ch->mhs,MHS_HIGHLANDER))
    && !IS_IMMORTAL(ch))
  return TRUE;

    if ( IS_SET(pRoomIndex->room_flags, ROOM_CLANONLY)
    && (!is_clan(ch) )
    && !IS_IMMORTAL(ch))
  return TRUE;

    return FALSE;
}

/* true if the char can go into the room w/ clan considerations */
bool is_room_clan( CHAR_DATA *ch, ROOM_INDEX_DATA *pRoomIndex )
{
    if ( !pRoomIndex->clan )
	return TRUE;

    if ( pRoomIndex->clan == ch->clan )
	return TRUE;

    if ( IS_IMMORTAL(ch) )
	return TRUE;

    return FALSE;
}

/* visibility on a room -- for entering and exits */
bool can_see_room( CHAR_DATA *ch, ROOM_INDEX_DATA *pRoomIndex )
{
    if (IS_SET(pRoomIndex->room_flags, ROOM_IMP_ONLY) 
    &&  get_trust(ch) < MAX_LEVEL)
  return FALSE;

    if (IS_SET(pRoomIndex->room_flags, ROOM_GODS_ONLY)
    &&  !IS_IMMORTAL(ch))
  return FALSE;

    if (IS_SET(pRoomIndex->room_flags, ROOM_HEROES_ONLY)
    &&  !IS_IMMORTAL(ch))
  return FALSE;

    if (IS_SET(pRoomIndex->room_flags,ROOM_NEWBIES_ONLY)
    &&  ch->level > 5 && !IS_IMMORTAL(ch))
  return FALSE;

    if (IS_SET(pRoomIndex->room_flags,ROOM_NOCLAN)
    &&  (is_clan(ch) || IS_SET(ch->mhs,MHS_HIGHLANDER)) 
    && !IS_IMMORTAL(ch))
  return FALSE;
    if (IS_SET(pRoomIndex->room_flags,ROOM_CLANONLY)
    &&  (!is_clan(ch) )
    && !IS_IMMORTAL(ch))
  return FALSE;

    return TRUE;
}



/*
 * True if char can see victim.
 */
bool can_see( CHAR_DATA *ch, CHAR_DATA *victim, bool ooc )
{
    int chance,nchance;

/* RT changed so that WIZ_INVIS has levels */
    if ( ch == victim )
       return TRUE;

    if ( ooc && victim->level < 52 && !IS_NPC(victim) )
	return TRUE;

    if ( get_trust(ch) < victim->invis_level)
       return FALSE;

    if (get_trust(ch) < victim->incog_level && ch->in_room != victim->in_room)
       return FALSE;

    if ( (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT)) 
          ||(IS_NPC(ch) && IS_IMMORTAL(ch)))
       return TRUE;

    if ( IS_AFFECTED(ch, AFF_BLIND) )
       return FALSE;

    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_IS_CHANGER))
	return TRUE;
   
    if ( !IS_SET(ch->mhs, MHS_GLADIATOR) && IS_SET(victim->mhs, MHS_GLADIATOR))
        return TRUE;

    if(!IS_NPC(ch) && ch->clan == clan_lookup("smurf"))
    {
        if (victim->level <= ch->level)
           return TRUE;

        if (IS_SET(ch->act,PLR_KILLER) || IS_SET(ch->act,PLR_THIEF))
        {
           if(ch->level+12 >= victim->level)
              return TRUE;
        }
        else
        {
           /* Victim is a Thug or Ruffian */
           if(ch->level + (ch->trumps > 0 ? 10 : 8) >= victim->level)
              return TRUE;
        }
    }

    if ( IS_SET(victim->mhs,MHS_FADE) && !IS_NPC(victim))
    {
       nchance = get_skill(victim,gsn_fade);
       if (is_affected(ch,gsn_vision))
          nchance /= 5;

       if(number_percent() <= nchance)
          return FALSE;
       
    }

    if ( room_is_dark( ch->in_room ) && (!IS_AFFECTED(ch, AFF_INFRARED) ) )
       return FALSE;

    if ( IS_AFFECTED(victim, AFF_INVISIBLE)
         && !IS_AFFECTED(ch, AFF_DETECT_INVIS) )
       return FALSE;

    /* sneaking */ 
    if (IS_AFFECTED(victim, AFF_SNEAK) && victim->fighting == NULL) 
    {
       if(!IS_AFFECTED(ch,AFF_DETECT_HIDDEN))
	  return FALSE;
	  
       chance = get_skill(victim,gsn_sneak) * 2 / 3;
       chance += get_curr_stat(victim,STAT_DEX);
       chance -= get_curr_stat(ch,STAT_INT) * 2;
       chance -= (ch->level - victim->level) * 3/2;
       chance += get_skill(victim, gsn_ninjitsu)/5;


       if (IS_NPC(ch))
	  chance *= 3/2;

          if( number_percent() < chance ) 
             return FALSE;
       } 
    
    if (IS_AFFECTED(victim, AFF_HIDE) && victim->fighting == NULL) 
    {
       if(!IS_AFFECTED(ch,AFF_DETECT_HIDDEN))
	  return FALSE;

       chance = get_skill(victim,gsn_hide);
       chance -= get_curr_stat(ch,STAT_INT);
       chance += get_curr_stat(victim,STAT_DEX);
       chance -= (ch->level - victim->level) * 2;

       if ( victim->class == class_lookup("assassin") )
          chance += get_curr_stat(victim,STAT_DEX);

          if( number_percent() <= chance ||
	      number_percent() < get_skill(victim, gsn_ninjitsu))
             return FALSE;
       }

    return TRUE;
}



/*
 * True if char can see obj.
 */
bool can_see_obj( CHAR_DATA *ch, OBJ_DATA *obj )
{
    CHAR_DATA *victim;
    int cancelSN =0;
    int cure_blindSN = 0;
    int i= 0;
    bool  foundSN = FALSE; 

    if(obj->carried_by != NULL)
    {
       victim = obj->carried_by;
       if (!IS_NPC(victim))
       {
          if ( get_trust(ch) < victim->invis_level)
             return FALSE;

          if (get_trust(ch) < victim->incog_level && ch->in_room != victim->in_room)
             return FALSE;
       }
    }

    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT))
  return TRUE;

    if ( IS_SET(obj->extra_flags,ITEM_VIS_DEATH))
  return FALSE;


    if ( IS_OBJ_STAT(obj,ITEM_MAGIC) && IS_OBJ_STAT(obj,ITEM_HUM)
	&& IS_OBJ_STAT(obj,ITEM_GLOW))
  return TRUE;


    if ( IS_AFFECTED(ch,AFF_BLIND) && 
 ( (obj->item_type != ITEM_POTION) && (obj->item_type != ITEM_PILL) )
       )
       {
       /* blind and item is not a pill or potion, can't see it */
             return FALSE;
       }
    
    if ( IS_AFFECTED(ch,AFF_BLIND) && 
 ( (obj->item_type == ITEM_POTION) || (obj->item_type == ITEM_PILL) )
       )
       {
           /* blind and item is pill or potion, check if cure 
	   blind or cancel on it */
           cancelSN = skill_lookup("cure blindness");
	   cure_blindSN = skill_lookup("cancellation");
           for ( i = 1; i<=3 ; i++)
	   {
	     if(obj->value[i] == cancelSN || obj->value[i] == cure_blindSN )
	       foundSN = TRUE;
	   }
	      return foundSN;
       }

    if ( ( IS_OBJ_STAT(obj,ITEM_MAGIC) && IS_OBJ_STAT(obj,ITEM_HUM) )
	|| IS_OBJ_STAT(obj,ITEM_GLOW))
  return TRUE;


    if(!IS_NPC(ch) && ch->clan != clan_lookup("smurf"))
    {
       if ( IS_SET(obj->extra_flags, ITEM_INVIS)
            && !IS_AFFECTED(ch, AFF_DETECT_INVIS) )
          return FALSE;

       if ( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
          return TRUE;

       if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_INFRARED) )
          return FALSE;
    }

    return TRUE;
}


/*
 * True if char can wear obj.
 */
bool can_wear_obj( CHAR_DATA *ch, OBJ_DATA *obj )
{
    if ( IS_NPC(ch) || ch->level >= LEVEL_IMMORTAL )
	return TRUE;

    if ( obj->item_type != ITEM_ARMOR )
	return TRUE;

    if ( obj->value[4] == 0 )
	return TRUE;

    if ( (obj->value[4] -1) == ch->size )
	return TRUE;

    if ( ch->level < 11 )
	return TRUE;

    return FALSE;
}

/*
 * True if char can drop obj.
 */
bool can_drop_obj( CHAR_DATA *ch, OBJ_DATA *obj )
{
    if ( !IS_SET(obj->extra_flags, ITEM_NODROP) )
  return TRUE;

    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
  return TRUE;

    return FALSE;
}



/*
 * Return ascii name of an item type.
 */
char *item_type_name( OBJ_DATA *obj )
{
    return item_type_name_num (obj->item_type);
}

char *item_type_name_num (int num)
{
    switch ( num )
    {
    case ITEM_LIGHT:    return "light";
    case ITEM_SCROLL:   return "scroll";
    case ITEM_WAND:   return "wand";
    case ITEM_STAFF:    return "staff";
    case ITEM_WEAPON:   return "weapon";
    case ITEM_TREASURE:   return "treasure";
    case ITEM_ARMOR:    return "armor";
    case ITEM_CLOTHING:   return "clothing";
    case ITEM_POTION:   return "potion";
    case ITEM_FURNITURE:  return "furniture";
    case ITEM_TRASH:    return "trash";
    case ITEM_CONTAINER:  return "container";
    case ITEM_DRINK_CON:  return "drink container";
    case ITEM_KEY:    return "key";
    case ITEM_FOOD:   return "food";
    case ITEM_MONEY:    return "money";
    case ITEM_BOAT:   return "boat";
    case ITEM_CORPSE_NPC: return "npc corpse";
    case ITEM_CORPSE_PC:  return "pc corpse";
    case ITEM_FOUNTAIN:   return "fountain";
    case ITEM_PILL:   return "pill";
    case ITEM_MAP:    return "map";
    case ITEM_PORTAL:   return "portal";
    case ITEM_WARP_STONE: return "warp stone";
    case ITEM_GEM:    return "gem";
    case ITEM_JEWELRY:    return "jewelry";
    case ITEM_JUKEBOX:    return "juke box";
    case ITEM_TRAP:	return "trap part";
    case ITEM_GRENADE: return "grenade";
    case ITEM_SPELL_PAGE: return "spell page";
    case ITEM_PART: return "item part";
    case ITEM_FORGE: return "forge";
    case 0: return "not used";
    }

    /* bug( "Item_type_name: unknown type %d.", num );  */
    return "unknown";
}




/*
 * Return ascii name of an affect location.
 */
char *affect_loc_name( int location )
{
    switch ( location )
    {
    case APPLY_NONE:    return "none";
    case APPLY_REFLEX_SAVE: 	return "reflex saves";
    case APPLY_FORTITUDE_SAVE:	return "fortitude saves";
    case APPLY_WILLPOWER_SAVE:  return "willpower saves";
    case APPLY_STR:   return "strength";
    case APPLY_DEX:   return "dexterity";
    case APPLY_INT:   return "intelligence";
    case APPLY_WIS:   return "wisdom";
    case APPLY_CON:   return "constitution";
    case APPLY_AGT:   return "agility";
    case APPLY_END:   return "endurance";
    case APPLY_SOC:   return "social";
    case APPLY_SEX:   return "sex";
    case APPLY_CLASS:   return "class";
    case APPLY_LEVEL:   return "level";
    case APPLY_AGE:   return "age";
    case APPLY_MANA:    return "mana";
    case APPLY_HIT:   return "hp";
    case APPLY_MOVE:    return "moves";
    case APPLY_GOLD:    return "gold";
    case APPLY_EXP:   return "experience";
    case APPLY_AC:    return "armor class";
    case APPLY_HITROLL:   return "hit roll";
    case APPLY_DAMROLL:   return "damage roll";
    case APPLY_SAVES:   return "saves";
    case APPLY_SAVING_ROD:  return "save vs rod";
    case APPLY_SAVING_PETRI:  return "save vs petrification";
    case APPLY_SAVING_BREATH: return "save vs breath";
    case APPLY_SAVING_SPELL:  return "save vs spell";
    case APPLY_SIZE:   return "size";
    case APPLY_SPELL_AFFECT:  return "none";
    }

    bug( "Affect_location_name: unknown location %d.", location );
    return "(unknown)";
}



/*
 * Return ascii name of an affect bit vector.
 */
char *affect_bit_name( int vector )
{
    static char buf[512];

    buf[0] = '\0';
    if ( vector & AFF_BLIND         ) strcat( buf, " blind"         );
    if ( vector & AFF_INVISIBLE     ) strcat( buf, " invisible"     );
    if ( vector & AFF_DETECT_ALIGN  ) strcat( buf, " detect_align"  );
    if ( vector & AFF_DETECT_INVIS  ) strcat( buf, " detect_invis"  );
    if ( vector & AFF_DETECT_MAGIC  ) strcat( buf, " detect_magic"  );
    if ( vector & AFF_DETECT_HIDDEN ) strcat( buf, " detect_hidden" );
    if ( vector & AFF_SANCTUARY     ) strcat( buf, " sanctuary"     );
    if ( vector & AFF_FAERIE_FIRE   ) strcat( buf, " faerie_fire"   );
    if ( vector & AFF_FAERIE_FOG    ) strcat( buf, " faerie_fog"    );
    if ( vector & AFF_INFRARED      ) strcat( buf, " infrared"      );
    if ( vector & AFF_CURSE         ) strcat( buf, " curse"         );
    if ( vector & AFF_POISON        ) strcat( buf, " poison"        );
    if ( vector & AFF_PROTECT_EVIL  ) strcat( buf, " prot_evil"     );
    if ( vector & AFF_PROTECT_GOOD  ) strcat( buf, " prot_good"     );
    if ( vector & AFF_SLEEP         ) strcat( buf, " sleep"         );
    if ( vector & AFF_SNEAK         ) strcat( buf, " sneak"         );
    if ( vector & AFF_HIDE          ) strcat( buf, " hide"          );
    if ( vector & AFF_CHARM         ) strcat( buf, " charm"         );
    if ( vector & AFF_FLYING        ) strcat( buf, " flying"        );
    if ( vector & AFF_PASS_DOOR     ) strcat( buf, " pass_door"     );
    if ( vector & AFF_BERSERK     ) strcat( buf, " berserk"     );
    if ( vector & AFF_CALM      ) strcat( buf, " calm"      );
    if ( vector & AFF_HASTE     ) strcat( buf, " haste"     );
    if ( vector & AFF_SLOW          ) strcat( buf, " slow"          );
    if ( vector & AFF_PLAGUE      ) strcat( buf, " plague"      );
    if ( vector & AFF_WEAPONRY   ) strcat( buf, " weaponry"   );
    if ( vector & AFF_WITHSTAND_DEATH ) strcat (buf, " withstand_death" );
    return ( buf[0] != '\0' ) ? buf+1 : "none";
}



/*
 * Return ascii name of extra flags vector.
 */
char *extra_bit_name( int extra_flags )
{
    static char buf[512];

    buf[0] = '\0';
    if ( extra_flags & ITEM_GLOW         ) strcat( buf, " glow"         );
    if ( extra_flags & ITEM_HUM          ) strcat( buf, " hum"          );
    /*
    if ( extra_flags & ITEM_DARK         ) strcat( buf, " dark"         );
    */
    if ( extra_flags & ITEM_LOCK         ) strcat( buf, " lock"         );
    if ( extra_flags & ITEM_EVIL         ) strcat( buf, " evil"         );
    if ( extra_flags & ITEM_INVIS        ) strcat( buf, " invis"        );
    if ( extra_flags & ITEM_MAGIC        ) strcat( buf, " magic"        );
    if ( extra_flags & ITEM_NODROP       ) strcat( buf, " nodrop"       );
    if ( extra_flags & ITEM_BLESS        ) strcat( buf, " bless"        );
    if ( extra_flags & ITEM_ANTI_GOOD    ) strcat( buf, " anti-good"    );
    if ( extra_flags & ITEM_ANTI_EVIL    ) strcat( buf, " anti-evil"    );
    if ( extra_flags & ITEM_ANTI_NEUTRAL ) strcat( buf, " anti-neutral" );
    if ( extra_flags & ITEM_NOREMOVE     ) strcat( buf, " noremove"     );
    if ( extra_flags & ITEM_INVENTORY    ) strcat( buf, " inventory"    );
    if ( extra_flags & ITEM_NOPURGE  ) strcat( buf, " nopurge"  );
    if ( extra_flags & ITEM_VIS_DEATH  ) strcat( buf, " vis_death"  );
    if ( extra_flags & ITEM_ROT_DEATH  ) strcat( buf, " rot_death"  );
    if ( extra_flags & ITEM_NOLOCATE   ) strcat( buf, " no_locate"  );
    if ( extra_flags & ITEM_SELL_EXTRACT ) strcat( buf, " sell_extract" );
    if ( extra_flags & ITEM_WEAR_TIMER  ) strcat( buf, " wear_timer" );
    if ( extra_flags & ITEM_BURN_PROOF   ) strcat( buf, " burn_proof" );
    if ( extra_flags & ITEM_NOUNCURSE  ) strcat( buf, " no_uncurse" );
    if ( extra_flags & ITEM_WARPED  ) strcat( buf, " warped" );
    if ( extra_flags & ITEM_TELEPORT  ) strcat( buf, " teleport" );
    if ( extra_flags & ITEM_NOIDENTIFY  ) strcat( buf, " noidentify" );
    if ( extra_flags & ITEM_IMM_LOAD    ) strcat( buf, " immload"     );
    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *obj_spec_bit_name( int obj_spec_flags )
{
    static char buf[512];

    buf[0] = '\0';

    return ( buf[0] != '\0' ) ? buf+1 : "none";
} 


char *mhs_bit_name( int mhs_flags )
{
    static char buf[512];

    buf[0] = '\0';

   if (mhs_flags & MHS_OLD_RECLASS) 	strcat(buf, " old-reclass");
   if (mhs_flags & MHS_MUTANT  ) 	strcat(buf, " mutant");
   if (mhs_flags & MHS_HIGHLANDER  ) 	strcat(buf, " highlander");
   if (mhs_flags & MHS_SAVANT )		strcat(buf, " savant");
   if (mhs_flags & MHS_SHAPESHIFTED )	strcat(buf, " shapeshifted");
   if (mhs_flags & MHS_SHAPEMORPHED )	strcat(buf, " shapemorphed");
   if (mhs_flags & MHS_NORESCUE )	strcat(buf, " norescue");
   if (mhs_flags & MHS_PREFRESHED )	strcat(buf, " prefreshed");
   if (mhs_flags & MHS_GLADIATOR )	strcat(buf, " gladiator");
   if (mhs_flags & MHS_ELEMENTAL )      strcat(buf, " elemental");
   if (mhs_flags & MHS_BANISH    )      strcat(buf, " banished");
   if (mhs_flags & MHS_WARLOCK_ENEMY )	strcat(buf, " warlock-enemy");
   if (mhs_flags & MHS_ZEALOT_ENEMY )	strcat(buf, " zealot-enemy");
   if (mhs_flags & MHS_POSSE_ENEMY )	strcat(buf, " posse-enemy");
   if (mhs_flags & MHS_HONOR_ENEMY )	strcat(buf, " honor-enemy");
   if (mhs_flags & MHS_FULL_SAC )	strcat(buf, " full_sac");

     return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *exit_bit_name( int exit_flags )
{
    static char buf[512];

    buf[0] = '\0';

    if ( exit_flags & EX_ISDOOR )	strcat(buf, " is-door");
    if ( exit_flags & EX_CLOSED )	strcat(buf, " closed");
    if ( exit_flags & EX_LOCKED )	strcat(buf, " locked");
    if ( exit_flags & EX_PICKPROOF)	strcat(buf, " pickproof");
    if ( exit_flags & EX_NOPASS)	strcat(buf, " nopassdoor");
    if ( exit_flags & EX_EASY)		strcat(buf, " easy-pick");
    if ( exit_flags & EX_HARD)		strcat(buf, " hard-pick");
    if ( exit_flags & EX_INFURIATING)    strcat(buf, " infur-pick");
    if ( exit_flags & EX_NOCLOSE)	strcat(buf, " no-close");
    if ( exit_flags & EX_NOLOCK)	strcat(buf, " no-lock");
    if ( exit_flags & EX_CONCEALED)	strcat(buf, " concealed");
    if ( exit_flags & EX_SECRET)	strcat(buf, " secret");
    if ( exit_flags & EX_NEW_FORMAT)	strcat(buf, " NEW_FORMAT");

     return ( buf[0] != '\0' ) ? buf+1 : "none";
}

/* return ascii name of clan flags */
char *clan_bit_name ( int clan_flags )
{
   static char buf[512];

   buf[0] = '\0';

   if ( clan_flags & CLAN_NO_HALL ) strcat(buf, " no_hall");
   if ( clan_flags & CLAN_NO_HEALER) strcat(buf, " no_healer");
   if ( clan_flags & CLAN_NO_CHANNEL) strcat(buf, " no_clan_channel");
   if ( clan_flags & CLAN_NO_PORTALS) strcat(buf, " no_portal");
   if ( clan_flags & CLAN_NO_REGEN) strcat(buf, " no_regen");
   if ( clan_flags & CLAN_NO_STORE) strcat(buf, " no_store");
   if ( clan_flags & CLAN_NO_SKILL_1) strcat(buf, " no_skill");
   if ( clan_flags & CLAN_ALLOW_SANC ) strcat(buf, " allowed");
    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

/* return ascii name of an act vector */
char *act_bit_name( int act_flags )
{
    static char buf[512];

    buf[0] = '\0';

    if (IS_SET(act_flags,ACT_IS_NPC))
    { 
  strcat(buf," npc");
      if (act_flags & ACT_SENTINEL  ) strcat(buf, " sentinel");
      if (act_flags & ACT_SCAVENGER ) strcat(buf, " scavenger");
  if (act_flags & ACT_AGGRESSIVE  ) strcat(buf, " aggressive");
  if (act_flags & ACT_STAY_AREA ) strcat(buf, " stay_area");
  if (act_flags & ACT_WIMPY ) strcat(buf, " wimpy");
  if (act_flags & ACT_PET   ) strcat(buf, " pet");
  if (act_flags & ACT_TRAIN ) strcat(buf, " train");
  if (act_flags & ACT_PRACTICE  ) strcat(buf, " practice");
  if (act_flags & ACT_UNDEAD  ) strcat(buf, " undead");
  if (act_flags & ACT_CLERIC  ) strcat(buf, " cleric");
  if (act_flags & ACT_MAGE  ) strcat(buf, " mage");
  if (act_flags & ACT_THIEF ) strcat(buf, " thief");
  if (act_flags & ACT_WARRIOR ) strcat(buf, " warrior");
  if (act_flags & ACT_NOALIGN ) strcat(buf, " no_align");
  if (act_flags & ACT_NOPURGE ) strcat(buf, " no_purge");
  if (act_flags & ACT_IS_HEALER ) strcat(buf, " healer");
  if (act_flags & ACT_IS_CHANGER  ) strcat(buf, " changer");
  if (act_flags & ACT_IS_ARMOURER  ) strcat(buf, " armourer");
  if (act_flags & ACT_IS_WEAPONSMITH  ) strcat(buf, " weaponsmith");
  if (act_flags & ACT_GAIN  ) strcat(buf, " skill_train");
  if (act_flags & ACT_UPDATE_ALWAYS) strcat(buf," update_always");
    }
    else
    {
  strcat(buf," player");
  if (act_flags & PLR_AUTOASSIST  ) strcat(buf, " autoassist");
  if (act_flags & PLR_RECLASS ) strcat(buf, " reclass");
  if (act_flags & PLR_CANCLAN ) strcat(buf, " canclan");
  if (act_flags & PLR_AUTOEXIT  ) strcat(buf, " autoexit");
  if (act_flags & PLR_AUTOLOOT  ) strcat(buf, " autoloot");
  if (act_flags & PLR_AUTOSAC ) strcat(buf, " autosac");
  if (act_flags & PLR_AUTOGOLD  ) strcat(buf, " autogold");
  if (act_flags & PLR_AUTOSPLIT ) strcat(buf, " autosplit");
  if (act_flags & PLR_HOLYLIGHT ) strcat(buf, " holy_light");
  if (act_flags & PLR_CANLOOT ) strcat(buf, " loot_corpse");
  if (act_flags & PLR_NOSUMMON  ) strcat(buf, " no_summon");
  if (act_flags & PLR_NOFOLLOW  ) strcat(buf, " no_follow");
  if (act_flags & PLR_FREEZE  ) strcat(buf, " frozen");
  if (act_flags & PLR_THIEF ) strcat(buf, " thief");
  if (act_flags & PLR_KILLER  ) strcat(buf, " killer");
  if (act_flags & PLR_THUG  ) strcat(buf, " thug");
    }
    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *comm_bit_name(int comm_flags)
{
    static char buf[512];

    buf[0] = '\0';

    if (comm_flags & COMM_QUIET   ) strcat(buf, " quiet");
    if (comm_flags & COMM_DEAF    ) strcat(buf, " deaf");
    if (comm_flags & COMM_NOWIZ   ) strcat(buf, " no_wiz");
    if (comm_flags & COMM_NOBITCH ) strcat(buf, " no_bitch");
    if (comm_flags & COMM_NOAUCTION ) strcat(buf, " no_auction");
    if (comm_flags & COMM_NOGOSSIP  ) strcat(buf, " no_gossip");
    if (comm_flags & COMM_NOOOC  ) strcat(buf, " no_ooc");
    if (comm_flags & COMM_NOQUESTION  ) strcat(buf, " no_question");
    if (comm_flags & COMM_NOMUSIC ) strcat(buf, " no_music");
    if (comm_flags & COMM_NOQUOTE ) strcat(buf, " no_quote");
    if (comm_flags & COMM_NOEMOTE ) strcat(buf, " no_emote");
    if (comm_flags & COMM_NOSHOUT ) strcat(buf, " no_shout");
    if (comm_flags & COMM_NOTELL  ) strcat(buf, " no_tell");
    if (comm_flags & COMM_NOCHANNELS  ) strcat(buf, " no_channels");
    if (comm_flags & COMM_BRIEF_MENUS) strcat (buf," brief_menus");    

    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *imm_bit_name(int imm_flags)
{
    static char buf[512];

    buf[0] = '\0';

    if (imm_flags & IMM_SUMMON    ) strcat(buf, " summon");
    if (imm_flags & IMM_CHARM   ) strcat(buf, " charm");
    if (imm_flags & IMM_MAGIC   ) strcat(buf, " magic");
    if (imm_flags & IMM_WEAPON    ) strcat(buf, " weapon");
    if (imm_flags & IMM_BASH    ) strcat(buf, " blunt");
    if (imm_flags & IMM_PIERCE    ) strcat(buf, " piercing");
    if (imm_flags & IMM_SLASH   ) strcat(buf, " slashing");
    if (imm_flags & IMM_FIRE    ) strcat(buf, " fire");
    if (imm_flags & IMM_COLD    ) strcat(buf, " cold");
    if (imm_flags & IMM_LIGHTNING ) strcat(buf, " lightning");
    if (imm_flags & IMM_ACID    ) strcat(buf, " acid");
    if (imm_flags & IMM_POISON    ) strcat(buf, " poison");
    if (imm_flags & IMM_NEGATIVE  ) strcat(buf, " negative");
    if (imm_flags & IMM_HOLY    ) strcat(buf, " holy");
    if (imm_flags & IMM_ENERGY    ) strcat(buf, " energy");
    if (imm_flags & IMM_MENTAL    ) strcat(buf, " mental");
    if (imm_flags & IMM_DISEASE ) strcat(buf, " disease");
    if (imm_flags & IMM_DROWNING  ) strcat(buf, " drowning");
    if (imm_flags & IMM_LIGHT   ) strcat(buf, " light");
    if (imm_flags & IMM_IRON   ) strcat(buf, " iron");
    if (imm_flags & IMM_WOOD   ) strcat(buf, " wood");
    if (imm_flags & IMM_SILVER ) strcat(buf, " silver");
    if (imm_flags & VULN_DISTRACTION ) strcat(buf, " distraction");
    if (imm_flags & RES_DELAY ) strcat(buf, " delay");

    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *wear_bit_name(int wear_flags)
{
    static char buf[512];

    buf [0] = '\0';
    if (wear_flags & ITEM_TAKE    ) strcat(buf, " take");
    if (wear_flags & ITEM_WEAR_FINGER ) strcat(buf, " finger");
    if (wear_flags & ITEM_WEAR_NECK ) strcat(buf, " neck");
    if (wear_flags & ITEM_WEAR_BODY ) strcat(buf, " torso");
    if (wear_flags & ITEM_WEAR_HEAD ) strcat(buf, " head");
    if (wear_flags & ITEM_WEAR_LEGS ) strcat(buf, " legs");
    if (wear_flags & ITEM_WEAR_FEET ) strcat(buf, " feet");
    if (wear_flags & ITEM_WEAR_HANDS  ) strcat(buf, " hands");
    if (wear_flags & ITEM_WEAR_ARMS ) strcat(buf, " arms");
    if (wear_flags & ITEM_WEAR_SHIELD ) strcat(buf, " shield");
    if (wear_flags & ITEM_WEAR_ABOUT  ) strcat(buf, " body");
    if (wear_flags & ITEM_WEAR_WAIST  ) strcat(buf, " waist");
    if (wear_flags & ITEM_WEAR_WRIST  ) strcat(buf, " wrist");
    if (wear_flags & ITEM_WIELD   ) strcat(buf, " wield");
    if (wear_flags & ITEM_HOLD    ) strcat(buf, " hold");
    if (wear_flags & ITEM_WEAR_FLOAT  ) strcat(buf, " float");

    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *form_bit_name(int form_flags)
{
    static char buf[512];

    buf[0] = '\0';
    if (form_flags & FORM_POISON  ) strcat(buf, " poison");
    else if (form_flags & FORM_EDIBLE ) strcat(buf, " edible");
    if (form_flags & FORM_MAGICAL ) strcat(buf, " magical");
    if (form_flags & FORM_INSTANT_DECAY ) strcat(buf, " instant_rot");
    if (form_flags & FORM_OTHER   ) strcat(buf, " other");
    if (form_flags & FORM_ANIMAL  ) strcat(buf, " animal");
    if (form_flags & FORM_SENTIENT  ) strcat(buf, " sentient");
    if (form_flags & FORM_UNDEAD  ) strcat(buf, " undead");
    if (form_flags & FORM_CONSTRUCT ) strcat(buf, " construct");
    if (form_flags & FORM_MIST    ) strcat(buf, " mist");
    if (form_flags & FORM_INTANGIBLE  ) strcat(buf, " intangible");
    if (form_flags & FORM_BIPED   ) strcat(buf, " biped");
    if (form_flags & FORM_CENTAUR ) strcat(buf, " centaur");
    if (form_flags & FORM_INSECT  ) strcat(buf, " insect");
    if (form_flags & FORM_SPIDER  ) strcat(buf, " spider");
    if (form_flags & FORM_CRUSTACEAN  ) strcat(buf, " crustacean");
    if (form_flags & FORM_WORM    ) strcat(buf, " worm");
    if (form_flags & FORM_BLOB    ) strcat(buf, " blob");
    if (form_flags & FORM_MAMMAL  ) strcat(buf, " mammal");
    if (form_flags & FORM_BIRD    ) strcat(buf, " bird");
    if (form_flags & FORM_REPTILE ) strcat(buf, " reptile");
    if (form_flags & FORM_SNAKE   ) strcat(buf, " snake");
    if (form_flags & FORM_DRAGON  ) strcat(buf, " dragon");
    if (form_flags & FORM_AMPHIBIAN ) strcat(buf, " amphibian");
    if (form_flags & FORM_FISH    ) strcat(buf, " fish");
    if (form_flags & FORM_COLD_BLOOD  ) strcat(buf, " cold_blooded");

    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *part_bit_name(int part_flags)
{
    static char buf[512];

    buf[0] = '\0';
    if (part_flags & PART_HEAD    ) strcat(buf, " head");
    if (part_flags & PART_ARMS    ) strcat(buf, " arms");
    if (part_flags & PART_LEGS    ) strcat(buf, " legs");
    if (part_flags & PART_HEART   ) strcat(buf, " heart");
    if (part_flags & PART_BRAINS  ) strcat(buf, " brains");
    if (part_flags & PART_GUTS    ) strcat(buf, " guts");
    if (part_flags & PART_HANDS   ) strcat(buf, " hands");
    if (part_flags & PART_FEET    ) strcat(buf, " feet");
    if (part_flags & PART_FINGERS ) strcat(buf, " fingers");
    if (part_flags & PART_EAR   ) strcat(buf, " ears");
    if (part_flags & PART_EYE   ) strcat(buf, " eyes");
    if (part_flags & PART_LONG_TONGUE ) strcat(buf, " long_tongue");
    if (part_flags & PART_EYESTALKS ) strcat(buf, " eyestalks");
    if (part_flags & PART_TENTACLES ) strcat(buf, " tentacles");
    if (part_flags & PART_FINS    ) strcat(buf, " fins");
    if (part_flags & PART_WINGS   ) strcat(buf, " wings");
    if (part_flags & PART_TAIL    ) strcat(buf, " tail");
    if (part_flags & PART_CLAWS   ) strcat(buf, " claws");
    if (part_flags & PART_FANGS   ) strcat(buf, " fangs");
    if (part_flags & PART_HORNS   ) strcat(buf, " horns");
    if (part_flags & PART_SCALES  ) strcat(buf, " scales");

    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *weapon_bit_name(int weapon_flags)
{
    static char buf[512];

    buf[0] = '\0';
    if (weapon_flags & WEAPON_FLAMING ) strcat(buf, " flaming");
    if (weapon_flags & WEAPON_FROST ) strcat(buf, " frost");
    if (weapon_flags & WEAPON_VAMPIRIC  ) strcat(buf, " vampiric");
    if (weapon_flags & WEAPON_SHARP ) strcat(buf, " sharp");
    if (weapon_flags & WEAPON_VORPAL  ) strcat(buf, " vorpal");
    if (weapon_flags & WEAPON_TWO_HANDS ) strcat(buf, " two-handed");
    if (weapon_flags & WEAPON_SHOCKING  ) strcat(buf, " shocking");
    if (weapon_flags & WEAPON_POISON  ) strcat(buf, " poison");
    if (weapon_flags & WEAPON_STUN  ) strcat(buf, " stun");
    if (weapon_flags & WEAPON_HOLY ) strcat(buf, " holy");
    if (weapon_flags & WEAPON_FAVORED ) strcat(buf, " favored");
    if (weapon_flags & WEAPON_NETHER ) strcat(buf, " nether" );
    if (weapon_flags & WEAPON_SCION ) strcat(buf, " scionic" );
    return ( buf[0] != '\0' ) ? buf+1 : "none";
}

char *cont_bit_name( int cont_flags)
{
    static char buf[512];

    buf[0] = '\0';

    if (cont_flags & CONT_CLOSEABLE ) strcat(buf, " closable");
    if (cont_flags & CONT_PICKPROOF ) strcat(buf, " pickproof");
    if (cont_flags & CONT_CLOSED  ) strcat(buf, " closed");
    if (cont_flags & CONT_LOCKED  ) strcat(buf, " locked");

    return (buf[0] != '\0' ) ? buf+1 : "none";
}


char *off_bit_name(int off_flags)
{
    static char buf[512];

    buf[0] = '\0';

    if (off_flags & OFF_AREA_ATTACK ) strcat(buf, " area attack");
    if (off_flags & OFF_BACKSTAB  ) strcat(buf, " backstab");
    if (off_flags & OFF_BASH    ) strcat(buf, " bash");
    if (off_flags & OFF_BERSERK   ) strcat(buf, " berserk");
    if (off_flags & OFF_DISARM    ) strcat(buf, " disarm");
    if (off_flags & OFF_DODGE   ) strcat(buf, " dodge");
    if (off_flags & OFF_FADE    ) strcat(buf, " fade");
    if (off_flags & OFF_FAST    ) strcat(buf, " fast");
    if (off_flags & OFF_KICK    ) strcat(buf, " kick");
    if (off_flags & OFF_KICK_DIRT ) strcat(buf, " kick_dirt");
    if (off_flags & OFF_PARRY   ) strcat(buf, " parry");
    if (off_flags & OFF_RESCUE    ) strcat(buf, " rescue");
    if (off_flags & OFF_TAIL    ) strcat(buf, " tail");
    if (off_flags & OFF_TRIP    ) strcat(buf, " trip");
    if (off_flags & OFF_CRUSH   ) strcat(buf, " crush");
    if (off_flags & ASSIST_ALL    ) strcat(buf, " assist_all");
    if (off_flags & ASSIST_ALIGN  ) strcat(buf, " assist_align");
    if (off_flags & ASSIST_RACE   ) strcat(buf, " assist_race");
    if (off_flags & ASSIST_PLAYERS  ) strcat(buf, " assist_players");
    if (off_flags & ASSIST_GUARD  ) strcat(buf, " assist_guard");
    if (off_flags & ASSIST_VNUM   ) strcat(buf, " assist_vnum");
    return ( buf[0] != '\0' ) ? buf+1 : "none";
}


void add_prev_owner( OBJ_DATA *obj, CHAR_DATA *ch)
{

 char buf[MAX_STRING_LENGTH];
 char buf2[MAX_STRING_LENGTH];
 char buf3[MAX_STRING_LENGTH];
 int count = 0, i;
 int n = 0;
 bool sCopy = FALSE;

 /* grab the current list of previous owners */

   strcpy(buf, obj->prev_owner);
   log_string(buf);

 /* count the number of names in the list */

 for ( i = 0; i <=strlen(buf); i++)
 {
   if (isspace(buf[i]))
     count++;
 }
 
 /* if we don't have 5 names yet, just tack on the last name, and return */
 if ( count < 5)
 {
 strcat(buf, ch->name);
 strcat(buf, " ");
 obj->prev_owner = strdup(buf);
 sprintf(buf3, "count: %d  buf: %s", count, buf);
 log_string(buf3);
 return;
 }
 /* now comes the hard part, removed the first name, and tack on the new one */
 else
 {
 for (i=0; i<=strlen(buf) ; i++) 
 {
 if ( isspace(buf[i]) && !sCopy )
    sCopy = TRUE;
 
 if (sCopy)
 {
  buf2[n++] = buf[i];
 }
 }
 obj->prev_owner = strdup(buf2);
 sprintf(buf3, "count: %d  buf: %s", count, buf);
 log_string(buf3);
 }
 return;
}

bool check_hai_ruki( CHAR_DATA *ch )
{
    OBJ_DATA *sword;

    if ((sword=get_eq_char(ch,WEAR_WIELD))!=NULL &&
         sword->value[0] == WEAPON_SWORD &&
             number_percent() > get_skill(ch,skill_lookup("hai-ruki")))
	return TRUE;

    return FALSE;
}

int count_groupies_in_room( CHAR_DATA *ch )
{
    CHAR_DATA *v;
     int count=0;

    for ( v = ch->in_room->people ; v != NULL ; v = v->next_in_room )
	if ( is_same_group(ch,v) || v == ch )
		++count;

    return count;
}

bool shogun_in_group( CHAR_DATA *ch )
{
    return FALSE;

    /* CHAR_DATA *v;

    for ( v = ch->in_room->people ; v != NULL ; v = v->next_in_room )
        if ( is_same_group(ch,v) && HAS_KIT(v,"shogun") )
	return TRUE;

    return FALSE;
    */
}

int smurf_group_count (CHAR_DATA *ch )
{
    CHAR_DATA *v;
    int count = 0;

    for ( v = ch->in_room->people ; v != NULL ; v = v->next_in_room )
        if ( v->race == race_lookup("smurf") &&
	   ( is_same_group(ch,v) || v == ch ))
		++count;

    return count;
}

bool room_has_medium( CHAR_DATA *ch )
{
    CHAR_DATA *vch;

    if ( ch == NULL || ch->in_room == NULL )
	return 0;

    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room )
	if ( !IS_NPC(vch) && HAS_KIT(vch,"medium") )
	    return vch->level;

    return 0;
}

int count_fight_size(CHAR_DATA *ch)
{
  int count = 0;
  CHAR_DATA *vch;

  for (vch = ch->in_room->people ; vch != NULL; vch = vch->next_in_room )
  {

       if (vch->fighting == ch)
	 ++count;
  }
  
  return count;

}
  
@


1.234
log
@DOuble wait_state affect for dweebs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.233 2003/10/08 00:49:27 ndagger Exp $";
d110 4
a113 1
    npulse /= 2;
@


1.233
log
@10/07/03 Nightdager:  Implemented bitch channel.  FUN!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.232 2003/09/26 04:07:12 boogums Exp $";
d114 5
@


1.232
log
@putting in clanonly room
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.231 2003/05/25 17:41:44 boogums Exp $";
d3713 1
@


1.231
log
@damn bit vectors
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.230 2003/05/25 14:32:21 boogums Exp $";
d3104 5
d3148 4
@


1.230
log
@DOH damn bitvecotrs :)
orey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.229 2003/05/25 01:34:23 boogums Exp $";
d2128 1
a2128 1
        ||   IS_SET(ch->mhs,MHS_CURSE)
@


1.229
log
@ok adding MHS_CURSE
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.228 2002/11/03 21:11:17 boogums Exp $";
d2128 1
a2128 1
        ||   IS_AFFECTED(ch, MHS_CURSE)
@


1.228
log
@stupid half compelete G code
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.227 2002/10/02 01:24:41 ndagger Exp $";
d2128 1
@


1.227
log
@10/01/02 Nightdagger-  Ok, made it so DWEEBS who aren't in nodie rooms repop at altar.  *whap self*
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.226 2002/09/20 15:21:05 boogums Exp $";
d3988 3
a3990 1
    CHAR_DATA *v;
d3997 1
@


1.226
log
@line 2048 of hanlder.c added anotehr NULL check in the for loop
corey
ne
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.225 2002/04/21 15:20:08 rusty Exp $";
d2527 4
a2530 1
        char_to_room(ch,get_room_index(clan_table[ch->clan].hall));
@


1.225
log
@Don't lose everything if you die, ooops
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.224 2002/04/01 21:07:25 mud Exp $";
d2050 4
@


1.224
log
@missing }
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.223 2002/04/01 21:05:44 rusty Exp $";
d2508 2
d2515 1
@


1.223
log
@Added pnet, wiznet like info for mortals
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.222 2002/03/09 19:14:28 rusty Exp $";
d339 1
@


1.222
log
@Hiding information and reup_affect() additions. Initial
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.221 2002/02/26 21:09:52 poquah Exp $";
d325 14
@


1.221
log
@fix all non-smurfs seeing invis objs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.220 2002/02/11 20:06:55 poquah Exp $";
d742 3
d804 3
d864 3
d1227 3
d3428 3
@


1.220
log
@smurfs can see invis objs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.219 2002/02/11 18:38:37 poquah Exp $";
d3290 1
a3290 1
    if(!IS_NPC(ch) && ch->clan == clan_lookup("smurf"))
@


1.219
log
@missing "
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.218 2002/02/11 18:34:10 poquah Exp $";
d3290 5
a3294 3
    if ( IS_SET(obj->extra_flags, ITEM_INVIS)
    &&   !IS_AFFECTED(ch, AFF_DETECT_INVIS) )
        return FALSE;
d3296 2
a3297 2
    if ( obj->item_type == ITEM_LIGHT && obj->value[2] != 0 )
  return TRUE;
d3299 3
a3301 2
    if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_INFRARED) )
  return FALSE;
@


1.218
log
@adding some smurf abilities
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.217 2001/12/15 02:41:39 poquah Exp $";
d3956 1
a3956 1
    CHAR_DATA *V;
d3960 1
a3960 1
        if ( v->race == race_lookup(smurf) &&
@


1.217
log
@attempt to fix losing racial affects on removing an item
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.216 2001/12/14 15:48:52 poquah Exp $";
d3952 13
@


1.216
log
@put level limits on smurfs vision
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.215 2001/12/13 17:56:23 poquah Exp $";
d2228 4
@


1.215
log
@smurfs can see faded, nethers, sneaking, hiding
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.214 2001/11/25 01:26:38 rusty Exp $";
d3139 7
a3145 2
   if ( !IS_SET(ch->mhs, MHS_GLADIATOR) && IS_SET(victim->mhs, MHS_GLADIATOR))
       return TRUE;
d3147 12
a3158 2
   if(!IS_NPC(ch) && ch->clan == clan_lookup("smurf"))
       return TRUE;
@


1.214
log
@Webpage crash/bug fixes applied
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.213 2001/11/15 03:10:32 poquah Exp $";
d3142 2
@


1.213
log
@add full sac, able to sac containers with things in them
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.212 2001/11/10 21:42:16 rage Exp $";
d1384 1
a1384 1
    VALIDATE(paf);
d1417 1
a1417 1
    VALIDATE(paf);
d1433 1
a1433 1
    VALIDATE(paf);
@


1.212
log
@bug fix for spec elemental water again
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.211 2001/11/10 19:13:43 rage Exp $";
d3529 1
@


1.211
log
@bug fixes for spec_elemental_water
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.210 2001/11/10 18:38:25 rage Exp $";
d3951 1
a3951 1
  for (vch = ch->in_room->people ; vch != NULL; vch = ch->next_in_room )
@


1.210
log
@initial insertion of spec_water
added in healing for drinking from holy grail
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.209 2001/09/23 20:25:04 rage Exp $";
a3952 5
       if (vch == ch)
	 continue;
   
       if (vch->fighting == NULL)
         continue;
@


1.209
log
@some changes to spec_elemental stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.208 2001/08/30 01:03:23 guerrand Exp $";
a1691 4
/*
    if ( is_room_affected(room, gsn_wall_ice))
	wall_effect(ch, room, gsn_wall_ice);   
*/
d3945 22
@


1.208
log
@Added bounty command.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.207 2001/08/24 00:42:18 guerrand Exp $";
a3843 1

@


1.207
log
@Medium kit coded.  Adjusted skill point cost for spirit caller.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.206 2001/08/08 05:45:51 poquah Exp $";
d3942 1
a3942 1
	return FALSE;
d3948 1
a3948 1
    return FALSE;
@


1.206
log
@Adding Honor's Enemy flag for Loner's and Outcasts
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.205 2001/07/13 01:57:13 guerrand Exp $";
d3937 13
@


1.205
log
@Dwarves wear armor better
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.204 2001/06/28 03:41:34 guerrand Exp $";
d3532 1
@


1.204
log
@Fixed spirit of phoenix crash bug.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.203 2001/06/18 01:17:32 rage Exp $";
d1930 1
d1970 3
a1972 3
    case WEAR_BODY: return 3 * obj->value[type];
    case WEAR_HEAD: return 2 * obj->value[type];
    case WEAR_LEGS: return 2 * obj->value[type];
d1976 1
a1976 1
    case WEAR_SHIELD: return     obj->value[type];
d1981 1
a1981 1
    case WEAR_ABOUT:  return 2 * obj->value[type];
d1983 2
a1984 2
    case WEAR_WRIST_L:  return     obj->value[type];
    case WEAR_WRIST_R:  return     obj->value[type];
d1992 3
a1994 3
    case WEAR_BODY: return 3 * (obj->value[type] -1);
    case WEAR_HEAD: return 2 * (obj->value[type] -1);
    case WEAR_LEGS: return 2 * (obj->value[type] -1);
d1998 1
a1998 1
    case WEAR_SHIELD: return     (obj->value[type] -1);
d2003 1
a2003 1
    case WEAR_ABOUT:  return 2 * (obj->value[type] -1);
d2005 2
a2006 2
    case WEAR_WRIST_L:  return     (obj->value[type] -1);
    case WEAR_WRIST_R:  return     (obj->value[type] -1);
@


1.203
log
@ Initial insertion of forging items.  Added new item type ITEM_FORGE.
 One can create "recipes" for these forges.  Each recipe is a list of
 objects that once placed inside the forge will create a bigger/better
 object.  Basically a better implementation of item parts.

-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.202 2001/06/18 01:02:33 guerrand Exp $";
d734 3
d792 4
d849 4
d1209 4
d3387 3
@


1.202
log
@Added some smarts to what the monk and drachlan willand won't wear.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.201 2001/06/17 00:10:05 guerrand Exp $";
d3352 2
@


1.201
log
@Fixed faerie casting level problem.
ADjusted DOT damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.200 2001/06/11 03:44:01 guerrand Exp $";
d3914 1
@


1.200
log
@GMAN:
Was a typo in is_room_affected.  Fixed it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.199 2001/06/11 00:04:03 rage Exp $";
d3880 34
@


1.199
log
@continuation of wall of fire spell
added function bool is_room_affected to check room effects
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.198 2001/06/10 03:30:10 guerrand Exp $";
d1629 1
a1629 1
		if (paf->type = sn )
@


1.198
log
@Removed the 'check is dot' function.
New implementation of DOTs in fight.c doesn't use it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.197 2001/06/09 19:34:46 guerrand Exp $";
d1623 11
a1633 1

d1674 7
@


1.197
log
@GMAN
Some more bug cleanup work.  Trying to eliminate the problem with getting
battle prompts when DOT'd.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.196 2001/06/09 06:27:40 guerrand Exp $";
a3862 10
bool check_is_dot( int sn )
{
    if ( sn 	== skill_lookup("blight") ||
	 sn	== skill_lookup("boiling blood") ||
	 sn	== skill_lookup("contagion") ||
	sn	== skill_lookup("scourge") )
	return TRUE;

    return FALSE;
}
@


1.196
log
@
GMAN

More bug fixing.  Found some bugs with calling 'damage' from 'dot', when
'ch' and 'victim' might be in different rooms.  Addressed these with some
work arounds.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.195 2001/06/09 03:56:59 guerrand Exp $";
d3866 3
a3868 1
	 sn	== skill_lookup("boiling blood") )
@


1.195
log
@GMAN!
1. Changed 'affect' command to show duration for dots correctly.
2. Removed unused variable in mag2.c
3. Added a long field to affects called 'caster_id'
4. Added a lookup function called 'get_char_by_id' to handler.c
5. Added a call to get_char_by_id to dot in magic.c to find the caster
6. WE can now track the caster of a spell.

To do: check for a 0 ID and ignore it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.194 2001/06/07 04:15:41 guerrand Exp $";
d3861 9
@


1.194
log
@GMAN
I completed the code for damage over time spells.  Some testing will be
needed, first just to make sure the code, while idling, doesn't break
anything else.  Then we can write some DOT spells and see if they work
right.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.193 2001/06/03 22:44:22 guerrand Exp $";
d2585 14
@


1.193
log
@still working on it - GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.192 2001/06/03 17:38:39 guerrand Exp $";
d1146 4
d1283 1
a1283 1
    if (where == TO_OBJECT || where == TO_WEAPON || vector == 0)
@


1.192
log
@GMAN
removed dex bonus for rockbitrs, ogres, and giants
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.191 2001/06/03 17:15:10 guerrand Exp $";
d3455 1
d3479 24
@


1.191
log
@GMAN
Added some more information to lore/ident.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.190 2001/05/26 00:33:57 rage Exp $";
d940 1
d946 1
@


1.190
log
@added in IMM command to turn double xp on and off.
added global var "override" to do so.
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.189 2001/04/09 18:30:39 mud Exp $";
d3314 1
@


1.189
log
@Applied rom 2.4 b5 and b6 patches as necessary.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.188 2001/03/27 19:43:30 mud Exp $";
d3442 9
@


1.188
log
@ooc act()'s revelaing trust level
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.187 2001/03/05 20:42:48 mud Exp $";
d1363 1
d1396 1
d1412 1
@


1.187
log
@Rockbiter tweak, 21 dex and VULN_MENTAL
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.186 2001/02/10 17:35:31 mud Exp $";
d3068 1
a3068 1
    if ( ooc && !IS_IMMORTAL(victim) && !IS_NPC(victim) )
@


1.186
log
@Final changes to rickie dex
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.185 2001/02/10 17:11:05 mud Exp $";
d944 1
a944 1
      max += 5;
@


1.185
log
@Fixing rockie and ogre/giant dex thing
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.184 2001/01/30 16:04:17 mud Exp $";
d944 1
a944 1
      max += 4;
@


1.184
log
@Bump down DEX bonus
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.183 2001/01/24 19:33:35 mud Exp $";
d944 1
a944 1
      max += pc_race_table[ch->race].max_stats[stat] + 4;
@


1.183
log
@Ogres giants and RockBiters have a better MAX DEX with +dex EQ
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.182 2000/12/15 00:19:05 mud Exp $";
d944 1
a944 1
      max += pc_race_table[ch->race].max_stats[stat] + 7;
@


1.182
log
@Warlock enemy overlap
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.181 2000/10/25 12:42:08 mud Exp $";
d939 6
@


1.181
log
@ adding double xp day code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.180 2000/10/23 22:05:57 mud Exp $";
a424 1
    if(IS_SET(ch->mhs,RES_LIGHT)) immune=IS_RESISTANT;
@


1.180
log
@zealot and posse enemies
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.179 2000/10/17 22:45:34 mud Exp $";
d3114 5
a3118 1
  
@


1.179
log
@enemies for clans , just warlock for now
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.178 2000/10/07 21:32:08 mud Exp $";
d3449 2
@


1.178
log
@fix bug in new bug ix
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.177 2000/10/07 21:30:52 mud Exp $";
d3448 1
@


1.177
log
@change victim to char
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.176 2000/10/07 21:28:57 mud Exp $";
d2176 1
a2176 1
    if (AppType = APPLY_PRIMARY)
@


1.176
log
@fix zapped object bug not moving secondary to primary
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.175 2000/09/13 14:01:50 mud Exp $";
d2178 1
a2178 1
       if ((obj = get_eq_char(victim,WEAR_SECOND)) != NULL)
d2181 2
a2182 2
 	  obj_to_char( obj, victim);
	  equip_char( victim, obj, WEAR_WIELD );
@


1.175
log
@
added check for holylight to detect good/evil and see spell effects like detect magic

slightly curved damage done by morphed chars

changed sneak again to make it less effective
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.174 2000/09/11 19:26:31 mud Exp $";
d2175 10
@


1.174
log
@Fixed shapemorph get_char_room() matches damnit!
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.173 2000/09/11 18:56:26 mud Exp $";
d3080 1
a3080 1
          nchance /= 2;
d3100 2
a3101 2
       chance = get_skill(victim,gsn_sneak);
       chance += get_curr_stat(victim,STAT_DEX) * 3/2;
d3117 1
a3117 1
       chance -= get_curr_stat(ch,STAT_DEX);
@


1.173
log
@|| should have been && in get_char_room() for SHAPEMORPH
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.172 2000/09/10 17:55:44 mud Exp $";
d2515 14
a2528 1
	  if(!is_name( arg, rch->long_descr ) && !is_name( arg, rch->name ) )
d2530 1
@


1.172
log
@Changed allowed names list, let people hit shapemorphs be their real
names.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.171 2000/09/02 03:27:37 mud Exp $";
d2515 1
a2515 1
	  if(!is_name( arg, rch->long_descr ) || !is_name( arg, rch->name ) )
@


1.171
log
@ng elves natural magic resistance
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.170 2000/08/29 14:47:28 mud Exp $";
d2515 1
a2515 1
	  if(!is_name( arg, rch->long_descr ) )
@


1.170
log
@ removed set_prev_owner() for now
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.169 2000/08/29 14:21:56 mud Exp $";
d424 2
a425 1
    }
@


1.169
log
@ more debuggin stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.168 2000/08/29 14:10:30 mud Exp $";
d1864 2
a1865 4
  if (!IS_NPC(obj->carried_by) )
      add_prev_owner(obj, ch);

//      obj->prev_owner  = str_dup(obj->carried_by->name);
@


1.168
log
@ added some debug lines to debug add_prev_owner()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.167 2000/08/29 13:48:57 mud Exp $";
d3730 1
a3730 1
   send_to_char(buf, ch);
d3747 1
a3747 1
 send_to_char(buf3, ch);
d3765 1
a3765 1
 send_to_char(buf3, ch);
@


1.167
log
@ first, probably very buggy attempt to have prev owner store 5 names
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.166 2000/08/28 13:38:07 mud Exp $";
d1864 1
a1864 1
  if (!IS_NPC(obj->carried_by)  && !IS_IMMORTAL(obj->carried_by))
d3722 1
d3730 1
d3746 2
d3764 2
@


1.166
log
@ saction hall moves victim to recall

 bug fix on communion allowing negative sac points

 bug fix on sneaking mobs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.165 2000/08/25 16:47:06 mud Exp $";
d46 1
a46 1

d1863 5
a1867 2
    if (!IS_NPC(obj->carried_by))
      obj->prev_owner  = str_dup(obj->carried_by->name);
d3714 48
@


1.165
log
@ first attempt to add obbj->prev_owner to display who last owned an obj
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.164 2000/08/23 13:38:05 mud Exp $";
a3088 2
       if(!IS_NPC(victim)) chance /= 2;

a3105 3

       if(IS_NPC(victim)) chance /= 2;

@


1.164
log
@ fixed little bug in olist with multiple declaration of aconstants
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.162 2000/08/18 22:49:03 mud Exp $";
d1863 2
@


1.163
log
@ another attempt to add in olist, also some general clean up
 -Rage
@
text
@@


1.162
log
@Highlanders Abound
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.161 2000/08/17 17:18:01 mud Exp $";
d3442 1
a3442 1

@


1.161
log
@ added in sanction allow to allow clan leader to grant ability to /4's
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.160 2000/08/17 14:29:28 mud Exp $";
d2972 2
a2973 1
    if ( IS_SET(pRoomIndex->room_flags, ROOM_NOCLAN) && is_clan(ch)
d3015 2
a3016 1
    &&  is_clan(ch) && !IS_IMMORTAL(ch))
@


1.160
log
@ first implementation of "sanction" command for clan leaders
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.159 2000/07/25 19:45:32 mud Exp $";
d3425 17
@


1.159
log
@removed rage code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.158 2000/07/25 16:41:15 mud Exp $";
d3421 2
@


1.158
log
@missing ;
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.157 2000/07/25 16:38:13 mud Exp $";
a3029 3
    if ( IS_AFFECTED(ch, AFF_BLIND) && !str_cmp(ch->name,"Rage") )
       return FALSE;

@


1.157
log
@Remove Rages Who name code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.156 2000/07/21 20:08:04 mud Exp $";
d3030 1
a3030 1
    If ( IS_AFFECTED(ch, AFF_BLIND) && !str_cmp(ch->name,"Rage") )
@


1.156
log
@Added some {}'s for proper OOO
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.155 2000/07/21 20:04:43 mud Exp $";
d3030 3
@


1.155
log
@Changed get_char_room() to work right.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.154 2000/07/18 17:06:29 mud Exp $";
d689 1
d694 1
d2116 1
d2118 1
d2138 2
@


1.154
log
@changed act_new() and get_char_room() to use HOLYLIGHT settings
for can/cannot see.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.153 2000/07/14 13:25:29 mud Exp $";
d2502 2
a2503 5
	if(IS_SET(rch->mhs,MHS_SHAPEMORPHED)
	   || (IS_SET(rch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE
	       && rch != ch  && (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT))
	      )
	  )
d2508 10
d2522 2
a2523 1
        }
@


1.153
log
@ Moved mistform up the defense list to be checked before dodge
 Stripped mistform affect if duration got to 0
 Non-glads can see glads all the time
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.152 2000/07/12 22:54:09 mud Exp $";
d2504 3
a2506 1
	       && rch != ch))
@


1.152
log
@fix blind/noblind setting, and attempt to not have you hit yourself as glad.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.151 2000/07/12 22:28:40 mud Exp $";
d3035 4
@


1.151
log
@add gladiator.h for gladiator_info in can see
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.150 2000/07/12 22:22:16 mud Exp $";
d2503 2
a2504 1
	   || (IS_SET(rch->mhs,MHS_GLADIATOR) && gladiator_info.blind == TRUE))
@


1.150
log
@working on blind glad matches
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.149 2000/07/12 21:24:57 mud Exp $";
d33 1
@


1.149
log
@ adjusted chances for slice/steal
 Fixed bug with victim needing to see obj for thief to slice
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.148 2000/06/29 22:57:50 mud Exp $";
d2501 2
a2502 1
	if(IS_SET(rch->mhs,MHS_SHAPEMORPHED))
@


1.148
log
@gladiaators dont disarm or go over weight
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.147 2000/06/18 20:39:28 mud Exp $";
d2622 23
@


1.147
log
@missing ;
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.146 2000/06/18 20:38:05 mud Exp $";
d1009 1
a1009 1
  if (ch->pcdata->logout_tracker != 0)
@


1.146
log
@declare clan_lookup
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.145 2000/06/18 20:36:05 mud Exp $";
d550 1
a550 1
	 skill = (skill/2) + (skill/10)
@


1.145
log
@Warlock clan skil
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.144 2000/05/24 02:53:27 mud Exp $";
d45 5
@


1.144
log
@trap fixes, non clanners can't use it
similar to hold person now, snare puts yuou in resting position
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.143 2000/05/20 01:12:21 mud Exp $";
d544 4
a547 1
      skill /= 2;
@


1.143
log
@working on Gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.142 2000/05/16 22:46:11 mud Exp $";
d1780 1
a1780 3
	  if ( is_clan(ch) != paf->modifier )
	      continue;
	  else
@


1.142
log
@ missed a colon in a switch/case, my bad
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.141 2000/05/16 22:43:23 mud Exp $";
d3368 1
@


1.141
log
@ Changed grenade to show damage message
 Removed all lag for IMMortals usage of commands
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.140 2000/05/16 21:26:29 mud Exp $";
d3224 1
a3224 1
    case ITEM_GRENADE return "grenade";
@


1.140
log
@ Added in a conversion for ITEM_GRENADE and changed haste so you cannot be hasted and use speed potion.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.139 2000/05/16 15:01:30 mud Exp $";
d107 1
a107 1
  ch->wait = UMAX(ch->wait, npulse);
@


1.139
log
@ Addition of alchemist kit.
 act_obj.c : added "brew" command to create potions
 const.c   : added in a couple new damaget types into attack_table
 fight.c   : grenade code for molotov cocktails
 handler.c : modified wait_state for speed potion
 mag2.c    : spells for use with alchemist potions

- Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.138 2000/04/22 02:45:33 mud Exp $";
d3224 1
@


1.138
log
@More changes to see if I can add an act flag on mobs
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.137 2000/04/18 19:50:59 mud Exp $";
d100 5
@


1.137
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.136 2000/04/18 03:05:07 mud Exp $";
d3393 2
@


1.136
log
@ more changes to can_see...you can now be semie_invis with sneak, but no check on ninjitsu inside sneak.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.135 2000/04/17 23:46:56 mud Exp $";
d1223 2
a1224 2
      act( "You drop $p.", ch, wield, NULL, TO_CHAR );
      act( "$n drops $p.", ch, wield, NULL, TO_ROOM );
d1758 1
a1758 1
              act("$n shivers and looks very ill.",vch,NULL,NULL,TO_ROOM);
d2003 2
a2004 2
  act( "You are zapped by $p and drop it.", ch, obj, NULL, TO_CHAR );
  act( "$n is zapped by $p and drops it.",  ch, obj, NULL, TO_ROOM );
d2056 1
a2056 1
          act( "$n flickers and phases.", ch, NULL, NULL, TO_ROOM );
d2061 1
a2061 1
          act("$n phases in.",ch,NULL,NULL,TO_ROOM);
@


1.135
log
@ Changed can see to ignore sneaking chars.  Sneak now only suppressees "arrives message.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.134 2000/04/17 22:00:49 mud Exp $";
d3017 1
a3017 1
    /* sneaking 
d3031 1
a3031 2
          if( number_percent() < chance 
	   || number_percent()  < get_skill(victim, gsn_ninjitsu)) 
d3033 1
a3033 1
       } */
@


1.134
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.133 2000/04/17 19:44:59 mud Exp $";
d3017 1
a3017 1
    /* sneaking */
d3034 1
a3034 1
       }
d3053 1
a3053 1
	      number_percent() <= get_skill(victim, gsn_ninjitsu))
@


1.133
log
@misspeld act flag
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.132 2000/04/17 19:43:11 mud Exp $";
d2488 1
a2488 1
        if ( !can_see( ch, rch ))
d2532 1
a2532 1
  if ( wch->in_room == NULL || !can_see( ch, wch ) 
d2972 1
a2972 1
bool can_see( CHAR_DATA *ch, CHAR_DATA *victim )
d2979 3
@


1.132
log
@ Money changeers can always see invis, snekaing, hiden faded etc

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.131 2000/04/15 17:00:34 mud Exp $";
d2993 1
a2993 1
    if ( IS_NPC(ch) && IS_SET(ch->act, IS_ACT_CHANGER))
@


1.131
log
@ changed can_see back to how it was before bug fixes.
 modified level mods in steeal and slice

 -Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.130 2000/03/23 00:41:36 mud Exp $";
d2992 3
@


1.130
log
@remove dual wield debug lines
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.129 2000/03/20 22:17:15 mud Exp $";
a3023 8
       if ((nchance = get_skill(victim,gsn_ninjitsu)) > 1)
       {
          nchance = nchance * 90/100;
          if (is_affected(ch,gsn_vision))
	  {
	     nchance /= 2;
	     chance /= 2;
	  }
d3025 2
a3026 1
          if( number_percent() < nchance && number_percent() < chance )
d3029 1
a3029 10
       else
       {
	  if(is_affected(ch,gsn_vision))
	     chance /= 2;

          if (number_percent() < chance)  
             return FALSE;
       }
    }

a3044 8
       if ((nchance = get_skill(victim,gsn_ninjitsu)) > 1)
       {
          nchance = nchance * 90/100;
          if (is_affected(ch,gsn_vision))
	  {
	     nchance /= 2;
	     chance /= 2;
	  }
d3046 2
a3047 1
          if( number_percent() <= nchance && number_percent() <= chance )
a3049 9
       else
       {
	  if(is_affected(ch,gsn_vision))
	     chance /= 2;

          if (number_percent() < chance)  
             return FALSE;
       }
    }
@


1.129
log
@l wield in handler.c and not have fear work on slept players in fight.c
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.128 2000/03/18 22:43:40 mud Exp $";
a622 1
    char buf[MAX_STRING_LENGTH];
a734 6
    if (get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"%s : 2(hit)= mod %d loc %d Pri %d Sec %d\n\r",
    obj->name,mod,loc,WEAR_WIELD,WEAR_SECOND);
    send_to_char(buf,ch);
    }
a746 6
    if (get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"%s : 2(dam)= mod %d loc %d Pri %d Sec %d\n\r",
    obj->name,mod,loc,WEAR_WIELD,WEAR_SECOND);
    send_to_char(buf,ch);
    }
a788 6
    if (get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"%s : 3(hit)= mod %d loc %d Pri %d Sec %d\n\r",
    obj->name,mod,loc,WEAR_WIELD,WEAR_SECOND);
    send_to_char(buf,ch);
    }
a799 6
    if (get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"%s : 3(dam)= mod %d loc %d Pri %d Sec %d\n\r",
    obj->name,mod,loc,WEAR_WIELD,WEAR_SECOND);
    send_to_char(buf,ch);
    }
a841 6
    if (get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"spell inside(hit)= mod %d to both\n\r",
    mod);
    send_to_char(buf,ch);
    }
a845 6
    if (get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"spell inside(dam)= mod %d to both\n\r",
    mod);
    send_to_char(buf,ch);
    }
a1120 1
    char buf[MAX_STRING_LENGTH];
a1190 5
    if(get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"1(hit)= mod %d apptype %d\n\r",mod,AppType);
    send_to_char(buf,ch);
    }
a1196 5
    if(get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"1(dam)= mod %d apptype %d\n\r",mod,AppType);
    send_to_char(buf,ch);
    }
a1977 1
    char buf[MAX_STRING_LENGTH];
d1980 1
a1989 6
    if(get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"%s :  iWear %d AppType %d\n\r",obj->name,iWear,AppType);
    send_to_char(buf,ch);
    }

a2081 1
    char buf[MAX_STRING_LENGTH];
a2089 6

    if(get_skill(ch,gsn_dual_wield))
    {
    sprintf(buf,"%s : wear_loc %d AppType %d\n\r",obj->name,obj->wear_loc,AppType);
    send_to_char(buf,ch);
    }
@


1.128
log
@remove debug lines, bug squashed
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.127 2000/03/18 22:34:17 mud Exp $";
d709 2
a710 2
  for (i = 0; i < 4; i++)
      ch->armor[i] -= apply_ac( obj, loc, i );
d713 23
a735 21
  for ( af = obj->pIndexData->affected; af != NULL; af = af->next )
        {
            mod = af->modifier;
            switch(af->location)
            {
    case APPLY_STR:   ch->mod_stat[STAT_STR]  += mod; break;
    case APPLY_DEX:   ch->mod_stat[STAT_DEX]  += mod; break;
    case APPLY_INT:   ch->mod_stat[STAT_INT]  += mod; break;
    case APPLY_WIS:   ch->mod_stat[STAT_WIS]  += mod; break;
    case APPLY_CON:   ch->mod_stat[STAT_CON]  += mod; break;

    case APPLY_SEX:   ch->sex     += mod; break;
    case APPLY_MANA:  ch->max_mana    += mod; break;
    case APPLY_HIT:   ch->max_hit   += mod; break;
    case APPLY_MOVE:  ch->max_move    += mod; break;

    case APPLY_AC:    
        for (i = 0; i < 4; i ++)
      ch->armor[i] += mod; 
        break;
    case APPLY_HITROLL: 
d742 12
a753 13
	if (loc == WEAR_SECOND)
	{
           ch->pcdata->second_hitroll   += mod; 
	   }
	else if (loc == WEAR_WIELD) 
           ch->hitroll   += mod; 
	else
	{
           ch->pcdata->second_hitroll   += mod; 
           ch->hitroll   += mod; 
	}
	break;
    case APPLY_DAMROLL: 
d760 19
a778 8
	if (loc == WEAR_SECOND)
	   ch->pcdata->second_damroll   += mod;
	else if (loc == WEAR_WIELD)  
	   ch->damroll   += mod; 
	else
	{
	   ch->pcdata->second_damroll   += mod;
	   ch->damroll   += mod; 
a779 10
        break;
  
    case APPLY_SAVES:   ch->saving_throw += mod; break;
    case APPLY_SAVING_ROD:    ch->saving_throw += mod; break;
    case APPLY_SAVING_PETRI:  ch->saving_throw += mod; break;
    case APPLY_SAVING_BREATH:   ch->saving_throw += mod; break;
    case APPLY_SAVING_SPELL:  ch->saving_throw += mod; break;
    case APPLY_SIZE:  ch->size += mod; break;
      }
        }
d783 19
a801 19
            mod = af->modifier;
            switch(af->location)
            {
                case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
                case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
                case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
                case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
                case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
 
                case APPLY_SEX:         ch->sex                 += mod; break;
                case APPLY_MANA:        ch->max_mana            += mod; break;
                case APPLY_HIT:         ch->max_hit             += mod; break;
                case APPLY_MOVE:        ch->max_move            += mod; break;
 
                case APPLY_AC:
                    for (i = 0; i < 4; i ++)
                        ch->armor[i] += mod;
                    break;
                case APPLY_HITROLL:
d804 2
a805 2
    sprintf(buf,"%s : inside(hit)= mod %d to both\n\r",
    obj->name,mod);
d808 11
a818 4
		    ch->hitroll             += mod;
		    ch->pcdata->second_hitroll             += mod;
		    break;
                case APPLY_DAMROLL:     
d821 2
a822 2
    sprintf(buf,"%s : inside(dam)= mod %d to both\n\r",
    obj->name,mod);
d825 19
a843 12
		    ch->damroll             += mod;
		    ch->pcdata->second_damroll             += mod;
		    break;
 
                case APPLY_SAVES:         ch->saving_throw += mod; break;
                case APPLY_SAVING_ROD:          ch->saving_throw += mod; break;
                case APPLY_SAVING_PETRI:        ch->saving_throw += mod; break;
                case APPLY_SAVING_BREATH:       ch->saving_throw += mod; break;
                case APPLY_SAVING_SPELL:        ch->saving_throw += mod; break;
            }
  }
    }
@


1.127
log
@adjust handler
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.126 2000/03/18 22:29:13 mud Exp $";
a628 4
                sprintf( buf, "%s reset (1)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (1)\n\r",ch);

a670 1
    send_to_char("Did you get here? (2)\n\r",ch);
a701 3
                sprintf( buf, "%s reset (3)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (3)\n\r",ch);
a733 3
                sprintf( buf, "%s reset (4)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (4)\n\r",ch);
a735 3
                sprintf( buf, "%s reset (5)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (5)\n\r",ch);
a738 3
                sprintf( buf, "%s reset (6)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (6)\n\r",ch);
a741 3
                sprintf( buf, "%s reset (7)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (7)\n\r",ch);
a747 3
                sprintf( buf, "%s reset (8)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (8)\n\r",ch);
a754 3
                sprintf( buf, "%s reset (9)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (9)\n\r",ch);
a757 3
                sprintf( buf, "%s reset (10)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (10)\n\r",ch);
a764 3
                sprintf( buf, "%s reset (11)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (11)\n\r",ch);
a766 3
                sprintf( buf, "%s reset (12)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (12)\n\r",ch);
a767 3
                sprintf( buf, "%s reset (13)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (13)\n\r",ch);
a777 2
                sprintf( buf, "%s reset (13.1)",ch->name) ;
                log_string( buf );
a781 2
                sprintf( buf, "%s reset (13.2)",ch->name) ;
                log_string( buf );
a801 3
                sprintf( buf, "%s reset (14)",ch->name) ;
                log_string( buf );
    send_to_char("Did you get here? (14)\n\r",ch);
a811 2
                sprintf( buf, "%s reset (15)",ch->name) ;
                log_string( buf );
a828 2
                sprintf( buf, "%s reset (16)",ch->name) ;
                log_string( buf );
a852 2
                sprintf( buf, "%s reset (17)",ch->name) ;
                log_string( buf );
a862 2
                sprintf( buf, "%s reset (18)",ch->name) ;
                log_string( buf );
a882 2
                sprintf( buf, "%s reset (20)",ch->name) ;
                log_string( buf );
a883 1

@


1.126
log
@even more log messages
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.125 2000/03/18 22:22:13 mud Exp $";
d904 2
a905 2
    sprintf(buf,"%s : spell inside(hit)= mod %d to both\n\r",
    obj->name,mod);
d916 2
a917 2
    sprintf(buf,"%s : spell inside(dam)= mod %d to both\n\r",
    obj->name,mod);
@


1.125
log
@debugging the hell out of it
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.124 2000/03/18 19:24:15 mud Exp $";
d816 2
d822 2
d857 2
d876 2
d902 2
d914 2
d936 2
@


1.124
log
@more debug
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.123 2000/03/18 19:08:33 mud Exp $";
d629 2
d707 2
d742 2
d747 2
d753 2
d759 2
d768 2
d778 2
d784 2
d794 2
d799 2
d803 2
d840 2
@


1.123
log
@debugging crash bug
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.122 2000/03/18 01:20:35 mud Exp $";
d741 1
d745 1
d748 2
d751 1
d756 1
d764 1
d768 1
d776 1
d779 1
d781 1
d816 1
@


1.122
log
@remove tweak for mobs in sneak/hide not need
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.121 2000/03/18 00:49:22 mud Exp $";
d629 2
d673 1
d705 1
d738 1
@


1.121
log
@try a tweak for mobs in sneak/hide
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.120 2000/03/16 17:39:14 mud Exp $";
a3061 3

       if (IS_NPC(victim))
	  chance = 100;
a3095 2
       if (IS_NPC(victim))
	  chance = 100;
@


1.120
log
@more dual wield debugging
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.119 2000/03/15 22:14:33 mud Exp $";
d3037 1
a3037 1
    if ( IS_SET(victim->mhs,MHS_FADE) )
d3062 3
d3099 2
@


1.119
log
@tweak sneaking/hiding numbers
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.118 2000/03/15 01:33:36 mud Exp $";
d736 2
a737 2
    sprintf(buf,"%s : 2(hit): loc %d Pri %d Sec %d\n\r",
    obj->name,loc,WEAR_WIELD,WEAR_SECOND);
d753 2
a754 2
    sprintf(buf,"%s : 2(dam): loc %d Pri %d Sec %d\n\r",
    obj->name,loc,WEAR_WIELD,WEAR_SECOND);
d798 6
d808 6
d849 6
d859 6
d1214 1
a1214 1
    sprintf(buf,"1(hit): apptype %d\n\r",AppType);
d1225 1
a1225 1
    sprintf(buf,"1(dam): apptype %d\n\r",AppType);
@


1.118
log
@debugging dual wield
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.117 2000/03/15 01:31:19 mud Exp $";
d3019 1
a3019 1
       if(number_percent() < nchance)
d3040 1
a3040 1
       chance += ch->level - victim->level * 3/2;
d3074 1
a3074 1
       chance += ch->level - victim->level * 2;
d3090 1
a3090 1
          if( number_percent() < nchance && number_percent() < chance )
@


1.117
log
@dual wield debugging
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.116 2000/03/15 01:17:06 mud Exp $";
d737 1
a737 1
    obj->name,loc,WEAR_WIELD<WEAR_SECOND);
@


1.116
log
@change dual wield a bit
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.115 2000/03/14 01:43:24 mud Exp $";
d736 2
a737 1
    sprintf(buf,"%s : 2(hit): loc %d Sec %d\n\r",obj->name,loc,WEAR_SECOND);
d753 2
a754 1
    sprintf(buf,"%s : 2(dam): loc %d Sec %d\n\r",obj->name,loc,WEAR_SECOND);
@


1.115
log
@wiznet steal line only if !NPC
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.114 2000/03/14 00:30:20 mud Exp $";
d741 2
d744 2
d747 1
d757 2
d760 2
d763 1
@


1.114
log
@ame errors further down
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.113 2000/03/14 00:28:59 mud Exp $";
d3026 1
a3026 1
       chance += get_curr_stat(ch,STAT_DEX) * 3/2;
@


1.113
log
@clena up erros in new sneak/hide code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.112 2000/03/14 00:25:15 mud Exp $";
d3078 1
a3078 1
          if( number_percent() < nchance && numer_percent() < chance )
d3084 1
a3084 1
	     change /= 2;
@


1.112
log
@adjust fade and hide/sneak and ninji
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.111 2000/03/12 00:32:45 mud Exp $";
d3032 1
a3032 1
       if (nchance = get_skill(victim,gsn_ninjitsu) > 1)
d3041 1
a3041 1
          if( number_percent() < nchance && numer_percent() < chance )
d3047 1
a3047 1
	     change /= 2;
d3069 1
a3069 1
       if (nchance = get_skill(victim,gsn_ninjitsu) > 1)
@


1.111
log
@new thieving data
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.110 2000/03/10 22:21:56 mud Exp $";
d2982 2
d2986 1
a2986 1
  return TRUE;
d2989 1
a2989 1
  return FALSE;
d2992 1
a2992 1
  return FALSE;
d2995 2
a2996 2
    ||   (IS_NPC(ch) && IS_IMMORTAL(ch)))
  return TRUE;
d2999 1
a2999 1
  return FALSE;
d3003 7
a3009 5
      if ( ( number_percent() >= ( get_skill(victim,gsn_fade) * 95 / 100 ) )
	|| ( is_affected(ch,gsn_vision) && number_percent() <= 50 ) )
	    return TRUE;
	else
	    return FALSE;
d3013 1
a3013 1
  return FALSE;
d3016 2
a3017 2
    &&   !IS_AFFECTED(ch, AFF_DETECT_INVIS) )
  return FALSE;
d3020 9
a3028 9
    if ( IS_AFFECTED(victim, AFF_SNEAK)
    &&   !IS_AFFECTED(ch,AFF_DETECT_HIDDEN)
    &&   victim->fighting == NULL)
    {
  int chance;
  chance = get_skill(victim,gsn_sneak);
  chance += get_curr_stat(ch,STAT_DEX) * 3/2;
  chance -= get_curr_stat(ch,STAT_INT) * 2;
  chance += ch->level - victim->level * 3/2;
d3030 18
a3047 1
  if(!IS_NPC(victim)) chance /= 2;
d3049 3
a3051 3
  if (number_percent() < chance ||
      number_percent() < get_skill(victim,gsn_ninjitsu) )
      return FALSE;
d3054 1
a3054 6
    if ( IS_AFFECTED(victim, AFF_HIDE)
    &&   victim->fighting == NULL)
     {
      if(!IS_AFFECTED(ch,AFF_DETECT_HIDDEN))
	return FALSE;
      else
d3056 12
a3067 7
  int chance;
  chance = get_skill(victim,gsn_hide);
  chance -= get_curr_stat(ch,STAT_INT);
  chance -= get_curr_stat(ch,STAT_DEX);
  chance += ch->level - victim->level * 2;
  if ( victim->class == class_lookup("assassin") )
    chance += get_curr_stat(victim,STAT_DEX);
d3069 16
a3084 1
  if(IS_NPC(victim)) chance /= 2;
d3086 3
a3088 3
  if ( ( number_percent() < chance) ||
       ( number_percent() < get_skill(victim,gsn_ninjitsu) ) )
      return FALSE;
a3089 1
     }
@


1.110
log
@enchance debug lines
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.109 2000/03/10 01:32:28 mud Exp $";
d736 1
a736 1
    sprintf(buf,"2(hit): loc %d Sec %d\n\r",loc,WEAR_SECOND);
d747 1
a747 1
    sprintf(buf,"2(dam): loc %d Sec %d\n\r",loc,WEAR_SECOND);
d1987 1
a1987 1
    sprintf(buf," iWear %d AppType %d\n\r",iWear,AppType);
d2095 1
a2095 1
    sprintf(buf," obj->wear_loc %d AppType %d\n\r",obj->wear_loc,AppType);
@


1.109
log
@dual wield debugging
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.108 2000/03/10 00:18:30 mud Exp $";
d736 1
a736 1
    sprintf(buf,"2: loc %d\n\r",loc);
d747 1
a747 1
    sprintf(buf,"2: loc %d\n\r",loc);
d1178 1
a1178 1
    sprintf(buf,"1: apptype %d\n\r",AppType);
d1189 1
a1189 1
    sprintf(buf,"1: apptype %d\n\r",AppType);
@


1.108
log
@fix hide and ninja
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.107 2000/03/09 19:33:22 mud Exp $";
d734 2
d738 1
d745 2
d749 1
d1176 2
d1180 1
d1187 2
d1191 1
d1985 2
d1989 1
d2093 2
d2097 1
@


1.107
log
@debug dual wield armor missings
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.106 2000/03/06 17:40:55 mud Exp $";
d3033 1
a3033 1
       ( number_percent() < get_skill(ch,gsn_ninjitsu) ) )
@


1.106
log
@remove unused buf
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.105 2000/03/06 17:35:31 mud Exp $";
d623 1
d734 2
d742 2
d1099 1
d1170 2
d1178 2
d1965 11
a1999 8
    AppType = APPLY_BOTH; 

    if (obj->wear_loc == WEAR_SECOND)
       AppType = APPLY_SECONDARY;

    if (obj->wear_loc == WEAR_WIELD)
       AppType = APPLY_PRIMARY;

d2068 1
a2068 6

    if ( obj->wear_loc == WEAR_NONE )
    {
  bug( "Unequip_char: already unequipped.", 0 );
  return;
    }
d2077 9
@


1.105
log
@remove debug lines
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.104 2000/03/06 17:24:13 mud Exp $";
a623 1
     char buf[256];
@


1.104
log
@fix unequip in applytype
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.103 2000/03/06 17:00:25 mud Exp $";
a734 3
	{
	sprintf(buf,"ap1 mod %d second",mod);
	send_to_char(buf,ch);
a735 1
	}
a736 3
	{
	sprintf(buf,"ap1 mod %d" ,mod);
	send_to_char(buf,ch);
a737 1
	}
a775 2
	sprintf(buf,"ap2 mod %d both",mod);
	send_to_char(buf,ch);
a814 2
	sprintf(buf,"ap3 mod %d both",mod);
	send_to_char(buf,ch);
a1095 1
    char buf[256];
a1165 3
	{
	sprintf(buf,"ap4 mod %d ",mod);
	send_to_char(buf,ch);
d1167 1
a1167 5
	}
	if (!IS_NPC(ch) && (AppType == APPLY_SECONDARY || AppType == APPLY_BOTH))
	{
	sprintf(buf,"ap4 mod %d second",mod);
	send_to_char(buf,ch);
a1168 1
	}
d1173 1
a1173 1
	if (!IS_NPC(ch) && (AppType == APPLY_SECONDARY || AppType == APPLY_BOTH))
@


1.103
log
@syntax smingtax
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.102 2000/03/06 16:53:49 mud Exp $";
a2083 4
    for (i = 0; i < 4; i++)
      ch->armor[i]  += apply_ac( obj, obj->wear_loc,i );
    obj->wear_loc  = -1;

d2091 4
@


1.102
log
@apply types
-poquaH
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.101 2000/03/06 16:18:29 mud Exp $";
d1178 1
a1178 1
	if (Apptype == APPLY_PRIMARY || AppType == APPLY_BOTH)
d1192 1
a1192 1
	if (Apptype == APPLY_PRIMARY || AppType == APPLY_BOTH)
@


1.101
log
@only do ap4 if secondary is true
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.100 2000/03/06 15:59:22 mud Exp $";
d43 1
a43 1
void  affect_modify args( ( CHAR_DATA *ch, AFFECT_DATA *paf, bool fAdd, bool fSecondary ) );
d1104 1
a1104 1
void affect_modify( CHAR_DATA *ch, AFFECT_DATA *paf, bool fAdd, bool fSecondary )
d1178 2
d1182 3
a1184 2
	ch->hitroll   += mod; 
	if (!IS_NPC(ch) && fSecondary)
d1189 1
a1189 1
	   }
d1192 3
a1194 2
	ch->damroll   += mod; 
	if (!IS_NPC(ch))
d1371 1
a1371 2
/* Since the affect is to the Char send TRUE for fSecondary */
    affect_modify( ch, paf_new, TRUE, TRUE );
d1442 1
a1442 1
void affect_remove( CHAR_DATA *ch, AFFECT_DATA *paf, bool fSecondary )
d1453 1
a1453 1
    affect_modify( ch, paf, FALSE, fSecondary );
d1500 1
a1500 1
  affect_modify( obj->carried_by, paf, FALSE, TRUE );
d1563 1
a1563 1
      affect_remove( ch, paf,TRUE );
d1605 1
a1605 1
      affect_remove( ch, paf_old, TRUE );
d1975 1
a1975 1
    bool fSecondary = FALSE;
d2001 2
d2004 4
a2007 1
       fSecondary = TRUE;
d2012 1
a2012 1
          affect_modify( ch, paf, TRUE, fSecondary );
d2017 1
a2017 1
      affect_modify( ch, paf, TRUE, fSecondary );
d2076 1
a2076 1
    bool fSecondary = FALSE; 
d2088 2
d2091 4
a2094 1
       fSecondary = TRUE;
d2107 1
a2107 1
            affect_remove( ch, lpaf, fSecondary );
d2114 1
a2114 1
          affect_modify( ch, paf, FALSE, fSecondary );
d2131 1
a2131 1
        affect_remove( ch, lpaf, fSecondary );
d2138 1
a2138 1
      affect_modify( ch, paf, FALSE, fSecondary );
@


1.100
log
@adjust affects
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.99 2000/03/06 14:36:41 mud Exp $";
d1181 1
a1181 1
	if (!IS_NPC(ch))
@


1.99
log
@decalre buf for debug
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.98 2000/03/06 14:34:56 mud Exp $";
d43 1
a43 1
void  affect_modify args( ( CHAR_DATA *ch, AFFECT_DATA *paf, bool fAdd ) );
d1104 1
a1104 1
void affect_modify( CHAR_DATA *ch, AFFECT_DATA *paf, bool fAdd )
d1367 2
a1368 1
    affect_modify( ch, paf_new, TRUE );
d1439 1
a1439 1
void affect_remove( CHAR_DATA *ch, AFFECT_DATA *paf )
d1450 1
a1450 1
    affect_modify( ch, paf, FALSE );
d1497 1
a1497 1
  affect_modify( obj->carried_by, paf, FALSE );
d1560 1
a1560 1
      affect_remove( ch, paf );
d1602 1
a1602 1
      affect_remove( ch, paf_old );
d1972 1
d1998 3
d2004 1
a2004 1
          affect_modify( ch, paf, TRUE );
d2009 1
a2009 1
      affect_modify( ch, paf, TRUE );
d2068 1
d2080 3
d2094 1
a2094 1
            affect_remove( ch, lpaf );
d2101 1
a2101 1
          affect_modify( ch, paf, FALSE );
d2118 1
a2118 1
        affect_remove( ch, lpaf );
d2125 1
a2125 1
      affect_modify( ch, paf, FALSE );
@


1.98
log
@debug lines for second hitroll stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.97 2000/03/06 01:44:38 mud Exp $";
d1108 1
@


1.97
log
@some IS_NPC checks to help get rid od seg fault
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.96 2000/03/06 01:09:18 mud Exp $";
d624 1
d735 3
d739 1
d741 3
d745 1
d784 2
d825 2
d1177 2
d1181 3
d1185 1
@


1.96
log
@Syntax erros for APPLY_HITROL
poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.95 2000/03/06 00:23:40 mud Exp $";
d1165 2
a1166 1
	ch->pcdata->second_hitroll   += mod; 
d1170 2
a1171 1
	ch->pcdata->second_damroll   += mod; 
@


1.95
log
@Dual Wield changes, second_hitroll,second_damroll and increase skill points to 2 for spells
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.94 2000/02/27 18:16:06 mud Exp $";
d734 1
a734 1
           ch->pcdata->second_hitroll   += mod; break;
d736 2
a737 1
           ch->hitroll   += mod; break;
d740 1
a740 1
	   ch->pcdata->second_damroll   += mod; break;
d742 2
a743 1
	   ch->damroll   += mod; break;
@


1.94
log
@typo fix in can_see _obj
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.93 2000/02/27 17:21:30 mud Exp $";
d554 1
a554 1
int get_weapon_sn(CHAR_DATA *ch)
d559 5
a563 1
    wield = get_eq_char( ch, WEAR_WIELD );
d699 2
d732 10
a741 2
    case APPLY_HITROLL: ch->hitroll   += mod; break;
    case APPLY_DAMROLL: ch->damroll   += mod; break;
d772 8
a779 2
    case APPLY_HITROLL:     ch->hitroll             += mod; break;
                case APPLY_DAMROLL:     ch->damroll             += mod; break;
d811 8
a818 2
                case APPLY_HITROLL:     ch->hitroll             += mod; break;
                case APPLY_DAMROLL:     ch->damroll             += mod; break;
d1161 8
a1168 2
    case APPLY_HITROLL:       ch->hitroll   += mod; break;
    case APPLY_DAMROLL:       ch->damroll   += mod; break;
@


1.93
log
@ added guilds in possible rooms types for rogues

 added checks in can_see_obj for pills and potions spells types
 if potion/pill has cure blind or cancel on it, you can see it when blind

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.92 2000/02/25 01:57:36 mud Exp $";
d3030 1
a3030 1
    if ( IS_OBJ_STAT(obj,ITEM_MAGIC) && IS_OBJ_STAT(obj,ITEM_HUM)
@


1.92
log
@bump up numbers items carry and weight for pfreshers
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.91 2000/02/20 08:30:07 mud Exp $";
d2976 4
d3000 1
d3005 1
d3009 20
a3028 1
  return FALSE;
d3030 2
a3031 1
    if ( IS_OBJ_STAT(obj,ITEM_GLOW))
d3033 1
@


1.91
log
@ removed all sorts fo debug statements now the the bug has been removed

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.90 2000/02/20 07:50:34 mud Exp $";
d922 1
a922 1
    return ( 10 * (MAX_WEAR +  2 * 25 + 51));
d942 1
a942 1
    return str_app[25].carry * 10 + (51*25);
@


1.90
log
@ syntax error corrections
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.89 2000/02/20 07:45:15 mud Exp $";
a2492 2
      sprintf(log_buf,"P23");
      bug( log_buf, 0 );
a2515 2
      sprintf(log_buf,"P24");
      bug( log_buf, 0 );
a2538 2
      sprintf(log_buf,"Get Obj Carry Start %s ", ch->name );
      bug( log_buf, 0 );
a2543 2
      sprintf(log_buf,"P20");
      bug( log_buf, 0 );
a2551 2
      sprintf(log_buf,"Get Obj Carry End %s ", ch->name );
      bug( log_buf, 0 );
a2571 2
      sprintf(log_buf,"P21");
      bug( log_buf, 0 );
a2624 2
      sprintf(log_buf,"P22");
      bug( log_buf, 0 );
@


1.89
log
@ FOUND the crash bug, can_carry_n and can_carry_w crashed teh game
 since it checked ch->pcdata for mobs....KABOOM
 Minister
 i removed my temp kludges in do_get and do_give and added some
 IS_NPC check before every logout_tracker
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.88 2000/02/20 07:12:56 mud Exp $";
d939 1
a939 1
  if ( IS_NPC (ch) )
@


1.88
log
@ removed a fe debug lines
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.87 2000/02/20 07:04:47 mud Exp $";
d918 3
a920 1
   
d939 2
a940 1
  
@


1.87
log
@syntax error in my debug flags
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.86 2000/02/20 07:02:04 mud Exp $";
a2741 2
sprintf( log_buf, " 1 getobj # ");
bug(log_buf,0);
a2747 2
sprintf( log_buf, " 2 getobj # ");
bug(log_buf,0);
a2750 2
sprintf( log_buf, " 3 getobj # ");
bug(log_buf,0);
a2753 2
sprintf( log_buf, " 4 getobj # ");
bug(log_buf,0);
@


1.86
log
@ more debug flags
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.85 2000/02/20 03:46:19 mud Exp $";
d2743 1
a2743 1
bug(log_buf);
d2751 1
a2751 1
bug(log_buf);
d2756 1
a2756 1
bug(log_buf);
d2761 1
a2761 1
bug(log_buf);
@


1.85
log
@debugging
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.84 2000/02/20 03:25:29 mud Exp $";
d2742 3
a2744 1
 
d2750 2
d2755 2
d2758 4
d2763 1
a2763 1
 
@


1.84
log
@iremove some debug lines
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.83 2000/02/20 03:13:20 mud Exp $";
d2490 2
d2515 2
d2547 2
d2579 2
d2634 2
@


1.83
log
@debugging debugs
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.82 2000/02/20 02:56:45 mud Exp $";
a2975 2
      sprintf(log_buf,"start can see %s ", ch->name );
      bug( log_buf, 0 );
a2988 2
      sprintf(log_buf,"1 can see %s ", ch->name );
      bug( log_buf, 0 );
a2991 2
      sprintf(log_buf,"2 can see %s ", ch->name );
      bug( log_buf, 0 );
a2993 2
      sprintf(log_buf,"3 can see %s ", ch->name );
      bug( log_buf, 0 );
a2998 2
      sprintf(log_buf,"4 can see %s ", ch->name );
      bug( log_buf, 0 );
a3002 2
      sprintf(log_buf,"5 can see %s ", ch->name );
      bug( log_buf, 0 );
a3005 2
      sprintf(log_buf,"6 can see %s ", ch->name );
      bug( log_buf, 0 );
a3009 2
      sprintf(log_buf,"7 can see %s ", ch->name );
      bug( log_buf, 0 );
a3013 2
      sprintf(log_buf,"8 can see %s ", ch->name );
      bug( log_buf, 0 );
a3016 2
      sprintf(log_buf,"end can see %s ", ch->name );
      bug( log_buf, 0 );
@


1.82
log
@debug can_see
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.81 2000/02/20 02:38:59 mud Exp $";
d2536 2
d2551 2
@


1.81
log
@debugging cansee
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.80 2000/02/20 02:15:07 mud Exp $";
d2987 2
d2992 2
d2996 2
d3003 2
d3006 1
a3006 1
	 ( (obj->item_type != ITEM_POTION) && (obj->item_type != ITEM_PILL) )
d3009 2
d3014 2
d3020 2
d3026 2
@


1.80
log
@    again minor change to get current stat

    Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.79 2000/02/20 00:36:49 mud Exp $";
d2972 2
d3015 2
@


1.79
log
@handler.c     minor fix to max trainable stat function
              mixed reclasses now get +1 to two stats
	      instead of +2 to one stat

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.78 2000/02/19 18:50:39 mud Exp $";
d850 1
a850 1
       || ( ch->class == class_lookup("elementalist")))
@


1.78
log
@ fight.c  changed the pen for blademasters to /5 instead of /4
	  so they have the same pen as druids

 handler.c
	changed max trainable to be similar to max attainable
	so reclasses now get +1 to both mixed reclass primaries
	instead of a +2 on a reclass primary

 magic.c
	added two more mods to saves calculations

 mag2.c
	 cahnged earthbind, 2 ticks now, lose haste NOT slow
	  and a lot less dex loss
	  more work to do with this spell, consider it a work in progress




	  MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.77 2000/02/18 08:02:01 mud Exp $";
d885 1
a885 1
       || ( ch->class == class_lookup("elementalist")))
@


1.77
log
@make it so double reclasses get +2 in some stat
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.76 2000/02/18 07:02:47 mud Exp $";
d850 1
a850 1
       || ( ch->class >= class_lookup("elementalist")))
d884 12
d897 3
a899 4
  if (ch->race == race_lookup("human"))
     max += 3;
  else
     max += 2;
@


1.76
log
@change max stat for reclasses to reflact allowed oldclasses +1 instead of +2
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.75 2000/02/15 21:38:10 mud Exp $";
d850 1
a850 1
       || ( ch->class == class_lookup("elementalist")))
@


1.75
log
@misplaced ending bracket
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.74 2000/02/15 21:36:47 mud Exp $";
d849 12
a860 2
  if (class_table[ch->class].attr_prime == stat)
      max += 2;
@


1.74
log
@Hard code largest possible numbers for logout tracker weight and item #
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.73 2000/02/15 20:53:21 mud Exp $";
d899 1
a899 1
    return ( 10 * (MAX_WEAR +  2 * 25) + 51));
@


1.73
log
@commiting rages weight/item # for pfresh changes he forgot
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.72 2000/02/15 15:16:20 mud Exp $";
d899 1
a899 1
    return ( 10 * (MAX_WEAR +  2 * get_curr_stat(ch, STAT_DEX) + 51));
d918 1
a918 1
    return str_app[get_curr_stat(ch,STAT_STR)].carry * 10 + (51*25);
@


1.72
log
@ fixed a booboo in handler.c with last change
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.71 2000/02/15 15:13:09 mud Exp $";
d898 1
a898 1
   if ( ch->pcdata->logout_tracker > 0 )
d917 1
a917 1
  if (ch->pcdata->logout_tracker > 0)
@


1.71
log
@ Added in removeal of weight code for chars still under 5 login pfresh limit
 Made some shanges to summon_elemental

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.70 2000/02/12 22:11:35 mud Exp $";
d899 1
a899 1
    return ( 10 * (MAX_WEAR +  2 * get_curr_stat(ch, STA_DEX) + 51));
@


1.70
log
@handler .c   opps. should of been && instead of || for that blind and pill
             can_see_object

	     Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.69 2000/02/12 21:41:13 mud Exp $";
d897 4
a900 1

d916 4
a919 1

@


1.69
log
@handler.c   can_see_obj
              made it so pills can be eaten when blind , same as potions

	      Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.68 2000/02/11 20:20:42 mud Exp $";
d2969 1
a2969 1
	 ( (obj->item_type != ITEM_POTION) || (obj->item_type != ITEM_PILL) )
@


1.68
log
@change ITEM_DARK to ITEM_IMM_LOAD and add removal of imm loads from pfreshed char
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.67 1999/12/17 23:13:40 mud Exp $";
d2968 3
a2970 1
    if (IS_AFFECTED(ch,AFF_BLIND) && obj->item_type != ITEM_POTION )
@


1.67
log
@Removed Savant added   Pfresh flag
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.66 1999/11/19 19:26:19 mud Exp $";
d3167 1
d3169 1
d3192 1
@


1.66
log
@New savant code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.65 1999/11/07 00:56:01 mud Exp $";
d3206 1
@


1.65
log
@Wear Timer for Objects
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.64 1999/11/02 22:08:25 mud Exp $";
d3428 1
@


1.64
log
@Just added some GSN's (fade and vision) and made some minor adjustments to the vision potion effect.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.63 1999/10/21 02:22:25 mud Exp $";
d3184 1
@


1.63
log
@Fixing not locating items on immortals
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.62 1999/10/21 02:10:02 mud Exp $";
d2877 7
a2883 1
    return FALSE;
@


1.62
log
@Forgot a ; on the end of victim in can_See_obj to hide wizi and invis
object on immortals
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.61 1999/10/21 02:06:23 mud Exp $";
d2939 1
a2939 1
    if(victim = obj->carried_by != NULL)
d2941 1
@


1.61
log
@Make object truely invis depending on Wizi and Incog levels
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.60 1999/10/17 23:22:51 mud Exp $";
d2937 1
a2937 1
    CHAR_DATA *victim
@


1.60
log
@Changes autorescue to norescue, made more sense
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.59 1999/10/17 22:56:44 mud Exp $";
a2865 1

d2937 14
@


1.59
log
@Fight.c - Changed do_rescue to check for MHS_AUTORESCUE
act_info.c - Displays of AUTORESCUE
handler.c - do_autorescue created
interp.c and interp.h - defined new do_autorescue
merc.h - defined MHS_AUTORESCUE
tables.c - added autorescue
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.58 1999/10/15 21:27:21 mud Exp $";
d3184 1
a3184 1
   if (mhs_flags & MHS_AUTORESCUE )	strcat(buf, " autorescue");
@


1.58
log
@Think I squashed the Morph Bug
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.57 1999/10/15 20:17:58 mud Exp $";
d3184 1
@


1.57
log
@Debugging Shapemorph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.56 1999/10/15 01:19:27 mud Exp $";
a2374 1
    send_to_char("blah\n\r",ch);
d2379 1
a2379 1
	  if(!is_name( arg, rch->save_name ) )
@


1.56
log
@Mispelled SHAPEMORPHED
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.55 1999/10/15 01:17:31 mud Exp $";
d2375 1
@


1.55
log
@Changed char_in_room to check for is_name (name) and (save_name) to avoid having
to change ch->name, cause that can get messy.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.54 1999/10/02 00:09:06 mud Exp $";
d2377 1
a2377 1
	if(IS_SET(rch->mhs,SHAPEMORPHED))
@


1.54
log
@New Shapeshifter Power - Shapemorph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.53 1999/08/23 03:34:45 mud Exp $";
d2375 10
a2384 1
        if ( !can_see( ch, rch ) || !is_name( arg, rch->name ) ) {
d2386 3
a2388 2
        } else {
          if (number)  {
d2390 6
a2395 5
                return rch;
          } else {
            if (IS_NPC (rch)) return rch;
            if (!wch) wch = rch;
          }
@


1.53
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.52 1999/08/12 01:30:04 mud Exp $";
d3172 1
@


1.52
log
@Adde fade thing
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.51 1999/08/12 01:12:15 mud Exp $";
d46 18
d66 1
a66 1
    return ( ch->mount == NULL ? FALSE : TRUE );
d1954 1
d2296 1
@


1.51
log
@Bug fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.50 1999/08/12 01:03:59 mud Exp $";
d2831 1
a2831 1
    
d2845 3
@


1.50
log
@Nethermancers are in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.49 1999/08/11 04:55:50 mud Exp $";
d3370 1
a3370 1
    if (weapon_flags & WEAPON_NETHER ) stract(buf, " nether" );
@


1.49
log
@Many many changes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.48 1999/08/09 22:08:28 mud Exp $";
d3370 1
@


1.48
log
@Removed all of Rusty's cheat codes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.47 1999/07/14 18:13:41 mud Exp $";
d530 1
a530 1
	skill -= (number_range(5,UMAX(5,skill/2)));
@


1.47
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: handler.c,v 1.46 1999/06/28 06:34:18 mud Exp $";
d829 1
a829 1
  max = pc_race_table[ch->race].max_stats[stat] +(IS_SET(ch->act,PLR_OLD)?5:4);
d2829 1
a2829 1
    if ( ch == victim || IS_SET(ch->act,PLR_OLD) )
d2846 1
a2846 1
    if ( room_is_dark( ch->in_room ) && (!IS_AFFECTED(ch, AFF_INFRARED) && !IS_SET(ch->act,PLR_OLD)) )
@


1.46
log
@Fixed skill levels
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.45 1999/06/24 02:33:58 mud Exp $ */
@


1.45
log
@Fixed an obscure bug in steal
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.44 1999/06/17 15:41:10 mud Exp $ */
d444 1
a444 1
  if (ch->level < skill_table[sn].skill_level[ch->class])
@


1.44
log
@Forgot a ending ) in the ROOM Flag for nonclan
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.43 1999/06/17 15:36:10 mud Exp $ */
d2437 25
@


1.43
log
@Addded NOCLAN room flag not allowing clanners in rooms
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.42 1999/06/17 15:15:54 mud Exp $ */
d2738 1
a2738 1
    && (count >= 2 || IS_SET(ch->mhs,MHS_HIGHLANDER))
d2742 1
a2742 1
    && (count >= 1 || IS_SET(ch->mhs,MHS_HIGHLANDER))
@


1.42
log
@NOCLAN Room flag not allowing clanners into room
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.41 1999/05/26 03:27:32 mud Exp $ */
d1921 1
a1921 1
        if( pRoomIndex != NULL && !room_is_private(pRoomIndex) )
d2724 1
a2724 1
bool room_is_private( ROOM_INDEX_DATA *pRoomIndex )
d2737 2
a2738 1
    if ( IS_SET(pRoomIndex->room_flags, ROOM_PRIVATE)  && count >= 2 )
d2741 2
a2742 1
    if ( IS_SET(pRoomIndex->room_flags, ROOM_SOLITARY) && count >= 1 )
@


1.41
log
@Changes to add in garotte item types and add the garotte
skill to assassins.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.40 1999/05/16 04:42:55 mud Exp $ */
d2746 4
d2785 4
@


1.40
log
@Shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.39 1999/05/13 21:02:19 mud Exp $ */
d555 1
@


1.39
log
@Food can't only count as a third of an item because
a ch can then carry too many for the fwrite_obj()
recursion causing a crash.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.38 1999/04/26 07:58:15 mud Exp $ */
d3112 1
@


1.38
log
@Added the SAVANT falg to the bit name in handler.c
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.37 1999/04/24 12:38:53 mud Exp $ */
a2651 3

    if ( obj->item_type == ITEM_FOOD )
	number = 3;
@


1.37
log
@Fix for Matook communications and such.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.36 1999/04/23 23:43:41 mud Exp $ */
d3111 4
a3114 3
   if (mhs_flags & MHS_OLD_RECLASS) strcat(buf, " old-reclass");
   if (mhs_flags & MHS_MUTANT  ) strcat(buf, " mutant");
   if (mhs_flags & MHS_HIGHLANDER  ) strcat(buf, " highlander");
@


1.36
log
@Change all PLR_HIGHLANDER to MHS_HIGHLANDER and moved under MHS bit
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.35 1999/04/12 02:54:44 mud Exp $ */
d410 1
a410 1
    if (clan_table[ch->clan].independent)
@


1.35
log
@Added HighLander
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.34 1999/03/29 19:12:13 mud Exp $ */
d3112 2
a3166 1
  if (act_flags & PLR_HIGHLANDER  ) strcat(buf, " highlander");
@


1.34
log
@Changes to kender, lashers and half-elves.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.33 1999/03/28 09:32:26 mud Exp $ */
d3164 2
@


1.33
log
@Added NOIDENTIFY flag for objects
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.32 1999/03/27 23:55:33 mud Exp $ */
d833 2
a834 1
  if ( ch->race == race_lookup("human") || ch->race == race_lookup("goblin") )
@


1.32
log
@Named the WEAPON_FAVOR flag, now is 'favor' not '(??)'
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.31 1998/12/23 16:51:34 mud Exp $ */
d3100 1
@


1.31
log
@Bunch of changes for rogues, including new skill and pther improvements
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.30 1998/12/13 22:51:48 mud Exp $ */
d3329 1
a3329 1
    if (weapon_flags & WEAPON_FAVORED ) strcat(buf, " ({???{x)");
@


1.30
log
@plague conatgion affect removed
:wq
;
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.29 1998/12/12 02:44:40 mud Exp $ */
d2829 1
d2851 1
@


1.29
log
@Fixed sac poit problem
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.28 1998/12/12 01:36:53 mud Exp $ */
d1607 1
d1648 1
@


1.28
log
@Fixed the 0 thing
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.27 1998/12/12 01:20:55 mud Exp $ */
d70 4
a73 1
	return UMIN( ch->pcdata->sac + points, max );
@


1.27
log
@Error checking
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.26 1998/12/09 08:50:25 mud Exp $ */
d57 1
a57 1
		return;
@


1.26
log
@Few information things
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.25 1998/12/09 08:32:16 mud Exp $ */
d49 22
@


1.25
log
@Re-reclassing.
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.24 1998/12/09 00:33:21 mud Exp $ */
d3072 11
@


1.24
log
@Ninjas
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.23 1998/12/08 01:54:13 mud Exp $ */
d45 5
@


1.23
log
@barbarians are done
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.22 1998/12/05 09:29:59 mud Exp $ */
d2799 2
a2800 1
  if (number_percent() < chance)
d2820 2
a2821 1
  if (number_percent() < chance)
@


1.22
log
@Misfired ... wrong directory, oh well
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.21 1998/12/02 18:51:14 mud Exp $ */
d1340 3
@


1.21
log
@blah
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.20 1998/12/02 09:06:38 mud Exp $ */
d262 14
@


1.20
log
@Fixed reclass bug and 'aid' bug
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.19 1998/11/28 09:21:50 mud Exp $ */
d2822 4
@


1.19
log
@*** empty log message ***
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.18 1998/11/28 07:49:34 mud Exp $ */
d3261 1
a3261 1
    if (weapon_flags & WEAPON_FAVORED ) strcat(buf, " ({Bunknown{x)");
@


1.18
log
@favored flag
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.17 1998/11/22 10:36:37 mud Exp $ */
d3261 1
a3261 1

@


1.17
log
@Added wizards
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.16 1998/11/22 08:45:29 mud Exp $ */
d2543 1
a2543 1
  obj = create_object( get_obj_index( OBJ_VNUM_SILVER_ONE ), 0 );
d2547 1
a2547 1
  obj = create_object( get_obj_index( OBJ_VNUM_GOLD_ONE), 0 );
d2551 1
a2551 1
        obj = create_object( get_obj_index( OBJ_VNUM_GOLD_SOME ), 0 );
d2561 1
a2561 1
        obj = create_object( get_obj_index( OBJ_VNUM_SILVER_SOME ), 0 );
d2572 1
a2572 1
  obj = create_object( get_obj_index( OBJ_VNUM_COINS ), 0 );
@


1.16
log
@Fixed an exit bug
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.15 1998/11/22 08:04:44 mud Exp $ */
d484 3
@


1.15
log
@Infiltrate coded.
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.14 1998/10/30 03:01:53 mud Exp $ */
d2701 7
a2707 1
    if ( pRoomIndex->clan && pRoomIndex->clan == ch->clan )
@


1.14
log
@MudTrader on line
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.13 1998/10/25 18:42:13 mud Exp $ */
d2698 9
a2723 3
  return FALSE;

    if (pRoomIndex->clan && ch->clan != pRoomIndex->clan && !IS_IMMORTAL(ch) )
@


1.13
log
@hours removed
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.12 1998/10/12 20:57:25 mud Exp $ */
d44 1
d1498 5
@


1.12
log
@Fixing bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.11 1998/10/11 00:13:34 mud Exp $ */
d789 1
a789 1
      max += get_age(ch) / 15;
d813 1
a813 1
       max += get_age(ch) / 15;
@


1.11
log
@Specializatio for warriros is in
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.10 1998/08/30 03:33:35 mud Exp $ */
d3059 2
@


1.10
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.9 1998/08/21 14:21:10 mud Exp $ */
d531 1
d533 3
d538 5
a542 1
    return URANGE(0,skill,100);
@


1.9
log
@I dunno
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.8 1998/08/20 21:05:32 mud Exp $ */
a3081 4
    if (comm_flags & COMM_COMPACT ) strcat(buf, " compact");
    if (comm_flags & COMM_BRIEF   ) strcat(buf, " brief");
    if (comm_flags & COMM_PROMPT  ) strcat(buf, " prompt");
    if (comm_flags & COMM_COMBINE ) strcat(buf, " combine");
@


1.8
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.7 1998/08/13 05:24:10 mud Exp $ */
d360 1
a360 1
    return ( clan_table[ch->pcdata->clan].true_clan );
d365 1
a365 1
    if (clan_table[ch->pcdata->clan].independent)
d368 1
a368 1
  return (ch->pcdata->clan == victim->pcdata->clan);
d2213 1
a2213 1
        char_to_room(ch,get_room_index(clan_table[ch->pcdata->clan].hall));
d2703 1
a2703 1
    if (pRoomIndex->clan && ch->pcdata->clan != pRoomIndex->clan && !IS_IMMORTAL(ch) )
@


1.7
log
@* Various bug fixes, mostly
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.6 1998/08/12 08:20:18 mud Exp $ */
d360 1
a360 1
    return ( clan_table[ch->clan].true_clan );
d365 1
a365 1
    if (clan_table[ch->clan].independent)
d368 1
a368 1
  return (ch->clan == victim->clan);
d1848 1
a1848 1
	 sprintf(buf,"%s has forsaken you.\n\r",deity_table[ch->deity].pname);
d2213 1
a2213 1
        char_to_room(ch,get_room_index(clan_table[ch->clan].hall));
d2703 1
a2703 1
    if (pRoomIndex->clan && ch->clan != pRoomIndex->clan && !IS_IMMORTAL(ch) )
@


1.6
log
@* Finished traps
* Rockbiters added
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.5 1998/08/10 19:41:23 mud Exp $ */
d780 3
d2831 3
d2892 1
@


1.5
log
@* Starter code for 'feign death'
* Protection neutral added
* Fixed bug with vampires
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.4 1998/08/07 20:19:58 mud Exp $ */
d801 3
d1173 14
@


1.4
log
@Room affects stuff for traps.
Bleed/vampire changes.
swim/scan start at 50% and 50%up for free for existing characters.
moved trap to after trip in interp list for grandfathered use
- Both of Us
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.3 1998/08/05 07:30:31 mud Exp $ */
d1572 1
a1572 1
	if ( paf->type = gsn_trap )
d2565 3
@


1.3
log
@* Gems are now 1/2 of an itme instead of a full item
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.2 1998/07/29 05:32:35 mud Exp $ */
d1155 18
d1217 7
d1225 27
d1484 1
d1564 17
d1582 9
d3206 1
@


1.2
log
@Added the 'Matook' flag.  Implemented by adding a 'true-clan' boolean
to the clan table, and changed is_clan to return the true-clan variable
rather than just the ch->clan element.  No other modifications were
needed as far as I know. -Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: handler.c,v 1.1 1998/06/16 17:49:24 mud Exp $ */
d811 1
a811 1
  return 1000;
d816 1
a816 1
    return MAX_WEAR +  2 * get_curr_stat(ch,STAT_DEX) + ch->level;
d2482 5
a2486 2
        number = 1;
 
d2488 1
a2488 1
        number += get_obj_number( obj );
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d360 1
a360 1
    return ch->clan;
@
