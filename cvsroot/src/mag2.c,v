head	1.438;
access;
symbols;
locks; strict;
comment	@ * @;


1.438
date	2005.02.01.03.54.37;	author rusty;	state Exp;
branches;
next	1.437;

1.437
date	2004.10.24.19.25.18;	author boogums;	state Exp;
branches;
next	1.436;

1.436
date	2004.09.01.04.42.52;	author boogums;	state Exp;
branches;
next	1.435;

1.435
date	2004.09.01.02.35.01;	author boogums;	state Exp;
branches;
next	1.434;

1.434
date	2004.08.30.02.24.33;	author boogums;	state Exp;
branches;
next	1.433;

1.433
date	2004.08.30.02.18.35;	author boogums;	state Exp;
branches;
next	1.432;

1.432
date	2004.08.30.00.10.22;	author boogums;	state Exp;
branches;
next	1.431;

1.431
date	2004.08.30.00.04.25;	author boogums;	state Exp;
branches;
next	1.430;

1.430
date	2004.08.29.23.54.17;	author boogums;	state Exp;
branches;
next	1.429;

1.429
date	2004.08.29.22.50.14;	author boogums;	state Exp;
branches;
next	1.428;

1.428
date	2004.08.27.12.58.13;	author boogums;	state Exp;
branches;
next	1.427;

1.427
date	2004.08.26.01.30.26;	author boogums;	state Exp;
branches;
next	1.426;

1.426
date	2004.03.27.15.51.41;	author boogums;	state Exp;
branches;
next	1.425;

1.425
date	2004.02.04.02.53.02;	author boogums;	state Exp;
branches;
next	1.424;

1.424
date	2004.01.26.00.11.09;	author boogums;	state Exp;
branches;
next	1.423;

1.423
date	2004.01.26.00.00.22;	author boogums;	state Exp;
branches;
next	1.422;

1.422
date	2003.10.01.00.14.12;	author ndagger;	state Exp;
branches;
next	1.421;

1.421
date	2003.06.14.19.53.11;	author boogums;	state Exp;
branches;
next	1.420;

1.420
date	2003.06.12.02.31.43;	author boogums;	state Exp;
branches;
next	1.419;

1.419
date	2003.06.10.01.34.14;	author boogums;	state Exp;
branches;
next	1.418;

1.418
date	2003.06.08.22.03.32;	author boogums;	state Exp;
branches;
next	1.417;

1.417
date	2003.06.05.17.51.39;	author rusty;	state Exp;
branches;
next	1.416;

1.416
date	2003.06.03.18.51.49;	author mud;	state Exp;
branches;
next	1.415;

1.415
date	2003.06.03.18.34.12;	author rusty;	state Exp;
branches;
next	1.414;

1.414
date	2003.06.03.18.02.18;	author mud;	state Exp;
branches;
next	1.413;

1.413
date	2003.06.03.17.49.54;	author rusty;	state Exp;
branches;
next	1.412;

1.412
date	2003.06.03.02.57.27;	author boogums;	state Exp;
branches;
next	1.411;

1.411
date	2003.05.30.02.23.05;	author ndagger;	state Exp;
branches;
next	1.410;

1.410
date	2003.05.28.17.14.09;	author boogums;	state Exp;
branches;
next	1.409;

1.409
date	2003.05.25.17.41.45;	author boogums;	state Exp;
branches;
next	1.408;

1.408
date	2003.05.25.14.32.22;	author boogums;	state Exp;
branches;
next	1.407;

1.407
date	2003.05.25.01.34.23;	author boogums;	state Exp;
branches;
next	1.406;

1.406
date	2003.05.24.16.36.22;	author boogums;	state Exp;
branches;
next	1.405;

1.405
date	2003.05.19.03.20.34;	author ndagger;	state Exp;
branches;
next	1.404;

1.404
date	2003.03.12.04.02.36;	author boogums;	state Exp;
branches;
next	1.403;

1.403
date	2003.02.17.21.54.50;	author ndagger;	state Exp;
branches;
next	1.402;

1.402
date	2002.11.15.02.26.52;	author boogums;	state Exp;
branches;
next	1.401;

1.401
date	2002.10.26.02.43.19;	author boogums;	state Exp;
branches;
next	1.400;

1.400
date	2002.10.20.00.46.27;	author boogums;	state Exp;
branches;
next	1.399;

1.399
date	2002.09.29.20.17.12;	author boogums;	state Exp;
branches;
next	1.398;

1.398
date	2002.09.27.04.17.54;	author boogums;	state Exp;
branches;
next	1.397;

1.397
date	2002.09.27.04.05.30;	author boogums;	state Exp;
branches;
next	1.396;

1.396
date	2002.09.15.01.12.14;	author boogums;	state Exp;
branches;
next	1.395;

1.395
date	2002.09.10.23.46.20;	author boogums;	state Exp;
branches;
next	1.394;

1.394
date	2002.09.09.15.49.12;	author boogums;	state Exp;
branches;
next	1.393;

1.393
date	2002.09.09.07.33.56;	author ndagger;	state Exp;
branches;
next	1.392;

1.392
date	2002.09.09.07.24.35;	author ndagger;	state Exp;
branches;
next	1.391;

1.391
date	2002.09.08.19.06.21;	author ndagger;	state Exp;
branches;
next	1.390;

1.390
date	2002.09.06.20.18.41;	author boogums;	state Exp;
branches;
next	1.389;

1.389
date	2002.09.05.14.17.05;	author boogums;	state Exp;
branches;
next	1.388;

1.388
date	2002.09.01.14.55.07;	author boogums;	state Exp;
branches;
next	1.387;

1.387
date	2002.07.01.00.51.40;	author boogums;	state Exp;
branches;
next	1.386;

1.386
date	2002.07.01.00.46.34;	author boogums;	state Exp;
branches;
next	1.385;

1.385
date	2002.07.01.00.26.20;	author boogums;	state Exp;
branches;
next	1.384;

1.384
date	2002.06.29.03.41.31;	author boogums;	state Exp;
branches;
next	1.383;

1.383
date	2002.04.27.02.16.03;	author boogums;	state Exp;
branches;
next	1.382;

1.382
date	2002.04.11.03.42.07;	author boogums;	state Exp;
branches;
next	1.381;

1.381
date	2002.04.11.03.17.38;	author boogums;	state Exp;
branches;
next	1.380;

1.380
date	2002.03.11.08.15.48;	author rusty;	state Exp;
branches;
next	1.379;

1.379
date	2002.03.09.19.14.28;	author rusty;	state Exp;
branches;
next	1.378;

1.378
date	2002.02.28.19.19.13;	author rusty;	state Exp;
branches;
next	1.377;

1.377
date	2002.02.11.20.28.35;	author poquah;	state Exp;
branches;
next	1.376;

1.376
date	2002.01.26.16.25.27;	author rage;	state Exp;
branches;
next	1.375;

1.375
date	2001.12.06.18.31.51;	author rage;	state Exp;
branches;
next	1.374;

1.374
date	2001.11.24.15.09.57;	author rage;	state Exp;
branches;
next	1.373;

1.373
date	2001.11.16.00.32.19;	author rage;	state Exp;
branches;
next	1.372;

1.372
date	2001.11.11.23.48.17;	author rage;	state Exp;
branches;
next	1.371;

1.371
date	2001.11.11.17.29.11;	author rage;	state Exp;
branches;
next	1.370;

1.370
date	2001.11.11.02.08.39;	author rage;	state Exp;
branches;
next	1.369;

1.369
date	2001.11.11.02.04.41;	author rage;	state Exp;
branches;
next	1.368;

1.368
date	2001.11.11.01.25.15;	author rage;	state Exp;
branches;
next	1.367;

1.367
date	2001.11.11.01.01.13;	author rage;	state Exp;
branches;
next	1.366;

1.366
date	2001.10.20.19.40.44;	author rage;	state Exp;
branches;
next	1.365;

1.365
date	2001.10.18.23.35.36;	author rage;	state Exp;
branches;
next	1.364;

1.364
date	2001.10.18.23.20.34;	author rage;	state Exp;
branches;
next	1.363;

1.363
date	2001.10.18.19.43.57;	author rage;	state Exp;
branches;
next	1.362;

1.362
date	2001.10.14.04.08.44;	author rage;	state Exp;
branches;
next	1.361;

1.361
date	2001.10.13.02.11.59;	author rage;	state Exp;
branches;
next	1.360;

1.360
date	2001.10.12.17.37.25;	author rage;	state Exp;
branches;
next	1.359;

1.359
date	2001.10.05.18.09.38;	author rage;	state Exp;
branches;
next	1.358;

1.358
date	2001.08.24.00.42.18;	author guerrand;	state Exp;
branches;
next	1.357;

1.357
date	2001.08.19.20.46.00;	author guerrand;	state Exp;
branches;
next	1.356;

1.356
date	2001.08.05.23.18.09;	author guerrand;	state Exp;
branches;
next	1.355;

1.355
date	2001.08.05.22.47.36;	author guerrand;	state Exp;
branches;
next	1.354;

1.354
date	2001.08.04.16.03.02;	author guerrand;	state Exp;
branches;
next	1.353;

1.353
date	2001.08.04.15.54.47;	author guerrand;	state Exp;
branches;
next	1.352;

1.352
date	2001.08.03.03.18.36;	author guerrand;	state Exp;
branches;
next	1.351;

1.351
date	2001.08.03.02.24.30;	author boogums;	state Exp;
branches;
next	1.350;

1.350
date	2001.08.02.02.12.09;	author guerrand;	state Exp;
branches;
next	1.349;

1.349
date	2001.07.31.02.48.16;	author boogums;	state Exp;
branches;
next	1.348;

1.348
date	2001.07.31.01.11.37;	author boogums;	state Exp;
branches;
next	1.347;

1.347
date	2001.07.30.04.51.49;	author guerrand;	state Exp;
branches;
next	1.346;

1.346
date	2001.07.27.03.03.20;	author guerrand;	state Exp;
branches;
next	1.345;

1.345
date	2001.07.27.02.35.02;	author guerrand;	state Exp;
branches;
next	1.344;

1.344
date	2001.07.27.02.14.11;	author guerrand;	state Exp;
branches;
next	1.343;

1.343
date	2001.07.25.18.27.44;	author rage;	state Exp;
branches;
next	1.342;

1.342
date	2001.07.15.23.42.38;	author guerrand;	state Exp;
branches;
next	1.341;

1.341
date	2001.07.12.00.25.55;	author rage;	state Exp;
branches;
next	1.340;

1.340
date	2001.07.04.15.22.24;	author guerrand;	state Exp;
branches;
next	1.339;

1.339
date	2001.07.04.04.24.15;	author guerrand;	state Exp;
branches;
next	1.338;

1.338
date	2001.07.04.01.36.41;	author guerrand;	state Exp;
branches;
next	1.337;

1.337
date	2001.07.04.01.21.57;	author guerrand;	state Exp;
branches;
next	1.336;

1.336
date	2001.07.03.03.28.49;	author guerrand;	state Exp;
branches;
next	1.335;

1.335
date	2001.06.28.04.21.52;	author guerrand;	state Exp;
branches;
next	1.334;

1.334
date	2001.06.28.03.41.34;	author guerrand;	state Exp;
branches;
next	1.333;

1.333
date	2001.06.24.04.14.58;	author guerrand;	state Exp;
branches;
next	1.332;

1.332
date	2001.06.24.01.27.38;	author guerrand;	state Exp;
branches;
next	1.331;

1.331
date	2001.06.23.19.12.04;	author guerrand;	state Exp;
branches;
next	1.330;

1.330
date	2001.06.22.23.45.55;	author guerrand;	state Exp;
branches;
next	1.329;

1.329
date	2001.06.19.06.04.25;	author guerrand;	state Exp;
branches;
next	1.328;

1.328
date	2001.06.19.05.00.40;	author guerrand;	state Exp;
branches;
next	1.327;

1.327
date	2001.06.18.04.31.09;	author guerrand;	state Exp;
branches;
next	1.326;

1.326
date	2001.06.18.01.17.33;	author rage;	state Exp;
branches;
next	1.325;

1.325
date	2001.06.18.00.49.51;	author guerrand;	state Exp;
branches;
next	1.324;

1.324
date	2001.06.18.00.39.30;	author guerrand;	state Exp;
branches;
next	1.323;

1.323
date	2001.06.17.19.20.47;	author guerrand;	state Exp;
branches;
next	1.322;

1.322
date	2001.06.17.18.53.41;	author guerrand;	state Exp;
branches;
next	1.321;

1.321
date	2001.06.17.17.06.00;	author guerrand;	state Exp;
branches;
next	1.320;

1.320
date	2001.06.17.01.47.21;	author guerrand;	state Exp;
branches;
next	1.319;

1.319
date	2001.06.16.15.51.16;	author rage;	state Exp;
branches;
next	1.318;

1.318
date	2001.06.16.15.49.31;	author rage;	state Exp;
branches;
next	1.317;

1.317
date	2001.06.16.15.24.14;	author rage;	state Exp;
branches;
next	1.316;

1.316
date	2001.06.15.03.08.11;	author guerrand;	state Exp;
branches;
next	1.315;

1.315
date	2001.06.15.01.27.50;	author guerrand;	state Exp;
branches;
next	1.314;

1.314
date	2001.06.14.01.03.27;	author guerrand;	state Exp;
branches;
next	1.313;

1.313
date	2001.06.13.03.47.56;	author guerrand;	state Exp;
branches;
next	1.312;

1.312
date	2001.06.11.04.44.49;	author guerrand;	state Exp;
branches;
next	1.311;

1.311
date	2001.06.11.04.22.38;	author guerrand;	state Exp;
branches;
next	1.310;

1.310
date	2001.06.11.01.17.01;	author rage;	state Exp;
branches;
next	1.309;

1.309
date	2001.06.10.04.33.36;	author guerrand;	state Exp;
branches;
next	1.308;

1.308
date	2001.06.10.04.22.27;	author guerrand;	state Exp;
branches;
next	1.307;

1.307
date	2001.06.09.19.34.46;	author guerrand;	state Exp;
branches;
next	1.306;

1.306
date	2001.06.09.18.48.47;	author guerrand;	state Exp;
branches;
next	1.305;

1.305
date	2001.06.09.04.18.23;	author guerrand;	state Exp;
branches;
next	1.304;

1.304
date	2001.06.09.03.57.00;	author guerrand;	state Exp;
branches;
next	1.303;

1.303
date	2001.06.09.01.25.33;	author guerrand;	state Exp;
branches;
next	1.302;

1.302
date	2001.06.09.01.10.52;	author guerrand;	state Exp;
branches;
next	1.301;

1.301
date	2001.06.07.22.30.00;	author rage;	state Exp;
branches;
next	1.300;

1.300
date	2001.06.03.14.42.08;	author mud;	state Exp;
branches;
next	1.299;

1.299
date	2001.06.03.14.40.27;	author rusty;	state Exp;
branches;
next	1.298;

1.298
date	2001.06.02.18.47.10;	author guerrand;	state Exp;
branches;
next	1.297;

1.297
date	2001.06.02.17.32.26;	author guerrand;	state Exp;
branches;
next	1.296;

1.296
date	2001.06.02.17.30.06;	author guerrand;	state Exp;
branches;
next	1.295;

1.295
date	2001.06.01.03.17.00;	author guerrand;	state Exp;
branches;
next	1.294;

1.294
date	2001.05.28.17.55.34;	author rusty;	state Exp;
branches;
next	1.293;

1.293
date	2001.05.27.22.05.34;	author rusty;	state Exp;
branches;
next	1.292;

1.292
date	2001.05.27.20.04.14;	author mud;	state Exp;
branches;
next	1.291;

1.291
date	2001.05.27.19.56.04;	author rusty;	state Exp;
branches;
next	1.290;

1.290
date	2001.03.19.21.04.06;	author mud;	state Exp;
branches;
next	1.289;

1.289
date	2001.03.10.22.33.31;	author mud;	state Exp;
branches;
next	1.288;

1.288
date	2001.03.10.22.09.17;	author mud;	state Exp;
branches;
next	1.287;

1.287
date	2001.03.10.21.23.40;	author mud;	state Exp;
branches;
next	1.286;

1.286
date	2001.03.10.17.38.16;	author mud;	state Exp;
branches;
next	1.285;

1.285
date	2001.03.10.16.15.38;	author mud;	state Exp;
branches;
next	1.284;

1.284
date	2001.03.10.16.02.45;	author mud;	state Exp;
branches;
next	1.283;

1.283
date	2001.03.10.15.57.05;	author mud;	state Exp;
branches;
next	1.282;

1.282
date	2001.03.10.15.29.30;	author mud;	state Exp;
branches;
next	1.281;

1.281
date	2001.03.10.15.10.18;	author mud;	state Exp;
branches;
next	1.280;

1.280
date	2001.03.10.15.04.52;	author mud;	state Exp;
branches;
next	1.279;

1.279
date	2001.03.10.14.54.45;	author mud;	state Exp;
branches;
next	1.278;

1.278
date	2001.03.10.14.35.13;	author mud;	state Exp;
branches;
next	1.277;

1.277
date	2001.03.10.14.31.20;	author mud;	state Exp;
branches;
next	1.276;

1.276
date	2001.03.10.14.26.31;	author mud;	state Exp;
branches;
next	1.275;

1.275
date	2001.03.03.19.13.26;	author mud;	state Exp;
branches;
next	1.274;

1.274
date	2001.03.03.18.53.58;	author mud;	state Exp;
branches;
next	1.273;

1.273
date	2000.12.24.02.35.51;	author mud;	state Exp;
branches;
next	1.272;

1.272
date	2000.12.24.02.30.58;	author mud;	state Exp;
branches;
next	1.271;

1.271
date	2000.12.21.05.03.38;	author mud;	state Exp;
branches;
next	1.270;

1.270
date	2000.12.15.17.05.18;	author mud;	state Exp;
branches;
next	1.269;

1.269
date	2000.12.15.06.10.00;	author mud;	state Exp;
branches;
next	1.268;

1.268
date	2000.12.15.05.19.36;	author mud;	state Exp;
branches;
next	1.267;

1.267
date	2000.12.15.03.56.49;	author mud;	state Exp;
branches;
next	1.266;

1.266
date	2000.12.13.04.10.21;	author mud;	state Exp;
branches;
next	1.265;

1.265
date	2000.12.09.07.05.49;	author mud;	state Exp;
branches;
next	1.264;

1.264
date	2000.12.07.06.45.46;	author mud;	state Exp;
branches;
next	1.263;

1.263
date	2000.12.07.06.25.40;	author mud;	state Exp;
branches;
next	1.262;

1.262
date	2000.12.07.05.46.12;	author mud;	state Exp;
branches;
next	1.261;

1.261
date	2000.12.03.19.22.56;	author mud;	state Exp;
branches;
next	1.260;

1.260
date	2000.12.03.17.50.31;	author mud;	state Exp;
branches;
next	1.259;

1.259
date	2000.12.03.03.29.14;	author mud;	state Exp;
branches;
next	1.258;

1.258
date	2000.12.03.03.24.02;	author mud;	state Exp;
branches;
next	1.257;

1.257
date	2000.11.19.18.56.24;	author mud;	state Exp;
branches;
next	1.256;

1.256
date	2000.10.16.19.17.01;	author mud;	state Exp;
branches;
next	1.255;

1.255
date	2000.10.14.04.31.50;	author mud;	state Exp;
branches;
next	1.254;

1.254
date	2000.10.13.02.34.21;	author mud;	state Exp;
branches;
next	1.253;

1.253
date	2000.10.11.13.54.54;	author mud;	state Exp;
branches;
next	1.252;

1.252
date	2000.10.10.21.14.16;	author mud;	state Exp;
branches;
next	1.251;

1.251
date	2000.10.10.21.08.59;	author mud;	state Exp;
branches;
next	1.250;

1.250
date	2000.10.10.04.07.44;	author mud;	state Exp;
branches;
next	1.249;

1.249
date	2000.10.10.03.38.32;	author mud;	state Exp;
branches;
next	1.248;

1.248
date	2000.10.10.03.33.19;	author mud;	state Exp;
branches;
next	1.247;

1.247
date	2000.10.09.15.34.52;	author mud;	state Exp;
branches;
next	1.246;

1.246
date	2000.10.09.15.25.25;	author mud;	state Exp;
branches;
next	1.245;

1.245
date	2000.10.09.14.44.21;	author mud;	state Exp;
branches;
next	1.244;

1.244
date	2000.10.09.03.15.33;	author mud;	state Exp;
branches;
next	1.243;

1.243
date	2000.10.08.22.52.21;	author mud;	state Exp;
branches;
next	1.242;

1.242
date	2000.10.08.19.11.20;	author mud;	state Exp;
branches;
next	1.241;

1.241
date	2000.10.08.18.30.17;	author mud;	state Exp;
branches;
next	1.240;

1.240
date	2000.09.30.14.29.33;	author mud;	state Exp;
branches;
next	1.239;

1.239
date	2000.09.27.17.02.50;	author mud;	state Exp;
branches;
next	1.238;

1.238
date	2000.09.25.02.35.55;	author mud;	state Exp;
branches;
next	1.237;

1.237
date	2000.09.24.22.39.02;	author mud;	state Exp;
branches;
next	1.236;

1.236
date	2000.09.24.22.32.39;	author mud;	state Exp;
branches;
next	1.235;

1.235
date	2000.09.24.20.45.53;	author mud;	state Exp;
branches;
next	1.234;

1.234
date	2000.09.24.20.31.35;	author mud;	state Exp;
branches;
next	1.233;

1.233
date	2000.09.24.20.26.09;	author mud;	state Exp;
branches;
next	1.232;

1.232
date	2000.09.24.20.04.40;	author mud;	state Exp;
branches;
next	1.231;

1.231
date	2000.09.24.19.09.02;	author mud;	state Exp;
branches;
next	1.230;

1.230
date	2000.09.24.18.41.39;	author mud;	state Exp;
branches;
next	1.229;

1.229
date	2000.09.24.16.40.15;	author mud;	state Exp;
branches;
next	1.228;

1.228
date	2000.09.24.16.31.59;	author mud;	state Exp;
branches;
next	1.227;

1.227
date	2000.09.10.18.24.33;	author mud;	state Exp;
branches;
next	1.226;

1.226
date	2000.09.10.18.11.41;	author mud;	state Exp;
branches;
next	1.225;

1.225
date	2000.09.10.17.38.08;	author mud;	state Exp;
branches;
next	1.224;

1.224
date	2000.09.10.17.34.16;	author mud;	state Exp;
branches;
next	1.223;

1.223
date	2000.09.08.05.14.57;	author mud;	state Exp;
branches;
next	1.222;

1.222
date	2000.09.08.05.06.00;	author mud;	state Exp;
branches;
next	1.221;

1.221
date	2000.09.08.05.00.59;	author mud;	state Exp;
branches;
next	1.220;

1.220
date	2000.09.08.04.49.27;	author mud;	state Exp;
branches;
next	1.219;

1.219
date	2000.09.06.00.44.38;	author mud;	state Exp;
branches;
next	1.218;

1.218
date	2000.09.04.20.48.44;	author mud;	state Exp;
branches;
next	1.217;

1.217
date	2000.08.29.03.51.56;	author mud;	state Exp;
branches;
next	1.216;

1.216
date	2000.08.27.23.23.07;	author mud;	state Exp;
branches;
next	1.215;

1.215
date	2000.08.26.02.05.58;	author mud;	state Exp;
branches;
next	1.214;

1.214
date	2000.08.25.19.43.05;	author mud;	state Exp;
branches;
next	1.213;

1.213
date	2000.08.19.22.29.02;	author mud;	state Exp;
branches;
next	1.212;

1.212
date	2000.08.19.21.56.27;	author mud;	state Exp;
branches;
next	1.211;

1.211
date	2000.08.18.23.00.40;	author mud;	state Exp;
branches;
next	1.210;

1.210
date	2000.08.18.22.49.03;	author mud;	state Exp;
branches;
next	1.209;

1.209
date	2000.07.24.00.29.35;	author mud;	state Exp;
branches;
next	1.208;

1.208
date	2000.07.21.23.45.27;	author mud;	state Exp;
branches;
next	1.207;

1.207
date	2000.07.18.23.00.12;	author mud;	state Exp;
branches;
next	1.206;

1.206
date	2000.07.18.22.47.05;	author mud;	state Exp;
branches;
next	1.205;

1.205
date	2000.07.18.22.45.02;	author mud;	state Exp;
branches;
next	1.204;

1.204
date	2000.07.11.23.26.44;	author mud;	state Exp;
branches;
next	1.203;

1.203
date	2000.06.29.02.04.35;	author mud;	state Exp;
branches;
next	1.202;

1.202
date	2000.06.28.16.25.22;	author mud;	state Exp;
branches;
next	1.201;

1.201
date	2000.06.28.02.59.41;	author mud;	state Exp;
branches;
next	1.200;

1.200
date	2000.06.28.02.53.18;	author mud;	state Exp;
branches;
next	1.199;

1.199
date	2000.06.28.02.37.57;	author mud;	state Exp;
branches;
next	1.198;

1.198
date	2000.06.27.04.21.40;	author mud;	state Exp;
branches;
next	1.197;

1.197
date	2000.06.27.03.52.49;	author mud;	state Exp;
branches;
next	1.196;

1.196
date	2000.06.23.02.11.06;	author mud;	state Exp;
branches;
next	1.195;

1.195
date	2000.06.23.02.03.19;	author mud;	state Exp;
branches;
next	1.194;

1.194
date	2000.06.21.21.37.08;	author mud;	state Exp;
branches;
next	1.193;

1.193
date	2000.06.19.22.25.20;	author mud;	state Exp;
branches;
next	1.192;

1.192
date	2000.06.18.22.51.58;	author mud;	state Exp;
branches;
next	1.191;

1.191
date	2000.06.18.22.47.11;	author mud;	state Exp;
branches;
next	1.190;

1.190
date	2000.06.18.21.24.07;	author mud;	state Exp;
branches;
next	1.189;

1.189
date	2000.06.17.20.10.27;	author mud;	state Exp;
branches;
next	1.188;

1.188
date	2000.06.17.19.02.44;	author mud;	state Exp;
branches;
next	1.187;

1.187
date	2000.05.27.02.44.12;	author mud;	state Exp;
branches;
next	1.186;

1.186
date	2000.05.26.01.04.20;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	2000.05.25.23.50.21;	author mud;	state Exp;
branches;
next	1.184;

1.184
date	2000.05.25.23.47.30;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2000.05.25.01.55.56;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	2000.05.25.01.15.18;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	2000.05.24.22.27.29;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	2000.05.24.22.23.57;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	2000.05.24.22.14.21;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	2000.05.24.22.08.07;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	2000.05.24.19.44.13;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	2000.05.24.19.40.52;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	2000.05.21.02.35.10;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	2000.05.21.02.33.58;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	2000.05.21.02.31.54;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	2000.05.19.13.46.56;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	2000.05.19.13.44.01;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	2000.05.16.15.01.31;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	2000.05.14.00.32.50;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	2000.04.18.19.51.02;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	2000.04.17.00.40.46;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	2000.04.17.00.36.53;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	2000.04.16.23.58.58;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	2000.04.16.23.12.19;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	2000.04.16.16.09.57;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	2000.04.16.15.31.37;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	2000.04.15.13.20.52;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	2000.04.14.23.01.06;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	2000.04.14.22.59.33;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	2000.04.14.22.58.14;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	2000.03.27.05.27.42;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	2000.03.20.14.59.01;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	2000.03.14.15.10.12;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	2000.03.08.14.09.51;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	2000.03.02.02.00.16;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	2000.03.02.01.31.06;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	2000.03.02.01.15.33;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	2000.02.27.00.59.56;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	2000.02.23.19.52.01;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	2000.02.23.17.59.32;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	2000.02.19.18.50.40;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	2000.02.15.15.13.10;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	2000.02.13.18.49.16;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	2000.02.13.18.12.03;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	2000.02.13.17.48.01;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	2000.02.13.16.21.34;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	2000.02.12.16.05.45;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	2000.02.05.15.30.12;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	2000.02.05.15.14.45;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	2000.02.05.15.03.34;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	2000.02.05.01.34.23;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	2000.01.21.19.56.18;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	2000.01.21.01.13.50;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	2000.01.21.01.11.30;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	2000.01.21.00.53.19;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	2000.01.08.07.31.26;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	2000.01.08.06.35.43;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	99.10.19.18.18.04;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	99.10.17.22.07.41;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	99.10.17.20.33.58;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	99.10.15.23.47.06;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	99.10.15.23.32.52;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	99.10.15.23.13.32;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	99.10.15.23.06.15;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	99.10.15.22.57.20;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	99.10.15.22.40.55;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	99.10.15.21.27.22;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	99.10.15.20.37.11;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	99.10.15.20.29.38;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	99.10.15.02.30.42;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	99.10.15.01.37.51;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	99.10.15.01.31.59;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	99.10.15.01.27.08;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	99.10.15.01.17.32;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	99.10.15.00.48.31;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	99.10.15.00.31.02;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	99.10.13.23.38.41;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	99.10.04.21.52.33;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	99.10.02.02.36.28;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	99.10.02.02.31.06;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	99.10.02.00.18.17;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	99.10.02.00.15.25;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	99.10.02.00.09.09;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	99.09.21.00.49.55;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	99.09.18.08.50.02;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	99.09.18.08.44.15;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	99.09.18.08.07.07;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	99.08.29.14.41.00;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	99.08.23.03.34.47;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	99.08.21.07.29.09;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	99.08.21.07.09.41;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	99.08.18.01.37.19;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	99.08.13.18.48.36;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	99.08.11.04.55.51;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	99.08.03.04.27.31;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.07.29.18.47.48;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.07.14.18.13.58;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.07.11.19.09.23;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.07.05.18.11.38;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.07.05.18.07.31;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.07.05.18.02.18;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.07.05.18.00.50;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.07.05.17.54.47;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.07.05.17.51.36;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	99.07.05.17.43.57;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	99.07.05.17.34.05;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	99.07.05.02.24.57;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	99.06.27.06.05.24;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.06.17.15.36.11;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.06.12.00.34.00;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	99.06.11.23.21.55;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	99.05.22.21.44.16;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	99.05.20.03.27.05;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	99.05.19.04.31.57;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	99.05.18.18.59.56;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	99.05.18.18.49.55;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	99.05.18.18.18.56;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	99.05.17.21.26.04;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	99.05.17.21.22.47;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	99.05.17.21.13.24;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	99.05.17.06.26.27;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	99.05.17.03.47.44;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	99.05.16.06.59.10;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	99.05.16.06.17.40;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	99.05.16.06.08.15;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	99.05.16.05.48.33;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.05.16.05.40.26;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.05.16.05.00.22;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.05.16.04.50.19;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.05.16.04.27.47;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.05.16.00.51.12;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.05.16.00.40.02;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.05.16.00.37.07;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.05.16.00.17.43;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.05.15.23.34.33;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.05.15.23.27.59;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.05.15.22.27.22;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.05.15.21.56.42;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.05.03.08.00.19;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.04.07.18.38.38;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.03.31.01.37.46;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.03.31.01.27.22;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.03.26.19.58.53;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.03.26.03.39.21;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.03.15.14.57.07;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.03.14.21.41.38;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.03.14.21.22.23;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	99.03.14.21.19.19;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.03.14.20.15.26;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.03.14.20.10.03;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.03.04.20.12.53;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	99.01.12.20.53.20;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.01.12.20.24.29;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	99.01.09.15.41.12;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	99.01.05.15.40.24;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	99.01.03.03.45.06;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	98.12.31.21.16.34;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.12.31.20.45.00;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.12.31.20.40.26;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.12.31.20.25.11;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.12.23.16.51.35;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.12.09.08.32.17;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.12.08.23.12.09;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.12.08.22.38.13;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.12.08.08.42.38;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.11.29.22.26.22;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.11.28.07.49.35;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.11.22.10.36.37;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.11.22.08.14.41;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.11.22.02.05.15;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.11.21.02.51.12;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.11.15.09.29.35;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.10.15.23.06.01;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.10.10.02.26.08;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.10.09.20.15.17;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.10.08.22.19.57;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.10.05.09.10.26;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.10.01.22.53.41;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.10.01.22.50.53;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.30.03.33.37;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.20.21.05.34;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.17.20.05.01;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.15.18.45.49;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.02.15.26.27;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.02.14.30.35;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.01.13.03.28;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.37;	author mud;	state Exp;
branches;
next	;


desc
@@


1.438
log
@Message to caster on success in cone of silence
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: mag2.c,v 1.437 2004/10/24 19:25:18 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include "merc.h"
#include "magic.h"
#include "tables.h"
#include "gladiator.h"
#include "lookup.h"

DECLARE_DO_FUN(action_wraithform);
DECLARE_DO_FUN(action_zealot_convert);
DECLARE_DO_FUN(do_look);
DECLARE_DO_FUN(do_scan);
DECLARE_DO_FUN(do_morph);
DECLARE_DO_FUN(do_shapemorph);
DECLARE_DO_FUN(do_shapeshift);

extern char *target_name;

int find_door args( ( CHAR_DATA *ch, char *arg ) );
bool  has_key   args( ( CHAR_DATA *ch, int key ) );
extern sh_int rev_dir [];
void  remove_all_objs  args( (CHAR_DATA *ch) );              
void  shapeshift_remove args ((CHAR_DATA *ch));
void  wear_obj  args( (CHAR_DATA *ch, OBJ_DATA *obj, bool fReplace ) );


void spell_restore_mana(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
   CHAR_DATA *victim = (CHAR_DATA *) vo;
   int restore = 0;

   restore = dice( level , 2 );
   victim->mana = UMIN( victim->mana + restore, victim->max_mana );
   act("You feel energized.",victim,NULL,NULL,TO_CHAR,FALSE);
   act("$n appears energized.",victim,NULL,NULL,TO_ROOM,FALSE);
   return;
}

void spell_speed(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(ch, skill_lookup("arcantic alacrity") ) )
    {
        send_to_char("Don't be a fucknut.  Bug abuse is bad, mmmkay?\n\r",ch);
        return;
    }

    if ( IS_AFFECTED( victim, AFF_HASTE ) )
    {
	if ( victim == ch )
		send_to_char("You are already moving as fast as you can.\n\r",ch);
	else
		act("$N is already hasted.",ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }
    if ( is_affected( victim, sn ) )
    {
	send_to_char("Your motions begin to speed up.\n\r",victim);
	if ( victim != ch )
	  act("$N's motions begin to speed up.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,level/17,level);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= level/17;
    af.modifier 	= 0;
    af.location		= 0;
    af.bitvector	= 0; 
    affect_to_char( victim, &af );

    send_to_char("Your motions begin to speed up.\n\r",victim);
    if ( victim != ch )
	act("$N's motions begin to speed up.",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}
void spell_cone_of_silence(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{

    CHAR_DATA *victim = (CHAR_DATA *) vo;
    OBJ_DATA *stone;
    AFFECT_DATA af;
    int skill;
    int currentLevel;

    if ((skill = get_skill(ch,gsn_cone_of_silence)) < 2 ) 
    {
      send_to_char("You try to silence the voices in your head.\r\n",ch);
      return;
    }
    stone = get_eq_char(ch,WEAR_HOLD);
    if (stone == NULL || stone->pIndexData->vnum != VNUM_SPELLCOMP_SILENCE  )
    {
        send_to_char("You lack the proper component to cast this spell.\n\r",ch);
        return;
    }
    if ( is_affected(victim, skill_lookup("cone of silence") ) )
    {
        send_to_char("How much more silence do you want to have?\n\r",ch);
        return;
    }
    if ( victim == ch )
    {
      send_to_char("If you want to be quiet, don't say anything.\r\n",ch);
      return;
    }
    currentLevel = ch->level;
    if ( number_range(1,10) == 4 )
    {
      send_to_char("A ball gag flares {Wbrightly{x and {YVANISHES{x!!!",ch);
      extract_obj(stone);
    }

    if ( number_percent() > get_skill(ch,gsn_cone_of_silence) - number_range(10,30) )
    {
        act("$n asks $N for some quiet and fails!", ch, NULL, victim, TO_ROOM, FALSE);
        act("$n chants and mumbles something about quiet.  You feel a brief tingling senstaion.",ch,NULL,victim,TO_VICT,FALSE);
        act("You failed to wrap $N in a Cone of Silence.", ch, NULL, victim, TO_CHAR, FALSE);
       //failed
       check_improve(ch,gsn_cone_of_silence,FALSE,8);
       if ( number_percent() < number_range(1,10) )
       {
         send_to_char("{YBACKLASH!!! Your cone of silence hits YOU!!!{x\r\n",ch);
         act("$n is enveloped in a cone of silence.",ch,NULL,victim,TO_ROOM,FALSE);
	 act("$n is enveloped in a cone of silence.",ch,NULL,victim,TO_CHAR,FALSE);
         af.where            = TO_AFFECTS;
         af.type             = sn;
         af.level            = level;
         af.duration         = number_range(2,4);
         af.modifier         = 0;
         af.location         = 0;
         af.bitvector        = 0;
         affect_to_char( ch, &af );
         send_to_char("The silence is deafening to your ears.\n\r",ch);
       } 
       return;
    }
    check_improve(ch,gsn_cone_of_silence,TRUE,6);

    if ( !saves_spell(level,victim,DAM_MENTAL) )
    {
      
      af.where            = TO_AFFECTS;
      af.type             = sn;
      af.level            = level;
      af.duration         = number_range(1,5);
      af.modifier         = 0;
      af.location         = 0;
      af.bitvector        = 0;
      affect_to_char( victim, &af );
      send_to_char("The silence is deafening to your ears.\n\r",victim);
      if ( victim != ch )
      {
        act("$N looks confused and shrouded by silence.",ch,NULL,victim,TO_ROOM,FALSE);
	act("$N looks confused and shrouded by silence.",ch,NULL,victim,TO_CHAR,FALSE);
      }
    }
    return;
}
void spell_creeping_doom(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{

    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    if ( !IS_NPC(ch) && !IS_EVIL(ch) )
    {
        victim = ch;
        send_to_char("The spiders swarm all over you!\n\r", ch);
    }

    if (victim != ch)
    {
        act("$n unleashes a stream of biting, venomous spiders at $N!", ch,             NULL, victim, TO_ROOM, FALSE);
        act("$n unleashes a stream of biting, venomous spiders at you!",ch,             NULL, victim, TO_VICT, FALSE);
        send_to_char("You unleash a stream of venemous spiders at your foe!\n\r", ch);
    }

    dam = dice(level, 10);

    /* Damage gets better as caster alignment gets worse. */

    if (ch->alignment <= -500)
        dam += dam * .05;
    if (ch->alignment <= -750)
        dam += dam * .08;
    if (ch->alignment <= -950)
        dam += dam * .1;

    if (saves_spell(level, victim, DAM_POISON))
        dam /= 2;

    /* Now poison the poor spiderbitten fool */
    spell_poison(gsn_poison, 3*level/4, ch, (void *) victim,                        TARGET_CHAR);

    damage( ch, victim, dam, sn, DAM_POISON, TRUE, TRUE);

} 

void spell_magic_resistance(int sn, int level,CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
	send_to_char("You are protected from magic.\n\r",victim);
	if ( victim != ch )
	  act("$N is protected from magic.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,24+level/4,level);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= level/10;
    af.modifier		= 0; 
    af.location		= 0;
    af.bitvector	= 0;
    affect_to_char( victim, &af );

    send_to_char("You are protected from magic.\n\r",victim);
    if ( victim != ch )
	act("$N is protected from magic.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}

void spell_vision(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
	send_to_char("You are bestowed with the gift of vision.\n\r",victim);
	if ( victim != ch )
	  act("$N is betstowed with the gift of vision.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,25,level);
	return;
    }

    af.where			= TO_AFFECTS;
    af.type		 	= sn;
    af.level			= level;
    af.duration			= 25;
    af.modifier			= 0;
    af.location			= 0;
    af.bitvector		= AFF_DETECT_INVIS;
    affect_to_char( victim, &af );
    af.bitvector		= AFF_DETECT_HIDDEN;
    affect_to_char( victim, &af );
    af.bitvector		= AFF_DETECT_MAGIC;
    affect_to_char( victim, &af );

    send_to_char("You are bestowed with the gift of vision.\n\r",victim);
    if ( victim != ch )
	act("$N is betstowed with the gift of vision.",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}

void spell_accuracy(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
	send_to_char("Your accuracy is vastly improved.\n\r",victim);
	if ( victim != ch )
	  act("$N is able to hit more often.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,1+level/10,level);
	return;
    }

    af.where	= TO_AFFECTS;
    af.type	= sn;
    af.level	= level;
    af.duration	= level/10 +1 ;
    af.modifier	= victim->hitroll / 2;
    af.location = APPLY_HITROLL;
    af.bitvector = 0;

    affect_to_char( victim, &af );
    send_to_char("Your accuracy is vastly improved.\n\r",victim);
    if ( victim != ch )
	act("$N is able to hit more often.",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}

/* Attempt at call mount spell for knight kit started 23-AUG-00 */
void spell_call_mount(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{ /* start curley brace for spell_call_mount */
   CHAR_DATA *victim;
   int t,count;


/* Not going to allow highlanders to have mounts 
   if (IS_SET(ch->mhs,MHS_HIGHLANDER))
     {
     send_to_char("Honorable combat is one on one. Highlanders can not ride warhorses.\n\r",ch);
     return;
     }
   if(IS_SET(ch->mhs,MHS_GLADIATOR))
     {
     send_to_char("Gladiators can not ride warhorses.\n\r",ch);
     return;
     }
     */

/* This next part looks like it checks to see if they already have a warhorse */
   count =0;
   for ( victim = char_list; victim != NULL; victim = victim->next )
      if ( (is_same_group( victim, ch ) && IS_SET(victim->mhs,MHS_WARHORSE))
      || (is_same_group(victim->master,ch) && IS_SET(victim->mhs,MHS_WARHORSE)))
         {
            count++;
         }
      if ( count >= 1 && !IS_IMMORTAL(ch))
         {
         send_to_char("Just how many horses can you ride?  One's plenty.\n\r",ch);
	 return;
         }
      victim = create_mobile(get_mob_index(MOB_VNUM_WARHORSE));
      act("The neighing of a horse gets your attention.",ch,NULL,victim,TO_ROOM,FALSE);
      act("You call forth a magestic warhorse.",ch,NULL, victim,TO_CHAR,FALSE);

      char_to_room (victim,ch->in_room);
      victim->size = UMAX(pc_race_table[ch->race].size + 1,SIZE_GIANT);
      victim->level = level * 3/4;

      for (t = 0; t < 3; t++)
      victim->armor[t] = interpolate(victim->level,50,-50);
      victim->armor[3] = interpolate(victim->level,0,-50);
      /* hmmm, this is weird
      victim->max_hit = level * 2 + number_range(level * level / 9, level * level/5 );
      victim->max_hit = UMAX( victim->max_hit, ch->max_hit * 2 / 4);
      */
      victim->hit = level * 13;
      victim->max_hit = level * 13;

      victim->max_mana = 100;
      victim->mana = 100;
      /*06SEP00 - Taken out by me to try somthing different
      victim->max_move = level * 5 + number_range(level * level / 9, level * level/5 );
      victim->max_move = UMAX( victim->max_move,ch-max_move * 3 / 4);
      */
      victim->move = level * 9;
      victim->max_move = level * 9; 

      victim->damage[DICE_NUMBER] = victim->level/5+1;
      victim->damage[DICE_TYPE]   = 5;
      victim->hitroll = victim->level * 3 / 5;
      victim->damroll = victim->level * 3 / 5;
      SET_BIT (victim->mhs,MHS_WARHORSE); /* just to make sure */
      add_follower( victim, ch );
      victim->leader = ch;
/*make that monkey follow the player */ 
      ch->pet = victim; 

      SET_BIT(victim->form,FORM_INSTANT_DECAY);
      SET_BIT(victim->affected_by,AFF_CHARM); /* quick-charm */
      /* Timer modified 28AUG00 by Boogums */
      victim->life_timer = ch->level*2;

      return;
} /* there goes the end curley brace for spell_call_mount */

void spell_summon_elemental(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
   CHAR_DATA *victim;
   AFFECT_DATA af;
   OBJ_DATA *segment;
   int t,count, number;

   number = number_percent(); 

   if ( is_affected(ch,skill_lookup("wound transfer")) )
	return;

   if (IS_SET(ch->mhs,MHS_HIGHLANDER))
   {
      send_to_char("Honorable combat is one on one. Highlanders can not summon elementals.\n\r",ch);
      return;
   }

   if(IS_SET(ch->mhs,MHS_GLADIATOR))
   {
      send_to_char("Gladiators can not summon elementals.\n\r",ch); 
      return;
   }


   count =0;
   for ( victim = char_list; victim != NULL; victim = victim->next )
      if ( (is_same_group( victim, ch ) && IS_SET(victim->mhs,MHS_ELEMENTAL))
   || (is_same_group(victim->master,ch) && IS_SET(victim->mhs,MHS_ELEMENTAL)))
      count++;

   if ( count >= 1 && !IS_IMMORTAL(ch))
   {
   send_to_char("You are already controlling as many elementals as you can handle\n\r",ch);
   return;
   }
      
   if((segment = get_eq_char(ch, WEAR_HOLD)) != NULL)
   switch(segment->pIndexData->vnum)
   {
   case VNUM_FIRE_SEGMENT:
	level += 5;
	number = 76;
	break;
   case VNUM_WATER_SEGMENT:
	level += 5;
	number = 51;
	break;
   default: 
     number = number_percent();
     break;
   }

   if (number < 3)
   {
      victim = create_mobile(get_mob_index(MOB_VNUM_ELEM_SPIRIT));
act("A shining hole opens to the Elemental Plane of Spirit.",
	ch,NULL,victim,TO_ROOM,FALSE);
act("You summon an elemental from the Elemental Plane of Spirit.",
	ch,NULL, victim,TO_CHAR,FALSE);
      if ( !(IS_SET(ch->res_flags, RES_MAGIC)))
      {
         af.where     = TO_RESIST;
         af.type      = sn;
         af.level     = level;
         af.duration  = level / 5;
	 af.location  = APPLY_NONE;
         af.modifier  = 0;
         af.bitvector = RES_MAGIC;
         affect_to_char( ch, &af );
      }
   }
   else if (number < 5)
   {
      victim = create_mobile(get_mob_index(MOB_VNUM_ELEM_ENERGY));
act("A shining hole opens to the Elemental Plane of Energy.",
	ch,NULL,victim,TO_ROOM,FALSE);
act("You summon an elemental from the Elemental Plane of Energy.",
	ch,NULL, victim,TO_CHAR,FALSE);

      if ( !(IS_SET(ch->res_flags, RES_WEAPON)))
      {
         af.where     = TO_RESIST;
         af.type      = sn;
         af.level     = level;
         af.duration  = level / 5;
         af.location  = APPLY_NONE;
	 af.modifier  = 0;
         af.bitvector = RES_WEAPON;
	 affect_to_char( ch, &af );
      }
   } 
   else if (number < 25)
   {
      victim = create_mobile(get_mob_index(MOB_VNUM_ELEM_AIR));
act("A shining hole opens to the Elemental Plane of Air.",
	ch,NULL,victim,TO_ROOM,FALSE);
act("You summon an elemental from the Elemental Plane of Air.",
	ch,NULL, victim,TO_CHAR,FALSE);
   }
   else if (number < 50)
   {
      victim = create_mobile(get_mob_index(MOB_VNUM_ELEM_EARTH));
act("A shining hole opens to the Elemental Plane of Earth.",
	ch,NULL,victim,TO_ROOM,FALSE);
act("You summon an elemental from the Elemental Plane of Earth.",
	ch,NULL, victim,TO_CHAR,FALSE);
   }
   else if (number < 75)
   {
      victim = create_mobile(get_mob_index(MOB_VNUM_ELEM_WATER));
act("A shining hole opens to the Elemental Plane of Water.",
	ch,NULL,victim,TO_ROOM,FALSE);
act("You summon an elemental from the Elemental Plane of Water.",
	ch,NULL, victim,TO_CHAR,FALSE);
   }
   else
   {
      victim = create_mobile(get_mob_index(MOB_VNUM_ELEM_FIRE));
act("A shining hole opens to the Elemental Plane of Fire.",
	ch,NULL,victim,TO_ROOM,FALSE);
act("You summon an elemental from the Elemental Plane of Fire.",
	ch,NULL, victim,TO_CHAR,FALSE);
  } 

   char_to_room (victim,ch->in_room);
   victim->level = level * 9/10;
   for (t = 0; t < 3; t++)
      victim->armor[t] = interpolate(victim->level,50,-150);
   victim->armor[3] = interpolate(victim->level,0,-100);
  victim->max_hit = level * 9 + number_range(level * level / 9, level * level );
   victim->max_hit = UMAX( victim->max_hit, ch->max_hit * 3 /4);
   victim->hit = victim->max_hit;
   victim->max_mana = 100;
   victim->mana = 100;
   victim->damage[DICE_NUMBER] = victim->level/5+1;
   victim->damage[DICE_TYPE]   = 6;
   victim->hitroll = victim->level * 4 / 5;
   victim->damroll = victim->level * 4 / 5;
   SET_BIT (victim->mhs,MHS_ELEMENTAL); /* just to make sure */

   add_follower( victim, ch );
   victim->leader = ch;
   SET_BIT(victim->form,FORM_INSTANT_DECAY);
   SET_BIT(victim->affected_by,AFF_CHARM); /* quick-charm */
   victim->life_timer = ch->level/8+18;

}

/*
void spell_scion_storm(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_ADTA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( dice(4,8) < get_curr_stat(victim,STAT_INT) )
	return;

    af.where		= 0;
    af.type		= sn;
    af.level		= level;
    af.duration		= 1; 
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector	= 0;
    affect_to_char( victim, &af );

act("You stagger beneath the mental assault.",ch,NULL,victim,TO_VICT,FALSE);
act("$N staggers beneath your psionic assault!",ch,NULL,victim,TO_CHAR,FALSE);
act("$N staggers beneath the psionic assault.",ch,NULL,victim,TO_NOTVICT,FALSE);
   return;
   }
*/
   
void spell_imbue(int sn,int level,CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
	send_to_char("The gods imbue you with enhanced casting.\n\r",victim);
	reup_affect(victim,sn,24+level/4,level);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= 5 + (level / 5);
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector	= 0;
    affect_to_char( victim, &af );

    send_to_char("The gods imbue you with enhanced casting.\n\r",victim);
    return;
}

void spell_wrath(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if( IS_NPC(ch) )
	return;

    if ( number_percent() > ch->pcdata->sac / 3 )
    {
	send_to_char("You fail to invoke the anger of your deity.\n\r",ch);
	return;
    }

    ch->pcdata->sac = ( UMAX( 0, ch->pcdata->sac - dice(2,4 ) ) );
    
    dam = ( ch->pcdata->sac * level );
    dam /= ( 100 - (get_skill(ch,gsn_communion)/4) );

    if ( is_affected(victim,sn) )
	dam *= 2;

    if ( saves_spell(level,victim,DAM_OTHER) )
	dam /= 2;

    dam = number_range( 90,100 ) * dam / 100;

    damage(ch,victim,dam,sn,DAM_OTHER,TRUE,TRUE);

    if ( saves_spell(level,victim,DAM_OTHER) )
	return;

    af.where 		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.modifier 	= 0;
    af.duration		= 0;
    af.location		= 0;
    af.bitvector	= 0;
    affect_to_char(victim,&af);

    return;
}

/* mostly a cut an paste of do_pick */
void spell_knock(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *obj;
    EXIT_DATA *pexit;
    char arg[MAX_INPUT_LENGTH];
    int door;

    one_argument( target_name,  arg );
    log_string( arg );

    if ( arg[0] == '\0' )
    {
    send_to_char( "What do you wish to knock open?\n\r", ch );
	return;
    }

    if ( ( obj = get_obj_here( ch, arg ) ) != NULL )
    {	     
	/* 'pick object' */
    if ( obj->item_type != ITEM_CONTAINER )         
        { send_to_char( "That isn't a container.\n\r", ch ); return; }
	if ( !IS_SET(obj->value[1], CONT_CLOSED) )
	    { send_to_char( "It's not closed.\n\r",        ch ); return; }
	if ( obj->value[2] < 0 )
	    { send_to_char( "It can't be unlocked.\n\r",   ch ); return; }
	if ( !IS_SET(obj->value[1], CONT_LOCKED) )
	    { send_to_char( "It's already unlocked.\n\r",  ch ); return; }
	if ( IS_SET(obj->value[1], CONT_PICKPROOF) )
	    { send_to_char( "You failed.\n\r",             ch ); return; }

	REMOVE_BIT(obj->value[1], CONT_LOCKED);
        act("You knock open $p!",ch,obj,NULL,TO_CHAR,FALSE);
        act("$n knocks open $p.",ch,obj,NULL,TO_ROOM,FALSE);
	return;
    }

    if ( ( door = find_door( ch, arg ) ) >= 0
    	&& (pexit=ch->in_room->exit[door]) != 0)
    {
	/* 'pick door' */
	ROOM_INDEX_DATA *to_room;
	EXIT_DATA *pexit_rev;

    if ( !IS_SET(pexit->exit_info, EX_CLOSED) && !IS_IMMORTAL(ch))
    { send_to_char( "It's not closed.\n\r",        ch ); return; }
    if ( pexit->key < 0 && !IS_IMMORTAL(ch))
	    { send_to_char( "It can't be picked.\n\r",     ch ); return; }
	if ( !IS_SET(pexit->exit_info, EX_LOCKED) )
	    { send_to_char( "It's already unlocked.\n\r",  ch ); return; }
    if ( IS_SET(pexit->exit_info, EX_PICKPROOF) && !IS_IMMORTAL(ch))
	    { send_to_char( "You failed.\n\r",ch ); return; }

	REMOVE_BIT(pexit->exit_info, EX_LOCKED);
    send_to_char( "You knock the door open!\n\r", ch );
    act( "$n knocks the $d open!", ch, NULL, pexit->keyword, TO_ROOM ,FALSE);

	/* pick the other side */
	if ( ( to_room   = pexit->u1.to_room            ) != NULL
	&& ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
	&&   pexit_rev->u1.to_room == ch->in_room )
	{
	    REMOVE_BIT( pexit_rev->exit_info, EX_LOCKED );
	}
    }

    return;
}

void spell_enervation(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( saves_spell(level,victim,DAM_NEGATIVE) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if ( is_affected( victim, sn ) )
    {
	send_to_char("Your magical prowess wavers and falters.\n\r",victim);
	if ( victim != ch )
	  act("$N's magical ability falters.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,2+level/10,level);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= (level/10) + 2;
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector		= 0;
    affect_to_char(victim, &af );

    send_to_char("Your magical prowess wavers and falters.\n\r",victim);
    if ( victim != ch )
	act("$N's magical ability falters.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}

void spell_fumble(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) || saves_spell(level-1,victim,DAM_OTHER) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= (level / 5);
    af.modifier		= -1 * (level / 10 );
    af.location		= APPLY_DEX;
    af.bitvector	= 0;
    affect_to_char( victim, &af );

    send_to_char("You feel awkward.\n\r",victim);

    if ( victim != ch )
    {
	act("$N stumbles clumsily.",ch,NULL,victim,TO_CHAR,FALSE);
    }

    if( is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_fumble(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_feeblemind(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) || saves_spell(level,victim,DAM_MENTAL) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= (level/12);
    af.modifier		= -1 * (level/8);
    af.location		= APPLY_INT;
    af.bitvector	= 0;
    affect_to_char( victim, &af );

    send_to_char("Your willpower and intellect flicker and fade.\n\r",victim);
    if ( victim != ch )
	act("$N's willpower fades away.",ch,NULL,victim,TO_CHAR,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_feeblemind(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_forget(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) || saves_spell(level,victim,DAM_MENTAL) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= (level/12);
    af.modifier		= 0;
    af.location		= 0;
    af.bitvector	= 0;
    affect_to_char( victim, &af );

    send_to_char("Your skills feel unpracticed and unfamiliar.\n\r",victim);
    if ( victim != ch )
	act("$N appears to have forgotten something.",
		ch, NULL, victim, TO_CHAR,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_forget(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_blur(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
	send_to_char("Your form begins to blur and shift.\n\r",victim);
	if ( victim != ch )
	  act("$N begins to blur and shift before your eyes.",
	      ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,level/5,level);
	return;
    }



    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= (level / 5 );
    af.location		= APPLY_AC;
    af.modifier		= -20;
    af.bitvector	= 0;
    affect_to_char( victim, &af );

    send_to_char("Your form begins to blur and shift.\n\r",victim);
    if ( victim != ch )
	act("$N begins to blur and shift before your eyes.",
		ch,NULL,victim,TO_CHAR,FALSE);
    return;
}

void spell_hold_person(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if( ch->fighting != NULL || victim->fighting != NULL)
      {
        send_to_char("Things need to be calmer.\n\r",ch);
        return;
      }

    if(IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_NPC(victim))
    {
       send_to_char("Highlanders are immune to that.\n\r",ch);
       return;
    }
 
    level = UMIN(ch->level, level);

    if ( is_affected( victim, sn ) ||
	saves_spell(level,victim,DAM_OTHER) ) 
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.location		= APPLY_DEX;
    af.modifier		= ( 3 - get_curr_stat(victim,STAT_DEX) );
    af.duration 	= 1 + (UMAX(0,level-51));
    af.bitvector	= 0;
    affect_to_char( victim, &af );

    victim->position = POS_RESTING;
    act("$N stops moving!",ch,NULL,victim,TO_NOTVICT,FALSE);
    send_to_char("Your muscles freeze and refuse to respond!\n\r",victim);
    if ( victim != ch )
	act("$N stops moving.",ch,NULL,victim,TO_CHAR,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_hold_person(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_endure_cold(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_SET(victim->vuln_flags,VULN_COLD)
       ||IS_SET(victim->imm_flags,IMM_COLD)
       ||IS_SET(victim->res_flags,RES_COLD))
    {
	if (ch != victim)
	   send_to_char("You can not cast this on them.\n\r",ch);
	else
	   send_to_char("You can not cast this on yourself.\n\r",ch);
	return;
    }

    af.where		= TO_RESIST;
    af.type		= sn;
    af.level		= level;
    af.location		= 0;
    af.modifier		= 0;
    af.duration		= (level / 5 ) + 2;
    af.bitvector	= RES_COLD;
    affect_to_char( victim, &af );

    send_to_char("Your body is able to endure cold.\n\r",victim);
    if ( victim != ch )
	act("$N is able to endure cold.",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}

void spell_sacred_guardian(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
	send_to_char("You are being watched by the gods.\n\r",victim);
	if ( victim != ch )
	  act("$N is being watched over by the gods.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,level/3,level);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= level / 3;
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector 	= 0;
    affect_to_char( victim, &af );

    send_to_char("You are being watched by the gods.\n\r",victim);
    if ( victim != ch )
      act("$N is being watched over by the gods.",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}

void spell_endure_heat(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_SET(victim->vuln_flags,VULN_FIRE)
       ||IS_SET(victim->imm_flags,IMM_FIRE)
       ||IS_SET(victim->res_flags,RES_FIRE))
    {
	if (ch != victim)
	   send_to_char("You can not cast this on them.\n\r",ch);
	else
	   send_to_char("You can not cast this on yourself.\n\r",ch);
	return;
    }

    af.where		= TO_RESIST;
    af.type		= sn;
    af.level		= level;
    af.modifier		= 0;
    af.location		= 0;
    af.duration		= (level / 5 ) + 2;
    af.bitvector	= RES_FIRE;
    affect_to_char( victim, &af );

    send_to_char("Your body is able to resist heat.\n\r",victim);
    if ( victim != ch )
	act("$N is able to resist heat.",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}

void spell_aid(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
	send_to_char("Your vitality is blessed by the gods.\n\r",victim);
	if ( victim != ch )
	  act("$N's vitality is blessed by the gods.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,(level/5)+5,level);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= (level / 5) + 5;
    af.location		= APPLY_HIT;
    af.modifier		= (victim->max_hit/(number_fuzzy(5)+number_fuzzy(5)));
    af.bitvector 	= 0;
    affect_to_char( victim, &af );

    send_to_char("Your vitality is blessed by the gods.\n\r",victim);
    if ( victim != ch )
      act("$N's vitality is blessed by the gods.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}  

void spell_bestow_holiness(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    AFFECT_DATA af;

    if ( obj->item_type != ITEM_WEAPON )
    {
	send_to_char("You can only bestow holiness on weapons.  Back to sunday school for you!.\n\r",ch);
	return;
    }
    if ( IS_WEAPON_STAT(obj,WEAPON_HOLY) )
    {
       send_to_char("Sorry, there are no Mega-Holy weapons.  It only takes one holy flag.\n\r",ch);
       return;
    }


    af.where		= TO_WEAPON;
    af.type		= sn;
    af.level		= level;
    af.location		= 0;
    if ( number_percent() == number_percent() )
    {
      if ( number_percent() >= number_percent() )
      {
        act("$p is consumed by the Gods and disappears!",ch,obj,NULL,TO_ROOM,FALSE);
        send_to_char("{RZOUNDS!!!{x Forsooth and {YYea Verily{x that was a little to much praying over the weapon.  It's toast now.\r\n", ch);
        extract_obj(obj);
        return;
      }
      else
      {
        send_to_char("{CPRAISE{x the maker!!!  This weapon can crush many foes!\r\n",ch);
        af.duration       = -1;
      }
    }
    else
    {
      af.duration		= obj->value[4] == 0 ? level / 2 : level / 4;
    }
    af.modifier 	= 0;
    af.bitvector	= WEAPON_HOLY;
    affect_to_obj( obj, &af );

    act("$p radiates with holiness.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$p radiates with holiness.",ch,obj,NULL,TO_ROOM,FALSE);
    return;
}

void spell_flamesword(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    AFFECT_DATA af;

    if (IS_WEAPON_STAT(obj,WEAPON_FLAMING))
    {
       send_to_char("This weapon can not get any hotter.\n\r",ch);
       return;
    }

    if ( obj->item_type != ITEM_WEAPON  )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    af.where      	= TO_WEAPON; 
    af.type	  	= sn;
    af.level		= level;
    af.duration		= obj->value[4] == 0 ? level / 3 : level / 6;  
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector	= WEAPON_FLAMING;
    affect_to_obj( obj, &af );

    af.where		= TO_AFFECTS;
    af.bitvector 	= 0;
    af.duration		= obj->value[4] == 0 ? level / 6 : level / 12;  
    af.location		= APPLY_CON;
    af.modifier		= -2;
    affect_to_char( ch, &af );

    act("$p flares brightly with an aura of fire.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$p flares brightly with an aura of fire.",ch,obj,NULL,TO_ROOM,FALSE);
    return;
}    

void spell_frostsword(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    AFFECT_DATA af;

    if ( obj->item_type != ITEM_WEAPON  )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if (IS_WEAPON_STAT(obj,WEAPON_FROST))
    {
       send_to_char("This weapon can not get any colder.\n\r",ch);
       return;
    }


    af.where      	= TO_WEAPON; 
    af.type	  	= sn;
    af.level		= level;
    af.duration		= obj->value[4] == 0 ? level / 3 : level / 6;  
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector	= WEAPON_FROST;
    affect_to_obj( obj, &af );

    af.where		= TO_AFFECTS;
    af.bitvector 	= 0;
    af.duration		= obj->value[4] == 0 ? level / 6 : level / 12;  
    af.location		= APPLY_CON;
    af.modifier		= -2;
    affect_to_char( ch, &af );

    act("$p freezes brightly with an aura of ice.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$p freezes brightly with an aura of ice.",ch,obj,NULL,TO_ROOM,FALSE);
    return;
}    

void spell_electricsword(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    AFFECT_DATA af;

    if ( obj->item_type != ITEM_WEAPON  )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if (IS_WEAPON_STAT(obj,WEAPON_SHOCKING))
    {
       send_to_char("This weapon can not hold more of a charge.\n\r",ch);
       return;
    }

    af.where      	= TO_WEAPON; 
    af.type	  	= sn;
    af.level		= level;
    af.duration		= obj->value[4] == 0 ? level / 3 : level / 6;  
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector	= WEAPON_SHOCKING;
    affect_to_obj( obj, &af );

    af.where		= TO_AFFECTS;
    af.bitvector 	= 0;
    af.duration		= obj->value[4] == 0 ? level / 6 : level / 12;  
    af.location		= APPLY_CON;
    af.modifier		= -2;
    affect_to_char( ch, &af );

act("$p sizzles brightly with an aura of lightning.",ch,obj,NULL,TO_CHAR,FALSE);
act("$p sizzles brightly with an aura of lightning.",ch,obj,NULL,TO_ROOM,FALSE);
    return;
}    

void spell_asphyxiate(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( is_affected( victim,sn ) )
    {
	send_to_char("That target is already suffocating.\n\r",ch);
	return;
    }

    if ( saves_spell(level,victim,DAM_OTHER) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    /* NAIL 'em! */
    dam = level + ( (ch->level > 20) * 3 ) 
		+ ( (ch->level > 35) * 3 )
		+ ( (ch->level > 50) * 3 );
    dam = dice(dam,12);

    damage(ch,victim,dam,sn,DAM_OTHER,TRUE,TRUE);

    if ( IS_AFFECTED(victim,AFF_HASTE) )
       affect_strip(victim,skill_lookup("haste"));

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= level / 6;
    af.modifier		= -4;
    af.location		= APPLY_DEX;
    af.bitvector	= AFF_SLOW;
    affect_to_char(victim,&af);

    act("$N gasps in pain as $S throat constricts!",
	ch,NULL,victim,TO_CHAR,FALSE);
    act("You gasp in pain as your throat constricts!",
	ch,NULL,victim,TO_VICT,FALSE);
    act("$N gasps in pain as $S throat constricts!",
	ch,NULL,victim,TO_NOTVICT,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_asphyxiate(sn,level+2,victim,ch,target);
    }   

    return;
}



void spell_create_node(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    if ( ch->in_room == NULL
      || IS_SET(ch->in_room->room_flags, ROOM_GODS_ONLY)    
      || IS_SET(ch->in_room->room_flags, ROOM_NODIE)    
      || IS_SET(ch->in_room->room_flags, ROOM_IMP_ONLY)
      || (ch->in_room->clan && ch->in_room->clan == ch->clan ))
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if (IS_NPC(ch))
	return;

    ch->pcdata->node = ch->in_room->vnum;
    send_to_char("Node created.\n\r",ch);
    act("An aura of magical energy lingers.",ch,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_mistform(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn))
    {
	if ( ch == victim )
	  act("Your body becomes insubstantial.",ch,NULL,NULL,TO_CHAR,FALSE);
	act("$n becomes insubstantial.",victim,NULL,NULL,TO_ROOM,FALSE);
	reup_affect(victim,sn,(level/2)+10,level);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.location		= APPLY_AC;
    af.duration		= level / 2 + 10;
    af.modifier		= ( -2 ) * ( level / 2 );   
    af.bitvector	= 0;

    affect_to_char(ch,&af);

    if ( ch == victim )
    act("Your body becomes insubstantial.",ch,NULL,NULL,TO_CHAR,FALSE);
    act("$n becomes insubstantial.", ch,NULL,NULL,TO_ROOM,FALSE);

    return;
}

void spell_visit_node(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    ROOM_INDEX_DATA *pRoom;

    if (IS_NPC(ch))
	return;

    if ( ch->pcdata->node == 0 )
    {
	send_to_char("You have no node available to visit.\n\r",ch);
	return;
    }

    if ( ( pRoom = get_room_index( ch->pcdata->node ) ) == NULL )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if ( IS_SET(pRoom->room_flags, ROOM_NOCLAN) 
    && (IS_SET(ch->mhs,MHS_HIGHLANDER)))
    {
       send_to_char("Highlander's can not visit nodes there.\n\r",ch);
       return;
    }

    ch->pcdata->node = 0;

    act("$n vanishes from sight!",ch,NULL,NULL,TO_ROOM,FALSE);
    char_from_room(ch);
    clear_mount( ch );
    stop_fighting(ch, TRUE );
    char_to_room(ch,pRoom);
    do_look(ch,"");
    act("$n materializes before you.",ch,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_rust_weapon(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    OBJ_DATA *obj;
    /*
    int material;
    */

    if(IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_NPC(victim))
    {
       send_to_char("Highlanders are immune to that.\n\r",ch);
       return;
    }

    if ( saves_spell(level,victim,DAM_OTHER) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }


    if ( (   obj  = get_eq_char(victim,WEAR_WIELD) ) == NULL )
    {
	send_to_char("Your opponent is not wielding anything.\n\r",ch);
	return;
    }

    if (    obj->item_type != ITEM_WEAPON ) /* just in case */
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    /* vorpal check, can't rust a vorpal */
    if ( IS_WEAPON_STAT(obj, WEAPON_VORPAL ) )
    {
	send_to_char( "You failed.\n\r", ch);
	return;
    }

/*
    material = material_lookup(obj->material);

    if ( !IS_SET(material_table[material].flags,MAT_VULN_RUST) )
    {
	send_to_char("You failed3.\n\r",ch);
	return;
    }
*/

if (
str_cmp(obj->material,"adamantanium") && 
str_cmp(obj->material,"adamantite") &&
str_cmp(obj->material,"adamantium") &&
str_cmp(obj->material,"adamite") &&
str_cmp(obj->material,"alloy") &&
str_cmp(obj->material,"aluminum") && 
str_cmp(obj->material,"brass") &&
str_cmp(obj->material,"bronze") &&
str_cmp(obj->material,"coins") &&
str_cmp(obj->material,"copper") &&
str_cmp(obj->material,"fools-gold") &&
str_cmp(obj->material,"gold") &&
str_cmp(obj->material,"iron") &&
str_cmp(obj->material,"lead") &&
str_cmp(obj->material,"metal") &&
str_cmp(obj->material,"mineral") &&
str_cmp(obj->material,"mithril") &&
str_cmp(obj->material,"nickel") &&
str_cmp(obj->material,"obsidian") &&
str_cmp(obj->material,"peweter") &&
str_cmp(obj->material,"pewter") &&
str_cmp(obj->material,"platinum") &&
str_cmp(obj->material,"silver") &&
str_cmp(obj->material,"stainless") && 
str_cmp(obj->material,"steel") &&
str_cmp(obj->material,"tin") &&
str_cmp(obj->material,"tinfoil") &&
str_cmp(obj->material,"titanium") && 
str_cmp(obj->material,"wire"))
    {
	send_to_char("Their weapon is not made out of metal.\n\r",ch);
	return;
    }

    if ( obj->enchanted )
	level -= 4;

    /* This spell is really mean, give 'em two saving throws */
    if ( saves_spell(level,victim,DAM_OTHER) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    /* Ok, that's that.  nail the weapon. */
    act("$p whithers and rusts away!",ch,obj,victim,TO_CHAR,FALSE);
    act("$p whithers and rusts away!",ch,obj,victim,TO_ROOM,FALSE);
    if ( obj->value[1] <= 0 )
       obj->value[2] = UMAX( 0, obj->value[2] - 1 );
    else
       obj->value[1] = UMAX( 0, obj->value[1] - 1 );

    return;
}

void spell_rust_armor(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    OBJ_DATA *obj, *obj_next;
    /*
    int material;
    */
    int loclevel;
    int i;

    if(IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_NPC(victim))
    {
       send_to_char("Highlanders are immune to that.\n\r",ch);
       return;
    }

    if ( saves_spell(level,victim,DAM_OTHER) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    for ( obj = victim->carrying ; obj != NULL ; obj = obj_next )
    { 
	obj_next = obj->next_content;

        if ( obj->wear_loc == -1 )
	   continue;

	if ( obj->item_type != ITEM_ARMOR )
	    continue;
/*
	material = material_lookup(obj->material);

	if (!IS_SET(material_table[material].flags,MAT_VULN_RUST) )
	    continue;
*/
if (
str_cmp(obj->material,"adamantanium") && 
str_cmp(obj->material,"adamantite") &&
str_cmp(obj->material,"adamantium") &&
str_cmp(obj->material,"adamite") &&
str_cmp(obj->material,"alloy") &&
str_cmp(obj->material,"aluminum") && 
str_cmp(obj->material,"brass") &&
str_cmp(obj->material,"bronze") &&
str_cmp(obj->material,"coins") &&
str_cmp(obj->material,"copper") &&
str_cmp(obj->material,"fools-gold") &&
str_cmp(obj->material,"gold") &&
str_cmp(obj->material,"iron") &&
str_cmp(obj->material,"lead") &&
str_cmp(obj->material,"metal") &&
str_cmp(obj->material,"mineral") &&
str_cmp(obj->material,"mithril") &&
str_cmp(obj->material,"nickel") &&
str_cmp(obj->material,"obsidian") &&
str_cmp(obj->material,"peweter") &&
str_cmp(obj->material,"pewter") &&
str_cmp(obj->material,"platinum") &&
str_cmp(obj->material,"silver") &&
str_cmp(obj->material,"stainless") && 
str_cmp(obj->material,"steel") &&
str_cmp(obj->material,"tin") &&
str_cmp(obj->material,"tinfoil") &&
str_cmp(obj->material,"titanium") && 
str_cmp(obj->material,"wire"))
    {
       continue;
    }


	loclevel = level;

	if (obj->enchanted)
	   loclevel -= 4;

	if ( saves_spell(loclevel,victim,DAM_OTHER) )
		continue;

	act("$p whithers and rusts away!",ch,obj,victim,TO_CHAR,FALSE);
	act("$p whithers are rusts away!",ch,obj,victim,TO_ROOM,FALSE);

	for ( i = 0 ; i < 4 ; i++ )
	   obj->value[i] = 0;

	level -= 2; /* reduce casting levelfor every successful land */

    }

    return;
}

void spell_irradiate(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
       if ( ch != victim )
	   act("$N is already affected.",ch,NULL,victim,TO_CHAR,FALSE);
       else
	   act("You're plenty sick as it is.",ch,NULL,victim,TO_CHAR,FALSE);
       return;
    }

    if ( saves_spell(level,victim,DAM_ENERGY) )
    {
       send_to_char("You failed.\n\r",ch);
       return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= 2 + (ch->level > 5 ) +
			      (ch->level > 20 ) +
			      (ch->level > 35 ) +
			      (ch->level > 50 );
    af.modifier		=    - (ch->level > 5)
			     - (ch->level > 20)
			     - (ch->level > 35)
			     - (ch->level > 50);
    af.location		= APPLY_STR;
    af.bitvector        = 0;
    affect_to_char(victim,&af);

    af.location		= APPLY_DEX;
    affect_to_char(victim,&af);

    af.location		= APPLY_CON;
    affect_to_char(victim,&af);


   act("$N appears to be stricken with sickness.",ch,NULL,victim,TO_CHAR,FALSE);
   act("You suddenly feel sick and nauseated.",ch,NULL,victim,TO_VICT,FALSE);
   act("$N appears to be sick and nauseated.",ch,NULL,victim,TO_NOTVICT,FALSE);
    return;
}

void spell_travel_fog(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *fog;

    if( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL)
    {
      send_to_char("Your master didn't tell you to do that.\n\r",ch);
      return;
    }

    if((fog = create_object(get_obj_index(OBJ_VNUM_FOG),0,FALSE)) == NULL )
    {
	send_to_char("The sphere of Air has failed you.\n\r",ch);
	return;
    }

    fog->value[0] = 1 +(ch->level>15)+(ch->level>35)+(ch->level>50);
    fog->timer = 10 + ( level / 10 );
    SET_BIT(fog->value[2],GATE_RANDOM);
    SET_BIT(fog->value[2],GATE_BUGGY);
    fog->value[3] = -1;  /*just to reinforce the randomness*/

    obj_to_room(fog,ch->in_room);

    act("$p shimmers into being.",ch,fog,NULL,TO_CHAR,FALSE);
    act("$p shimmers into being.",ch,fog,NULL,TO_ROOM,FALSE);
    return;
}

void spell_earthbind(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    level = UMIN(ch->level, level);

    if ( is_affected(victim,sn) )
    {
       if ( victim != ch )
	  act("$N is already bound to the earth.",ch,NULL,victim,TO_CHAR,FALSE);
       else
	   act("Your feet are already bound.",ch,NULL,victim,TO_CHAR,FALSE);
       return;
    }
/*
    if (  !IS_AFFECTED(victim, AFF_FLYING) )
    {
           
       if ( victim != ch )
	  act("$N is already on the ground.",ch,NULL,victim,TO_CHAR,FALSE);
       else
       act("Your feet are already on the ground.",ch,NULL,victim,TO_CHAR,FALSE);
       return;

    }
 */

    /* This one is a doosy.  Removes a haste AND a bit of dex */
    /* To make it more fair, it's hard to land, especially in town
       where most fights will happen */

    switch( ch->in_room->sector_type )
    {
    /*
    case SECT_INSIDE:    level /= 2;  break;   
    case SECT_CITY:	 level -= 5;  break;
    default:		 level -= 2;  break; 
    */
    case SECT_INSIDE:    level -= 5;  break;   /* Fat chance */
    case SECT_CITY:	 level -= 3;  break;
    default:		 level -= 1;  break; 
    }

    if ( saves_spell(level,victim,DAM_OTHER) )
    {
	act("You failed.",ch,NULL,NULL,TO_CHAR,FALSE);
	return;
    }

     /* remove a haste if it's there */
    if ( IS_AFFECTED(victim,AFF_HASTE) )
	affect_strip(victim,skill_lookup("haste"));
    /* remove half moves */
    ch->move /= 2;

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= ( ch->level / 17 ) ; /* > 35 ); */
    af.location		= APPLY_DEX;
    af.modifier		= -1 * (get_curr_stat(victim,STAT_DEX)/ 4);
    af.bitvector	= 0;
    affect_to_char(victim,&af);

    act("Your feet sink into the ground, you can barely move!",
	ch,NULL,victim,TO_VICT,FALSE);
    act("$N's feet sink into the earth!",ch,NULL,victim,TO_CHAR,FALSE);
    act("$N's feet sink into the earth!",ch,NULL,victim,TO_NOTVICT,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_earthbind(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_stonefist(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
       if ( victim == ch )
	  act("You're already sporting some rocky hands.",
		ch,NULL,NULL,TO_CHAR,FALSE);
       else
	  act("$N is already sporting some rocky hands.",
		ch,NULL,victim,TO_CHAR,FALSE);
       return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.location		= APPLY_DAMROLL;
    af.duration		= level / 3;
    af.modifier		= ch->level / 5;
    af.bitvector	= 0;
    affect_to_char(victim,&af);

    send_to_char("Your hands harden into stone.\n\r",victim);
    if ( victim != ch )
    act("$N's hands harden into stone.",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}

void spell_wall_of_wind(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    CHAR_DATA *vch, *vch_next;

    act("$n summons forth a powerful gale!",ch,NULL,NULL,TO_ROOM,FALSE);
    act("You summon forth a powerful gale!",ch,NULL,NULL,TO_CHAR,FALSE);

    /* Hit primary victim */
    /* Give them some credit for being big */
    level += ( ch->level / 10 );

    if ( saves_spell(level-victim->size,victim,DAM_BASH) )
	act("$N appears to be unaffected.",ch,NULL,victim,TO_CHAR,FALSE);
    else
    {
	act("$N is blown to the ground!",ch,NULL,victim,TO_CHAR,FALSE);
	act("$N is blown to the ground!",ch,NULL,victim,TO_NOTVICT,FALSE);
	act("You are blown to the ground!",ch,NULL,victim,TO_VICT,FALSE);
	victim->position = POS_RESTING;
	DAZE_STATE(victim,24);
	damage(ch,victim,dice(2,4),sn,DAM_BASH,FALSE,TRUE);
    }

    /* Now hit friends and neighbours */
    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch_next )
    {
      /* vch_next = vch->next;*/
       vch_next = vch->next_in_room;

       if ( is_safe_spell(ch,vch,TRUE, sn) ||
	   !is_same_group(vch,victim) ||
	    is_same_group(ch,vch) ||
	    vch == victim) 
	    continue;

 	if ( saves_spell(level-vch->size,vch,DAM_BASH) )
	   act("$N appears to be unaffected.",ch,NULL,vch,TO_CHAR,FALSE);
	else
	{
	   act("$N is blown to the ground!",ch,NULL,vch,TO_CHAR,FALSE);
	   act("You are blown to the ground!",ch,NULL,vch,TO_VICT,FALSE);
	   act("$N is blown to the ground!",ch,NULL,vch,TO_NOTVICT,FALSE);
	   vch->position = POS_RESTING;
	   DAZE_STATE(vch,24);
	   damage(ch,vch,dice(2,4),sn,DAM_BASH,FALSE,TRUE);
 	}
    }
    return;
}

void spell_dust_storm(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    CHAR_DATA *vch, *vch_next;

    level = UMIN(ch->level, level);

    if ( IS_AFFECTED(victim,AFF_BLIND) )
    {
	send_to_char("That victim is already blinded.\n\r",ch);
	return;
   }

  act("$n summons forth a billowing storm of dust!",ch,NULL,NULL,TO_ROOM,FALSE);
  act("You summon forth a billowing storm of dust!",ch,NULL,NULL,TO_CHAR,FALSE);

     af.where		= TO_AFFECTS;
     af.type		= sn;
     af.level		= level;
     af.location	= APPLY_HITROLL;
     af.modifier	= -4;
     af.duration	= 1 + (ch->level > 35 ) + (ch->level > 50 );
     af.bitvector	= AFF_BLIND;

    /* Check intended victim first */
    if ( saves_spell(level,victim,DAM_OTHER) )
	act("$N appears to be unaffected.",ch,NULL,victim,TO_CHAR,FALSE);
    else
    {
	act("$N is blinded!",ch,NULL,victim,TO_CHAR,FALSE);
	act("You are blinded!",ch,NULL,victim,TO_VICT,FALSE);
	act("$N  is blinded!",ch,NULL,victim,TO_NOTVICT,FALSE);
	affect_to_char(victim,&af);
	damage(ch,victim,dice(2,4),sn,DAM_OTHER,FALSE,TRUE);
    }

    /* Check victim's group members */
    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch_next )
    {
       vch_next = vch->next_in_room;

       if ( !is_same_group(victim,vch) ||
	     is_same_group(vch,ch) ||
	     is_safe_spell(ch,vch,TRUE, sn) ||
	     victim == vch )
	     continue;

       if ( saves_spell(level,vch,DAM_OTHER) || IS_AFFECTED(vch, AFF_BLIND) )
	   act("$N appears to be unaffacted.",ch,NULL,vch,TO_CHAR,FALSE);
       else
       {
	  act("$N is blinded!",ch,NULL,vch,TO_CHAR,FALSE);
	  act("You are blinded!",ch,NULL,vch,TO_VICT,FALSE);
	  act("$N is blinded!",ch,NULL,vch,TO_NOTVICT,FALSE);
	  affect_to_char(victim,&af);
	  damage(ch,victim,dice(2,4),sn,DAM_OTHER,FALSE,TRUE);
       }
    }

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_dust_storm(sn,level+2,victim,ch,target);
    } 

    return;
}

void spell_water_breathing(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
	send_to_char("Your lungs have the capacity to breathe water.\n\r",victim);
	if ( victim != ch )
	  act("$N can now breathe underwater.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,level/2,level);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.modifier		= 0;
    af.duration		= level / 2;
    af.location		= 0;
    af.bitvector	= 0;
    affect_to_char(victim,&af);

    if ( level > 35 
      && !IS_SET(victim->res_flags,RES_DROWNING) )
    {
    af.where 		= TO_RESIST;
    af.bitvector	= RES_DROWNING;
    af.duration		= level / 10;
    affect_to_char(victim,&af);
    }

    send_to_char("Your lungs have the capacity to breathe water.\n\r",victim);

    if ( victim != ch )
    act("$N can now breathe underwater.",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}

void spell_body_of_stone(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( victim->race == race_lookup("rockbiter") )
    {
	if ( victim != ch )
	    act("$N is already affected.",ch,NULL,victim,TO_CHAR,FALSE);
	else
	    act("You are already made of stone.",ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }

    if( is_affected( victim, sn ) )
    {
	reup_affect(victim,sn,level,level);
	send_to_char("Your body hardens to stone!\n\r",victim);
	if ( victim != ch )
	  act("$N's body hardens to stone!",ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }

    af.where 		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= ch->level;
    af.location		= APPLY_CON;
    af.modifier		= 1 + ( level > 15 ) + (level > 30 ) + (level > 45 );
    af.bitvector	= 0;
    affect_to_char(victim,&af);

    if ( ch->level > 35 ) 
    {
    af.where		= TO_RESIST;
    af.level		= level / 5;
    af.duration		= UMAX(0,level / 10 - 1);
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector	= RES_ACID;  
    if ( !IS_SET(victim->res_flags,RES_ACID) )
        affect_to_char(victim,&af);
    if ( ch->level > 50 )
    af.bitvector 	= RES_WEAPON;
    if ( !IS_SET(victim->res_flags,RES_WEAPON ) )
	affect_to_char(victim,&af);
    }

    send_to_char("Your body hardens to stone!\n\r",victim);
    if ( victim != ch )
       act("$N's body hardens to stone!",ch,NULL,victim,TO_CHAR,FALSE);

    return;
}


void spell_ice_storm(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    CHAR_DATA *vch, *vch_next;
    int dam;
   char buf[MAX_STRING_LENGTH];

    dam = dice(level, ch->level/3);   

    if ( saves_spell(level,victim,DAM_COLD)) 
        damage(ch,victim,dam/2,sn,DAM_COLD, TRUE ,TRUE);
    else
           damage(ch,victim,dam,sn,DAM_COLD, TRUE,TRUE);

    /* Gladiator Spectator Channel */ 
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
       sprintf(buf,"%s summons a powerful ice storm, freezing everyone in the room.",ch->name);
       gladiator_talk(buf);
    }

    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch_next )
    {
       vch_next = vch->next_in_room;
       
       if ( is_safe_spell(ch,vch,TRUE, sn) ||
           !is_same_group(vch,victim) ||
            is_same_group(ch,vch) ||
            vch == victim )
            continue;

        if ( saves_spell(level,vch,DAM_COLD) )
           damage(ch,vch,dam/2,sn,DAM_COLD, TRUE,TRUE);
        else
           damage(ch,vch,dam,sn,DAM_COLD, TRUE,TRUE);
    }

    return;
}

void spell_farsight( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    if (IS_AFFECTED(ch,AFF_BLIND))
    {
        send_to_char("Maybe it would help if you could see?\n\r",ch);
        return;
    }
 
    do_scan(ch,target_name);
}


void spell_portal( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim;
    OBJ_DATA *portal, *stone;

    if ( is_affected(ch,gsn_trap) )                                         
    {                                                                           
        send_to_char("You are held fast by a snare trap.\n\r",ch);
        return;                                                                 
    }                                                                           
                                                                                
  if( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL)                         
  {                                                                             
    send_to_char("Your master didn't tell you to do that.\n\r",ch);             
    return;                                                                     
  }      

        if ( ( victim = get_char_world( ch, target_name ) ) == NULL
    ||   victim == ch
    ||   victim->in_room == NULL
    ||   !can_see_room(ch,victim->in_room)
    ||   !is_room_clan(ch,victim->in_room)
    ||   IS_SET(victim->in_room->room_flags, ROOM_SAFE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)
    ||   IS_SET(victim->in_room->room_flags, ROOM_NO_RECALL)
    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
    ||   victim->level >= ch->level + 3
    ||   (!IS_NPC(victim) && victim->level >= LEVEL_HERO)  /* NOT trust */
    ||   (IS_NPC(victim) && IS_SET(victim->imm_flags,IMM_SUMMON))
    ||   (IS_NPC(victim) && saves_spell( level, victim,DAM_NONE) ) 
    ||  (is_clan(victim) && !is_same_clan(ch,victim))
    ||  victim->in_room->area->under_develop 
    ||  victim->in_room->area->no_transport 
    ||  ch->in_room->area->no_transport )
    {
        send_to_char( "You failed.\n\r", ch );
        return;
    }   

    stone = get_eq_char(ch,WEAR_HOLD);
    if (!IS_IMMORTAL(ch) 
    &&  (stone == NULL || stone->item_type != ITEM_WARP_STONE))
    {
  send_to_char("You lack the proper component for this spell.\n\r",ch);
  return;
    }

    if (stone != NULL && stone->item_type == ITEM_WARP_STONE)
    {
      act("You draw upon the power of $p.",ch,stone,NULL,TO_CHAR,FALSE);
      act("It flares brightly and vanishes!",ch,stone,NULL,TO_CHAR,FALSE);
      extract_obj(stone);
    }

    portal = create_object(get_obj_index(OBJ_VNUM_PORTAL),0,FALSE);
    portal->timer = 2 + level / 25; 
    portal->value[3] = victim->in_room->vnum;

    obj_to_room(portal,ch->in_room);

    act("$p rises up from the ground.",ch,portal,NULL,TO_ROOM,FALSE);
    act("$p rises up before you.",ch,portal,NULL,TO_CHAR,FALSE);
}

void spell_nexus( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim;
    OBJ_DATA *portal, *stone;
    ROOM_INDEX_DATA *to_room, *from_room;

    if ( is_affected(ch,gsn_trap) )                                         
    {                                                                           
        send_to_char("You are held fast by a snare trap.\n\r",ch);
        return;                                                                 
    }                                                                           
                                                                                
  if( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL)                         
  {                                                                             
    send_to_char("Your master didn't tell you to do that.\n\r",ch);             
    return;                                                                     
  }      

    from_room = ch->in_room;
 
        if ( ( victim = get_char_world( ch, target_name ) ) == NULL
    ||   victim == ch
    ||   (to_room = victim->in_room) == NULL
    ||   !can_see_room(ch,to_room) || !can_see_room(ch,from_room)
    ||	 !is_room_clan(ch,to_room) || !is_room_clan(ch,from_room)
    ||   IS_SET(to_room->room_flags, ROOM_SAFE)
    ||   IS_SET(from_room->room_flags,ROOM_SAFE)
    ||   IS_SET(to_room->room_flags, ROOM_PRIVATE)
    ||   IS_SET(to_room->room_flags, ROOM_SOLITARY)
    ||   IS_SET(to_room->room_flags, ROOM_NO_RECALL)
    ||   IS_SET(from_room->room_flags,ROOM_NO_RECALL)
    ||   victim->level >= ch->level + 3
    ||   (!IS_NPC(victim) && victim->level >= LEVEL_HERO)  /* NOT trust */
    ||   (IS_NPC(victim) && IS_SET(victim->imm_flags,IMM_SUMMON))
    ||   (IS_NPC(victim) && saves_spell( level, victim,DAM_NONE) ) 
    ||   (is_clan(victim) && !is_same_clan(ch,victim))
    ||  victim->in_room->area->under_develop 
    ||  victim->in_room->area->no_transport
    ||  ch->in_room->area->no_transport )
    {
        send_to_char( "You failed.\n\r", ch );
        return;
    }   
 
    stone = get_eq_char(ch,WEAR_HOLD);
    if (!IS_IMMORTAL(ch)
    &&  (stone == NULL || stone->item_type != ITEM_WARP_STONE))
    {
        send_to_char("You lack the proper component for this spell.\n\r",ch);
        return;
    }
 
    if (stone != NULL && stone->item_type == ITEM_WARP_STONE)
    {
        act("You draw upon the power of $p.",ch,stone,NULL,TO_CHAR,FALSE);
        act("It flares brightly and vanishes!",ch,stone,NULL,TO_CHAR,FALSE);
        extract_obj(stone);
    }

    /* portal one */ 
    portal = create_object(get_obj_index(OBJ_VNUM_PORTAL),0,FALSE);
    portal->timer = 1 + level / 10;
    portal->value[3] = to_room->vnum;
 
    obj_to_room(portal,from_room);
 
    act("$p rises up from the ground.",ch,portal,NULL,TO_ROOM,FALSE);
    act("$p rises up before you.",ch,portal,NULL,TO_CHAR,FALSE);

    /* no second portal if rooms are the same */
    if (to_room == from_room)
  return;

    /* portal two */
    portal = create_object(get_obj_index(OBJ_VNUM_PORTAL),0,FALSE);
    portal->timer = 1 + level/10;
    portal->value[3] = from_room->vnum;

    obj_to_room(portal,to_room);

    if (to_room->people != NULL)
    {
  act("$p rises up from the ground.",to_room->people,portal,NULL,TO_ROOM,FALSE);
  act("$p rises up from the ground.",to_room->people,portal,NULL,TO_CHAR,FALSE);
    }
}
     
void do_morph( CHAR_DATA *ch, char *argument )
{
    AFFECT_DATA af;
    int sn, dur;

    if(IS_NPC(ch))
      return;

    sn = skill_lookup("morph");

    if ( ch->mana < (ch->level/5) )
    {
	send_to_char("You can't seem to transform.\n\r",ch);
        return;
    }

    if (IS_AFFECTED(ch,AFF_MORPH))
    {
       send_to_char("You are already transformed.\n\r",ch);
       return;
    }

    ch->mana -= (ch->level/5);

    if ( number_percent( ) < get_skill(ch,gsn_morph))
    {
       send_to_char( "You transform into a beast state.\n\r", ch );
       dur = number_range(4,5);

       check_improve(ch,gsn_morph,TRUE,3);
       af.where     = TO_AFFECTS;
       af.type      = gsn_morph;
       af.level     = ch->level;
       af.duration  = dur;
       af.location  = APPLY_NONE;
       af.modifier  = 0;
       af.bitvector = AFF_MORPH;
       affect_to_char( ch, &af );

/*       if(!IS_SET(ch->mhs,MHS_CURSE))
       {
          af.where     = TO_AFFECTS;
          af.type      = sn;
          af.level     = 2*ch->level;
          af.duration  = dur;
          af.location  = APPLY_NONE;
          af.modifier  = 0;
          af.bitvector = MHS_CURSE;
          affect_to_char( ch, &af );
       }
*/
    }
    else
    {
       send_to_char("You fail to transform into a beast state.\n\r",ch);
       check_improve(ch,gsn_morph,FALSE,3);
    }
     
    return;
}    

void do_shapemorph( CHAR_DATA *ch, char *argument)
{

   char arg[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   CHAR_DATA *victim;
   /*
   DESCRIPTOR_DATA d;
   bool isChar;
    */
   FILE	*fp;
   char strsave[MAX_INPUT_LENGTH];
   sh_int i;
   char strstore[MAX_INPUT_LENGTH];
   return;



    sprintf(log_buf,"%s shapemorphing into %s",ch->name,argument);
    log_string(log_buf);

   if( IS_NPC(ch) || !HAS_KIT(ch,"shapeshifter"))
   {
     send_to_char("You got a problem with how you look?\n\r",ch);
     return;
   }

   if(IS_SET(ch->mhs,MHS_GLADIATOR))
   {
      send_to_char("Gladiator's can not shapemorph.\n\r",ch);
      return;
   }

   strcpy(strstore,argument);

   for( i=0 ; argument[i] != '\0' ; i++ )
   {
	if( ispunct(argument[i]) || argument[i] == '{' || isdigit(argument[i]) )
	{
	  send_to_char( "Oooh, you are so tricky aren't you?", ch);
	  return;
	}
   }

   one_argument(argument,arg);
   if( arg[0] == '\0')
   {
      send_to_char("You must supply a name to morph into.\n\r",ch);
      return;
   }

   if ( !str_prefix(arg,"return"))
   {
      if (IS_SET(ch->mhs,MHS_SHAPEMORPHED))
      {
	 REMOVE_BIT(ch->mhs,MHS_SHAPEMORPHED);
         send_to_char("You return to your regular appearance. How boring!\n\r",ch);
	 act( "$n returns to $s regular appearance.", ch,NULL,ch,TO_ROOM,FALSE);
         return;
      }
      else
      {
         send_to_char("You are not Morphed.\n\r",ch);
         return;
      } 
   }

   if(IS_SET(ch->mhs,MHS_SHAPEMORPHED))
   {
      send_to_char("You are already morphed.\n\r",ch);
      return;
   }


   /* Don't allow morphing into other players */
   /* Simply check if the pfile name is there to open
      and then close it!
    */
   sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( arg ) );
   if ( ( fp = fopen( strsave, "r" ) ) != NULL )
   {                                                                                             
      send_to_char( "They would not be very happy with you, would they?\n\r", ch );
      fclose( fp );
      return;                   
   }     

  /* Dont allow morphing into Mobs, this is only cause 2.mobname isnt working */
   if ( ( victim = get_char_world( ch, argument ) ) != NULL)
   {
      send_to_char("Becoming a Mob is so beneath you.\n\r",ch);
      return;
   }

   i = 0;
   while(arg[i] != '\0')
   {
      arg[i] = tolower(arg[i]);
      i++;
   }

   if (!strncmp(arg,"self",4))
   {
      send_to_char("Self is not valid as the start to a morphing name.\n\r",ch);
      return;
   }

/*
   i = 0;
   while (strstore[i] != '\0')
   {
      if(!isalpha(strstore[i]))
      {
	 send_to_char("a thru Z are the only valid characers for shapemorph.\n\r",ch);
	 return;
      }
      i++;
   }
   */


   free_string( ch->long_descr );                                        
   ch->long_descr = str_dup( argument ); 
   SET_BIT(ch->mhs,MHS_SHAPEMORPHED);

   sprintf(buf,"You morph into %s.\n\r",ch->long_descr );
   send_to_char(buf,ch);
   act( "$n morphs into $r.",ch,NULL,ch->long_descr,TO_ROOM ,FALSE);
   return;
}

/* ShapeShift in Work - Poquah */
void do_shapeshift( CHAR_DATA *ch, char *argument)
{
   char arg[MAX_INPUT_LENGTH];
   sh_int i = 0;
   sh_int temp_stat[MAX_STATS];
   sh_int race;
   char buf[MAX_STRING_LENGTH];
   sh_int failchance;
   sh_int sizediff;
   

   if( IS_NPC(ch) || !HAS_KIT(ch,"shapeshifter"))
   {
     send_to_char("You got a problem with the race you are currently?\n\r",ch);
     return;
   }

   one_argument(argument,arg);
   if( arg[0] == '\0')
   {
      send_to_char("You must supply a race to shapeshift into.\n\r",ch);
      return;
   }
   if ( !str_prefix(arg,"return"))
   {
      if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
      {
	 if (ch->save_race != ch->race)
	 {
	    REMOVE_BIT(ch->mhs,MHS_SHAPESHIFTED);
            shapeshift_remove(ch); 
            return;
	 }
	 else
	 {
	    send_to_char("You are recovering from a shift.\n\r",ch);
	    return;
	 }
      }
      else
      {
         send_to_char("You are not Shapeshifted.\n\r",ch);
         return;
      } 
   }

   race = race_lookup(arg);

   if (race == 0 || !race_table[race].pc_race)
   {
      send_to_char("That is not a valid race.\n\r",ch);
      return;
   }

   if (!str_cmp(race_table[race].name,"mutant"))
   {
      send_to_char("You can not shift into a mutant.\n\r",ch);
      return;
   }

   if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
   {
      send_to_char("You have not recovered from your last shift.\n\r",ch);
      return;
   }

   if (race == ch->race)
   {
      send_to_char("You are already that race.\n\r",ch);
      return;
   }

   /* Not allowed to attempt shift with no mana */
   if (ch->mana < 25)
   {
     send_to_char("You are too drained to attempt the shift.\n\r",ch);
     return;
   }

   sizediff = abs(ch->size - pc_race_table[race].size);
   /* At low level can not shift into any size different from original */
   if (ch->level <= 15)
   {
      if (sizediff != 0) 
      {
    send_to_char("You have not the skill to shift into that size.\n\r",ch);
    return;
      }
   }

   /* Place Current HP/MANA drain here to hit people even if they fail */
   /* Slash Current HP and Mana from Drain of Shifting */
   /* Dont drop below one, no need to kill them */
   if (ch->hit > 1)
      ch->hit = ch->hit /2;

   /* Let mana drop below 25 so they cant continue spamming to shift */
   if (ch->mana > 1)
      ch->mana = ch->mana /2;

   /* Sizes greater then original is % based on level */
   failchance = 100 - ((ch->level - (9 + (sizediff * 7))) * 14);

   if (failchance <= 0)
      failchance = 1;

   if (failchance > 95)
      failchance = 95;

   if ((ch->level == 51) && (sizediff == 5))
      failchance = 5;

   if (sizediff == 0)
      failchance = 1;
  
   if (number_percent() <= failchance)
   {
send_to_char("Your skin stretches and tears then returns to its normal form.\n\r",ch);
return;
   }

   /* Save off Real Race Information for Restore later */
   /* Save Race */
   ch->save_race = ch->race;

   /* Save Stats */
   for (i = 0; i < MAX_STATS; i++)
      ch->save_stat[i] = ch->perm_stat[i];

   /* Save HP,Mana 
   ch->save_max_hit = ch->max_hit;
   ch->save_max_mana = ch->max_mana;
*/

   /* Remove ALL Worn EQ */
   remove_all_objs(ch);

   /* Begin Shapeshift */
   ch->race = race;

   /* initialize stats */
   /* Get New Race Stats Temp */
   for (i = 0; i < MAX_STATS; i++)
      temp_stat[i] = pc_race_table[race].stats[i];

   /* Compare New Race Stats to Existing Stats */
   /* If Existing Stat is below New Race Minimum */
   for ( i = 0 ; i < MAX_STATS ; i++ )
      if (ch->perm_stat[i] < temp_stat[i])
      {
         ch->perm_stat[i] = temp_stat[i];
      }

   /* If Existing Stat is above New Race Maximum */
   for ( i = 0 ; i < MAX_STATS ; i++ )
      if (ch->perm_stat[i]  >= get_max_train(ch,i)) 
      {
         ch->perm_stat[i] = get_max_train(ch,i); 
      }
      
   /* Add on New Race Aff,Imm,Res,Vulns,Form,Parts,Size */
   ch->affected_by = race_table[race].aff;
   ch->imm_flags   = race_table[race].imm;
   ch->res_flags   = race_table[race].res;
   ch->vuln_flags  = race_table[race].vuln;
   ch->form        = race_table[race].form;
   ch->parts       = race_table[race].parts;
   ch->size 	   = pc_race_table[race].size;

   /* Drop CON for being ShapeShifted -3 initial 
      and %5 chance every tick -1 */
   ch->mod_stat[STAT_CON] -= 3;
   ch->save_con_mod = -3;

   /* Display change to CH and Room */
   if (!str_prefix(race_table[race].name ,"elf"))
   {
      sprintf(buf,"You transform into an %s.\n\r",race_table[race].name );
      send_to_char(buf,ch);
 act( "$n transforms into an $r.",ch,NULL,race_table[race].name,TO_ROOM ,FALSE);
   }
   else
   {
      sprintf(buf,"You transform into a %s.\n\r",race_table[race].name );
      send_to_char(buf,ch);
 act( "$n transforms into a $r.",ch,NULL,race_table[race].name,TO_ROOM ,FALSE);
   }
   SET_BIT(ch->mhs,MHS_SHAPESHIFTED);
   return;
}

void shapeshift_remove( CHAR_DATA *ch)
{
   sh_int i = 0;
   sh_int race = 0;

   /* Return from Shapeshift */

   /* Remove All Worn EQ */
   remove_all_objs(ch);

   /* Retrieve Real Race Information from Save */
   /* Return Race */
   race = ch->save_race;
   ch->race = race;

   /* Return HP,Mana 
   ch->max_hit = ch->save_max_hit;
   ch->max_mana = ch->save_max_mana;
*/

   /* Return Stats */
   for (i = 0; i < MAX_STATS; i++)
      ch->perm_stat[i] = ch->save_stat[i];

   /* Return Old Race Aff,Imm,Res,Vulns,Form,Parts,Size */
   ch->affected_by = race_table[race].aff;
   ch->imm_flags   = race_table[race].imm;
   ch->res_flags   = race_table[race].res;
   ch->vuln_flags  = race_table[race].vuln;
   ch->form        = race_table[race].form;
   ch->parts       = race_table[race].parts;
   ch->size        = pc_race_table[race].size;

   /* Slash Current HP and Mana from Drain of Returning */
   /* Dont drop below one, no need to kill them */
   if (ch->hit > 1)
      ch->hit = ch->hit /2;
   
   /* Dont drop Mana below 1, just to be kind */
   if (ch->mana > 1)
      ch->mana = ch->mana /2;

   /* Display return to CH and Room */
   act( "You return to your natural form.\n\r",ch,NULL,NULL,TO_CHAR,FALSE);
   act( "$n returns to $s natural form.", ch, NULL, ch, TO_ROOM ,FALSE);

   return;
}
/* Shapeshift currently in work - Poquah */

void spell_smoke_screen ( int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
  CHAR_DATA *victim;
  AFFECT_DATA af;

  if((victim = ch->fighting) == NULL)
    {
        send_to_char("But you aren't fighting anyone.\n\r",ch);
        return;
    }

  if ( saves_spell(level,victim,DAM_OTHER))
  return;

  send_to_char("You bring forth a cloud of smoke to hide your escape, ",ch);
  if(IS_SET(ch->display,DISP_COLOR))
   send_to_char( GREEN"RUN!"NORMAL"\n\r", ch );
  else
   send_to_char( "RUN!\n\r", ch );

  stop_fighting( victim, FALSE );
  stop_fighting( ch, FALSE );

    if (IS_AFFECTED(victim,AFF_BLIND))
        return;

  act("$n is blinded by the smoke in $s eyes!",victim,NULL,NULL,TO_ROOM,FALSE);
  act("$n's smoke cloud gets in your eyes!",ch,NULL,victim,TO_VICT,FALSE);
  send_to_char("You can't see a thing!\n\r",victim);

  af.where  = TO_AFFECTS;
  af.type   = sn;
  af.level  = level;
  af.duration = 0;
  af.location = APPLY_HITROLL;
  af.modifier = -2;
  af.bitvector  = AFF_BLIND;

  affect_to_char(victim,&af);
    
  return;
} 

void blow_orb(CHAR_DATA *victim,int sn)
{
    affect_strip(victim,sn);
    if ( skill_table[sn].msg_off )
      {
       send_to_char( skill_table[sn].msg_off, victim );
       send_to_char( "\n\r", victim );
      }

     if ( sn == skill_lookup("orb of touch") )
     WAIT_STATE(victim,12);

    return;
}

void spell_orb_of_touch(int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
  CHAR_DATA *victim = (CHAR_DATA *) vo;
  AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
  if (victim == ch)
    send_to_char("You are already surrounded by that orb.\n\r",ch);
  else
    act("$N is already surrounded by that orb.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if (IS_SET(ch->mhs,MHS_GLADIATOR) && 
        gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
    {
       send_to_char("You can not cast orbs in the arena.\n\r", ch);
       return;
    }

  af.where  = TO_AFFECTS;
  af.type   = sn;
  af.level  = level+ ch->level/8;    
  af.duration = level/2;
  af.location = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = 0;

  affect_to_char(victim,&af);
  send_to_char( "You are surrounded by an orb of touch.\n\r", victim );
    if ( ch != victim )
  act("$N is surrounded by an orb of touch.",ch,NULL,victim,TO_CHAR,FALSE);

  return;
}

void spell_orb_of_surprise(int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
  CHAR_DATA *victim = (CHAR_DATA *) vo;
  AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
  if (victim == ch)
    send_to_char("You are already surrounded by that orb.\n\r",ch);
  else
    act("$N is already surrounded by that orb.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if (IS_SET(ch->mhs,MHS_GLADIATOR) && 
        gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
    {
       send_to_char("You can not cast orbs in the arena.\n\r", ch);
       return;
    }

  af.where  = TO_AFFECTS;
  af.type   = sn;
  af.level  = level;
  af.duration = level/2;
  af.location = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = 0;

  affect_to_char(victim,&af);
  send_to_char( "You are surrounded by an orb of surprise.\n\r", victim );
    if ( ch != victim )
  act("$N is surrounded by an orb of surprise.",ch,NULL,victim,TO_CHAR,FALSE);  

  return;
}

void spell_orb_of_awakening(int sn, int level,CHAR_DATA *ch, void *vo, int targ)
{
  CHAR_DATA *victim = (CHAR_DATA *) vo;
  AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
  if (victim == ch)
    send_to_char("You are already surrounded by that orb.\n\r",ch);
  else
    act("$N is already surrounded by that orb.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if (IS_SET(ch->mhs,MHS_GLADIATOR) && 
        gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
    {
       send_to_char("You can not cast orbs in the arena.\n\r", ch);
       return;
    }

  af.where  = TO_AFFECTS;
  af.type   = sn;
  af.level  = level;
  af.duration = level/2;
  af.location = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = 0;

  affect_to_char(victim,&af);
  send_to_char( "You are surrounded by an orb of awakening.\n\r", victim );
    if ( ch != victim )
  act("$N is surrounded by an orb of awakening.",ch,NULL,victim,TO_CHAR,FALSE);  

  return;
}

void spell_orb_of_turning(int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
  CHAR_DATA *victim = (CHAR_DATA *) vo;
  AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
  if (victim == ch)
    send_to_char("You are already surrounded by that orb.\n\r",ch);
  else
    act("$N is already surrounded by that orb.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if (IS_SET(ch->mhs,MHS_GLADIATOR) && 
        gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
    {
       send_to_char("You can not cast orbs in the arena.\n\r", ch);
       return;
    }

  af.where  = TO_AFFECTS;
  af.type   = sn;
  af.level  = level;
  af.duration = level/2;
  af.location = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = 0;

  affect_to_char(victim,&af);
  send_to_char( "You are surrounded by an orb of turning.\n\r", victim );
    if ( ch != victim )
  act("$N is surrounded by an orb of turning.",ch,NULL,victim,TO_CHAR,FALSE);  

  return;
}

void spell_see_soul(int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{

  CHAR_DATA *victim = (CHAR_DATA *) vo;
   char buf[MAX_STRING_LENGTH];

   level = UMAX(ch->level,level);
  if( saves_spell( level, victim,DAM_HOLY) )
	return;

  send_to_char( "They are ", ch );
    if ( victim->alignment >  900 ) send_to_char( "angelic.\n\r", ch );
     else if ( victim->alignment >  700 ) send_to_char( "saintly.\n\r", ch );
     else if ( victim->alignment >  350 ) send_to_char( "good.\n\r",    ch );
     else if ( victim->alignment >  100 ) send_to_char( "kind.\n\r",    ch );
     else if ( victim->alignment > -100 ) send_to_char( "neutral.\n\r", ch );
     else if ( victim->alignment > -350 ) send_to_char( "mean.\n\r",    ch );
     else if ( victim->alignment > -700 ) send_to_char( "evil.\n\r",    ch );
     else if ( victim->alignment > -900 ) send_to_char( "demonic.\n\r", ch );
     else                             send_to_char( "satanic.\n\r", ch );

  if(!IS_NPC(victim))
  {
 sprintf(buf,"They are a follower of %s.\n\r",deity_table[victim->pcdata->deity].pname);
 send_to_char(buf,ch);
  }
  /*
check_killer(ch,victim);
*/

 return;
}

void spell_crusade(int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
 CHAR_DATA *victim = (CHAR_DATA *) vo;
   char buf[MAX_STRING_LENGTH];

   level = UMAX(ch->level,level);
  if(IS_NPC(victim) || ch->pcdata->deity == victim->pcdata->deity 
	|| saves_spell( level, victim,DAM_HOLY) )
    {
	send_to_char("Nothing seems to happen.\n\r", ch);
	return;
    }

       if(ch->pcdata->sac< 10)
    {
	sprintf(buf,"You are powerless to act in %s's name.\n\r",
	deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,ch);
	return;
    }

	  sprintf(buf,"Using the gifts of %s you attempt to convert %s.\n\r",
		deity_table[ch->pcdata->deity].pname, victim->name);
	send_to_char(buf,ch);
	sprintf(buf,"%s protects you from %s's agent.\n\r",
		deity_table[victim->pcdata->deity].pname,deity_table[ch->pcdata->deity].pname);
	send_to_char(buf,victim);

/* Poquah change, cause it cause + sac points
  loss = ch->pcdata->sac / 2;
  loss = UMIN( victim->pcdata->sac - loss, loss );
  */
  /* loss = UMIN( loss, 10 ); */

/* Poquah change cause it cases + sac points
  ch->pcdata->sac -= loss;
  victim->pcdata->sac = UMAX(0,victim->pcdata->sac - loss);
  */

  ch->pcdata->sac /= 2;
  victim->pcdata->sac /= 2;

  switch(number_range(1,2))
  {
	default: break;
	case 1:  if ( !saves_spell( level, victim,DAM_HOLY) )
		victim->move /= 2; 
		break;
	case 2:   if ( !saves_spell( level, victim,DAM_HOLY) )
		{ victim->mana /= 3; victim->mana *= 2; }
		break;
  }
  check_killer(ch,victim);

  return;
}

void spell_holy_silence(int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
 CHAR_DATA *vch,*vch_next;
  AFFECT_DATA af;
  char buf[MAX_STRING_LENGTH];

   level = UMAX(ch->level,level);
   for ( vch = char_list; vch != NULL; vch = vch_next )
    {
    vch_next  = vch->next;
  if ( vch->in_room == NULL )
      continue;
  if ( vch->in_room == ch->in_room 
      && !IS_NPC(vch)
      && !is_safe_spell(ch,vch,FALSE, sn) )
  {
    if ( is_affected( vch, sn ) || saves_spell( level, vch,DAM_HOLY) )
  continue;

  af.where  = TO_AFFECTS;
  af.type   = sn;
  af.level  = level;
  af.duration = level/10;
  af.location = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = 0;

affect_to_char(vch,&af);
  sprintf(buf, "You no longer feel the presence of %s.\n\r", 
	deity_table[vch->pcdata->deity].pname );
  send_to_char(buf,vch);
    if ( ch != vch )
  act("$N is lost to their deity.",ch,NULL,vch,TO_CHAR,FALSE);
  }
	}

return;
}


void spell_farsee(int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
//1518 is the object's vnum
  CHAR_DATA *victim = (CHAR_DATA *) vo;
  OBJ_DATA *obj;
  char  buf[MAX_STRING_LENGTH];
  if ( IS_NPC(ch) )
  {
    return;
  }

  if ( !is_clan(ch) )
  {
    send_to_char("You are not a clanner.  This is a clanner only spell.  You are a fool and will not be reimbursed.\r\n",ch);
    return;
  }

  obj = get_eq_char(ch,WEAR_HOLD);

  if ( obj == NULL || obj->pIndexData->vnum != 1518 )
  {
    send_to_char("You lack the component for this spell.\n\r",ch);
    return;
  }
  
  if ( ch->in_room->sector_type == SECT_INSIDE )
  {
    send_to_char("You cannot be inside to cast the farsee spell.\r\n",ch);
    return;
  }
/*
 if (!IS_NPC(ch) && !HAS_KIT(ch,"seer"))
 {
   send_to_char("You are no longer a Seer, the spell fails you.\n\r",ch);
   return;
 }
*/
      act("You draw upon the power of $p.",ch,obj,NULL,TO_CHAR,FALSE);
      act("It flares brightly and vanishes!",ch,obj,NULL,TO_CHAR,FALSE);
      extract_obj(obj);

 if ( ( victim = get_char_world( ch, target_name ) ) == NULL                 
   ||   victim == ch                                                           
   ||   victim->in_room == NULL                                                
   ||   !can_see_room(ch,victim->in_room)                                      
   ||   !is_room_clan(ch,victim->in_room)                                      
   ||   IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)                      
   ||   IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)                     
   ||   (is_clan(victim) && !is_clan(ch) && !is_same_group(ch,victim))
   ||   (!IS_NPC(victim) && victim->level > LEVEL_HERO)  /* NOT trust */
   ||   saves_spell( level, victim, DAM_MENTAL)
   ||   (!is_room_owner(ch,victim->in_room) && room_is_private(ch,victim->in_room))
   ||  victim->in_room->area->under_develop                                    
   ||  victim->in_room->area->no_transport                                     
   ||  ch->in_room->area->no_transport )                                       
   {
       send_to_char( "You failed.\n\r", ch );                                  
       return;                                                                 
   }
    if ( saves_spell( level, victim, DAM_MENTAL ) )
    {
act("You feel as though you are being watched.",victim,NULL,NULL,TO_CHAR,FALSE);
    }

    sprintf(log_buf,"%s casting seer to find %s",ch->name,victim->name);
    log_string(log_buf);
 sprintf(buf,"%s is at %s\n\r",IS_NPC(victim)?victim->short_descr:victim->name
	,victim->in_room->name);
 send_to_char(buf,ch);

 return;
}

void spell_tsunami(int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
    CHAR_DATA *vch;
    CHAR_DATA *vch_next;

    sprintf(log_buf,"%s casting tsunami in room %d %s",ch->name,ch->in_room->vnum,ch->in_room->name);
    log_string(log_buf);

    send_to_char( "You summon forth a wall of water!\n\r", ch );
    act( "$n summons forth a wall of water.", ch, NULL, NULL, TO_ROOM ,FALSE);

    for ( vch = char_list; vch != NULL; vch = vch_next )
    {
       vch_next  = vch->next;
       if ( vch->in_room == NULL )
          continue;
       if ( vch->in_room == ch->in_room )
       {
          if ( vch == ch || is_safe_spell(ch,vch,TRUE, sn))
          {
             if ( vch != ch )
                send_to_char("Some water splashes at your ankles.\n\r",vch);
             continue;
          }
          else
          {
             damage( ch,vch,2*level + dice(3, 8), sn, DAM_DROWNING,TRUE,TRUE);

	     /* CAREFUL, they may have died.  Don't want to play with
		moving a non-existant (NULL) vch as in a dead NPC
	      */
	      if ( (vch == NULL) || (vch->in_room == NULL) 
		   || (vch->in_room != ch->in_room) )
	      {
		continue;
	      }
              if ( IS_NPC(vch) && vch->spec_fun != 0 )
              {
                if (
                   vch->spec_fun == spec_lookup("spec_honor_guard")
                   || vch->spec_fun == spec_lookup("spec_demise_guard")
                   || vch->spec_fun == spec_lookup("spec_posse_guard")
                   || vch->spec_fun == spec_lookup("spec_zealot_guard")
                   || vch->spec_fun == spec_lookup("spec_warlock_guard")
                   )
                   {
                     continue;
                   }
               }


             if(!saves_spell(level,vch,DAM_DROWNING))
             {
                 EXIT_DATA *pexit;
                 int door;

                 /* you failed your saves, you are now dazed and you might be moved */
                 send_to_char("You are knocked about gurgling and sputtering.\n\r",vch);
                 DAZE_STATE(vch,24);
                 vch->position = POS_RESTING;
	
                 door = number_door();
                 if ( ( pexit = vch->in_room->exit[door] ) == 0
                        ||  pexit->u1.to_room == NULL
                        ||  pexit->u1.to_room->clan
                        ||  IS_SET(pexit->exit_info, EX_CLOSED)
                        || (IS_NPC(vch)
                            && IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB) ) )
                    continue;
         
                 /* should stop combat only if you can move the person */
	         stop_fighting(vch,TRUE);
                 move_char(vch, door, FALSE );
              }
           }
           continue;
        }
        if ( vch->in_room->area == ch->in_room->area )
           send_to_char( "The rumbling of water echos in the distance.\n\r", vch );
     }
     return;
}

void spell_enhance(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{                                                                               
    CHAR_DATA *victim = (CHAR_DATA *) vo;                                       
    AFFECT_DATA af;                                                             
    char  buf[MAX_STRING_LENGTH];
                                                                                
    if ( is_affected(victim,sn) )
    {
	send_to_char("You improve your self.\n\r",ch);
	reup_affect(victim,sn,level/3,level);
        return;                                                                 
    }                                                                           
                                                                                
    switch(number_range(1,3))
    {
	case 1:	af.location = APPLY_CON;
	sprintf(buf,"constitution.\n\r"); break;
	case 2:	af.location = APPLY_STR; 
	sprintf(buf,"strength.\n\r"); break;
	case 3:	af.location = APPLY_DEX; 
	sprintf(buf,"dexterity.\n\r"); break;
	default: af.location = APPLY_NONE;
	sprintf(buf,"self.\n\r"); break;
    }

    af.where            = TO_AFFECTS;                                           
    af.type             = sn;                                                   
    af.level            = level;                                                
    af.duration         = ch->level/3;
    af.modifier         = 1 + (number_percent() < get_skill(ch,sn));
    af.bitvector        = 0;                                                    
    affect_to_char(victim,&af);

    damage(ch,ch,level,0,DAM_MENTAL, FALSE,FALSE);
    send_to_char("You improve your ",ch);
    send_to_char(buf,ch);

  return;
}

void spell_flame_shield(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    AFFECT_DATA af;
    CHAR_DATA *victim = (CHAR_DATA *) vo;

    if ( is_affected(victim,skill_lookup("flame shield")) ||
	 is_affected(victim,skill_lookup("frost shield")) ||
	 is_affected(victim,skill_lookup("electric shield")))
    {
	if ( victim == ch )
  send_to_char("You're already protected with an element shield.\n\r",ch);
	else
	act("$N is already protected by an element shield.",
		ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }

    /* If you are vuln fire you need to make a saving throw for this
     * to work and either way you take damage from it.
     */
    if ( IS_SET(ch->vuln_flags,VULN_FIRE) )
    {
	if ( !saves_spell(level,ch,DAM_FIRE) )
	{
		send_to_char("You failed.\n\r",ch);
		return;
	}

        ch->hit = UMAX( 1, ch->hit - dice(5,10) );
    }

    af.where    		= 0;
    af.type			= sn;
    af.level			= level;
    af.modifier			= 0;
    af.location			= 0;
    af.duration			= level / 5;
    af.bitvector		= 0;
    affect_to_char(victim,&af);

    if( victim == ch )
	send_to_char("A flame shield flickers around you.\n\r",ch);
    else
    {
	act("A flame shield flickers around $N.",ch,NULL,victim,TO_CHAR,FALSE);
	act("A flame shield flickers around you.",ch,NULL,victim,TO_VICT,FALSE);
    }

    act("A flame shield flickers around $N.",ch,NULL,victim,TO_NOTVICT,FALSE);
    return;
} 

void spell_frost_shield(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    AFFECT_DATA af;
    CHAR_DATA *victim = (CHAR_DATA *) vo;

    if ( is_affected(victim,skill_lookup("flame shield")) ||
	 is_affected(victim,skill_lookup("frost shield")) ||
	 is_affected(victim,skill_lookup("electric shield")))
    {
	if ( victim == ch )
  send_to_char("You're already protected with an element shield.\n\r",ch);
	else
  act("$N is already protected by an element shield.",
	ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }

    /* If you are vuln cold you need to make a saving throw for this
     * to work and either way you take damage from it.
     */
    if ( IS_SET(ch->vuln_flags,VULN_COLD) )
    {
	if ( !saves_spell(level,ch,DAM_COLD) )
	{
		send_to_char("You failed.\n\r",ch);
		return;
	}

        ch->hit = UMAX( 1, ch->hit - dice(5,10) );
    }

    af.where    		= 0;
    af.type			= sn;
    af.level			= level;
    af.modifier			= 0;
    af.location			= 0;
    af.duration			= level / 5;
    af.bitvector		= 0;
    affect_to_char(victim,&af);

    send_to_char("A frost shield freezes around you.\n\r",ch);
    act("A frost shield freezes around $N.",ch,NULL,victim,TO_NOTVICT,FALSE);
    return;
} 


void spell_electric_shield(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    AFFECT_DATA af;
    CHAR_DATA *victim = (CHAR_DATA *) vo;

    if ( is_affected(victim,skill_lookup("flame shield")) ||
	 is_affected(victim,skill_lookup("frost shield")) ||
	 is_affected(victim,skill_lookup("electric shield")))
    {
	if ( victim == ch )
  send_to_char("You're already protected with an element shield.\n\r",ch);
	else
  act("$N is already protected by an element shield.",
	ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }

    /* If you are vuln lightning you need to make a saving throw for this
     * to work and either way you take damage from it.
     */
    if ( IS_SET(ch->vuln_flags,VULN_LIGHTNING) )
    {
	if ( !saves_spell(level,ch,DAM_LIGHTNING) )
	{
		send_to_char("You failed.\n\r",ch);
		return;
	}

        ch->hit = UMAX( 1, ch->hit - dice(5,10) );
    }

    af.where    		= 0;
    af.type			= sn;
    af.level			= level;
    af.modifier			= 0;
    af.location			= 0;
    af.duration			= level / 5;
    af.bitvector		= 0;
    affect_to_char(victim,&af);

    send_to_char("An electric shield energizes around you.\n\r",ch);
    act("An electric shield energizes around $N.",
	ch,NULL,victim,TO_NOTVICT,FALSE);
    return;
} 

void spell_confusion(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    AFFECT_DATA af;
    CHAR_DATA *victim = (CHAR_DATA *) vo;
   char buf[MAX_STRING_LENGTH];

    level = UMAX(level, ch->level);
    
    if (IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1))
    {
      send_to_char("You have been sanctioned from using this skill.\n\r", ch);
      return;
    }

    if (is_affected(victim, skill_lookup("confusion")))
      {
      send_to_char("They are already confused.\n\r", ch);
      return;
      }

    if ( saves_spell(level,victim,DAM_MENTAL) )
       {
	 send_to_char("You failed.\n\r", ch);
	 return;
       }

       af.where                    = 0;
       af.type                     = sn;
       af.level                    = level;
       af.modifier                 = 0;
       af.location                 = 0;
       af.duration                 = level / 9;
       af.bitvector                = 0;
       affect_to_char(victim,&af);

       send_to_char( "The ground spins beneath your feet.\n\r", victim);
       act("$n appears to be confused.",victim,NULL,NULL,TO_ROOM,FALSE);
    /* Gladiator Spectator Channel */ 
    if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       sprintf(buf,"%s confuses the hell out of %s, they are walking in circles!",ch->name,victim->name);
       gladiator_talk(buf);
    }
       return;
}

void spell_cuffs_of_justice(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    AFFECT_DATA af;
    CHAR_DATA *victim = (CHAR_DATA *) vo;
   char buf[MAX_STRING_LENGTH];
    send_to_char("Sorry, that isn't a spell anymore.\n\r",ch);
    return;
    level = UMAX(level, ch->level);
    if (IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1))
    {
      send_to_char("You have been sanctioned from using this skill.\n\r", ch);
      return;
    }
    if (is_affected(victim, skill_lookup("cuffs of justice" )))
      {
      send_to_char("They are already bound by justice.\n\r", ch);
      return;
      }
    if ( saves_spell(level,victim,DAM_MENTAL) )
       {
         send_to_char("You failed.\n\r", ch);
         return;
       }
       af.where                    = 0;
       af.type                     = sn;
       af.level                    = level;
       af.modifier                 = -1 * (get_curr_stat(victim,STAT_DEX)/ 4);
       af.location                 = APPLY_DEX;
       af.duration                 = level / 9;
       af.bitvector                = 0;
       affect_to_char(victim,&af);
       affect_to_char(ch,&af);
       send_to_char("You put the smackdown on them.\r\n",ch);
       act( "$n screams \"Respect my authority!\" and puts the smack down on $N.", ch, NULL, victim,TO_ROOM,FALSE);
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       sprintf(buf,"%s makes  %s respect his authorita!
",ch->name,victim->name);
       gladiator_talk(buf);
    }
       return;
}

void spell_restrain(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    AFFECT_DATA af;
    CHAR_DATA *victim = (CHAR_DATA *) vo;
   char buf[MAX_STRING_LENGTH];
    level = UMAX(level, ch->level);
    if (is_affected(victim, skill_lookup("restrain" )))
      {
      send_to_char("They are already restrained.\n\r", ch);
      return;
      }
    if ( saves_spell(level,victim,DAM_MENTAL) )
       {
         send_to_char("You failed.\n\r", ch);
         return;
       }
       af.where                    = 0;
       af.type                     = sn;
       af.level                    = level;
       af.modifier                 = -1 * (get_curr_stat(victim,STAT_DEX)/ 4);
       af.location                 = APPLY_DEX;
       af.duration                 = level / 9;
       af.bitvector                = 0;
       affect_to_char(victim,&af);
       affect_to_char(ch,&af);
       send_to_char("You put the smackdown on them.\r\n",ch);
       act( "$n screams \"Respect my authority!\" and puts the smack down on $N.", ch, NULL, victim,TO_ROOM,FALSE);
    /* Gladiator Spectator Channel */
    /* Gladiator Spectator Channel */
    if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       sprintf(buf,"%s makes  %s respect his authorita!
",ch->name,victim->name);
       gladiator_talk(buf);
    }
       return;
}





void spell_nether_shield(int sn,int level, CHAR_DATA *ch, void *vo, int target)
{

  OBJ_DATA *shield, *wShield;

  wShield = get_eq_char(ch, WEAR_SHIELD);

  if (wShield != NULL)
    {
    send_to_char("You must remove your current shield first.\n\r", ch);
    return;
    }

  if (!HAS_KIT(ch, "nethermancer"))
    {
    send_to_char("Only nethermancers may create a nether shield.\n\r", ch);
    return;
    }
  shield = create_object(get_obj_index(OBJ_VNUM_NETHER_SHIELD), 0, FALSE);

  shield->timer = ch->level  - number_range(0,ch->level /3);

  act("$n has created a shield from the nether plane.\n\r",
	ch, NULL, NULL, TO_ROOM,FALSE);
  send_to_char("You create a shield from the nether plane.\n\r", ch);
  obj_to_char(shield, ch);
  wear_obj(ch, shield, TRUE);

  return;

}

void spell_cure_vision(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;

    send_to_char("Sorry, this isn't a spell anymore\n\r",ch);
    return;

    if (victim->clan != ch->clan)
    {
       send_to_char("They are not in your clan.\n\r",ch);
       return;
    }

    if (IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1))
    {
      send_to_char("You have been sanctioned from using this skill.\n\r", ch);
      return;
    }

    if ( !is_affected( victim, gsn_blindness ) )
    {
        if (victim == ch)
          send_to_char("You aren't blind.\n\r",ch);
        else
          act("$N doesn't appear to be blinded.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
    }
 /* Everyone casts at their actual level or casting level, which ever is higher */
    level = UMAX(ch->level, level);

    if (check_dispel(level,victim,gsn_blindness))
    {
        send_to_char( "Your vision returns!\n\r", victim );
        act("$n is no longer blinded.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
    else
        send_to_char("Spell failed.\n\r",ch);
}


void spell_indulgence(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{

 AFFECT_DATA af;
 CHAR_DATA *victim = (CHAR_DATA * )vo;

 if ( is_affected(victim,sn)) 
 {
  send_to_char("You have been granted an indulgence to kill as you choose.\n\r", ch);
  reup_affect(victim,sn,level,level);
  return;
 }

 
       af.where                    = 0;
       af.type                     = sn;
       af.level                    = level;
       af.modifier                 = 0;
       af.location                 = 0;
       af.duration                 = level;
       af.bitvector                = 0;
       affect_to_char(victim,&af);

  send_to_char("You have been granted an indulgence to kill as you choose.\n\r", ch);

  return;
}
/*19SEP00 - Start of the charm_animal spell - Boogums */
void spell_charm_animal( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
  CHAR_DATA *victim = (CHAR_DATA *) vo;
  CHAR_DATA *victim_group = (CHAR_DATA *) vo;
  AFFECT_DATA af;
  int count=0;

  if ( is_safe(ch,victim) )
  {
    return;
  }
  if ( victim->form != NULL && !IS_SET(victim->form,FORM_ANIMAL) )
  {
    if ( victim == ch )
    {
      send_to_char("Grrrowl, you are QUITE the animal aren't you?\n\r",ch);
      return;
    }
    if (!IS_NPC(victim))
    {
    send_to_char("They might be weird but they aren't an animal.\n\r",ch);
    return;
    }

    send_to_char("You can only cast charm animal on animals.\n\r", ch);
    return;
  }


  for ( victim_group = char_list; victim_group != NULL; victim_group = victim_group->next )
  if ( (is_same_group( victim_group, ch ) && IS_SET(victim_group->form,FORM_ANIMAL))
    || (is_same_group(victim_group->master,ch) && IS_SET(victim_group->form,FORM_ANIMAL)))
  {
    count++;
  }
  if ( count >= level/5 && !IS_IMMORTAL(ch))
  {
    send_to_char("You lack the experience to control any more animals.\n\r",ch);
   return;
  }
  
  if ( IS_SET(victim->act, ACT_AGGRESSIVE) 
  ||   IS_AFFECTED(victim, AFF_CHARM)
  ||   IS_AFFECTED(ch, AFF_CHARM)
  ||   level < victim->level
  ||   victim->position == POS_FIGHTING) 
  {
    send_to_char("Sorry Charlie, not on that target.\n\r",ch);
    return;
  }

  switch(check_immune(victim,DAM_MENTAL))
  {
    case IS_IMMUNE:   level = (IS_NPC(victim)?1:0);  break;
    case IS_RESISTANT:  level = (IS_NPC(victim)?level/2:1);  break;
    case IS_VULNERABLE: level = (IS_NPC(victim)?level+4:2);  break;
    default:            level = (IS_NPC(victim)?level:1);break;
  }

  if ( victim->master )
  {
    stop_follower( victim );
  }
  add_follower( victim,ch );
  victim->leader = ch;
  af.where       = TO_AFFECTS;
  af.type        = sn;
  af.level       = level;
  af.duration    = IS_NPC(victim)?number_fuzzy(level/2):level*1.5;
  af.location    = 0;
  af.modifier    = 0;
  af.bitvector   = AFF_CHARM;
  affect_to_char( victim, &af );

  if ( ch != victim )
  {
    act("You have quelled the beast within $N.",ch,NULL,victim,TO_CHAR,FALSE);
  }
  return;
}/*end brace for spell_charm_animal */

/* 07OCT00 - Start of spell_swarm by Boogums */
void spell_swarm( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{ /*Start Brace of spell_swarm */
  CHAR_DATA *victim = (CHAR_DATA *) vo;
  char buf  [MAX_STRING_LENGTH];
  int dam,hp_damage,dice_damage;
  int casters_hp;
  int damage_attack = 0;
  AFFECT_DATA af;

  casters_hp = UMAX( 10, ch->hit );
  hp_damage = number_range( casters_hp/9+1, casters_hp/5 );
  dice_damage = dice(level,15);
    
  dam = UMAX(hp_damage + dice_damage /10, dice_damage + hp_damage /10);

  /* Gladiator Spectator Channel */
  if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
      sprintf(buf,"%s calls forth nature's wrath on %s, and boy is she pissed.",
      ch->name,victim->name);
      gladiator_talk(buf);
    }

  switch (number_range(0,6) )
  { 
    case 1: /* Bees - Poison */
      act("BZZZZZZZZZZZZZZZ! It's Killer Bees!\r\n",ch,NULL,victim,TO_NOTVICT,FALSE);
      act("BZZZZZZZZZZZZZZZ! Someone's stirred up a hornets nest.\r\n",ch,NULL,victim,TO_VICT,FALSE);
      send_to_char("Your Africanized wasps swarm about them.\r\n",ch);

      if (( saves_spell( level, victim,DAM_POISON) || is_affected(victim,sn) )
	 ||(IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD)))
      {
	damage_attack = 1;
	act("WASPS!!! RUN!!!",victim,NULL,NULL,TO_ROOM,FALSE);
	send_to_char("You feel momentarily ill, but it passes.\n\r",victim);
	return;
      }
      else 
      {
	af.where     = TO_AFFECTS;
	af.type      = sn;
	af.level     = level;
	af.duration  = level/4;
	af.location  = APPLY_STR;
	af.modifier  = -1;
	af.bitvector = AFF_POISON;
	affect_join( victim, &af );

	damage_attack=1;
	send_to_char( "DOH!  You're not feeling to well right now.\n\r", victim );
	act("$n looks very ill.",victim,NULL,NULL,TO_ROOM,FALSE);
      }
    break;
    case 0: /* Rats - Plague */
      act("Oh rats...\r\n",ch,NULL,victim,TO_NOTVICT,FALSE);
      act("$n looks really freaky with those rats swarming out from behind them.\r\n",ch,NULL,victim,TO_VICT,FALSE);
      act("Pretty cool Willard, your rats attack!\r\n",ch,NULL,NULL,TO_CHAR,FALSE);
      if ( ( saves_spell(level,victim,DAM_DISEASE) || is_affected( victim, sn) ) ||
      (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD)))
      {
        damage_attack = 1;
        if (ch == victim)
        {
	  send_to_char("You feel momentarily ill, but it passes.\n\r",ch);
	}
        else
	{
          act("$N seems to be unaffected.",ch,NULL,victim,TO_CHAR,FALSE);
	}
      }
      else
      {
        damage_attack = 1;
        af.where     = TO_AFFECTS;
        af.type     = sn;
        af.level    = level*3/4 ;
        af.duration  = level/4;
        af.location  = APPLY_STR;
        af.modifier  = -3;
        af.bitvector = AFF_PLAGUE;
        affect_join(victim,&af);
        send_to_char("You scream in agony as plague sores erupt from your skin.\n\r",victim);
        act("$n screams in agony as plague sores erupt from $s skin.",victim,NULL,NULL,TO_ROOM,FALSE);
      }
      break;

    case 2: /* Butterflies - calm */
      damage_attack = 0;
      act("$n opens a hole to the elemental plane of butterfly.\r\n",ch,NULL,victim,TO_NOTVICT,FALSE);
      act("$n opens a hole to the elemental plane of butterfly.\r\n",ch,NULL,victim,TO_VICT,FALSE);
      act("You open a portal to the elemental plane of butterfly.\r\n",ch,NULL,NULL,TO_CHAR,FALSE);

      if ( ( saves_spell( level, victim,DAM_MENTAL) || is_affected( victim, sn) ) )
      {
        if (ch == victim)
        {
	  send_to_char("Awwww, those butterflies sure is pretty.\r\n",ch);
        }
        else
        {
	  send_to_char("Awwww, those butterflies sure are pretty.\r\n",victim);
        }
      }
      else
      {
	act("Grab your nets!!! $n is summoning butterflies!  Who wants to fight anymore?\r\n",ch,NULL,victim,TO_ROOM,FALSE);
        if (victim->fighting || victim->position == POS_FIGHTING)
        {
          stop_fighting(victim,FALSE);
          af.where = TO_AFFECTS;
          af.type = sn;
          af.level = level;
          af.duration = level/4;
          af.location = APPLY_HITROLL;
          if (!IS_NPC(victim))
          af.modifier = -5;
          else
          af.modifier = -2;
          af.bitvector = AFF_CALM;
          affect_to_char(victim,&af);
          af.location = APPLY_DAMROLL;
          affect_to_char(victim,&af);
        }
      }
      break;

    case 3: /* Spiders - hold person */
      damage_attack = 1;
      act("$n spews spiders from their fingertips.\r\n",ch,NULL,victim,TO_NOTVICT,FALSE);
      act("$n spews spiders from their fingertips.",ch,NULL,victim,TO_VICT,FALSE);
      act("Spiders fly from your fingertips!\r\n",ch,NULL,NULL,TO_CHAR,FALSE);

      if ( ( is_affected( victim, sn) ) ||
      saves_spell(level,victim,DAM_OTHER) )
      {
      send_to_char("Come into my parlor...\r\n",victim);
      send_to_char("They dodge your spiders web.\r\n",ch);
      }
      else
      {
	damage_attack = 0;
        af.where            = TO_AFFECTS;
        af.type             = sn;
        af.level            = level;
        af.location         = APPLY_DEX;
        af.modifier         = ( 3 - get_curr_stat(victim,STAT_DEX) );
        af.duration         = 1 + (UMAX(0,level-51));
        af.bitvector        = 0;
        affect_to_char( victim, &af );
        victim->position = POS_RESTING;
        act("$N is wrapped up snug as a bug in a rug!",ch,NULL,victim,TO_NOTVICT,FALSE);
        send_to_char("The spiders wrap you snugly in their web.\n\r",victim);
        if ( victim != ch )
	{
          act("$N is wrapped in the spider's web..",ch,NULL,victim,TO_CHAR,FALSE);
	}
      }
      break;

    case 4: /* Ants - Stun affect */
      act("Small holes open in the ground and ants stream out.\r\n",ch,NULL,victim,TO_NOTVICT,FALSE);
      act("*CRACK* The ground opens and ants pour out.",ch,NULL,victim,TO_VICT,FALSE);
      act("The whole room is filled with ants.\r\n",ch,NULL,NULL,TO_CHAR,FALSE);
      if ( saves_spell(level,victim,DAM_MENTAL) )
      {
        damage_attack = 1;
      }
      else
      {
        send_to_char("Ants!  Ants with stingers! Ouch!\r\n.",victim);
	act("$n is stunned by the ants.\r\n",victim,NULL,NULL,TO_ROOM,FALSE);
	damage_attack = 1;
        DAZE_STATE(victim, 2 * PULSE_VIOLENCE);
        victim->position = POS_RESTING;
      }
      break;


    case 5: /* Locust - blindness */
      act("A swarm of locusts comes from the sky.\r\n",ch,NULL,victim,TO_NOTVICT,FALSE);
      act("A swarm of locusts comes from the sky.\r\n",ch,NULL,victim,TO_VICT,FALSE);
      act("The whole room is filled with locusts.\r\n",ch,NULL,NULL,TO_CHAR,FALSE);

      if (is_affected(victim,sn) || saves_spell(level,victim,DAM_OTHER) )
      {
        damage_attack = 1;
	act("$n dodges the locusts.\r\n",victim,NULL,NULL,TO_ROOM,FALSE);
	send_to_char("You dodge the locusts.\r\n", victim );
      }
      else
      {
	damage_attack = 1;

        af.where     = TO_AFFECTS;
	af.type      = sn;
        af.level     = level;
	af.location  = APPLY_HITROLL;
        af.modifier  = -4;
        af.duration  = 1+level/4;
	af.bitvector = AFF_BLIND;
	affect_to_char( victim, &af );
	send_to_char( "You are {Gblinded{x by the locusts!\n\r", victim );
	act("$n appears to be {Gblinded{x by the locusts.",victim,NULL,NULL,TO_ROOM,FALSE);
      }
    break;

    case 6: /* Fireflys - feeblemind */
      damage_attack = 0;
      act("$n fills the room with fireflies.\r\n",ch,NULL,victim,TO_NOTVICT,FALSE);
      act("$n fills the room with fireflies.",ch,NULL,victim,TO_VICT,FALSE);
      act("The whole room is filled with fireflies.\r\n",ch,NULL,NULL,TO_CHAR,FALSE);
      if ( is_affected(victim,sn ) || saves_spell(level,victim,DAM_MENTAL) )
      {
        send_to_char("The fireflies you called fly away.\n\r",ch);
	send_to_char("You were distracted momentarily by the firefiles.\n\r",victim);
      }
      else
      {
        af.where            = TO_AFFECTS;
        af.type             = sn;
        af.level            = level;
        af.duration         = (level/12);
        af.modifier         = -1 * (level/8);
        af.location         = APPLY_INT;
        af.bitvector        = 0;
        affect_to_char( victim, &af );
       
        send_to_char("Oh the designs!  They are so simple yet so beautiful!  Those fireflies sure are smart.\n\r",victim);
        if ( victim != ch )
        {
	  act("$N's willpower fades away.",ch,NULL,victim,TO_CHAR,FALSE);
        }
      }
      break;
    default:
    break;
    }/*end brace for case*/

/*hit em hard damage taken from firebreath spell */

  if(damage_attack == 1)
  {
    
        if (saves_spell(level,victim,DAM_HARM))
        {
          damage( ch, victim, dam/2, sn, DAM_HARM,TRUE ,TRUE);
        }
        else
        {
          damage( ch, victim, dam, sn, DAM_HARM,TRUE ,TRUE);
        }
  }
  return;

} /*End Brace of spell_swarm */

void spell_wraithform( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
  CHAR_DATA *victim = (CHAR_DATA *) vo;

  if ( is_affected( ch, sn ))
  {
    if (victim == ch)
    send_to_char("You are already in wraith form.",ch);
    return;
  }
     if(IS_SET(ch->mhs,MHS_GLADIATOR))
	  {
	       send_to_char("A ghost in the gladiators? Tune in next week for The Undead Wars.\n\r",ch);
		    return;
			 }

  /* Set timer */
  if ( !IS_NPC(victim) )
  {
     victim->pcdata->wraith_timer = 48;
     act("$n begins to fade into shadow...",victim,NULL,NULL,TO_ROOM,FALSE);
     send_to_char("You begin to fade into wraithform...\n\r",victim);
  }
 
  return;
}

void action_wraithform( CHAR_DATA *victim, char *arg )
{ 
    AFFECT_DATA af;

  if ( IS_NPC(victim) )
	return;

  af.where     = TO_AFFECTS;
  af.type      = skill_lookup("wraithform");
  af.level     = victim->level;
  af.duration  = victim->level *3/4;
  af.location  = 0;
  af.modifier  = 0;
  af.bitvector = 0;
  affect_to_char( victim, &af );
  act( "$n becomes very shadowy.", victim, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( "You become very wraithlike.\n\r", victim );
  return;
}
void action_zealot_convert( CHAR_DATA *victim,char *argh)
{
  if ( IS_NPC(victim) )
  { 
    return;
  }
  victim->pcdata->deity = deity_lookup("almighty");
  victim->pcdata->rank = 0;
}


/* Support function for wraith form */
void spell_make_bag( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    static char *headers[] = { "corpse of the ", "corpse of The ",
			       "corpse of an ", "corpse of An ",
   			       "corpse of a ", "corpse of A ",
			       "the corpse of ",
			       "corpse of " }; // (This one must be last)
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    char buf[MAX_STRING_LENGTH];
    int i;

    if ( obj->item_type != ITEM_CORPSE_NPC && obj->item_type != ITEM_CORPSE_PC)
    {
       send_to_char("That is not a corpse.\n\r",ch);
	return;
    }

    if (obj->contains != NULL)
    {
       send_to_char("You must empty out the corpse first.\n\r",ch);
       return;
    }

    for (i = 0; i < 7; i++)
    {
       int len = strlen(headers[i]);
       if ( memcmp(obj->short_descr, headers[i], len) == 0 )
       {
          sprintf( buf, "bag beta %s", obj->short_descr+len );
/*   	  free_string( obj->name );
*/
	  obj->name = str_dup(buf);

          sprintf( buf, "A bag of fine %s hide catches your eye.  ",
                   obj->short_descr+len );
/*	  free_string( obj->description );
*/
          obj->description = str_dup( buf );

          sprintf( buf, "a bag made from %s's hide", obj->short_descr+len );
/*          free_string( obj->short_descr );
*/
	  obj->short_descr = str_dup( buf );

          break;
       }
    }
    /* remove old weight of item */ 
    ch->carry_weight  -= get_obj_weight( obj );
    ch->carry_number -= get_obj_number( obj );

    obj->item_type = ITEM_CONTAINER;
    obj->wear_flags = ITEM_HOLD|ITEM_TAKE;
    obj->timer = 0;
    obj->weight = 5;
    obj->level = level/3;
    obj->cost = level * 50;
    obj->value[0] = level * 10;                 /* Weight capacity */
    obj->value[1] = 1;                          /* Closeable */
    obj->value[2] = -1;                         /* No key needed */
    obj->value[3] = 90;			/* maximum weight */
    obj->value[4] = 25;    			/* weight % multiplier */
    obj->pIndexData = get_obj_index( 1258 );    /* So it's not a corpse */

    act( "Your new $p looks pretty snazzy.", ch, obj, NULL, TO_CHAR,FALSE );
    act( "$n's new $p looks pretty snazzy.", ch, obj, NULL, TO_ROOM,FALSE );

    /* add new weight of item */
    ch->carry_weight  += get_obj_weight( obj );
    ch->carry_number  += get_obj_number( obj );

    send_to_char( "Ok.\n\r", ch );
    return;
}

void spell_annointment(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{    
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    send_to_char("Sorry, this spell doesn't exist anymore.\n\r",ch);
    return;

    if (IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1))
    {
        send_to_char("You have been sanctioned from using this skill.\n\r",
          ch);
        return;
    }

    if ( is_affected(victim,sn) || ch->clan != clan_lookup("zealot") )
    {
        send_to_char("You failed.\n\r",ch);
        return;   
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = (level / 5);
    af.modifier         = 0;
    af.location         = APPLY_NONE;
    af.bitvector        = 0;  
    affect_to_char( victim, &af );

    send_to_char("You gain the annointment of The Almighty.\n\r",victim);
    return;
}

void spell_aura_of_valor(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
 
    send_to_char("Sorry, this isn't a spell anymore.\n\r",ch);
    return;

    if ( IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1) )
    {
        send_to_char("You have been sanctioned from using this skill.\n\r",ch);
        return;
    }

    if ( ch->clan != clan_lookup("honor") )
    {
        send_to_char("You are not a member of Honor.\n\r",ch);
        return;
    } 

    if ( is_affected(victim,sn) )
    {
        send_to_char("You are already surrounded by an aura of valor.\n\r",victim);
        return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = (victim->level / 2);
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = 0;
    affect_to_char( victim, &af );

    send_to_char("You are surrounded by an aura of valor./n/r",victim);
    return;
}

void spell_spirit_phoenix(int sn,int level,CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    OBJ_DATA *feather;
    AFFECT_DATA af;

    feather = get_eq_char(ch,WEAR_HOLD);
    if ( !IS_IMMORTAL(ch) && (feather == NULL || feather->pIndexData->vnum != OBJ_VNUM_FEATHER) )
    {
	send_to_char("You lack the proper material component.\n\r",ch);
	return;
    }

    if (feather != NULL &&  feather->pIndexData->vnum == OBJ_VNUM_FEATHER && number_percent( ) < 25 )
    {
        act("$p whithers away to ashes.",ch,feather,NULL,TO_CHAR,FALSE);
        extract_obj(feather);
	/* It's possible to save the ashes */
	if ( number_percent() < level / 5 )
	{
	    OBJ_DATA *ash;

	    ash = create_object( get_obj_index( OBJ_VNUM_ASHES ), 0, FALSE );
	    obj_to_char( ash, ch );
	}
    }

    if ( is_affected( victim, sn ) )
    {
	if ( victim == ch )
	    send_to_char("You are already gifted with the spirit.\n\r",ch);
	else
	    send_to_char("You failed.\n\r",ch);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= level / 3;
    af.modifier		= 0;
    af.location		= 0;
    af.bitvector	= (AFF_SANCTUARY | AFF_WITHSTAND_DEATH);
    affect_to_char( victim, &af );

    /* Now the cool part.  If this is cast in a superior magelab at midnight,
     * the feather becomes an amulet.
     */
    if ( ch->in_room->sector_type == SECT_MAGELAB_SUPERIOR && time_info.hour == 0 && ch == victim )
    {
	OBJ_DATA *amulet;
 
	amulet = create_object( get_obj_index( OBJ_VNUM_AMULET ), 0, FALSE );
	amulet->level = UMAX(level,ch->level);
	amulet->level = UMIN(amulet->level,51);
	act("$p materializes in your hands!",ch,amulet,NULL,TO_CHAR,FALSE);
	act("$p materializes in $n's hands!",ch,amulet,NULL,TO_ROOM,FALSE);
	obj_to_char( amulet, ch );
    }

    return;
}

void spell_flameseek(int sn,int level,CHAR_DATA *ch, void *vo, int target)
{

	CHAR_DATA *victim = (CHAR_DATA *) vo;
	AFFECT_DATA af;

    	if ( victim == ch )
  	{
	send_to_char("If you desire the flames that much, cast fireball on yourself!\n\r", ch);
	return;
	}

	if ( IS_SET(victim->vuln_flags, VULN_FIRE))
	{
	send_to_char("They already desire oneness with the flame.\n\r", ch);
	return;
	}

    	if ( saves_spell(IS_SET(ch->mhs, MHS_ELEMENTAL) ? level + 5 : level,victim,DAM_FIRE) )
       	{
	 send_to_char("You failed.\n\r", ch);
	 return;
        }

    	af.where		= TO_VULN;
    	af.type			= sn;
    	af.level		= level;
    	af.duration		= level /11; 
    	af.modifier		= 0;
    	af.location		= 0;
    	af.bitvector		= VULN_FIRE; 
    	affect_to_char( victim, &af );
	
	act("You suddenly feel drawn to the flames.",ch,NULL,victim,TO_VICT,FALSE);
	act("$N suddenly feels drawn to the flames.",ch,NULL,victim,TO_CHAR,FALSE);

	return;
}

void spell_wall_of_fire( int sn, int level, CHAR_DATA *ch, void *vo, int traget)
{
	CHAR_DATA *victim = (CHAR_DATA *) vo;
	AFFECT_DATA af;
	OBJ_DATA *wall;
	int dam;

	dam = dice(level, (IS_SET(ch->mhs, MHS_ELEMENTAL) ? 15 : 10));

	if ( victim == ch)
	{
	send_to_char("You may not cast this spell on yourself.\n\r", ch);
	return;
	}

    	if ( saves_spell(IS_SET(ch->mhs, MHS_ELEMENTAL) ? level + 5 : level,victim,DAM_FIRE) )
	{
	send_to_char("You failed.\n\r", ch);
	return;
	}

	wall = create_object(get_obj_index(OBJ_VNUM_WALL_FIRE),0,FALSE);
        obj_to_room(wall, ch->in_room);
 	damage( ch, victim, dam, sn,DAM_FIRE,TRUE,TRUE);
 
   	af.where = TO_AFFECTS;
    	af.type = gsn_wall_fire;
    	af.level = level;
    	af.location = 0;
    	af.duration = level * 2 / 3;
        wall->timer = level * 2 / 3;
    	af.modifier = 0; 
    	af.bitvector = 0;
	af.caster_id = ch->id;

    	affect_to_room( ch->in_room, &af );

	return;
}

/* Like an acid blast, but a little less damage, and some DOT */	
void spell_boiling_blood( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( saves_spell(level+2,victim,DAM_DISEASE) || is_affected(victim,sn) )
    {
	send_to_char("Nothing seems to happen.\n\r",ch);
	return;
    }

    dam = dice(level,9); /* Acid blast is level d 12 */
    /* It worked */
    damage( ch, victim, dam, sn, DAM_DISEASE,TRUE,TRUE );

    /* At this point, ch should be fighting victim.
     * If not, we killed victim.  So quit!  */
    if ( ch->fighting != victim )
	return;

    af.where = DAMAGE_OVER_TIME;
    af.duration = 12; 	/* 2 minutes of damage */
    af.location = 52;
    af.modifier = 52; /* 624/312/156 */
    af.level	= level;
    af.type	= sn;
    af.bitvector	= DAM_DISEASE;
    af.caster_id	= ch->id;

    affect_to_char( victim, &af );

    send_to_char("You scream in agony as your blood begins to boil!\n\r",victim);
    act("$n screams in unimaginable pain as $s skin blisters and $s blood boils.",
		victim,NULL,NULL,TO_ROOM,FALSE);

    return;
}

/* Level 25 DOT. Does damage comprable to fireball up front, plus
  more over 12 dot pulses */
void spell_blight( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( saves_spell(level+2,victim,DAM_DISEASE) || is_affected(victim,sn) )
    {
        send_to_char("Nothing seems to happen.\n\r",ch);
        return;
    }

    
    dam = number_range( level * 2, level * 4 );
    /* It worked */
    damage( ch, victim, dam, sn, DAM_DISEASE,TRUE,TRUE );

    /* At this point, ch should be fighting victim.
     * If not, we killed victim.  So quit!  */
    if ( ch->fighting != victim )
	return;

    af.where = DAMAGE_OVER_TIME;
    af.duration = 12;   /* 2 minutes of damage */
    af.location = 40;
    af.modifier = 40; /* 480/240/120 */
    af.level    = level;
    af.type     = sn;
    af.bitvector        = DAM_DISEASE;
    af.caster_id        = ch->id;

    affect_to_char( victim, &af );

    send_to_char("Your heart constricts with undescribable pain!\n\r",victim);
    act("$n doubles over in pain as $s heart constricts with the Blight!",
                victim,NULL,NULL,TO_ROOM,FALSE);

    return;
}

/* Level 18 DOT */
void spell_contagion( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( saves_spell(level+2,victim,DAM_DISEASE) || is_affected(victim,sn) )
    {
        send_to_char("Nothing seems to happen.\n\r",ch);
        return;
    }

    dam = number_range( 3 * level / 2 , level * 4 );
    /* It worked */
    damage( ch, victim, dam, sn, DAM_DISEASE,TRUE,TRUE );

    /* At this point, ch should be fighting victim.
     * If not, we killed victim.  So quit!  */
    if ( ch->fighting != victim )
	return;

    af.where = DAMAGE_OVER_TIME;
    af.duration = 12;   /* 2 minutes of damage */
    af.location = 23;
    af.modifier = 23; /* 276, 138, 69 if caster not there */
    af.level    = level;
    af.type     = sn;
    af.bitvector        = DAM_DISEASE;
    af.caster_id        = ch->id;

    affect_to_char( victim, &af );

    af.where	= TO_AFFECTS;
    af.duration	= 4;
    af.location	= APPLY_STR;
    af.modifier = -1 * (level / 10);
    af.bitvector	= 0;
    affect_to_char( victim, &af );

    send_to_char("You feel sick and weak.\n\r",victim);
    act("$n stumbles about with the contagion.",
                victim,NULL,NULL,TO_ROOM,FALSE);

    return;
}


void spell_scourge( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
     AFFECT_DATA af;
     int dam;

    if ( saves_spell(level+2,victim,DAM_DISEASE) || is_affected(victim,sn) )
    {
        send_to_char("Nothing seems to happen.\n\r",ch);
        return;
    }

    dam = number_range( 5 * level / 2 , level * 5 );
    /* It worked */
    damage( ch, victim, dam, sn, DAM_DISEASE,TRUE,TRUE );

    /* At this point, ch should be fighting victim.
     * If not, we killed victim.  So quit!  */
    if ( ch->fighting != victim )
	return;

    af.where = DAMAGE_OVER_TIME;
    af.duration = 12;   /* 3 minutes of damage */
    af.location = 64;
    af.modifier = 64;
    af.level    = level;
    af.type     = sn;
    af.bitvector        = DAM_DISEASE;
    af.caster_id        = ch->id;

    affect_to_char( victim, &af );

    send_to_char("You begin to sweat as you contract the Scourge.\n\r",victim);
    act("$n begins to sweat as $e contracts the Scourge.",
                victim,NULL,NULL,TO_ROOM,FALSE);
 
    return;
}
void spell_blade_barrier(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
	AFFECT_DATA af;


	af.where = TO_AFFECTS;
	af.duration = level;
	af.location = 0;
	af.modifier = 0;
	af.level = level;
	af.type = sn;
	af.bitvector = DAM_SLASH;
	
	affect_to_char(ch, &af);

	act("$n surrounds $eself with a barrier of spinning blades summoned from the Earth itself!\n\r", ch, ch,  NULL, TO_ROOM, FALSE);
	send_to_char("You call forth a barrier of blades from the earth.\n\r", ch);

	return;
}

void spell_thunderclap(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    CHAR_DATA *vch, *vch_next;
    AFFECT_DATA 	af;
    int		dam;

    for ( vch = victim->in_room->people ; vch != NULL ; vch = vch_next )
    {
	vch_next = vch->next_in_room;

	if ( is_safe_spell( ch, vch, TRUE , sn)|| is_affected(vch,sn)
		|| is_same_group(ch, vch) )
		continue;

  	/* Hit 'em */
	dam = number_range( level, level * 2 );
	if ( victim == vch )
	    dam = 3 * dam / 2;

	/* Put the spell affect on first.  If they die, it'll just get removed */
	af.where		= DAMAGE_OVER_TIME;
	af.level		= level;
	af.duration		= 9; /* 90 seconds */
	af.type			= sn;
	af.location		= level / 2;
	af.modifier		= 3 * level / 2;
	af.bitvector		= DAM_SOUND;
	af.caster_id		= ch->id;

	affect_to_char( vch, &af );
	send_to_char("The sound of the thunderclap rings in your ears.\n\r",vch);
	damage( ch, vch, dam, sn, DAM_SOUND, TRUE,TRUE);
    }
    
    return;
}

void spell_venom_of_vhan(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( saves_spell(level,victim,DAM_POISON) || is_affected(victim,sn) )
    {
        send_to_char("Nothing seems to happen.\n\r",ch);
 	return;
    }

     dam = number_range( level * 3, level * 6 );
     damage( ch, victim, dam, sn, DAM_POISON,TRUE,TRUE );

     if ( ch->fighting != victim )
 	return;

     af.where = DAMAGE_OVER_TIME;
     af.duration = 18;   /* 3 minutes of damage */
     af.location = level * 2;    if ( IS_NPC(victim) ); af.location *= 2;
     af.modifier = level * 5;	 if ( IS_NPC(victim) ); af.modifier *= 2;
     af.level    = level;
     af.type     = sn;
     af.bitvector= DAM_POISON;
     af.caster_id= ch->id;

     affect_to_char( victim, &af );

    send_to_char("Your blood turns ice cold as the venom begins to circulate.\n\r",victim);
    act("$n breaks into a cold sweat as venom enters $s veins.",victim,NULL,NULL,TO_ROOM,FALSE);

    return;
} 

void spell_remove_disease(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA *paf;

    /* Find the DOT */
    for ( paf = victim->affected ; paf != NULL ; paf = paf->next )
    	if ( paf->where == DAMAGE_OVER_TIME && paf->bitvector == DAM_DISEASE )
	    break;

    if ( paf == NULL )
    {
	if ( victim == ch )
	    send_to_char("You aren't diseased.\n\r",ch);
	else
	    act("$N isn't diseased.",ch,NULL,victim,TO_CHAR,FALSE);
	return;
    }

    /** Tke down the level **/
    paf->level -= level / 2;
    if ( paf->level < 1 )
    {
	act("$n sighs in relief as the disease fades.",victim,NULL,NULL,TO_ROOM,FALSE);
	act("You sigh in relief as the disease fades.",victim,NULL,NULL,TO_CHAR,FALSE);
	affect_remove( victim, paf , APPLY_BOTH);
    }
    else
    {
	act("$n regains some strength as the disease weakens.",victim,NULL,NULL,TO_ROOM,FALSE);
	act("You regain some strength as the disease weakens.",victim,NULL,NULL,TO_CHAR,FALSE);
    }

    return;
}

void spell_remove_poison(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA *paf;

    /* Find the DOT */
    for ( paf = victim->affected ; paf != NULL ; paf = paf->next )
        if ( paf->where == DAMAGE_OVER_TIME && paf->bitvector == DAM_POISON )
            break;

    if ( paf == NULL )
    {
        if ( victim == ch )
            send_to_char("You aren't poisoned.\n\r",ch);
        else
            act("$N isn't poisoned.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
    }

    /** Tke down the level **/
    paf->level -= level / 2;
    if ( paf->level < 1 )
    {
        act("$n sighs in relief as the poison fades.",victim,NULL,NULL,TO_ROOM,FALSE);
        act("You sigh in relief as the poison fades.",victim,NULL,NULL,TO_CHAR,FALSE);
        affect_remove( victim, paf , APPLY_BOTH );
    }
    else
    {
        act("$n regains some strength as the poison weakens.",victim,NULL,NULL,TO_ROOM,FALSE);
        act("You regain some strength as the poison weakens.",victim,NULL,NULL,TO_CHAR,FALSE);
    }

    return;
}

void spell_frostbite(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( saves_spell(level,victim,DAM_COLD) || is_affected(victim,sn) )
    {
        send_to_char("Nothing seems to happen.\n\r",ch);
        return;
    }

    dam = dice(level,9); /* Acid blast is level d 12 */
    /* It worked */
    damage( ch, victim, dam, sn, DAM_COLD,TRUE,TRUE );

    /* At this point, ch should be fighting victim.
     * If not, we killed victim.  So quit!  */
    if ( ch->fighting != victim )
        return;

    af.where = DAMAGE_OVER_TIME;
    af.duration = 12;   /* 2 minutes of damage */
    af.location = 3 * level / 2;
    af.modifier = 3 * level;      /* 75 to 150! */
    af.level    = level;
    af.type     = sn;
    af.bitvector        = DAM_COLD;
    af.caster_id        = ch->id;

    affect_to_char( victim, &af );

    act("Your skin frosts over as a numbing coldness envelops you.",victim,NULL,NULL,TO_CHAR,FALSE);
    act("$n's skin frosts over as a numbing coldness evenlops $m.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_blistering_skin(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( saves_spell(level,victim,DAM_FIRE) || is_affected(victim,sn) )
    {
       send_to_char("Nothing seems to happen.\n\r",ch);
       return;
    }

    dam = dice(level,9); /* Acid blast is level d 12 */
    /* It worked */
    damage( ch, victim, dam, sn, DAM_FIRE,TRUE,TRUE );

    /* At this point, ch should be fighting victim.
     * If not, we killed victim.  So quit!  */
    if ( ch->fighting != victim )
        return;

    af.where = DAMAGE_OVER_TIME;
    af.duration = 12;   /* 2 minutes of damage */
    af.location = 3 * level / 2;
    af.modifier = 3*level;      /* 50 to 100! */
    af.level    = level;
    af.type     = sn;
    af.bitvector        = DAM_FIRE;
    af.caster_id        = ch->id;

    affect_to_char( victim, &af );

    act("Your skin blisters and peels as a heat wave envelops you.",victim,NULL,NULL,TO_CHAR,FALSE);
    act("$n's skin blisters and peels as a heat wave evenlops $m.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_electrocution(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( saves_spell(level,victim,DAM_ENERGY) || is_affected(victim,sn) )
    {
       send_to_char("Nothing seems to happen.\n\r",ch);
       return;
    }

    dam = dice(level,9); /* Acid blast is level d 12 */
    /* It worked */
    damage( ch, victim, dam, sn, DAM_ENERGY,TRUE,TRUE );

    /* At this point, ch should be fighting victim.
     * If not, we killed victim.  So quit!  */
    if ( ch->fighting != victim )
        return;

    af.where = DAMAGE_OVER_TIME;
    af.duration = 12;   /* 2 minutes of damage */
    af.location = 3 * level / 2;
    af.modifier = 3 * level;      /* 50 to 100! */
    af.level    = level;
    af.type     = sn;
    af.bitvector        = DAM_ENERGY;
    af.caster_id        = ch->id;

    affect_to_char( victim, &af );

    act("Your skin shivers as a shock of electricity courses through your body.",victim,NULL,NULL,TO_CHAR,FALSE);
    act("$n shivers as a chock of electricity courses through $s body.",victim,NULL,NULL,TO_VICT,FALSE);
    return;
}

void spell_betray(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
	CHAR_DATA *victim = (CHAR_DATA *) vo;
	CHAR_DATA *gch;
	

 	if ( victim == ch )
	{
	send_to_char("You cannot cast this spell on yourself.\n\r", ch);
	return;
	}

	if (IS_NPC(victim))
	{
	send_to_char("Not on that target.\n\r", ch);
	return;
	}
 
	if (!ch->fighting )
	{
	send_to_char("You can only cause betrayal during the confusion of combat.\n\r", ch);
	return;
	}

 	for ( gch = char_list; 	gch != NULL ; gch = gch->next )
	{
	
	/* OK, we need to find all the undead and elementals that are in the same group
	   as the victim.  Make sure that they are NPC's too.  */

	if ( (is_same_group(victim, gch) || is_same_group(victim->master, gch))  &&
	     (IS_SET(gch->mhs, MHS_ELEMENTAL) || IS_SET(gch->act, ACT_UNDEAD))  &&
	     (IS_NPC(gch)) && !saves_spell(level, gch, DAM_CHARM) )
	{
		if(gch->fighting != NULL)
			stop_fighting(gch, TRUE);
	
		if(gch->master)
		   stop_follower(gch);

		add_follower(gch, ch);
		gch->master = ch;
	 	
      		SET_BIT(gch->affected_by,AFF_CHARM); /* quick-charm */
			
		if(ch->fighting != NULL)
		{
			gch->fighting = ch->fighting;
		}
		else
		{
			ch->fighting = victim;
			gch->fighting = victim;
		}

		act("$n betrays you!\n\r", gch, NULL, NULL, TO_VICT, FALSE);
		act("$n betrays $N!\n\r", gch, NULL, victim, TO_NOTVICT, FALSE);
	}
	}
	return;
}

void spell_shield_of_faith(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= level / 5;
    af.modifier		= 0;
    af.location		= 0;
    af.bitvector	= 0;

    affect_to_char(victim,&af);
    send_to_char("You are surrounded by a shield of faith.\n\r",victim);
    act("$n is surrounded by a shield of faith.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_diamond_skin(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) || is_affected(victim,gsn_steel_skin) || is_affected(victim,gsn_stone_skin) 
	|| is_affected(victim,gsn_adamantite_skin) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level / 3;
    af.modifier         = -1 * get_curr_stat(victim,STAT_CON) * 3;
    af.location         = APPLY_AC;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("Your skin turns as hard as diamond!\n\r",victim);
    act("$n's skin turns as hard as diamond!",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_steel_skin(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) || is_affected(victim,gsn_diamond_skin) || is_affected(victim,gsn_stone_skin)  
	|| is_affected(victim,gsn_adamantite_skin) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level / 5;
    af.modifier         = -1 * get_curr_stat(victim,STAT_CON) * 2;
    af.location         = APPLY_AC;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("Your skin hardens to steel!\n\r",victim);
    act("$n's skin hardens to steel!",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_crushing_grip(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
	CHAR_DATA *victim = (CHAR_DATA *) vo;
	int dam;

 	dam = dice(level, 12);

	if (saves_spell(level, victim, DAM_BASH))
		dam /= 2;
 	
	act("$n summons a hand of solid air that tries to squeeze the life out of you!\n\r", ch, NULL, victim, TO_VICT, FALSE);
	act("$n summons	a hand of solid air that tries to squeeze the life from $N!\n\r", ch, NULL, victim, TO_NOTVICT, FALSE);
        damage(ch,victim,dam,sn,DAM_BASH,TRUE,TRUE);

	return;
}

void spell_sunburst(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    dam = dice(level,10);

    if( saves_spell(level,victim,DAM_LIGHT) )
	dam /= 2;

    damage(ch,victim,dam,sn,DAM_LIGHT,TRUE,TRUE);

    /* make sure damage didn't kill 'em.  if not, give a save */
    if ( ch->fighting != victim ||
	 is_affected(victim,sn) ||
	saves_spell(level,victim,DAM_LIGHT) )
       return;


    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= (dam%3); /* duration will be 0,1, or 2 */
    af.modifier		= -6;
    af.location		= APPLY_HITROLL;
    af.bitvector	= AFF_BLIND;

    affect_to_char(victim,&af);

    act("You are blinded by the light!",victim,NULL,NULL,TO_CHAR,FALSE);
    act("$n is blinded by the light!",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_sonic_blast( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;
    bool saved;
    int chance;

    dam = dice(level,9);
    
    if ( saves_spell(level,victim,DAM_SOUND) )
	dam /= 2;

    damage(ch,victim,dam,sn,DAM_SOUND,TRUE,TRUE);

    if ( ch->fighting != victim )
	return;

    /* Base 50% chance */
    chance = 50;

    /* best case: still at 50%.  Worst, at 25%.  Average will be 25-30% */
    chance -= get_curr_stat(victim,STAT_CON);

    if ( (saved = saves_spell(level,victim,DAM_SOUND)) )
	chance /= 2;

    if ( number_percent( ) < chance )
    {
	act("You are stunned by the sonic shockwave!",victim,NULL,NULL,TO_CHAR,FALSE);
	act("$n is stunned by the sonic shockwave!",victim,NULL,NULL,TO_ROOM,FALSE);
	if ( saved )
	    DAZE_STATE(victim,PULSE_VIOLENCE);
	else
	    DAZE_STATE(victim,PULSE_VIOLENCE*2);
    }
    return;
}

void spell_regeneration( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
    act("You feel full of vigor and health.",victim,NULL,NULL,TO_CHAR,FALSE);
    act("$n appears vigorous and healthy.",victim,NULL,NULL,TO_ROOM,FALSE);
    reup_affect(victim,sn,24,level);
	return;
    }

    af.where		= DAMAGE_OVER_TIME; /* engine, not really damage */
	af.level	= level;
	af.type		= sn;
	af.modifier	= -1 * (level/5);
	af.location	= -1 * (level/3);
	af.duration	= 24;
  	af.bitvector	= 0;
   
    affect_to_char(victim,&af);
    act("You feel full of vigor and health.",victim,NULL,NULL,TO_CHAR,FALSE);
    act("$n appears vigorous and healthy.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_adamantite_skin(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) || is_affected(victim,gsn_steel_skin) || is_affected(victim,gsn_stone_skin) ||
	 is_affected(victim,gsn_diamond_skin) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level / 2;
    af.modifier         = -1 * get_curr_stat(victim,STAT_CON) * 4;
    af.location         = APPLY_AC;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("Your skin becomes adamantite!\n\r",victim);
    act("$n's skin becomes adamantite!",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_incinerate(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

       dam = dice( level, 12 );

    if ( saves_spell( level, victim, DAM_FIRE ) )
  dam /= 2;
    damage( ch, victim, dam, sn,DAM_FIRE,TRUE,TRUE);
    return;
}

void spell_acclimate(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = DAMAGE_OVER_TIME;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/5; /* At 100hp/pulse, this is all-star! */
    af.modifier         = -100;
    af.location         = -100;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are more attuned to your environment.\n\r",victim);
    act("$n is more attuned to $s environment.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_symbol_1(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,gsn_symbol_1) ||
	 is_affected(victim,gsn_symbol_2) ||
	 is_affected(victim,gsn_symbol_3) ||
	 is_affected(victim,gsn_symbol_4) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if ( ch->gold < 500 )
    {
	send_to_char("You lack the appropriate sacrifice for your deity.\n\r",ch);
	return;
    }

    ch->gold -= 500;

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level*3;
    af.duration         = level*3;
    af.modifier         = 50;
    af.location         = APPLY_HIT;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("An ancient symbol shines before your eyes.\n\r",victim);
    act("A symbol glows before $n.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_symbol_2(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,gsn_symbol_1) ||
         is_affected(victim,gsn_symbol_2) ||
         is_affected(victim,gsn_symbol_3) ||
         is_affected(victim,gsn_symbol_4) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    if ( ch->gold < 1000 )
    {
        send_to_char("You lack the appropriate sacrifice for your deity.\n\r",ch);
        return;
    }

    ch->gold -= 1000;

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level*3;
    af.duration         = level*3;
    af.modifier         = 100;
    af.location         = APPLY_HIT;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("An ancient symbol shines before your eyes.\n\r",victim);
    act("A symbol glows before $n.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_symbol_3(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,gsn_symbol_1) ||
         is_affected(victim,gsn_symbol_2) ||
         is_affected(victim,gsn_symbol_3) ||
         is_affected(victim,gsn_symbol_4) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    if ( ch->gold < 2000 )
    {
        send_to_char("You lack the appropriate sacrifice for your deity.\n\r",ch);
        return;
    }

    ch->gold -= 2000;

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level*3;
    af.duration         = level*3;
    af.modifier         = 200;
    af.location         = APPLY_HIT;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("An ancient symbol shines before your eyes.\n\r",victim);
    act("A symbol glows before $n.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_symbol_4(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,gsn_symbol_1) ||
         is_affected(victim,gsn_symbol_2) ||
         is_affected(victim,gsn_symbol_3) ||
         is_affected(victim,gsn_symbol_4) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    if ( ch->gold < 4000 )
    {
        send_to_char("You lack the appropriate sacrifice for your deity.\n\r",ch);
        return;
    }

    ch->gold -= 4000;

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level*3;
    af.duration         = level*3;
    af.modifier         = 400;
    af.location         = APPLY_HIT;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("An ancient symbol shines before your eyes.\n\r",victim);
    act("A symbol glows before $n.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_spirit_of_bear(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    if ( ch->skill_points < (level/10) )
    {
	send_to_char("You lack sufficient skill points.\n\r",ch);
	return;
    }

    ch->skill_points -= (level/10);

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/2;
    af.modifier         = (level/10);
    af.location         = APPLY_STR;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are imbued with the Spirit of Bear.\n\r",victim);
    act("$n is strong as a bear.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_spirit_of_boar(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    if ( ch->skill_points < (level/10) )
    {
        send_to_char("You lack sufficient skill points.\n\r",ch);
        return;
    }

    ch->skill_points -= (level/10);

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/2;
    af.modifier         = (level/10);
    af.location         = APPLY_CON;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are imbued with the Spirit of Boar.\n\r",victim);
    act("$n is hardy as a boar.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_spirit_of_cat(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    if ( ch->skill_points < (level/10) )
    {
        send_to_char("You lack sufficient skill points.\n\r",ch);
        return;
    }

    ch->skill_points -= (level/10);

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/2;
    af.modifier         = (level/10);
    af.location         = APPLY_DEX;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are imbued with the Spirit of Cat.\n\r",victim);
    act("$n is quick as a cat.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_spirit_of_owl(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    if ( ch->skill_points < (level/10) )
    {
        send_to_char("You lack sufficient skill points.\n\r",ch);
        return;
    }

    ch->skill_points -= (level/10);

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/2;
    af.modifier         = (level/10);
    af.location         = APPLY_WIS;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are imbued with the Spirit of Owl.\n\r",victim);
    act("$n is wise as an owl.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_spirit_of_wolf(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    /* Costs up to 10 sp per casting */
    if ( ch->skill_points < (level/5) )
    {
        send_to_char("You lack sufficient skill points.\n\r",ch);
        return;
    }

    ch->skill_points -= (level/5);

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = (level/5);
    af.modifier         = 0;
    af.location         = 0;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are imbued with the Spirit of Wolf.\n\r",victim);
    act("$n is cunning as a wolf.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

/*Here are the spells for the scribe kit */
void spell_scribe_maguswrath( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;
    int dam1;
    int dam2;

    dam = dice(level / 10, 4);
    dam1= dice(level / 8, 4);
    dam2 = dice(level /8, 4);

    if ( saves_spell( level, victim,DAM_FIRE) )
    {
        dam /= 2;
    }
    if ( saves_spell( level, victim,DAM_COLD) )
    {
        dam1 /= 2;
    }
    if ( saves_spell( level, victim,DAM_MENTAL) )
    {
        dam2 /= 2;
    }
    send_to_char("OUCH!!! So THAT'S the wrath of a mage!!! \r \n",victim);
    damage( ch, victim, dam, sn, DAM_FIRE ,TRUE,TRUE);
    damage( ch, victim, dam1, sn, DAM_COLD,TRUE ,TRUE);
    damage( ch, victim, dam2, sn, DAM_MENTAL,TRUE ,TRUE);


    return;
}

void spell_scribe_knowledge( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
	    CHAR_DATA *victim = (CHAR_DATA *) vo;

	if ( saves_spell(level,victim,DAM_MENTAL) )
	{
 	send_to_char("Nope, nothing.\r\n",victim);
	send_to_char("I guess they'll never learn.\r\n",ch);	
	return;
	}
	else
	{
	send_to_char("Wow, you should read more often!\r\b",victim);
        victim->skill_points += 15;
	return;
	}


}




void spell_scribe_rest( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
	CHAR_DATA *victim = (CHAR_DATA *) vo;

	if (saves_spell(level, victim, DAM_MENTAL) )
	{
		send_to_char("Nothing seemed to happen.\r\n",ch);
		send_to_char("Nothing seemed to happen.\r\n",victim);
		return;
	}
	else
	{
		send_to_char("WHOA! What a rush!!!\r\n",victim);
		send_to_char("They look much better now.\r\n",ch);
            	victim->hit  = victim->max_hit;
            	victim->mana = victim->max_mana;
            	victim->move = victim->max_move;
		return;
	}
}


void spell_scribe_pox( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int dam;

    if ( saves_spell(level,victim,DAM_DISEASE) || is_affected(victim,sn) )
    {
        send_to_char("Nothing seems to happen.\n\r",ch);
        return;
    }


    dam = number_range( level * 1, level * 2 );
    /* It worked */
    damage( ch, victim, dam, sn, DAM_DISEASE,TRUE,TRUE );

    /* At this point, ch should be fighting victim.
     * If not, we killed victim.  So quit!  */
    if ( ch->fighting != victim )
        return;

    af.where = DAMAGE_OVER_TIME;
    af.duration = 9;   /* 2 minutes of damage */
    af.location = 35;
    af.modifier = 35; /* 360/180/90 */
    af.level    = level;
    af.type     = sn;
    af.bitvector        = DAM_DISEASE;
    af.caster_id        = ch->id;

    affect_to_char( victim, &af );

    send_to_char("This ain't Chicken pox!!!!\n\r",victim);
    act("$n suddenly is covered with oozing sores!",
                victim,NULL,NULL,TO_ROOM,FALSE);

    return;
}















void spell_shield_of_thorns(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,gsn_shield_of_thorns) ||
         is_affected(victim,gsn_shield_of_brambles) ||
         is_affected(victim,gsn_shield_of_spikes) ||
         is_affected(victim,gsn_shield_of_blades) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/10;
    af.modifier         = 15;
    af.location         = APPLY_AC;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are surrounded by a shield of thorns.\n\r",victim);
    act("$n is surrounded by a shield of thorns.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_shield_of_brambles(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,gsn_shield_of_thorns) ||
         is_affected(victim,gsn_shield_of_brambles) ||
         is_affected(victim,gsn_shield_of_spikes) ||
         is_affected(victim,gsn_shield_of_blades) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/10;
    af.modifier         = 30;
    af.location         = APPLY_AC;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are surrounded by a shield of brambles.\n\r",victim);
    act("$n is surrounded by a shield of brambles.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_shield_of_spikes(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,gsn_shield_of_thorns) ||
         is_affected(victim,gsn_shield_of_brambles) ||
         is_affected(victim,gsn_shield_of_spikes) ||
         is_affected(victim,gsn_shield_of_blades) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/10;
    af.modifier         = 45;
    af.location         = APPLY_AC;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are surrounded by a shield of spikes.\n\r",victim);
    act("$n is surrounded by a shield of spikes.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_shield_of_blades(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,gsn_shield_of_thorns) ||
	 is_affected(victim,gsn_shield_of_brambles) ||
	 is_affected(victim,gsn_shield_of_spikes) ||
	 is_affected(victim,gsn_shield_of_blades) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level/10;
    af.modifier         = 60;
    af.location         = APPLY_AC;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are surrounded by a shield of blades.\n\r",victim);
    act("$n is surrounded by a shield of blades.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_midnight_cloak(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = ( HAS_KIT(ch,"necromancer") ? 2 : 0 ) + ( time_info.hour == 0 ? 2 : 0 );
    af.modifier         = 10;
    af.location         = APPLY_HITROLL;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You are surrounded by a cloak of darkness.\n\r",victim);
    act("$n is surrounded by a cloak of darkness.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}


void spell_arcantic_alacrity( int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) || is_affected(victim,gsn_arcantic_lethargy) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = 1;
    af.modifier         = (level/10);
    af.location         = APPLY_INT;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("Your magical abilities are enhanced.\n\r",victim);
    act("$n's magical abilities are enhanced.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_arcantic_lethargy( int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) || saves_spell(level,victim,DAM_OTHER) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = 1;
    af.modifier         = (level/-10);
    af.location         = APPLY_INT;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You feel your magical abilities slip away.\n\r",victim);
    act("$n appears shocked as $s magical powers fade.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}

void spell_immolate( int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    dam = dice(level,12);

    if( saves_spell(level,victim,DAM_FIRE) )
        dam /= 2;

    damage(ch,victim,dam,sn,DAM_FIRE,TRUE,TRUE);
    return;
}

void spell_lacerate( int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    dam = dice(level,15);

    if ( saves_spell(level,victim,DAM_SLASH) )
	dam /= 2;

    damage(ch,victim,dam,sn,DAM_SLASH,TRUE,TRUE);
    return;
}

void spell_clarity( int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
	send_to_char("You feel relaxed as your mind clears.\n\r",victim);
	act("$n relaxes as $s mind clears.",victim,NULL,NULL,TO_ROOM,FALSE);
	reup_affect(victim,sn,level,level);
        return;
    }

    af.where            = TO_AFFECTS;
    af.type             = sn;
    af.level            = level;
    af.duration         = level;
    af.modifier         = 0;
    af.location         = 0;
    af.bitvector        = 0;

    affect_to_char(victim,&af);
    send_to_char("You feel relaxed as your mind clears.\n\r",victim);
    act("$n relaxes as $s mind clears.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}
void spell_dispel_wall( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
   OBJ_DATA *wall;
   AFFECT_DATA *paf;
   char *targ;

   if ( !(is_room_affected(ch->in_room, gsn_wall_fire) ) && !(is_room_affected(ch->in_room, gsn_wall_ice)) )
	{
	send_to_char("You can't dispel that.\n\r", ch);
	return;
	}

   for(paf = ch->in_room->affected; paf !=  NULL; paf = paf->next)
   	{
	if(paf->type == gsn_wall_fire) break;
	if(paf->type == gsn_wall_ice ) break;
	}

if (target_name == "") {
    targ = "wall";
  } else {
    targ = target_name;
  }
  wall = get_obj_list( ch, targ, ch->in_room->contents );

   raffect_remove(ch->in_room, paf);
   act("$p slowly disappears", ch, wall, NULL, TO_ROOM, FALSE);
   act("$p slowly disappears", ch, wall, NULL, TO_CHAR, FALSE);
   obj_from_room(wall);
   extract_obj(wall);
}

void spell_wall_of_ice( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
  EXIT_DATA *pexit;
  int door;
  OBJ_DATA *wall;
  AFFECT_DATA af;

  if (is_room_affected(ch->in_room, gsn_wall_ice))
  {
  send_to_char("There is already a wall of ice here.\n\r", ch);
  return;
  }


  for (door =0; door < 6; door++ ){
  if ( ( pexit = ch->in_room->exit[door] ) == 0 || pexit->u1.to_room == NULL || pexit->u1.to_room->clan)
        continue;
  else
    break;
  } 

  wall = create_object(get_obj_index(OBJ_VNUM_WALL_ICE),0,FALSE);
        obj_to_room(wall, ch->in_room);

        af.where = TO_AFFECTS;
        af.type = gsn_wall_ice;
        af.level = level;
        af.location = door;
        af.duration = level * 2 / 3;
 	wall->timer = level * 2 / 3;
        af.modifier = 0;
        af.bitvector = 0;
        af.caster_id = ch->id;

        affect_to_room( ch->in_room, &af );

        act("You summon $p!",ch,wall,NULL,TO_CHAR,FALSE);
        act("$n summons $p!",ch,wall,NULL,TO_ROOM,FALSE);
        return;
}

void spell_aura_cthon(int sn,int level,CHAR_DATA *ch, void *vo, int target)
{

        CHAR_DATA *victim = (CHAR_DATA *) vo;
        AFFECT_DATA af;

        send_to_char("Sorry, this isn't a spell anymore\n\r",ch);
        return;

        if ( victim != ch )
        {
        send_to_char("You may not cast this on another.\n\r", ch);
        return;
        }
        if( is_affected(ch, skill_lookup("aura of cthon")) )
        {
        send_to_char("How much creepier do you want to get?  You are already affected by the aura of {RCthon{x.\n\r", ch);
        return;
        }

        check_improve(ch,gsn_honor_guard,TRUE,8);
    af.where    = TO_AFFECTS;
    af.type     = sn;
    af.level    = ch->level;
    af.duration = number_range(1,10) + number_range(1,ch->level/10);
    af.bitvector= 0;
    af.modifier = 0;
    af.location = APPLY_NONE;
    affect_to_char(ch, &af );
    return;


}

void spell_hydrophilia(int sn,int level,CHAR_DATA *ch, void *vo, int target)
{

        CHAR_DATA *victim = (CHAR_DATA *) vo;
        AFFECT_DATA af;

        if ( victim == ch )
        {
        send_to_char("If you desire the waves that much, go jump in the lake!\n\r", ch);
        return;
        }

        if ( IS_SET(victim->vuln_flags, VULN_DROWNING) || IS_SET(victim->vuln_flags, VULN_COLD))
        {
        send_to_char("They already desire oneness with the waves.\n\r", ch);
        return;
        }

        if ( saves_spell(IS_SET(ch->mhs, MHS_ELEMENTAL) ? level + 5 : level,victim,DAM_DROWNING) )
        {
         send_to_char("You failed.\n\r", ch);
         return;
        }

        af.where                = TO_VULN;
        af.type                 = sn;
        af.level                = level;
        af.duration             = level /11;
        af.modifier             = 0;
        af.location             = 0;
        af.bitvector            = VULN_DROWNING | VULN_COLD;
        affect_to_char( victim, &af );

        act("You suddenly feel drawn to the waves.",ch,NULL,victim,TO_VICT,FALSE);
        act("$N suddenly feels drawn to the waves.",ch,NULL,victim,TO_CHAR,FALSE);

        return;
}

void spell_stalk ( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim;
    AFFECT_DATA af;
    if( is_affected(ch, skill_lookup("stalk")) )
    {
        send_to_char("You are to spent from your last attempt to stalk, wait a minute.\n\r",ch);
        return;
    }

    if ( is_affected(ch,gsn_trap) )
    {
        send_to_char("You are held fast by a snare trap.\n\r",ch);
        return;
    }

  if( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL)
  {
    send_to_char("Your master didn't tell you to do that.\n\r",ch);
    return;
  }
    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not stalk.\n\r",ch);
       return;
    }
    if ( (victim = get_char_world( ch, target_name ))  == NULL )
    {
    send_to_char("They aren't there.\n\r",ch);
    return;
    }
    if( IS_IMMORTAL(victim) )
    {
      send_to_char("That would be really, really, really stupid...\r\n",ch);
      return;
    }

    if( IS_NPC(victim) )
    {
      send_to_char("Stalking a mob?  Get a life.\r\n",ch);
      return;
    }
    if ( !is_clan(ch) )
    {
      send_to_char("You really should have read the helpfile.  This spell can't be used by nonclanners.\r\n",ch);
      return;
    }
    if ( !is_clan(victim) )
    {
      send_to_char("You will not stalk non-clanners.\r\n",ch);
      return;
    }
    if ( !is_clan(ch) && is_clan(victim) )
    {
	send_to_char("That would be in violation of pkrules.\r\n",ch);
	return;
    }
    af.where    = TO_AFFECTS;
    af.type     = sn;
    af.level    = 0;
    af.duration = 0;
    af.bitvector= 0;
    af.modifier = 0;
    af.location = APPLY_NONE;
    affect_to_char(ch, &af );

  
    if ( ( victim = get_char_world( ch, target_name ) ) == NULL
    ||   victim == ch
    ||   victim->in_room == NULL
    ||   saves_spell(ch->level,victim,DAM_OTHER) 
    ||   !is_room_clan(ch,victim->in_room)
    ||   IS_SET(victim->in_room->room_flags, ROOM_SAFE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)
    ||   IS_SET(victim->in_room->room_flags, ROOM_NO_RECALL)
    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
    ||   (victim->level >= ch->level + 12)
    ||   (victim->level <= ch->level - 12)
    ||   (!IS_NPC(victim) && victim->level > LEVEL_HERO)  /* NOT trust */
    ||   (!is_room_owner(ch,victim->in_room) && room_is_private(ch,victim->in_room) )
    ||  victim->in_room->area->under_develop
    ||  victim->in_room->area->no_transport
    ||  ch->in_room->area->no_transport )
    {
        send_to_char( "You failed.\n\r", ch );
	if (victim != NULL )
        {
	send_to_char( "You feel a shiver run down your spine.\n\r",victim);
	}
        return;
    }

    /* act("$n steps through a gate and vanishes.",ch,NULL,NULL,TO_ROOM,FALSE); */
    send_to_char("You begin your stalking adventure.\n\r",ch);

    char_from_room(ch);
    clear_mount(ch);
    char_to_room(ch,victim->in_room);
 /*   act("$n has arrived through a gate.",ch,NULL,NULL,TO_ROOM,FALSE); */

 /*   do_look(ch,"auto");*/
    if( saves_spell(ch->level,victim,DAM_OTHER) )
    {
        send_to_char("Brrrr, that was weird.\r\n",victim); 
    }

}

@


1.437
log
@taking xp away when killing guards,
making tsunami not affect guards
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.436 2004/09/01 04:42:52 boogums Exp $";
d147 1
a147 1
        act("$n asks $N for some quiet and fails!", ch,             NULL, victim, TO_ROOM, FALSE);
d186 1
@


1.436
log
@t crash bug fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.435 2004/09/01 02:35:01 boogums Exp $";
d3067 14
@


1.435
log
@t putting in cone of silence
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.434 2004/08/30 02:24:33 boogums Exp $";
a124 2
      if ( stone->pIndexData->vnum != 3149 )
      {
a126 1
      }
d139 5
a143 2
    send_to_char("A ball gag flares {Wbrightly{x and {YVANISHES{x!!!",ch);
    extract_obj(stone);
@


1.434
log
@trying more stuff
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.433 2004/08/30 02:18:35 boogums Exp $";
d145 1
a145 1
    if ( number_percent() > get_skill(ch,gsn_cone_of_silence) - number_range(10,20) )
@


1.433
log
@still more cone of silence
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.432 2004/08/30 00:10:22 boogums Exp $";
d123 1
a123 1
    if (stone == NULL || (stone->pIndexData->vnum != VNUM_SPELLCOMP_SILENCE || stone->pIndexData->vnum !=3149) )
d125 5
a129 2
      send_to_char("You lack the proper component to cast this spell.\n\r",ch);
      return;
@


1.432
log
@t moving moving movin
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.431 2004/08/30 00:04:25 boogums Exp $";
a115 2
    send_to_char("This spell is under construction\r\n.",ch);
    return;
d123 1
a123 1
    if (stone == NULL || stone->pIndexData->vnum != VNUM_SPELLCOMP_SILENCE )
a127 1

d142 1
a142 1
    if ( number_percent() < get_skill(ch,gsn_cone_of_silence) - (ch->level / 5) )
d145 2
a146 2
        act("$n chants and mumbles something about quiet.  You feel a brief tingling senstaion.",ch,             NULL, victim, TO_VICT, FALSE);
        act("You failed to wrap $N in a Cone of Silence.", ch,             NULL, victim, TO_CHAR, FALSE);
d149 1
a149 1
       if ( number_percent() < number_range(1,7) )
d168 2
a169 2
    //if ( !saves_spell(level,victim,DAM_MENTAL) )
    //{
a182 1
        
d184 1
a184 1
    //}
@


1.431
log
@tweaking tweaking tweaking
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.430 2004/08/29 23:54:17 boogums Exp $";
d116 3
@


1.430
log
@r BR says its' too poerfil
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.429 2004/08/29 22:50:14 boogums Exp $";
d139 1
a139 1
    act("$n flares brightly and vanishes!",ch,stone,NULL,TO_CHAR,FALSE);
d168 2
a169 2
    if ( !saves_spell(level,victim,DAM_MENTAL) )
    {
d185 1
a185 1
    }
@


1.429
log
@putting cone of silence in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.428 2004/08/27 12:58:13 boogums Exp $";
d149 1
a149 1
       if ( number_percent() < currentLevel + number_range(1,40) )
d157 1
a157 1
         af.duration         = level/10;
d162 1
a162 1
         send_to_char("The silence is deafening to your ears.\n\r",victim);
d174 1
a174 1
      af.duration         = level/20;
@


1.428
log
@cone of silence going in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.427 2004/08/26 01:30:26 boogums Exp $";
d139 4
a142 1
    if ( number_percent() >  get_skill(ch,gsn_cone_of_silence) - (ch->level / 5) )
d153 1
@


1.427
log
@adding cone of silence stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.426 2004/03/27 15:51:41 boogums Exp $";
d110 1
d112 1
d114 14
d138 2
a139 1
    if ( saves_spell(level,victim,DAM_MENTAL) )
d141 22
d164 3
d178 2
a179 1
        act("$N's looks confused and shrouded by silence.",ch,NULL,victim,TO_CHAR,FALSE);
@


1.426
log
@many changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.425 2004/02/04 02:53:02 boogums Exp $";
d108 16
d125 16
@


1.425
log
@taking out shapeshifter
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.424 2004/01/26 00:11:09 boogums Exp $";
d36 1
d3820 10
@


1.424
log
@ok made it extract the spyglass
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.423 2004/01/26 00:00:22 boogums Exp $";
d2170 1
d2182 2
@


1.423
log
@putting farsee back in
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.422 2003/10/01 00:14:12 ndagger Exp $";
d2910 4
a2931 1

@


1.422
log
@09/30/03 Nightdagger:  can't create node in main hall
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.421 2003/06/14 19:53:11 boogums Exp $";
d2875 16
a2890 2
 CHAR_DATA *victim = (CHAR_DATA *) vo;
 char  buf[MAX_STRING_LENGTH];
d2892 12
d2909 1
a2909 1

@


1.421
log
@adding the restrain spell to the infuse ability
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.420 2003/06/12 02:31:43 boogums Exp $";
d1212 1
a1212 1
      || (ch->in_room->clan && ch->in_room->clan != ch->clan ))
@


1.420
log
@tweaking perma holy
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.419 2003/06/10 01:34:14 boogums Exp $";
a3220 1

a3222 1

a3223 1

a3228 1

d3234 25
d3260 11
a3275 1

d3288 1
d3297 2
@


1.419
log
@cannot bestow holiness on a weapon more than once now
also added message to char when it blows
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.418 2003/06/08 22:03:32 boogums Exp $";
d1007 1
a1007 1
      if ( number_percent() != number_percent() )
@


1.418
log
@holyineess flag chance to be perm
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.417 2003/06/05 17:51:39 rusty Exp $";
d994 6
d1010 1
@


1.417
log
@compare correct args in shapemorph
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.416 2003/06/03 18:51:49 mud Exp $";
d991 1
a991 1
	send_to_char("You failed.\n\r",ch);
d999 18
a1016 1
    af.duration		= obj->value[4] == 0 ? level / 2 : level / 4;
@


1.416
log
@Logging shapemorph user and args
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.415 2003/06/03 18:34:12 rusty Exp $";
d2178 1
a2178 1
	if( ispunct(arg[i]) || arg[i] == '{' || isdigit(arg[i]) )
@


1.415
log
@FIxed shapemorph
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.414 2003/06/03 18:02:18 mud Exp $";
d2158 3
@


1.414
log
@Fixed shapeshift
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.413 2003/06/03 17:49:54 rusty Exp $";
d2172 10
d2183 1
a2183 1
   if( arg == '\0')
d2185 1
a2185 1
      send_to_char("You must supply a race to morph into.\n\r",ch);
a2211 9
   for( i=0 ; arg[i] != '\0' ; i++ )
   {
	if( ispunct(arg[i]) )
	{
	  send_to_char( "Oooh, you are so tricky aren't you?", ch);
	  return;
	}
   }

a2212 8

   /* This includes using color codes (ie: {xRusty )*/
   if( arg[0] == '{')
   {
     send_to_char( "Oooh, you are so tricky aren't you?", ch);
     return;
   }

@


1.413
log
@Fixed dam initialization before reduction
upped damage on all DOT spells.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.412 2003/06/03 02:57:27 boogums Exp $";
a2157 3
   send_to_char("We have a major shapemorph bug.  See an Admin if you want a refund for pracs, it may be awhile till it's fixed.\r\n",ch);
   return;

a2285 3
   send_to_char("Major shapeshift bug.  We are working on it.  See an Admin if you want a refund for the kit.\r\n",ch);
   return;

d2299 1
a2299 1
   if ( str_prefix(arg[0],"return"))
d2322 1
a2322 1
   race = race_lookup(argument);
@


1.412
log
@taking confusion out of demises setup as well as aura of cthon
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.411 2003/05/30 02:23:05 ndagger Exp $";
d4055 2
a4056 2
    af.location = 42;
    af.modifier = 42; /* 504/252/126 */
d4097 2
a4098 2
    af.location = 30;
    af.modifier = 30; /* 360/180/90 */
d4137 2
a4138 2
    af.location = 18;
    af.modifier = 18; /* 18x12 = 216 damage, 108 with sanc, 54 if caster not there */
d4184 2
a4185 2
    af.location = 54;
    af.modifier = 54;
d4245 2
a4246 2
	af.location		= level / 3;
	af.modifier		= level;
d4388 2
a4389 2
    af.location = level;
    af.modifier = 2*level;      /* 50 to 100! */
d4425 2
a4426 2
    af.location = level;
    af.modifier = 2*level;      /* 50 to 100! */
d4462 2
a4463 2
    af.location = level;
    af.modifier = 2*level;      /* 50 to 100! */
d4721 2
a4722 2
	af.modifier	= -1 * (level/10);
	af.location	= -1 * (level/5);
d5208 2
a5209 2
    af.location = 30;
    af.modifier = 30; /* 360/180/90 */
@


1.411
log
@05/29/03 Nightdagger:  All clan skills nerfed to prepare for new ones.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.410 2003/05/28 17:14:09 boogums Exp $";
a3160 3

    send_to_char("Sorry, this isn't a spell anymore\n\r",ch);
    return;
@


1.410
log
@yanking shapeshifter till we can get the bugs worked out
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.409 2003/05/25 17:41:45 boogums Exp $";
d3162 3
d3211 3
d3293 3
d3824 3
d3858 3
d5561 3
@


1.409
log
@damn bit vectors
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.408 2003/05/25 14:32:22 boogums Exp $";
d2158 4
d2288 4
@


1.408
log
@DOH damn bitvecotrs :)
orey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.407 2003/05/25 01:34:23 boogums Exp $";
d2091 1
a2091 1
    sn = skill_lookup("curse");
d2122 1
a2122 1
       if(!IS_SET(ch->mhs,MHS_CURSE))
d2133 1
@


1.407
log
@ok adding MHS_CURSE
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.406 2003/05/24 16:36:22 boogums Exp $";
d2122 1
a2122 1
       if(!IS_AFFECTED(ch,MHS_CURSE))
@


1.406
log
@t looking into shapeshifter
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.405 2003/05/19 03:20:34 ndagger Exp $";
d2122 1
a2122 1
       if(!IS_AFFECTED(ch,AFF_CURSE))
d2130 1
a2130 1
          af.bitvector = AFF_CURSE;
d2171 1
a2171 1
   if( arg[0] == '\0')
d2173 1
a2173 1
      send_to_char("You must supply a description to morph into.\n\r",ch);
@


1.405
log
@05/18/03 Nightdagger:  Fixed speed stacking bug.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.404 2003/03/12 04:02:36 boogums Exp $";
d2296 1
a2296 1
   if ( str_prefix(arg,"return"))
@


1.404
log
@shapeshift bug fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.403 2003/02/17 21:54:50 ndagger Exp $";
d68 6
@


1.403
log
@2/17/03 Nightdagger: basework for honor's clan skill, testing before wimpy changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.402 2002/11/15 02:26:52 boogums Exp $";
d2290 1
a2290 1
   if ( !str_prefix(arg,"return"))
d2296 1
@


1.402
log
@adding the aura of cthon skill for demise
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.401 2002/10/26 02:43:19 boogums Exp $";
d3822 36
@


1.401
log
@have a comment in comm.c interp.c dunnow what's going on and mag2.c
has the affects done
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.400 2002/10/20 00:46:27 boogums Exp $";
d5487 31
@


1.400
log
@ahhh effects.c touched that's right
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.399 2002/09/29 20:17:12 boogums Exp $";
d1500 1
a1500 1
/*    af.location		= APPLY_DEX;
d1505 1
a1505 1
*/
@


1.399
log
@testing new ID code oh and stalker code too
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.398 2002/09/27 04:17:54 boogums Exp $";
d1500 1
a1500 1
    af.location		= APPLY_DEX;
d1505 1
@


1.398
log
@still tweaking stalk
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.397 2002/09/27 04:05:30 boogums Exp $";
d5605 1
@


1.397
log
@tweaking stalk
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.396 2002/09/15 01:12:14 boogums Exp $";
d5584 8
d5597 1
a5597 1
    ||   saves_spell(ch->level-5,victim,DAM_OTHER) 
a5625 8
    af.where	= TO_AFFECTS;
    af.type	= sn;
    af.level	= 0;
    af.duration = 0;
    af.bitvector= 0;
    af.modifier = 0;
    af.location = APPLY_NONE;
    affect_to_char(ch, &af );
d5628 1
a5628 1
    if( saves_spell(ch->level-5,victim,DAM_OTHER) )
@


1.396
log
@stalk bug squashed, nobody yet bug hopefully gone too
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.395 2002/09/10 23:46:20 boogums Exp $";
d5530 6
a5535 1
    /*AFFECT_DATA af;*/
d5548 5
d5569 5
d5589 1
a5589 1
    ||   saves_spell(ch->level,victim,DAM_OTHER) 
d5604 4
a5607 1
	/*send_to_char( "You feel a shiver run down your spine.\n\r",victim);*/
a5609 5
    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not stalk.\n\r",ch);
       return;
    }
d5618 1
a5618 1
 /*   af.where	= TO_AFFECTS;
d5626 1
a5626 1
*/
d5628 1
a5628 1
    if( saves_spell(ch->level,victim,DAM_OTHER) )
@


1.395
log
@minor tweak to spell stalk, removed affect for now
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.394 2002/09/09 15:49:12 boogums Exp $";
d5589 1
a5589 1
	send_to_char( "You feel a shiver run down your spine.\n\r",victim);
@


1.394
log
@09sep02
cleaned up spell_stalk, got rid of the unused variables
took the pnet message out of hte die part of fight.c
to big of a potential for abuse
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.393 2002/09/09 07:33:56 ndagger Exp $";
d5530 1
a5530 1
    AFFECT_DATA af;
d5605 1
a5605 1
    af.where	= TO_AFFECTS;
d5608 1
a5608 1
    af.duration = ch->level / 10;
d5613 2
a5614 2

    do_look(ch,"auto");
@


1.393
log
@08/08/2002 Nightdagger:  Fixed creeping doom, was getting a whole mess of           spaces to char when casting spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.392 2002/09/09 07:24:35 ndagger Exp $";
a5529 4
    bool gate_pet;
    CHAR_DATA *fch=NULL;
    CHAR_DATA *fch_next;
    bool fHighlander = FALSE;
@


1.392
log
@09/09/2002 Nightdagger:  Added "creeping doom" spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.391 2002/09/08 19:06:21 ndagger Exp $";
d118 1
a118 1
        send_to_char("You unleash a stream of venemous spiders at your                  foe!\n\r", ch);
@


1.391
log
@09/08/2002 Nightdagger:  Added check to spell_annointment to make sure
   that Zealots who are sanctioned skill can't use it.09/08/2002 Nightdagger:  Added check to spell_annointment to make sure
   that Zealots who are sanctioned skill can't use it.09/08/2002 Nightdagger:  Added check to spell_annointment to make sure
   that Zealots who are sanctioned skill can't use it.09/08/2002 Nightdagger:  Added check to spell_annointment to make sure
   that Zealots who are sanctioned skill can't use it.09/08/2002 Nightdagger:  Added check to spell_annointment to make sure
   that Zealots who are sanctioned skill can't use it.09/08/2002 Nightdagger:  Added check to spell_annointment to make sure
   that Zealots who are sanctioned skill can't use it.09/08/2002 Nightdagger:  Added check to spell_annointment to make sure
   that Zealots who are sanctioned skill can't use it.09/08/2002 Nightdagger:  Added check to spell_annointment to make sure
   that Zealots who are sanctioned skill can't use it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.390 2002/09/06 20:18:41 boogums Exp $";
d101 40
@


1.390
log
@putting in the shadowstalker kit
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.389 2002/09/05 14:17:05 boogums Exp $";
d3757 7
@


1.389
log
@cleaning up sloppy code obs room was known as water plane in olc.c
merc.h has a space added to it
mag2.c has some work on stalking in it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.388 2002/09/01 14:55:07 boogums Exp $";
d5505 6
d5531 1
@


1.388
log
@tweaked the cuffs of justice affect when fleeing
tweaked out the stalk spell
testing on olc now
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.387 2002/07/01 00:51:40 boogums Exp $";
d5515 6
a5524 1
    ||   !can_see_room(ch,victim->in_room)
d5531 1
a5531 3
    ||   (victim->level >= ch->level + 8)
    /*||   (is_clan(victim) && !is_same_clan(ch,victim) && !is_same_group(ch,victim))*/
    ||   (!is_clan(victim) && is_clan(ch) && IS_SET(victim->act,PLR_NOSUMMON) )
a5532 4
    ||   (IS_NPC(victim) && IS_SET(victim->imm_flags,IMM_SUMMON))
    ||   (IS_NPC(victim) &&
          (IS_SET(victim->affected_by,AFF_CHARM) && victim->leader != ch))
    ||   (IS_NPC(victim) && saves_spell( level, victim,DAM_OTHER) )
@


1.387
log
@argh damn it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.386 2002/07/01 00:46:34 boogums Exp $";
d5505 10
a5538 5
             if( IS_NPC(victim) )
             {
                 send_to_char("Stalking a mob?  Get a life.\r\n",ch);
                 return;
             }
@


1.386
log
@DOH one must set victim before one IS_NPC's(victim)
confusious say
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.385 2002/07/01 00:26:20 boogums Exp $";
d5500 5
@


1.385
log
@ok adding the shadow stalker kit, to do some testing, will make
the kit live after tests
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.384 2002/06/29 03:41:31 boogums Exp $";
d5500 1
a5500 6
  if( IS_NPC(victim) )
  {
    send_to_char("Stalking a mob?  Get a life.\r\n",ch);
    return;
  }

d5524 5
@


1.384
log
@28JUL02
minor tweak to the cuffs of justice affect on fleeing
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.383 2002/04/27 02:16:03 boogums Exp $";
d5487 1
d5500 5
d5516 2
a5517 2
    ||   (victim->level >= ch->level + 3 && !is_same_clan(ch,victim) && !is_same_group(ch,victim))
    ||   (is_clan(victim) && !is_same_clan(ch,victim) && !is_same_group(ch,victim))
d5546 9
d5556 4
a5559 1

@


1.383
log
@26apr02
fixed bug in spirit of hte wolf
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.382 2002/04/11 03:42:07 boogums Exp $";
d5478 65
@


1.382
log
@cuffs of justice spell for posse is in, testing on olc now
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.381 2002/04/11 03:17:38 boogums Exp $";
d4978 1
a4978 1
    ch->skill_points -= (level/2);
@


1.381
log
@adding posse skill cuffs of justice
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.380 2002/03/11 08:15:48 rusty Exp $";
d3180 1
a3180 1

d3185 1
a3185 1
       sprintf(buf,"%s confuses the hell out of %s, they are walking in circles!
@


1.380
log
@Fuzzy'ed spell_aid()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.379 2002/03/09 19:14:28 rusty Exp $";
d3144 48
@


1.379
log
@Hiding information and reup_affect() additions. Initial
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.378 2002/02/28 19:19:13 rusty Exp $";
d928 1
a928 1
    af.modifier		= (victim->max_hit / 10 );
@


1.378
log
@communion helps a bit more in wrath spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.377 2002/02/11 20:28:35 poquah Exp $";
d69 1
a69 1
    if ( is_affected( victim, sn ) || IS_AFFECTED( victim, AFF_HASTE ) )
d77 8
d109 4
a112 4
	if ( victim == ch )
		send_to_char("You are already protected.\n\r",ch);
	else
		act("$N is already protected.",ch,NULL,victim,TO_CHAR,FALSE);
d138 4
a141 4
	if ( victim == ch )
		send_to_char("You can already see all.\n\r",ch);
	else
		act("$N can already see all.",ch,NULL,victim,TO_CHAR,FALSE);
d172 5
a176 5
        if ( victim == ch )
		send_to_char("You are already affected by this spell.\n\r",ch);
	else
		act("$N is already affected.",ch,NULL,victim,TO_CHAR,FALSE);
   	return;
a188 1
	
d452 1
a452 1
    if ( is_affected(victim,sn) )
d454 2
a455 1
	send_to_char("You are already imbued with enhanced casting.\n\r",ch);
d591 1
a591 1
    if ( is_affected(victim,sn) || saves_spell(level,victim,DAM_NEGATIVE) )
d597 9
d735 1
a735 1
    if ( is_affected(victim, sn) )
d737 5
a741 1
	send_to_char("You failed.\n\r",ch);
d745 2
d854 1
d856 2
a857 3
	    act("$N is already protected.",ch,NULL,victim,TO_CHAR,FALSE);
	else
	    send_to_char("You are already protected.\n\r",ch);
d916 4
a919 1
	send_to_char("You failed.\n\r",ch);
d1163 5
d1169 1
d1743 1
d1745 3
a1747 6
	    act("$N is already able to breathe underwater.",
			ch,NULL,victim,TO_CHAR,FALSE);
	    else
	    act("You already feel like a walleye.",
			ch,NULL,victim,TO_CHAR,FALSE);
	    return;
d1781 1
a1781 2
    if ( is_affected(victim,sn)  ||
	 victim->race == race_lookup("rockbiter") )
d1790 9
a2465 26

/*
void spell_burning_hands( int sn, int level, CHAR_DATA *ch, void *vo )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    static const sh_int dam_each[] = 
    {
   0,
   0,  0,  0,  0, 14, 17, 20, 23, 26, 29,
  29, 29, 30, 30, 31, 31, 32, 32, 33, 33,
  34, 34, 35, 35, 36, 36, 37, 37, 38, 38,
  39, 39, 40, 40, 41, 41, 42, 42, 43, 43,
  44, 44, 45, 45, 46, 46, 47, 47, 48, 48
    };
    int dam;

    level = UMIN(level, sizeof(dam_each)/sizeof(dam_each[0]) - 1);
    level = UMAX(0, level);
    dam   = number_range( dam_each[level] / 2, dam_each[level] * 2 );
    if ( saves_spell( level, victim ) )
  dam /= 2;
    damage( ch, victim, dam, sn, DAM_FIRE ,TRUE);
    return;
}
 */

d2922 3
a2924 5
    {                                                                           
        if ( victim != ch )                                                     
            act("$N is already affected.",ch,NULL,victim,TO_CHAR,FALSE);
        else                                                                    
            act("You are already enhanced.",ch,NULL,victim,TO_CHAR,FALSE);
d3223 3
a3225 2
   send_to_char("You have already been granted an indulgence.\n\r", ch);
   return;
d4552 3
a4554 1
	send_to_char("You failed.\n\r",ch);
d5301 3
a5303 1
        send_to_char("You failed.\n\r",ch);
@


1.377
log
@message when fail into beast state in morph
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.376 2002/01/26 16:25:27 rage Exp $";
d482 1
a482 1
    dam /= ( 100 - (get_skill(ch,gsn_communion)/5) );
@


1.376
log
@whole mess of bug fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.375 2001/12/06 18:31:51 rage Exp $";
d2024 2
a2025 2
    send_to_char( "You transform into a beast state.\n\r", ch );
    dur = number_range(4,5);
d2027 9
a2035 21
  check_improve(ch,gsn_morph,TRUE,3);
  af.where     = TO_AFFECTS;
  af.type      = gsn_morph;
  af.level     = ch->level;
  af.duration  = dur;
  af.location  = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = AFF_MORPH;
  affect_to_char( ch, &af );

  if(!IS_AFFECTED(ch,AFF_CURSE))
    {
     af.where     = TO_AFFECTS;
     af.type      = sn;
     af.level     = 2*ch->level;
     af.duration  = dur;
     af.location  = APPLY_NONE;
     af.modifier  = 0;
     af.bitvector = AFF_CURSE;
     affect_to_char( ch, &af );
    }
d2037 11
d2050 4
a2053 1
  check_improve(ch,gsn_morph,FALSE,3);
@


1.375
log
@bug fix in kill updates
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.374 2001/11/24 15:09:57 rage Exp $";
d1612 1
a1612 1
       if ( is_safe_spell(ch,vch,TRUE) ||
d1677 1
a1677 1
	     is_safe_spell(ch,vch,TRUE) ||
d1819 1
a1819 1
       if ( is_safe_spell(ch,vch,TRUE) ||
d2762 1
a2762 1
      && !is_safe_spell(ch,vch,FALSE) )
d2850 1
a2850 1
          if ( vch == ch || is_safe_spell(ch,vch,TRUE))
d4058 1
a4058 1
	if ( is_safe_spell( ch, vch, TRUE ) || is_affected(vch,sn)
@


1.374
log
@fix bug with newbie flag
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.373 2001/11/16 00:32:19 rage Exp $";
d5371 2
@


1.373
log
@added in water segment effects
modified water king special to flee more reliably
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.372 2001/11/11 23:48:17 rage Exp $";
a5339 1
  bool found = TRUE;
@


1.372
log
@first try at spec_water_king
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.371 2001/11/11 17:29:11 rage Exp $";
d309 4
@


1.371
log
@made some changes to wall of ice, spec_elemental_water, hydrophilia
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.370 2001/11/11 02:08:39 rage Exp $";
d5325 2
a5326 2
   act("$p slowly disappears", ch, NULL, wall, TO_ROOM, FALSE);
   act("$p slowly disappears", ch, NULL, wall, TO_CHAR, FALSE);
d5383 1
a5383 1
        if ( IS_SET(victim->vuln_flags, VULN_DROWNING))
d5401 1
a5401 1
        af.bitvector            = VULN_DROWNING;
@


1.370
log
@one last bug fix for wall of ice
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.369 2001/11/11 02:04:41 rage Exp $";
d3844 1
d5324 3
a5328 3
   raffect_remove(ch->in_room, paf);
   act("$p slowly disappears", NULL, NULL, wall, TO_ROOM, FALSE);
   act("$p slowly disappears", NULL, NULL, wall, TO_CHAR, FALSE);
d5339 7
d5361 1
d5367 39
@


1.369
log
@final version of wall of ice
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.368 2001/11/11 01:25:15 rage Exp $";
d5327 1
a5327 1
   act("$p slowly disappears", ch, NULL, wall, TO_CHAR, FALSE);
@


1.368
log
@second try at wall of ice
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.367 2001/11/11 01:01:13 rage Exp $";
d5327 1
@


1.367
log
@first insertion of wall of ice spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.366 2001/10/20 19:40:44 rage Exp $";
d5337 1
a5337 3
  do
  {
  door = number_door( );
d5339 4
a5342 3
     found = FALSE;
  }while(!found);
  
@


1.366
log
@removed code_test ifdefs around random exits code
paladins can now take battlerager
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.365 2001/10/18 23:35:36 rage Exp $";
d5304 1
a5304 1
   if( !is_room_affected(ch->in_room, gsn_wall_fire))
d5313 1
d5329 1
a5329 1
/*void spell_wall_of_ice( int sn, int level, CHAR_DATA *ch, void *vo, int target)
d5331 1
a5331 1
 EXIT_DATA *pexit;
d5333 3
d5337 2
d5340 21
a5360 6
  if ( ( pexit = ch->in_room->exit[door] ) == 0
  ||   pexit->u1.to_room == NULL
  ||   pexit->u1.to_room->clan
  ||   IS_SET(pexit->exit_info, EX_CLOSED))
      continue;
*/
@


1.365
log
@bug fix for dispel wall
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.364 2001/10/18 23:20:34 rage Exp $";
d1725 1
a1725 1
    if ( ch->level > 35 
d5325 1
d5327 14
@


1.364
log
@added dispel wall spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.363 2001/10/18 19:43:57 rage Exp $";
d5300 1
a5300 1
   OBJ_DATA *wall = (OBJ_DATA *) vo;
d5302 2
a5303 1
 
d5314 7
@


1.363
log
@added some functionality for the fire segment
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.362 2001/10/14 04:08:44 rage Exp $";
d3802 1
a3802 1
    	af.duration		= level /17; 
d5314 2
@


1.362
log
@added some stuff for water elemental stuff
small change to wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.361 2001/10/13 02:11:59 rage Exp $";
d271 3
a273 1
   int t,count, number = 0;
@


1.361
log
@Bug fixes as follow

can no longer drag furniture that's being used
steal/slice kr only increments on players
IMMs now immune to sector damage
die command should work now
spec_average now has an IS_AWAKE check
Cavalier attack is now given to groupmates
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.360 2001/10/12 17:37:25 rage Exp $";
d271 1
a271 1
   int t,count, number;
d3816 1
d3833 2
d5296 15
d5312 2
@


1.360
log
@bug fix for symbol/aid put back in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.359 2001/10/05 18:09:38 rage Exp $";
d270 1
d301 11
a311 1
   number = number_percent();
@


1.359
log
@bug fix for annointment...if two zealots both affected, and one casts on the other, we go poof with buffer overflows
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.358 2001/08/24 00:42:18 guerrand Exp $";
d3795 3
@


1.358
log
@Medium kit coded.  Adjusted skill point cost for spirit caller.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.357 2001/08/19 20:46:00 guerrand Exp $";
d614 1
a614 1
    if( is_affected(victim,skill_lookup("annointment")) && victim != ch )
d649 1
a649 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d685 1
a685 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d764 1
a764 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d1080 1
a1080 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d1522 1
a1522 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d1676 1
a1676 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
@


1.357
log
@Sonic blast stun % changed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.356 2001/08/05 23:18:09 guerrand Exp $";
d4752 1
a4752 1
    if ( ch->skill_points < (level/5) )
d4758 1
a4758 1
    ch->skill_points -= (level/5);
d4785 1
a4785 1
    if ( ch->skill_points < (level/5) )
d4791 1
a4791 1
    ch->skill_points -= (level/5);
d4818 1
a4818 1
    if ( ch->skill_points < (level/5) )
d4824 1
a4824 1
    ch->skill_points -= (level/5);
d4851 1
a4851 1
    if ( ch->skill_points < (level/5) )
d4857 1
a4857 1
    ch->skill_points -= (level/5);
d4885 1
a4885 1
    if ( ch->skill_points < (level/2) )
@


1.356
log
@Shamans cast their disease spells at +2 levels hard
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.355 2001/08/05 22:47:36 guerrand Exp $";
a4492 5
    /* Damage will be around 230 average.  best case, *= 4, worse, *= 1 */
    /* Best: 200%   Worst: 25% Average: 50-60% */
    chance *= UMAX( 1 , ( dam / 100 ) );

    /* Best: 200%  Worst: 12%  Avergae: 25-30% */
@


1.355
log
@Added 5 spells for warlock/witch kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.354 2001/08/04 16:03:02 guerrand Exp $";
d3841 1
a3841 1
    if ( saves_spell(level,victim,DAM_DISEASE) || is_affected(victim,sn) )
d3882 1
a3882 1
    if ( saves_spell(level,victim,DAM_DISEASE) || is_affected(victim,sn) )
d3923 1
a3923 1
    if ( saves_spell(level,victim,DAM_DISEASE) || is_affected(victim,sn) )
d3970 1
a3970 1
    if ( saves_spell(level,victim,DAM_DISEASE) || is_affected(victim,sn) )
@


1.354
log
@Finished midnight cloak - returns hp when you strike.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.353 2001/08/04 15:54:47 guerrand Exp $";
a3840 1

d5180 105
@


1.353
log
@IMMs no longer show up when wizi and entering portals.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.352 2001/08/03 03:18:36 guerrand Exp $";
d5171 3
a5173 3
    af.duration         = 2 + ( HAS_KIT(ch,"necromancer") ? 2 : 0 ) + ( time_info.hour == 0 ? 2 : 0 );
    af.modifier         = 0;
    af.location         = 0;
@


1.352
log
@Added 'midnight cloak', which doesn't do anything yet.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.351 2001/08/03 02:24:30 boogums Exp $";
d5162 1
a5162 1
    if ( is_affected(victim,sn) || time_info.hour != 0 )
d5171 1
a5171 1
    af.duration         = 2 + ( HAS_KIT(ch,"necromancer") ? 2 : 0 );
@


1.351
log
@ok now putting scribed spells and goodies back in the game
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.350 2001/08/02 02:12:09 guerrand Exp $";
d111 1
a111 1
    af.duration		= level/17 ; 
d5157 24
@


1.350
log
@Improved 'restore mana' potion a little.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.349 2001/07/31 02:48:16 boogums Exp $";
d4945 23
@


1.349
log
@ok for some reason the magus knowledge spell was freaking every thing out
i've yanked it and will add more spells later as time permits
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.348 2001/07/31 01:11:37 boogums Exp $";
d57 1
a57 1
   restore = dice( (level / 2) , 2 );
@


1.348
log
@Ok added four new spells and tweaked do_scribe a bit
hope this woirks
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.347 2001/07/30 04:51:49 guerrand Exp $";
a4943 18
}

void spell_scribe_knowledge( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;

	if (saves_spell(level, victim, DAM_MENTAL) )
	{
                send_to_char("ARGH!!! Thar be tygers 'ere!!!\r\n",victim);
                return;
	}
	else
	{
		send_to_char("You feel more skillful.\r\n",victim);
		ch->skill_points += 10;
		return;
	}

@


1.347
log
@Damage shield spells added.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.346 2001/07/27 03:03:20 guerrand Exp $";
d4913 126
a5150 3



@


1.346
log
@Fixed duration on spirit of wolf.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.345 2001/07/27 02:35:02 guerrand Exp $";
d4912 114
@


1.345
log
@FIxed a few bugs with spirit caller.  Otherwise, it looks like it's all et.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.344 2001/07/27 02:14:11 guerrand Exp $";
d4902 1
a4902 1
    af.duration         = (level/10);
@


1.344
log
@Added spirit caller kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.343 2001/07/25 18:27:44 rage Exp $";
d4770 1
a4770 1
    af.modifier         = (level/5);
d4803 1
a4803 1
    af.modifier         = (level/5);
d4836 1
a4836 1
    af.modifier         = (level/5);
d4869 1
a4869 1
    af.modifier         = (level/5);
d4902 1
a4902 1
    af.duration         = (level/5);
@


1.343
log
@fixed bug in double xp
more changes to spec_king functionality
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.342 2001/07/15 23:42:38 guerrand Exp $";
d4746 167
@


1.342
log
@Bug fixed for skellies
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.341 2001/07/12 00:25:55 rage Exp $";
d3789 1
a3789 1
    	af.duration		= IS_SET(ch->mhs, MHS_ELEMENTAL) ? level /10 : level /17; 
@


1.341
log
@bug fix in wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.340 2001/07/04 15:22:24 guerrand Exp $";
d271 3
@


1.340
log
@Symbols don't stack, duration fixed.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.339 2001/07/04 04:24:15 guerrand Exp $";
d3824 1
@


1.339
log
@Cleric spells: Symbol I through IV
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.338 2001/07/04 01:36:41 guerrand Exp $";
d4604 9
a4620 6
    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

d4623 2
a4624 2
    af.level            = level;
    af.duration         = level*2;
d4640 9
a4656 6
    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

d4659 2
a4660 2
    af.level            = level;
    af.duration         = level*2;
d4676 9
a4692 6
    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

d4695 2
a4696 2
    af.level            = level;
    af.duration         = level*2;
d4712 9
a4728 6
    if ( is_affected(victim,sn) )
    {
        send_to_char("You failed.\n\r",ch);
        return;
    }

d4731 2
a4732 2
    af.level            = level;
    af.duration         = level*2;
@


1.338
log
@Scrapped wraith fix 1.0 and tried again.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.337 2001/07/04 01:21:57 guerrand Exp $";
d4598 133
@


1.337
log
@Extensive changes to wraithform to have it proc after the timer expires.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.336 2001/07/03 03:28:49 guerrand Exp $";
d3568 1
a3568 3
     victim->pcdata->pulse_union.wraith.wraith_timer = 48;
     victim->pcdata->pulse_union.wraith.level = level;
     victim->pcdata->action_function = action_wraithform;
a3582 2
  victim->pcdata->action_function = NULL;

d3585 2
a3586 2
  af.level     = victim->pcdata->pulse_union.wraith.level;
  af.duration  = victim->pcdata->pulse_union.wraith.level *3/4;
@


1.336
log
@New druid spell - acclimate.
Kurjitsu will kick in a tad more often.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.335 2001/06/28 04:21:52 guerrand Exp $";
d35 1
a3551 1
  AFFECT_DATA af;
d3565 22
a3586 1
  WAIT_STATE(ch,48);
d3588 3
a3590 3
  af.type      = sn;
  af.level     = level;
  af.duration  = level*3/4;
d3600 1
@


1.335
log
@Added burn for component of phoenix spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.334 2001/06/28 03:41:34 guerrand Exp $";
d4553 25
@


1.334
log
@Fixed spirit of phoenix crash bug.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.333 2001/06/24 04:14:58 guerrand Exp $";
d3691 1
a3691 1
    if (feather != NULL &&  feather->pIndexData->vnum != OBJ_VNUM_FEATHER )
@


1.333
log
@Research adept is 95%, goes up1%per practice.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.332 2001/06/24 01:27:38 guerrand Exp $";
d3685 1
a3685 1
    if ( !IS_IMMORTAL(ch) && feather->pIndexData->vnum != OBJ_VNUM_FEATHER )
@


1.332
log
@Changed Shaman DOTs around, fixed MudTrader.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.331 2001/06/23 19:12:04 guerrand Exp $";
d3965 1
a3965 1
    af.duration = 18;   /* 3 minutes of damage */
@


1.331
log
@Added incinerate spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.330 2001/06/22 23:45:55 guerrand Exp $";
a3825 3
    /* Caps at 45 */
    level = UMIN(level,45);

d3837 2
a3838 2
    af.location = level;
    af.modifier = 2*level;	/* 50 to 100! */
a3866 2
    level = UMIN(level,40);
    /* Little less than fireball damage, but nice at 51 */
d3879 2
a3880 2
    af.location = 2  *level / 3;	/* 33 to 75 damage at 51 */
    af.modifier = 3 * level / 2;
a3907 3
    /* CAps at 35 */
    level = UMIN(level,35);

d3919 2
a3920 2
    af.location = level / 2;    /* 25 to 51 damage at 51 */
    af.modifier = level;
a3954 2
    level = UMIN(50,level);

d3966 2
a3967 2
    af.location = 3 * level / 2;    /* 75 to 200 damage */
    af.modifier = level * 4;
@


1.330
log
@Added adamantite skin
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.329 2001/06/19 06:04:25 guerrand Exp $";
d4550 13
@


1.329
log
@Fixed typo in regen
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.328 2001/06/19 05:00:40 guerrand Exp $";
d4360 2
a4361 1
    if ( is_affected(victim,sn) || is_affected(victim,gsn_steel_skin) || is_affected(victim,gsn_stone_skin) )
d4386 2
a4387 1
    if ( is_affected(victim,sn) || is_affected(victim,gsn_diamond_skin) || is_affected(victim,gsn_stone_skin)  )
d4526 27
@


1.328
log
@New spell for cleric/crus/monk/pal/druid: regeneration.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.327 2001/06/18 04:31:09 guerrand Exp $";
d4521 1
a4521 1
    act("Appears vigorous and healthy.",victim,NULL,NULL,TO_ROOM,FALSE);
@


1.327
log
@Added sunburst and sonic blast.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.326 2001/06/18 01:17:33 rage Exp $";
d4497 25
@


1.326
log
@ Initial insertion of forging items.  Added new item type ITEM_FORGE.
 One can create "recipes" for these forges.  Each recipe is a list of
 objects that once placed inside the forge will create a bigger/better
 object.  Basically a better implementation of item parts.

-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.325 2001/06/18 00:49:51 guerrand Exp $";
d4420 78
@


1.325
log
@Added vision ot shamans, removed bug where melees would follow wraith'd
people around.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.324 2001/06/18 00:39:30 guerrand Exp $";
d4300 1
a4300 1
	     (IS_NPC(gch))  )
d4315 4
d4320 1
a4320 1
			gch->fighting = ch->fighting;
d4324 1
a4324 1
		act("$n betrays $n!\n\r", gch, NULL, victim, TO_NOTVICT, FALSE);
d4405 16
@


1.324
log
@Another update to drachlan shaman logic.  Removed stone skin.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.323 2001/06/17 19:20:47 guerrand Exp $";
d151 1
a151 1
act("$N is betstowed with the gift of vision.",ch,NULL,victim,TO_CHAR,FALSE);
@


1.323
log
@Changed levels so it goes like this:
 25 stone skin
 35 steel skin
 45 diamond skin

They don't stack.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.322 2001/06/17 18:53:41 guerrand Exp $";
d4366 1
a4366 1
    af.modifier         = get_curr_stat(victim,STAT_CON) * 3;
d4391 1
a4391 1
    af.modifier         = get_curr_stat(victim,STAT_CON) * 2;
@


1.322
log
@Added steel skin and diamond skin for mage/wizard
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.321 2001/06/17 17:06:00 guerrand Exp $";
d4356 1
a4356 1
    if ( is_affected(victim,sn) || is_affected(victim,gsn_steel_skin) )
d4381 1
a4381 1
    if ( is_affected(victim,sn) || is_affected(victim,gsn_diamond_skin) )
@


1.321
log
@Fixed the haste bug in shaman drachlan special.
Added healing DOt functionality.
Added 'shield of faith' spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.320 2001/06/17 01:47:21 guerrand Exp $";
d4348 50
@


1.320
log
@Harder to teleport now through curse.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.319 2001/06/16 15:51:16 rage Exp $";
d4325 26
@


1.319
log
@More fixes to betray
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.318 2001/06/16 15:49:31 rage Exp $";
d80 1
a80 1
    af.duration		= level/17 +1;
@


1.318
log
@fixes to betray spell
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.317 2001/06/16 15:24:14 rage Exp $";
d4315 1
a4315 1
			ch->fighting = victim
@


1.317
log
@added spell betrayal - causes skellies etc to betray their master and fight forh the other side
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.316 2001/06/15 03:08:11 guerrand Exp $";
d4314 2
d4317 2
a4318 1
	
d4320 1
a4320 1
		act("$n betrays $n!\n\r", gch, victim, NULL, TO_NOTVICT, FALSE);
@


1.316
log
@More improvements to drachlans
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.315 2001/06/15 01:27:50 guerrand Exp $";
d4266 55
@


1.315
log
@Added tyhree new NPC spells, one fire, one frist, one elcetrocution.
Used by drachlans.  Improved Drachlan AI somewhat for shamans.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.314 2001/06/14 01:03:27 guerrand Exp $";
d4023 2
a4024 1
	if ( is_safe_spell( ch, vch, TRUE ) || is_affected(vch,sn))
@


1.314
log
@Two new spells:
'remove disease' and 'remove poison' which work only on disease and poison dots
respectievly.  Only way to eliminate dots.  May take multiple castings.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.313 2001/06/13 03:47:56 guerrand Exp $";
d4156 110
@


1.313
log
@VHAN special for Altirin.
Including new venom of vhan spell!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.312 2001/06/11 04:44:49 guerrand Exp $";
d4083 73
@


1.312
log
@Coded thunderclap spell.
GMAN.
Area affect DOT. Low power.  90 mana.  24 delay.  level 49.  Ele only.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.311 2001/06/11 04:22:38 guerrand Exp $";
d4049 34
@


1.311
log
@Fixed a little elementalist bug thereby they did 5000 damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.310 2001/06/11 01:17:01 rage Exp $";
d4011 38
@


1.310
log
@added new spell "blade barrier"
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.309 2001/06/10 04:33:36 guerrand Exp $";
a1410 7
    affect_to_char(victim,&af);

    af.where		= DAMAGE_OVER_TIME;
    af.location		= level / 2;
    af.modifier		= level;
    af.duration		= 6;
    af.bitvector	= DAM_ENERGY;
@


1.309
log
@Added a DOT to irraddiate to test it amongst the people.  Low-power DOT.
It does 25-50 damage over 1 minute (6 hits).
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.308 2001/06/10 04:22:27 guerrand Exp $";
d3998 17
d4016 2
@


1.308
log
@Guerrand

The last fixes for DOTs are in.

1. The initial DOT damage may kill somebody.  If this happens, the
spell wil exit and not add the affect on.

2. The dot function in magic.c sends a special constant to damage( )
that tells it not to initiate combat based on this damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.307 2001/06/09 19:34:46 guerrand Exp $";
d1413 7
d3827 1
a3827 1
    if ( saves_spell(level,victim,DAM_DISEASE) )
a3829 2
	if ( victim != ch )
	    send_to_char("Your body shivers as flash of heat overcomes you.\n\r",victim);
d3871 1
a3871 1
    if ( saves_spell(level,victim,DAM_DISEASE) )
a3873 2
        if ( victim != ch )
            send_to_char("You shudder as your heart constricts briefly.\n\r",victim);
d3914 1
a3914 1
    if ( saves_spell(level,victim,DAM_DISEASE) )
a3916 2
        if ( victim != ch )
            send_to_char("You briefly feel sick and weak.\n\r",victim);
d3964 1
a3964 1
    if ( saves_spell(level,victim,DAM_DISEASE) )
a3966 2
        if ( victim != ch )
            send_to_char("You manage to throw off the Scourge.\n\r",victim);
@


1.307
log
@GMAN
Some more bug cleanup work.  Trying to eliminate the problem with getting
battle prompts when DOT'd.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.306 2001/06/09 18:48:47 guerrand Exp $";
d3835 5
d3881 5
d3926 5
d3976 5
@


1.306
log
@GMAN
	Added 'scourge' and 'contagion' to round out the spell list for Shamans.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.305 2001/06/09 04:18:23 guerrand Exp $";
d3819 1
d3828 3
d3869 1
d3871 1
d3909 4
a3912 1
    dam = number_range( 3 * UMIN(level,40) / 2 , UMIN(level,40) * 4 );
d3955 2
@


1.305
log
@Added a new spell: 'blight'.
Level 26, does damage comprable to fireball, plus DOT, but costs 75 mana.
Adjusted 'boiling blood'.
Level 36, does damage comprable to acid blast, plus DOT, but coss 75 mana also.
Both are 2-round delay spells.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.304 2001/06/09 03:57:00 guerrand Exp $";
d3833 2
a3834 2
    af.location = 3*level/2;
    af.modifier = 3*level;	/* 75 to 400! */
d3872 2
a3873 2
    af.location = level;	/* 51 to 102 damage at 51 - NIC! */
    af.modifier = level * 2;
d3885 81
@


1.304
log
@GMAN!
1. Changed 'affect' command to show duration for dots correctly.
2. Removed unused variable in mag2.c
3. Added a long field to affects called 'caster_id'
4. Added a lookup function called 'get_char_by_id' to handler.c
5. Added a call to get_char_by_id to dot in magic.c to find the caster
6. WE can now track the caster of a spell.

To do: check for a 0 ID and ignore it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.303 2001/06/09 01:25:33 guerrand Exp $";
d3811 2
a3812 1
	
d3823 1
a3823 1
	    send_to_char("You body shivers as flash of heat overcomes you.\n\r",victim);
d3827 1
a3827 1
    dam = dice(level/2,level/3); /* Half the damage of ice storm */
d3833 2
a3834 2
    af.location = level/3;
    af.modifier = level/4;
d3848 40
@


1.303
log
@Fixed two bugs in DOTs.  One was a post-decrement where we wanted a pre.
The other was a typo in an 'act'.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.302 2001/06/09 01:10:52 guerrand Exp $";
a3778 1
	OBJ_DATA *wall;
d3837 1
@


1.302
log
@GMAN
Added the first test DOT: boiling blood.
It will eventually go into a 'shaman' kit with some other DOT spells.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.301 2001/06/07 22:30:00 rage Exp $";
d3842 1
a3842 1
    act("$n screams in unimaginable pain as $S skin blisters and $S blood boils.",
@


1.301
log
@Fixed up "Assemble" function a bit
Added in spells flameseek and started on wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.300 2001/06/03 14:42:08 mud Exp $";
d3813 34
@


1.300
log
@added lookup.h include ot eliminate compile time warning
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.299 2001/06/03 14:40:27 rusty Exp $";
d3740 73
@


1.299
log
@annointment +2 bounce back on casting level forgtten in
original implementation.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.298 2001/06/02 18:47:10 guerrand Exp $";
d33 1
@


1.298
log
@GMAN
Fix for amulet level
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.297 2001/06/02 17:32:26 guerrand Exp $";
d614 1
a614 1
        spell_fumble(sn,level,victim,ch,target);
d649 1
a649 1
        spell_feeblemind(sn,level,victim,ch,target);
d685 1
a685 1
        spell_forget(sn,level,victim,ch,target);
d764 1
a764 1
        spell_hold_person(sn,level,victim,ch,target);
d1080 1
a1080 1
        spell_asphyxiate(sn,level,victim,ch,target);
d1522 1
a1522 1
        spell_earthbind(sn,level,victim,ch,target);
d1676 1
a1676 1
        spell_dust_storm(sn,level,victim,ch,target);
@


1.297
log
@GMAN - fixed a typo
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.296 2001/06/02 17:30:06 guerrand Exp $";
d3731 1
@


1.296
log
@GMAN

Some neat stuff.
1. New spell: spirit of phoenix.  It's a long sanc/withstand death combo for 250 mana.
2. But the point of the spell isn't the affect, it's the side affect -
	a. the component will sometimes turn to ashes, which are a key you need to
	   get into the palace in Altirin.
	b. if the spell is cast in a superior magelab at midnight, the caster gets
	   an 'Amulet of the Phoenix', which is a really nice item.
3. New special: phoenix, for a phoenix mob that moves around like puff.  It has on
it the material component for the phoenix spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.295 2001/06/01 03:17:00 guerrand Exp $";
d3677 1
a3677 1
void spell_spirit_of_phoenix(int sn,int level,CHAR_DATA *ch, void *vo, int target)
@


1.295
log
@GMAN
Changed mistform, fixed a bug, added some cosmetic echoes.
Improved the duration.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.294 2001/05/28 17:55:34 rusty Exp $";
d3674 62
@


1.294
log
@annoinment checks not looping if victim == ch
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.293 2001/05/27 22:05:34 rusty Exp $";
d1121 1
a1121 1
    af.duration		= level / 2;
@


1.293
log
@annointment message to victim as well as ch (instead of double
to ch)
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.292 2001/05/27 20:04:14 mud Exp $";
d609 1
a609 1
    if( is_affected(victim,skill_lookup("annointment")) )
d644 1
a644 1
    if(is_affected(victim,skill_lookup("annointment")) )
d680 1
a680 1
    if(is_affected(victim,skill_lookup("annointment")))
d759 1
a759 1
    if(is_affected(victim,skill_lookup("annointment")))
d1075 1
a1075 1
    if(is_affected(victim,skill_lookup("annointment")))
d1517 1
a1517 1
    if(is_affected(victim,skill_lookup("annointment")))
d1671 1
a1671 1
    if(is_affected(victim,skill_lookup("annointment")))
@


1.292
log
@Missing )'s fixed for annointment
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.291 2001/05/27 19:56:04 rusty Exp $";
d611 1
a611 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d646 1
a646 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d682 1
a682 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d761 1
a761 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d1077 1
a1077 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d1519 1
a1519 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d1673 1
a1673 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
@


1.291
log
@Added Zealot clan skill "annointment"
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.290 2001/03/19 21:04:06 mud Exp $";
d603 1
d605 1
d607 1
d609 1
a609 1
    if(is_affected(victim,skill_lookup("annointment"))
d616 1
d644 1
a644 1
    if(is_affected(victim,skill_lookup("annointment"))
d680 1
a680 1
    if(is_affected(victim,skill_lookup("annointment"))
d759 1
a759 1
    if(is_affected(victim,skill_lookup("annointment"))
d1075 1
a1075 1
    if(is_affected(victim,skill_lookup("annointment"))
d1517 1
a1517 1
    if(is_affected(victim,skill_lookup("annointment"))
d1671 1
a1671 1
    if(is_affected(victim,skill_lookup("annointment"))
@


1.290
log
@fix number counts
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.289 2001/03/10 22:33:31 mud Exp $";
d605 8
d639 9
d675 9
d755 8
d1071 8
d1513 8
d1667 8
d3646 24
@


1.289
log
@remove old weight of corpse and add weight of bag
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.288 2001/03/10 22:09:17 mud Exp $";
d3565 1
d3585 1
@


1.288
log
@remove comment line doing return at start of bag
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.287 2001/03/10 21:23:40 mud Exp $";
d3563 2
d3581 3
@


1.287
log
@removed free_strings from make_bag
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.286 2001/03/10 17:38:16 mud Exp $";
a3526 2
       send_to_char("This spell isn't working.\n\r",ch);
	return;
@


1.286
log
@Added an immediate return; in spell_make_bag() as it's broken
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.285 2001/03/10 16:15:38 mud Exp $";
d3547 2
a3548 1
   	  free_string( obj->name );
d3553 2
a3554 1
	  free_string( obj->description );
d3558 2
a3559 1
          free_string( obj->short_descr );
@


1.285
log
@add a beta name to bags so I can track them for changes if its a mess
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.284 2001/03/10 16:02:45 mud Exp $";
d3527 2
@


1.284
log
@force emptying corpses before making bag
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.283 2001/03/10 15:57:05 mud Exp $";
d3544 1
a3544 1
          sprintf( buf, "bag %s", obj->short_descr+len );
d3567 1
a3567 1
    obj->value[0] = level * 20;                 /* Weight capacity */
@


1.283
log
@empty out a corpse before making a bag out of it
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.282 2001/03/10 15:29:30 mud Exp $";
a3523 2
    OBJ_DATA *obj2;
    OBJ_DATA *obj_next2;
d3528 2
d3531 1
d3533 1
a3533 3
    /* empty out the contents so they dont get lost */

    for ( obj2 = obj->contains; obj2 != NULL; obj2 = obj_next2 )
d3535 2
a3536 2
        obj_next2 = obj2->next_content;
        get_obj( ch, obj2, obj );
@


1.282
log
@remove debug lines and change syntax on restringing
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.281 2001/03/10 15:10:18 mud Exp $";
d3524 2
d3531 8
@


1.281
log
@add 'the corpse of' to headers in make bag
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.280 2001/03/10 15:04:52 mud Exp $";
a3534 1
    send_to_char( "changing descr.\n\r", ch );
d3544 1
a3544 1
          sprintf( buf, "bag made from %s hide", obj->short_descr+len );
a3548 6
       }
       else
       {
       sprintf(buf,"not changing desc %i %i.\n\r",i,len);
    send_to_char( buf, ch );

@


1.280
log
@debug lines to find out why make bag isnt changing descrps
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.279 2001/03/10 14:54:45 mud Exp $";
d3521 1
@


1.279
log
@use vnum 1258 for the generic vnum for the bag
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.278 2001/03/10 14:35:13 mud Exp $";
d3534 1
d3549 6
@


1.278
log
@fix void declare on make bag
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.277 2001/03/10 14:31:20 mud Exp $";
d3562 1
a3562 1
    obj->pIndexData = get_obj_index( 5660 );    /* So it's not a corpse */
@


1.277
log
@missing extra field on act
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.276 2001/03/10 14:26:31 mud Exp $";
d3516 1
a3516 1
void spell_make_bag( int sn, int level, CHAR_DATA *ch, void *vo )
@


1.276
log
@make bag spell for testing
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.275 2001/03/03 19:13:26 mud Exp $";
d3564 2
a3565 2
    act( "Your new $p looks pretty snazzy.", ch, obj, NULL, TO_CHAR );
    act( "$n's new $p looks pretty snazzy.", ch, obj, NULL, TO_ROOM );
@


1.275
log
@changed var "damage" to "dam" to not step on damage() function call.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.274 2001/03/03 18:53:58 mud Exp $";
d3516 54
@


1.274
log
@Took out all references to damage_old() and used iOld var in damage()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.273 2000/12/24 02:35:51 mud Exp $";
d3232 1
a3232 1
  int damage,hp_damage,dice_damage;
d3241 1
a3241 1
  damage = UMAX(hp_damage + dice_damage /10, dice_damage + hp_damage /10);
d3474 1
a3474 1
          damage( ch, victim, damage/2, sn, DAM_HARM,TRUE ,TRUE);
d3478 1
a3478 1
          damage( ch, victim, damage, sn, DAM_HARM,TRUE ,TRUE);
@


1.273
log
@fixing ordering and trying stuff out
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.272 2000/12/24 02:30:58 mud Exp $";
d470 1
a470 1
    damage_old(ch,victim,dam,sn,DAM_OTHER,TRUE);
d487 1
a487 1
/* mostly a cut an paste of do_ipck */
d1016 1
a1016 1
    damage_old(ch,victim,dam,sn,DAM_OTHER,TRUE);
d1527 1
a1527 1
	damage_old(ch,victim,dice(2,4),sn,DAM_BASH,FALSE);
d1551 1
a1551 1
	   damage_old(ch,vch,dice(2,4),sn,DAM_BASH,FALSE);
d1591 1
a1591 1
	damage_old(ch,victim,dice(2,4),sn,DAM_OTHER,FALSE);
d1613 1
a1613 1
	  damage_old(ch,victim,dice(2,4),sn,DAM_OTHER,FALSE);
d1720 1
a1720 1
        damage_old(ch,victim,dam/2,sn,DAM_COLD, TRUE ); 
d1722 1
a1722 1
           damage_old(ch,victim,dam,sn,DAM_COLD, TRUE);
d1742 1
a1742 1
           damage_old(ch,vch,dam/2,sn,DAM_COLD, TRUE);
d1744 1
a1744 1
           damage_old(ch,vch,dam,sn,DAM_COLD, TRUE); 
d2363 1
a2363 1
    damage_old( ch, victim, dam, sn, DAM_FIRE );
d2774 1
a2774 1
             damage_old( ch,vch,2*level + dice(3, 8), sn, DAM_DROWNING,TRUE);
d3474 1
a3474 1
          damage_old( ch, victim, damage/2, sn, DAM_HARM,TRUE );	
d3478 1
a3478 1
          damage_old( ch, victim, damage, sn, DAM_HARM,TRUE );
@


1.272
log
@let's try this
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.271 2000/12/21 05:03:38 mud Exp $";
d3502 1
a3502 1
  DAZE_STATE(ch,36);
@


1.271
log
@20DEC00
Tweaking necromancer a bit -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.270 2000/12/15 17:05:18 mud Exp $";
d3502 1
a3502 1
  WAIT_STATE(ch,36);
@


1.270
log
@NODIE rooms can not have nodes created in them, ie.
the Tomb of Matook.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.269 2000/12/15 06:10:00 mud Exp $";
d3496 6
@


1.269
log
@14DEC00
Ok forgot the lag when they cast, it lags em before the affect takes
hold.  also had to put a check in autoassist
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.268 2000/12/15 05:19:36 mud Exp $";
d1046 1
@


1.268
log
@14DEC00
had one more little check to do, now here goes teh necromancer kit
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.267 2000/12/15 03:56:49 mud Exp $";
d3495 1
@


1.267
log
@14DEC00
Okies, the check in the update is in.  Temporary short duration to check
the kill
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.266 2000/12/13 04:10:21 mud Exp $";
d3498 1
a3498 1
  af.duration  = level/10;
@


1.266
log
@12DEC00
Starting wraithform again, this time much slower.  Adding the spell
and going to see if it is castable.  Also looking for any weird affects
on mobs.
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.265 2000/12/09 07:05:49 mud Exp $";
d3498 1
a3498 1
  af.duration  = level;
@


1.265
log
@08DEC00
DAMN this wraithform it's gone now :)
=Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.264 2000/12/07 06:45:46 mud Exp $";
d3483 24
@


1.264
log
@ok got all the necromancer stuff out trying to restore order
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.263 2000/12/07 06:25:40 mud Exp $";
a3482 41
void spell_wraithform(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{ /* Start brace for spell_wraithform */
  CHAR_DATA *victim = (CHAR_DATA *) vo;
  AFFECT_DATA af;
  if (IS_NPC(ch))
  {
  return;
  }

  if (victim != ch)
  {
    send_to_char("If you want to make them dead, try more conventional methods.\r\n",ch);
    return;
  }

  if ( IS_AFFECTED(victim, skill_lookup("wraithform")) )
  {
    if (victim == ch)
    {
      send_to_char("You are already walking the umbra.\n\r",ch);
      return;
    }
    else
    {
      act("$N is already shifted out of phase.",ch,NULL,victim,TO_CHAR,FALSE);
      return;
    }
  }
  af.where     = TO_AFFECTS;
  af.type      = sn;
  af.level     = level;
  af.duration  = level/7+10;
  af.location  = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = 0;
  affect_to_char( victim, &af );
  act( "$n becomes very shadowy.\r\n", victim, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( "You are turned into a shadow.\n\r", victim );
  WAIT_STATE(ch, 48);
  return;
} /* End brace for spell_wraithform */
@


1.263
log
@ok i tink i know what's happening with hassan
-boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.262 2000/12/07 05:46:12 mud Exp $";
d3513 1
a3513 1
  af.level     = level/10;
@


1.262
log
@06DEC00
Ok no AFF_WRAITHFORM had to change those to skill_lookups
compiled clean testing now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.261 2000/12/03 19:22:56 mud Exp $";
d3487 4
@


1.261
log
@03DEC00
Ok i forgot to do buy and sell. covered now cann't do while in wraithform
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.260 2000/12/03 17:50:31 mud Exp $";
d3494 1
a3494 1
  if ( IS_AFFECTED(victim, AFF_WRAITHFORM) )
d3513 1
a3513 1
  af.bitvector = AFF_WRAITHFORM;
@


1.260
log
@03DEC00
Ok I have added teh unwraith and am going to check the logic with a player
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.259 2000/12/03 03:29:14 mud Exp $";
d3509 2
a3510 2
  af.level     = level;
  af.duration  = get_curr_stat(ch,STAT_INT)+get_curr_stat(ch,STAT_WIS)+get_curr_stat(ch,STAT_CON)/6;
@


1.259
log
@02DEC00 -
DOH!!! forgot to take out that damn ifdef codetest...
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.258 2000/12/03 03:24:02 mud Exp $";
d3510 1
a3510 1
  af.duration  = get_curr_stat(ch,STAT_INT)+get_curr_stat(ch,STAT_WIS)+get_curr_stat(ch,STAT_CON)/3;
d3517 1
d3520 1
@


1.258
log
@2DEC00 - Ok here goes teh necromancer kit.  changes in act_info.c act_move.c
         act_obj.c const.c figt.c mag2.c magic.c magic.h merc.h update.c
	 all sorts of cool stuff
	 -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.257 2000/11/19 18:56:24 mud Exp $";
a3482 1
#ifdef CODETEST	
a3518 1
#endif
@


1.257
log
@19NOV00
Added a change to mirror image spell.  Now it does a check to see if they're
mounted on a warhorse or not.  If so, it won't allow them to cast.
Also hoping the necromancer stuff i have in fight.c doesn't affect game play :)
it *shouldn't* but you never know ;)
ttfn
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.256 2000/10/16 19:17:01 mud Exp $";
d3486 2
a3487 1
  CHAR_DATA *victim;
d3489 5
d3495 24
@


1.256
log
@ added in second avarice clan skill
 fixed bug in indulgence
 added in functionality for "sanction skill"
 -rage
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.255 2000/10/14 04:31:50 mud Exp $";
d3483 8
@


1.255
log
@13OCT00
Added a gladiator channel message to swarm spell
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.254 2000/10/13 02:34:21 mud Exp $";
d3009 6
d3089 6
@


1.254
log
@12oct00
doh can't have people running around with a 55 tick poison that's uncurable
:)
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.253 2000/10/11 13:54:54 mud Exp $";
d3218 1
a3218 1

d3229 8
@


1.253
log
@11oct00
minor tweakings to swarm spell
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.252 2000/10/10 21:14:16 mud Exp $";
d3250 1
a3250 1
	af.duration  = level;
d3283 2
a3284 2
        af.level    = level * 3/4;
        af.duration  = level/2;
@


1.252
log
@10oct00
fixing messages in swarm
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.251 2000/10/10 21:08:59 mud Exp $";
a3236 2
      damage_attack = 1;

d3240 1
d3255 2
d3393 1
a3393 1
        damage_attack = 0;
d3410 1
a3410 1
	act("$n appears to be {Gblinded{x.",victim,NULL,NULL,TO_ROOM,FALSE);
@


1.251
log
@10OCT00 -
Fixed the hold person bug.  now in swarm, if the spiders hit, there
is no damage done
_corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.250 2000/10/10 04:07:44 mud Exp $";
d3235 1
a3235 1
      act("Your Africanized wasps swarm about them.\r\n",ch,NULL,NULL,TO_CHAR,FALSE);
@


1.250
log
@09OCT00
This should be the final commit of the evening.  i added some 'failure'
messages to the swarm spells.
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.249 2000/10/10 03:38:32 mud Exp $";
d3347 1
a3347 1
	damage_attack = 1;
@


1.249
log
@09OCT00
Tweak tweak tweak, i'm going to get this damn spell right one day
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.248 2000/10/10 03:33:19 mud Exp $";
d3239 1
a3239 1
      if (( saves_spell( level, victim,DAM_POISON) )
d3246 1
a3246 1
      if(!is_affected( victim, sn ))
d3339 7
a3345 2
      if ( ( !is_affected( victim, sn) ) ||
      !saves_spell(level,victim,DAM_OTHER) )
d3377 1
d3393 2
@


1.248
log
@09OCT00
Yahoo ok i got it all fixed i think.  The logic should work now, damn
misplaced {'s in swarm spell.
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.247 2000/10/09 15:34:52 mud Exp $";
d3237 2
a3241 1
	damage_attack = 1;
a3247 1
	damage_attack = 1;
@


1.247
log
@09OCT00
Ok, i think i fixed the stacking problem.  my bad
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.246 2000/10/09 15:25:25 mud Exp $";
d3264 1
a3264 1
      if (( saves_spell(level,victim,DAM_DISEASE) || is_affected( victim, sn)) ||
d3297 1
a3297 1
      act("Monarch butterflies come to your aid.\r\n",ch,NULL,NULL,TO_CHAR,FALSE);
d3299 1
a3299 1
      if (( saves_spell( level, victim,DAM_MENTAL) ) )
a3306 1
	  act("Grab your nets!!! $n is summoning butterflies!  Who wants to fight anymore?\r\n",ch,NULL,victim,TO_ROOM,FALSE);
d3310 1
a3310 2

      if (victim->fighting || victim->position == POS_FIGHTING)
d3312 18
a3329 14
      stop_fighting(victim,FALSE);
      af.where = TO_AFFECTS;
      af.type = sn;
      af.level = level;
      af.duration = level/4;
      af.location = APPLY_HITROLL;
      if (!IS_NPC(victim))
      af.modifier = -5;
      else
      af.modifier = -2;
      af.bitvector = AFF_CALM;
      affect_to_char(victim,&af);
      af.location = APPLY_DAMROLL;
      affect_to_char(victim,&af);
@


1.246
log
@09OCT00
Ok, i think i figured out what i want to do with swarm :).  compiling to
check now.
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.245 2000/10/09 14:44:21 mud Exp $";
d3264 1
a3264 1
      if (saves_spell(level,victim,DAM_DISEASE) ||
@


1.245
log
@09OCT00
Fixed some minor bugs with swarm spell.  I forgot to add a break in hte
select so it was hitting ppl with two affects some times.  also fixed
the typo in hte hold person.  nothing else to major will tweak it a bit
more this evening
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.244 2000/10/09 03:15:33 mud Exp $";
d3240 2
a3241 2
	damage_attack = 0;
	act("$n is unaffected by the swarm..",victim,NULL,NULL,TO_ROOM,FALSE);
d3245 1
a3245 1
      if(!is_affected( victim, skill_lookup("poison") ))
d3249 1
a3249 1
	af.type      = skill_lookup("poison");
d3267 1
a3267 1
        damage_attack = 0;
d3281 1
a3281 1
        af.type     = skill_lookup("plague");
d3316 1
a3316 1
      af.type = skill_lookup("calm");
d3332 1
a3332 1
      damage_attack = 0;
d3337 1
a3337 1
      if ( !is_affected( victim, skill_lookup("hold person") ) ||
d3342 1
a3342 1
        af.type             = skill_lookup("hold person");
d3365 1
a3365 1
        damage_attack = 0;
d3382 1
a3382 1
      if (is_affected(victim,AFF_BLIND) || saves_spell(level,victim,DAM_OTHER) )
d3391 1
a3391 1
	af.type      = skill_lookup("blindness");
d3408 1
a3408 1
      if ( is_affected(victim,skill_lookup("feeblemind") ) || saves_spell(level,victim,DAM_MENTAL) )
d3416 1
a3416 1
        af.type             = skill_lookup("feeblemind");
@


1.244
log
@08OCT00
Bring on the clowns...
Ok, here goes teh nature fried kit for druids.  Going to give it the
final once over on 8080 then make it in the main port.
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.243 2000/10/08 22:52:21 mud Exp $";
d3259 1
a3259 1

d3337 1
a3337 1
      if ( !is_affected( victim, sn ) ||
d3351 1
a3351 1
        send_to_char("The spiders $n summoned wrap you snugly in their web.\n\r",victim);
d3391 1
a3391 1
	af.type      = sn;
@


1.243
log
@08OCT00
Tweak tweak tweak i tweak mag2.c to get swarm to work right
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.242 2000/10/08 19:11:20 mud Exp $";
d3283 1
a3283 1
        af.duration  = level;
@


1.242
log
@08OCT00 - trying a fix in charm animal, need to see why it's crashing
-corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.241 2000/10/08 18:30:17 mud Exp $";
d3429 1
d3433 1
a3433 2
  }/*end brace for case*/
  }
@


1.241
log
@08OCT00 - Yahooo! adding the charm animal spell and swarm spells for the
          druid kit.  going to test now on olc.
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.240 2000/09/30 14:29:33 mud Exp $";
a3161 1
/* Taking this part out for now*/ 
d3193 1
d3195 1
d3208 1
d3210 1
a3212 47
#ifdef CODETEST
/* Attempt at summon mouse spell for animal friend kit started 28SEP00 */
void spell_summon_mouse(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{ /* start curley brace for spell_call_mount */
  CHAR_DATA *victim;
  int count;

  /* Check to see if they already have a mouse */
  count =0;
  for ( victim = char_list; victim != NULL; victim = victim->next )
  if ( (is_same_group( victim, ch ) && IS_SET(victim->mhs,MHS_SPYMOUSE))
     || (is_same_group(victim->master,ch) && IS_SET(victim->mhs,MHS_SPYMOUSE)))
     {
       count++;
     }
  if ( count >= 1 && !IS_IMMORTAL(ch))
     {
       send_to_char("You may only summon one mouse.\n\r",ch);
       return;
     }

  victim = create_mobile(get_mob_index(MOB_VNUM_SPYMOUSE));
  act("*Squeak Squeak Sqeak*\r\n",ch,NULL,victim,TO_ROOM,FALSE);
  act("A portal to the Elemental Plane of Mouse opens and a mouse appears.\r\n",ch,NULL, victim,TO_CHAR,FALSE);

  char_to_room (victim,ch->in_room);
/*Set the mouse up real wimpy like*/
  victim->level = 1;
  victim->armor[0] = 100;victim->armor[1] = 100;victim->armor[2] = 100;
  victim->armor[3] = 100;
  victim->hit = 1;victim->max_hit = 1;victim->max_mana = 1;victim->mana = 1;
  victim->move = level * 15;victim->max_move = level * 15;
  victim->damage[DICE_NUMBER] = 0;victim->damage[DICE_TYPE]   = 0;
  victim->hitroll = 0;victim->damroll = 0;

/*Now go thru the gyrations to make the moue a foller*/
  SET_BIT (victim->mhs,MHS_SPYMOUSE); /* just to make sure */
  add_follower( victim, ch );
  victim->leader = ch;
 /* ch->pet = victim;*/

  SET_BIT(victim->form,FORM_INSTANT_DECAY);
  /* SET_BIT(victim->affected_by,AFF_CHARM);*/ /* quick-charm */
  victim->life_timer = ch->level*3/2;
  return;
  } /* there goes the end curley brace for spell_summon_mouse */
#endif
d3433 1
a3448 1
}
@


1.240
log
@30SEP00 - Made changes to charm animal and want to test summon mouse
on olc
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.239 2000/09/27 17:02:50 mud Exp $";
d3210 1
a3210 1

d3241 1
a3241 1
  victim->move = level * 5;victim->max_move = level * 5;
d3247 3
a3249 1
  add_follower( victim, ch );victim->leader = ch;ch->pet = victim;
d3252 2
a3253 2
  SET_BIT(victim->affected_by,AFF_CHARM); /* quick-charm */
  victim->life_timer = ch->level;
d3256 118
d3375 119
d3495 1
@


1.239
log
@27SEP00
Added finishing touches to charm_animal in mag2.c
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.238 2000/09/25 02:35:55 mud Exp $";
d3210 45
@


1.238
log
@24SEP00
Thanks to Poq for helping figure out why it wasn't working right.
Did a check for IS_NPC, incase we ever add any "animal" races.
Going to start troubleshooting the counter thing next.
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.237 2000/09/24 22:39:02 mud Exp $";
a3131 1

d3136 1
d3151 1
a3151 1
    if ( !IS_NPC(victim) )
d3153 2
a3154 2
      send_to_char("Uhhh, $N may look like an animal, but charm animal really is only for charming animals.\n\r",ch);
      return;
a3160 5
  if (!IS_NPC(victim))
  {
     send_to_char("They might be weird but they aren't an animal.\n\r",ch);
     return;
  }
d3162 4
a3165 4
/* Taking this part out for now 
  for ( victim = char_list; victim != NULL; victim = victim->next )
  if ( (is_same_group( victim, ch ) && IS_SET(victim->form,FORM_ANIMAL))
    || (is_same_group(victim->master,ch) && IS_SET(victim->form,FORM_ANIMAL)))
d3174 1
a3174 1
*/
d3200 1
a3200 1
  af.duration    = IS_NPC(victim)?number_fuzzy(level/2):level;
d3210 1
@


1.237
log
@fix boogies charm animal problem
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.236 2000/09/24 22:32:39 mud Exp $";
d3149 5
@


1.236
log
@debuging charm animal
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.235 2000/09/24 20:45:53 mud Exp $";
d3156 6
d3175 1
a3175 17
  /* ||   IS_SET(victim->imm_flags,IMM_CHARM)
   Taking the line below out.  Animals don't get a chance to save vs this spell
  ||   saves_spell( level, victim,DAM_CHARM)

  if ( (IS_NPC(victim) && IS_SET(victim->act, ACT_AGGRESSIVE) )
  ||   IS_AFFECTED(victim, AFF_CHARM)
  ||   IS_AFFECTED(ch, AFF_CHARM)
  ||   IS_SET(victim->act, PLR_DWEEB)
  ||   level < victim->level
  ||   victim->position == POS_FIGHTING
  || ( !IS_NPC(victim) && is_affected(ch,gsn_wound_transfer) ) )
  {
    send_to_char("Sorry Charlie, not on that target.\n\r",ch);
    return;
  }
  */
  if ( (IS_NPC(victim) && IS_SET(victim->act, ACT_AGGRESSIVE) )
d3179 1
a3179 2
  ||   victim->position == POS_FIGHTING
  || ( !IS_NPC(victim) && is_affected(ch,gsn_wound_transfer) ) )
@


1.235
log
@lookig at charm_animal
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.234 2000/09/24 20:31:35 mud Exp $";
a3171 1
  */
d3177 11
@


1.234
log
@24SEP00
And the charm animal saga continues
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.233 2000/09/24 20:26:09 mud Exp $";
d3156 1
a3157 1
/* Taking this part out for now 
d3169 4
a3178 4
  /* ||   IS_SET(victim->imm_flags,IMM_CHARM)
   Taking the line below out.  Animals don't get a chance to save vs this spell
  ||   saves_spell( level, victim,DAM_CHARM)
  */
@


1.233
log
@24SEP00
Ok, me thinks i got it figured out
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.232 2000/09/24 20:04:40 mud Exp $";
d3175 2
a3176 2
  ||   IS_SET(victim->imm_flags,IMM_CHARM)
  /* Taking the line below out.  Animals don't get a chance to save vs this spell
@


1.232
log
@24SEP00
Ok, I moved the check for if the spell is cast on the caster for the funny
message to be displayed.  Stioll don't know why it crashes gonna test it
again then go look at the log?
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.231 2000/09/24 19:09:02 mud Exp $";
a3194 1
  {
a3195 2
  }

a3207 1
  {
d3209 1
a3209 3
  }

return;
@


1.231
log
@24SEP00
The Crash bug hunt continues
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.230 2000/09/24 18:41:39 mud Exp $";
d3146 6
a3169 6
  if ( victim == ch )
  {
    send_to_char("Grrrowl, you are QUITE the animal aren't you?\n\r",ch);
    return;
  }
  
@


1.230
log
@24SEP00
Ok, I think I got why charm_animal crashes when cast on a target
am compileing now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.229 2000/09/24 16:40:15 mud Exp $";
d3151 1
a3151 1
 
d3162 1
@


1.229
log
@24SEP00 -
DOH!  Well, it compiles clean but when charm animal's cast, the game crashes
Briar says i shouldn't be proud of crashing the game :).
Trying a fix now in mag2.c
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.228 2000/09/24 16:31:59 mud Exp $";
d3144 6
a3167 6
/* Here's one of the things that makes this different from charm person */
  if ( IS_SET(victim->form,FORM_ANIMAL) )
  {
    send_to_char("You can only cast charm animal on animals.\n\r", ch);
    return;
  } 
@


1.228
log
@24SEP00 -
Added the charm_animal spell.  Mods made to const.c db.c mag2.c and magic.h
aaaand magic.c
Going to compile on OLC and test
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.227 2000/09/10 18:24:33 mud Exp $";
d3163 1
a3163 1
  if ( victim->form != FORM_ANIMAL )
@


1.227
log
@10SEP00 - Took out warnings in mag2.c and fight.c unused vars -0 Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.226 2000/09/10 18:11:41 mud Exp $";
d3133 83
@


1.226
log
@Made punctuation in Shapemorph names illegal.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.225 2000/09/10 17:38:08 mud Exp $";
d190 1
a190 3
   AFFECT_DATA af;
   int t,count, number;
   int max_move,move;
@


1.225
log
@Added ctype.h to includes to get rid of tolower() warning.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.224 2000/09/10 17:34:16 mud Exp $";
d2029 9
@


1.224
log
@No more starting shapemorphs with a color code, ie. {x
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.223 2000/09/08 05:14:57 mud Exp $";
d28 1
@


1.223
log
@06SEP00 - Ok this is it :) call mount should be done - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.222 2000/09/08 05:06:00 mud Exp $";
d2028 1
a2029 4
   /* BIG memory leak!  Commented out 4/14/00 -Rusty
   isChar = load_char_obj(&d, arg);
   if (isChar)          
    */
d2031 7
a2037 1
   /* Don't allow morphing into other players */
@


1.222
log
@06SEP00 - GOT IT!!! - Corey (oh, mount HPs now are decent ;))
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.221 2000/09/08 05:00:59 mud Exp $";
d236 2
d245 1
@


1.221
log
@06SEP00 - got the warhorses HP fixed i think testing now - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.220 2000/09/08 04:49:27 mud Exp $";
d231 1
d234 2
a235 1
      victim->hit = victim->max_hit;
@


1.220
log
@06SEP00 - Ok i think i got the mount's moves figured out in call mount in mag2.c
          -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.219 2000/09/06 00:44:38 mud Exp $";
d231 2
a232 2
      victim->max_hit = level * 5 + number_range(level * level / 9, level * level/5 );
      victim->max_hit = UMAX( victim->max_hit, ch->max_hit * 3 /4);
@


1.219
log
@05SEP00 - AARRGGHH!!! :) wasn't dividing the max_move in call_mount so it
          was doing this insane number, driving moves to negative.
	  All better now, compiling on OLC and going to test
	  -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.218 2000/09/04 20:48:44 mud Exp $";
d236 1
d239 2
a240 1
      victim->move = victim->max_move;
@


1.218
log
@04SEP00- Fixed bug allowing people to take kcharge at creation but
         they couldn't get the skill, but took the cp pen.  also
	 bringing in the revised warhorse
	 -Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.217 2000/08/29 03:51:56 mud Exp $";
d191 1
a191 1
   sh_int max_move,move;
d237 1
a237 1
      victim->max_move = UMAX( victim->max_move,ch-max_move * 3);
@


1.217
log
@28AUG00 - Adde section to update.c for warhorses, we can't ahve a boring
"goes to dust" message now can we? :) Also tweaked mag2.c call_mount for
hte life timer, now twice the casters level - Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.216 2000/08/27 23:23:07 mud Exp $";
d191 2
d226 1
a226 1
      victim->level = level * 9/10;
d229 3
a231 3
      victim->armor[t] = interpolate(victim->level,50,-200);
      victim->armor[3] = interpolate(victim->level,0,-100);
      victim->max_hit = level * 10 + number_range(level * level / 9, level * level );
d236 4
d241 1
a241 1
      victim->damage[DICE_TYPE]   = 6;
@


1.216
log
@27-Aug-00 Making skill point tracker work in skills.c - Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.215 2000/08/26 02:05:58 mud Exp $";
d246 3
a248 1
      victim->life_timer = ch->level/2+18;
@


1.215
log
@25-AUG-00 - addedwarhorse to player's pet area
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.214 2000/08/25 19:43:05 mud Exp $";
d223 1
a223 1
      victim -> size = pc_race_table[ch->race].size + 1;
@


1.214
log
@25-AUG-00  Added the call_mount spell for the knight kit
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.213 2000/08/19 22:29:02 mud Exp $";
d241 3
@


1.213
log
@heat metal, rust things dont work o highaldners
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.212 2000/08/19 21:56:27 mud Exp $";
d184 62
@


1.212
log
@new highlander code -poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.211 2000/08/18 23:00:40 mud Exp $";
d1054 6
d1066 1
d1161 6
@


1.211
log
@missing )
-poqo
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.210 2000/08/18 22:49:03 mud Exp $";
d620 5
@


1.210
log
@Highlanders Abound
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.209 2000/07/24 00:29:35 mud Exp $";
d1023 1
a1023 1
    && (IS_SET(ch->mhs,MHS_HIGHLANDER))
@


1.209
log
@hard code some metal types in rust weapona nd rust armor
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.208 2000/07/21 23:45:27 mud Exp $";
d1020 7
@


1.208
log
@glads can not quaff or withstand or orb after arena starts
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.207 2000/07/18 23:00:12 mud Exp $";
d1077 35
d1164 34
@


1.207
log
@missing () on number_percent function
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.206 2000/07/18 22:47:05 mud Exp $";
d2254 7
d2291 7
d2328 7
d2363 7
@


1.206
log
@add spells for glad messages or vice versa
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.205 2000/07/18 22:45:02 mud Exp $";
d1551 1
a1551 1
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 50)
@


1.205
log
@adding some glad messages to spells
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.204 2000/07/11 23:26:44 mud Exp $";
d31 1
@


1.204
log
@gladiators can not shapemorph and will not fade by accident
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.203 2000/06/29 02:04:35 mud Exp $";
d1540 1
d1549 7
d2792 1
a2792 1

d2819 6
@


1.203
log
@ Added in gladiator betting, with dynamic odds calculation
 -Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.202 2000/06/28 16:25:22 mud Exp $";
d1807 6
@


1.202
log
@No more moving NULL (dead NPC) vch's after damage is
done by tsunami.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.201 2000/06/28 02:59:41 mud Exp $";
d2790 1
a2790 1
	 send_to_char("You failed.\n\r.", ch);
@


1.201
log
@ Fixed another bug, stackable confusion
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.200 2000/06/28 02:53:18 mud Exp $";
d2546 10
@


1.200
log
@ fixed missing reutrn statement in confusion
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.199 2000/06/28 02:37:57 mud Exp $";
d2772 5
@


1.199
log
@ Removal of restriction on using blind and confusion together
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.198 2000/06/27 04:21:40 mud Exp $";
d2776 1
d2788 1
a2788 1
       send_to_char( "You're SO confused!!!\n\r", victim);
@


1.198
log
@ added in a littel extra functionality to indulgence
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.197 2000/06/27 03:52:49 mud Exp $";
a2771 5
    if (is_affected (victim, gsn_blindness))
       {
	send_to_char("You cannot confuse someone who can't see.\n\r", ch);
        return;
       }
@


1.197
log
@ Added new paladin spell indulgence, keeps alignment from changing whenm cast

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.196 2000/06/23 02:11:06 mud Exp $";
d2865 1
a2865 1
 CHAR_DATA *victim = (CHAR_DATA * )vo
@


1.196
log
@lower con affects on elementalist flame swords etc
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.195 2000/06/23 02:03:19 mud Exp $";
d77 1
a77 1
    af.duration		= 1;
d107 1
a107 1
    af.duration		= (level > 30) + (level > 50);
d170 1
a170 1
    af.duration	= 1;
d2861 26
@


1.195
log
@allow other then a - Z back in shapemorph
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.194 2000/06/21 21:37:08 mud Exp $";
d820 1
d822 1
a822 1
    af.modifier		= -5;
d859 1
d861 1
a861 1
    af.modifier		= -5;
d897 1
d899 1
a899 1
    af.modifier		= -5;
@


1.194
log
@ Fixed some typoes in confusion
 Fixed bug in cure vision
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.193 2000/06/19 22:25:20 mud Exp $";
d1874 1
d1885 1
@


1.193
log
@logging tsunamis to find the rooms crashing us.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.192 2000/06/18 22:51:58 mud Exp $";
d2764 3
a2768 1
	
d2773 1
a2773 1
    if ( !saves_spell(level,ch,DAM_MENTAL) )
d2775 1
a2775 1
	 send_to_char("You failed\n\r.", ch);
d2843 2
a2844 4
 
   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("cleric") &&
	 ch->pcdata->old_class!=class_lookup("elementalist")))
	level = level * 9 / 10 ;
@


1.192
log
@can only use alphas in shapemorph now
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.191 2000/06/18 22:47:11 mud Exp $";
d2518 3
@


1.191
log
@working on shapemorph only alphas
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.190 2000/06/18 21:24:07 mud Exp $";
a1873 1
#ifdef CODE_TEST
a1883 1
#endif
@


1.190
log
@fix endure cold and heat so they are castable on faeries
increase duration
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.189 2000/06/17 20:10:27 mud Exp $";
d1870 1
a1870 1
      send_to_char("Self is not valid as the start to a morhping name.\n\r",ch);
d1878 1
a1878 1
      if(strstore[i] < "a" || strstore[i] > "Z")
@


1.189
log
@Starting 'cure vision' for Avarice
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.188 2000/06/17 19:02:44 mud Exp $";
d652 3
a654 1
    if ( check_immune(victim,DAM_COLD) )
d656 4
a659 1
	send_to_char("You failed.\n\r",ch);
d668 1
a668 1
    af.duration		= (level / 8 ) + 2;
d714 3
a716 1
    if ( check_immune(victim,DAM_FIRE) )
d718 4
a721 1
	send_to_char("You failed.\n\r",ch);
d730 1
a730 1
    af.duration		= (level / 8 ) + 2;
@


1.188
log
@move damage in Tsunami to before moving of char
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.187 2000/05/27 02:44:12 mud Exp $";
d2811 34
@


1.187
log
@Kit Changing: REmove sepcial effects ( ennemy, spec)
Float: swim skill helps you vs floating away
Hold: casting level capped similar to sleep
Position for zap, brandish, quaff, recite set to Fighting
Check on eating pills for position at least of fighting
Snare: duration similar to hold

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.186 2000/05/26 01:04:20 mud Exp $";
d2516 23
a2538 27
  vch_next  = vch->next;
  if ( vch->in_room == NULL )
      continue;
  if ( vch->in_room == ch->in_room )
  {
      if ( vch == ch || is_safe_spell(ch,vch,TRUE))
      {
      /*
        damage_old(ch,vch,0,sn,DAM_DROWNING,TRUE);
	*/
	if ( vch != ch )
	{
	  send_to_char("Some water splashes at your ankles.\n\r",vch);
	}
	continue;
      }
    else
    {
	if(!saves_spell(level,vch,DAM_DROWNING))
	{
	 EXIT_DATA *pexit;
	 int door;

	/* you failed your saves, you are now dazed and you might be moved */
	send_to_char("You are knocked about gurgling and sputtering.\n\r",vch);
	DAZE_STATE(vch,24);
	vch->position = POS_RESTING;
d2540 8
a2547 9
	/* stop_fighting(vch,TRUE); */
	 door = number_door();
	 if ( ( pexit = vch->in_room->exit[door] ) == 0
	     ||   pexit->u1.to_room == NULL
	     ||   pexit->u1.to_room->clan
	     ||   IS_SET(pexit->exit_info, EX_CLOSED)
	     || ( IS_NPC(vch)
	 	&& IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB) ) )
	 continue;
d2549 11
a2559 14
	 /* shoudl stop combat only if you can move the person */
	 stop_fighting(vch,TRUE);
	 move_char(vch, door, FALSE );
	}
      }
      damage_old( ch,vch,2*level + dice(3, 8), sn, DAM_DROWNING,TRUE);
      continue;
  }

  if ( vch->in_room->area == ch->in_room->area )
      send_to_char( "The rumbling of water echos in the distance.\n\r", vch );
    }

    return;
@


1.186
log
@increaded movement loss (based on ch level now)
added a half move pen if earthbind
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.185 2000/05/25 23:50:21 mud Exp $";
d618 3
@


1.185
log
@Typo fix , had a extra bracket
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.184 2000/05/25 23:47:30 mud Exp $";
d1263 2
@


1.184
log
@ Mods to earthbind ( can flee now, but cost you 10 extra moves per square)
 Can't reanimate into a corpse whihc is in a clan hall
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.183 2000/05/25 01:55:56 mud Exp $";
d1245 1
a1245 1
    case SECT_INSIDE:    level /= 2;  break;   /* Fat chance */
@


1.183
log
@change shapemorph up a bit
add gladiator_team to pcdata
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.182 2000/05/25 01:15:18 mud Exp $";
d1225 1
a1225 1

d1236 2
a1237 1
    
d1244 1
d1248 4
d1267 1
a1267 1
    af.duration		= ( ch->level > 35 );
d1273 1
a1273 1
    act("Your feet sink into the ground, you cannot move!",
@


1.182
log
@working on not allowing any char except a .. Z in shapemorph
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.181 2000/05/24 22:27:29 mud Exp $";
d1777 1
d1785 1
d1855 1
a1855 1
   while (argument[i] != '\0')
d1857 1
a1857 1
      if(argument[i] < "a" || argument[i] > "Z")
@


1.181
log
@need to ! the strncmp
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.180 2000/05/24 22:23:57 mud Exp $";
d1851 1
d1855 1
a1855 1
      if(argument[i] < 'a' || argument[i] > 'Z')
d1862 1
@


1.180
log
@working on shapemoprh
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.179 2000/05/24 22:14:21 mud Exp $";
d1845 1
a1845 1
   if (strncmp(arg,"self",4))
@


1.179
log
@debugging shapemorph
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.178 2000/05/24 22:08:07 mud Exp $";
a1838 12
   while (argument[i] != '\0')
   {
      if(argument[i] < 'a' || argument[i] > 'Z')
      {
	 sprintf(buf,"%s is not a valid character, use only a thru Z.\n\r",argument[i]);
	 send_to_char(buf,ch);
	 return;
      }
      i++;
   }

   i = 0;
d1850 12
@


1.178
log
@do not allow 'self' as the start of a morph
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.177 2000/05/24 19:44:13 mud Exp $";
d1843 2
a1844 1
	 send_to_char("a thru Z are the only valid characters.\n\r",ch);
@


1.177
log
@declare i
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.176 2000/05/24 19:40:52 mud Exp $";
d1847 13
@


1.176
log
@make shapemorph not use any characters except a - Z
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.175 2000/05/21 02:35:10 mud Exp $";
d1776 1
@


1.175
log
@missing ;
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.174 2000/05/21 02:33:58 mud Exp $";
d1835 11
@


1.174
log
@typod send_to_char
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.173 2000/05/21 02:31:54 mud Exp $";
d198 1
a198 1
      send_to_char("Gladiators can not summon elementals.\n\r",ch)l
@


1.173
log
@gladiators can not summon mobs, gate, summon elementals, charm or entrance
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.172 2000/05/19 13:46:56 mud Exp $";
d198 1
a198 1
      send_to_Char("Gladiators can not summon elementals.\n\r",ch)l
@


1.172
log
@ Fixed minor syntax error
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.171 2000/05/19 13:44:01 mud Exp $";
d195 7
@


1.171
log
@ more adjustments to alchemy, as well as removeing CODE_TES #ifdef's
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.170 2000/05/16 15:01:31 mud Exp $";
d107 1
a107 1
    af.duration		= (level > 30)i + (level > 50);
@


1.170
log
@ Addition of alchemist kit.
 act_obj.c : added "brew" command to create potions
 const.c   : added in a couple new damaget types into attack_table
 fight.c   : grenade code for molotov cocktails
 handler.c : modified wait_state for speed potion
 mag2.c    : spells for use with alchemist potions

- Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.169 2000/05/14 00:32:50 mud Exp $";
d77 1
a77 1
    af.duration		= 0;
d107 1
a107 1
    af.duration		= 1;
@


1.169
log
@clean up old warnings, declare wear_obj and remove unused material declare
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.168 2000/04/18 19:51:02 mud Exp $";
d68 1
a68 1
		send_to_char("You are already hastess.\n\r",ch);
d80 1
a80 1
    af.bitvector		= AFF_HASTE;
@


1.168
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.167 2000/04/17 00:40:46 mud Exp $";
d45 1
d1014 1
d1016 1
d1078 1
d1080 1
@


1.167
log
@ remove the material check on rust armor, so i can test it out
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.166 2000/04/17 00:36:53 mud Exp $";
d54 2
a55 2
   act("You feel energized.",victim,NULL,NULL,TO_CHAR);
   act("$n appears energized.",victim,NULL,NULL,TO_ROOM);
d69 1
a69 1
		act("$N is already hasted.",ch,NULL,victim,TO_CHAR);
d84 1
a84 1
	act("$N's motions begin to speed up.",ch,NULL,victim,TO_CHAR);
d99 1
a99 1
		act("$N is already protected.",ch,NULL,victim,TO_CHAR);
d114 1
a114 1
	act("$N is protected from magic.",ch,NULL,victim,TO_CHAR);
d128 1
a128 1
		act("$N can already see all.",ch,NULL,victim,TO_CHAR);
d147 1
a147 1
	act("$N is betstowed with the gift of vision.",ch,NULL,victim,TO_CHAR);
d162 1
a162 1
		act("$N is already affected.",ch,NULL,victim,TO_CHAR);
d178 1
a178 1
	act("$N is able to hit more often.",ch,NULL,victim,TO_CHAR);
d212 4
a215 2
act("A shining hole opens to the Elemental Plane of Spirit.",ch,NULL,victim,TO_ROOM);
act("You summon an elemental from the Elemental Plane of Spirit.",ch,NULL, victim,TO_CHAR);
d231 4
a234 2
act("A shining hole opens to the Elemental Plane of Energy.",ch,NULL,victim,TO_ROOM);
act("You summon an elemental from the Elemental Plane of Energy.",ch,NULL, victim,TO_CHAR);
d251 4
a254 2
act("A shining hole opens to the Elemental Plane of Air.",ch,NULL,victim,TO_ROOM);
act("You summon an elemental from the Elemental Plane of Air.",ch,NULL, victim,TO_CHAR);
d259 4
a262 2
act("A shining hole opens to the Elemental Plane of Earth.",ch,NULL,victim,TO_ROOM);
act("You summon an elemental from the Elemental Plane of Earth.",ch,NULL, victim,TO_CHAR);
d267 4
a270 2
act("A shining hole opens to the Elemental Plane of Water.",ch,NULL,victim,TO_ROOM);
act("You summon an elemental from the Elemental Plane of Water.",ch,NULL, victim,TO_CHAR);
d275 4
a278 2
act("A shining hole opens to the Elemental Plane of Fire.",ch,NULL,victim,TO_ROOM);
act("You summon an elemental from the Elemental Plane of Fire.",ch,NULL, victim,TO_CHAR);
d323 3
a325 3
   act("You stagger beneath the mental assault.",ch,NULL,victim,TO_VICT);
   act("$N staggers beneath your psionic assault!",ch,NULL,victim,TO_CHAR);
   act("$N staggers beneath the psionic assault.",ch,NULL,victim,TO_NOTVICT);
d431 2
a432 2
        act("You knock open $p!",ch,obj,NULL,TO_CHAR);
        act("$n knocks open $p.",ch,obj,NULL,TO_ROOM);
d454 1
a454 1
    act( "$n knocks the $d open!", ch, NULL, pexit->keyword, TO_ROOM );
d490 1
a490 1
	act("$N's magical ability falters.",ch,NULL,victim,TO_CHAR);
d516 1
a516 1
	act("$N stumbles clumsily.",ch,NULL,victim,TO_CHAR);
d542 1
a542 1
	act("$N's willpower fades away.",ch,NULL,victim,TO_CHAR);
d569 1
a569 1
		ch, NULL, victim, TO_CHAR);
d596 1
a596 1
		ch,NULL,victim,TO_CHAR);
d628 1
a628 1
    act("$N stops moving!",ch,NULL,victim,TO_NOTVICT);
d631 1
a631 1
	act("$N stops moving.",ch,NULL,victim,TO_CHAR);
d658 1
a658 1
	act("$N is able to endure cold.",ch,NULL,victim,TO_CHAR);
d671 1
a671 1
	    act("$N is already protected.",ch,NULL,victim,TO_CHAR);
d688 1
a688 1
	act("$N is being watched over by the gods.",ch,NULL,victim,TO_CHAR);
d715 1
a715 1
	act("$N is able to resist heat.",ch,NULL,victim,TO_CHAR);
d742 1
a742 1
	act("$N's vitality is blessed by the gods.",ch,NULL,victim,TO_CHAR);
d766 2
a767 2
    act("$p radiates with holiness.",ch,obj,NULL,TO_CHAR);
    act("$p radiates with holiness.",ch,obj,NULL,TO_ROOM);
d803 2
a804 2
    act("$p flares brightly with an aura of fire.",ch,obj,NULL,TO_CHAR);
    act("$p flares brightly with an aura of fire.",ch,obj,NULL,TO_ROOM);
d841 2
a842 2
    act("$p freezes brightly with an aura of ice.",ch,obj,NULL,TO_CHAR);
    act("$p freezes brightly with an aura of ice.",ch,obj,NULL,TO_ROOM);
d878 2
a879 2
    act("$p sizzles brightly with an aura of lightning.",ch,obj,NULL,TO_CHAR);
    act("$p sizzles brightly with an aura of lightning.",ch,obj,NULL,TO_ROOM);
d922 1
a922 1
	ch,NULL,victim,TO_CHAR);
d924 1
a924 1
	ch,NULL,victim,TO_VICT);
d926 1
a926 1
	ch,NULL,victim,TO_NOTVICT);
d949 1
a949 1
    act("An aura of magical energy lingers.",ch,NULL,NULL,TO_ROOM);
d972 2
a973 2
    act("Your body becomes insubstantial.",ch,NULL,NULL,TO_CHAR);
    act("$n becomes insubstantial.", ch,NULL,NULL,TO_ROOM);
d999 1
a999 1
    act("$n vanishes from sight!",ch,NULL,NULL,TO_ROOM);
d1005 1
a1005 1
    act("$n materializes before you.",ch,NULL,NULL,TO_ROOM);
d1061 2
a1062 2
    act("$p whithers and rusts away!",ch,obj,victim,TO_CHAR);
    act("$p whithers and rusts away!",ch,obj,victim,TO_ROOM);
d1109 2
a1110 2
	act("$p whithers and rusts away!",ch,obj,victim,TO_CHAR);
	act("$p whithers are rusts away!",ch,obj,victim,TO_ROOM);
d1130 1
a1130 1
	   act("$N is already affected.",ch,NULL,victim,TO_CHAR);
d1132 1
a1132 1
	   act("You're plenty sick as it is.",ch,NULL,victim,TO_CHAR);
d1163 3
a1165 3
    act("$N appears to be stricken with sickness.",ch,NULL,victim,TO_CHAR);
    act("You suddenly feel sick and nauseated.",ch,NULL,victim,TO_VICT);
    act("$N appears to be sick and nauseated.",ch,NULL,victim,TO_NOTVICT);
d1193 2
a1194 2
    act("$p shimmers into being.",ch,fog,NULL,TO_CHAR);
    act("$p shimmers into being.",ch,fog,NULL,TO_ROOM);
d1208 1
a1208 1
	  act("$N is already bound to the earth.",ch,NULL,victim,TO_CHAR);
d1210 1
a1210 1
	   act("Your feet are already bound.",ch,NULL,victim,TO_CHAR);
d1218 1
a1218 1
	  act("$N is already on the ground.",ch,NULL,victim,TO_CHAR);
d1220 1
a1220 1
	   act("Your feet are already on the ground.",ch,NULL,victim,TO_CHAR);
d1238 1
a1238 1
	act("You failed.",ch,NULL,NULL,TO_CHAR);
d1256 3
a1258 3
	ch,NULL,victim,TO_VICT);
    act("$N's feet sink into the earth!",ch,NULL,victim,TO_CHAR);
    act("$N's feet sink into the earth!",ch,NULL,victim,TO_NOTVICT);
d1272 1
a1272 1
		ch,NULL,NULL,TO_CHAR);
d1275 1
a1275 1
		ch,NULL,victim,TO_CHAR);
d1290 1
a1290 1
    act("$N's hands harden into stone.",ch,NULL,victim,TO_CHAR);
d1300 2
a1301 2
    act("$n summons forth a powerful gale!",ch,NULL,NULL,TO_ROOM);
    act("You summon forth a powerful gale!",ch,NULL,NULL,TO_CHAR);
d1308 1
a1308 1
	act("$N appears to be unaffected.",ch,NULL,victim,TO_CHAR);
d1311 3
a1313 3
	act("$N is blown to the ground!",ch,NULL,victim,TO_CHAR);
	act("$N is blown to the ground!",ch,NULL,victim,TO_NOTVICT);
	act("You are blown to the ground!",ch,NULL,victim,TO_VICT);
d1332 1
a1332 1
	   act("$N appears to be unaffected.",ch,NULL,vch,TO_CHAR);
d1335 3
a1337 3
	   act("$N is blown to the ground!",ch,NULL,vch,TO_CHAR);
	   act("You are blown to the ground!",ch,NULL,vch,TO_VICT);
	   act("$N is blown to the ground!",ch,NULL,vch,TO_NOTVICT);
d1360 2
a1361 2
    act("$n summons forth a billowing storm of dust!",ch,NULL,NULL,TO_ROOM);
    act("You summon forth a billowing storm of dust!",ch,NULL,NULL,TO_CHAR);
d1373 1
a1373 1
	act("$N appears to be unaffected.",ch,NULL,victim,TO_CHAR);
d1376 3
a1378 3
	act("$N is blinded!",ch,NULL,victim,TO_CHAR);
	act("You are blinded!",ch,NULL,victim,TO_VICT);
	act("$N  is blinded!",ch,NULL,victim,TO_NOTVICT);
d1395 1
a1395 1
	   act("$N appears to be unaffacted.",ch,NULL,vch,TO_CHAR);
d1398 3
a1400 3
	  act("$N is blinded!",ch,NULL,vch,TO_CHAR);
	  act("You are blinded!",ch,NULL,vch,TO_VICT);
	  act("$N is blinded!",ch,NULL,vch,TO_NOTVICT);
d1418 1
a1418 1
			ch,NULL,victim,TO_CHAR);
d1421 1
a1421 1
			ch,NULL,victim,TO_CHAR);
d1446 1
a1446 1
    act("$N can now breathe underwater.",ch,NULL,victim,TO_CHAR);
d1460 1
a1460 1
	    act("$N is already affected.",ch,NULL,victim,TO_CHAR);
d1462 1
a1462 1
	    act("You are already made of stone.",ch,NULL,victim,TO_CHAR);
d1493 1
a1493 1
       act("$N's body hardens to stone!",ch,NULL,victim,TO_CHAR);
d1593 2
a1594 2
      act("You draw upon the power of $p.",ch,stone,NULL,TO_CHAR);
      act("It flares brightly and vanishes!",ch,stone,NULL,TO_CHAR);
d1604 2
a1605 2
    act("$p rises up from the ground.",ch,portal,NULL,TO_ROOM);
    act("$p rises up before you.",ch,portal,NULL,TO_CHAR);
d1662 2
a1663 2
        act("You draw upon the power of $p.",ch,stone,NULL,TO_CHAR);
        act("It flares brightly and vanishes!",ch,stone,NULL,TO_CHAR);
d1674 2
a1675 2
    act("$p rises up from the ground.",ch,portal,NULL,TO_ROOM);
    act("$p rises up before you.",ch,portal,NULL,TO_CHAR);
d1690 2
a1691 2
  act("$p rises up from the ground.",to_room->people,portal,NULL,TO_ROOM);
  act("$p rises up from the ground.",to_room->people,portal,NULL,TO_CHAR);
d1784 1
a1784 1
	 act( "$n returns to $s regular appearance.", ch, NULL, ch, TO_ROOM );
d1831 1
a1831 1
   act( "$n morphs into $r.",ch,NULL,ch->long_descr,TO_ROOM );
d2013 1
a2013 1
      act( "$n transforms into an $r.",ch,NULL,race_table[race].name,TO_ROOM );
d2019 1
a2019 1
      act( "$n transforms into a $r.",ch,NULL,race_table[race].name,TO_ROOM );
d2068 2
a2069 2
   act( "You return to your natural form.\n\r",ch,NULL,NULL,TO_CHAR);
   act( "$n returns to $s natural form.", ch, NULL, ch, TO_ROOM );
d2127 2
a2128 2
  act("$n is blinded by the smoke in $s eyes!",victim,NULL,NULL,TO_ROOM);
  act("$n's smoke cloud gets in your eyes!",ch,NULL,victim,TO_VICT);
d2169 1
a2169 1
    act("$N is already surrounded by that orb.",ch,NULL,victim,TO_CHAR);
d2184 1
a2184 1
  act("$N is surrounded by an orb of touch.",ch,NULL,victim,TO_CHAR);
d2199 1
a2199 1
    act("$N is already surrounded by that orb.",ch,NULL,victim,TO_CHAR);
d2214 1
a2214 1
  act("$N is surrounded by an orb of surprise.",ch,NULL,victim,TO_CHAR);  
d2229 1
a2229 1
    act("$N is already surrounded by that orb.",ch,NULL,victim,TO_CHAR);
d2244 1
a2244 1
  act("$N is surrounded by an orb of awakening.",ch,NULL,victim,TO_CHAR);  
d2259 1
a2259 1
    act("$N is already surrounded by that orb.",ch,NULL,victim,TO_CHAR);
d2274 1
a2274 1
  act("$N is surrounded by an orb of turning.",ch,NULL,victim,TO_CHAR);  
d2401 1
a2401 1
  act("$N is lost to their deity.",ch,NULL,vch,TO_CHAR);
d2441 1
a2441 1
	act("You feel as though you are being watched.",victim,NULL,NULL,TO_CHAR);
d2459 1
a2459 1
    act( "$n summons forth a wall of water.", ch, NULL, NULL, TO_ROOM );
d2526 1
a2526 1
            act("$N is already affected.",ch,NULL,victim,TO_CHAR);              
d2528 1
a2528 1
            act("You are already enhanced.",ch,NULL,victim,TO_CHAR);       
d2571 2
a2572 1
  act("$N is already protected by an element shield.",ch,NULL,victim,TO_CHAR);
d2603 2
a2604 2
	act("A flame shield flickers around $N.",ch,NULL,victim,TO_CHAR);
	act("A flame shield flickers around you.",ch,NULL,victim,TO_VICT);
d2607 1
a2607 1
    act("A flame shield flickers around $N.",ch,NULL,victim,TO_NOTVICT);
d2623 2
a2624 1
  act("$N is already protected by an element shield.",ch,NULL,victim,TO_CHAR);
d2652 1
a2652 1
    act("A frost shield freezes around $N.",ch,NULL,victim,TO_NOTVICT);
d2669 2
a2670 1
  act("$N is already protected by an element shield.",ch,NULL,victim,TO_CHAR);
d2698 2
a2699 1
    act("An electric shield energizes around $N.",ch,NULL,victim,TO_NOTVICT);
d2730 1
a2730 1
       act("$n appears to be confused.",victim,NULL,NULL,TO_ROOM);
d2757 2
a2758 1
  act("$n has created a shield from the nether plane.\n\r",ch, NULL, NULL, TO_ROOM);
@


1.166
log
@ hopefully fixed rust armor, was doing globla rust armor effect on every item
 very bad.....
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.165 2000/04/16 23:58:58 mud Exp $";
d1082 1
a1082 1

d1087 1
@


1.165
log
@rust armor go boom on all the eq in the game
. removed it for now
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.164 2000/04/16 23:12:19 mud Exp $";
d1062 1
a1062 1
    OBJ_DATA *obj;
d1073 1
a1073 1
    for ( obj = victim->carrying ; obj != NULL ; obj = obj->next )
d1075 2
d1101 2
@


1.164
log
@rust weapon fix, was checking your weapon and not the victim
thanks rage :)
Pierre
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.163 2000/04/16 16:09:57 mud Exp $";
a1080 1
	/*
a1084 1
         */
@


1.163
log
@rust weapon and armor should work now, nasty spells :(
will not work on a vorpal weapon. will be less effective when
the infamous material table is done.

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.162 2000/04/16 15:31:37 mud Exp $";
d1005 1
a1005 1
	send_to_char("You failed1.\n\r",ch);
d1009 1
a1009 1
    if ( (   obj  = get_eq_char(ch,WEAR_WIELD) ) == NULL )
d1017 1
a1017 1
	send_to_char("You failed2.\n\r",ch);
d1024 1
a1024 1
	send_to_char( "You failed5 .\n\r", ch);
d1044 1
a1044 1
	send_to_char("You failed4.\n\r",ch);
@


1.162
log
@earthbind mods, immune if not flying
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.161 2000/04/15 13:20:52 mud Exp $";
d1021 8
d1036 1
d1081 1
d1086 1
@


1.161
log
@Took out the fclose() on the NULL file pointer.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.160 2000/04/14 23:01:06 mud Exp $";
d1187 11
d1223 1
a1223 1
    af.duration		= (ch->level > 35 );
@


1.160
log
@Wrapped comment around now unused desciptor VAR declaration
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.159 2000/04/14 22:59:33 mud Exp $";
a1779 1
   fclose( fp );
d1781 1
a1781 1
   /* Dont allow morphing into Mobs, this is only cause 2.mobname isnt working */
@


1.159
log
@Removed nested comments
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.158 2000/04/14 22:58:14 mud Exp $";
d1721 1
d1723 2
a1724 1
   /* bool isChar; */
@


1.158
log
@No reading in and allocating random pfiles
if someone tries to shapemorph to the name
of a player.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.157 2000/03/27 05:27:42 mud Exp $";
d1763 1
a1763 1
   isChar = load_char_obj(&d, arg); /* char pfile exists? */
@


1.157
log
@ added checs for pc's only to be able to use remort skills...put checks in fear, hex, breather, bite, bleed, and morph.  Don't think I missed any.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.156 2000/03/20 14:59:01 mud Exp $";
d1722 3
a1724 1
   bool isChar;
d1762 1
d1765 8
d1775 1
d1778 1
@


1.156
log
@ Changed mana cost of endure heat and endure cold to 30, also upped duration from level/10 to level /8.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.155 2000/03/14 15:10:12 mud Exp $";
d1662 3
@


1.155
log
@ Added spell "nehter shield"
 Immortals will now never fail an enchant, and will always increase
 the hit/dam addition by one at a time.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.154 2000/03/08 14:09:51 mud Exp $";
d640 1
a640 1
    af.duration		= (level / 10 ) + 2;
d697 1
a697 1
    af.duration		= (level / 10 ) + 2;
@


1.154
log
@better messages in morph
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.153 2000/03/02 02:00:16 mud Exp $";
d2675 33
@


1.153
log
@made see soul  tar_+char+_defenszie , it can't be tar ignore, victim becomes null
and it crashes the game. if you want to see soul on someone not in the room
we need new code for that
Minsiter
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.152 2000/03/02 01:31:06 mud Exp $";
d1667 1
a1669 1
    ch->mana -= (ch->level/5);
d1672 2
d1675 1
d1677 1
@


1.152
log
@ first attempt to find see soul crash bug, debug statements are in
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.151 2000/03/02 01:15:33 mud Exp $";
a2226 1
  send_to_char( "1\n ", ch );
a2227 1
  send_to_char( "2\n ", ch );
a2230 1
  send_to_char( "3\n ", ch );
a2241 1
  send_to_char( "4\n ", ch );
a2243 1
  send_to_char( "5\n ", ch );
a2244 1
  send_to_char( "6\n ", ch );
a2245 1
  send_to_char( "7\n ", ch );
a2250 1
  send_to_char( "That would crash the game \n\r", ch );
@


1.151
log
@temp fix for see soul
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.150 2000/02/27 00:59:56 mud Exp $";
d2223 1
a2223 1
/*
d2227 1
d2229 1
d2233 1
d2245 1
d2248 1
d2250 1
d2252 1
@


1.150
log
@see soul no longer offensive, so nonclanners can use it
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.149 2000/02/23 19:52:01 mud Exp $";
d2223 1
d2251 1
@


1.149
log
@adjust elementalist stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.148 2000/02/23 17:59:32 mud Exp $";
d2246 1
d2248 1
@


1.148
log
@tweak irradiate
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.147 2000/02/19 18:50:40 mud Exp $";
d1119 1
a1119 1
    af.duration		= 3 + (ch->level > 5 ) +
d1123 1
a1123 1
    af.modifier		= -2 - (ch->level > 5)
d1214 1
a1214 1
    af.modifier		= -1 * (ch->level / 12 );
@


1.147
log
@ fight.c  changed the pen for blademasters to /5 instead of /4
	  so they have the same pen as druids

 handler.c
	changed max trainable to be similar to max attainable
	so reclasses now get +1 to both mixed reclass primaries
	instead of a +2 on a reclass primary

 magic.c
	added two more mods to saves calculations

 mag2.c
	 cahnged earthbind, 2 ticks now, lose haste NOT slow
	  and a lot less dex loss
	  more work to do with this spell, consider it a work in progress




	  MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.146 2000/02/15 15:13:10 mud Exp $";
d1119 1
a1119 1
    af.duration		= 5 + (ch->level > 5 ) +
@


1.146
log
@ Added in removeal of weight code for chars still under 5 login pfresh limit
 Made some shanges to summon_elemental

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.145 2000/02/13 18:49:16 mud Exp $";
d1188 1
a1188 1
    /* This one is a doosy.  Removes a haste AND applies a slow */
d1212 1
a1212 1
    af.duration		= 1 + (ch->level > 20 ) + (ch->level > 35 );
d1214 2
a1215 2
    af.modifier		= -1 * (get_curr_stat(victim,STAT_DEX) / 2 );
    af.bitvector	= AFF_SLOW;
@


1.145
log
@ const.c     ice storm back to 1 round delay and 40 mana
	     i had only compared it to braeth spells,
	     now that i looked at harm and other damage spells
	     it looks ok with 1 round delay
 mag2.c      damage was reduced to level /3, roughly equivalent to harm
             and 50% more than acid blast
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.144 2000/02/13 18:12:03 mud Exp $";
d219 1
a219 1
         af.duration  = level / 8;
d237 1
a237 1
         af.duration  = level / 8;
d279 2
a280 2
   victim->damage[DICE_NUMBER] = victim->level/6+1;
   victim->damage[DICE_TYPE]   = 5;
d282 1
a282 1
   victim->damroll = victim->level * 3 / 5;
d289 1
a289 1
   victim->life_timer = ch->level/8+10;
@


1.144
log
@ mag2.c   brought the damage back to what it was on ice storm

    Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.143 2000/02/13 17:48:01 mud Exp $";
d1468 1
a1468 1
    dam = dice(level, ch->level/2);   
@


1.143
log
@ const.c      increased mana cost to ice storm and casting delay

 mag2.c      decreased damage done with ice storm

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.142 2000/02/13 16:21:34 mud Exp $";
d1468 1
a1468 1
    dam = dice(level, ch->level/3);   
@


1.142
log
@ mag2.c     modified dust storm in an attempt to prevent the
	    temporary perma blind effect when combined with
	    irradiate.

	    Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.141 2000/02/12 16:05:45 mud Exp $";
d1177 2
d1315 2
d1468 1
a1468 1
    dam = dice(level, ch->level/2);   
@


1.141
log
@ magic.c     tweak to magic missile

 mag2.c      tweak to dust storm , hope it stops the perma blind

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.140 2000/02/05 15:30:12 mud Exp $";
d1313 1
a1313 1
    if ( is_affected(victim,AFF_BLIND) )
d1353 1
a1353 1
       if ( saves_spell(level,vch,DAM_OTHER) || is_affected(vch, AFF_BLIND) )
@


1.140
log
@mag2.c    tweak to tsumani again, it never checked your saves and dazed you
          all the time. Now you have to fail saves to be dazed.

	  MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.139 2000/02/05 15:14:45 mud Exp $";
d1313 1
a1313 1
    if ( is_affected(victim,sn) )
d1353 1
a1353 1
       if ( saves_spell(level,vch,DAM_OTHER) )
@


1.139
log
@ mag2.c    minor tweak to tsumnai, stop combat only if you can actually
	   move the  person

	   MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.138 2000/02/05 15:03:34 mud Exp $";
d2415 1
a2415 4
      {
	send_to_char("You are knocked about gurgling and sputtering.\n\r",vch);
	DAZE_STATE(vch,24);
	vch->position = POS_RESTING;
d2421 6
a2426 1
	 /* stop_fighting(vch,TRUE); */
d2435 2
a2436 1
         /* shoudl stop combat only if you can move the person */
@


1.138
log
@ mag2.c	 minor tweaks to wind, ice storm, dust storm, tsumani
	 now loops with vch->next in room instead of vch->next
	 prevetns message being sent to the caster about pick on
	 your own size and not on that target



	 MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.137 2000/02/05 01:34:23 mud Exp $";
d2424 1
a2424 1
	 stop_fighting(vch,TRUE);
d2433 2
a2434 1
 
@


1.137
log
@ mag2.c   mod to wall_of _wind vch_.next in room and not
	  vcn->next.

 fight.c  mod to parry.
	  rage is now a max of 10% based on level like bladesong and
	  CON is now taken into account in parry.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.136 2000/01/21 19:56:18 mud Exp $";
d1345 1
a1345 1
       vch_next = vch->next;
d1473 1
a1473 1
       vch_next = vch->next;
d2408 4
a2411 1
	send_to_char("Some water splashes at your ankles.\n\r",vch);
@


1.136
log
@ fiexed two small bugs in new spell confusion
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.135 2000/01/21 01:13:50 mud Exp $";
d1283 2
a1284 1
       vch_next = vch->next;
d1289 1
a1289 1
	    vch == victim )
@


1.135
log
@ See previous comments
 forgot the declare my function type...been too damn long since I coded anything
 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.134 2000/01/21 01:11:30 mud Exp $";
d2633 1
d2635 1
@


1.134
log
@I must be stupid, missed a return staement in spell_confusion
Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.133 2000/01/21 00:53:19 mud Exp $";
d2626 1
a2626 1
spell_confusion(int sn, int level, CHAR_DATA *ch, void *vo, int target)
@


1.133
log
@Added new spelll confusion.
Confuses victims sense of direction
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.132 2000/01/08 07:31:26 mud Exp $";
d2652 1
@


1.132
log
@remove 'age' and 'loss' some left over variables
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.131 2000/01/08 06:35:43 mud Exp $";
d925 2
a926 1
      || IS_SET(ch->in_room->room_flags, ROOM_IMP_ONLY) )
d2626 27
@


1.131
log
@removed all age code
-Poquah
CVS ll age ----------------------------------------------------------------------
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.130 1999/10/19 18:18:04 mud Exp $";
a1460 1
    int age;
a2248 1
  int loss;
@


1.130
log
@Spell Crusade change, just half sac points of ch and victim for now, old
code was actually giving the caster sacs in certain situations
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.129 1999/10/17 22:07:41 mud Exp $";
d890 3
a892 3
    dam = level + ( (get_age(ch) > 35) * 3 ) 
		+ ( (get_age(ch) > 50) * 3 )
		+ ( (get_age(ch) > 65) * 3 );
d1118 8
a1125 8
    af.duration		= 5 + (get_age(ch) > 20 ) +
			      (get_age(ch) > 35 ) +
			      (get_age(ch) > 50 ) +
			      (get_age(ch) > 65 );
    af.modifier		= -2 - (get_age(ch) > 20)
			     - (get_age(ch) > 35)
			     - (get_age(ch) > 50)
			     - (get_age(ch) > 65);
d1158 1
a1158 1
    fog->value[0] = 1 +(get_age(ch)>30)+(get_age(ch)>50)+(get_age(ch)>90);
d1209 1
a1209 1
    af.duration		= 1 + (get_age(ch) > 35 ) + (get_age(ch) > 50 );
d1244 1
a1244 1
    af.modifier		= get_age(ch) / 10;
d1265 1
a1265 1
    level += ( get_age(ch) / 15 );
d1325 1
a1325 1
     af.duration	= 1 + (get_age(ch) > 35 ) + (get_age(ch) > 50 );
d1391 1
a1391 1
    if ( get_age(ch) > 50 
d1426 1
a1426 1
    af.duration		= get_age(ch);
d1432 1
a1432 1
    if ( get_age(ch) > 35 ) 
d1442 1
a1442 1
    if ( get_age(ch) > 50 )
d1463 1
a1463 2
    age = get_age(ch);
    dam = dice(level, age/3);   
d2475 1
a2475 1
    af.duration         = get_age(ch)/3;
@


1.129
log
@Not allowed to morhph into Mobs, just cause 2.mobname isnt looking right
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.128 1999/10/17 20:33:58 mud Exp $";
d2276 1
d2279 1
d2282 1
d2285 4
@


1.128
log
@Trying to make it so you cant morph into Players
-POquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.127 1999/10/15 23:47:06 mud Exp $";
d1731 1
a1731 2
         sprintf(buf,"You return to your regular appearance. How boring!\n\r");
         send_to_char(buf,ch);
d1748 1
d1756 7
d1766 1
@


1.127
log
@Added messages for those in room to see morph wear off properly
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.126 1999/10/15 23:32:52 mud Exp $";
d1749 1
a1749 1
   isChar = load_char_obj(&d, argument); /* char pfile exists? */
@


1.126
log
@Added descriptive messages when morph in or out
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.125 1999/10/15 23:13:32 mud Exp $";
d1731 1
a1731 1
         sprintf(buf,"You return to your regular form. How boring!\n\r");
d1733 1
a1733 1
         act( "$r morphs into $n.",ch->long_descr,NULL,ch,TO_ROOM );
@


1.125
log
@Doh wrong variable 'name'
-POquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.124 1999/10/15 23:06:15 mud Exp $";
d1708 1
d1731 3
d1743 6
d1759 3
@


1.124
log
@Changing how to check for Players to not morph into
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.123 1999/10/15 22:57:20 mud Exp $";
d1739 1
a1739 1
   isChar = load_char_obj(&d, name); /* char pfile exists? */
@


1.123
log
@Dont allow Morphing into existing players
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.122 1999/10/15 22:40:55 mud Exp $";
d1710 1
d1739 2
a1740 1
   if ( ( victim = get_char_world( ch, arg ) ) != NULL)          
@


1.122
log
@Remove Save_Name (not needed) from all files.
Make it remove the Shapemorph on quiting.
Show in Score what you are morphed into.
Adjust Morph so you cant morph into other players online or via pfile
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.121 1999/10/15 21:27:22 mud Exp $";
a1709 1
   bool isChar = FALSE;
d1738 1
a1738 2
   isChar = load_char_obj(&d, arg); /* chr pfile exists? */
   if (isChar || ( ( victim = get_char_world( ch, arg ) ) != NULL))          
@


1.121
log
@Think I squashed the Morph Bug
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.120 1999/10/15 20:37:11 mud Exp $";
d1708 3
a1718 1
   send_to_char("0.1 \n\r",ch);
d1724 1
a1724 1
   send_to_char("0.2 \n\r",ch);
d1738 8
a1745 1
   send_to_char("0.3 \n\r",ch);
a1746 1
   send_to_char("0.4 \n\r",ch);
a1747 1
   send_to_char("0.5 \n\r",ch);
d1749 1
a1749 3
   send_to_char("1 \n\r",ch);
   free_string( ch->save_name );
   send_to_char("1.1 \n\r",ch);
@


1.120
log
@still debugging morph
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.119 1999/10/15 20:29:38 mud Exp $";
a1744 3
   return;
   strcat (ch->save_name,argument);
   send_to_char("2 \n\r",ch);
@


1.119
log
@Debugging shapemorph still
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.118 1999/10/15 02:30:42 mud Exp $";
d1743 2
@


1.118
log
@Debugging Morph still
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.117 1999/10/15 01:37:51 mud Exp $";
a1722 1
   return;
d1738 1
d1740 1
d1743 1
@


1.117
log
@Debugging Morph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.116 1999/10/15 01:31:59 mud Exp $";
d1723 1
@


1.116
log
@Debugging morph bug
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.115 1999/10/15 01:27:08 mud Exp $";
d1716 1
d1722 1
d1736 1
@


1.115
log
@Crash bug in Shapemorph
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.114 1999/10/15 01:17:32 mud Exp $";
d1737 1
d1739 1
@


1.114
log
@Changed char_in_room to check for is_name (name) and (save_name) to avoid having
to change ch->name, cause that can get messy.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.113 1999/10/15 00:48:31 mud Exp $";
a1736 1
   free_string( ch->save_name );
@


1.113
log
@who and whois should show actually save_name of morphed shifters
Added a " " to name when it appends description in mag2.c
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.112 1999/10/15 00:31:02 mud Exp $";
a1724 2
	 free_string( ch->name );
	 ch->name = str_dup( ch->save_name );
d1737 2
a1738 3
   ch->save_name = ch->name;
   strcat (ch->name," ");
   strcat (ch->name,argument);
@


1.112
log
@Added return of save_name to name when fighting starts or when shapemorph return
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.111 1999/10/13 23:38:41 mud Exp $";
d1740 1
@


1.111
log
@Working on Shapemorph, added removal of shapemorph during combat, added a save_name
variable to store of the person's name and added the actual argument to the name
while morphed so you can actually attack them, I hope.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.110 1999/10/04 21:52:33 mud Exp $";
d1725 2
@


1.110
log
@Do not allow casting of Elemental flags on a  weapon if flag already exists
this will solve the bug of it removing the flag on wear off
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.109 1999/10/02 02:36:28 mud Exp $";
d1737 2
@


1.109
log
@Damn I suck
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.108 1999/10/02 02:31:06 mud Exp $";
d764 6
d807 7
d843 6
@


1.108
log
@Work on Shapemorph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.107 1999/10/02 00:18:17 mud Exp $";
d1716 1
a1716 1
   ch->long_descr = str_dup( arguement ); 
@


1.107
log
@Typoed a MHS_SHAPEMORPHED
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.106 1999/10/02 00:15:25 mud Exp $";
d1716 1
a1716 2
   strcat(arg,"\n\r");                                                      
   ch->long_descr = str_dup( arg ); 
@


1.106
log
@Wokring on Shapemorph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.105 1999/10/02 00:09:09 mud Exp $";
d1704 1
a1704 1
      if (IS_SET(ch->mhs,MHS_SHAPEMORHPED))
@


1.105
log
@New Shapeshifter Power - Shapemorph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.104 1999/09/21 00:49:55 mud Exp $";
d1688 1
@


1.104
log
@Frostsword and Electricsword, like flamesword
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.103 1999/09/18 08:50:02 mud Exp $";
d35 1
d1685 34
@


1.103
log
@Spell_lookup should have been skill_lookup
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.102 1999/09/18 08:44:15 mud Exp $";
d786 62
@


1.102
log
@Elementalist Electric Shield
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.101 1999/09/18 08:07:07 mud Exp $";
d2336 3
a2338 3
    if ( is_affected(victim,spell_lookup("flame shield")) ||
	 is_affected(victim,spell_lookup("frost shield")) ||
	 is_affected(victim,spell_lookup("electric shield")))
d2387 3
a2389 3
    if ( is_affected(victim,spell_lookup("flame shield")) ||
	 is_affected(victim,spell_lookup("frost shield")) ||
	 is_affected(victim,spell_lookup("electric shield")))
d2432 3
a2434 3
    if ( is_affected(victim,spell_lookup("flame shield")) ||
	 is_affected(victim,spell_lookup("frost shield")) ||
	 is_affected(victim,spell_lookup("electric shield")))
@


1.101
log
@Elementalists Frost Shield
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.100 1999/08/29 14:41:00 mud Exp $";
d2336 3
a2338 1
    if ( is_affected(victim,sn) )
d2341 1
a2341 1
  send_to_char("You're already protected with a flame shield.\n\r",ch);
d2343 1
a2343 1
  act("$N is already protected by a flame shield.",ch,NULL,victim,TO_CHAR);
d2387 3
a2389 1
    if ( is_affected(victim,sn) )
d2392 1
a2392 1
  send_to_char("You're already protected with a frost shield.\n\r",ch);
d2394 1
a2394 1
  act("$N is already protected by a frost shield.",ch,NULL,victim,TO_CHAR);
d2425 46
@


1.100
log
@Bug fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.99 1999/08/23 03:34:47 mud Exp $";
d2380 41
@


1.99
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.98 1999/08/21 07:29:09 mud Exp $";
d2128 1
a2128 1
  loss = UMAX( loss, 10 );
@


1.98
log
@Changes to crusade
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.97 1999/08/21 07:09:41 mud Exp $";
d906 1
@


1.97
log
@Changed mana cost on blind
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.96 1999/08/18 01:37:19 mud Exp $";
d2110 1
a2110 1
       if(ch->pcdata->sac< 2)
d2126 3
d2131 2
a2132 1
  switch(number_range(0,2))
d2135 6
a2140 3
	case 0: break;
	case 1: victim->move /= 2; break;
	case 2: victim->mana /= 3; victim->mana *= 2; break;
@


1.96
log
@Paladin stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.95 1999/08/13 18:48:36 mud Exp $";
d75 1
a75 1
    af.duration		= level / 4 + 5;
d105 1
a105 1
    af.duration		= level / 6;
d134 1
a134 1
    af.duration			= 2 * level / 3;
a150 3



d168 2
a169 2
    af.duration	= level / 8;
    af.modifier	= ch->hitroll / 2;
@


1.95
log
@Basic stuff for alchemists, saves changes, magelabs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.94 1999/08/11 04:55:51 mud Exp $";
d2074 1
a2074 1
   level = UMIN(ch->level,level + ch->level/5);
d2105 1
a2105 1
   level = UMIN(ch->level,level + ch->level/5);
d2149 1
a2149 1
   level = UMIN(ch->level,level + ch->level/5);
@


1.94
log
@Many many changes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.93 1999/08/03 04:27:31 mud Exp $";
d46 138
@


1.93
log
@Testing rust weapon, never seems to land
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.92 1999/07/29 18:47:48 mud Exp $";
d387 1
a387 1
    af.modifier		= -1 * (level/10);
@


1.92
log
@Stop tsunami from turning group members against you
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.91 1999/07/14 18:13:58 mud Exp $";
d786 1
a786 1
	send_to_char("You failed.\n\r",ch);
d798 1
a798 1
	send_to_char("You failed.\n\r",ch);
d806 1
a806 1
	send_to_char("You failed.\n\r",ch);
d816 1
a816 1
	send_to_char("You failed.\n\r",ch);
@


1.91
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: mag2.c,v 1.90 1999/07/11 19:09:23 mud Exp $";
d2106 1
d2108 1
@


1.90
log
@fixed some bugs in battle ragere, new toast messages and summon elemental

Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.89 1999/07/05 18:11:38 mud Exp $ */
@


1.89
log
@ finally squahed the bug.. removed debugfging stuff

 R.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.88 1999/07/05 18:07:31 mud Exp $ */
a51 1
      char buf[MAX_STRING_LENGTH];
d134 1
a134 1
   victim->level = level * 9/10+1;
d143 1
a143 1
   victim->damage[DICE_NUMBER] = victim->level/4+1;
d145 2
a146 2
   victim->hitroll = victim->level;
   victim->damroll = victim->level * 2 / 3;
@


1.88
log
@I think I go t it this time..maybe I'll actually be right

R.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.87 1999/07/05 18:02:18 mud Exp $ */
a64 3

      sprintf(buf,"count = %d.\n\r",count );
	    send_to_char(buf,ch);
@


1.87
log
@Debug Elemental
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.86 1999/07/05 18:00:50 mud Exp $ */
d151 1
a151 1
   SET_BIT (victim->act,MHS_ELEMENTAL); /* just to make sure */
@


1.86
log
@Debug Elemental
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.85 1999/07/05 17:54:47 mud Exp $ */
d52 1
a65 1
   char buf[MAX_STRING_LENGTH];
@


1.85
log
@finally found the bloody bug

Rage
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.84 1999/07/05 17:51:36 mud Exp $ */
d65 3
@


1.84
log
@Debug Summon elementa
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.83 1999/07/05 17:43:57 mud Exp $ */
d61 2
a62 2
      if ( (is_same_group( victim, ch ) && IS_SET(victim->act,MHS_ELEMENTAL))
   || (is_same_group(victim->master,ch) && IS_SET(victim->act,MHS_ELEMENTAL)))
a64 2
sprintf(buf,"count= %d.\n\r",count);
send_to_char(buf,ch);
@


1.83
log
@ last try to fix bug with summon elemental


 Rage
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.82 1999/07/05 17:34:05 mud Exp $ */
d64 3
@


1.82
log
@pefully fixed bug in summoner kit


Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.81 1999/07/05 02:24:57 mud Exp $ */
d65 1
a65 1
   if ( count > 0 && !IS_IMMORTAL(ch))
@


1.81
log
@dded summon elemental spell and kit for elemntalists

Rage.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.80 1999/06/27 06:05:24 mud Exp $ */
d51 1
a51 1
   int t, number;
d59 1
a60 1
   {
d63 1
a63 4
      {
  send_to_char ("You're controlling as many elementals as you can handle.",ch);
  return;
      }}
d65 6
@


1.80
log
@Seer
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.79 1999/06/17 15:36:11 mud Exp $ */
d44 109
@


1.79
log
@Addded NOCLAN room flag not allowing clanners in rooms
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.78 1999/06/12 00:34:00 mud Exp $ */
a1965 1
	return;
d1968 2
@


1.78
log
@Fixed seer error
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.77 1999/06/11 23:21:55 mud Exp $ */
d1954 1
a1954 1
   ||   (!is_room_owner(ch,victim->in_room) && room_is_private(victim->in_room))
@


1.77
log
@Stuff I changed.  mostly updates of existing files and changes to seer
and flee.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.76 1999/05/22 21:44:16 mud Exp $ */
d1965 1
a1965 1
	act("You feel as though you are being watched.",ch,NULL,NULL,TO_CHAR);
@


1.76
log
@*Added flame shiel
*Fixed betstow holiness and flamesword
*Repaired a bug in shapaeshifter
*that's it
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.75 1999/05/20 03:27:05 mud Exp $ */
d1962 6
@


1.75
log
@Must have shapeshifter kit to shapeshift.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.74 1999/05/19 04:31:57 mud Exp $ */
d93 1
d239 1
a239 1
    if ( is_affected(victim,sn) || saves_spell(level,victim,DAM_OTHER) )
d248 1
a248 1
    af.duration		= (level / 3);
a259 5





d491 1
a491 1
    if ( obj->item_type != ITEM_WEAPON || obj->value[4] != 0 )
d501 1
a501 1
    af.duration		= level / 2;
d516 1
a516 1
    if ( obj->item_type != ITEM_WEAPON || obj->value[4] != 0 )
d525 1
a525 1
    af.duration		= level / 10;
d1077 1
d2066 50
@


1.74
log
@Fix shift return bug
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.73 1999/05/18 18:59:56 mud Exp $ */
d1388 6
@


1.73
log
@str_cmp not str_comp in shapeshifter you bonehead
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.72 1999/05/18 18:49:55 mud Exp $ */
d1399 1
a1399 1
	 if (ch->save_con_mod == 0)
@


1.72
log
@Shapeshifters can not shift into Mutants
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.71 1999/05/18 18:18:56 mud Exp $ */
d1425 1
a1425 1
   if (!str_comp(race_table[race].name,"mutant"))
@


1.71
log
@SHapeshifter changes - Add Saves Penalty, Slow Regen of Con mod
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.70 1999/05/17 21:26:04 mud Exp $ */
d1422 6
@


1.70
log
@Cleaned up a warning message in shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.69 1999/05/17 21:22:47 mud Exp $ */
d1399 10
a1408 2
         shapeshift_remove(ch); 
         return;
d1427 7
a1433 1
      send_to_char("You are already Shapeshifted.\n\r",ch);
d1494 1
a1494 1
   /* Save HP,Mana */
d1497 1
a1533 3
   /* Adjust HP and Mana for New Race */
   /* ** routine needed here **/

d1537 1
d1571 1
a1571 1
   /* Return HP,Mana */
d1574 1
a1574 3

   /* Remove Con Modifiers from Initial and Per Tick */
   ch->mod_stat[STAT_CON] = 0;
a1601 1
   REMOVE_BIT(ch->mhs,MHS_SHAPESHIFTED);
@


1.69
log
@Typo in shapeshifter size diff
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.68 1999/05/17 21:13:24 mud Exp $ */
d1460 1
a1460 1
   if ((ch->level = 51) && (sizediff = 5))
d1463 1
a1463 1
   if (sizediff = 0)
@


1.68
log
@Added fail percentages to Shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.67 1999/05/17 06:26:27 mud Exp $ */
d1463 1
a1463 1
   if (diff = 0)
@


1.67
log
@Shapeshifter level based percentages of sucess
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.66 1999/05/17 03:47:44 mud Exp $ */
d1386 2
d1423 8
d1434 1
a1434 1
      if(ch->size != pc_race_table[race].size)
d1441 10
d1452 13
d1466 6
a1483 9
   /* Strip them down and prepare to be shapeshifted */
   /* Remove Affects
   while ( ch->affected )
      affect_remove( ch, ch->affected );
   ch->affected_by = 0;
   */

   /* Remove Res,Vulns,Imms If not done from above */

a1525 9
   /* Slash Current HP and Mana from Drain of Shifting */
   /* Dont drop below one, no need to kill them */
   if (ch->hit > 1)
      ch->hit = ch->hit /2;
   
   /* Dont drop Mana below 1, just to be kind */
   if (ch->mana > 1)
      ch->mana = ch->mana /2;

a1549 8
   /* Remove Affects 
   while ( ch->affected )
      affect_remove( ch, ch->affected );
   ch->affected_by = 0;
   */

   /* Remove Res,Vulns,Imms If not done from above */

a2046 1

@


1.66
log
@Shapeshifting
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.65 1999/05/16 06:59:10 mud Exp $ */
d1421 12
@


1.65
log
@You little bug I eat you raw!
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.64 1999/05/16 06:17:40 mud Exp $ */
d1434 1
a1434 1
   /* Remove Affects */
d1438 1
d1469 4
a1472 4
   ch->affected_by = ch->affected_by|race_table[race].aff;
   ch->imm_flags   = ch->imm_flags|race_table[race].imm;
   ch->res_flags   = ch->res_flags|race_table[race].res;
   ch->vuln_flags  = ch->vuln_flags|race_table[race].vuln;
d1482 1
a1482 1
   /*** routine needed here **/
a1486 1
   { 
d1488 1
a1488 1
   }
a1490 1
   {
a1491 1
   }
d1517 1
a1517 1
   /* Remove Affects */
d1521 1
d1530 2
a1531 1
   ch->race = ch->save_race;
d1537 3
d1545 4
a1548 4
   ch->affected_by = ch->affected_by|race_table[race].aff;
   ch->imm_flags   = ch->imm_flags|race_table[race].imm;
   ch->res_flags   = ch->res_flags|race_table[race].res;
   ch->vuln_flags  = ch->vuln_flags|race_table[race].vuln;
d1553 9
d1564 1
a1564 1
   act( "$n returns to %s natural form.", ch, NULL, ch, TO_ROOM );
@


1.64
log
@change str_cmp to str_prefix in SHAPESHIFTER
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.63 1999/05/16 06:08:15 mud Exp $ */
d1400 5
a1405 5
   else
   {
      send_to_char("You are not Shapeshifted.\n\r",ch);
      return;
   } 
@


1.63
log
@Bug Squish!
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.62 1999/05/16 05:48:33 mud Exp $ */
d1393 1
a1393 1
   if ( !str_cmp(arg,"return"))
d1496 1
a1496 1
   if (!str_cmp(race_table[race].name ,"elf"))
@


1.62
log
@Shapeshifting to a bug
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.61 1999/05/16 05:40:26 mud Exp $ */
d1393 1
a1393 3
      sprintf(buf,"%s %s.\n\r",argument,arg );
send_to_char(buf,ch);
   if ( str_cmp(argument,"return"))
d1496 1
a1496 1
   if (str_cmp(race_table[race].name ,"elf"))
@


1.61
log
@debugging shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.60 1999/05/16 05:00:22 mud Exp $ */
d1393 2
a1394 1
send_to_char("%s %s\n\r",ch);
@


1.60
log
@Squash a bug here squash a bug there
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.59 1999/05/16 04:50:19 mud Exp $ */
d1393 1
a1393 1

a1397 1
         send_to_char("You return to your normal race.\n\r",ch);
@


1.59
log
@Shapeshift here shapeshift there
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.58 1999/05/16 04:27:47 mud Exp $ */
d1396 1
a1396 1
      if (IS_AFFECTED(ch->mhs,MHS_SHAPESHIFTED))
d1417 1
a1417 1
   if (IS_AFFECTED(ch->mhs,MHS_SHAPESHIFTED))
@


1.58
log
@Actually have the shapeshift do a set_bit and remove_bit *bonk*
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.57 1999/05/16 00:51:12 mud Exp $ */
d1396 1
a1396 1
      if (IS_AFFECTED(ch,MHS_SHAPESHIFTED))
d1417 1
a1417 1
   if (IS_AFFECTED(ch,MHS_SHAPESHIFTED))
@


1.57
log
@Last of the shapeshifter bugs for now?
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.56 1999/05/16 00:40:02 mud Exp $ */
d1510 1
d1556 1
@


1.56
log
@Shapeshift
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.55 1999/05/16 00:37:07 mud Exp $ */
d1498 1
a1498 1
   if (str_cmp(race,"elf"))
d1500 1
a1500 1
      sprintf(buf,"You transform into an %s.\n\r",race);
d1502 1
a1502 1
      act( "$n transforms into an $r.", ch, NULL, race, TO_ROOM );
d1506 1
a1506 1
      sprintf(buf,"You transform into a %s.\n\r",race);
d1508 1
a1508 1
      act( "$n transforms into a $r.", ch, NULL, race, TO_ROOM );
d1516 1
a1516 1
   sh_int race;
@


1.55
log
@Bug Cleaning in Shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.54 1999/05/16 00:17:43 mud Exp $ */
d43 1
a43 1
void  shapeshift_remove((CHAR_DATA *ch));
@


1.54
log
@Working on more of Shapeshifting
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.53 1999/05/15 23:34:33 mud Exp $ */
a35 1
DECLARE_DO_FUN(do_shapeshift_remove);
d43 1
d1384 2
d1399 1
a1399 1
         do_shapeshift_remove(ch); 
d1513 1
a1513 1
void do_shapeshift_remove( CHAR_DATA *ch)
d1515 3
d1540 1
a1540 1
      ch->perm_stat[i] = ch->save_stats[i];
d1552 1
a1552 2
   sprintf(buf,"You return to your natural form.\n\r",);
   send_to_char(buf,ch);
d1557 1
a1557 1
*/ Shapeshift currently in work - Poquah */
@


1.53
log
@Cleaning out bugs in Shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.52 1999/05/15 23:27:59 mud Exp $ */
d35 2
d43 1
d1382 2
d1394 1
a1394 1
      if (IS_AFFECTED(ch,AFF_SHAPESHIFTED))
d1397 1
a1397 1
         shapeshift_remove(ch); 
d1415 1
a1415 1
   if (IS_AFFECTED(ch,AFF_SHAPESHIFTED))
d1431 1
d1452 1
a1452 1
   * Compare New Race Stats to Existing Stats */
d1511 1
a1511 1
void shapeshift_remove( CHAR_DATA *ch)
@


1.52
log
@Added comments to shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.51 1999/05/15 22:27:22 mud Exp $ */
a1378 1
   sh_int i =0;
d1387 1
a1387 1
   if ( str_cmp(arg[0],"return")
@


1.51
log
@Working on Shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.50 1999/05/15 21:56:42 mud Exp $ */
d1417 2
a1418 2
   * Save off Real Race Information for Restore later *
   * Save Race *
d1421 1
a1421 1
   * Save Stats *
d1425 1
a1425 1
   * Save HP,Mana *
d1428 2
a1429 2
   * Strip them down and prepare to be shapeshifted *
   * Remove Affects *
d1434 1
a1434 1
   * Remove Res,Vulns,Imms If not done from above *
d1436 1
a1436 1
   * Remove ALL Worn EQ *
d1439 1
a1439 1
   * Begin Shapeshift *
d1442 2
a1443 2
   * initialize stats *
   * Get New Race Stats Temp *
d1447 2
a1448 2
   * Compare New Race Stats to Existing Stats *
   * If Existing Stat is below New Race Minimum *
d1455 1
a1455 1
   * If Existing Stat is above New Race Maximum *
d1462 1
a1462 1
   * Add on New Race Aff,Imm,Res,Vulns,Form,Parts,Size *
d1471 2
a1472 2
   * Adjust HP and Mana for New Race *
   *** routine needed here ***
d1474 3
a1476 3
   * Drop CON for being ShapeShifted -3 initial 
      and %5 chance every tick -1 *
   *** routine needed here ***
d1478 2
a1479 2
   * Slash Current HP and Mana from Drain of Shifting *
   * Dont drop below one, no need to kill them *
d1484 1
a1484 1
   * Dont drop Mana below 1, just to be kind *
d1490 1
a1490 1
   * Display change to CH and Room *
a1494 1
   * Can we use ACT in this case to send to room? *
a1500 1
      * Can we use ACT in this case to send to room? *
d1508 1
a1508 1
   * Return from Shapeshift *
d1510 1
a1510 1
   * Remove Affects *
d1515 1
a1515 1
   * Remove Res,Vulns,Imms If not done from above *
d1517 1
a1517 1
   * Remove All Worn EQ *
d1520 2
a1521 2
   * Retrieve Real Race Information from Save *
   * Return Race *
d1524 1
a1524 1
   * Return HP,Mana *
d1528 1
a1528 1
   * Return Stats *
d1532 1
a1532 1
   * Return Old Race Aff,Imm,Res,Vulns,Form,Parts,Size *
d1541 1
a1541 1
   * Display return to CH and Room *
@


1.50
log
@Adding 'r' Race to act for use in shapeshifter
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.49 1999/05/03 08:00:19 mud Exp $ */
d1375 1
a1375 1
/* ShapeShift in Work - Poquah
d1550 1
a1550 1
Shapeshift currently in work - Poquah */
@


1.49
log
@Bank code.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.48 1999/04/07 18:38:38 mud Exp $ */
d1436 2
a1437 2
   * Remove All Worn EQ *
  *** routine needed here ***
d1496 1
a1496 1
      act( "$n transforms into an elf.", ch, NULL, NULL, TO_ROOM );
d1503 1
a1503 1
      act( "$n transforms into a %s.", ch, NULL, NULL, TO_ROOM );
d1520 1
a1520 1
   *** routine needed here ***
@


1.48
log
@Hold person spell only when not in combat, even with Bishop
kit.  Replicated 'lay on hands' code.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.47 1999/03/31 01:37:46 mud Exp $ */
d42 25
@


1.47
log
@Gave error during compile of comment with a comment
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.46 1999/03/31 01:27:22 mud Exp $ */
d320 6
@


1.46
log
@Begin ShapeShift Ability (commented out)
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.45 1999/03/26 19:58:53 mud Exp $ */
d1386 2
a1387 2
   /* Save off Real Race Information for Restore later */
   /* Save Race */
d1390 1
a1390 1
   /* Save Stats */
d1394 1
a1394 1
   /* Save HP,Mana */
d1397 2
a1398 2
   /* Strip them down and prepare to be shapeshifted */
   /* Remove Affects */
d1403 1
a1403 1
   /* Remove Res,Vulns,Imms If not done from above */
d1405 1
a1405 1
   /* Remove All Worn EQ */
d1408 1
a1408 1
   /* Begin Shapeshift */
d1411 2
a1412 2
   /* initialize stats */
   /* Get New Race Stats Temp */
d1416 2
a1417 2
   /* Compare New Race Stats to Existing Stats */
   /* If Existing Stat is below New Race Minimum */
d1424 1
a1424 1
   /* If Existing Stat is above New Race Maximum */
d1431 1
a1431 1
   /* Add on New Race Aff,Imm,Res,Vulns,Form,Parts,Size */
d1440 1
a1440 1
   /* Adjust HP and Mana for New Race */
d1443 2
a1444 2
   /* Drop CON for being ShapeShifted -3 initial 
      and %5 chance every tick -1 */
d1447 2
a1448 2
   /* Slash Current HP and Mana from Drain of Shifting */
   /* Dont drop below one, no need to kill them */
d1453 1
a1453 1
   /* Dont drop Mana below 1, just to be kind */
d1459 1
a1459 1
   /* Display change to CH and Room */
d1464 1
a1464 1
   /* Can we use ACT in this case to send to room? */
d1471 1
a1471 1
      /* Can we use ACT in this case to send to room? */
d1479 1
a1479 1
   /* Return from Shapeshift */
d1481 1
a1481 1
   /* Remove Affects */
d1486 1
a1486 1
   /* Remove Res,Vulns,Imms If not done from above */
d1488 1
a1488 1
   /* Remove All Worn EQ */
d1491 2
a1492 2
   /* Retrieve Real Race Information from Save */
   /* Return Race */
d1495 1
a1495 1
   /* Return HP,Mana */
d1499 1
a1499 1
   /* Return Stats */
d1503 1
a1503 1
   /* Return Old Race Aff,Imm,Res,Vulns,Form,Parts,Size */
d1512 1
a1512 1
   /* Display return to CH and Room */
@


1.45
log
@The hold person spell now makes you rest stopping combat initiation.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.44 1999/03/26 03:39:21 mud Exp $ */
d1344 176
@


1.44
log
@Fixed typo in Enervation, flaters to falters.
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.43 1999/03/15 14:57:07 mud Exp $ */
d337 1
@


1.43
log
@Fixed spell_knock
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.42 1999/03/14 21:41:38 mud Exp $ */
d201 1
a201 1
	act("$N's magical ability flaters.",ch,NULL,victim,TO_CHAR);
@


1.42
log
@Finally got tsunami working right
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.41 1999/03/14 21:22:23 mud Exp $ */
d40 1
a40 1
extern const int rev_dir [];
d114 1
d119 1
d147 2
a148 1
    if ( ( door = find_door( ch, arg ) ) >= 0 )
a151 1
	EXIT_DATA *pexit;
a153 1
	pexit = ch->in_room->exit[door];
d155 1
a155 1
	    { send_to_char( "It's not closed.\n\r",        ch ); return; }
d161 1
a161 1
	    { send_to_char( "You failed.\n\r",             ch ); return; }
d169 1
a169 1
	&&   ( pexit_rev = to_room->exit[rev_dir[door]] ) != NULL
d284 1
a284 1
	act("$N appears to to have forgotten something.",
@


1.41
log
@Moved damage to the end of tsunami affects to
prevent moving about dead chars.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.40 1999/03/14 21:19:19 mud Exp $ */
d1717 1
d1739 1
a1739 1
	 move_char( ch, door, FALSE );
@


1.40
log
@More silly tsunami fixes
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.39 1999/03/14 20:15:26 mud Exp $ */
d1720 1
a1720 2
        damage_old( ch,vch,2*level + dice(3, 8), sn, DAM_DROWNING,TRUE);
	send_to_char("You are knocked about gurgling and sputtering\n\r",vch);
d1741 1
@


1.39
log
@spell_tsunami func declaration fixes
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.38 1999/03/14 20:10:03 mud Exp $ */
d1713 1
a1713 1
      if ( vch != ch && !is_safe_spell(ch,vch,TRUE))
@


1.38
log
@Added tsunami spell.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.37 1999/03/04 20:12:53 mud Exp $ */
d1698 1
a1698 1
void spell_tsunami(int sn, int level, CHAR_DATA *ch, void *vo, in target)
@


1.37
log
@Fixed 'hold person' to lower victim DEX instead of raise it.
Made 'sacred guardian' only yell when attacked by a PC.
Tried to fix the THIEF flag giving thing for caught infiltrators.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.36 1999/01/12 20:53:20 mud Exp $ */
d257 1
a257 1
	act("$N's willpowr fades away.",ch,NULL,victim,TO_CHAR);
d1698 54
d1793 1
@


1.36
log
@Adjusted to add damage for enhance spell.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.35 1999/01/12 20:24:29 mud Exp $ */
d331 1
a331 1
    af.modifier		= ( get_curr_stat(victim,STAT_DEX) - 3 );
@


1.35
log
@Added stuff for wu jen kit.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.34 1999/01/09 15:41:12 mud Exp $ */
d1733 1
@


1.34
log
@Made the affect of spell_flamesword() last longer.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.33 1999/01/05 15:40:24 mud Exp $ */
d1696 41
@


1.33
log
@Switched + INT to - INT in spell_feeblemind()
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.32 1999/01/03 03:45:06 mud Exp $ */
d493 1
a493 1
    af.duration		= level / 12;
@


1.32
log
@Finished traveler's fog.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.31 1998/12/31 21:16:34 mud Exp $ */
d250 1
a250 1
    af.modifier		= (level/10);
@


1.31
log
@Hmmmm
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.30 1998/12/31 20:45:00 mud Exp $ */
d784 7
a790 1
    if ( ( fog = create_object( get_obj_index(OBJ_VNUM_FOG), 0, FALSE ) ) == NULL )
d796 1
a796 1
    fog->value[0] = 1 + (get_age(ch) > 35) + (get_age(ch) > 50 );
d798 3
@


1.30
log
@Fixed a couple typos in farsee.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.29 1998/12/31 20:40:26 mud Exp $ */
d1682 2
a1683 1
 sprintf(buf,"%s is at %s\n\r",victim->name,victim->in_room->name);
@


1.29
log
@made farsee not work if you switched kits.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.28 1998/12/31 20:25:11 mud Exp $ */
d1655 1
a1655 1
 buf char[MAX_STRING_LENGTH];
d1672 1
a1672 1
   ||   saves_spell( level, victim, DAM_MENTAL) )             
d1683 1
a1683 1
 send-to_char(buf,ch);
@


1.28
log
@Added the seer kit, gives farsee spell.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.27 1998/12/23 16:51:35 mud Exp $ */
d1656 6
@


1.27
log
@Bunch of changes for rogues, including new skill and pther improvements
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.26 1998/12/09 08:32:17 mud Exp $ */
d1652 29
@


1.26
log
@Re-reclassing.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.25 1998/12/08 23:12:09 mud Exp $ */
d56 1
a56 1
    af.duration		= level / 5;
@


1.25
log
@A
Bugs fixed.  Prophets added
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.24 1998/12/08 22:38:13 mud Exp $ */
d219 1
a219 1
    af.modifier		= (level / 15 );
@


1.24
log
@Fixed some bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.23 1998/12/08 08:42:38 mud Exp $ */
d42 23
d80 2
@


1.23
log
@Vindicators
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.22 1998/11/29 22:26:22 mud Exp $ */
d51 1
a51 1
    if ( number_percent() < ch->pcdata->sac / 3 )
d53 1
a53 1
	send_to_char("You fail in invoke the anger of your deity.\n\r",ch);
@


1.22
log
@Neat crusader stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.21 1998/11/28 07:49:35 mud Exp $ */
d42 43
d914 6
@


1.21
log
@favored flag
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.20 1998/11/22 10:36:37 mud Exp $ */
d374 1
a374 1
    af.duration		= (level / 5);
@


1.20
log
@Added wizards
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.19 1998/11/22 08:14:41 mud Exp $ */
d716 1
a716 1
    if ( ( fog = create_object( get_obj_index(OBJ_VNUM_FOG), 0 ) ) == NULL )
d1111 1
a1111 1
    portal = create_object(get_obj_index(OBJ_VNUM_PORTAL),0);
d1181 1
a1181 1
    portal = create_object(get_obj_index(OBJ_VNUM_PORTAL),0);
d1195 1
a1195 1
    portal = create_object(get_obj_index(OBJ_VNUM_PORTAL),0);
@


1.19
log
@I had to split up clan checks and can_see_room() checiks, added them all back into the code to make sure it's all consistant
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.18 1998/11/22 02:05:15 mud Exp $ */
d37 209
@


1.18
log
@Crusader spells
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.17 1998/11/21 02:51:12 mud Exp $ */
d868 1
d936 1
@


1.17
log
@New spells for elementalists so tehy'll shut the hell up
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.16 1998/11/15 09:29:35 mud Exp $ */
d37 164
@


1.16
log
@minor bug fix.  aeshteic thing
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.15 1998/10/15 23:06:01 mud Exp $ */
d37 31
@


1.15
log
@Various bug fixes
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.14 1998/10/10 02:26:08 mud Exp $ */
d605 1
a605 1
/*
d610 2
a611 7
    int dam
    int age

    age = get_age(ch)
    dam = dice(level, age/3)   

    if ( saves_spell(level,victim,DAM_FROST) )
d613 2
a614 1
        damage_old(ch,victim,dam/2,sn,DAM_FROST,FALSE);
d616 2
d619 1
a619 4

           damage_old(ch,victim,dam,DAM_FROST,FALSE);

        
a621 1

a622 1

d624 1
a624 3



a625 1

a626 1

a627 1

a628 1

d631 2
a632 6


        if ( saves_spell(level,vch,DAM_FROST) )

           damage_old(ch,vch,dam/2,sn,DAM_FROST,FALSE);

d634 1
a634 7

        {
           
           damage_old(ch,vch,dam,sn,DAM_FROST,FALSE);

        }

d638 1
a638 3


*/
@


1.14
log
@added apsecial for 51 obstacle course
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.13 1998/10/09 20:15:17 mud Exp $ */
d368 1
a368 1
    af.modifier		= (get_curr_stat(victim,STAT_DEX) / 2 );
@


1.13
log
@charm break changes
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.12 1998/10/08 22:19:57 mud Exp $ */
d684 1
a684 1
        send_to_char("You are held fast by a snare trap.\n\r",victim);          
d749 1
a749 1
        send_to_char("You are held fast by a snare trap.\n\r",victim);          
@


1.12
log
@Added mistform
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.11 1998/10/05 09:10:26 mud Exp $ */
d682 12
d746 12
@


1.11
log
@C

Added ability to flag an entrei area as no-transport.
Set any mob in the area to act_notrans and it's automatic from there.
Saves us the annoyance of converting area files formats.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.10 1998/10/01 22:53:41 mud Exp $ */
d104 25
@


1.10
log
@C added delay to orb of touch
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.9 1998/10/01 22:50:53 mud Exp $ */
d671 3
a673 1
    ||  victim->in_room->area->under_develop )
d727 3
a729 1
    ||  victim->in_room->area->under_develop )
@


1.9
log
@C
aded a wait state to orbs
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.8 1998/08/30 03:33:37 mud Exp $ */
d904 1
@


1.8
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.7 1998/08/20 21:05:34 mud Exp $ */
d903 2
@


1.7
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.6 1998/08/17 20:05:01 mud Exp $ */
d867 1
a867 1
  if(IS_SET(ch->act,PLR_COLOR))
@


1.6
log
@Elementalists and some of their spells added.
Material table begun.

-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.5 1998/08/15 18:45:49 mud Exp $ */
d32 1
a32 1

d38 265
d580 59
d1049 1
a1049 1
 sprintf(buf,"They are a follower of %s.\n\r",deity_table[victim->deity].pname);
d1064 1
a1064 1
  if(IS_NPC(victim) || ch->deity == victim->deity 
d1071 1
a1071 1
       if(ch->sac< 2)
d1074 1
a1074 1
	deity_table[ch->deity].pname);
d1080 1
a1080 1
		deity_table[ch->deity].pname, victim->name);
d1083 1
a1083 1
		deity_table[victim->deity].pname,deity_table[ch->deity].pname);
d1086 3
a1088 3
  loss = ch->sac / 2;
  ch->sac -= loss;
  victim->sac = UMAX(0,victim->sac - loss);
d1130 1
a1130 1
	deity_table[vch->deity].pname );
@


1.5
log
@skills.c changed to add level range args for 'skills' and spells' commands
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.4 1998/08/02 15:26:27 mud Exp $ */
d38 278
a816 28
void spell_earthbind(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA)* vo;
    AFFECT_DATA af;

    if ( saves_spell( level, victim, DAM_OTHER ) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    af.where 		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= 0;
    af.location		= 0;
    af.modifier		= 0;
    af.bitvector	= 0;

    affect_to_char(victim,&af);

    act("$N's feet sink into the ground, immobilized.",ch,NULL,victim,TO_CHAR);
    act("$N's feet sink into the ground, immobilized!",ch,NULL,victim,TO_NOTVICT);
    act("Your feet sink into the ground, immobilizing you!",
	ch,NULL,victim,TO_VICT);

    return;
}
@


1.4
log
@transport spell level adjustments
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.3 1998/08/02 14:30:35 mud Exp $ */
d536 30
@


1.3
log
@Druid dodge, parry and shield block reductions
removal of nofollow cancelling charm and spell_charm_person() tweeked
to accomodate PC charmings.
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.2 1998/08/01 13:03:28 mud Exp $ */
d64 1
a64 1
    ||   victim->level >= level + 3
d118 1
a118 1
    ||   victim->level >= level + 3
@


1.2
log
@Piety spells level mod
@
text
@d18 1
a18 1
/* @@(#)$Id: mag2.c,v 1.1 1998/06/16 17:49:37 mud Exp $ */
d430 1
a430 1
   level += ch->level/5;
d461 1
a461 1
   level += ch->level/5;
d505 1
a505 1
   level += ch->level/5;
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d430 1
d461 1
d505 1
@
