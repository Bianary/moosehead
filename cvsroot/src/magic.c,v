head	1.484;
access;
symbols;
locks; strict;
comment	@ * @;


1.484
date	2005.04.18.02.58.27;	author rusty;	state Exp;
branches;
next	1.483;

1.483
date	2004.10.09.03.32.05;	author boogums;	state Exp;
branches;
next	1.482;

1.482
date	2004.08.29.23.54.17;	author boogums;	state Exp;
branches;
next	1.481;

1.481
date	2004.01.02.17.06.03;	author rusty;	state Exp;
branches;
next	1.480;

1.480
date	2003.12.19.00.58.46;	author boogums;	state Exp;
branches;
next	1.479;

1.479
date	2003.12.17.02.11.24;	author boogums;	state Exp;
branches;
next	1.478;

1.478
date	2003.12.13.15.00.46;	author boogums;	state Exp;
branches;
next	1.477;

1.477
date	2003.12.13.14.57.29;	author boogums;	state Exp;
branches;
next	1.476;

1.476
date	2003.12.13.14.47.03;	author boogums;	state Exp;
branches;
next	1.475;

1.475
date	2003.12.10.03.04.56;	author boogums;	state Exp;
branches;
next	1.474;

1.474
date	2003.12.07.20.42.45;	author boogums;	state Exp;
branches;
next	1.473;

1.473
date	2003.12.04.03.57.00;	author boogums;	state Exp;
branches;
next	1.472;

1.472
date	2003.12.04.03.50.57;	author boogums;	state Exp;
branches;
next	1.471;

1.471
date	2003.12.04.03.45.20;	author boogums;	state Exp;
branches;
next	1.470;

1.470
date	2003.12.04.03.41.33;	author boogums;	state Exp;
branches;
next	1.469;

1.469
date	2003.12.04.03.35.55;	author boogums;	state Exp;
branches;
next	1.468;

1.468
date	2003.11.30.20.37.56;	author boogums;	state Exp;
branches;
next	1.467;

1.467
date	2003.11.30.20.32.00;	author boogums;	state Exp;
branches;
next	1.466;

1.466
date	2003.11.30.18.51.11;	author boogums;	state Exp;
branches;
next	1.465;

1.465
date	2003.11.30.17.32.03;	author boogums;	state Exp;
branches;
next	1.464;

1.464
date	2003.06.14.19.53.12;	author boogums;	state Exp;
branches;
next	1.463;

1.463
date	2003.06.07.21.25.49;	author boogums;	state Exp;
branches;
next	1.462;

1.462
date	2003.06.03.17.49.55;	author rusty;	state Exp;
branches;
next	1.461;

1.461
date	2003.05.30.02.23.05;	author ndagger;	state Exp;
branches;
next	1.460;

1.460
date	2003.05.25.17.41.45;	author boogums;	state Exp;
branches;
next	1.459;

1.459
date	2003.05.25.14.32.22;	author boogums;	state Exp;
branches;
next	1.458;

1.458
date	2003.05.25.01.34.23;	author boogums;	state Exp;
branches;
next	1.457;

1.457
date	2003.04.25.15.39.43;	author rusty;	state Exp;
branches;
next	1.456;

1.456
date	2003.04.02.04.09.46;	author boogums;	state Exp;
branches;
next	1.455;

1.455
date	2003.04.01.23.25.53;	author ndagger;	state Exp;
branches;
next	1.454;

1.454
date	2003.04.01.23.20.06;	author ndagger;	state Exp;
branches;
next	1.453;

1.453
date	2003.03.28.21.40.26;	author rusty;	state Exp;
branches;
next	1.452;

1.452
date	2003.03.27.16.18.53;	author rusty;	state Exp;
branches;
next	1.451;

1.451
date	2003.03.22.17.37.30;	author boogums;	state Exp;
branches;
next	1.450;

1.450
date	2003.02.17.21.54.51;	author ndagger;	state Exp;
branches;
next	1.449;

1.449
date	2002.12.14.17.13.59;	author boogums;	state Exp;
branches;
next	1.448;

1.448
date	2002.12.08.00.59.40;	author boogums;	state Exp;
branches;
next	1.447;

1.447
date	2002.11.26.09.38.38;	author ndagger;	state Exp;
branches;
next	1.446;

1.446
date	2002.11.26.08.58.43;	author ndagger;	state Exp;
branches;
next	1.445;

1.445
date	2002.11.15.02.26.53;	author boogums;	state Exp;
branches;
next	1.444;

1.444
date	2002.11.14.19.15.04;	author rusty;	state Exp;
branches;
next	1.443;

1.443
date	2002.11.13.00.24.03;	author ndagger;	state Exp;
branches;
next	1.442;

1.442
date	2002.11.13.00.04.57;	author ndagger;	state Exp;
branches;
next	1.441;

1.441
date	2002.11.12.01.14.01;	author ndagger;	state Exp;
branches;
next	1.440;

1.440
date	2002.10.19.16.41.05;	author boogums;	state Exp;
branches;
next	1.439;

1.439
date	2002.10.13.20.12.13;	author boogums;	state Exp;
branches;
next	1.438;

1.438
date	2002.10.12.22.30.16;	author ndagger;	state Exp;
branches;
next	1.437;

1.437
date	2002.10.12.21.41.40;	author boogums;	state Exp;
branches;
next	1.436;

1.436
date	2002.10.12.17.04.47;	author boogums;	state Exp;
branches;
next	1.435;

1.435
date	2002.10.12.03.07.35;	author boogums;	state Exp;
branches;
next	1.434;

1.434
date	2002.10.11.04.22.32;	author boogums;	state Exp;
branches;
next	1.433;

1.433
date	2002.10.11.03.38.51;	author boogums;	state Exp;
branches;
next	1.432;

1.432
date	2002.10.11.03.18.04;	author boogums;	state Exp;
branches;
next	1.431;

1.431
date	2002.10.07.02.36.52;	author boogums;	state Exp;
branches;
next	1.430;

1.430
date	2002.10.06.21.47.45;	author boogums;	state Exp;
branches;
next	1.429;

1.429
date	2002.10.06.21.01.20;	author boogums;	state Exp;
branches;
next	1.428;

1.428
date	2002.10.05.20.11.15;	author boogums;	state Exp;
branches;
next	1.427;

1.427
date	2002.10.05.19.32.28;	author boogums;	state Exp;
branches;
next	1.426;

1.426
date	2002.10.05.19.16.10;	author boogums;	state Exp;
branches;
next	1.425;

1.425
date	2002.10.05.17.25.02;	author boogums;	state Exp;
branches;
next	1.424;

1.424
date	2002.10.05.17.15.44;	author boogums;	state Exp;
branches;
next	1.423;

1.423
date	2002.10.05.17.09.32;	author boogums;	state Exp;
branches;
next	1.422;

1.422
date	2002.10.03.03.25.34;	author boogums;	state Exp;
branches;
next	1.421;

1.421
date	2002.10.02.14.49.38;	author boogums;	state Exp;
branches;
next	1.420;

1.420
date	2002.09.30.03.33.47;	author boogums;	state Exp;
branches;
next	1.419;

1.419
date	2002.09.30.02.58.19;	author boogums;	state Exp;
branches;
next	1.418;

1.418
date	2002.09.30.02.37.19;	author boogums;	state Exp;
branches;
next	1.417;

1.417
date	2002.09.30.02.32.03;	author boogums;	state Exp;
branches;
next	1.416;

1.416
date	2002.09.30.02.22.52;	author boogums;	state Exp;
branches;
next	1.415;

1.415
date	2002.09.29.21.11.51;	author boogums;	state Exp;
branches;
next	1.414;

1.414
date	2002.09.29.21.08.57;	author boogums;	state Exp;
branches;
next	1.413;

1.413
date	2002.09.29.20.59.25;	author boogums;	state Exp;
branches;
next	1.412;

1.412
date	2002.09.29.20.53.15;	author boogums;	state Exp;
branches;
next	1.411;

1.411
date	2002.09.29.20.39.33;	author boogums;	state Exp;
branches;
next	1.410;

1.410
date	2002.09.29.20.29.36;	author boogums;	state Exp;
branches;
next	1.409;

1.409
date	2002.09.29.20.23.48;	author boogums;	state Exp;
branches;
next	1.408;

1.408
date	2002.09.29.20.17.12;	author boogums;	state Exp;
branches;
next	1.407;

1.407
date	2002.09.21.16.45.50;	author boogums;	state Exp;
branches;
next	1.406;

1.406
date	2002.09.21.16.37.18;	author boogums;	state Exp;
branches;
next	1.405;

1.405
date	2002.09.21.16.30.40;	author boogums;	state Exp;
branches;
next	1.404;

1.404
date	2002.09.18.03.26.25;	author boogums;	state Exp;
branches;
next	1.403;

1.403
date	2002.09.15.14.39.04;	author boogums;	state Exp;
branches;
next	1.402;

1.402
date	2002.09.14.17.04.04;	author boogums;	state Exp;
branches;
next	1.401;

1.401
date	2002.09.14.16.31.57;	author boogums;	state Exp;
branches;
next	1.400;

1.400
date	2002.09.11.18.23.27;	author boogums;	state Exp;
branches;
next	1.399;

1.399
date	2002.09.10.18.30.56;	author boogums;	state Exp;
branches;
next	1.398;

1.398
date	2002.05.28.17.25.27;	author rusty;	state Exp;
branches;
next	1.397;

1.397
date	2002.05.22.18.00.41;	author rusty;	state Exp;
branches;
next	1.396;

1.396
date	2002.05.16.19.13.02;	author rusty;	state Exp;
branches;
next	1.395;

1.395
date	2002.04.17.15.27.34;	author poquah;	state Exp;
branches;
next	1.394;

1.394
date	2002.04.11.03.42.07;	author boogums;	state Exp;
branches;
next	1.393;

1.393
date	2002.04.10.21.21.41;	author rusty;	state Exp;
branches;
next	1.392;

1.392
date	2002.03.23.18.07.33;	author rusty;	state Exp;
branches;
next	1.391;

1.391
date	2002.03.23.18.04.45;	author rusty;	state Exp;
branches;
next	1.390;

1.390
date	2002.03.13.16.37.16;	author rusty;	state Exp;
branches;
next	1.389;

1.389
date	2002.03.09.19.14.29;	author rusty;	state Exp;
branches;
next	1.388;

1.388
date	2002.02.26.03.51.20;	author rusty;	state Exp;
branches;
next	1.387;

1.387
date	2002.02.25.17.08.10;	author mud;	state Exp;
branches;
next	1.386;

1.386
date	2002.02.22.15.59.50;	author mud;	state Exp;
branches;
next	1.385;

1.385
date	2002.02.22.15.47.42;	author mud;	state Exp;
branches;
next	1.384;

1.384
date	2002.02.22.15.45.06;	author rusty;	state Exp;
branches;
next	1.383;

1.383
date	2002.02.11.20.17.06;	author poquah;	state Exp;
branches;
next	1.382;

1.382
date	2002.02.11.18.42.18;	author poquah;	state Exp;
branches;
next	1.381;

1.381
date	2002.02.11.18.34.11;	author poquah;	state Exp;
branches;
next	1.380;

1.380
date	2002.01.26.16.25.28;	author rage;	state Exp;
branches;
next	1.379;

1.379
date	2002.01.18.15.21.02;	author mud;	state Exp;
branches;
next	1.378;

1.378
date	2002.01.18.15.17.35;	author mud;	state Exp;
branches;
next	1.377;

1.377
date	2002.01.18.15.11.26;	author rusty;	state Exp;
branches;
next	1.376;

1.376
date	2001.12.15.02.43.35;	author poquah;	state Exp;
branches;
next	1.375;

1.375
date	2001.12.15.02.41.40;	author poquah;	state Exp;
branches;
next	1.374;

1.374
date	2001.12.13.18.20.50;	author poquah;	state Exp;
branches;
next	1.373;

1.373
date	2001.12.08.02.11.06;	author poquah;	state Exp;
branches;
next	1.372;

1.372
date	2001.12.08.02.07.09;	author poquah;	state Exp;
branches;
next	1.371;

1.371
date	2001.12.05.18.22.08;	author poquah;	state Exp;
branches;
next	1.370;

1.370
date	2001.11.27.16.20.40;	author poquah;	state Exp;
branches;
next	1.369;

1.369
date	2001.11.16.00.32.19;	author rage;	state Exp;
branches;
next	1.368;

1.368
date	2001.10.29.21.17.20;	author rusty;	state Exp;
branches;
next	1.367;

1.367
date	2001.10.29.21.15.44;	author rusty;	state Exp;
branches;
next	1.366;

1.366
date	2001.10.23.03.37.19;	author boogums;	state Exp;
branches;
next	1.365;

1.365
date	2001.10.22.19.21.34;	author rusty;	state Exp;
branches;
next	1.364;

1.364
date	2001.10.18.23.20.34;	author rage;	state Exp;
branches;
next	1.363;

1.363
date	2001.10.18.19.43.57;	author rage;	state Exp;
branches;
next	1.362;

1.362
date	2001.10.18.13.44.03;	author rage;	state Exp;
branches;
next	1.361;

1.361
date	2001.10.17.03.35.57;	author boogums;	state Exp;
branches;
next	1.360;

1.360
date	2001.10.17.03.02.47;	author boogums;	state Exp;
branches;
next	1.359;

1.359
date	2001.10.05.18.09.38;	author rage;	state Exp;
branches;
next	1.358;

1.358
date	2001.09.22.17.53.01;	author rage;	state Exp;
branches;
next	1.357;

1.357
date	2001.09.22.17.41.47;	author rage;	state Exp;
branches;
next	1.356;

1.356
date	2001.09.22.17.41.18;	author rage;	state Exp;
branches;
next	1.355;

1.355
date	2001.09.22.00.10.49;	author boogums;	state Exp;
branches;
next	1.354;

1.354
date	2001.09.20.03.10.31;	author boogums;	state Exp;
branches;
next	1.353;

1.353
date	2001.09.02.08.54.21;	author guerrand;	state Exp;
branches;
next	1.352;

1.352
date	2001.08.05.22.47.37;	author guerrand;	state Exp;
branches;
next	1.351;

1.351
date	2001.07.31.03.13.54;	author boogums;	state Exp;
branches;
next	1.350;

1.350
date	2001.07.27.02.14.12;	author guerrand;	state Exp;
branches;
next	1.349;

1.349
date	2001.07.23.04.26.28;	author guerrand;	state Exp;
branches;
next	1.348;

1.348
date	2001.07.15.01.18.39;	author guerrand;	state Exp;
branches;
next	1.347;

1.347
date	2001.07.13.00.58.58;	author guerrand;	state Exp;
branches;
next	1.346;

1.346
date	2001.07.04.02.29.29;	author guerrand;	state Exp;
branches;
next	1.345;

1.345
date	2001.06.28.04.25.18;	author guerrand;	state Exp;
branches;
next	1.344;

1.344
date	2001.06.24.01.27.38;	author guerrand;	state Exp;
branches;
next	1.343;

1.343
date	2001.06.22.23.45.55;	author guerrand;	state Exp;
branches;
next	1.342;

1.342
date	2001.06.19.06.27.09;	author guerrand;	state Exp;
branches;
next	1.341;

1.341
date	2001.06.19.06.07.59;	author guerrand;	state Exp;
branches;
next	1.340;

1.340
date	2001.06.19.05.46.09;	author guerrand;	state Exp;
branches;
next	1.339;

1.339
date	2001.06.19.02.11.32;	author guerrand;	state Exp;
branches;
next	1.338;

1.338
date	2001.06.19.01.38.41;	author guerrand;	state Exp;
branches;
next	1.337;

1.337
date	2001.06.17.19.20.47;	author guerrand;	state Exp;
branches;
next	1.336;

1.336
date	2001.06.17.17.06.00;	author guerrand;	state Exp;
branches;
next	1.335;

1.335
date	2001.06.17.01.47.21;	author guerrand;	state Exp;
branches;
next	1.334;

1.334
date	2001.06.17.00.21.26;	author guerrand;	state Exp;
branches;
next	1.333;

1.333
date	2001.06.17.00.10.06;	author guerrand;	state Exp;
branches;
next	1.332;

1.332
date	2001.06.15.02.49.05;	author guerrand;	state Exp;
branches;
next	1.331;

1.331
date	2001.06.10.04.26.57;	author guerrand;	state Exp;
branches;
next	1.330;

1.330
date	2001.06.10.03.29.32;	author guerrand;	state Exp;
branches;
next	1.329;

1.329
date	2001.06.09.06.27.40;	author guerrand;	state Exp;
branches;
next	1.328;

1.328
date	2001.06.09.05.14.20;	author guerrand;	state Exp;
branches;
next	1.327;

1.327
date	2001.06.09.04.40.17;	author guerrand;	state Exp;
branches;
next	1.326;

1.326
date	2001.06.09.04.30.31;	author guerrand;	state Exp;
branches;
next	1.325;

1.325
date	2001.06.09.04.18.23;	author guerrand;	state Exp;
branches;
next	1.324;

1.324
date	2001.06.09.04.01.47;	author guerrand;	state Exp;
branches;
next	1.323;

1.323
date	2001.06.09.03.58.47;	author guerrand;	state Exp;
branches;
next	1.322;

1.322
date	2001.06.09.03.57.00;	author guerrand;	state Exp;
branches;
next	1.321;

1.321
date	2001.06.09.01.25.33;	author guerrand;	state Exp;
branches;
next	1.320;

1.320
date	2001.06.09.01.10.52;	author guerrand;	state Exp;
branches;
next	1.319;

1.319
date	2001.06.07.04.15.41;	author guerrand;	state Exp;
branches;
next	1.318;

1.318
date	2001.06.03.21.40.48;	author guerrand;	state Exp;
branches;
next	1.317;

1.317
date	2001.06.03.17.38.39;	author guerrand;	state Exp;
branches;
next	1.316;

1.316
date	2001.06.03.17.20.22;	author guerrand;	state Exp;
branches;
next	1.315;

1.315
date	2001.06.03.17.15.10;	author guerrand;	state Exp;
branches;
next	1.314;

1.314
date	2001.06.03.14.40.27;	author rusty;	state Exp;
branches;
next	1.313;

1.313
date	2001.06.02.02.16.10;	author guerrand;	state Exp;
branches;
next	1.312;

1.312
date	2001.06.02.02.12.41;	author guerrand;	state Exp;
branches;
next	1.311;

1.311
date	2001.06.01.04.25.14;	author guerrand;	state Exp;
branches;
next	1.310;

1.310
date	2001.06.01.04.10.37;	author guerrand;	state Exp;
branches;
next	1.309;

1.309
date	2001.06.01.02.37.33;	author guerrand;	state Exp;
branches;
next	1.308;

1.308
date	2001.05.28.17.55.34;	author rusty;	state Exp;
branches;
next	1.307;

1.307
date	2001.05.28.17.41.21;	author boogums;	state Exp;
branches;
next	1.306;

1.306
date	2001.05.27.22.05.34;	author rusty;	state Exp;
branches;
next	1.305;

1.305
date	2001.05.27.20.04.14;	author mud;	state Exp;
branches;
next	1.304;

1.304
date	2001.05.27.19.56.04;	author rusty;	state Exp;
branches;
next	1.303;

1.303
date	2001.05.20.21.25.44;	author rusty;	state Exp;
branches;
next	1.302;

1.302
date	2001.05.14.15.08.33;	author rusty;	state Exp;
branches;
next	1.301;

1.301
date	2001.03.20.17.44.32;	author mud;	state Exp;
branches;
next	1.300;

1.300
date	2001.03.10.15.36.48;	author mud;	state Exp;
branches;
next	1.299;

1.299
date	2001.03.03.19.14.38;	author mud;	state Exp;
branches;
next	1.298;

1.298
date	2001.03.03.18.53.59;	author mud;	state Exp;
branches;
next	1.297;

1.297
date	2001.02.10.03.29.22;	author mud;	state Exp;
branches;
next	1.296;

1.296
date	2001.01.27.03.05.44;	author mud;	state Exp;
branches;
next	1.295;

1.295
date	2001.01.27.02.39.28;	author mud;	state Exp;
branches;
next	1.294;

1.294
date	2001.01.20.00.32.12;	author mud;	state Exp;
branches;
next	1.293;

1.293
date	2001.01.20.00.24.41;	author mud;	state Exp;
branches;
next	1.292;

1.292
date	2001.01.12.03.38.47;	author mud;	state Exp;
branches;
next	1.291;

1.291
date	2000.12.22.05.13.36;	author mud;	state Exp;
branches;
next	1.290;

1.290
date	2000.12.22.04.53.57;	author mud;	state Exp;
branches;
next	1.289;

1.289
date	2000.12.22.04.46.53;	author mud;	state Exp;
branches;
next	1.288;

1.288
date	2000.12.22.04.35.30;	author mud;	state Exp;
branches;
next	1.287;

1.287
date	2000.12.21.05.37.39;	author mud;	state Exp;
branches;
next	1.286;

1.286
date	2000.12.21.05.30.57;	author mud;	state Exp;
branches;
next	1.285;

1.285
date	2000.12.17.05.12.28;	author mud;	state Exp;
branches;
next	1.284;

1.284
date	2000.12.15.05.19.37;	author mud;	state Exp;
branches;
next	1.283;

1.283
date	2000.12.13.05.03.41;	author mud;	state Exp;
branches;
next	1.282;

1.282
date	2000.12.13.04.44.09;	author mud;	state Exp;
branches;
next	1.281;

1.281
date	2000.12.13.04.39.24;	author mud;	state Exp;
branches;
next	1.280;

1.280
date	2000.12.13.04.21.38;	author mud;	state Exp;
branches;
next	1.279;

1.279
date	2000.12.13.04.17.30;	author mud;	state Exp;
branches;
next	1.278;

1.278
date	2000.12.13.04.10.22;	author mud;	state Exp;
branches;
next	1.277;

1.277
date	2000.12.09.07.05.50;	author mud;	state Exp;
branches;
next	1.276;

1.276
date	2000.12.07.05.46.13;	author mud;	state Exp;
branches;
next	1.275;

1.275
date	2000.12.06.20.42.39;	author mud;	state Exp;
branches;
next	1.274;

1.274
date	2000.12.03.22.52.29;	author mud;	state Exp;
branches;
next	1.273;

1.273
date	2000.12.03.22.39.29;	author mud;	state Exp;
branches;
next	1.272;

1.272
date	2000.12.03.20.21.10;	author mud;	state Exp;
branches;
next	1.271;

1.271
date	2000.12.03.19.29.58;	author mud;	state Exp;
branches;
next	1.270;

1.270
date	2000.12.03.03.24.03;	author mud;	state Exp;
branches;
next	1.269;

1.269
date	2000.11.27.17.14.14;	author mud;	state Exp;
branches;
next	1.268;

1.268
date	2000.11.27.17.10.44;	author mud;	state Exp;
branches;
next	1.267;

1.267
date	2000.11.19.19.01.56;	author mud;	state Exp;
branches;
next	1.266;

1.266
date	2000.11.19.18.56.25;	author mud;	state Exp;
branches;
next	1.265;

1.265
date	2000.10.16.19.17.02;	author mud;	state Exp;
branches;
next	1.264;

1.264
date	2000.09.24.16.32.00;	author mud;	state Exp;
branches;
next	1.263;

1.263
date	2000.09.02.03.27.37;	author mud;	state Exp;
branches;
next	1.262;

1.262
date	2000.08.20.00.11.26;	author mud;	state Exp;
branches;
next	1.261;

1.261
date	2000.08.19.23.39.02;	author mud;	state Exp;
branches;
next	1.260;

1.260
date	2000.08.19.23.38.08;	author mud;	state Exp;
branches;
next	1.259;

1.259
date	2000.08.19.23.29.02;	author mud;	state Exp;
branches;
next	1.258;

1.258
date	2000.08.19.23.24.49;	author mud;	state Exp;
branches;
next	1.257;

1.257
date	2000.08.19.23.22.09;	author mud;	state Exp;
branches;
next	1.256;

1.256
date	2000.08.19.22.34.54;	author mud;	state Exp;
branches;
next	1.255;

1.255
date	2000.08.19.22.29.03;	author mud;	state Exp;
branches;
next	1.254;

1.254
date	2000.08.19.21.56.27;	author mud;	state Exp;
branches;
next	1.253;

1.253
date	2000.08.18.22.58.58;	author mud;	state Exp;
branches;
next	1.252;

1.252
date	2000.08.18.22.49.04;	author mud;	state Exp;
branches;
next	1.251;

1.251
date	2000.08.18.21.38.03;	author mud;	state Exp;
branches;
next	1.250;

1.250
date	2000.08.18.21.21.41;	author mud;	state Exp;
branches;
next	1.249;

1.249
date	2000.08.01.18.07.18;	author mud;	state Exp;
branches;
next	1.248;

1.248
date	2000.07.31.22.15.00;	author mud;	state Exp;
branches;
next	1.247;

1.247
date	2000.07.27.00.19.59;	author mud;	state Exp;
branches;
next	1.246;

1.246
date	2000.07.24.18.48.47;	author mud;	state Exp;
branches;
next	1.245;

1.245
date	2000.07.22.21.20.15;	author mud;	state Exp;
branches;
next	1.244;

1.244
date	2000.07.22.20.31.51;	author mud;	state Exp;
branches;
next	1.243;

1.243
date	2000.07.21.23.45.27;	author mud;	state Exp;
branches;
next	1.242;

1.242
date	2000.07.18.23.00.13;	author mud;	state Exp;
branches;
next	1.241;

1.241
date	2000.07.18.22.47.05;	author mud;	state Exp;
branches;
next	1.240;

1.240
date	2000.07.18.22.45.03;	author mud;	state Exp;
branches;
next	1.239;

1.239
date	2000.07.18.19.08.29;	author mud;	state Exp;
branches;
next	1.238;

1.238
date	2000.07.18.18.48.45;	author mud;	state Exp;
branches;
next	1.237;

1.237
date	2000.07.17.21.00.41;	author mud;	state Exp;
branches;
next	1.236;

1.236
date	2000.07.17.20.56.28;	author mud;	state Exp;
branches;
next	1.235;

1.235
date	2000.06.30.02.23.41;	author mud;	state Exp;
branches;
next	1.234;

1.234
date	2000.06.29.23.52.38;	author mud;	state Exp;
branches;
next	1.233;

1.233
date	2000.06.28.02.37.58;	author mud;	state Exp;
branches;
next	1.232;

1.232
date	2000.06.28.01.21.11;	author mud;	state Exp;
branches;
next	1.231;

1.231
date	2000.06.27.04.21.41;	author mud;	state Exp;
branches;
next	1.230;

1.230
date	2000.06.26.04.20.30;	author mud;	state Exp;
branches;
next	1.229;

1.229
date	2000.06.21.21.37.09;	author mud;	state Exp;
branches;
next	1.228;

1.228
date	2000.06.20.22.39.32;	author mud;	state Exp;
branches;
next	1.227;

1.227
date	2000.06.18.20.48.17;	author mud;	state Exp;
branches;
next	1.226;

1.226
date	2000.06.18.20.36.06;	author mud;	state Exp;
branches;
next	1.225;

1.225
date	2000.05.29.20.03.29;	author mud;	state Exp;
branches;
next	1.224;

1.224
date	2000.05.25.02.01.17;	author mud;	state Exp;
branches;
next	1.223;

1.223
date	2000.05.23.04.19.47;	author mud;	state Exp;
branches;
next	1.222;

1.222
date	2000.05.21.02.31.55;	author mud;	state Exp;
branches;
next	1.221;

1.221
date	2000.05.21.00.28.57;	author mud;	state Exp;
branches;
next	1.220;

1.220
date	2000.05.19.13.44.02;	author mud;	state Exp;
branches;
next	1.219;

1.219
date	2000.05.16.22.55.12;	author mud;	state Exp;
branches;
next	1.218;

1.218
date	2000.05.16.21.26.30;	author mud;	state Exp;
branches;
next	1.217;

1.217
date	2000.05.16.20.33.10;	author mud;	state Exp;
branches;
next	1.216;

1.216
date	2000.05.16.00.56.01;	author mud;	state Exp;
branches;
next	1.215;

1.215
date	2000.05.14.00.27.54;	author mud;	state Exp;
branches;
next	1.214;

1.214
date	2000.05.13.22.37.25;	author mud;	state Exp;
branches;
next	1.213;

1.213
date	2000.05.13.21.55.15;	author mud;	state Exp;
branches;
next	1.212;

1.212
date	2000.05.01.21.03.35;	author mud;	state Exp;
branches;
next	1.211;

1.211
date	2000.04.18.20.40.12;	author mud;	state Exp;
branches;
next	1.210;

1.210
date	2000.04.18.20.33.51;	author mud;	state Exp;
branches;
next	1.209;

1.209
date	2000.04.18.19.51.03;	author mud;	state Exp;
branches;
next	1.208;

1.208
date	2000.04.17.22.00.50;	author mud;	state Exp;
branches;
next	1.207;

1.207
date	2000.03.24.16.23.01;	author mud;	state Exp;
branches;
next	1.206;

1.206
date	2000.03.23.14.11.33;	author mud;	state Exp;
branches;
next	1.205;

1.205
date	2000.03.22.16.10.28;	author mud;	state Exp;
branches;
next	1.204;

1.204
date	2000.03.21.02.02.16;	author mud;	state Exp;
branches;
next	1.203;

1.203
date	2000.03.21.01.56.47;	author mud;	state Exp;
branches;
next	1.202;

1.202
date	2000.03.19.00.04.31;	author mud;	state Exp;
branches;
next	1.201;

1.201
date	2000.03.14.15.10.13;	author mud;	state Exp;
branches;
next	1.200;

1.200
date	2000.03.08.14.41.37;	author mud;	state Exp;
branches;
next	1.199;

1.199
date	2000.03.08.14.25.06;	author mud;	state Exp;
branches;
next	1.198;

1.198
date	2000.03.07.13.56.06;	author mud;	state Exp;
branches;
next	1.197;

1.197
date	2000.02.29.02.02.04;	author mud;	state Exp;
branches;
next	1.196;

1.196
date	2000.02.27.00.45.09;	author mud;	state Exp;
branches;
next	1.195;

1.195
date	2000.02.24.03.17.33;	author mud;	state Exp;
branches;
next	1.194;

1.194
date	2000.02.24.03.13.00;	author mud;	state Exp;
branches;
next	1.193;

1.193
date	2000.02.24.02.54.31;	author mud;	state Exp;
branches;
next	1.192;

1.192
date	2000.02.23.19.52.02;	author mud;	state Exp;
branches;
next	1.191;

1.191
date	2000.02.19.18.50.41;	author mud;	state Exp;
branches;
next	1.190;

1.190
date	2000.02.12.16.05.46;	author mud;	state Exp;
branches;
next	1.189;

1.189
date	2000.02.08.02.58.00;	author mud;	state Exp;
branches;
next	1.188;

1.188
date	2000.02.08.02.15.59;	author mud;	state Exp;
branches;
next	1.187;

1.187
date	2000.02.07.23.02.36;	author mud;	state Exp;
branches;
next	1.186;

1.186
date	2000.01.24.17.22.10;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	2000.01.22.01.20.30;	author mud;	state Exp;
branches;
next	1.184;

1.184
date	2000.01.21.19.56.19;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2000.01.21.01.21.06;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	2000.01.21.00.53.20;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	99.12.15.17.53.45;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	99.12.02.18.34.17;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	99.12.02.18.27.16;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	99.12.02.18.20.41;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	99.12.01.22.13.49;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	99.11.30.01.32.39;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	99.11.30.01.12.56;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	99.11.26.21.49.39;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	99.11.26.21.42.32;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	99.11.26.21.41.23;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	99.11.26.21.33.51;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	99.11.19.05.41.18;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	99.11.11.18.26.06;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	99.10.07.01.48.01;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	99.10.03.00.58.44;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	99.10.02.02.07.38;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	99.09.30.00.57.47;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	99.09.30.00.55.43;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	99.09.30.00.48.01;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	99.09.14.04.39.42;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	99.08.28.21.45.51;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	99.08.28.21.21.14;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	99.08.28.21.17.16;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	99.08.28.16.34.28;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	99.08.26.19.31.24;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	99.08.23.22.48.20;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	99.08.23.19.46.26;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	99.08.23.03.34.48;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	99.08.19.04.56.50;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	99.08.13.19.40.14;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	99.08.13.18.48.36;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	99.08.13.18.34.36;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	99.08.12.01.04.00;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	99.08.11.20.18.03;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	99.08.11.04.55.52;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	99.08.11.03.30.19;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	99.08.11.00.51.03;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	99.08.09.22.08.29;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	99.07.21.01.16.30;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	99.07.21.01.13.27;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	99.07.14.18.14.00;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	99.07.06.22.34.00;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	99.07.06.04.17.16;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	99.06.28.06.34.19;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	99.06.27.20.41.41;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	99.06.26.09.35.31;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	99.06.19.03.01.05;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	99.06.17.15.36.12;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	99.06.11.23.21.56;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	99.05.28.12.05.04;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	99.05.28.11.47.18;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	99.05.28.11.41.55;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	99.05.28.07.29.00;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	99.05.28.07.15.47;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	99.05.28.07.11.50;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	99.05.28.07.08.59;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	99.05.28.07.01.29;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	99.05.28.06.33.25;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	99.05.28.06.18.14;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	99.05.26.03.27.35;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	99.05.25.06.22.24;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	99.05.22.16.11.59;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	99.05.22.16.09.33;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	99.05.19.21.02.25;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	99.05.19.20.52.41;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	99.05.18.18.23.59;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	99.05.18.18.18.57;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	99.05.06.02.16.40;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	99.05.03.08.00.20;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	99.04.26.07.54.46;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	99.04.23.23.43.42;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	99.04.23.21.51.45;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	99.04.23.21.50.09;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	99.04.23.21.43.37;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	99.04.22.13.04.07;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	99.04.18.06.24.54;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	99.04.18.04.32.27;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	99.04.18.04.01.00;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	99.04.17.22.54.31;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	99.04.17.09.36.40;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	99.04.17.09.27.13;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	99.04.17.07.42.54;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	99.04.17.01.56.11;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	99.04.16.16.36.32;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	99.04.16.16.34.14;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	99.04.16.16.19.41;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	99.04.16.01.40.11;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	99.04.16.01.27.33;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	99.04.14.20.23.21;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.04.08.02.27.41;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.04.08.02.03.38;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.04.08.01.49.34;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.04.08.01.41.11;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.04.01.06.37.57;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.03.29.22.07.01;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.03.29.18.34.28;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.03.29.05.21.49;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.03.29.00.07.46;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	99.03.28.09.42.57;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	99.03.28.09.32.28;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	99.03.27.03.42.44;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	99.03.27.03.37.30;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.03.15.14.57.08;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.03.13.17.43.57;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	99.01.12.21.14.31;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	99.01.12.20.51.29;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	99.01.12.20.24.30;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	99.01.05.17.39.57;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	99.01.03.16.54.25;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	98.12.29.20.36.28;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	98.12.16.20.42.41;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	98.12.15.22.17.24;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	98.12.13.21.32.27;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	98.12.13.03.05.35;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	98.12.12.01.20.57;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	98.12.08.23.23.08;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	98.12.08.23.12.10;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	98.12.05.21.44.06;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	98.12.05.09.50.20;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	98.12.01.16.02.55;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	98.11.29.22.26.23;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	98.11.28.07.49.35;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	98.11.22.10.36.38;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	98.11.22.08.14.42;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	98.11.19.09.06.02;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	98.11.15.09.29.36;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	98.11.14.07.15.53;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	98.11.10.19.20.50;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	98.10.27.22.10.41;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	98.10.25.18.52.52;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	98.10.25.18.38.47;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	98.10.24.22.03.03;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	98.10.22.05.27.00;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	98.10.21.00.36.37;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	98.10.19.06.15.16;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	98.10.19.06.09.16;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	98.10.17.08.03.15;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	98.10.14.17.38.01;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	98.10.13.23.07.43;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	98.10.11.00.36.22;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	98.10.11.00.35.37;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	98.10.11.00.31.11;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	98.10.09.20.15.18;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	98.10.09.19.04.04;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	98.10.09.18.44.31;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	98.10.09.17.59.48;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	98.10.09.17.56.45;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	98.10.09.01.35.03;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	98.10.09.00.46.01;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	98.10.09.00.35.44;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	98.10.06.22.03.07;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.10.05.09.10.27;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.10.05.06.17.41;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.10.05.04.13.35;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.10.02.23.39.35;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.09.23.23.27.24;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.09.20.07.46.18;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.08.30.03.33.38;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.08.20.21.05.35;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.08.17.20.05.02;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.08.13.05.24.11;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.08.12.08.20.20;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.08.10.21.32.54;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.08.10.19.41.24;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.08.10.05.32.16;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.08.10.00.08.25;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.08.07.20.20.01;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.08.06.04.24.53;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.08.05.08.46.16;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.08.05.08.14.35;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.08.05.06.59.14;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.08.05.06.31.16;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.08.02.15.26.28;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.02.14.30.36;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.01.13.03.28;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.07.31.21.06.11;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.07.31.20.51.20;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.07.31.20.37.44;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.07.30.15.39.38;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.07.30.15.36.58;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.38;	author mud;	state Exp;
branches;
next	;


desc
@@


1.484
log
@No ToIW for vuln_mental
@
text
@/****************************************************************************
 a  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: magic.c,v 1.483 2004/10/09 03:32:05 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "merc.h"
#include "magic.h"
#include "recycle.h"
#include "tables.h"
#include "gladiator.h"

/* command procedures needed */
DECLARE_DO_FUN(do_look    );
DECLARE_DO_FUN(do_order    );

/*
 * Local functions.
 */
bool cast_spell args((CHAR_DATA *ch, char *argument, bool fChant, bool fFocus));
void  say_spell args( ( CHAR_DATA *ch, int sn ) );
void write_spell( CHAR_DATA *ch, int sn );

/* imported functions */
bool    remove_obj      args( ( CHAR_DATA *ch, int iWear, bool fReplace ) );
void  wear_obj  args( ( CHAR_DATA *ch, OBJ_DATA *obj, bool fReplace ) );
void  set_fighting  args( ( CHAR_DATA *ch, CHAR_DATA *victim ) );
int	clan_lookup	args( (const char *name) );

/*
 * Process a damage over time spell
 */
void heal_dot( CHAR_DATA *victim, CHAR_DATA *ch, AFFECT_DATA *paf )
{
    int heal;

    heal = number_range( abs(paf->modifier), abs(paf->location) );
  
    if ( ch != NULL &&  ch->in_room != victim->in_room )
	heal /= 2;

    if ( victim->fighting != NULL )
	heal /= 2;

    victim->hit = UMIN(victim->hit+heal,victim->max_hit);

     paf->level--;
     if ( --paf->duration < 0 )
     {
        send_to_char(skill_table[paf->type].msg_off,victim);
        send_to_char("\n\r",victim);
        affect_remove(victim,paf,APPLY_BOTH);
     }

    return;
}

void dot( CHAR_DATA *ch, AFFECT_DATA *paf )
{
    int dam;
    CHAR_DATA *caster;
   
    if ( ch == NULL || paf == NULL )
	return;

    caster = NULL;

    if ( paf->location < 0 || paf->modifier < 0 )
    {
	heal_dot(ch,caster,paf);
	return;
    }

    dam = number_range(paf->modifier,paf->location);

    if ( paf->caster_id > 0 )
        caster = get_char_by_id( paf->caster_id );

    if ( caster == NULL )
    {
	caster = ch;
	dam /= 2;
    }
    else
    {
	/* if we know the caster, see if they're in the room with ch */

	/* Damage cut in half if caster isn't in same room */
	if( caster->in_room != ch->in_room )
	    dam /= 2;
    }

    /* The fields in AFFECT_DATA for DOT spells are different.
     * 
     * af.where = DAMAGE_OVER_TIME
     * af.duration = #DOT cycles ( 10 second cycles )
     * af.location = Minimum damage
     * af.modifier = Maximum damage
     * af.bitvector = damage type
     */


     damage(caster,ch,dam,TYPE_DOT,paf->bitvector,FALSE,FALSE);

     if ( ch == NULL )
	return;
 
     /** Handle wear-off **/ 

     paf->level--;
     if ( --paf->duration < 0 )
     {
	send_to_char(skill_table[paf->type].msg_off,ch);
	send_to_char("\n\r",ch);
	affect_remove(ch,paf,APPLY_BOTH);
     }
     return;
}

/*
 * Lookup a skill by name.
 */
int skill_lookup( const char *name )
{
    int sn;

    for ( sn = 0; sn < MAX_SKILL; sn++ )
    {
  if ( skill_table[sn].name == NULL )
      break;
  if ( LOWER(name[0]) == LOWER(skill_table[sn].name[0])
  &&   !str_prefix( name, skill_table[sn].name ) )
      return sn;
    }

    return -1;
}

int find_spell( CHAR_DATA *ch, const char *name )
{
    /* finds a spell the character can cast if possible */
    int sn, found = -1;

    if (IS_NPC(ch))
  return skill_lookup(name);

    for ( sn = 0; sn < MAX_SKILL; sn++ )
    {
  if (skill_table[sn].name == NULL)
      break;
  if (LOWER(name[0]) == LOWER(skill_table[sn].name[0])
  &&  !str_prefix(name,skill_table[sn].name))
  {
      if ( found == -1)
    found = sn;
      if (ch->level >= skill_level(ch,sn)
      &&  ch->pcdata->learned[sn] > 0)
        return sn;
  }
    }
    return found;
}



/*
 * Lookup a skill by slot number.
 * Used for object loading.
 */
int slot_lookup( int slot )
{
    extern bool fBootDb;
    int sn;

    if ( slot <= 0 )
  return -1;

    for ( sn = 0; sn < MAX_SKILL; sn++ )
    {
  if ( slot == skill_table[sn].slot )
      return sn;
    }

    if ( fBootDb )
    {
  bug( "Slot_lookup: bad slot %d.", slot );
  abort( );
    }

    return -1;
}



/*
 * Utter mystical words for an sn.
 */
void say_spell( CHAR_DATA *ch, int sn )
{
    char buf  [MAX_STRING_LENGTH];
    char buf2 [MAX_STRING_LENGTH];
    CHAR_DATA *rch;
    char *pName;
    int iSyl;
    int length;

    struct syl_type
    {
  char *  old;
  char *  new;
    };

    static const struct syl_type syl_table[] =
    {
  { " ",    " "   },
  { "ar",   "abra"    },
  { "au",   "kada"    },
  { "bless",  "fido"    },
  { "blind",  "nose"    },
  { "bur",  "mosa"    },
  { "cu",   "judi"    },
  { "de",   "oculo"   },
  { "en",   "unso"    },
  { "light",  "dies"    },
  { "lo",   "hi"    },
  { "mor",  "zak"   },
  { "move", "sido"    },
  { "ness", "lacri"   },
  { "ning", "illa"    },
  { "per",  "duda"    },
  { "ra",   "gru"   },
  { "fresh",  "ima"   },
  { "re",   "candus"  },
  { "son",  "sabru"   },
  { "tect", "infra"   },
  { "tri",  "cula"    },
  { "ven",  "nofo"    },
  { "wall",  "denca"    },
  { "a", "a" }, { "b", "b" }, { "c", "q" }, { "d", "e" },
  { "e", "z" }, { "f", "y" }, { "g", "o" }, { "h", "p" },
  { "i", "u" }, { "j", "y" }, { "k", "t" }, { "l", "r" },
  { "m", "w" }, { "n", "i" }, { "o", "a" }, { "p", "s" },
  { "q", "d" }, { "r", "f" }, { "s", "g" }, { "t", "h" },
  { "u", "j" }, { "v", "z" }, { "w", "x" }, { "x", "n" },
  { "y", "l" }, { "z", "k" },
  { "", "" }
    };

    buf[0]  = '\0';
    for ( pName = skill_table[sn].name; *pName != '\0'; pName += length )
    {
  for ( iSyl = 0; (length = strlen(syl_table[iSyl].old)) != 0; iSyl++ )
  {
      if ( !str_prefix( syl_table[iSyl].old, pName ) )
      {
    strcat( buf, syl_table[iSyl].new );
    break;
      }
  }

  if ( length == 0 )
      length = 1;
    }

    sprintf( buf2, "$n utters the words, '%s'.", buf );
    sprintf( buf,  "$n utters the words, '%s'.", skill_table[sn].name );

    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
    {
  if ( rch == ch )
		continue;

      if ( get_skill(rch,gsn_spellcraft) >= 65 &&
	   rch->position > POS_SLEEPING)
      {
	check_improve(rch,gsn_spellcraft,TRUE,10);
	act( buf, ch, NULL, rch, TO_VICT,FALSE);
      }
      else
      act( ch->class==rch->class ? buf : buf2, ch, NULL, rch, TO_VICT ,FALSE);
    }

    return;
}



/*
 * Compute a saving throw.
 * Negative apply's make saving throw better.
 */
bool saves_spell( int level, CHAR_DATA *victim, int dam_type )
{
    int save,saving_throw;
    OBJ_DATA *segment;

    if ( IS_NPC(victim) && victim->pIndexData->pShop != NULL )
    return TRUE;

    saving_throw = victim->saving_throw;

    if(dam_type == DAM_FIRE && ((segment = get_eq_char(victim, WEAR_HOLD)) != NULL && segment->pIndexData->vnum == VNUM_FIRE_SEGMENT))
    {
    return TRUE;
    }

    if(dam_type == DAM_DROWNING && ((segment = get_eq_char(victim, WEAR_HOLD)) != NULL && segment->pIndexData->vnum == VNUM_WATER_SEGMENT))
    {
    return TRUE;
    }

    if (saving_throw < -8 && !is_affected(victim,gsn_magic_resistance) )
    {
    saving_throw = ( saving_throw + 8 ) / 2 - 8;
    }

    if (saving_throw < -12 && !is_affected(victim,gsn_magic_resistance) )
    {
    saving_throw = ( saving_throw + 12 ) / 2 - 12;
    }

    if (saving_throw < -16 && !is_affected(victim,gsn_magic_resistance))
    {
    saving_throw = ( saving_throw + 16 ) / 2 - 16;
    }
    
    /* curve only once for people with res magic but curve is /3 */
    if (saving_throw < -24 && is_affected(victim,gsn_magic_resistance))
    {
    saving_throw = ( saving_throw + 24 ) / 3 - 24;
    }

    if( victim->race == race_lookup("elf") ) saving_throw -= 5;

    save = 80 + ( level / 6 ) +  saving_throw  ;

    save -= ( get_curr_stat(victim,STAT_INT)  +
	      get_curr_stat(victim,STAT_WIS) ) ;

    save -= ( ( victim->level - level ) * 5 ) ;

    if (IS_AFFECTED(victim,AFF_CURSE))
	 save += 5;


    if (victim->position < POS_FIGHTING)
	save += 5;

  
    if( number_percent() < get_skill(victim,gsn_weave_resistance) )
    {
        save -= ( get_skill(victim,gsn_weave_resistance) / 5 );
        check_improve(victim,gsn_weave_resistance,TRUE,1);
    }
    
    if (IS_AFFECTED(victim,AFF_BERSERK))
    {
	save -=( get_skill(victim, gsn_berserk) / 15) ;
    }

    switch(check_immune(victim,dam_type))
    {
  case IS_IMMUNE:   return TRUE;
  case IS_RESISTANT:  save -= 25;  break;
  case IS_VULNERABLE: save += 25;  break;
    }

    if ( get_skill(victim,gsn_spellcraft) >= 90 ) 
	save -= 10;

    if (!IS_NPC(victim) && class_table[victim->pcdata->old_class].fMana  == 1)
        save -= 10;
    if (!IS_NPC(victim) && class_table[victim->pcdata->old_class].fMana == 2 )
        save -= 14;

    if ( !IS_NPC(victim) && group_has_cavalier( victim ) &&
        number_percent() <  (victim->pcdata->sac / 8 )  )
    {
	save -=15;
    }


    save = URANGE( 5, save, 95 );
    return number_percent( ) > save;
}

/* RT save for dispels */

bool saves_dispel( int dis_level, int spell_level, int duration)
{
    int save;
    
    if (duration == -1)
      spell_level += 5;  
      /* very hard to dispel permanent effects */

    save = 50 + (spell_level - dis_level) * 5;
    save = URANGE( 5, save, 95 );
    return number_percent( ) < save;
}

/* co-routine for dispel magic and cancellation */

bool check_dispel( int dis_level, CHAR_DATA *victim, int sn)
{
    AFFECT_DATA *af;

    if (is_affected(victim, sn))
    {
        for ( af = victim->affected; af != NULL; af = af->next )
        {
            if ( af->type == sn )
            {
                if (!saves_dispel(dis_level,af->level,af->duration))
                {
                  affect_strip(victim,sn);
              	  if ( skill_table[sn].msg_off )
              	  {
		    send_to_char( skill_table[sn].msg_off, victim );
		    send_to_char( "\n\r", victim );
              	  }
        	  return TRUE;
    	    	}
    	    	else
    		  af->level--;
            }
        }
    }
    return FALSE;
}

bool dragon_breath( CHAR_DATA *ch, int sn )
{
   if ( ch->race != race_lookup("dragon") )
	return FALSE;

   if (
	 sn == skill_lookup("acid breath") ||
	 sn == skill_lookup("gas breath") ||
	 sn == skill_lookup("frost breath") ||
	 sn == skill_lookup("lightning breath") ||
	 sn == skill_lookup("fire breath") ) 
	return TRUE;

   return FALSE;
}

/* for finding mana costs -- temporary version */
int mana_cost (CHAR_DATA *ch, int min_mana, int level, int sn)
{
    int mana;

    if (ch->level + 2 == level)
  	return 1000;
    else
	mana = (100 / ( 2 + ch->level - level ) );

    if ( HAS_KIT(ch,"nethermancer") &&
	 ( sn == skill_lookup("gate") ||
	   sn == skill_lookup("summon") ||
	   sn == skill_lookup("portal") ||
	   sn == skill_lookup("nexus") ) )
	return ( min_mana / 2 );

    if ( HAS_KIT(ch, "enchanter") &&
       ( sn == skill_lookup("enchant weapon") ||
	 sn == skill_lookup("enchant armor") ) )
          return (min_mana * 8 /10 );


    if ( dragon_breath( ch, sn ) )
	return ( min_mana / 2 );
   
    return UMAX(min_mana,mana);
}


int compute_casting_level( CHAR_DATA *ch, int sn )
{
   int level;
   OBJ_DATA *segment = get_eq_char(ch, WEAR_HOLD) ;
   if ( IS_NPC(ch) )
	return ch->level;

   level = ch->level;

    if ( class_table[ch->pcdata->old_class].fMana == 2 )
    {
      level += 2;
    }

    if ( class_table[ch->pcdata->old_class].fMana == 1 )
    {
        level += 1;
    }
    switch( class_table[ch->class].fMana )
    {
    case 0: level = ( 8 * level / 10 ); break;  /* 60% casting level */
    case 1: level = ( 9 * level / 10 ); break; /* 90% casting level */
    case 2: level = ch->level;break;
    }
    if ( ch->class == class_lookup("druid") )
    {
       level += ( get_curr_stat(ch,STAT_INT) == 25 );
       level += ( get_curr_stat(ch,STAT_WIS) == 25 );
       level += ( ch->level >= 25 );
       level += ( ch->level >= 50 );
       level += ( ch->mana / 400 );
    }

    if ( is_affected(ch,gsn_imbue) )
    {
	if ( level <  ch->level )
		level += number_range(2,3);
	else
		level++;
    }

    if ( ch->race == race_lookup("elf") )
	level++;

    if ( ch->race == race_lookup("faerie"))
	level += 1;

    if ( ch->class == class_lookup("elementalist") )
	level += ( ( ch->max_mana > 500 ) + ( ch->max_mana >= 1000 ) );

    if ( get_skill(ch,gsn_spellcraft) >= 100 )
	level++;

    if ( ch->race == race_lookup("smurf"))
       if (smurf_group_count(ch) > 1)
          level += smurf_group_count(ch);

    /* Casting Level Curve */
    if ( level > (ch->level + 2 ) )
       level = ( level - (ch->level +2 ) ) / 2 + (ch->level +2 );

    if ( level > (ch->level +5 ) )
	level = ( level - (ch->level +5 ) ) /2 + (ch->level +5 );

    if ( is_affected(ch,gsn_enervation) )
	level -= number_range( 2, 4 );

   /*below starts the check to see if they're a necromancer and
     are casting necromantic spells - Boogums */
    if ( ch->kit == kit_lookup("necromancer") &&
	 (  
	     ( sn == skill_lookup( "animate dead" ) )  ||
	     ( sn == skill_lookup( "draw life" ) )     ||
	     ( sn == skill_lookup( "enervation" ) )    ||
	     ( sn == skill_lookup( "summon dead" ) )   ||
	     ( sn == skill_lookup( "turn undead" ) )   ||
	     ( sn == skill_lookup( "wound transfer" ) )||
	     ( sn == skill_lookup( "cryogenesis" ) )   ||
	     ( sn == skill_lookup( "make bag" ) )   ||
	     ( sn == skill_lookup( "withstand death" ) ) 
	 ) 
       )
      {
        if ( ch->alignment >= 500)
          level -= 20;
	if ( 249 < ch->alignment && ch->alignment < 500 )
	  level -= 15;
	if ( -1 < ch->alignment  && ch->alignment < 250 )
	  level -= 10;
        if ( -251 < ch->alignment && ch->alignment < 0 )
	  level -= 5;
	if ( -751 < ch->alignment  && ch->alignment < -500 )
          level += 1;
	if ( -950 < ch->alignment && ch->alignment < -750)
          level += 2;
	if ( -1001 < ch->alignment  && ch->alignment < -950 )
          level += 3;
      } /*end the necromancy check */
     
    /*Starte check for holding various segments of the elements */
    if( segment != NULL && segment->pIndexData->vnum == VNUM_FIRE_SEGMENT &&
	(
		sn == skill_lookup("incinerate") ||
		sn == skill_lookup("fireball") ||
		sn == skill_lookup("flamesword") ||
		sn == skill_lookup("flame shield") ||
		sn == skill_lookup("burning hands") ||
		sn == skill_lookup("fireproof") ||
		sn == skill_lookup("heat metal") ||
		sn == skill_lookup("flameseek")||
		sn == skill_lookup("immolation")||
		sn == skill_lookup("flamestrike") 
	)) 
        {  
           level += 3;
     /* Ok, 50 percent chance of segment going byebye- ND */
           if (number_percent()<50)
           {
              send_to_char("The last of its energy expended, your fire segment flares and vanishes.\n\r",ch);
              extract_obj(segment);
           }  
         } 
   return level;

}     

/*
 * The kludgy global is for spells who want more stuff from command line.
 */
char *target_name;

void do_cast( CHAR_DATA *ch, char *argument )
{
   if ( is_affected(ch, gsn_cone_of_silence ) )
   {
    send_to_char("You are wrapped in a cone of silence.\n\r",ch);
    return;
    }

    if ( HAS_KIT(ch,"bishop") )
    {
	send_to_char("You must chant for your powers.\n\r",ch);
	return;
    }
    /*added for wraith form check 25NOV00 - Boogums*/
    if( is_affected(ch,skill_lookup("wraithform")) )
    {
      send_to_char("You cannot cast while affected by wraith form.\n\r",ch);
      return;
    } 
   
     cast_spell( ch, argument, FALSE, FALSE );
    return;
}

void do_chant( CHAR_DATA *ch, char *argument )
{
   if ( is_affected(ch, gsn_cone_of_silence ) )
   {
    send_to_char("You are wrapped in a cone of silence.\n\r",ch);
    return;
    }

    if ( number_percent() < get_skill(ch,gsn_holy_chant) )
    {
 	if ( cast_spell( ch, argument, TRUE, FALSE ) )
    		check_improve(ch,gsn_holy_chant,TRUE,4);
    }
    else
    {
	send_to_char("Your chant failed.\n\r",ch);
	check_improve(ch,gsn_holy_chant,FALSE,8);
	return;
    }
}

void do_focus( CHAR_DATA *ch, char *argument )
{

    if ( !HAS_KIT(ch,"wu jen") )
    {
      send_to_char("You are not Wu Jen.\n\r",ch);
      return;
    }

    if ( number_percent() < get_skill(ch,gsn_focus) )
    {
 	if ( cast_spell( ch, argument, FALSE, TRUE ) )
    		check_improve(ch,gsn_focus,TRUE,4);
    }
    else
    {
	send_to_char("You failed to focus.\n\r",ch);
	check_improve(ch,gsn_focus,FALSE,8);
	WAIT_STATE( ch, 24 );
	return;
    }
}

void do_quicken (CHAR_DATA *ch, char *argument)
{

   char arg1[MAX_INPUT_LENGTH];
   char arg2[MAX_INPUT_LENGTH];
   char buf[MAX_STRING_LENGTH];
   CHAR_DATA *victim;
   void *vo;
   int sn;
   int level;

   if(!IS_SET(ch->mhs,MHS_HIGHLANDER))
   {
      send_to_char("Only Highlanders can Quicken.\n\r",ch);
      return;
   }

   if(ch->fighting != NULL)
   {
      send_to_char("You can not invoke the Quickening during combat.\n\r",ch);
      return;
   }

   argument = one_argument(argument, arg1);
   argument = one_argument(argument, arg2);

   if ( arg1[0] == '\0' )
   {
      send_to_char( "What do wish to invoke your Quickening into?\n\r", ch );
      return;
   }
   if((sn = skill_lookup(arg1)) == -1)
   {
      send_to_char("No such skill or spell exists.\n\r",ch);
      return;
   }

   if (!strcmp(arg2,"self") || arg2[0] == '\0')
      victim = ch;
   else
   {
      if ( ( victim = get_char_world( ch, arg2 ) ) == NULL )
      {
         send_to_char( "They aren't here.\n\r", ch );
         return;
      }
   }

   sprintf(buf,"%s is quickening %s at %s",ch->name,skill_table[sn].name,victim->name);
   log_string(buf);

   if (sn != skill_lookup("haste") &&
       sn != skill_lookup("giant strength") &&
       sn != skill_lookup("farsee"))
   {
      send_to_char("That is not a valid Quickening power.\n\r",ch);
      return;
   }

   if (victim != ch && sn != skill_lookup("farsee"))  
   {
      send_to_char("The Quickening powers are for your use only.\n\r",ch);
      return;
   }

   level = 60;

   vo = (void *) ch;
   if (sn == skill_lookup("farsee"))
      vo = (void *) victim;

   (*skill_table[sn].spell_fun) (sn, level, ch, vo, TARGET_CHAR );
   return;
}


bool cast_spell( CHAR_DATA *ch, char *argument, bool fChant, bool fFocus )
{
    char arg1[MAX_INPUT_LENGTH];
    char arg2[MAX_INPUT_LENGTH];
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    EXIT_DATA *exit;
    void *vo;
    int mana;
    int spell_skill;
    int sn;
    int target;
    int level;
    bool iWyrm = FALSE;
    bool fConcentrate = FALSE;
    char buf  [MAX_STRING_LENGTH];

    /*
     * Switched NPC's can cast spells, but others can't.
     */
    if ( IS_NPC(ch) && ch->desc == NULL)
  return FALSE;

    target_name = one_argument( argument, arg1 );
    one_argument( target_name, arg2 );

    if ( arg1[0] == '\0' )
    {
  send_to_char( "Cast which what where?\n\r", ch );
  return FALSE;
    }

    if ( ( sn = find_spell( ch,arg1 ) ) < 0
    || ( !IS_NPC(ch) && (ch->level < skill_level(ch,sn)
    ||       ch->pcdata->learned[sn] == 0)))
    {
  send_to_char( "You don't know any spells of that name.\n\r", ch );
  return FALSE;
    }
    if (skill_table[sn].spell_fun == spell_null)
    {
      send_to_char( "That's not a spell!\n\r", ch );
      return FALSE;
    }
    if ( sn == skill_lookup("scion storm") )
    {
      send_to_char("You cannot cast that spell.\n\r",ch);
      return FALSE;
    }
    if ( ch->position < skill_table[sn].minimum_position && !fChant )
    {
  send_to_char( "You can't concentrate enough.\n\r", ch );
  return FALSE;
    }

    if( !IS_NPC(ch) && IS_SET(ch->affected_by, AFF_HIDE))
        REMOVE_BIT( ch->affected_by, AFF_HIDE );

    mana = mana_cost(ch,skill_table[sn].min_mana,
		     skill_level(ch,sn),sn);

/**
    if (ch->level + 2 == skill_table[sn].skill_level[ch->class])
  mana = 50;
    else
      mana = UMAX(
      skill_table[sn].min_mana,
      100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->class] ) );
**/

    if ( fChant )
    {
	int reduction;

	reduction = 100;
	reduction -= ( get_skill(ch,gsn_holy_chant) / 5 );
	mana = reduction * mana / 100;
    }

    /*
     * Locate targets.
     */
    victim  = NULL;
    obj   = NULL;
    vo    = NULL;
    exit = NULL;
    target  = TARGET_NONE;
      
    switch ( skill_table[sn].target )
    {
    default:
  bug( "Do_cast: bad target for sn %d.", sn );
  return FALSE;

    case TAR_IGNORE:
  break;
    case TAR_CHAR_OFFENSIVE:
  if ( arg2[0] == '\0' )
  {
      if ( ( victim = ch->fighting ) == NULL )
      {
    send_to_char( "Cast the spell on whom?\n\r", ch );
    return FALSE;
      }
  }
  else
  {
      if ( ( victim = get_char_room( ch, target_name ) ) == NULL )
      {
    send_to_char( "They aren't here.\n\r", ch );
    return FALSE;
      }
  }
        if ( ch == victim && IS_SET(ch->mhs,MHS_GLADIATOR))
        {
            send_to_char( "Suicide is not in the Gladiator Code. Kill someone besides yourself!\n\r", ch );
            return FALSE;
        }
  if (ch == victim && IS_SET(ch->in_room->room_flags,ROOM_NOCOMBAT))
  {
     send_to_char("No Combat in this room.\n\r",ch);
     return FALSE;
  }

  if(victim->fighting != ch && victim->fighting != NULL && 
     IS_SET(ch->mhs,MHS_HIGHLANDER) 
     && IS_SET(victim->mhs,MHS_HIGHLANDER))
  {
     send_to_char("Honorable Combat is one on one.\n\r",ch);
     return FALSE;
  }
  
  /*Wraithform check-Boogums*/
  if (is_affected(victim,skill_lookup("wraithform")))
  {
    send_to_char("They are made of mist.\r\n",ch);
    return FALSE;
  }

  if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
  {
    send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
    return FALSE;
  }

  if( victim->fighting != NULL &&
  !is_same_group(ch,victim->fighting)  && ch != victim 
  && IS_NPC(victim) )
    {
        send_to_char("Kill stealing is not permitted.\n\r",ch);
        return FALSE;
    }

  if ( !IS_NPC(ch) )
  {

            if (is_safe(ch,victim) && victim != ch)
      {
    send_to_char("Not on that target.\n\r",ch);
    return FALSE; 
      }
  check_killer(ch,victim);
  }

        if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
  {
      send_to_char( "You can't do that on your own follower.\n\r",
    ch );
      return FALSE;
  }
  /* Gladiator Spectator Channel */
  if (IS_SET(ch->mhs,MHS_GLADIATOR))
  {
     if (number_percent() < 50)
     {
        sprintf(buf,"%s casts %s at %s.\n\r",ch->name,skill_table[sn].name,victim->name);
        gladiator_talk(buf);
     }
  }

  vo = (void *) victim;
  target = TARGET_CHAR;
  if(HAS_KIT(ch,"wyrmslayer") && victim->race == race_lookup("dragon"))
	iWyrm = TRUE;
  break;

    case TAR_CHAR_DEFENSIVE:
  if ( arg2[0] == '\0' )
  {
      victim = ch;
  }
  else
  {
      /*another wraithform check -Boogums
      if ( is_affected(victim,skill_lookup("wraithform")) )
      {
        send_to_char("Your spell has no affect on them.\r\n",ch);
	return FALSE;
      }
*/
      if ( ( victim = get_char_room( ch, target_name ) ) == NULL )
      {
    send_to_char( "They aren't here.\n\r", ch );
    return FALSE;
      }
  }

  vo = (void *) victim;
  target = TARGET_CHAR;
  break;

    case TAR_CHAR_SELF:
  if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
  {
      send_to_char( "You cannot cast this spell on another.\n\r", ch );
      return FALSE;
  }

  vo = (void *) ch;
  target = TARGET_CHAR;
  break;

    case TAR_OBJ_INV:
  if ( arg2[0] == '\0' )
  {
      send_to_char( "What should the spell be cast upon?\n\r", ch );
      return FALSE;
  }

  if ( ( obj = get_obj_carry( ch, arg2 ) ) == NULL )
  {
      send_to_char( "You are not carrying that.\n\r", ch );
      return FALSE;
  }

  vo = (void *) obj;
  target = TARGET_OBJ;
  break;

    case TAR_OBJ_CHAR_OFF:
  if (arg2[0] == '\0')
  {
      if ((victim = ch->fighting) == NULL)
      {
    send_to_char("Cast the spell on whom or what?\n\r",ch);
    return FALSE;
      }
  
      target = TARGET_CHAR;
  }
  else if ((victim = get_char_room(ch,target_name)) != NULL)
  {
      target = TARGET_CHAR;
  }

  if (target == TARGET_CHAR) /* check the sanity of the attack */
  {
      if(is_safe_spell(ch,victim,FALSE, sn) && victim != ch)
      {
    send_to_char("Not on that target.\n\r",ch);
    return FALSE;
      }

            if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
            {
                send_to_char( "You can't do that on your own follower.\n\r",
                    ch );
                return FALSE;
            }

      if (!IS_NPC(ch))
    check_killer(ch,victim);

      vo = (void *) victim;
  }
  else if ((obj = get_obj_here(ch,target_name)) != NULL)
  {
      vo = (void *) obj;
      target = TARGET_OBJ;
  }
  else
  {
      send_to_char("You don't see that here.\n\r",ch);
      return FALSE;
  }
  break; 

	case TAR_OBJ_CHAR_DEF:
        if (arg2[0] == '\0')
        {
            vo = (void *) ch;
            target = TARGET_CHAR;                                                 
        }
        else if ((victim = get_char_room(ch,target_name)) != NULL)
        {
            vo = (void *) victim;
            target = TARGET_CHAR;
  }
  else if ((obj = get_obj_carry(ch,target_name)) != NULL)
  {
      vo = (void *) obj;
      target = TARGET_OBJ;
  }
  else
  {
      send_to_char("You don't see that here.\n\r",ch);
      return FALSE;
  }
  break;
    }
   
   /* Dragon breath */
    if ( dragon_breath( ch, sn ) )
    {
       int moves;

       moves = mana_cost(ch,skill_table[sn].min_mana,
			    skill_level(ch,sn),sn) / 2;

       if ( moves > ch->move )
       {
	    send_to_char("You are too exhausted.\n\r",ch);
	    return FALSE;
	}

	ch->move -= moves;
    }
    
    if ( !IS_NPC(ch) && ch->mana < mana )
    {

       if ( number_percent() < get_skill(ch,gsn_nethermancy) )
       {
	   if ( ch->hit < ( mana * 2 ) )
	   {
		send_to_char("Your nethermancy has failed you.\n\r",ch);
			return FALSE;
	   }
	   check_improve(ch,gsn_nethermancy,TRUE,5);
	   ch->hit -= ( mana * 2 );
	   ch->mana += mana;
	   send_to_char("Your soul screams as you transfer your life force.\n\r",ch);
	}
	else
       if ( number_percent() < get_skill(ch,gsn_communion) )
       {
 	   if ( ch->pcdata->sac < mana * 2)
	   {
	      send_to_char("Your communion fails.\n\r",ch); 
	      return FALSE;
	   }

	   check_improve(ch,gsn_communion,TRUE,3);
	   ch->pcdata->sac -= mana * 2;
	   ch->mana += mana;
	   send_to_char("Your deity grants your communion.\n\r",ch);
       }
       else
       {
       check_improve(ch,gsn_nethermancy,FALSE,12);
       check_improve(ch,gsn_communion,FALSE,6);
       send_to_char("You don't have enough mana.\n\r",ch);
       return FALSE;
       }

    }
      
    if ( str_cmp( skill_table[sn].name, "ventriloquate" ) && 
	 str_cmp( skill_table[sn].name, "mirror image" ) )
  say_spell( ch, sn );
   
   /* Immortals do not lag with casting spells */
if (!IS_IMMORTAL(ch))
{
    int 	wait_beats;

    wait_beats = skill_table[sn].beats;

    if ( ch->race == race_lookup("faerie") && IS_AFFECTED(ch,AFF_SLOW) )
	wait_beats *= 2;

    if ( skill_table[sn].target != TAR_CHAR_OFFENSIVE && skill_table[sn].beats >= 24 
	&& ( number_percent() < get_skill(ch,gsn_spellcraft) ) )
    {
	check_improve(ch,gsn_spellcraft,TRUE,10);
	wait_beats /= 2;
    }
    else
	check_improve(ch,gsn_spellcraft,FALSE,15);

    if ( is_affected(ch,gsn_arcantic_alacrity) )
	wait_beats /= 2;

    if ( is_affected(ch,gsn_arcantic_lethargy) )
	wait_beats *= 2;

//COREY WAIT_STATE IS HERE
    if ( !IS_NPC(ch) )
    {
        switch( class_table[ch->class].fMana )
        {
        case 0:
                wait_beats *= 1;
                break;
        case 1:
                wait_beats *= .75;
                break;
        case 2:
                wait_beats *= .90;
                break;
        default:
                wait_beats *= 1;
                break;
        }
    }

    WAIT_STATE(ch,wait_beats);
}

    spell_skill = get_skill(ch,sn);
    if ( is_affected(ch,skill_lookup("shield bash")) )
	spell_skill = spell_skill * 3 / 4;

    if ( is_mounted(ch) )
	spell_skill -= ( spell_skill / 10 );

    if ( number_percent( ) > spell_skill ) 
    {

       /*  This code killed by Nightdagger
       if (ch->clan == clan_lookup("warlock") && !IS_SET(ch->pcdata->clan_flags, CLAN_NO_SKILL_1))
       {
	  if (number_percent( ) < 50)
	     fConcentrate = TRUE;
	  else
	     send_to_char ("You concentrate a little harder and succeed.\n\r",ch);
       }
       else
	  fConcentrate = TRUE;
       End code nerf */

          fConcentrate = TRUE;
    }

    if (fConcentrate)
    {
       send_to_char( "You lost your concentration.\n\r", ch );
       check_improve(ch,sn,FALSE,1);
       if ( number_percent() < get_skill(ch,gsn_spellcraft) )
       {
          ch->mana -= ( mana / 4 );
          if ( spell_skill > 1 )
             check_improve(ch,gsn_spellcraft,TRUE,6);
       }
       else
       {
          if ( spell_skill > 1 )
             check_improve(ch,gsn_spellcraft,FALSE,8);
          ch->mana -= mana / 2;
       }
    }
    else
    {
       ch->mana -= mana;

       if( target == TARGET_CHAR && victim != NULL && victim != ch 
          && is_affected(victim, skill_lookup("orb of turning")) )
       {
          send_to_char("Your spell encounters an orb of turning.\n\r",ch);
          blow_orb(victim,skill_lookup("orb of turning"));
          return TRUE;
       }

       level = compute_casting_level( ch, sn );
       if( iWyrm ) level += 2;
       if( fFocus )
       {
          int dam;
          dam = ((get_skill(ch, gsn_focus)+5) /20) - (4 - ch->level/10);
          level += dam;

          /* Curve it */
          if ( level > 53 )
             level = ( level - 53 ) / 2 + 53;

          if ( level > 56 )
             level = ( level - 56 ) / 2 + 56;

          dam += mana * dam;
          dam = UMAX(dam,0);
          damage(ch,ch,dam,0,DAM_MENTAL, FALSE,FALSE);
       }
     /* Dwarf magical resistance */
     if ( target == TARGET_CHAR 
          && victim != NULL 
          && (!IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("mage")) )
          && victim != ch 
          && victim->race == race_lookup("dwarf") )
     { 
         int dwarf_magres;

         dwarf_magres = victim->level / 5;

         if ( number_percent() < dwarf_magres )
         {
             send_to_char("You failed.\n\r",ch);
             return TRUE;
         }
     }

     if ( target == TARGET_CHAR && victim != NULL &&
	  victim != ch && victim->race == race_lookup("dragon") )
     { /* Dragon magical resistance */
	 int magres;

	 magres = victim->level / 4;

	 if ( HAS_KIT(ch,"wyrmslayer") )
	     magres /= 2;

        /* Lets slash Dragon's Res in half and see what happens */
         // magres * 3 /4;

	 if ( number_percent() < magres )
	 {
	     send_to_char("You failed.\n\r",ch);
	     return TRUE;
	 }
     }

    if( target == TARGET_CHAR && victim != NULL && victim != ch &&
	number_percent() < get_skill(victim,gsn_weave_resistance)/5 )
    {
	send_to_char("You failed.\n\r",ch);
	return TRUE;
    }

     (*skill_table[sn].spell_fun) (sn, level, ch, vo, target );
     check_improve(ch,sn,TRUE,1);
    }

    if ((skill_table[sn].target == TAR_CHAR_OFFENSIVE
    ||   (skill_table[sn].target == TAR_OBJ_CHAR_OFF && target == TARGET_CHAR))
    &&   victim != ch
    &&   victim->master != ch)
    {
  CHAR_DATA *vch;
  CHAR_DATA *vch_next;

  for ( vch = ch->in_room->people; vch; vch = vch_next )
  {
      vch_next = vch->next_in_room;
      if ( victim == vch && victim->fighting == NULL )
      { check_killer(victim,ch);
    multi_hit( victim, ch, TYPE_UNDEFINED );
    break;
      }
  }
    }

    return TRUE;
}



/*
 * Cast spells at targets using a magical object.
 */
void obj_cast_spell( int sn, int level, CHAR_DATA *ch, CHAR_DATA *victim, OBJ_DATA *obj )
{
    void *vo;
    int target = TARGET_NONE;

    if ( sn <= 0 )
  return;

    if ( sn >= MAX_SKILL || skill_table[sn].spell_fun == 0 )
    {
  bug( "Obj_cast_spell: bad sn %d.", sn );
  return;
    }

    switch ( skill_table[sn].target )
    {
    default:
  bug( "Obj_cast_spell: bad target for sn %d.", sn );
  return;

    case TAR_IGNORE:
  vo = NULL;
  break;

    case TAR_CHAR_OFFENSIVE:
  if ( victim == NULL )
      victim = ch->fighting;
  if ( victim == NULL )
    victim = ch;
  if (is_safe(ch,victim) && ch != victim)
  {
      send_to_char("Something isn't right...\n\r",ch);
      return;
  }
  if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
  {
    send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
    return;
  }

        check_killer(ch,victim);
  vo = (void *) victim;
  target = TARGET_CHAR;
  break;

    case TAR_CHAR_DEFENSIVE:
    case TAR_CHAR_SELF:
  if ( victim == NULL )
      victim = ch;
  vo = (void *) victim;
  target = TARGET_CHAR;
  break;

    case TAR_OBJ_INV:
  if ( obj == NULL )
  {
      send_to_char( "You can't do that.\n\r", ch );
      return;
  }
  vo = (void *) obj;
  target = TARGET_OBJ;
  break;

    case TAR_OBJ_CHAR_OFF:
        if ( victim == NULL && obj == NULL)
	{
      if (ch->fighting != NULL)
    victim = ch->fighting;
      else
      {
    send_to_char("You can't do that.\n\r",ch);
    return;
      }
	}

      if (victim != NULL)
      {
    if (is_safe_spell(ch,victim,FALSE, sn) && ch != victim)
    {
        send_to_char("Somehting isn't right...\n\r",ch);
        return;
    }

    if (is_clan(ch) && !IS_NPC(victim) && ch->pcdata->start_time > 0)
    {
      send_to_char("Easy there sparky.  You just got here.  Read some notes and such.\n\r",ch);
      return;
    }

    vo = (void *) victim;
    target = TARGET_CHAR;
      }
      else
      {
        vo = (void *) obj;
        target = TARGET_OBJ;
      }
        break;


    case TAR_OBJ_CHAR_DEF:
  if (victim == NULL && obj == NULL)
  {
      vo = (void *) ch;
      target = TARGET_CHAR;
  }
  else if (victim != NULL)
  {
      vo = (void *) victim;
      target = TARGET_CHAR;
  }
  else
  {
      vo = (void *) obj;
      target = TARGET_OBJ;
  }
  
  break;
    }

    target_name = "";

    if( target == TARGET_CHAR  && victim != NULL
	&& is_affected(victim, skill_lookup("orb of turning")) )
    {
        send_to_char("Your spell encounters an orb of turning.\n\r",ch);
        blow_orb(victim,skill_lookup("orb of turning"));
        return;
    }

    (*skill_table[sn].spell_fun) ( sn, level, ch, vo,target);

    

    if ( skill_table[sn].target == TAR_CHAR_OFFENSIVE
    &&   victim != ch
    &&   victim->master != ch )
    {
  CHAR_DATA *vch;
  CHAR_DATA *vch_next;

  for ( vch = ch->in_room->people; vch; vch = vch_next )
  {
      vch_next = vch->next_in_room;
      if ( victim == vch && victim->fighting == NULL )
      {
    multi_hit( victim, ch, TYPE_UNDEFINED );
    break;
      }
  }
    }

    return;
}



/*
 * Spell functions.
 */
void spell_acid_blast( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    dam = dice( level, 12 );
    if (ch->class == class_lookup("mage"))
    {
      dam = dice( level, 14);
    }
    if (ch->class == class_lookup("elementalist"))
    {
      dam = dice( level, 10);
    }

    if ( saves_spell( level, victim, DAM_ACID ) )
  dam /= 2;
    damage( ch, victim, dam, sn,DAM_ACID,TRUE,TRUE);
    return;
}


bool reup_affect(CHAR_DATA *ch, int sn, int duration, int level)
{
  AFFECT_DATA *paf;
  AFFECT_DATA *paf_next;
  bool up=FALSE;

 for ( paf = ch->affected; paf != NULL; paf = paf_next )
  {
      paf_next  = paf->next;

      if ( paf->type == sn && paf->duration > 0)
      {
	    paf->duration = (paf->duration + duration)/2;
	    paf->level = (paf->level + level)/2;
	    up = TRUE;
      }
   }
   return up;
}

void spell_armor( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
	send_to_char( "You feel someone protecting you.\n\r", victim );
	if (victim != ch)
	{
	  act("$N is protected by your magic.",ch,NULL,victim,TO_CHAR,FALSE);
	}
	reup_affect(victim,sn,24+level/4,level);
	return;
    }
    af.where   = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = 24 + level / 4;
    af.modifier  = -20;
    af.location  = APPLY_AC;
    af.bitvector = 0;
    affect_to_char( victim, &af );
    send_to_char( "You feel someone protecting you.\n\r", victim );
    if ( ch != victim )
  act("$N is protected by your magic.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}



void spell_bless( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    AFFECT_DATA af;

    /* deal with the object case first */
    if (target == TARGET_OBJ)
    {
  obj = (OBJ_DATA *) vo;
  if (IS_OBJ_STAT(obj,ITEM_BLESS))
  {
      act("$p is already blessed.",ch,obj,NULL,TO_CHAR,FALSE);
      return;
  }

  if (IS_OBJ_STAT(obj,ITEM_EVIL))
  {
      AFFECT_DATA *paf;

      paf = affect_find(obj->affected,gsn_curse);
      if (!saves_dispel(level,paf != NULL ? paf->level : obj->level,0))
      {
    if (paf != NULL)
        affect_remove_obj(obj,paf);
    act("$p glows a pale blue.",ch,obj,NULL,TO_ALL,FALSE);
    REMOVE_BIT(obj->extra_flags,ITEM_EVIL);
    return;
      }
      else
      {
    act("The evil of $p is too powerful for you to overcome.",
        ch,obj,NULL,TO_CHAR,FALSE);
    return;
      }
  }
  
  af.where  = TO_OBJECT;
  af.type   = sn;
  af.level  = level;
  af.duration = 6 + level;
  af.location = APPLY_SAVES;
  af.modifier = -1;
  af.bitvector  = ITEM_BLESS;
  affect_to_obj(obj,&af);

  act("$p glows with a holy aura.",ch,obj,NULL,TO_ALL,FALSE);
  return;
    }

    /* character target */
    victim = (CHAR_DATA *) vo;


    if ( is_affected( victim, sn ) )
    {
    send_to_char( "You feel righteous.\n\r", victim );
    if ( ch != victim )
  act("You grant $N the favor of your god.",ch,NULL,victim,TO_CHAR,FALSE);
	reup_affect(victim,sn,6+level,level);
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = 6+level;
    af.location  = APPLY_HITROLL;
    af.modifier  = level / 8;
    af.bitvector = 0;
    affect_to_char( victim, &af );

    af.location  = APPLY_SAVING_SPELL;
    af.modifier  = 0 - level / 8;
    affect_to_char( victim, &af );
    send_to_char( "You feel righteous.\n\r", victim );
    if ( ch != victim )
  act("You grant $N the favor of your god.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}



void spell_blindness( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    char buf[MAX_STRING_LENGTH];

    level = UMIN(ch->level,level);

    if ( saves_spell(level,victim,DAM_OTHER))
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if (IS_AFFECTED(victim,AFF_BLIND))
    {
	if(reup_affect(victim,sn,level/3,level))
	{
    send_to_char( "You are {Gblinded{x!\n\r", victim );
    if ( ch != victim )
    act("$n appears to be {Gblinded{x.",victim,NULL,NULL,TO_ROOM,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }


    /* Gladiator Spectator Channel */ 
    if (IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       sprintf(buf,"%s throws a flaming blast from his hands and singes %s's eyes.",ch->name,victim->name);
       gladiator_talk(buf);
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.location  = APPLY_HITROLL;
    af.modifier  = -4;
    af.duration  = 1+level/4;
    if (IS_SET(victim->mhs,MHS_GLADIATOR) && !IS_NPC(victim))
       af.duration  = 3;
    else
       af.duration  = 1+level/4;
    if ( !IS_NPC(ch) )
    {
        switch( class_table[ch->class].fMana )
        {
        case 0:af.duration = 1+level/8;break;
        case 1:af.duration = 1+level/6;break;
        case 2:af.duration = 1+level/4;break;
        default:af.duration = 1+level/4;break;
        }
    }
    af.bitvector = AFF_BLIND;
    affect_to_char( victim, &af );
    send_to_char( "You are {Gblinded{x!\n\r", victim );
    act("$n appears to be {Gblinded{x.",victim,NULL,NULL,TO_ROOM,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_blindness(sn,level+2,victim,ch,target);
    }   

    return;
}



void spell_burning_hands(int sn,int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    static const sh_int dam_each[] = 
    {
   0,
   0,  0,  0,  0, 14, 17, 20, 23, 26, 29,
  29, 29, 30, 30, 31, 31, 32, 32, 33, 33,
  34, 34, 35, 35, 36, 36, 37, 37, 38, 38,
  39, 39, 40, 40, 41, 41, 42, 42, 43, 43,
  44, 44, 45, 45, 46, 46, 47, 47, 48, 48
    };
    int dam;

    level = UMIN(level, sizeof(dam_each)/sizeof(dam_each[0]) - 1);
    level = UMAX(0, level);
    dam   = number_range( dam_each[level] / 2, dam_each[level] * 2 );
    if ( saves_spell( level, victim,DAM_FIRE) )
    {
      dam /= 2;
    }
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    damage( ch, victim, dam, sn, DAM_FIRE,TRUE,TRUE);
    return;
}



void spell_call_lightning( int sn, int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *vch;
    CHAR_DATA *vch_next;
    char buf[MAX_STRING_LENGTH];
    int dam;

    if ( !IS_OUTSIDE(ch) )
    {
  send_to_char( "You must be out of doors.\n\r", ch );
  return;
    }

    if ( weather_info.sky < SKY_RAINING )
    {
  send_to_char( "You need bad weather.\n\r", ch );
  return;
    }

    dam = dice(level,10 );

    sprintf(buf,"%s's lightning strikes your foes!\n\r",
		deity_table[ch->pcdata->deity].pname);
    send_to_char(buf,ch);
    act( "$n calls $s deity's lightning to strike $s foes!",
  ch, NULL, NULL, TO_ROOM ,FALSE);

    for ( vch = char_list; vch != NULL; vch = vch_next )
    {
  vch_next  = vch->next;
  if ( vch->in_room == NULL )
      continue;
  if ( vch->in_room == ch->in_room )
  {
      if ( vch != ch && !is_safe_spell(ch,vch,TRUE, sn) )
	/* None of this PC's only hitting NPC's and vice versa
	   && ( IS_NPC(ch) ? !IS_NPC(vch) : IS_NPC(vch) ) )
	 */
    damage( ch, vch, saves_spell( level,vch,DAM_LIGHTNING) 
    ? dam / 2 : dam, sn,DAM_LIGHTNING,TRUE,TRUE);
      continue;
  }

  if ( vch->in_room->area == ch->in_room->area
  &&   IS_OUTSIDE(vch)
  &&   IS_AWAKE(vch) )
      send_to_char( "Lightning flashes in the sky.\n\r", vch );
    }

    return;
}

/* RT calm spell stops all fighting in the room */

void spell_calm( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *vch;
    int mlevel = 0;
    int count = 0;
    int high_level = 0;    
    int chance;
    AFFECT_DATA af;


    if (IS_SET(ch->mhs,MHS_GLADIATOR) && 
	ch->in_room == get_room_index(ROOM_VNUM_SINGLE_GLADIATOR))
    {
	send_to_char("No casting Calm in Prep Room!\n\r",ch);
	return;
    }

    /* get sum of all mobile levels in the room */
    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
    {
  if (vch->position == POS_FIGHTING)
  {
      count++;
      if (IS_NPC(vch))
        mlevel += vch->level;
      else
        mlevel += vch->level/2;
      high_level = UMAX(high_level,vch->level);
  }
    }

    /* compute chance of stopping combat */
    chance = 4 * level - high_level + 2 * count;

    /*necromancers are creepy, make them have a less chance of beguiling -Boogums*/
    if (ch->kit== kit_lookup("necromancer") )
    {
      chance=chance*2/3;
    }

    if (IS_IMMORTAL(ch)) /* always works */
      mlevel = 0;

    if (number_range(0, chance) >= mlevel)  /* hard to stop large fights */
    {
  for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
    {
      if (IS_NPC(vch) && (IS_SET(vch->imm_flags,IMM_MAGIC) ||
        IS_SET(vch->act,ACT_UNDEAD)))
        return;

      if (IS_AFFECTED(vch,AFF_CALM) || IS_AFFECTED(vch,AFF_BERSERK)
      ||  is_affected(vch,skill_lookup("frenzy")))
        return;
      
      if(!is_clan(ch) && is_clan(vch) && !IS_NPC(vch) && !IS_NPC(ch) )
      {
 	/* a non-clanner cannot affect a clanner */      
	/* do nothing */
      }
      else if(is_clan(ch) && !is_clan(vch) && !IS_NPC(vch) && !IS_NPC(ch) )
      {
 	/* a clanner cannot affect a non-clanner */      
	/* do nothing*/
      }
      else
      {

      send_to_char("A wave of calm passes over you.\n\r",vch);

      if (vch->fighting || vch->position == POS_FIGHTING)
        stop_fighting(vch,FALSE);


      af.where = TO_AFFECTS;
      af.type = sn;
        af.level = level;
      af.duration = level/4;
      af.location = APPLY_HITROLL;
      if (!IS_NPC(vch))
        af.modifier = -5;
      else
        af.modifier = -2;
      af.bitvector = AFF_CALM;
      affect_to_char(vch,&af);

      af.location = APPLY_DAMROLL;
      affect_to_char(vch,&af);
      }

  }
    }
}

void spell_cancellation( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    bool found = FALSE;
 
    level += 2;
	if( level < ch->level)
      level = UMIN(ch->level+2, level + ch->level/5);

    if ((!IS_NPC(ch) && IS_NPC(victim) && 
   !(IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim) ) ||
        (IS_NPC(ch) && !IS_NPC(victim)) ||
        (!IS_NPC(victim) && IS_SET (victim->act,PLR_NOCANCEL) && (ch != victim)))
    {
  send_to_char("You failed, try dispel magic.\n\r",ch);
  return;
    }

    /* unlike dispel magic, the victim gets NO save */
 
    /* begin running through the spells */

    if (check_dispel(level,victim,gsn_spirit_of_boar) )
	found = TRUE;

    if (check_dispel(level,victim,gsn_spirit_of_bear) )
        found = TRUE;

    if (check_dispel(level,victim,gsn_spirit_of_cat ) )
        found = TRUE;

    if (check_dispel(level,victim,gsn_spirit_of_owl ) )
        found = TRUE;

    if (check_dispel(level,victim,gsn_spirit_of_wolf) )
        found = TRUE;

    if (check_dispel(level/2,victim,skill_lookup("spirit of phoenix")))
	found = TRUE; 
    
    if (check_dispel(level,victim,gsn_honor_guard) )
	found = TRUE;
 
    if (check_dispel(level,victim,gsn_aura_of_valor) )
        found = TRUE;
    if (check_dispel(level,victim,gsn_spell_restrain) )
	found = TRUE;

    if (check_dispel(level,victim,skill_lookup("pox")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("armor")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("aura of cthon")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("asphyxiate")))
	found = TRUE;

    if (check_dispel(level,victim,skill_lookup("bless")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("blindness")))
    {
        found = TRUE;
        act("$n is no longer blinded.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if (check_dispel(level,victim,skill_lookup("body of stone")))
    {
	found = TRUE;
	act("$n regains a fleshy texture.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if (check_dispel(level,victim,skill_lookup("calm")))
    {
  found = TRUE;
  act("$n no longer looks so peaceful...",victim,NULL,NULL,TO_ROOM,FALSE);
    }
 
    if (check_dispel(level,victim,skill_lookup("change sex")))
    {
        found = TRUE;
        act("$n looks more like $mself again.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
 
    if (check_dispel(level,victim,skill_lookup("charm person")))
    {
        found = TRUE;
        act("$n regains $s free will.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
 
    if (check_dispel(level,victim,skill_lookup("cone of silence")))
    {
        found = TRUE;
        act("$n can hear again.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if (check_dispel(level,victim,skill_lookup("chill touch")))
    {
        found = TRUE;
        act("$n looks warmer.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if (check_dispel(level,victim,skill_lookup("orb of touch")))
    {
        found = TRUE;
        act("$n can be touched.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
 
    if (check_dispel(level,victim,skill_lookup("curse")) 
	&& !IS_AFFECTED(victim,AFF_MORPH))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("detect evil")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("detect good")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("detect hidden")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("detect invis")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("detect hidden")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("detect magic")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("tower of iron will")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("body weaponry")))
        found = TRUE;

    if (check_dispel(level-2,victim,skill_lookup("earthbind")))
	found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("faerie fog")))
    {
        act("$n's purple cloud fades.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("faerie fire")))
    {
        act("$n's outline fades.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("fly")))
    {
        act("$n falls to the ground!",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("frenzy")))
    {
  act("$n no longer looks so wild.",victim,NULL,NULL,TO_ROOM,FALSE);;
  found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("fumble")))
	found = TRUE;

    if (check_dispel(level-1,victim,skill_lookup("confusion")))
    {
        found = TRUE;
        act("$n doesn't look boggled.",victim,NULL,NULL,TO_ROOM,FALSE);
    }


    if (check_dispel(level,victim,skill_lookup("giant strength")))
    {
        act("$n no longer looks so mighty.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("haste")))
    {
  act("$n is no longer moving so quickly.",victim,NULL,NULL,TO_ROOM,FALSE);
  found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("infravision")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("invis")))
    {
        act("$n fades into existance.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("irradiate")))
	found = TRUE;

    if (check_dispel(level,victim,skill_lookup("mass invis")))
    {
        act("$n fades into existance.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("pass door")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("protection neutral")))
	found = TRUE;

    if (check_dispel(level,victim,skill_lookup("protection evil")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("protection good")))
        found = TRUE; 
 
    if (check_dispel(level,victim,skill_lookup("sanctuary")))
    {
        act("The white aura around $n's body vanishes.",
            victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("shield")))
    {
        act("The shield protecting $n vanishes.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("sleep")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("slow")))
    {
        act("$n is no longer moving so slowly.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("stone skin")))
    {
        act("$n's skin regains its normal texture.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("weaken")))
    {
        act("$n looks stronger.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
    
    if (check_dispel(level,victim,skill_lookup("withstand death")))
    {
        act("$n no longer looks more powerful than death.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }    
 
    if (found)
        send_to_char("Ok.\n\r",ch);
    else
        send_to_char("Spell failed.\n\r",ch);
}

void spell_cause_light( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

       dam = dice( level, 2);

    if ( saves_spell( level, victim, DAM_HARM ) )
  dam /= 2;
    damage( ch, victim, dam, sn,DAM_HARM,TRUE,TRUE);
    return;
}



void spell_cause_critical(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

       dam = dice( level, 6);

    if ( saves_spell( level, victim, DAM_HARM ) )
  dam /= 2;
    damage( ch, victim, dam, sn,DAM_HARM,TRUE,TRUE);
    return;
}



void spell_cause_serious(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

       dam = dice( level, 4);

    if ( saves_spell( level, victim, DAM_HARM ) )
  dam /= 2;
    damage( ch, victim, dam, sn,DAM_HARM,TRUE,TRUE);
    return;
}

void spell_chain_lightning(int sn,int level,CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    CHAR_DATA *tmp_vict,*last_vict,*next_vict;
    bool found;
    int dam;

    /* first strike */

    act("A lightning bolt leaps from $n's hand and arcs to $N.",
        ch,NULL,victim,TO_ROOM,FALSE);
    act("A lightning bolt leaps from your hand and arcs to $N.",
  ch,NULL,victim,TO_CHAR,FALSE);
    act("A lightning bolt leaps from $n's hand and hits you!",
  ch,NULL,victim,TO_VICT,FALSE);  

    dam = dice(level,6);
    if (ch->class == class_lookup("mage"))
    {
      dam = dice( level, 9);
    }
    if (saves_spell(level,victim,DAM_LIGHTNING))
  dam /= 3;
    damage(ch,victim,dam,sn,DAM_LIGHTNING,TRUE,TRUE);
    last_vict = victim;
    level -= 4;   /* decrement damage */

    /* new targets */
    while (level > 0)
    {
  found = FALSE;
  for (tmp_vict = ch->in_room->people; 
       tmp_vict != NULL; 
       tmp_vict = next_vict) 
  {
    next_vict = tmp_vict->next_in_room;
    if (!is_safe_spell(ch,tmp_vict,TRUE, sn) && tmp_vict != last_vict)
    {
      found = TRUE;
      last_vict = tmp_vict;
      /** 
      act("The bolt arcs to $n!",tmp_vict,NULL,NULL,TO_ROOM,FALSE);
      act("The bolt hits you!",tmp_vict,NULL,NULL,TO_CHAR,FALSE);
       **/
      dam = dice(level,6);
      if (saves_spell(level,tmp_vict,DAM_LIGHTNING))
    dam /= 3;
      damage(ch,tmp_vict,dam,sn,DAM_LIGHTNING,TRUE,TRUE);
      level -= 4;  /* decrement damage */
    }
  }   /* end target searching loop */
  
  if (!found) /* no target found, hit the caster */
  {
    if (ch == NULL)
          return;

    if (last_vict == ch) /* no double hits */
    {
      act("The bolt seems to have fizzled out.",ch,NULL,NULL,TO_ROOM,FALSE);
      act("The bolt grounds out through your body.",
    ch,NULL,NULL,TO_CHAR,FALSE);
      return;
    }
  
    last_vict = ch;
    act("The bolt arcs to $n...whoops!",ch,NULL,NULL,TO_ROOM,FALSE);
    send_to_char("You are struck by your own lightning!\n\r",ch);
    dam = dice(level,6);
    if (saves_spell(level,ch,DAM_LIGHTNING))
      dam /= 3;
    damage(ch,ch,dam,sn,DAM_LIGHTNING,TRUE,TRUE);
    level -= 4;  /* decrement damage */
    if (ch == NULL) 
      return;
  }
    /* now go back and find more targets */
    }
}
    

void spell_change_sex( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ))
    {
  if (victim == ch)
    send_to_char("You've already been changed.\n\r",ch);
  else
    act("$N has already had $s(?) sex changed.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }
    if (saves_spell(level , victim,DAM_OTHER))
  return; 
    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = 2 * level;
    af.location  = APPLY_SEX;
    do
    {
  af.modifier  = number_range( 0, 2 ) - victim->sex;
    }
    while ( af.modifier == 0 );
    af.bitvector = 0;
    affect_to_char( victim, &af );
    send_to_char( "You feel different.\n\r", victim );
    act("$n doesn't look like $mself anymore...",victim,NULL,NULL,TO_ROOM,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch  && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_change_sex(sn,level+2,victim,ch,target);
    }   
    return;
}



void spell_charm_person( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    CHAR_DATA *fvict;
    AFFECT_DATA af;
    int levtot = 0;

    if (is_safe(ch,victim)) return;

    if ( victim == ch )
    {
  send_to_char( "You like yourself even better!\n\r", ch );
  return;
    }

    if(is_affected(ch,skill_lookup("wound transfer")))
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if(IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Highlanders can not charm.\n\r",ch);
       return;
    }
    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not charm person.\n\r",ch);
       return;
    }

    if ( !IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("mage")) )
	level = 9* level /10 ;
    /*necromancers are creepy, they don't beguile well -Boogums*/
    if (ch->kit== kit_lookup("necromancer") )
    {
      level = level*3/4;
    }
//make social stat affect it a bit
    if (!IS_NPC(ch) )
    {
	if(get_curr_stat(ch,STAT_SOC) < 10)
	{
	    level = level - number_range(1,4);
	}
	if(get_curr_stat(ch,STAT_SOC) >= 10 &&
           get_curr_stat(ch,STAT_SOC) <= 18 )
  	{
	    level = level + number_range(-2,2);
	}

	if(get_curr_stat(ch,STAT_SOC) >= 19 )
	{
	  level = level + number_range(1,4);
	}
    }
    if ( (IS_NPC(victim) && IS_SET(victim->act, ACT_AGGRESSIVE))
    ||   IS_AFFECTED(victim, AFF_CHARM)
    ||   IS_AFFECTED(ch, AFF_CHARM)
    ||   IS_SET(victim->act, PLR_DWEEB) 
    ||   level < victim->level
    ||   IS_SET(victim->imm_flags,IMM_CHARM)
    ||   saves_spell( level, victim,DAM_CHARM)
    ||   victim->position == POS_FIGHTING )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

  for ( fvict = char_list; fvict != NULL; fvict = fvict->next )
    {
    if ( is_same_group( fvict, ch ) && (IS_NPC(fvict) && fvict->master == ch) )
      levtot += fvict->level;
    }

  if ( IS_NPC(victim) &&
	(compute_casting_level(ch,sn)*5) < (levtot + victim->level) )
  {
    send_to_char ("You're controlling as many mental slaves as you can handle.",ch);
    return;
  }

/*    if (IS_SET(victim->in_room->room_flags,ROOM_LAW))
    {
  send_to_char(
      "The mayor does not allow charming in the city limits.\n\r",ch);
  return;
    }
*/  

    switch(check_immune(victim,DAM_MENTAL))
    {
  case IS_IMMUNE:   level = (IS_NPC(victim)?1:0);  break;
  case IS_RESISTANT:  level = (IS_NPC(victim)?level/2:1);  break;
  case IS_VULNERABLE: level = (IS_NPC(victim)?level+4:2);  break;
  default:	level = (IS_NPC(victim)?level:1); break;
    }

    if ( IS_NPC(victim) && victim->spec_fun != 0 )
       if (victim->spec_fun == spec_lookup("spec_executioner")
	   || victim->spec_fun == spec_lookup("spec_guard_l")
	   || victim->spec_fun == spec_lookup("spec_guard_d"))
	  victim->spec_fun = 0;

    if ( victim->master )
      stop_follower( victim );
    add_follower( victim, ch );
    victim->leader = ch;
    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = IS_NPC(victim)?number_fuzzy(level/4):level;
    if ( !IS_NPC(ch) )
    {
        switch( class_table[ch->class].fMana )
        {
        case 0:af.duration = IS_NPC(victim)?number_fuzzy(level/8):level/4;break;
        case 1:af.duration = IS_NPC(victim)?number_fuzzy(level/6):level/2;break;
        case 2:af.duration = IS_NPC(victim)?number_fuzzy(level/4):level;break;
        default:af.duration = IS_NPC(victim)?number_fuzzy(level/4):level;break;
        }
    }
    af.location  = 0;
    af.modifier  = 0;
    af.bitvector = AFF_CHARM;
    affect_to_char( victim, &af );
    act( "Isn't $n just so nice?", ch, NULL, victim, TO_VICT ,FALSE);
    if ( ch != victim )
  act("$N looks at you with adoring eyes.",ch,NULL,victim,TO_CHAR,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch  && victim->clan != ch->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_charm_person(sn,level+2,victim,ch,target);
    }   

    return;
}



void spell_chill_touch( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    static const sh_int dam_each[] = 
    {
   0,
   0,  0,  6,  7,  8,  9, 12, 13, 13, 13,
  14, 14, 14, 15, 15, 15, 16, 16, 16, 17,
  17, 17, 18, 18, 18, 19, 19, 19, 20, 20,
  20, 21, 21, 21, 22, 22, 22, 23, 23, 23,
  24, 24, 24, 25, 25, 25, 26, 26, 26, 27
    };
    AFFECT_DATA af;
    int dam;

    level = UMIN(level, sizeof(dam_each)/sizeof(dam_each[0]) - 1);
    level = UMAX(0, level);
    dam   = number_range( dam_each[level] / 2, dam_each[level] * 2 );
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    if ( !saves_spell( level, victim,DAM_COLD ) && !is_affected( victim, sn ))
    {
  act("$n turns blue and shivers.",victim,NULL,NULL,TO_ROOM,FALSE);
  af.where     = TO_AFFECTS;
  af.type      = sn;
        af.level     = level;
  af.duration  = 6;
  af.location  = APPLY_STR;
  af.modifier  = -1;
  af.bitvector = 0;
  affect_join( victim, &af );
    }
    else
    {
  dam /= 2;
    }

    damage( ch, victim, dam, sn, DAM_COLD,TRUE ,TRUE);
    return;
}



void spell_colour_spray( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    static const sh_int dam_each[] = 
    {
   0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
  30, 35, 40, 45, 50, 55, 55, 55, 56, 57,
  58, 58, 59, 60, 61, 61, 62, 63, 64, 64,
  65, 66, 67, 67, 68, 69, 70, 70, 71, 72,
  73, 73, 74, 75, 76, 76, 77, 78, 79, 79
    };
    int dam;

    level = UMIN(level, sizeof(dam_each)/sizeof(dam_each[0]) - 1);
    level = UMAX(0, level);
    dam   = number_range( dam_each[level] / 2,  dam_each[level] * 2 );
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    if ( saves_spell( level, victim,DAM_LIGHT) )
  dam /= 2;
    else 
  spell_blindness(skill_lookup("blindness"),
      level/2,ch,(void *) victim,TARGET_CHAR);

    damage( ch, victim, dam, sn, DAM_LIGHT,TRUE ,TRUE);
    return;
}



void spell_continual_light(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *light;

    if (target_name[0] != '\0')  /* do a glow on some object */
    {
  light = get_obj_carry(ch,target_name);
  
  if (light == NULL)
  {
      send_to_char("You don't see that here.\n\r",ch);
      return;
  }

  if (IS_OBJ_STAT(light,ITEM_GLOW))
  {
      act("$p is already glowing.",ch,light,NULL,TO_CHAR,FALSE);
      return;
  }

  SET_BIT(light->extra_flags,ITEM_GLOW);
  act("$p glows with a white light.",ch,light,NULL,TO_ALL,FALSE);
  return;
    }

    light = create_object( get_obj_index( OBJ_VNUM_LIGHT_BALL ), 0, FALSE );
    obj_to_room( light, ch->in_room );
    act( "$n twiddles $s thumbs and $p appears.",   ch, light, NULL, TO_ROOM ,FALSE);
    act( "You twiddle your thumbs and $p appears.", ch, light, NULL, TO_CHAR ,FALSE);
    return;
}



void spell_control_weather(int sn,int level,CHAR_DATA *ch,void *vo,int target) 
{
    if ( !str_cmp( target_name, "better" ) )
  weather_info.change += dice( level / 3, 4 );
    else if ( !str_cmp( target_name, "worse" ) )
  weather_info.change -= dice( level / 3, 4 );
    else
  send_to_char ("Do you want it to get better or worse?\n\r", ch );

    send_to_char( "Ok.\n\r", ch );
    return;
}



void spell_create_food( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    OBJ_DATA *mushroom;

    mushroom = create_object( get_obj_index( OBJ_VNUM_MUSHROOM ), 0, FALSE );
    mushroom->value[0] = level / 2;
    mushroom->value[1] = level;
    obj_to_room( mushroom, ch->in_room );
    act( "$p suddenly appears.", ch, mushroom, NULL, TO_ROOM ,FALSE);
    act( "$p suddenly appears.", ch, mushroom, NULL, TO_CHAR ,FALSE);
    return;
}

void spell_create_rose( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    OBJ_DATA *rose;
    rose = create_object(get_obj_index(OBJ_VNUM_ROSE), 0, FALSE);
    act("$n has created a beautiful red rose.",ch,rose,NULL,TO_ROOM,FALSE);
    send_to_char("You create a beautiful red rose.\n\r",ch);
    obj_to_char(rose,ch);
    return;
}

void spell_create_fountain(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *fount;

    fount = create_object( get_obj_index( OBJ_VNUM_FOUNTAIN ), 0, FALSE );
    fount->timer = level;
    fount->value[2] = liq_lookup( target_name );

    obj_to_room( fount, ch->in_room );
    act( "$p materializes before you.",ch,fount,NULL,TO_CHAR,FALSE);
    act( "$p materializes before you.",ch,fount,NULL,TO_ROOM,FALSE);
    return;
}

void spell_create_spring(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    OBJ_DATA *spring;

    spring = create_object( get_obj_index( OBJ_VNUM_SPRING ), 0, FALSE );
    spring->timer = level;
    obj_to_room( spring, ch->in_room );
    act( "$p flows from the ground.", ch, spring, NULL, TO_ROOM ,FALSE);
    act( "$p flows from the ground.", ch, spring, NULL, TO_CHAR ,FALSE);
    return;
}



void spell_create_water( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    int water;

    if ( obj->item_type != ITEM_DRINK_CON  
	|| obj->pIndexData->vnum == OBJ_VNUM_GRAIL)
    {
  send_to_char( "It is unable to hold water.\n\r", ch );
  return;
    }

    if ( obj->value[2] != LIQ_WATER && obj->value[1] != 0 )
    {
  send_to_char( "It contains some other liquid.\n\r", ch );
  return;
    }

    water = UMIN(
    level * (weather_info.sky >= SKY_RAINING ? 4 : 2),
    obj->value[0] - obj->value[1]
    );
  
    if ( water > 0 )
    {
  obj->value[2] = LIQ_WATER;
  obj->value[1] += water;
  if ( !is_name( "water", obj->name ) )
  {
      char buf[MAX_STRING_LENGTH];

      sprintf( buf, "%s water", obj->name );
      free_string( obj->name );
      obj->name = str_dup( buf );
  }
  act( "$p is filled.", ch, obj, NULL, TO_CHAR ,FALSE);
    }

    return;
}



void spell_cure_blindness(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;

    if ( !is_affected( victim, gsn_blindness ) && !is_affected(victim,skill_lookup("eye gouge")) )
    {
        if (victim == ch)
          send_to_char("You aren't blind.\n\r",ch);
        else
          act("$N doesn't appear to be blinded.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
    }
 
   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("cleric")) ) 
	level = level * 9 / 10 ;

    if ( is_affected(victim,gsn_blindness) && check_dispel(level,victim,gsn_blindness))
    {
        send_to_char( "Your vision returns!\n\r", victim );
        act("$n is no longer blinded.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
    else
    if ( check_dispel(level,victim,skill_lookup("eye gouge") ) )
    {
	send_to_char("Your vision returns!\n\r",victim);
	act("$n is no longer blinded.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
    else
        send_to_char("Spell failed.\n\r",ch);
}



void spell_cure_critical( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int heal;

    heal = dice(3, 8) + level - 6;
    if ( ch->race == race_lookup("volare") )
	heal = 3 * heal / 2;

    if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("cleric") &&
		 ch->pcdata->old_class!=class_lookup("elementalist")))
	heal -= ( heal / 4 );

    victim->hit = UMIN( victim->hit + heal, victim->max_hit );
    update_pos( victim );
    send_to_char( "You feel better!\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
    return;
}

/* RT added to cure plague */
void spell_cure_disease( int sn, int level, CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int found = FALSE;

    if ( !is_affected( victim, gsn_plague ) &&
	 !is_affected( victim, gsn_irradiate ) )
    {
        if (victim == ch)
          send_to_char("You aren't ill.\n\r",ch);
        else
          act("$N doesn't appear to be diseased.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
    }
    
   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("cleric") &&
	 ch->pcdata->old_class!=class_lookup("elementalist")))
	level = 9 * level / 10;

    if (check_dispel(level,victim,gsn_plague))
    {
  send_to_char("Your sores vanish.\n\r",victim);
  act("$n looks relieved as $s sores vanish.",victim,NULL,NULL,TO_ROOM,FALSE);
  found = TRUE;
    }

    if (check_dispel(level,victim,gsn_irradiate))
    {
  send_to_char("Your sickness leaves your body.\n\r",victim);
  act("$n appears to hvae regained $s health.",victim,NULL,NULL,TO_ROOM,FALSE);
  found = TRUE;
    }

   /* 
    if (check_dispel(level, victim, skill_lookup("confusion")))
    {
  act("$n appears to have regained $s mental faculties.\n\r", victim, NULL, NULL, TO_ROOM, FALSE);
  found = TRUE;
    }
    */
  
  if( !found )
  send_to_char("Spell failed.\n\r",ch);
}



void spell_cure_light( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int heal;

    heal = dice(1, 8) + level / 3;
    if ( ch->race == race_lookup("volare") )
	heal = 3 * heal / 2;

   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("cleric") &&
	 ch->pcdata->old_class!=class_lookup("elementalist")))
	heal -= ( heal / 4 );

    victim->hit = UMIN( victim->hit + heal, victim->max_hit );
    update_pos( victim );
    send_to_char( "You feel better!\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
    return;
}



void spell_cure_poison( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
 
    if ( !is_affected( victim, gsn_poison ) )
    {
        if (victim == ch)
          send_to_char("You aren't poisoned.\n\r",ch);
        else
          act("$N doesn't appear to be poisoned.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
    }
 
   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("cleric") &&
	 ch->pcdata->old_class!=class_lookup("elementalist")))
	level = 9* level/ 10;
	
    if (check_dispel(level,victim,gsn_poison))
    {
        send_to_char("A warm feeling runs through your body.\n\r",victim);
        act("$n looks much better.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
    else
        send_to_char("Spell failed.\n\r",ch);
}


void spell_cure_serious( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int heal;

    heal = dice(2, 8) + level /2 ;
    if ( ch->race == race_lookup("volare") )
	heal = 3 * heal / 2;

    if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("cleric") &&
		 ch->pcdata->old_class!=class_lookup("elementalist")))
	heal -= ( heal / 4 );

    victim->hit = UMIN( victim->hit + heal, victim->max_hit );
    update_pos( victim );
    send_to_char( "You feel better!\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
    return;
}



void spell_curse( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    AFFECT_DATA af;

    /* deal with the object case first */
    if (target == TARGET_OBJ)
    {
        obj = (OBJ_DATA *) vo;
        if (IS_OBJ_STAT(obj,ITEM_EVIL))
        {
            act("$p is already filled with evil.",ch,obj,NULL,TO_CHAR,FALSE);
            return;
        }

        if (IS_OBJ_STAT(obj,ITEM_BLESS))
        {
            AFFECT_DATA *paf;

            paf = affect_find(obj->affected,skill_lookup("bless"));
            if (!saves_dispel(level,paf != NULL ? paf->level : obj->level,0))
            {
                if (paf != NULL)
                    affect_remove_obj(obj,paf);
                act("$p glows with a red aura.",ch,obj,NULL,TO_ALL,FALSE);
                REMOVE_BIT(obj->extra_flags,ITEM_BLESS);
                return;
            }
            else
            {
                act("The holy aura of $p is too powerful for you to overcome.",
                    ch,obj,NULL,TO_CHAR,FALSE);
                return;
            }
        }

        af.where        = TO_OBJECT;
        af.type         = sn;
        af.level        = level;
        af.duration     = 2 * level;
    if ( !IS_NPC(ch) )
    {
        switch( class_table[ch->class].fMana )
        {
        case 0:af.duration = level/2;break;
        case 1:af.duration = level;break;
        case 2:af.duration = 2 * level;break;
        default:af.duration = 2 * level;break;
        }
    }
        af.location     = APPLY_SAVES;
        af.modifier     = +1;
        af.bitvector    = ITEM_EVIL;
        affect_to_obj(obj,&af);

        act("$p glows with a malevolent aura.",ch,obj,NULL,TO_ALL,FALSE);
        return;
    }

    /* character curses */
    victim = (CHAR_DATA *) vo;

    if ( saves_spell(level,victim,DAM_NEGATIVE))
    {
       send_to_char("You failed.\n\r",ch);
       return;
    }

    if (IS_AFFECTED(victim,AFF_CURSE) || is_affected(ch,gsn_morph))
    {
	if(reup_affect(victim,sn,level/3,level))
	{
    send_to_char( "You feel unclean.\n\r", victim );
    if ( ch != victim )
  act("$N looks very uncomfortable.",ch,NULL,victim,TO_CHAR,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = level / 3;
    af.location  = APPLY_HITROLL;
    af.modifier  = -1 * (level / 8);
    af.bitvector = AFF_CURSE;
    affect_to_char( victim, &af );

    af.location  = APPLY_SAVING_SPELL;
    af.modifier  = level / 8;
    affect_to_char( victim, &af );

    send_to_char( "You feel unclean.\n\r", victim );
    if ( ch != victim )
  act("$N looks very uncomfortable.",ch,NULL,victim,TO_CHAR,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_curse(sn,level+2,victim,ch,target);
    }   

    return;
}

/* RT replacement demonfire spell */

void spell_demonfire(int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    if ( !IS_NPC(ch) && !IS_EVIL(ch) )
    {
        victim = ch;
  send_to_char("The demons turn upon you!\n\r",ch);
    }
 
   if ( !is_affected(ch, skill_lookup("indulgence")) )
    ch->alignment = UMAX(-1000, ch->alignment - 50);

    if (victim != ch)
    {
  act("$n calls forth the demons of Hell upon $N!",
      ch,NULL,victim,TO_ROOM,FALSE);
        act("$n has assailed you with the demons of Hell!",
      ch,NULL,victim,TO_VICT,FALSE);
  send_to_char("You conjure forth the demons of hell!\n\r",ch);
    }
    dam = dice( level, 10 );
    if ( saves_spell( level, victim,DAM_NEGATIVE) )
        dam /= 2;
    spell_curse(gsn_curse, 3 * level / 4, ch, (void *) victim,TARGET_CHAR);
    damage( ch, victim, dam, sn, DAM_NEGATIVE ,TRUE,TRUE);
}

void spell_detect_evil( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_DETECT_ALIGN) )
    {
    	if(reup_affect(victim,sn,level,level))
	{
    send_to_char( "Your eyes tingle.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level   = number_fuzzy(level);
    af.duration  = number_fuzzy(level);
    af.modifier  = 0;
    af.location  = APPLY_NONE;
    af.bitvector = AFF_DETECT_ALIGN;
    affect_to_char( victim, &af );
    send_to_char( "Your eyes tingle.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
    return;
}


void spell_detect_good( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
 
    if ( IS_AFFECTED(victim, AFF_DETECT_ALIGN) )
    {
    	if(reup_affect(victim,sn,level,level))
	{
    send_to_char( "Your eyes tingle.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }
 
    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = number_fuzzy(level);
    af.duration  = number_fuzzy(level);
    af.modifier  = 0;
    af.location  = APPLY_NONE;
    af.bitvector = AFF_DETECT_ALIGN;
    affect_to_char( victim, &af );
    send_to_char( "Your eyes tingle.\n\r", victim );
    if ( ch != victim )
        send_to_char( "Ok.\n\r", ch );
    return;
}



void spell_detect_hidden(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_DETECT_HIDDEN) )
    {
    	if(reup_affect(victim,sn,level,level))
	{
    send_to_char( "Your awareness improves.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = number_fuzzy(level);
    af.duration  = number_fuzzy(level);
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_DETECT_HIDDEN;
    affect_to_char( victim, &af );
    send_to_char( "Your awareness improves.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
    return;
}



void spell_detect_invis( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_DETECT_INVIS) )
    {
    	if(reup_affect(victim,sn,level,level))
	{
    send_to_char( "Your eyes tingle.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = number_fuzzy(level);
    af.duration  = number_fuzzy(level);
    af.modifier  = 0;
    af.location  = APPLY_NONE;
    af.bitvector = AFF_DETECT_INVIS;
    affect_to_char( victim, &af );
    send_to_char( "Your eyes tingle.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
    return;
}



void spell_detect_magic( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_DETECT_MAGIC) )
    {
    	if(reup_affect(victim,sn,level,level))
	{
    send_to_char( "Your eyes tingle.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level   = number_fuzzy(level);
    af.duration  = number_fuzzy(level);
    af.modifier  = 0;
    af.location  = APPLY_NONE;
    af.bitvector = AFF_DETECT_MAGIC;
    affect_to_char( victim, &af );
    send_to_char( "Your eyes tingle.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
    return;
}



void spell_detect_poison( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;

    if ( obj->item_type == ITEM_DRINK_CON || obj->item_type == ITEM_FOOD )
    {
  if ( obj->value[3] != 0 )
      send_to_char( "You smell poisonous fumes.\n\r", ch );
  else
      send_to_char( "It looks delicious.\n\r", ch );
    }
    else
    {
  send_to_char( "It doesn't look poisoned.\n\r", ch );
    }

    return;
}



void spell_dispel_evil( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;
  
    if ( !IS_NPC(ch) && IS_EVIL(ch) )
  victim = ch;
  
    if ( IS_GOOD(victim) )
    {
  act( "$N is protected by $s deity.", ch, NULL, victim, TO_ROOM ,FALSE);
  return;
    }

    if ( IS_NEUTRAL(victim) )
    {
  act( "$N does not seem to be affected.", ch, NULL, victim, TO_CHAR ,FALSE);
  return;
    }

    if (victim->hit > (ch->level * 4))
      dam = dice( level, 4 );
    else
      dam = UMAX(victim->hit, dice(level,4));
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    if ( saves_spell( level, victim,DAM_HOLY) )
  dam /= 2;
    damage( ch, victim, dam, sn, DAM_HOLY ,TRUE,TRUE);
    return;
}


void spell_dispel_good( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;
 
    if ( !IS_NPC(ch) && IS_GOOD(ch) )
        victim = ch;
 
    if ( IS_EVIL(victim) )
    {
        act( "$N is protected by $S evil.", ch, NULL, victim, TO_ROOM ,FALSE);
        return;
    }
 
    if ( IS_NEUTRAL(victim) )
    {
        act( "$N does not seem to be affected.", ch, NULL, victim, TO_CHAR ,FALSE);
        return;
    }
 
    if (victim->hit > (ch->level * 4))
      dam = dice( level, 4 );
    else
      dam = UMAX(victim->hit, dice(level,4));
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    if ( saves_spell( level, victim,DAM_NEGATIVE) )
        dam /= 2;
    damage( ch, victim, dam, sn, DAM_NEGATIVE ,TRUE,TRUE);
    return;
}


/* modified for enhanced use */

void spell_dispel_magic( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    bool found = FALSE;
    char buf[MAX_STRING_LENGTH];
    int  lower_level; 

/*02OCT02 trying to help out casters a bit - Corey*/
#ifdef COREYTEST
    if ( !IS_NPC(victim) )
    {
	switch( class_table[victim->pcdata->old_class].fMana )
	{
	case 0:
		level += 2;
		break;
	case 1:
		level += 1;
		break;
	case 2:
		level += 0;
		break;
	default:
		level += 0;
		break;
	} 
    }
#endif

    if (saves_spell(level, victim,DAM_OTHER))
    {
  send_to_char( "You feel a brief tingling sensation.\n\r",victim);
  send_to_char( "You failed.\n\r", ch);
  return;
    }

    /* begin running through the spells */ 

    if ((IS_SET(victim->mhs,MHS_GLADIATOR) || 
	IS_SET(victim->mhs,MHS_HIGHLANDER)) && !IS_NPC(victim)) 
       lower_level = 15;
    else
       lower_level = 66;

    if (check_dispel(level/2,victim,skill_lookup("spirit of phoenix")))
    {
	act("$n shivers as though a great spirit has left.",victim,NULL,NULL,TO_ROOM,FALSE);
	found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("wound transfer")))
    {
	int dam;

	if(number_percent() > lower_level ) level--;
	found = TRUE;
	act("Your body screams in pain as your soul is stripped of its link.",
		ch,NULL,victim,TO_VICT,FALSE);
	act("$N cries out in pain!",ch,NULL,victim,TO_CHAR,FALSE);
	act("$N cries out in pain!",ch,NULL,victim,TO_NOTVICT,FALSE);
	dam = number_range( level / 2, 3 * level / 2 );
	   damage( ch, victim, dam, sn, DAM_NEGATIVE, FALSE,TRUE);
    }

    if (check_dispel(level,victim,skill_lookup("armor")))
    {
	if(number_percent() > lower_level) level--;
	found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("asphyxiate")))
    {
	found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("bless")))
    {
	if(number_percent() > lower_level) level--;
	found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("blindness")))
    {
        found = TRUE;
        act("$n is no longer blinded.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if (check_dispel(level,victim,skill_lookup("body of stone")))
    {
	if(number_percent() > lower_level) level--;
	found = TRUE;
	act("$n regains a fleshy texture.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if (check_dispel(level,victim,skill_lookup("calm")))
    {
        found = TRUE;
        act("$n no longer looks so peaceful...",victim,NULL,NULL,TO_ROOM,FALSE);
    }
 
    if (check_dispel(level,victim,skill_lookup("change sex")))
    {
        found = TRUE;
        act("$n looks more like $mself again.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
 
    if (check_dispel(level,victim,skill_lookup("charm person")))
    {
        found = TRUE;
        act("$n regains $s free will.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
 
    if (check_dispel(level,victim,skill_lookup("chill touch")))
    {
        found = TRUE;
        act("$n looks warmer.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if (check_dispel(level,victim,skill_lookup("honor guard")))
    {
        found = TRUE;
	act("The shield of honor around $n vanishes.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
    if (check_dispel(level,victim,skill_lookup("aura of cthon")))
    {
        found = TRUE;
        act("The aura of {RCthon{x around $n vanishes.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
    if (check_dispel(level,victim,skill_lookup("confusion")))
    {
        found = TRUE;
        act("$n doesn't look boggled.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

 
    if (check_dispel(level,victim,skill_lookup("curse")))
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("detect evil")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("detect good")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("detect hidden")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("detect invis")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("detect magic")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("earthbind")))
	found = TRUE;

    if (check_dispel(level,victim,skill_lookup("faerie fog")))
    {
        act("$n's purple cloud fades.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("faerie fire")))
    {
        act("$n's outline fades.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("fly")))
    {
        act("$n falls to the ground!",victim,NULL,NULL,TO_ROOM,FALSE);
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("frenzy")))
    {
        act("$n no longer looks so wild.",victim,NULL,NULL,TO_ROOM,FALSE);;
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }

  if (check_dispel(level,victim,skill_lookup("fumble")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("giant strength")))
    {
        act("$n no longer looks so mighty.",victim,NULL,NULL,TO_ROOM,FALSE);
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("haste")))
    {
        act("$n is no longer moving so quickly.",victim,NULL,NULL,TO_ROOM,FALSE);
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("infravision")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("invis")))
    {
        act("$n fades into existance.",victim,NULL,NULL,TO_ROOM,FALSE);
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("irradiate")))
	found = TRUE;

    if (check_dispel(level,victim,skill_lookup("mass invis")))
    {
        act("$n fades into existance.",victim,NULL,NULL,TO_ROOM,FALSE);
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("pass door")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }


    if (check_dispel(level,victim,skill_lookup("protection evil")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("protection neutral")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }

    if (check_dispel(level,victim,skill_lookup("protection good")))
    {
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("sanctuary")))
    {
        act("The white aura around $n's body vanishes.",
            victim,NULL,NULL,TO_ROOM,FALSE);
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }

    if (IS_NPC(victim) && IS_AFFECTED(victim,AFF_SANCTUARY) 
  && !saves_dispel(level, victim->level,-1)
  && !is_affected(victim,skill_lookup("sanctuary")))
    {
  REMOVE_BIT(victim->affected_by,AFF_SANCTUARY);
        act("The white aura around $n's body vanishes.",
            victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("shield")))
    {
        act("The shield protecting $n vanishes.",victim,NULL,NULL,TO_ROOM,FALSE);
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("sleep")))
        found = TRUE;

    if (check_dispel(level,victim,skill_lookup("slow")))
    {
        act("$n is no longer moving so slowly.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("stone skin")))
    {
        act("$n's skin regains its normal texture.",victim,NULL,NULL,TO_ROOM,FALSE);
	if(number_percent() > lower_level) level--;
        found = TRUE;
    }
 
    if (check_dispel(level,victim,skill_lookup("weaken")))
    {
        act("$n looks stronger.",victim,NULL,NULL,TO_ROOM,FALSE);
        found = TRUE;
    }
 
    if (found)
    {
        send_to_char("Ok.\n\r",ch);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch  && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_dispel_magic(sn,level+2,victim,ch,target);
    }   

     /* Gladiator Spectator Channel */ 
     if (IS_SET(ch->mhs,MHS_GLADIATOR))
     {
       sprintf(buf,"%s invokes a red aura around %s, removing his protections.",ch->name,victim->name);
       gladiator_talk(buf);
     }
    }
    else
    {
        send_to_char("Spell failed.\n\r",ch);
     /* Gladiator Spectator Channel */ 
     if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
     {
       sprintf(buf,"%s fails to invoke a destructive aura on %s.",ch->name,victim->name);
       gladiator_talk(buf);
     }
    }
  return;
}

void spell_earthquake( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *vch;
    CHAR_DATA *vch_next;

    send_to_char( "The earth trembles beneath your feet!\n\r", ch );
    act( "$n makes the earth tremble and shiver.", ch, NULL, NULL, TO_ROOM ,FALSE);

    for ( vch = char_list; vch != NULL; vch = vch_next )
    {
  vch_next  = vch->next;
  if ( vch->in_room == NULL )
      continue;
  if ( vch->in_room == ch->in_room )
  {
      if ( vch != ch && !is_safe_spell(ch,vch,TRUE, sn))
      {
    if (IS_AFFECTED(vch,AFF_FLYING))
        damage(ch,vch,0,sn,DAM_BASH,TRUE,TRUE);
    else
        damage( ch,vch,level + dice(2, 8), sn, DAM_BASH,TRUE,TRUE);
      }
      continue;
  }

  if ( vch->in_room->area == ch->in_room->area )
      send_to_char( "The earth trembles and shivers.\n\r", vch );
    }

    return;
}

void spell_warp( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    char size[MAX_INPUT_LENGTH];
    char blah[MAX_INPUT_LENGTH];
    int old_size,factor;

    if (obj->item_type != ITEM_ARMOR)
    {
	send_to_char("That isn't an armor.\n\r",ch);
	return;
    }

    if (obj->wear_loc != -1)
    {
	send_to_char("The item must be carried to be warped.\n\r",ch);
	return;
    }

    /* item destroyed? */
    if (IS_SET(obj->extra_flags,ITEM_WARPED))
    {
	level /= 2;
	level -= ( ++obj->warps * 10 );
    }

    if (number_percent() < (obj->level - level))
    {
	act("$p wavers... and crumbles to dust!",ch,obj,NULL,TO_CHAR,FALSE);
	act("$p wavers... and crumbles to dust!",ch,obj,NULL,TO_ROOM,FALSE);
	extract_obj(obj);
	return;
    }

    target_name = one_argument( target_name, blah );
    target_name = one_argument( target_name, size );

    if ( (old_size = obj->value[4]) == 0 )
	old_size = 3;

    switch ( UPPER(size[0]) )
    {
        case 'O':
	  obj->value[4] = 0;
	  break;

	case 'T':
	  obj->value[4] = 1;
	  break;

	case 'S':
	  obj->value[4] = 2;
	  break;

	case 'M':
	  obj->value[4] = 3;
	  break;

	case 'L':
	  obj->value[4] = 4;
	  break;

	case 'H':
	  obj->value[4] = 5;
	  break;

	case 'G':
	  obj->value[4] = 6;
	  break;

	default:
	  send_to_char("That's not a valid size.\n\r",ch);
	  return;
    }

    /** We want to change the object's weight as well, so that
     ** making something smaller makes it lighter (for elves, etc).
     * Change weight by +- 10% per size difference 
     * Using a new variable for the sake of clarity 
     * Also remove object from char and re-assign it to fix weights */
    
    obj_from_char( obj );
    factor = 10 * (obj->value[4] - old_size);
    obj->weight =  UMAX(1,( ( 100 + factor ) * obj->weight ) / 100);
    obj_to_char( obj, ch );

    SET_BIT(obj->extra_flags,ITEM_WARPED);
    act("$n warps $p to a new size.",ch,obj,NULL,TO_ROOM,FALSE);
    act("You warp $p to a new size.",ch,obj,NULL,TO_CHAR,FALSE);

    return;
}

void spell_enchant_armor( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    AFFECT_DATA *paf; 
    int result, fail;
    int ac_bonus, added;
    bool ac_found = FALSE;

    if (obj->item_type != ITEM_ARMOR)
    {
  send_to_char("That isn't an armor.\n\r",ch);
  return;
    }

    if (obj->wear_loc != -1)
    {
  send_to_char("The item must be carried to be enchanted.\n\r",ch);
  return;
    }

    /* this means they have no bonus */
    ac_bonus = 0;
    fail = 25;  /* base 25% chance of failure */

    /* find the bonuses */

    if (!obj->enchanted)
      for ( paf = obj->pIndexData->affected; paf != NULL; paf = paf->next )
      {
            if ( paf->location == APPLY_AC )
            {
        ac_bonus = paf->modifier;
    ac_found = TRUE;
        fail += 5 * (ac_bonus * ac_bonus);
      }

      else  /* things get a little harder */
        fail += 20;
      }
 
    for ( paf = obj->affected; paf != NULL; paf = paf->next )
    {
  if ( paf->location == APPLY_AC )
    {
      ac_bonus = paf->modifier;
      ac_found = TRUE;
      fail += 5 * (ac_bonus * ac_bonus);
  }

  else /* things get a little harder */
      fail += 20;
    }

    /* apply other modifiers */
    fail -= level;

    if (IS_OBJ_STAT(obj,ITEM_BLESS))
  fail -= 15;
    if (IS_OBJ_STAT(obj,ITEM_GLOW))
  fail -= 5;

    if (HAS_KIT(ch,"enchanter"))
  fail -= 30;
    if (number_percent() < get_skill(ch,gsn_spellcraft) )
  fail -= ( get_skill(ch, gsn_spellcraft) / 7 );

  fail += ( 90 - get_skill(ch,sn) );

   /* Magelabs */
   if(!IS_NPC(ch)&&( ch->class == class_lookup("mage") || 
		     ch->class == class_lookup("wizard") ) )
   {
       int factor = 0;
       switch( ch->in_room->sector_type )
       {
       case SECT_MAGELAB_SIMPLE: factor = 20; break;
       case SECT_MAGELAB_INTERMEDIATE: factor = 40; break;
       case SECT_MAGELAB_ADVANCED: factor = 70; break;
       default: break;
       }
       if ( HAS_KIT(ch,"enchanter") ) factor *= 2;
       fail -= factor;
   }

   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("mage")) ) 
	fail += 25;

    fail = URANGE(5,fail,HAS_KIT(ch,"enchanter") ? 75 : 85);

    result = number_percent();

    /* the moment of truth */
    if (result < (fail / 5))  /* item destroyed */
    {
  act("$p flares blindingly... and evaporates!",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p flares blindingly... and evaporates!",ch,obj,NULL,TO_ROOM,FALSE);
  extract_obj(obj);
  return;
    }

    if (result < (fail / 3)) /* item disenchanted */
    {
  AFFECT_DATA *paf_next;

  act("$p glows brightly, then fades...oops.",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows brightly, then fades.",ch,obj,NULL,TO_ROOM,FALSE);
  obj->cost = obj->cost/2;
  obj->enchanted = TRUE;

  /* remove all affects */
  for (paf = obj->affected; paf != NULL; paf = paf_next)
  {
      paf_next = paf->next; 
      affect_remove_obj( obj, paf );
  }
  obj->affected = NULL;

  /* clear all flags */
  obj->extra_flags = 0;
  return;
    }

    if ( result <= fail )  /* failed, no bad result */
    {
  send_to_char("Nothing seemed to happen.\n\r",ch);
  return;
    }

    /* okay, move all the old flags into new vectors if we have to */
    if (!obj->enchanted)
    {
  AFFECT_DATA *af_new;
  obj->enchanted = TRUE;

  for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next) 
  {
      af_new = new_affect();
  
      af_new->next = obj->affected;
      obj->affected = af_new;

      af_new->where = paf->where;
      af_new->type  = UMAX(0,paf->type);
      af_new->level = paf->level;
      af_new->duration  = paf->duration;
      af_new->location  = paf->location;
      af_new->modifier  = paf->modifier;
      af_new->bitvector = paf->bitvector;
  }
    }

    if (result <= (90 - level/5))  /* success! */
    {
  act("$p shimmers with a gold aura.",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p shimmers with a gold aura.",ch,obj,NULL,TO_ROOM,FALSE);
  SET_BIT(obj->extra_flags, ITEM_MAGIC);
  added = -1;
    }
    
    else if ( !HAS_KIT(ch,"enchanter") ||
		number_percent() > level / 4)
    {
  act("$p glows a {Ybrilliant{x gold!",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows a {Ybrilliant{x gold!",ch,obj,NULL,TO_ROOM,FALSE);
  SET_BIT(obj->extra_flags,ITEM_MAGIC);
  SET_BIT(obj->extra_flags,ITEM_GLOW);
  added = -2;
    }

    else
    {
  act("$p glows with a {YBLINDING gold{x aura!!",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows with a {YBLINDING gold{x aura!!",ch,obj,NULL,TO_ROOM,FALSE);
  SET_BIT(obj->extra_flags,ITEM_MAGIC);
  SET_BIT(obj->extra_flags,ITEM_GLOW);
  added = -4;
    }

    /* now add the enchantments */ 

    if (obj->level < LEVEL_HERO)
  obj->level = UMIN(LEVEL_HERO - 1,obj->level + 1);

    if (ac_found)
    {
  for ( paf = obj->affected; paf != NULL; paf = paf->next)
  {
      if ( paf->location == APPLY_AC)
      {
    paf->type = sn;
    paf->modifier += added;
    paf->level = UMAX(paf->level,level);
      }
  }
    }
    else /* add a new affect */
    {
  paf = new_affect();

  paf->where  = TO_OBJECT;
  paf->type = sn;
  paf->level  = level;
  paf->duration = -1;
  paf->location = APPLY_AC;
  paf->modifier =  added;
  paf->bitvector  = 0;
      paf->next = obj->affected;
      obj->affected = paf;
    }

}




void spell_enchant_weapon(int sn,int level,CHAR_DATA *ch, void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    AFFECT_DATA *paf; 
    int result, fail;
    int hit_bonus, dam_bonus, added=0;
    bool hit_found = FALSE, dam_found = FALSE;

    if (obj->item_type != ITEM_WEAPON)
    {
  send_to_char("That isn't a weapon.\n\r",ch);
  return;
    }

    if (obj->wear_loc != -1)
    {
  send_to_char("The item must be carried to be enchanted.\n\r",ch);
  return;
    }

    /* this means they have no bonus */
    hit_bonus = 0;
    dam_bonus = 0;
    fail = 25;  /* base 25% chance of failure */

    /* find the bonuses */

    if (!obj->enchanted)
    {
      for ( paf = obj->pIndexData->affected; paf != NULL; paf = paf->next )
      {
            if ( paf->location == APPLY_HITROLL )
            {
		hit_bonus = paf->modifier;
		hit_found = TRUE;
		fail += (hit_bonus * hit_bonus);
      	    }

            if (paf->location == APPLY_DAMROLL )
      	    {
        	dam_bonus = paf->modifier;
    		dam_found = TRUE;
        	fail += (dam_bonus * dam_bonus);
            }
      }
    }
    else  /* object is enchanted, a bit tougher */
    {
      for ( paf = obj->affected; paf != NULL; paf = paf->next )
      {
	if ( paf->location == APPLY_HITROLL )
	{
		hit_bonus = paf->modifier;
		hit_found = TRUE;
		fail += (hit_bonus * hit_bonus);
	}

	if (paf->location == APPLY_DAMROLL )
	{
		dam_bonus = paf->modifier;
		dam_found = TRUE;
		fail += (dam_bonus * dam_bonus);
	}

	fail += 25; /* because it's enchanted */
      }
    }

    /* apply other modifiers */
    fail -= 3 * level/2;

    if (IS_OBJ_STAT(obj,ITEM_BLESS))
  fail -= 15;
    if (IS_OBJ_STAT(obj,ITEM_GLOW))
  fail -= 5;

    if (IS_WEAPON_STAT(obj,WEAPON_FAVORED))
  fail -= 25;

    if (HAS_KIT(ch,"enchanter") )
  fail -= 30;

  /* reward good enchant skills */
  fail += ( 90 - get_skill(ch,sn) );

    if ( number_percent() < get_skill(ch,gsn_spellcraft) )
  fail -= ( get_skill(ch,gsn_spellcraft) / 10 );

   /* Magelabs */
  if(!IS_NPC(ch)&&( ch->class == class_lookup("mage") || 
                    ch->class == class_lookup("wizard") ) )
  {
	int factor = 0;

     switch( ch->in_room->sector_type )
    {
   case SECT_MAGELAB_SIMPLE: factor = 15; break;
   case SECT_MAGELAB_INTERMEDIATE: factor = 30; break;
   case SECT_MAGELAB_ADVANCED: factor = 60; break;
   default: break;
    }
    if ( HAS_KIT(ch,"enchanter") ) factor *= 2;
    fail -= factor;
  }

   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("mage")) ) 
		   fail += 20;


    fail = URANGE(5,fail,HAS_KIT(ch,"enchanter") ? 85 : 95);
   
    if( IS_IMMORTAL(ch)) fail = 0;

    result = number_percent();

    /* the moment of truth */
    if (result < (fail / 5) 
	|| (hit_found && hit_bonus > 15)
	|| (dam_found && dam_bonus > 15) 
 	|| ( IS_SET(obj->value[4],WEAPON_RESIST_ENCHANT) &&
	     number_percent() > level ) )  /* item destroyed */
    {
  act("$p shivers violently and explodes!",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p shivers violently and explodes!",ch,obj,NULL,TO_ROOM,FALSE);
  extract_obj(obj);
  return;
    }

    if (result < (fail / 2)) /* item disenchanted */
    {
  AFFECT_DATA *paf_next;

  act("$p glows brightly, then fades...oops.",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows brightly, then fades.",ch,obj,NULL,TO_ROOM,FALSE);
  obj->enchanted = TRUE;
  obj->cost = obj->cost/2;


  /* remove all affects */
  for (paf = obj->affected; paf != NULL; paf = paf_next)
  {
      paf_next = paf->next; 
      affect_remove_obj( obj, paf );
  }
  obj->affected = NULL;

  /* clear all flags */
  obj->extra_flags = 0;
  return;
    }

    if ( result <= fail )  /* failed, no bad result */
    {
  send_to_char("Nothing seemed to happen.\n\r",ch);
  return;
    }

    /* okay, move all the old flags into new vectors if we have to */
    if (!obj->enchanted)
    {
  AFFECT_DATA *af_new;
  obj->enchanted = TRUE;

  for (paf = obj->pIndexData->affected; paf != NULL; paf = paf->next) 
  {
      af_new = new_affect();
  
      af_new->next = obj->affected;
      obj->affected = af_new;

      af_new->where = paf->where;
      af_new->type  = UMAX(0,paf->type);
      af_new->level = paf->level;
      af_new->duration  = paf->duration;
      af_new->location  = paf->location;
      af_new->modifier  = paf->modifier;
      af_new->bitvector = paf->bitvector;
  }
    }

    if (result > (level/(HAS_KIT(ch,"enchanter")?5:7)) 
	|| IS_IMMORTAL(ch))  /* success! */
    {
  act("$p glows blue.",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows blue.",ch,obj,NULL,TO_ROOM,FALSE);
  SET_BIT(obj->extra_flags, ITEM_MAGIC);
  added = 1;
    }
    else
    {
     if (number_percent() < level / 5 
	&& (HAS_KIT(ch,"enchanter") && number_percent() < 40) )
     {
  act("$p glows with a {BBLINDING blue{x aura!!",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows with a {BBLINDING blue{x aura!!",ch,obj,NULL,TO_ROOM,FALSE);
  SET_BIT(obj->extra_flags,ITEM_MAGIC);
  SET_BIT(obj->extra_flags,ITEM_GLOW);
  added = 3;
     }
     else
     {
  act("$p glows a {Bbrilliant{x blue!",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows a {Bbrilliant{x blue!",ch,obj,NULL,TO_ROOM,FALSE);
  SET_BIT(obj->extra_flags,ITEM_MAGIC);
  SET_BIT(obj->extra_flags,ITEM_GLOW);
  added = 2;
     }
    }
    
    /* now add the enchantments */ 

    if (obj->level < LEVEL_HERO - 1)
  obj->level = UMIN(LEVEL_HERO - 1,obj->level + 1);

    if (dam_found)
    {
  for ( paf = obj->affected; paf != NULL; paf = paf->next)
  {
      if ( paf->location == APPLY_DAMROLL)
      {
    paf->type = sn;
    paf->modifier += added;
    paf->level = UMAX(paf->level,level);
    if (paf->modifier > 4)
        SET_BIT(obj->extra_flags,ITEM_HUM);
      }
  }
    }
    else /* add a new affect */
    {
  paf = new_affect();

  paf->where  = TO_OBJECT;
  paf->type = sn;
  paf->level  = level;
  paf->duration = -1;
  paf->location = APPLY_DAMROLL;
  paf->modifier =  added;
  paf->bitvector  = 0;
      paf->next = obj->affected;
      obj->affected = paf;
    }

    if (hit_found)
    {
        for ( paf = obj->affected; paf != NULL; paf = paf->next)
  {
            if ( paf->location == APPLY_HITROLL)
            {
    paf->type = sn;
                paf->modifier += added;
                paf->level = UMAX(paf->level,level);
                if (paf->modifier > 4)
                    SET_BIT(obj->extra_flags,ITEM_HUM);
            }
  }
    }
    else /* add a new affect */
    {
        paf = new_affect();
 
        paf->type       = sn;
        paf->level      = level;
        paf->duration   = -1;
        paf->location   = APPLY_HITROLL;
        paf->modifier   =  added;
        paf->bitvector  = 0;
        paf->next       = obj->affected;
        obj->affected   = paf;
    }

}



/*
 * Drain XP, MANA, HP.
 * Caster gains HP.
 */
void spell_energy_drain( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    if ( (victim != ch && !is_affected(ch, skill_lookup("indulgence")))  || ( victim != ch && ch->kit != kit_lookup("necromancer")) )
	{
	if(IS_EVIL(ch))
         ch->alignment = UMAX(-1000, ch->alignment - 50);
	if(IS_GOOD(ch))
	 ch->alignment = UMIN(1000, ch->alignment +50);
	if(IS_NEUTRAL(ch))
	 ch->alignment = 0;
	}

    if ( saves_spell( level, victim,DAM_NEGATIVE) )
    {
  send_to_char("You feel a momentary chill.\n\r",victim);   
  return;
    }


    if ( victim->level <= 2 )
    {
  dam    = ch->hit + 1;
    }
    else
    {
  gain_exp( victim, 0 - number_range( level/2, 3 * level / 2 ) );
  if ( !saves_spell( level, victim, DAM_NEGATIVE) )
  	victim->mana  /= 2;
  else
	victim->mana = ( 3 * victim->mana ) / 4;

  if ( !saves_spell( level, victim, DAM_NEGATIVE) )
	victim->move  /= 2; 
  else
	victim->move = ( 3 * victim->move ) / 4;

  dam    = dice(1, level);
  ch->hit   += dam;
    }

    send_to_char("You feel your life slipping away!\n\r",victim);
    send_to_char("Wow....what a rush!\n\r",ch);
    damage( ch, victim, dam, sn, DAM_NEGATIVE ,TRUE,TRUE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch  && victim->clan != ch->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_energy_drain(sn,level+2,victim,ch,target);
    }   

    return;
}



void spell_fireball( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    static const sh_int dam_each[] = 
    {
    0,
    0,   0,   0,   0,   0,    0,   0,   0,   0,   0,
    0,   0,   0,   0,  30,   35,  40,  45,  50,  55,
   60,  65,  70,  75,  80,   82,  84,  86,  88,  90,
   92,  94,  96,  98, 100,  102, 104, 106, 108, 110,
  112, 114, 116, 118, 120,  122, 124, 126, 128, 130
    };
    int dam;

    level = UMIN(level, sizeof(dam_each)/sizeof(dam_each[0]) - 1);
    level = UMAX(0, level);
    dam   = number_range( dam_each[level] / 2, dam_each[level] * 2 );
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    if ( saves_spell( level, victim, DAM_FIRE) )
  dam /= 2;
    damage( ch, victim, dam, sn, DAM_FIRE ,TRUE,TRUE);
    return;
}


void spell_fireproof(int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    AFFECT_DATA af;
 
    if (IS_OBJ_STAT(obj,ITEM_BURN_PROOF))
    {
        act("$p is already protected from burning.",ch,obj,NULL,TO_CHAR,FALSE);
        return;
    }
 
    af.where     = TO_OBJECT;
    af.type      = sn;
    af.level     = level;
    af.duration  = number_fuzzy(level / 3);
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = ITEM_BURN_PROOF;
 
    affect_to_obj(obj,&af);
 
    act("You protect $p from fire.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$p is surrounded by a protective aura.",ch,obj,NULL,TO_ROOM,FALSE);
}



void spell_flamestrike( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    dam = dice(6 + level / 2, 8);
    if ( saves_spell( level, victim,DAM_FIRE) )
  dam /= 2;
    damage( ch, victim, dam, sn, DAM_FIRE ,TRUE,TRUE);
    return;
}



void spell_faerie_fire( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_FAERIE_FIRE) || 
	 saves_spell(level+5,victim,DAM_FIRE) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }
    
    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = level;
    af.location  = APPLY_AC;
    af.modifier  = 2 * level;
    af.bitvector = AFF_FAERIE_FIRE;
    affect_to_char( victim, &af );
    send_to_char( "You are surrounded by a pink outline.\n\r", victim );
    act( "$n is surrounded by a pink outline.", victim, NULL, NULL, TO_ROOM ,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && victim->clan != ch->clan)
    {
	send_to_char( "The Almighty rebukes your attacker.\n\r", victim );
	act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
	    TO_CHAR,FALSE);
	spell_faerie_fire(sn,level+2,victim,ch,target);
    }
    return;
}



void spell_faerie_fog( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *ich;
    AFFECT_DATA af;

    if (IS_SET(ch->mhs,MHS_GLADIATOR) && 
	ch->in_room == get_room_index(ROOM_VNUM_SINGLE_GLADIATOR))
    {
	send_to_char("No casting Faerie Fog in Prep Room!\n\r",ch);
	return;
    }
    level +=2;

    act( "$n conjures a cloud of purple smoke.", ch, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "You conjure a cloud of purple smoke.\n\r", ch );

   for ( ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room )
   {
      if (ich->invis_level > 0)
         continue;

      if ( ich == ch || saves_spell( level, ich,DAM_OTHER) )
         continue;
  
      if (!is_safe_spell(ch,ich,TRUE, sn))
      {
         affect_strip ( ich, gsn_invis     );
         affect_strip ( ich, gsn_mass_invis    );
         affect_strip ( ich, gsn_sneak     );
         REMOVE_BIT   ( ich->affected_by, AFF_HIDE );
         REMOVE_BIT   ( ich->affected_by, AFF_INVISIBLE  );
         REMOVE_BIT   ( ich->affected_by, AFF_SNEAK  );
         REMOVE_BIT   ( ich->mhs, MHS_FADE ); 
         act( "$n is revealed!", ich, NULL, NULL, TO_ROOM ,FALSE);
         send_to_char( "You are revealed!\n\r", ich );

         if ( IS_AFFECTED(ich, AFF_FAERIE_FOG) )
  	    continue;

         af.where     = TO_AFFECTS;
         af.type      = sn;
         af.level   = level;
         af.duration  = level/12;
         af.location  = APPLY_NONE;
         af.modifier  = 0;
         af.bitvector = AFF_FAERIE_FOG;
         affect_to_char( ich, &af );
      } 
    }
    return;
}

void spell_famine( int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;

/*
    if ( ( victim != ch ) && IS_SET(ch->act,PLR_NOCANCEL) &&
	saves_spell(level,victim,DAM_OTHER) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }
    */

    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not famine.\n\r",ch);
       return;
    }

/* Adding in so people just dont famine others without worry */
    if( is_safe(ch,victim) && !is_same_group(ch,victim) 
        && !is_same_clan(ch,victim) && !IS_NPC(ch) 
        && (!is_clan(ch) && IS_SET (victim->act,PLR_NOCANCEL)))
    {
	send_to_char("You are not permitted to cast on them.\n\r",ch);
	return;
    }
    else
       if( is_clan(ch) && is_clan(victim) && !is_same_group(ch,victim)
           && !is_same_clan(ch,victim) )
          check_killer(ch,victim);

    if(!is_same_group(ch,victim) && ch != victim &&
        saves_spell(level,victim,DAM_OTHER))
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    gain_condition(victim,COND_HUNGER,-1 * level / 2);
    gain_condition(victim,COND_FULL,-1 * level / 2 );
    gain_condition(victim,COND_THIRST,-1 * level / 2 );

    send_to_char("You are absolutely famished!\n\r",victim);

    if ( victim != ch )
    act("$N appears to be famished!",ch,NULL,victim,TO_CHAR,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch  && victim->clan != ch->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_famine(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_feast(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;

/*
    if ( (victim != ch) && IS_SET(victim->act,PLR_NOCANCEL) &&
	 saves_spell(level,victim,DAM_OTHER) )
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }
    */

    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not feast.\n\r",ch);
       return;
    }

/* Adding in so people just dont feast others without worry */
    if( is_safe(ch,victim) && !is_same_group(ch,victim) 
        && !is_same_clan(ch,victim) && !IS_NPC(ch) 
        && (!is_clan(ch) && IS_SET (victim->act,PLR_NOCANCEL)))
    {
	send_to_char("You are not permitted to cast on them.\n\r",ch);
	return;
    }
    else
       if( is_clan(ch) && is_clan(victim) && !is_same_group(ch,victim)
           && !is_same_clan(ch,victim) )
          check_killer(ch,victim);

    if(!is_same_group(ch,victim) && ch != victim &&
        saves_spell(level,victim,DAM_OTHER))
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    gain_condition(victim,COND_HUNGER, level / 2 );
    gain_condition(victim,COND_FULL, level / 2 );
    gain_condition(victim,COND_THIRST, level / 2 );

    send_to_char("You feel nourished.\n\r",victim);

    if ( victim != ch )
    act("$N appears to be nourished.",ch,NULL,victim,TO_CHAR,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && victim->clan != ch->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_feast(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_floating_disc( int sn, int level,CHAR_DATA *ch,void *vo,int target )
{
    OBJ_DATA *disc, *floating;

    floating = get_eq_char(ch,WEAR_FLOAT);
    if (floating != NULL && IS_OBJ_STAT(floating,ITEM_NOREMOVE))
    {
  act("You can't remove $p.",ch,floating,NULL,TO_CHAR,FALSE);
  return;
    }

    disc = create_object(get_obj_index(OBJ_VNUM_DISC), 0, FALSE );
    disc->value[0]  = ch->level * 10; /* 10 pounds per level capacity */
    disc->value[3]  = ch->level * 5; /* 5 pounds per level max per item */
    disc->timer   = ch->level * 2 - number_range(0,level / 2); 

    act("$n has created a floating black disc.",ch,NULL,NULL,TO_ROOM,FALSE);
    send_to_char("You create a floating disc.\n\r",ch);
    obj_to_char(disc,ch);
    wear_obj(ch,disc,TRUE);
    return;
}


void spell_fly( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_FLYING) )
    {
    	if(reup_affect(victim,sn,level+3,level))
	{
    send_to_char( "Your feet rise off the ground.\n\r", victim );
    if ( ch != victim )
    act( "$n's feet rise off the ground.", victim, NULL, NULL, TO_ROOM ,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }
    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = level + 3;
    af.location  = 0;
    af.modifier  = 0;
    af.bitvector = AFF_FLYING;
    affect_to_char( victim, &af );
    send_to_char( "Your feet rise off the ground.\n\r", victim );
    act( "$n's feet rise off the ground.", victim, NULL, NULL, TO_ROOM ,FALSE);
    return;
}

/* RT clerical berserking spell */

void spell_frenzy(int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if (is_affected(victim,sn) || 
    ( IS_AFFECTED(victim,AFF_BERSERK) && 
      victim->race != race_lookup("dwarf") ) )
    {
  if (victim == ch)
    send_to_char("You are already in a frenzy.\n\r",ch);
  else
    act("$N is already in a frenzy.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if (is_affected(victim,skill_lookup("calm")))
    {
  if (victim == ch)
    send_to_char("Why don't you just relax for a while?\n\r",ch);
  else
    act("$N doesn't look like $e wants to fight anymore.",
        ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if ((IS_GOOD(ch) && !IS_GOOD(victim)) ||
  (IS_NEUTRAL(ch) && !IS_NEUTRAL(victim)) ||
  (IS_EVIL(ch) && !IS_EVIL(victim))
       )
    {
  act("Your god doesn't seem to like $N",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    af.where     = TO_AFFECTS;
    af.type    = sn;
    af.level   = level;
    af.duration  = level / 3;
    af.modifier  = level / 6;
    af.bitvector = 0;

    af.location  = APPLY_HITROLL;
    affect_to_char(victim,&af);

    af.location  = APPLY_DAMROLL;
    affect_to_char(victim,&af);

    af.modifier  = 10 * (level / 12);
    af.location  = APPLY_AC;
    affect_to_char(victim,&af);

    send_to_char("You are filled with holy wrath!\n\r",victim);
    act("$n gets a wild look in $s eyes!",victim,NULL,NULL,TO_ROOM,FALSE);
}

/* RT ROM-style gate */
    
void spell_gate( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim;
    bool gate_pet;
    CHAR_DATA *fch=NULL;
    CHAR_DATA *fch_next;
    bool fHighlander = FALSE;

    if ( is_affected(ch,gsn_trap) )                                             
    {                                                                           
        send_to_char("You are held fast by a snare trap.\n\r",ch);              
        return;                                                                 
    }  

  if( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL)
  {
    send_to_char("Your master didn't tell you to do that.\n\r",ch);
    return;
  }


    if ( ( victim = get_char_world( ch, target_name ) ) == NULL
    ||   victim == ch
    ||   victim->in_room == NULL
    ||   !can_see_room(ch,victim->in_room)
    ||	 !is_room_clan(ch,victim->in_room)
    ||   IS_SET(victim->in_room->room_flags, ROOM_SAFE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)
    ||   IS_SET(victim->in_room->room_flags, ROOM_NO_RECALL)
    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
    ||   (victim->level >= ch->level + 3 && !is_same_clan(ch,victim) && !is_same_group(ch,victim))
    ||   (is_clan(victim) && !is_same_clan(ch,victim) && !is_same_group(ch,victim))
    ||   (!is_clan(victim) && is_clan(ch) && IS_SET(victim->act,PLR_NOSUMMON) )
    ||   (!IS_NPC(victim) && victim->level > LEVEL_HERO)  /* NOT trust */ 
    ||   (IS_NPC(victim) && IS_SET(victim->imm_flags,IMM_SUMMON))
    ||	 (IS_NPC(victim) && 
          (IS_SET(victim->affected_by,AFF_CHARM) && victim->leader != ch))
    ||   (IS_NPC(victim) && saves_spell( level, victim,DAM_OTHER) ) 
    ||   (!is_room_owner(ch,victim->in_room) && room_is_private(ch,victim->in_room) ) 
    ||  victim->in_room->area->under_develop 
    ||  victim->in_room->area->no_transport 
    ||  ch->in_room->area->no_transport )
    {
        send_to_char( "You failed.\n\r", ch );
        return;
    } 
    if (ch->pet != NULL && ch->in_room == ch->pet->in_room)
  gate_pet = TRUE;
    else
  gate_pet = FALSE;
    
    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not gate.\n\r",ch);
       return;
    }

    act("$n steps through a gate and vanishes.",ch,NULL,NULL,TO_ROOM,FALSE);
    send_to_char("You step through a gate and vanish.\n\r",ch);

    if (IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
      for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
      {
         fch_next = fch->next_in_room;
         if (IS_SET(fch->mhs,MHS_HIGHLANDER) && fch != ch)
         {
	    fHighlander = TRUE;
	    send_to_char("The tingle in your neck stops and the presence of the other Highlander is gone.\n\r",fch);
	 }
      }
    }

    /*Ogre's Smell Remorts Leaving The Room */
    if (!IS_NPC(ch) && (IS_SET(ch->act,PLR_VAMP) ||
	                IS_SET(ch->act,PLR_MUMMY) ||
	                IS_SET(ch->act,PLR_WERE) ) )  
    {
       for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
       {
	  fch_next = fch->next_in_room;
	  if (fch->race == race_lookup("ogre") && fch != ch ) 
	  {
	     if (number_percent() < (fch->level + get_curr_stat(fch,STAT_CON))) 
	     {
	        if(IS_SET(ch->act,PLR_VAMP))
	           send_to_char("The strange odor of blood is gone.\n\r",fch);
	        if(IS_SET(ch->act,PLR_WERE))
	           send_to_char("The scent of decay is gone.\n\r",fch);
	        if(IS_SET(ch->act,PLR_MUMMY))
	           send_to_char("The smell of filthy fur is gone.\n\r",fch);
	     }
	  }
       }
    }

    char_from_room(ch);
    clear_mount(ch);
    char_to_room(ch,victim->in_room);
    act("$n has arrived through a gate.",ch,NULL,NULL,TO_ROOM,FALSE);
    do_look(ch,"auto");

    if (IS_SET(ch->mhs,MHS_HIGHLANDER) && fch != NULL)
    {
       if (fHighlander)
       {
	  send_to_char("The tingle in your neck stops and the presence of the other Highlander is gone.\n\r",fch);
	  fHighlander = FALSE;
       } 
       for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
       {
          fch_next = fch->next_in_room;
	  if (IS_SET(fch->mhs,MHS_HIGHLANDER) && fch != ch)
	  {
             send_to_char("Your neck tingles as you feel the presence of another Highlander.\n\r",fch);
	     fHighlander = TRUE;
          }
       }
       if (fHighlander)
       {
	  send_to_char("Your neck tingles as you feel the presence of another Highlander.\n\r",fch);
       }
    }

    /*Ogre's Smell Remorts Entering The Room */
    if (!IS_NPC(ch) && (IS_SET(ch->act,PLR_VAMP) ||
	                IS_SET(ch->act,PLR_MUMMY) ||
	                IS_SET(ch->act,PLR_WERE) ) )  
    {
       for (fch = ch->in_room->people; fch != NULL; fch = fch_next)
       {
	  fch_next = fch->next_in_room;
          if (fch->race == race_lookup("ogre") && fch != ch) 
          {
	     if (number_percent() < (fch->level + get_curr_stat(fch,STAT_CON))) 
	     {
                if(IS_SET(ch->act,PLR_VAMP))
                   send_to_char("The strange odor of blood makes you feel uncomfortable.\n\r",fch);
                if(IS_SET(ch->act,PLR_WERE))
                   send_to_char("The scent of decay makes your head dizzy.\n\r",fch);
                if(IS_SET(ch->act,PLR_MUMMY))
                   send_to_char("The smell of filthy fur fills up the air.\n\r",fch);
	     }
          }
       }
    }

    if (gate_pet)
    {
  act("$n steps through a gate and vanishes.",ch->pet,NULL,NULL,TO_ROOM,FALSE);
  send_to_char("You step through a gate and vanish.\n\r",ch->pet);
  char_from_room(ch->pet);
  clear_mount(ch->pet);
  char_to_room(ch->pet,victim->in_room);
  act("$n has arrived through a gate.",ch->pet,NULL,NULL,TO_ROOM,FALSE);
  do_look(ch->pet,"auto");
    }
}



void spell_giant_strength(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
	reup_affect(victim,sn,level,level);
	send_to_char( "Your muscles surge with heightened power!\n\r", victim );
	act("$n's muscles surge with heightened power.",victim,NULL,NULL,TO_ROOM,FALSE);
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = level;
    af.location  = APPLY_STR;
    af.modifier  = 1 + (level >= 18) + (level >= 25) + (level >= 32);
    af.bitvector = 0;
    affect_to_char( victim, &af );
    send_to_char( "Your muscles surge with heightened power!\n\r", victim );
    act("$n's muscles surge with heightened power.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}



void spell_harm( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

       dam = dice( level, 12);

    if ( saves_spell( level, victim, DAM_HARM ) )
  dam /= 2;
    damage( ch, victim, dam, sn,DAM_HARM,TRUE,TRUE);
    return;
}

/* RT haste spell */

void spell_haste( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim, gsn_hamstring) )
    {
	act("Your spell failed!",ch,NULL,NULL,TO_CHAR,FALSE);
	return;
    }
 
    if( IS_SET(victim->off_flags,OFF_FAST) || is_affected(victim, skill_lookup("speed")))
    {
  if (victim == ch)
    send_to_char("You can't move any faster!\n\r",ch);
  else
    act("$N is already moving as fast as $e can.",
        ch,NULL,victim,TO_CHAR,FALSE);
        return;
    }

    if ( IS_AFFECTED(victim,AFF_HASTE))
    {
	if(reup_affect(victim,sn,level/3,level))
	{
    send_to_char( "You feel yourself moving more quickly.\n\r", victim );
    act("$n is moving more quickly.",victim,NULL,NULL,TO_ROOM,FALSE);
    if ( ch != victim )
        send_to_char( "Ok.\n\r", ch );
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }


    if (IS_AFFECTED(victim,AFF_SLOW))
    {
  if (!check_dispel(level,victim,skill_lookup("slow")))
  {
      if (victim != ch)
          send_to_char("Spell failed.\n\r",ch);
      send_to_char("You feel momentarily faster.\n\r",victim);
      return;
  }
        act("$n is moving less slowly.",victim,NULL,NULL,TO_ROOM,FALSE);
        return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    if (victim == ch)
      af.duration  = level/2;
    else
      af.duration  = level/4;
    af.location  = APPLY_DEX;
    af.modifier  = 1 + (level >= 18) + (level >= 25) + (level >= 32);
    af.bitvector = AFF_HASTE;
    affect_to_char( victim, &af );
    send_to_char( "You feel yourself moving more quickly.\n\r", victim );
    act("$n is moving more quickly.",victim,NULL,NULL,TO_ROOM,FALSE);
    if ( ch != victim )
        send_to_char( "Ok.\n\r", ch );
    return;
}



void spell_heal( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    int healed;
    CHAR_DATA *victim = (CHAR_DATA *) vo;

    healed = 100;
    if ( ch->race == race_lookup("volare") )
	healed = 3 * healed / 2;

    if ( !IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("cleric") &&
		       ch->pcdata->old_class != class_lookup("elementalist")))
	healed -= ( healed / 5 );

    victim->hit = UMIN( victim->hit + healed, victim->max_hit );
    update_pos( victim );
    send_to_char( "A warm feeling fills your body.\n\r", victim );
    if ( ch != victim )
  send_to_char( "Ok.\n\r", ch );
    return;
}

void spell_heat_metal( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    OBJ_DATA *obj_lose, *obj_next;
    int dam = 0;
    bool fail = TRUE;

    if (IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_NPC(victim))
    {
       send_to_char("Highlanders are immune to that.\n\r",ch);
       return;
    }
 
   if (!saves_spell(level + 2,victim,DAM_FIRE) 
   &&  !IS_SET(victim->imm_flags,IMM_FIRE))
   {
        for ( obj_lose = victim->carrying;
        obj_lose != NULL; 
        obj_lose = obj_next)
        {
      obj_next = obj_lose->next_content;
            if ( number_range(1,2 * level) > obj_lose->level 
      &&   !saves_spell(level,victim,DAM_FIRE)
      &&   !IS_OBJ_STAT(obj_lose,ITEM_NONMETAL)
      &&   !IS_OBJ_STAT(obj_lose,ITEM_BURN_PROOF))
            {
                switch ( obj_lose->item_type )
                {
                case ITEM_ARMOR:
    if (obj_lose->wear_loc != -1) /* remove the item */
    {
        if (can_drop_obj(victim,obj_lose)
        &&  (obj_lose->weight / 10) < 
      number_range(1,2 * get_curr_stat(victim,STAT_DEX))
        &&  remove_obj( victim, obj_lose->wear_loc, TRUE ))
        {
            act("$n yelps and throws $p to the ground!",
          victim,obj_lose,NULL,TO_ROOM,FALSE);
            act("You remove and drop $p before it burns you.",
          victim,obj_lose,NULL,TO_CHAR,FALSE);
      dam += (number_range(1,obj_lose->level) / 3);
                        obj_from_char(obj_lose);
			if(!IS_NPC(victim) && IS_SET(victim->mhs,MHS_GLADIATOR))
                           obj_to_char( obj_lose, victim ); 
			else
                           obj_to_room(obj_lose, victim->in_room);
			   obj_lose->stolen_timer += 10 * number_fuzzy(5);
                        fail = FALSE;
                    }
        else /* stuck on the body! ouch! */
        {
      act("Your skin is seared by $p!",
          victim,obj_lose,NULL,TO_CHAR,FALSE);
      dam += (number_range(1,obj_lose->level));
      fail = FALSE;
        }

    }
    else /* drop it if we can */
    {
        if (can_drop_obj(victim,obj_lose))
        {
                        act("$n yelps and throws $p to the ground!",
                            victim,obj_lose,NULL,TO_ROOM,FALSE);
                        act("You and drop $p before it burns you.",
                            victim,obj_lose,NULL,TO_CHAR,FALSE);
                        dam += (number_range(1,obj_lose->level) / 6);
                        obj_from_char(obj_lose);
			if(!IS_NPC(victim) && IS_SET(victim->mhs,MHS_GLADIATOR))
                           obj_to_char( obj_lose, victim ); 
			else
                           obj_to_room(obj_lose, victim->in_room);
			   obj_lose->stolen_timer += 10 * number_fuzzy(5);
      fail = FALSE;
                    }
        else /* cannot drop */
        {
                        act("Your skin is seared by $p!",
                            victim,obj_lose,NULL,TO_CHAR,FALSE);
                        dam += (number_range(1,obj_lose->level) / 2);
      fail = FALSE;
                    }
    }
                break;
                case ITEM_WEAPON:
    if (obj_lose->wear_loc != -1) /* try to drop it */
    {
        if (IS_WEAPON_STAT(obj_lose,WEAPON_FLAMING))
      continue;

        if (can_drop_obj(victim,obj_lose) 
        &&  remove_obj(victim,obj_lose->wear_loc,TRUE))
        {
      act("$n is burned by $p, and throws it to the ground.",
          victim,obj_lose,NULL,TO_ROOM,FALSE);
      send_to_char(
          "You throw your red-hot weapon to the ground!\n\r",
          victim);
      dam += 1;
      obj_from_char(obj_lose);
      if(!IS_NPC(victim) && IS_SET(victim->mhs,MHS_GLADIATOR))
         obj_to_char( obj_lose, victim ); 
      else
         obj_to_room(obj_lose,victim->in_room);
	 obj_lose->stolen_timer += 10 * number_fuzzy(5);
      fail = FALSE;
        }
        else /* YOWCH! */
        {
      send_to_char("Your weapon sears your flesh!\n\r",
          victim);
      dam += number_range(1,obj_lose->level);
      fail = FALSE;
        }
    }
                else /* drop it if we can */
                {
                    if (can_drop_obj(victim,obj_lose))
                    {
                        act("$n throws a burning hot $p to the ground!",
                            victim,obj_lose,NULL,TO_ROOM,FALSE);
                        act("You and drop $p before it burns you.",
                            victim,obj_lose,NULL,TO_CHAR,FALSE);
                        dam += (number_range(1,obj_lose->level) / 6);
                        obj_from_char(obj_lose);
                        if(!IS_NPC(victim) && IS_SET(victim->mhs,MHS_GLADIATOR))
                           obj_to_char( obj_lose, victim ); 
                        else
                           obj_to_room(obj_lose, victim->in_room);
			   obj_lose->stolen_timer += 10 * number_fuzzy(5);
                        fail = FALSE;
                    }
                    else /* cannot drop */
                    {
                        act("Your skin is seared by $p!",
                            victim,obj_lose,NULL,TO_CHAR,FALSE);
                        dam += (number_range(1,obj_lose->level) / 2);
                        fail = FALSE;
                    }
                }
                break;
    }
      }
  }
    } 
    if (fail)
    {
        send_to_char("Your spell had no effect.\n\r", ch);
  send_to_char("You feel momentarily warmer.\n\r",victim);
    }
    else /* damage! */
    {
  if (saves_spell(level,victim,DAM_FIRE))
      dam = 2 * dam / 3;
  damage(ch,victim,dam,sn,DAM_FIRE,TRUE,TRUE);
    }

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_heat_metal(sn,level+2,victim,ch,target);
    }   

    return;
}

/* RT really nasty high-level attack spell */
void spell_holy_word(int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *vch;
    CHAR_DATA *vch_next;
    int dam;
    int bless_num, curse_num, frenzy_num;
   
    bless_num = skill_lookup("bless");
    curse_num = skill_lookup("curse"); 
    frenzy_num = skill_lookup("frenzy");

    act("$n utters a word of divine power!",ch,NULL,NULL,TO_ROOM,FALSE);
    send_to_char("You utter a word of divine power.\n\r",ch);
 
    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
    {
        vch_next = vch->next_in_room;

  if ((IS_GOOD(ch) && IS_GOOD(vch)) ||
      (IS_EVIL(ch) && IS_EVIL(vch)) ||
      (IS_NEUTRAL(ch) && IS_NEUTRAL(vch)) )
  {
    send_to_char("You feel fully more powerful.\n\r",vch);
    spell_frenzy(frenzy_num,level,ch,(void *) vch,TARGET_CHAR); 
    spell_bless(bless_num,level,ch,(void *) vch,TARGET_CHAR);
  }

  else if ((IS_GOOD(ch) && IS_EVIL(vch)) ||
     (IS_EVIL(ch) && IS_GOOD(vch)) )
  {
    if (!is_safe_spell(ch,vch,TRUE, sn))
    {
            spell_curse(curse_num,level,ch,(void *) vch,TARGET_CHAR);
      send_to_char("You are struck down!\n\r",vch);
      dam = dice(level,6);
      damage(ch,vch,dam,sn,DAM_ENERGY,TRUE,TRUE);
    }
  }

        else if (IS_NEUTRAL(ch))
  {
    if (!is_safe_spell(ch,vch,TRUE, sn))
    {
            spell_curse(curse_num,level/2,ch,(void *) vch,TARGET_CHAR);
      send_to_char("You are struck down!\n\r",vch);
      dam = dice(level,4);
      damage(ch,vch,dam,sn,DAM_ENERGY,TRUE,TRUE);
      }
  }
    }  
    
    send_to_char("You feel drained.\n\r",ch);
    ch->move = 0;
    ch->hit /= 2;
}
 
void spell_identify( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    char buf[MAX_STRING_LENGTH];
    AFFECT_DATA *paf;
    //float num;
    bool stop_looping;
    bool already_did_enchant;
    already_did_enchant = FALSE;
    stop_looping = FALSE;
    sprintf( buf,
  "Object '%s' is type %s.\n\rWeight is %d.%d, value is %d, level is %d.\n\r",

  obj->name,
  item_type_name( obj ),
  obj->weight / 10, obj->weight % 10,
  obj->cost,
  obj->level
  );
    send_to_char( buf, ch );

    if( obj->pIndexData->new_format )
    {
     sprintf( buf, "Made of: %s", obj->material);
     send_to_char( buf, ch );
	if (obj->item_type == ITEM_ARMOR && obj->value[4] <= MAX_OBJ_SIZE)
	  sprintf( buf, ", Size: %s\n\r", obj_size_table[obj->value[4]].name);
	else
	  sprintf( buf, "\n\r");
     send_to_char( buf, ch );
    }

    
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    {
       sprintf( buf, "Extra Flags %s.\n\r", extra_bit_name(obj->extra_flags));
       send_to_char( buf, ch);
    }
     

    switch ( obj->item_type )
    {
    case ITEM_SCROLL: 
    case ITEM_POTION:
    case ITEM_PILL:
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    {
  sprintf( buf, "Level %d spells of:", obj->value[0] );
      send_to_char ("Contains the following spells:\r\n",ch);


  if ( obj->value[1] >= 0 && obj->value[1] < MAX_SKILL )
  {
      send_to_char( " '", ch );
      /*send_to_char( skill_table[obj->value[1]].name, ch );*/
      write_spell(ch,obj->value[1]);
      send_to_char( "'", ch );
  }

  if ( obj->value[2] >= 0 && obj->value[2] < MAX_SKILL )
  {
      send_to_char( " '", ch );
      /*send_to_char( skill_table[obj->value[2]].name, ch );*/
      write_spell(ch,obj->value[2]);
      send_to_char( "'", ch );
  }

  if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL )
  {
      send_to_char( " '", ch );
      /*send_to_char( skill_table[obj->value[3]].name, ch );*/
      write_spell(ch,obj->value[3]);
      send_to_char( "'", ch );
  }

  send_to_char( ".\n\r", ch );
    }
	break;
	    /* Here's the origional section below
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    {
  sprintf( buf, "Level %d spells of:", obj->value[0] );
  send_to_char( buf, ch );

  if ( obj->value[1] >= 0 && obj->value[1] < MAX_SKILL )
  {
      send_to_char( " '", ch );
      send_to_char( skill_table[obj->value[1]].name, ch );
      send_to_char( "'", ch );
  }

  if ( obj->value[2] >= 0 && obj->value[2] < MAX_SKILL )
  {
      send_to_char( " '", ch );
      send_to_char( skill_table[obj->value[2]].name, ch );
      send_to_char( "'", ch );
  }

  if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL )
  {
      send_to_char( " '", ch );
      send_to_char( skill_table[obj->value[3]].name, ch );
      send_to_char( "'", ch );
  }

  send_to_char( ".\n\r", ch );
    }
  break;
*/

    case ITEM_WAND: 
    case ITEM_STAFF: 
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    { 
  sprintf( buf, "Has %d charges of ",
      obj->value[2]);
  send_to_char( buf, ch );
      
  if ( obj->value[3] >= 0 && obj->value[3] < MAX_SKILL )
  {
      send_to_char( " '", ch );
      write_spell(ch,obj->value[3]);
     /* send_to_char( skill_table[obj->value[3]].name, ch );*/
      send_to_char( "'", ch );
  }

  send_to_char( ".\n\r", ch );
    }
  break;

    case ITEM_SPELL_PAGE:
  /*
	sprintf(buf,"It is a page containing the spell '%s'.\n\r",
	    skill_table[obj->value[2]].name );
	send_to_char(buf,ch);
	*/
 	if ( obj->value[1] <= 25 )
	    sprintf(buf,"This page is trivial to copy.");
	else
	if ( obj->value[1] <= 50 )
	    sprintf(buf,"This is of moderate complexity.");
	else
	if ( obj->value[1] <= 75 )
	    sprintf(buf,"This page is somewhat difficult to copy.");
	else
	if ( obj->value[1] <= 100 )
	    sprintf(buf,"This page is fairly challenging to copy.");
	else
	    sprintf(buf,"This page is very difficult to copy.");
	send_to_char(buf,ch); send_to_char("\n\r",ch);
	/*
	if ( obj->value[3] < 0 )
	    sprintf(buf,"This spell can be copied without limit.\n\r");
	else
	    sprintf(buf,"This spell can be copied %d time%s.\n\r",
		obj->value[3], obj->value[3] == 1 ? "" : "s" );
	send_to_char(buf,ch);
	*/
	break;
    case ITEM_DRINK_CON:
        sprintf(buf,"It holds %s-colored %s.\n\r",
            liq_table[obj->value[2]].liq_color,
            liq_table[obj->value[2]].liq_name);
        send_to_char(buf,ch);
        break;

    case ITEM_CONTAINER:
	//
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    {
  sprintf(buf,"Capacity: %d#  Maximum weight: %d#  flags: %s\n\r",
      obj->value[0], obj->value[3], cont_bit_name(obj->value[1]));
  send_to_char(buf,ch);
  if (obj->value[4] != 100)
  {
      sprintf(buf,"Weight multiplier: %d%%\n\r",
      obj->value[4]);
      send_to_char(buf,ch);
  }
    }
    //
  break;
    
    case ITEM_WEAPON:
  send_to_char("Weapon type is ",ch);
  switch (obj->value[0])
  {
      case(WEAPON_EXOTIC) : send_to_char("exotic.\n\r",ch); break;
      case(WEAPON_SWORD)  : send_to_char("sword.\n\r",ch);  break;  
      case(WEAPON_DAGGER) : send_to_char("dagger.\n\r",ch); break;
      case(WEAPON_SPEAR)  : send_to_char("spear/staff.\n\r",ch);  break;
      case(WEAPON_MACE)   : send_to_char("mace/club.\n\r",ch);  break;
      case(WEAPON_AXE)  : send_to_char("axe.\n\r",ch);    break;
      case(WEAPON_FLAIL)  : send_to_char("flail.\n\r",ch);  break;
      case(WEAPON_WHIP) : send_to_char("whip.\n\r",ch);   break;
      case(WEAPON_POLEARM): send_to_char("polearm.\n\r",ch);  break;
      case(WEAPON_GAROTTE): send_to_char("garotte.\n\r",ch);  break;
      default   : send_to_char("unknown.\n\r",ch);  break;
  }
  //
  if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
  {
    if (obj->pIndexData->new_format)
    {
      sprintf(buf,"Damage is %dd%d (average %d).\n\r",
       obj->value[1],obj->value[2],
       ((1 + obj->value[2]) * obj->value[1] / 2));
    }
    else
    {
      sprintf( buf, "Damage is %d to %d (average %d).\n\r",
        obj->value[1], obj->value[2],
        ( (obj->value[1] + obj->value[2] ) / 2) );
    }
  send_to_char( buf, ch );
     //
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    {
        if (obj->value[4])  // weapon flags
        {
            sprintf(buf,"Weapons flags: %s\n\r",weapon_bit_name(obj->value[4]));
            send_to_char(buf,ch);
        }
    }
  } 
  break;

    case ITEM_ARMOR:
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    {
      sprintf( buf, 
       "Armor class is %d pierce, %d bash, %d slash, and %d vs. magic.\n\r", 
        (obj->value[0]), (obj->value[1]), (obj->value[2]), (obj->value[3]) );
      send_to_char( buf, ch );
    }
    
  break;
    }

    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    {
    if (!obj->enchanted)
    for ( paf = obj->pIndexData->affected; paf != NULL; paf = paf->next )
    {
      if ( paf->location != APPLY_NONE && paf->modifier != 0 )
      {
        if ( stop_looping == TRUE)
        {
          break;
        }
//COREY TEST THIS BREAK
    //break;
		 
        sprintf( buf, "Affects %s by %d.\n\r",
         affect_loc_name( paf->location ), (paf->modifier) );
        send_to_char(buf,ch);
        if (paf->bitvector)
        {
          switch(paf->where)
          {
                    case TO_AFFECTS:
                        sprintf(buf,"Adds %s affect.\n",
                            affect_bit_name(paf->bitvector));
                        break;
                    case TO_OBJECT:
                        sprintf(buf,"Adds %s object flag.\n",
                            extra_bit_name(paf->bitvector));
                        break;
                    case TO_IMMUNE:
                        sprintf(buf,"Adds immunity to %s.\n",
                            imm_bit_name(paf->bitvector));
                        break;
                    case TO_RESIST:
                        sprintf(buf,"Adds resistance to %s.\n\r",
                            imm_bit_name(paf->bitvector));
                        break;
                    case TO_VULN:
                        sprintf(buf,"Adds vulnerability to %s.\n\r",
                            imm_bit_name(paf->bitvector));
                        break;
                    default:
                        sprintf(buf,"Unknown bit %d: %ld\n\r",
                            paf->where,paf->bitvector);
                        break;
                }
          send_to_char( buf, ch );
      }
//
  }
    }
stop_looping = FALSE;

    for ( paf = obj->affected; paf != NULL; paf = paf->next )
    {
  if ( paf->location != APPLY_NONE && paf->modifier != 0 )
  {
  if (already_did_enchant == FALSE)
  {
    if(paf->location == APPLY_HITROLL || paf->location == APPLY_DAMROLL)
    {
     int Nench = number_fuzzy(paf->modifier);

      strcpy(buf,"Magically enchanted: ");
      if ( Nench >= 14 )
      { strcat(buf,"perfectly\n\r"); }
      else if( Nench >= 11 )
      { strcat(buf,"well\n\r"); }
      else if( Nench >= 8 )
      { strcat(buf,"good\n\r"); }
      else if( Nench >= 5 )
      { strcat(buf,"fairly\n\r"); }
      else if( Nench > 2 )
      { strcat(buf,"some\n\r"); }
      else
      { strcat(buf,"a bit\n\r"); }
      send_to_char(buf,ch);
      already_did_enchant = TRUE;
    } else {
      send_to_char("Magically enhanced.\n\r",ch);
      already_did_enchant = TRUE;
    }
  } //end of already did enchant
if ( stop_looping == TRUE)
{
break;
}
//  break;
//#ifdef COREY_TAKEOUT_SO_OTHER_AFFECTS_SHOW
      sprintf( buf, "Affects %s by %d",
        affect_loc_name( paf->location ), (paf->modifier) );
      send_to_char( buf, ch );
            if ( paf->duration > -1)
                sprintf(buf,", %d hours.\n\r",(paf->duration));
            else
                sprintf(buf,".\n\r");
      send_to_char(buf,ch);
            if (paf->bitvector)
            {
                switch(paf->where)
                {
                    case TO_AFFECTS:
                        sprintf(buf,"Adds %s affect.\n",
                            affect_bit_name(paf->bitvector));
                        break;
                    case TO_OBJECT:
                        sprintf(buf,"Adds %s object flag.\n",
                            extra_bit_name(paf->bitvector));
                        break;
        case TO_WEAPON:
      sprintf(buf,"Adds %s weapon flags.\n",
          weapon_bit_name(paf->bitvector));
      break;
                    case TO_IMMUNE:
                        sprintf(buf,"Adds immunity to %s.\n",
                            imm_bit_name(paf->bitvector));
                        break;
                    case TO_RESIST:
                        sprintf(buf,"Adds resistance to %s.\n\r",
                            imm_bit_name(paf->bitvector));
                        break;
                    case TO_VULN:
                        sprintf(buf,"Adds vulnerability to %s.\n\r",
                            imm_bit_name(paf->bitvector));
                        break;
                    default:
                        sprintf(buf,"Unknown bit %d: %ld\n\r",
                            paf->where,paf->bitvector);
                        break;
                }
                send_to_char(buf,ch);
            }
//#endif
  }
    }
    }

    if( IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
       send_to_char("Your scrying is unable to attain more information.\n\r",ch);
    return;
}



void spell_infravision( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_INFRARED) )
    {
    	if(reup_affect(victim,sn,level*2,level))
	{
    send_to_char( "Your eyes glow red.\n\r", victim );
    act( "$n's eyes glow red.\n\r", victim, NULL, NULL, TO_ROOM ,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}

  return;
    }

    act( "$n's eyes glow red.\n\r", victim, NULL, NULL, TO_ROOM ,FALSE);

    af.where   = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = 2 * level;
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_INFRARED;
    affect_to_char( victim, &af );
    send_to_char( "Your eyes glow red.\n\r", victim );
    return;
}



void spell_invis( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    AFFECT_DATA af;

    /* object invisibility */
    if (target == TARGET_OBJ)
    {
  obj = (OBJ_DATA *) vo;  

  if (IS_OBJ_STAT(obj,ITEM_INVIS))
  {
      act("$p is already invisible.",ch,obj,NULL,TO_CHAR,FALSE);
      return;
  }
  
  af.where  = TO_OBJECT;
  af.type   = sn;
  af.level  = level;
  af.duration = level + 12;
  af.location = APPLY_NONE;
  af.modifier = 0;
  af.bitvector  = ITEM_INVIS;
  affect_to_obj(obj,&af);

  act("$p fades out of sight.",ch,obj,NULL,TO_ALL,FALSE);
  return;
    }

    /* character invisibility */
    victim = (CHAR_DATA *) vo;

    if ( IS_AFFECTED(victim, AFF_INVISIBLE) )
    {
	if(reup_affect(victim,sn,level+12,level))
	{
    send_to_char( "You fade out of existence.\n\r", victim );
    if ( ch != victim )
    act( "$n fades out of existence.", victim, NULL, NULL, TO_ROOM ,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    if ( IS_AFFECTED(victim,AFF_FAERIE_FOG) ) {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    act( "$n fades out of existence.", victim, NULL, NULL, TO_ROOM ,FALSE);

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = level + 12;
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_INVISIBLE;
    affect_to_char( victim, &af );
    send_to_char( "You fade out of existence.\n\r", victim );
    return;
}



void spell_know_alignment(int sn,int level,CHAR_DATA *ch,void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    char *msg;
    int ap;

    ap = victim->alignment;

         if ( ap >  700 ) msg = "$N has a pure and good aura.";
    else if ( ap >  350 ) msg = "$N is of excellent moral character.";
    else if ( ap >  100 ) msg = "$N is often kind and thoughtful.";
    else if ( ap > -100 ) msg = "$N doesn't have a firm moral commitment.";
    else if ( ap > -350 ) msg = "$N lies to $S friends.";
    else if ( ap > -700 ) msg = "$N is a black-hearted murderer.";
    else msg = "$N is the embodiment of pure evil!.";

    act( msg, ch, NULL, victim, TO_CHAR ,FALSE);
    return;
}



void spell_lightning_bolt(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    static const sh_int dam_each[] = 
    {
   0,
   0,  0,  0,  0,  0,  0,  0,  0, 25, 28,
  31, 34, 37, 40, 40, 41, 42, 42, 43, 44,
  44, 45, 46, 46, 47, 48, 48, 49, 50, 50,
  51, 52, 52, 53, 54, 54, 55, 56, 56, 57,
  58, 58, 59, 60, 60, 61, 62, 62, 63, 64
    };
    int dam;

    level = UMIN(level, sizeof(dam_each)/sizeof(dam_each[0]) - 1);
    level = UMAX(0, level);
    dam   = number_range( dam_each[level] / 2, dam_each[level] * 2 );
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    if ( saves_spell( level, victim,DAM_LIGHTNING) )
  dam /= 2;

    if ( level == 1 )
    { 
	sprintf(log_buf,"%s casting lightning bolt",ch->name);
	log_string(log_buf);
    }

    damage( ch, victim, dam, sn, DAM_LIGHTNING ,TRUE,TRUE);
    return;
}



void spell_locate_object( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    char buf[MAX_INPUT_LENGTH];
    BUFFER *buffer;
    OBJ_DATA *obj;
    OBJ_DATA *in_obj;
    bool found;
    int number = 0, max_found;

    found = FALSE;
    number = 0;
    max_found = IS_IMMORTAL(ch) ? 200 : 2 * level;

    buffer = new_buf();
 
    for ( obj = object_list; obj != NULL; obj = obj->next )
    {
  if ( !can_see_obj( ch, obj ) || !is_name( target_name, obj->name ) 
      ||   IS_OBJ_STAT(obj,ITEM_NOLOCATE) || number_percent() > 2 * level
  ||   ch->level < obj->level)
      continue;

  found = TRUE;
        number++;

  for ( in_obj = obj; in_obj->in_obj != NULL; in_obj = in_obj->in_obj )
      ;

  if ( in_obj->carried_by != NULL && can_see(ch,in_obj->carried_by,FALSE))
  {
      sprintf( buf, "one is carried by %s\n\r",
    PERS(in_obj->carried_by, ch, FALSE) );
  }
  else
  {
      if (IS_IMMORTAL(ch) && in_obj->in_room != NULL)
    sprintf( buf, "one is in %s [Room %d]\n\r",
        in_obj->in_room->name, in_obj->in_room->vnum);
      else 
        sprintf( buf, "one is in %s\n\r",
        in_obj->in_room == NULL
          ? "somewhere" : in_obj->in_room->name );
  }

  buf[0] = UPPER(buf[0]);
  add_buf(buffer,buf);

      if (number >= max_found)
      break;
    }

    if ( !found )
  send_to_char( "Nothing like that in heaven or earth.\n\r", ch );
    else
  page_to_char(buf_string(buffer),ch);

    free_buf(buffer);

    return;
}



void spell_magic_missile( int sn, int level, CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    static const sh_int dam_each[] = 
    {
   0,
   3,  3,  4,  4,  5,  6,  6,  6,  6,  6,
   7,  7,  7,  7,  7,  8,  8,  8,  8,  8,
   9,  9,  9,  9,  9, 10, 10, 10, 10, 10,
  11, 11, 11, 11, 11, 12, 12, 12, 12, 12,
  13, 13, 13, 13, 13, 14, 14, 14, 14, 14
    };
    int dam;
    int num_missiles, i;

    num_missiles = dice(1,4) + ch->level / 12; 

    level = UMIN(level, sizeof(dam_each)/sizeof(dam_each[0]) - 1);
    level = UMAX(0, level);
    
    for ( i = 0 ; i < num_missiles ; i++ )
    {
    dam   = number_range( dam_each[level] / 2, dam_each[level] * 2 );
    damage( ch, victim, dam, sn, DAM_ENERGY ,TRUE,TRUE);
    if ( victim == NULL || victim->position <= POS_STUNNED || ch->fighting == NULL )
	return;
    }

    return;
}

void spell_mass_healing(int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *gch;
    int heal_num, refresh_num;
    
    heal_num = skill_lookup("heal");
    refresh_num = skill_lookup("refresh"); 

    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
    {
  if ((IS_NPC(ch) && IS_NPC(gch)) ||
      (!IS_NPC(ch) && !IS_NPC(gch)))
  {
      spell_heal(heal_num,level,ch,(void *) gch,TARGET_CHAR);
      spell_refresh(refresh_num,level,ch,(void *) gch,TARGET_CHAR);  
  }
    }
}
      

void spell_mass_invis( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    AFFECT_DATA af;
    CHAR_DATA *gch;

    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
    {
  if ( !is_same_group( gch, ch ) || IS_AFFECTED(gch, AFF_INVISIBLE)
	|| IS_AFFECTED(gch,AFF_FAERIE_FOG) )
      continue;
  act( "$n slowly fades out of existence.", gch, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( "You slowly fade out of existence.\n\r", gch );

  af.where     = TO_AFFECTS;
  af.type      = sn;
      af.level     = level/2;
  af.duration  = 24;
  af.location  = APPLY_NONE;
  af.modifier  = 0;
  af.bitvector = AFF_INVISIBLE;
  affect_to_char( gch, &af );
    }
    send_to_char( "Ok.\n\r", ch );

    return;
}



void spell_null( int sn, int 
level, CHAR_DATA *ch, void *vo, int target ) {
    send_to_char( "That's not a spell!\n\r", ch );
    return;
}



void spell_pass_door( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_PASS_DOOR) )
    {
    	if(reup_affect(victim,sn,level/4,level))
	{
    send_to_char( "You turn translucent.\n\r", victim );
    act( "$n turns translucent.", victim, NULL, NULL, TO_ROOM ,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = number_fuzzy( level / 4 );
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_PASS_DOOR;
    affect_to_char( victim, &af );
    act( "$n turns translucent.", victim, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "You turn translucent.\n\r", victim );
    return;
}

/* RT plague spell, very nasty */

void spell_plague( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if (saves_spell(level,victim,DAM_DISEASE) || 
        (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD)))
    {
  if (ch == victim)
    send_to_char("You feel momentarily ill, but it passes.\n\r",ch);
  else
    act("$N seems to be unaffected.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if (IS_AFFECTED(victim,AFF_PLAGUE))
    {
       if ( victim != ch )
          act("$N is already plagued.",ch,NULL,victim,TO_CHAR,FALSE);
       else
	  send_to_char("You're already plagued!",ch);
       return;
    }

    if(!is_affected( victim, sn ))
    {
    af.where     = TO_AFFECTS;
    af.type     = sn;
    af.level    = level * 3/4;
    af.duration  = level;
    if ( !IS_NPC(ch) )
    {
        switch( class_table[ch->class].fMana )
        {
        case 0:af.duration = level/4;break;
        case 1:af.duration = level/2;break;
        case 2:af.duration = level;break;
        default:af.duration = level;break;
        }
    }
    af.location  = APPLY_STR;
    af.modifier  = -3; 
    af.bitvector = AFF_PLAGUE;
    affect_join(victim,&af);
   
    send_to_char
      ("You scream in agony as plague sores erupt from your skin.\n\r",victim);
    act("$n screams in agony as plague sores erupt from $s skin.",
  victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch  && victim->clan != ch->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_plague(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_poison( int sn, int level, CHAR_DATA *ch, void *vo, int target )
{
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    AFFECT_DATA af;


    if (target == TARGET_OBJ)
    {
  obj = (OBJ_DATA *) vo;

  if (obj->item_type == ITEM_FOOD || obj->item_type == ITEM_DRINK_CON)
  {
      if (IS_OBJ_STAT(obj,ITEM_BLESS) || IS_OBJ_STAT(obj,ITEM_BURN_PROOF))
      {
    act("Your spell fails to corrupt $p.",ch,obj,NULL,TO_CHAR,FALSE);
    return;
      }
      obj->value[3] = 1;
      act("$p is infused with poisonous vapors.",ch,obj,NULL,TO_ALL,FALSE);
      return;
  }

  if (obj->item_type == ITEM_WEAPON)
  {
      if (IS_WEAPON_STAT(obj,WEAPON_FLAMING)
      ||  IS_WEAPON_STAT(obj,WEAPON_FROST)
      ||  IS_WEAPON_STAT(obj,WEAPON_VAMPIRIC)
      ||  IS_WEAPON_STAT(obj,WEAPON_SHARP)
      ||  IS_WEAPON_STAT(obj,WEAPON_VORPAL)
      ||  IS_WEAPON_STAT(obj,WEAPON_SHOCKING)
      ||  IS_OBJ_STAT(obj,ITEM_BLESS) || IS_OBJ_STAT(obj,ITEM_BURN_PROOF))
      {
    act("You can't seem to envenom $p.",ch,obj,NULL,TO_CHAR,FALSE);
    return;
      }

      if (IS_WEAPON_STAT(obj,WEAPON_POISON))
      {
    act("$p is already envenomed.",ch,obj,NULL,TO_CHAR,FALSE);
    return;
      }

      af.where   = TO_WEAPON;
      af.type  = sn;
      af.level   = level;
      af.duration  = level/2;
      af.location  = 0;
      af.modifier  = 0;
      af.bitvector = WEAPON_POISON;
      affect_to_obj(obj,&af);

      act("$p is coated with deadly venom.",ch,obj,NULL,TO_ALL,FALSE);
      return;
  }

  act("You can't poison $p.",ch,obj,NULL,TO_CHAR,FALSE);
  return;
    }

    victim = (CHAR_DATA *) vo;

    if ( saves_spell( level, victim,DAM_POISON) )
    {
  act("$n turns slightly green, but it passes.",victim,NULL,NULL,TO_ROOM,FALSE);
  send_to_char("You feel momentarily ill, but it passes.\n\r",victim);
  return;
    }

    if (IS_AFFECTED(victim,AFF_POISON))
    {
    	if(reup_affect(victim,sn,level,level))
	{
    send_to_char( "You feel very sick.\n\r", victim );
    act("$n looks very ill.",victim,NULL,NULL,TO_ROOM,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    if(!is_affected( victim, sn ))
    {
    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = level;
    af.location  = APPLY_STR;
    af.modifier  = -1;
    af.bitvector = AFF_POISON;
    affect_join( victim, &af );
    send_to_char( "You feel very sick.\n\r", victim );
    act("$n looks very ill.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_poison(sn,level+2,victim,ch,target);
    }   

    return;
}



void spell_protection_neutral(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_PROTECT_EVIL) 	||
	 IS_AFFECTED(victim, AFF_PROTECT_GOOD)  ||
	 is_affected(victim, gsn_protect_neutral) )
    {
    	if(reup_affect(victim,sn,24,level))
	{
    send_to_char("You are ready to smite wishy washy neutral punks.\n\r",victim);
    if ( victim != ch )
    act("$N is protected from neutrality.",ch,NULL,victim,TO_CHAR,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= 24;
    af.location		= APPLY_SAVING_SPELL;
    af.modifier		= -1;
    af.bitvector	= 0;
    affect_to_char(victim,&af);
    send_to_char("You are ready to smite wishy washy neutral punks.\n\r",victim);
    if ( victim != ch )
    act("$N is protected from neutrality.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}


void spell_protection_evil(int sn,int level,CHAR_DATA *ch,void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
 
    if ( IS_AFFECTED(victim, AFF_PROTECT_EVIL) 
    ||   IS_AFFECTED(victim, AFF_PROTECT_GOOD)
    ||   is_affected(victim,gsn_protect_neutral))
    {
    	if(reup_affect(victim,sn,24,level))
	{
    send_to_char( "You feel holy and pure.\n\r", victim );
    if ( ch != victim )
        act("$N is protected from evil.",ch,NULL,victim,TO_CHAR,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
        return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = 24;
    af.location  = APPLY_SAVING_SPELL;
    af.modifier  = -1;
    af.bitvector = AFF_PROTECT_EVIL;
    affect_to_char( victim, &af );
    send_to_char( "You feel holy and pure.\n\r", victim );
    if ( ch != victim )
        act("$N is protected from evil.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}
 
void spell_protection_good(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
 
    if ( IS_AFFECTED(victim, AFF_PROTECT_GOOD) 
    ||   IS_AFFECTED(victim, AFF_PROTECT_EVIL)
    ||   is_affected(victim, gsn_protect_neutral))
    {
    	if(reup_affect(victim,sn,24,level))
	{
    send_to_char( "You feel aligned with darkness.\n\r", victim );
    if ( ch != victim )
        act("$N is protected from good.",ch,NULL,victim,TO_CHAR,FALSE);
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
        return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = 24;
    af.location  = APPLY_SAVING_SPELL;
    af.modifier  = -1;
    af.bitvector = AFF_PROTECT_GOOD;
    affect_to_char( victim, &af );
    send_to_char( "You feel aligned with darkness.\n\r", victim );
    if ( ch != victim )
        act("$N is protected from good.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}


void spell_ray_of_truth (int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam, align;
 
    if (IS_EVIL(ch) )
    {
        victim = ch;
        send_to_char("The energy explodes inside you!\n\r",ch);
    }
 
    if (victim != ch)
    {
        act("$n raises $s hand, and a blinding ray of light shoots forth!",
            ch,NULL,NULL,TO_ROOM,FALSE);
        send_to_char(
     "You raise your hand and a blinding ray of light shoots forth!\n\r",
     ch);
    }

    if (IS_GOOD(victim))
    {
  act("$n seems unharmed by the light.",victim,NULL,victim,TO_ROOM,FALSE);
  send_to_char("The light seems powerless to affect you.\n\r",victim);
  return;
    }

    dam = dice( level, 10 );
    if ( saves_spell( level, victim,DAM_HOLY) )
        dam /= 2;

    align = victim->alignment;
    align -= 350;

    if (align < -1000)
  align = -1000 + (align + 1000) / 3;

    dam = (dam * align * align) / 1000000;

    spell_blindness(gsn_blindness, 
		   3 * level / 4, ch, (void *) victim,TARGET_CHAR);
    damage( ch, victim, dam, sn, DAM_HOLY ,TRUE,TRUE);

   if( (!is_affected(ch, skill_lookup("indulgence"))) || (ch->kit != kit_lookup("necromancer")) )
    ch->alignment = UMIN(1000, ch->alignment + 50);
}


void spell_recharge( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    OBJ_DATA *obj = (OBJ_DATA *) vo;
    int chance, percent;

    if (obj->pIndexData->vnum == OBJ_VNUM_WAND_PINE ||
 obj->pIndexData->vnum == OBJ_VNUM_WAND_PINE   ||
 obj->pIndexData->vnum == OBJ_VNUM_WAND_APPLE  ||
 obj->pIndexData->vnum == OBJ_VNUM_WAND_OAK    ||
 obj->pIndexData->vnum == OBJ_VNUM_WAND_WILLOW ||
 obj->pIndexData->vnum == OBJ_VNUM_WAND_YEW )
     {
       send_to_char("You may not recharge this wand.\r\n",ch);
	return; 
     }

    if ( (obj->item_type != ITEM_WAND) & (obj->item_type != ITEM_STAFF) )
    {
  send_to_char("That item does not carry charges.\n\r",ch);
  return;
    }

    if (obj->value[0] >= 3 * level / 2)
    {
  send_to_char("Your skills are not great enough for that.\n\r",ch);
  return;
    }

    if (obj->value[1] == 0)
    {
  send_to_char("That item has already been recharged once.\n\r",ch);
  return;
    }

    chance = 40 + 2 * level;

    chance -= obj->value[0]; /* harder to do high-level spells */
    chance -= (obj->value[1] - obj->value[2]) *
        (obj->value[1] - obj->value[2]);

    chance = UMAX(level/2,chance);

    percent = number_percent();

    if (percent < chance / 2)
    {
  act("$p glows softly.",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows softly.",ch,obj,NULL,TO_ROOM,FALSE);
  obj->value[2] = UMAX(obj->value[1],obj->value[2]);
  obj->value[1] = 0;
  return;
    }

    else if (percent <= chance)
    {
  int chargeback,chargemax;

  act("$p glows softly.",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows softly.",ch,obj,NULL,TO_ROOM,FALSE);

  chargemax = obj->value[1] - obj->value[2];
  
  if (chargemax > 0)
      chargeback = UMAX(1,chargemax * percent / 100);
  else
      chargeback = 0;

  obj->value[2] += chargeback;
  obj->value[1] = 0;
  return;
    } 

    else if (percent <= UMIN(95, 3 * chance / 2))
    {
  send_to_char("Nothing seems to happen.\n\r",ch);
  if (obj->value[1] > 1)
      obj->value[1]--;
  return;
    }

    else /* whoops! */
    {
  act("$p glows brightly and explodes!",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows brightly and explodes!",ch,obj,NULL,TO_ROOM,FALSE);
  extract_obj(obj);
    }
}

void spell_refresh( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    victim->move = UMIN( victim->move + level, victim->max_move );
    if (victim->max_move == victim->move)
        send_to_char("You feel fully refreshed!\n\r",victim);
    else
        send_to_char( "You feel less tired.\n\r", victim );
    if ( ch != victim )
        send_to_char( "Ok.\n\r", ch );
    return;
}

void spell_remove_curse( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim;
    OBJ_DATA *obj;
    bool found = FALSE;

    /* do object cases first */
    if (target == TARGET_OBJ)
    {
  obj = (OBJ_DATA *) vo;

  if (IS_OBJ_STAT(obj,ITEM_NODROP) || IS_OBJ_STAT(obj,ITEM_NOREMOVE))
  {
      if (!IS_OBJ_STAT(obj,ITEM_NOUNCURSE)
      &&  !saves_dispel(level + 2,obj->level,0))
      {
    REMOVE_BIT(obj->extra_flags,ITEM_NODROP);
    REMOVE_BIT(obj->extra_flags,ITEM_NOREMOVE);
    act("$p glows blue.",ch,obj,NULL,TO_ALL,FALSE);
    return;
      }

      act("The curse on $p is beyond your power.",ch,obj,NULL,TO_CHAR,FALSE);
      return;
  }
  return;
    }

    /* characters */
    victim = (CHAR_DATA *) vo;

/* Adding in so people just dont remove curse others without worry */
    if( (is_safe(ch,victim) && !is_same_group(ch,victim) 
        && !is_same_clan(ch,victim) && !IS_NPC(ch) )
        || (!is_clan(ch) && IS_SET(victim->act,PLR_NOCANCEL)))
    {
	send_to_char("You are not permitted to cast on them.\n\r",ch);
	return;
    }
    else
       if( is_clan(ch) && is_clan(victim) && !is_same_group(ch,victim)
           && !is_same_clan(ch,victim) )
          check_killer(ch,victim);

    if(!is_same_group(ch,victim) && ch != victim &&
        saves_spell(level,victim,DAM_OTHER))
    {
	send_to_char("You failed.\n\r",ch);
	return;
    }

    if (check_dispel(level,victim,gsn_curse))
    {
  send_to_char("You feel better.\n\r",victim);
  act("$n looks more relaxed.",victim,NULL,NULL,TO_ROOM,FALSE);
  return;
    }

   for (obj = victim->carrying; (obj != NULL && !found); obj = obj->next_content)
   {
        if ((IS_OBJ_STAT(obj,ITEM_NODROP) || IS_OBJ_STAT(obj,ITEM_NOREMOVE))
  &&  !IS_OBJ_STAT(obj,ITEM_NOUNCURSE))
        {   /* attempt to remove curse */
            if (!saves_dispel(level,obj->level,0))
            {
                found = TRUE;
                REMOVE_BIT(obj->extra_flags,ITEM_NODROP);
                REMOVE_BIT(obj->extra_flags,ITEM_NOREMOVE);
                act("Your $p glows blue.",victim,obj,NULL,TO_CHAR,FALSE);
                act("$n's $p glows blue.",victim,obj,NULL,TO_ROOM,FALSE);
            }
         }
    }
}

void spell_sanctuary( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_SANCTUARY) )
    {
    	if(reup_affect(victim,sn,level/6,level))
	{
    act( "$n is surrounded by a white aura.", victim, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "You are surrounded by a white aura.\n\r", victim );
	}
	else
	{
	  send_to_char("Nothing seems to happen.\n\r",ch);
	}
	return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = level / 6;
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_SANCTUARY;
    affect_to_char( victim, &af );
    act( "$n is surrounded by a white aura.", victim, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "You are surrounded by a white aura.\n\r", victim );
    return;
}



void spell_shield( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
    act( "$n is surrounded by a force shield.", victim, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "You are surrounded by a force shield.\n\r", victim );
      reup_affect(victim,sn,8+level,level);
      return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = 8 + level;
    af.location  = APPLY_AC;
    af.modifier  = -20;
    af.bitvector = 0;
    affect_to_char( victim, &af );
    act( "$n is surrounded by a force shield.", victim, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "You are surrounded by a force shield.\n\r", victim );
    return;
}



void spell_shocking_grasp(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    static const int dam_each[] = 
    {
   0,
   0,  0,  0,  0,  0,  0, 20, 25, 29, 33,
  36, 39, 39, 39, 40, 40, 41, 41, 42, 42,
  43, 43, 44, 44, 45, 45, 46, 46, 47, 47,
  48, 48, 49, 49, 50, 50, 51, 51, 52, 52,
  53, 53, 54, 54, 55, 55, 56, 56, 57, 57
    };
    int dam;

    level = UMIN(level, sizeof(dam_each)/sizeof(dam_each[0]) - 1);
    level = UMAX(0, level);
    dam   = number_range( dam_each[level] / 2, dam_each[level] * 2 );
    if (ch->class == class_lookup("mage"))
    {
      dam *= 1.25;
    }
    if ( saves_spell( level, victim,DAM_LIGHTNING) )
  dam /= 2;
    damage( ch, victim, dam, sn, DAM_LIGHTNING ,TRUE,TRUE);
    return;
}

void spell_entrance( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;

    if (is_safe(ch,victim)) return;
    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not entrance.\n\r",ch);
       return;
    }
    if(IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       send_to_char("Highlanders can not entrance.\n\r",ch);
       return;
    }

    if (ch->level < victim->level)
    {
	send_to_char("Your will is not strong enough.\n\r",ch);
	return;
    }

    if (saves_spell (ch->level,victim,DAM_MENTAL))
    {
       send_to_char("Your will has been defeated.\n\r",ch);
       return;
    }

  if ( IS_AFFECTED(victim, AFF_CHARM) 
       || (victim->master != ch && victim->master != NULL) )
  {  
      send_to_char("You can not will those under another's power.\n\r", ch );
      return;
  }

    SET_BIT(victim->affected_by,AFF_CHARM);
    add_follower( victim, ch );
    do_order(ch,target_name);
    stop_follower( victim );
    REMOVE_BIT(victim->affected_by,AFF_CHARM);
    victim->master = NULL;
    return;
}

void spell_sleep( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
 
    if (IS_SET(victim->mhs,MHS_HIGHLANDER) && !IS_NPC(victim))
    {
       send_to_char("Highlanders are immune to that.\n\r",ch);
       return;
    }

    level = UMIN(level,ch->level);

    if ( !IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("mage")) ) 
	level = 9* level /10 ;
    if ( IS_AFFECTED(victim, AFF_SLEEP)
    ||   (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD))
    ||   saves_spell( level, victim,DAM_CHARM) )
  return;

    if ( !IS_NPC(victim) 
    && victim->race == race_lookup("elf")
    && saves_spell(level/4, victim, DAM_CHARM) )
    {
        return;
    }

    switch(check_immune(victim,DAM_MENTAL))
    {
  case IS_IMMUNE:   level = 0;  break;
  case IS_RESISTANT:  level /= 2;  break;
  case IS_VULNERABLE: level += 4;  break;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    if (IS_SET(victim->mhs,MHS_GLADIATOR) && !IS_NPC(victim))
       af.duration  = 3;
    else
       af.duration  = level / 5;
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_SLEEP;
    affect_join( victim, &af );

    if ( IS_AWAKE(victim) )
    {
  send_to_char( "You feel very sleepy ..... zzzzzz.\n\r", victim );
  act( "$n goes to sleep.", victim, NULL, NULL, TO_ROOM ,FALSE);
  victim->position = POS_SLEEPING;
    }

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_sleep(sn,level+2,victim,ch,target);
    }   

    return;
}

void spell_slow( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
 
    if ( is_affected( victim, sn ) || IS_AFFECTED(victim,AFF_SLOW))
    {
    	if(reup_affect(victim,sn,level/2,level))
	{
    send_to_char( "You feel yourself slowing d o w n...\n\r", victim );
    act("$n starts to move in slow motion.",victim,NULL,NULL,TO_ROOM,FALSE);
	}
	else
	{
        if (victim == ch)
          send_to_char("You can't move any slower!\n\r",ch);
        else
          act("$N can't get any slower than that.", ch,NULL,victim,TO_CHAR,FALSE);
	}
        return;
    }

    if ( victim->race != race_lookup("faerie") )
        level = UMIN( level, 51 );

    if (saves_spell(level,victim,DAM_OTHER) 
    ||  IS_SET(victim->imm_flags,IMM_MAGIC))
    {
  if (victim != ch)
            send_to_char("Nothing seemed to happen.\n\r",ch);
        send_to_char("You feel momentarily lethargic.\n\r",victim);
        return;
    }
 
    if (IS_AFFECTED(victim,AFF_HASTE))
    {
        if (!check_dispel(level+2,victim,skill_lookup("haste")))
        {
      if (victim != ch)
              send_to_char("Spell failed.\n\r",ch);
            send_to_char("You feel momentarily slower.\n\r",victim);
            return;
        }

        act("$n is moving less quickly.",victim,NULL,NULL,TO_ROOM,FALSE);
    	level -= ( level / 10 );

	/* Another saves check to see if they still get slowed
	   since they lost their haste
	 */
        if( saves_spell(level,victim,DAM_OTHER))
	  return;
 
    }


    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = level/2;
    if ( !IS_NPC(ch) )
    {
        switch( class_table[ch->class].fMana )
        {
        case 0:af.duration = level/6;break;
        case 1:af.duration = level/4;break;
        case 2:af.duration = level/2;break;
        default:af.duration =level/2;break;
        }
    }
    af.location  = APPLY_DEX;
    af.modifier  = -1 - (level >= 18) - (level >= 25) - (level >= 32);
    af.bitvector = AFF_SLOW;
    affect_to_char( victim, &af );
    send_to_char( "You feel yourself slowing d o w n...\n\r", victim );
    act("$n starts to move in slow motion.",victim,NULL,NULL,TO_ROOM,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_slow(sn,level+2,victim,ch,target);
    }   

    return;
}




void spell_stone_skin( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    int modifier;

    if ( is_affected(victim,gsn_steel_skin) || is_affected(victim,gsn_diamond_skin) || is_affected(victim,gsn_adamantite_skin) )
   {
	send_to_char("You failed.\n\r",ch);
	return;
   }

    if ( ch->race == race_lookup("rockbiter") )
    {
  if (victim == ch)
    send_to_char("Your skin is already as hard as a rock.\n\r",ch); 
  else
    act("$N is already as hard as can be.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    if ( is_affected( victim, sn ) )
    {
	act( "$n's skin turns to stone.", victim, NULL, NULL, TO_ROOM ,FALSE);
	send_to_char( "Your skin turns to stone.\n\r", victim );
	reup_affect(victim,sn,level,level);
	return;
    }

    modifier = -40;

    if ( ch == victim && ch->race == race_lookup("gargoyle") )
	modifier = UMIN(-40,-3*level/2);

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = level;
    af.location  = APPLY_AC;
    af.modifier  = modifier;
    af.bitvector = 0;
    affect_to_char( victim, &af );
    act( "$n's skin turns to stone.", victim, NULL, NULL, TO_ROOM ,FALSE);
    send_to_char( "Your skin turns to stone.\n\r", victim );
    return;
}



void spell_summon( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim;
    char log_buf[MAX_STRING_LENGTH];
    CHAR_DATA *ich;
    bool legal;

    
    if ( ( victim = get_char_world( ch, target_name ) ) == NULL
    ||   victim == ch
    ||   victim->in_room == NULL
    ||   IS_SET(ch->in_room->room_flags, ROOM_SAFE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_SAFE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_PRIVATE)
    ||   IS_SET(victim->in_room->room_flags, ROOM_SOLITARY)
    ||   IS_SET(victim->in_room->room_flags, ROOM_NO_RECALL)
    ||   (IS_NPC(victim) && IS_SET(victim->act,ACT_AGGRESSIVE))
    ||   victim->level >= level + 3
    ||   (!IS_NPC(victim) && victim->level >= LEVEL_IMMORTAL)
    ||   victim->fighting != NULL
    ||   (IS_NPC(victim) && IS_SET(victim->imm_flags,IMM_SUMMON))
    ||	 (IS_NPC(victim) && IS_SET(victim->affected_by,AFF_CHARM))
    ||   (IS_NPC(victim) && victim->pIndexData->pShop != NULL)
    ||   (!IS_NPC(victim) && IS_SET(victim->act,PLR_NOSUMMON) && 
  !IS_SET(victim->act, PLR_DWEEB) )  
    ||   (IS_NPC(victim) && saves_spell( level, victim,DAM_OTHER)) 
    ||  victim->in_room->area->under_develop 
    ||  victim->in_room->area->no_transport
    ||   (IS_SET(ch->in_room->room_flags,ROOM_NOCLAN) && 
	  (is_clan(victim) || IS_SET(ch->mhs,MHS_HIGHLANDER)))
    ||  ch->in_room->area->no_transport )

    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not summon.\n\r",ch);
       return;
    }

/* NIGHTDAGGER added code to prevent summoning mobs in with slept etc. people*/

    legal = TRUE;
    for ( ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room)
    {
        if ( is_clan(ich) && ( IS_AFFECTED(ich, AFF_SLEEP) || is_affected(ich, skill_lookup("hold person")) || is_affected(ich, skill_lookup("garotte")) || is_affected(ich,gsn_trap) ))
        {
            legal = FALSE;
            break;
        }
    }

    if ( (!legal) && (IS_NPC(victim)) && ( (victim->spec_fun == spec_lookup("spec_guard_l")) || (victim->spec_fun == spec_lookup("spec_guard_d")) ) ) 
    {
        send_to_char("Your spell failed, for some reason...\n\r",ch);
        return;
    }
    
    act( "$n disappears suddenly.", victim, NULL, NULL, TO_ROOM ,FALSE);
    char_from_room( victim );
    char_to_room( victim, ch->in_room );
    clear_mount(ch);
    act( "$n arrives suddenly.", victim, NULL, NULL, TO_ROOM ,FALSE);
    act( "$n has summoned you!", ch, NULL, victim,   TO_VICT ,FALSE);
    if (!IS_NPC(victim))
    {
    sprintf(log_buf, "%s has summoned %s to Room [%d]", ch->name, victim->name, ch->in_room->vnum);
    log_string(log_buf);
    }

    do_look( victim, "auto" );
    return;
}



void spell_teleport( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    ROOM_INDEX_DATA *pRoomIndex;

    if ( is_affected(victim,gsn_trap) )
    {
        send_to_char("You are held fast by a snare trap.\n\r",victim);
        return;                                                                 
    }

  if( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL)
  {
    send_to_char("Your master didn't tell you to do that.\n\r",ch);
    return;
  }

    if ( victim->in_room == NULL
    ||   IS_SET(victim->in_room->room_flags, ROOM_NO_RECALL)
    || ( victim != ch && IS_SET(victim->imm_flags,IMM_SUMMON))
    || ( victim == ch && victim->fighting != NULL )
    || ( victim->in_room->area->no_transport )
    || ( IS_AFFECTED(victim,AFF_CURSE) && number_percent() < 75 )
    || ( is_affected(ch,gsn_morph) && number_percent() < 75 )
    || ( is_safe_spell(ch,victim,FALSE, sn))
    || ( IS_NPC(victim) && IS_SET(victim->act, ACT_AGGRESSIVE) )
    || ( victim != ch
    && ( saves_spell( level + (IS_AFFECTED(victim, AFF_CHARM)?1:-5), victim,DAM_OTHER))))
    {
  send_to_char( "You failed.\n\r", ch );
  return;
    }

    pRoomIndex = get_random_room(victim);

    if (victim != ch)
  send_to_char("You have been teleported!\n\r",victim);

    act( "$n vanishes!", victim, NULL, NULL, TO_ROOM ,FALSE);
    if (victim->fighting != NULL) stop_fighting(victim,FALSE);
    char_from_room( victim );
    char_to_room( victim, pRoomIndex );
    clear_mount(ch);
    act( "$n slowly fades into existence.", victim, NULL, NULL, TO_ROOM ,FALSE);
    do_look( victim, "auto" );

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && victim->clan != ch->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_teleport(sn,level+2,victim,ch,target);
    }   
    return;
}



void spell_ventriloquate( int sn, int level, CHAR_DATA *ch,void *vo,int target)
{
    char buf1[MAX_STRING_LENGTH];
    char buf2[MAX_STRING_LENGTH];
    char speaker[MAX_INPUT_LENGTH];
    CHAR_DATA *vch;

    target_name = one_argument( target_name, speaker );

    sprintf( buf1, "%s says '%s'.\n\r",              speaker, target_name );
    sprintf( buf2, "Someone makes %s say '%s'.\n\r", speaker, target_name );
    buf1[0] = UPPER(buf1[0]);

    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
    {
  if ( !is_name( speaker, vch->name ) )
      send_to_char( saves_spell(level,vch,DAM_OTHER) ? buf2 : buf1, vch );
    }

    return;
}



void spell_weaken( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
	send_to_char( "You feel your strength slip away.\n\r", victim );
	act("$n looks tired and weak.",victim,NULL,NULL,TO_ROOM,FALSE);
	reup_affect(victim,sn,level/3,level);
	return;
    }

    if ( saves_spell(level,victim,DAM_OTHER))
    {
       send_to_char("You failed.\n\r",ch);
       return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = level / 3;
    if ( !IS_NPC(ch) )
    {
        switch( class_table[ch->class].fMana )
        {
        case 0:af.duration = level/7;break;
        case 1:af.duration = level/5;break;
        case 2:af.duration = level/3;break;
        default:af.duration = level/3;break;
        }
    }
    af.location  = APPLY_STR;
    af.modifier  = -1 * (level / 10);
    af.bitvector = AFF_WEAKEN;
    affect_to_char( victim, &af );
    send_to_char( "You feel your strength slip away.\n\r", victim );
    act("$n looks tired and weak.",victim,NULL,NULL,TO_ROOM,FALSE);

    if(is_affected(victim,skill_lookup("annointment")) && victim != ch && ch->clan != victim->clan)
    {
        send_to_char( "The Almighty rebukes your attacker.\n\r", victim ); 
        act( "The Almighty rebukes you for harming $N.",ch,NULL,victim,
            TO_CHAR,FALSE);
        spell_weaken(sn,level+2,victim,ch,target);
    }   

    return;
}



/* RT recall spell is back */

void spell_word_of_recall( int sn, int level, CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    ROOM_INDEX_DATA *location;
    
    if ( is_affected(victim,gsn_trap) )
    {                                                                           
        send_to_char("You are held fast by a snare trap.\n\r",victim);
        return;                                                                 
    }  

  if( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL)
  {
    send_to_char("Your master didn't tell you to do that.\n\r",ch);
    return;
  }

    if (IS_NPC(victim))
      return;

	if( is_safe(ch,victim) && !is_same_group(ch,victim) 
	    && !is_same_clan(ch,victim) )
	  return;
	else
        if( is_clan(ch) && is_clan(victim) && !is_same_group(ch,victim)
	    && !is_same_clan(ch,victim) )
	  check_killer(ch,victim);

    if(!is_same_group(ch,victim) && ch != victim &&
		      saves_spell(level,victim,DAM_OTHER))
	 return;
    location = get_room_index( ROOM_VNUM_TEMPLE );
    if ( location  == NULL )
    {
  send_to_char("You are completely lost.\n\r",victim);
  return;
    } 

    if (IS_SET(victim->in_room->room_flags,ROOM_NO_RECALL) ||
  (IS_AFFECTED(victim,AFF_CURSE) && number_percent() < 85) ||
  (is_affected(ch,gsn_morph) && number_percent() < 85)
       )
    {
  send_to_char("Spell failed.\n\r",victim);
  return;
    }

    if ( victim->in_room->area->no_transport )
    {
  send_to_char("Spell failed.\n\r",victim);
  return;
    }

    if (victim->fighting != NULL)
    stop_fighting(victim,TRUE);
    
    ch->move /= 2;
    act("$n disappears.",victim,NULL,NULL,TO_ROOM,FALSE);
    char_from_room(victim);
    clear_mount(victim);
    char_to_room(victim,location);
    act("$n appears in the room.",victim,NULL,NULL,TO_ROOM,FALSE);
    do_look(victim,"auto");
}

/*
 * NPC spells.
 */
void spell_acid_breath( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam,hp_dam,dice_dam,hpch;

    act("$n spits acid at $N.",ch,NULL,victim,TO_NOTVICT,FALSE);
    act("$n spits a stream of corrosive acid at you.",ch,NULL,victim,TO_VICT,FALSE);
    act("You spit acid at $N.",ch,NULL,victim,TO_CHAR,FALSE);

    hpch = UMAX(12,ch->hit);
    hp_dam = number_range(hpch/11 + 1, hpch/6);
    dice_dam = dice(level,16);

    dam = UMAX(hp_dam + dice_dam/10,dice_dam + hp_dam/10);
    
    if (saves_spell(level,victim,DAM_ACID))
    {
  acid_effect(victim,level/2,dam/4,TARGET_CHAR);
  damage(ch,victim,dam/2,sn,DAM_ACID,TRUE,TRUE);
    }
    else
    {
  acid_effect(victim,level,dam,TARGET_CHAR);
  damage(ch,victim,dam,sn,DAM_ACID,TRUE,TRUE);
    }
}



void spell_fire_breath( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    CHAR_DATA *vch, *vch_next;
    int dam,hp_dam,dice_dam;
    int hpch;

    act("$n breathes forth a cone of fire.",ch,NULL,victim,TO_NOTVICT,FALSE);
    act("$n breathes a cone of hot fire over you!",ch,NULL,victim,TO_VICT,FALSE);
    act("You breath forth a cone of fire.",ch,NULL,NULL,TO_CHAR,FALSE);

    hpch = UMAX( 10, ch->hit );
    hp_dam  = number_range( hpch/9+1, hpch/5 );
    dice_dam = dice(level,20);

    dam = UMAX(hp_dam + dice_dam /10, dice_dam + hp_dam / 10);
    fire_effect(victim->in_room,level,dam/2,TARGET_ROOM);

    for (vch = victim->in_room->people; vch != NULL; vch = vch_next)
    {
  vch_next = vch->next_in_room;

  if (is_safe_spell(ch,vch,TRUE, sn) 
  ||  (IS_NPC(vch) && IS_NPC(ch) 
  &&   (ch->fighting != vch || vch->fighting != ch)))
      continue;

  if (vch == victim) /* full damage */
  {
      if (saves_spell(level,vch,DAM_FIRE))
      {
    fire_effect(vch,level/2,dam/4,TARGET_CHAR);
    damage(ch,vch,dam/2,sn,DAM_FIRE,TRUE,TRUE);
      }
      else
      {
    fire_effect(vch,level,dam,TARGET_CHAR);
    damage(ch,vch,dam,sn,DAM_FIRE,TRUE,TRUE);
      }
  }
  else /* partial damage */
  {
      if (saves_spell(level - 2,vch,DAM_FIRE))
      {
    fire_effect(vch,level/4,dam/8,TARGET_CHAR);
    damage(ch,vch,dam/4,sn,DAM_FIRE,TRUE,TRUE);
      }
      else
      {
    fire_effect(vch,level/2,dam/4,TARGET_CHAR);
    damage(ch,vch,dam/2,sn,DAM_FIRE,TRUE,TRUE);
      }
  }
    }
}

void spell_frost_breath( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    CHAR_DATA *vch, *vch_next;
    int dam,hp_dam,dice_dam, hpch;

    act("$n breathes out a freezing cone of frost!",ch,NULL,victim,TO_NOTVICT,FALSE);
    act("$n breathes a freezing cone of frost over you!",
  ch,NULL,victim,TO_VICT,FALSE);
    act("You breath out a cone of frost.",ch,NULL,NULL,TO_CHAR,FALSE);

    hpch = UMAX(12,ch->hit);
    hp_dam = number_range(hpch/11 + 1, hpch/6);
    dice_dam = dice(level,16);

    dam = UMAX(hp_dam + dice_dam/10,dice_dam + hp_dam/10);
    cold_effect(victim->in_room,level,dam/2,TARGET_ROOM); 

    for (vch = victim->in_room->people; vch != NULL; vch = vch_next)
    {
  vch_next = vch->next_in_room;

  if (is_safe_spell(ch,vch,TRUE, sn)
  ||  (IS_NPC(vch) && IS_NPC(ch) 
  &&   (ch->fighting != vch || vch->fighting != ch)))
      continue;

  if (vch == victim) /* full damage */
  {
      if (saves_spell(level,vch,DAM_COLD))
      {
    cold_effect(vch,level/2,dam/4,TARGET_CHAR);
    damage(ch,vch,dam/2,sn,DAM_COLD,TRUE,TRUE);
      }
      else
      {
    cold_effect(vch,level,dam,TARGET_CHAR);
    damage(ch,vch,dam,sn,DAM_COLD,TRUE,TRUE);
      }
  }
  else
  {
      if (saves_spell(level - 2,vch,DAM_COLD))
      {
    cold_effect(vch,level/4,dam/8,TARGET_CHAR);
    damage(ch,vch,dam/4,sn,DAM_COLD,TRUE,TRUE);
      }
      else
      {
    cold_effect(vch,level/2,dam/4,TARGET_CHAR);
    damage(ch,vch,dam/2,sn,DAM_COLD,TRUE,TRUE);
      }
  }
    }
}

    
void spell_gas_breath( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *vch;
    CHAR_DATA *vch_next;
    int dam,hp_dam,dice_dam,hpch;

    act("$n breathes out a cloud of poisonous gas!",ch,NULL,NULL,TO_ROOM,FALSE);
    act("You breath out a cloud of poisonous gas.",ch,NULL,NULL,TO_CHAR,FALSE);

    hpch = UMAX(16,ch->hit);
    hp_dam = number_range(hpch/15+1,8);
    dice_dam = dice(level,12);

    dam = UMAX(hp_dam + dice_dam/10,dice_dam + hp_dam/10);
    poison_effect(ch->in_room,level,dam,TARGET_ROOM);

    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
    {
  vch_next = vch->next_in_room;

  if (is_safe_spell(ch,vch,TRUE, sn)
  ||  (IS_NPC(ch) && IS_NPC(vch) 
  &&   (ch->fighting == vch || vch->fighting == ch)))
      continue;

  if (saves_spell(level,vch,DAM_POISON))
  {
      poison_effect(vch,level/2,dam/4,TARGET_CHAR);
      damage(ch,vch,dam/2,sn,DAM_POISON,TRUE,TRUE);
  }
  else
  {
      poison_effect(vch,level,dam,TARGET_CHAR);
      damage(ch,vch,dam,sn,DAM_POISON,TRUE,TRUE);
  }
    }
}

void spell_lightning_breath(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam,hp_dam,dice_dam,hpch;

    act("$n breathes a bolt of lightning at $N.",ch,NULL,victim,TO_NOTVICT,FALSE);
    act("$n breathes a bolt of lightning at you!",ch,NULL,victim,TO_VICT,FALSE);
    act("You breathe a bolt of lightning at $N.",ch,NULL,victim,TO_CHAR,FALSE);

    hpch = UMAX(10,ch->hit);
    hp_dam = number_range(hpch/9+1,hpch/5);
    dice_dam = dice(level,20);

    dam = UMAX(hp_dam + dice_dam/10,dice_dam + hp_dam/10);

    if (saves_spell(level,victim,DAM_LIGHTNING))
    {
  shock_effect(victim,level/2,dam/4,TARGET_CHAR);
  damage(ch,victim,dam/2,sn,DAM_LIGHTNING,TRUE,TRUE);
    }
    else
    {
  shock_effect(victim,level,dam,TARGET_CHAR);
  damage(ch,victim,dam,sn,DAM_LIGHTNING,TRUE,TRUE);
    }
}

/*
 * Spells for mega1.are from Glop/Erkenbrand.
 */
void spell_general_purpose(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;
 
    dam = number_range( 25, 100 );
    if ( saves_spell( level, victim, DAM_PIERCE) )
        dam /= 2;
    damage( ch, victim, dam, sn, DAM_PIERCE ,TRUE,TRUE);
    return;
}

void spell_high_explosive(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;
 
    dam = number_range( 35, 125 );
    if ( saves_spell( level, victim, DAM_PIERCE) )
        dam /= 2;
    damage( ch, victim, dam, sn, DAM_PIERCE ,TRUE,TRUE);
    return;
}

void spell_animate_dead ( int sn, int level, CHAR_DATA *ch, void *vo, int targ) 
{
  CHAR_DATA *victim;
  OBJ_DATA *obj,*obj2,*next_obj;
  int t,perc,count;
  char *target;
  char str [MAX_INPUT_LENGTH];
  sh_int fail;

  count = 0;
  for ( victim = char_list; victim != NULL; victim = victim->next )
    if ( is_same_group( victim, ch ) && IS_SET(victim->act,ACT_UNDEAD))
      count++;

  if ((count > (ch->level/10)) && !IS_IMMORTAL(ch)) {
    send_to_char ("Your controlling as many undead as you can handle.",ch);
    return;
  }
  if (target_name == "") {
    target = "corpse";
  } else {
    target = target_name;
  }
  obj = get_obj_list( ch, target, ch->in_room->contents );
  if ( obj == NULL )
  {
     act( "I see no $T on the ground here.", ch, NULL, target, TO_CHAR ,FALSE);
     return;
  }
  if ((obj->pIndexData->vnum != OBJ_VNUM_CORPSE_NPC)) {
    send_to_char ("That object cannot be animated.\n\r",ch);
    return;
  }
  
  /* maybe throw in a check for no_loot? */
  if (obj->owner != NULL && !IS_SET(obj->extra_flags,ITEM_CLAN_CORPSE)) {
    send_to_char ("Leave that corpse alone!\n\r",ch);
    return;
  }

  fail = 0;
  if (obj->level > (ch->level*2)) {
    fail = 1;                        /* Nope.. corpse too high */
  } else {
    perc = 100;
    if (obj->level > (ch->level-3)) {
      perc = (ch->level*2 - obj->level)*10;
      if (number_percent() > perc)
        fail = 1;
    }
  }

  if (IS_IMMORTAL (ch)) fail = 0;

  if (fail) {
    send_to_char ("Spell failed.\n\r",ch);
    return;
  }

    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not animate dead.\n\r",ch);
       return;
    }

  /* let's create a corpse mob */
  if (obj->value[3]) {          /* weaken him up a bit */
    victim = create_mobile ( get_mob_index(obj->value[3] ));
    victim->level = UMAX (1,victim->level*2/3);
    victim->max_hit = victim->max_hit*2/3+1;
    victim->hit = victim->max_hit;
    victim->max_mana = victim->max_mana*2/3+1;
    victim->mana = victim->max_mana;
    victim->damage[DICE_NUMBER] = victim->damage[DICE_NUMBER]*2/3+1;    
    victim->damroll = victim->damroll*2/3+1;
    SET_BIT (victim->res_flags,victim->imm_flags);
    victim->imm_flags = 0;
  } else {
    victim = create_mobile ( get_mob_index( MOB_VNUM_CORPSE ));
    victim->level = obj->level*2/3+1;
    for (t = 0; t < 3; t++)
      victim->armor[t] = interpolate(victim->level,100,-100);
    victim->armor[3] = interpolate(victim->level,100,0);
    victim->max_hit = victim->level * 8 + number_range(
          victim->level * victim->level/8,
          victim->level * victim->level);
    victim->hit = victim->max_hit;
    victim->max_mana = 100;
    victim->mana = 100;
    victim->damage[DICE_NUMBER] = victim->level/8+1;
    victim->damage[DICE_TYPE]   = 5;
    victim->hitroll = victim->level;
    victim->damroll = victim->level/2;
  }  
  SET_BIT (victim->form, FORM_UNDEAD);
  SET_BIT (victim->form, FORM_INSTANT_DECAY);
  if ( IS_SET(victim->act, ACT_AGGRESSIVE) )
	REMOVE_BIT(victim->act,ACT_AGGRESSIVE);
  if(victim->spec_fun) victim->spec_fun = NULL;
  char_to_room (victim,ch->in_room);
  free_string( victim->long_descr );
  free_string( victim->short_descr );  
  free_string( victim->name );
  strcpy (str,obj->short_descr); 
  strcat (str," is twitching here.\n\r");  
  victim->long_descr = str_dup (capitalize (str));
  victim->short_descr = str_dup ("the corpse");
  strcpy (str,victim->name);
  strcat (str," corpse");
  victim->name = str_dup (str);
  SET_BIT (victim->act,ACT_UNDEAD); /* just to make sure */

  for (obj2 = obj->contains; obj2 != NULL; obj2 = next_obj) {
    next_obj = obj2->next_content;
    obj_from_obj (obj2);
    obj_to_char (obj2,victim);
  } /* copy the objects over */

  act( "$N raises from the dead and bows before $n.",   ch, NULL, victim, TO_ROOM ,FALSE);
  act( "$N raises from the dead and bows before you.", ch, NULL, victim, TO_CHAR ,FALSE);

  add_follower( victim, ch );
  victim->leader = ch;
  SET_BIT(victim->affected_by,AFF_CHARM); /* quick-charm */
  victim->life_timer = obj->timer*2;
  if (victim->life_timer == 0) {
    victim->life_timer = 10;
  }

  obj_from_room (obj); /* delete the corpse object */
  extract_obj (obj);

  if( !is_affected(ch, skill_lookup("indulgence")) )
    {
      ch->alignment = UMAX(-1000, ch->alignment - number_range (50,100));
    }
}

void spell_summon_dead (  int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
  CHAR_DATA *victim;
  int t,count;

  if ( is_affected(ch,skill_lookup("wound transfer")) )
  {
	send_to_char("You failed.\n\r",ch);
	return;
  }

  if (IS_SET(ch->mhs,MHS_HIGHLANDER))
  {
     send_to_char("Honorable combat is one on one. Highlanders can not summon dead.\n\r",ch);
     return;
  }

    if(IS_SET(ch->mhs,MHS_GLADIATOR))
    {
       send_to_char(" Gladiators can not summon dead.\n\r",ch);
       return;
    }
  count = 0;
  for ( victim = char_list; victim != NULL; victim = victim->next )
    if ( (is_same_group( victim, ch ) && (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD)))
      || (is_same_group(victim->master, ch) && (IS_NPC(victim) && IS_SET(victim->act,ACT_UNDEAD))) )
      count++;
  if ( (ch->kit == kit_lookup("necromancer")) && (count > (ch->level/7)) && !IS_IMMORTAL(ch) )
  {
    send_to_char ("You're controlling as many undead as you can handle.",ch);
    return;
  }

  if ( ((count > (ch->level/10)) && (ch->kit != kit_lookup("necromancer")) && !IS_IMMORTAL(ch))  ) 
  {
    send_to_char ("You're controlling as many undead as you can handle.",ch);
    return;
  }

  /* let's create a skeletal warrior mob */
  victim = create_mobile ( get_mob_index( MOB_VNUM_SKEL_WAR ));
  char_to_room (victim,ch->in_room);
  if ( ch->kit == kit_lookup("necromancer") )
  {
    victim->level = level *4/5 + 3;
  }
  else
  {
    victim->level = level * 4/5+1;
  }
  //victim->level = level * 4/5+1;  
  for (t = 0; t < 3; t++)
    victim->armor[t] = interpolate(victim->level,100,-100);
  victim->armor[3] = interpolate(victim->level,100,0);
  victim->max_hit = level * 8 + number_range(
          level * level / 8, level * level );
  victim->max_hit = UMAX( victim->max_hit, ch->max_hit * 3 /4);
  victim->hit = victim->max_hit;
  victim->max_mana = 100;
  victim->mana = 100;
  victim->damage[DICE_NUMBER] = victim->level/4+1;
  victim->damage[DICE_TYPE]   = 5;
  if ( ch->kit == kit_lookup("necromancer") )
  {
    victim->hitroll = victim->level + number_range(1,4);
    victim->damroll = victim->level/2 + number_range(1,4);
  }
  else
  {
    victim->hitroll = victim->level;
    victim->damroll = victim->level/2;
  }
  //victim->hitroll = victim->level;
  //victim->damroll = victim->level/2;
  SET_BIT (victim->act,ACT_UNDEAD); /* just to make sure */

  act( "A dark hole opens to reveal a skeletal warrior.",ch, NULL, victim,TO_ROOM,FALSE);
  act( "A dark hole opens to reveal a skeletal warrior.",ch, NULL, victim,TO_CHAR,FALSE);

  add_follower( victim, ch );
  victim->leader = ch;
  SET_BIT(victim->form,FORM_INSTANT_DECAY);
  SET_BIT(victim->affected_by,AFF_CHARM); /* quick-charm */
  if ( ch->kit == kit_lookup("necromancer") )
  {
    victim->life_timer = ch->level/3+10;
  }
  else
  {
    victim->life_timer = ch->level/5+10;
  }

  //victim->life_timer = ch->level/5+10;

  if( !is_affected(ch, skill_lookup("indulgence")) )
    {
      ch->alignment = UMAX(-1000, ch->alignment - number_range (50,70));
    }
}

void spell_cryogenesis ( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
  OBJ_DATA *obj = vo;
  int vnum;

  vnum = obj->pIndexData->vnum;

  if ((vnum >= OBJ_VNUM_CORPSE_NPC) &&
      (vnum <= OBJ_VNUM_BRAINS)) {
    obj->timer = 0;
    act("$p looks more solid.",ch,obj,NULL,TO_CHAR,FALSE);
    act("$p looks more solid.",ch,obj,NULL,TO_ROOM,FALSE);
  } else {
    send_to_char ("That object cannot be preserved.\n\r",ch);
    return;
  }
}

void spell_draw_life ( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
  OBJ_DATA *obj = vo,*obj2,*next_obj;
  int vnum,hp;

  vnum = obj->pIndexData->vnum;
  if ((vnum == OBJ_VNUM_CORPSE_NPC) ||
      (vnum == OBJ_VNUM_CORPSE_PC)) {
    if (obj->owner != NULL) {
      send_to_char ("Not on that corpse!\n\r",ch);
      return;
    }
    hp = number_range (obj->level*2,4*obj->level);
    if (hp > 120) hp = 120;
    if (hp < 20) hp = 20;
    
  if( (!is_affected(ch, skill_lookup("indulgence"))) || (ch->kit != kit_lookup("necromancer")) )
    ch->alignment = UMAX(-1000, ch->alignment - number_range (40,70));

    act("You draw the last remains of energy from the corpse.",ch,NULL,NULL,TO_CHAR,FALSE);
    act("As the corpse disintegrates, $n looks healthier.",ch,NULL,NULL,TO_ROOM,FALSE);

    ch->hit += hp;   /* hit can go over max_hit by level/2 */
    if (ch->hit > (ch->max_hit + (ch->level/2))) ch->hit = ch->max_hit + (ch->level/2);

    for (obj2 = obj->contains; obj2 != NULL; obj2 = next_obj) {
      next_obj = obj2->next_content;
      obj_from_obj (obj2);
      if ( obj->item_type == ITEM_MONEY) {
        ch->silver += obj->value[0];
        ch->gold += obj->value[1];
        extract_obj( obj );
      } else {      
        obj_to_char (obj2,ch);
      }
    }                    /* copy the objects to the carrier */
    obj_from_char (obj); /* delete the corpse object */
    extract_obj (obj);
  } else {
    send_to_char ("You cannot draw life from that object.\n\r",ch);
    return;
  }
}


void spell_turn_undead ( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
  CHAR_DATA *gch,*next_char;
  OBJ_DATA *obj,*next_obj;
  sh_int found = 0;
  sh_int skl = 0;
  sh_int passedLevel =0;

  for ( gch = ch->in_room->people; gch != NULL; gch = next_char ) 
  {
    next_char = gch->next_in_room;
    
    if (IS_SET((gch)->form, FORM_UNDEAD) && IS_NPC(gch)) 
    {
      found = TRUE;

	// Commented out as it seems very HARD to turn skellies this way
	// putting it back it, it seems really easy to turn skellies
      if (gch->leader != NULL)
      {
//	skl = get_skill(gch->leader,skill_lookup("summon dead"));
//	skl /= 15 ; 
        if (gch->leader->kit == kit_lookup("necromancer"))
	{
	  skl = get_skill(gch->leader,skill_lookup("summon dead"));
	  skl /= 5;
	}
      }
      //
      if (saves_spell (level-skl,gch,DAM_HOLY)) 
      {
  	act("$n seems unaffected.",gch,NULL,NULL,TO_ROOM,FALSE);
  	if (IS_AWAKE(gch) && gch->fighting == NULL) 
	{
    	act("$n twitches and attacks!",gch,NULL,NULL,TO_ROOM,FALSE);
        if (gch->leader == ch) 
	{
       	   REMOVE_BIT(gch->affected_by,AFF_CHARM);
           gch->leader = NULL;
           gch->master = NULL;
    	}
  	multi_hit(gch,ch,TYPE_UNDEFINED);
  	}
      } 
      else 
      {
  act("$n twitches violently and crumbles into dust.",gch,NULL,NULL,TO_ROOM,FALSE);
  for (obj = gch->carrying; obj != NULL; obj = next_obj) {
    next_obj = obj->next_content;
    obj_from_char (obj);
    obj_to_room (obj,ch->in_room);
      }                    /* copy the objects to the room */

  stop_fighting (gch,FALSE);
  gch->pIndexData->killed++;
  kill_table[URANGE(0, gch->level, MAX_LEVEL-1)].killed++;
  extract_char( gch, TRUE );
      }
    }
  }
  if (!found) {
    send_to_char ("You don't see any undead here.\n\r",ch);
  }
}
/*
void spell_feign_death( int sn, int level, CHAR_DATA *ch,void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected(victim,sn) )
    {
	send_to_char("You are already falsifying your own destruction.\n\r",victim);
	return;
    }

    af.where		= TO_AFFECTS;
    af.type		= sn;
    af.level		= level;
    af.duration		= level/6;
    af.modifier		= 0;
    af.location		= 0;
    af.bitvector	= 0;
    affect_to_char(victim,&af);

    act("Your flesh rots away into the visage of the dead.",victim,NULL,NULL,TO_CHAR,FALSE);
    act("$n's flesh rots away to reveal the visage of the dead.",victim,NULL,NULL,TO_ROOM,FALSE);
    return;
}
*/

void spell_wound_transfer( int sn, int level, CHAR_DATA *ch, void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;
    CHAR_DATA *gch;

    if ( is_affected( victim, sn ) )
    {
	send_to_char("You are already prepared to transfer wounds.\n\r",ch);
	return;
    }

    for ( gch = char_list;
	  gch != NULL ;
	  gch = gch->next )
    {
	if ( is_same_group( ch, gch ) )
	{
 	    if ( is_affected(gch,gsn_wound_transfer) )
	    {
   send_to_char("Another group member is transferring.\n\r",ch);
   return;
	    }

	    if ( (is_clan(victim) && !is_clan(gch)) ||
		(!is_clan(victim) &&  is_clan(gch)) )
	    {
   send_to_char("This spell cannot cross clan boundries.\n\r",victim);
   return;
	    }
       }
   }
    af.where	= TO_AFFECTS;
    af.type	= sn;
    af.level	= level;
    af.duration = dice(1,3) + 3;
    af.location = APPLY_NONE;
    af.modifier = 0;
    af.bitvector = 0;

    affect_to_char( victim, &af );
    send_to_char("Your soul is prepared to share your pain.\n\r",ch);

    return;
}

void spell_withstand_death ( int sn, int level, CHAR_DATA *ch, void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( IS_AFFECTED(victim, AFF_WITHSTAND_DEATH) )
    {
       send_to_char("You are already more powerful then death.\n\r",ch);
       return;
    }

    if (IS_SET(ch->mhs,MHS_GLADIATOR) && 
        gladiator_info.started == TRUE && gladiator_info.bet_counter < 1)
    {
       send_to_char("You may not become more powerful then death in the arena.\n\r", ch);
       return;
    }

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = level/5+5;
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_WITHSTAND_DEATH;
    affect_to_char( victim, &af );
    send_to_char( "You feel like you can withstand death itself.\n\r", victim );
    act( "$n looks more powerful than death.", victim, NULL, NULL, TO_ROOM ,FALSE);
    
  if( !is_affected(ch, skill_lookup("indulgence")) )
    ch->alignment = UMAX(-1000, ch->alignment - number_range (20,50));
    
    return;
}

void spell_lay_on_hands( int sn, int level, CHAR_DATA *ch, void *vo,int target )
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int HchLoses,HvictNeeds;

    if ( IS_AFFECTED(ch,AFF_CHARM) )
	return;

    if( ch->fighting != NULL || victim->fighting != NULL)
	{
	send_to_char("Things need to be calmer.\n\r",ch);
	return;
	}

    if(victim != ch )
    {

     HvictNeeds = victim->max_hit - victim->hit;
     HchLoses = UMIN( ch->hit +3, HvictNeeds );

     victim->hit = UMIN( victim->hit + HchLoses, victim->max_hit );
     update_pos( victim );
     send_to_char( "A warm feeling fills your body.\n\r", victim );

     ch->hit = UMAX( -3, ch->hit - HchLoses);
     update_pos(ch);
     send_to_char( "You force your life out through your hands.\n\r",ch);
    }
    return;
}

void spell_psionic_blast(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    dam = dice( (level*7)/10, 
          (get_curr_stat(ch,STAT_CON) + get_curr_stat(ch,STAT_INT)) / 4 );
    if ( saves_spell( level, victim, DAM_MENTAL ) )
  dam /= 2;
    damage( ch, victim, dam, sn,DAM_MENTAL,TRUE,TRUE);
    /* now we hit the caster */
    dam /= 8;
    damage(ch,ch,dam,sn,DAM_MENTAL,TRUE,TRUE);
    return;
}

void spell_body_weaponry(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    if ( is_affected( victim, sn ) )
    {
  if (victim == ch)
    send_to_char("Your body is already equipped.\n\r",ch);
  else
    act("$N's body is already equipped.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }
    af.where   = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = 24;
    af.location = APPLY_NONE;
    af.modifier = 0;
    af.bitvector = AFF_WEAPONRY;
    affect_to_char( victim, &af );
    send_to_char( "Your body feels protected and armed.\n\r", victim );
    if ( ch != victim )
  act("$N's body becomes equipped for combat.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}

void spell_tower_of_iron_will(int sn,int level,CHAR_DATA *ch,void *vo,int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

  if ( is_affected( victim, sn ) || IS_SET(victim->res_flags,RES_MENTAL))
    {
  if (victim == ch)
    send_to_char("Your will has already peaked.\n\r",ch);
  else
   act("$N is already strong willed.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }
  // Those vulns shouldn't be covered easily
  if ( IS_SET(victim->vuln_flags,VULN_MENTAL))
    {
  if (victim == ch)
    send_to_char("You thought you already took care of that.\n\r",ch);
  else
    act("$N is too easily swayed to make use of your help.",
	ch,NULL,victim,TO_CHAR,FALSE);
  return;
    }

    af.where   = TO_RESIST;
    af.type      = sn;
    af.level   = level;
    af.duration  = level / 2;
    af.location = APPLY_NONE;
    af.modifier = 0;
    af.bitvector = RES_MENTAL;
    affect_to_char( victim, &af );


    send_to_char( "Your will can not be broken.\n\r", victim );
    if ( ch != victim )
  act("$N's will can not be broken.",ch,NULL,victim,TO_CHAR,FALSE);
    return;
}

void spell_mirror_image ( int sn, int level, CHAR_DATA *ch, void *vo, int targ)
{
  CHAR_DATA *victim, *fch;
  char descr[MAX_STRING_LENGTH];
  int t;

  if( is_mounted(ch) && IS_NPC(ch->riding) && ch->riding->pIndexData->vnum == MOB_VNUM_WARHORSE)
  {
    send_to_char("Your magic is not strong enough to mirror your handy dandy warhorse.\n\r",ch);
    return;
  }

  if((fch = ch->fighting) == NULL)
    {
	send_to_char("But you aren't fighting anyone.\n\r",ch);
	return;
    }

    victim = create_mobile ( get_mob_index( MOB_VNUM_MIRROR_IMAGE ));
    victim->level = ch->level*2/3+1;
    for (t = 0; t < 3; t++)
      victim->armor[t] = interpolate(victim->level,100,-100);
    victim->armor[3] = interpolate(victim->level,100,0);
    victim->max_hit = level;
    victim->hit = victim->max_hit;
    victim->max_mana = 100;
    victim->mana = 100;
    victim->damage[DICE_NUMBER] = 1;
    victim->damage[DICE_TYPE]   = 5;
    victim->hitroll = victim->level;
    victim->damroll = 2;
  SET_BIT (victim->form, FORM_INSTANT_DECAY);
  if ( IS_SET(victim->act, ACT_AGGRESSIVE) )
        REMOVE_BIT(victim->act,ACT_AGGRESSIVE);
  SET_BIT (victim->imm_flags, IMM_CHARM);
  SET_BIT (victim->imm_flags, IMM_MENTAL);
  char_to_room (victim,ch->in_room);
/*  free_string( victim->long_descr );
  free_string( victim->short_descr );
  free_string( victim->name ); */
  sprintf(descr,"%s %s is here.\n\r",ch->name,ch->pcdata->title);
  victim->long_descr = str_dup (descr);
  victim->short_descr = str_dup (ch->name);
  victim->name = str_dup (ch->name);

  send_to_char("Your mirror image fools your opponent, ",ch);
  if(IS_SET(ch->display,DISP_COLOR))
   send_to_char( GREEN"RUN!"NORMAL"\n\r", ch );
  else
   send_to_char( "RUN!\n\r", ch );


  stop_fighting( fch, FALSE );
  stop_fighting( ch, FALSE );
  set_fighting(victim,fch);
  set_fighting(fch,victim);

  return;
}

void spell_honor_guard(int sn,int level,CHAR_DATA *ch,void *vo, int target)
{
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    AFFECT_DATA af;

    send_to_char("Sorry, this isn't a spell anymore.\n\r",ch);
    return;

    if( is_affected(victim,skill_lookup("honor guard")) )
	{
	    send_to_char("Just how much more honorable do you want to be?\r\n",victim);
	    return;
	}

    if (ch != victim)
        {
         send_to_char("You may not cast this on another.\r\n",victim);
         return;
        }

        check_improve(ch,gsn_honor_guard,TRUE,8);

    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level     = level;
    af.duration  = victim->level;
    af.location  = APPLY_SAVING_SPELL;
    af.modifier  = -3;
    af.bitvector = 0;
    affect_to_char( victim, &af );
    send_to_char( "You are surrounded by a shield of honor.\n\r", victim );
    return;
}
void write_spell( CHAR_DATA *ch, int sn )
{
    static char buf  [MAX_STRING_LENGTH];
    static char buf2 [MAX_STRING_LENGTH];
    char *pName;
    int iSyl;
    int length;

    struct syl_type
    {
  char *  old;
  char *  new;
    };

    static const struct syl_type syl_table[] =
    {
  { " ",    " "   },
  { "ar",   "abra"    },
  { "au",   "kada"    },
  { "bless",  "fido"    },
  { "blind",  "nose"    },
  { "bur",  "mosa"    },
  { "cu",   "judi"    },
  { "de",   "oculo"   },
  { "en",   "unso"    },
  { "light",  "dies"    },
  { "lo",   "hi"    },
  { "mor",  "zak"   },
  { "move", "sido"    },
  { "ness", "lacri"   },
  { "ning", "illa"    },
  { "per",  "duda"    },
  { "ra",   "gru"   },
  { "fresh",  "ima"   },
  { "re",   "candus"  },
  { "son",  "sabru"   },
  { "tect", "infra"   },
  { "tri",  "cula"    },
  { "ven",  "nofo"    },
  { "wall",  "denca"    },
  { "a", "a" }, { "b", "b" }, { "c", "q" }, { "d", "e" },
  { "e", "z" }, { "f", "y" }, { "g", "o" }, { "h", "p" },
  { "i", "u" }, { "j", "y" }, { "k", "t" }, { "l", "r" },
  { "m", "w" }, { "n", "i" }, { "o", "a" }, { "p", "s" },
  { "q", "d" }, { "r", "f" }, { "s", "g" }, { "t", "h" },
  { "u", "j" }, { "v", "z" }, { "w", "x" }, { "x", "n" },
  { "y", "l" }, { "z", "k" },
  { "", "" }
    };

    buf[0]  = '\0';
    for ( pName = skill_table[sn].name; *pName != '\0'; pName += length )
    {
  for ( iSyl = 0; (length = strlen(syl_table[iSyl].old)) != 0; iSyl++ )
  {
      if ( !str_prefix( syl_table[iSyl].old, pName ) )
      {
    strcat( buf, syl_table[iSyl].new );
    break;
      }
  }

  if ( length == 0 )
      length = 1;
    }

    sprintf( buf2, "%s", buf );
    sprintf( buf,  "%s", skill_table[sn].name );


      if ( get_skill(ch,gsn_spellcraft) >= number_percent() )
      {
        check_improve(ch,gsn_spellcraft,TRUE,10);
	send_to_char(buf,ch);
	return;
      }
      else
	send_to_char(buf2,ch);
	return;
}
@


1.483
log
@hzaaah cone of silence is fixed
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.482 2004/08/29 23:54:17 boogums Exp $";
d7883 10
@


1.482
log
@r BR says its' too poerfil
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.481 2004/01/02 17:06:03 rusty Exp $";
d632 6
d656 6
@


1.481
log
@Let PC's hit other PC's with Call Lightning
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.480 2003/12/19 00:58:46 boogums Exp $";
d1993 6
@


1.480
log
@tweaking necro's skellies
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.479 2003/12/17 02:11:24 boogums Exp $";
d1786 2
a1787 1
      if ( vch != ch && !is_safe_spell(ch,vch,TRUE, sn)
d1789 1
@


1.479
log
@tweaking summon dead
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.478 2003/12/13 15:00:46 boogums Exp $";
d7470 1
a7470 1
  if ( (ch->kit == kit_lookup("necromancer")) && (count > (ch->level/5)) && !IS_IMMORTAL(ch) )
d7487 1
a7487 1
    victim->level = level - number_range(1,5);
@


1.478
log
@done
coirey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.477 2003/12/13 14:57:29 boogums Exp $";
d7507 2
a7508 2
    victim->hitroll = victim->level + number_range(3,10);
    victim->damroll = victim->level/2 + number_range(3,10);
@


1.477
log
@fuzzy out
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.476 2003/12/13 14:47:03 boogums Exp $";
d5463 1
a5463 1
         affect_loc_name( paf->location ), number_fuzzy(paf->modifier) );
@


1.476
log
@ a little randomizing on identify
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.475 2003/12/10 03:04:56 boogums Exp $";
d5415 1
a5415 1
       (number_fuzzy(1 + obj->value[2]) * obj->value[1] / 2));
d5421 1
a5421 1
        ( number_fuzzy(obj->value[1] + obj->value[2] ) / 2) );
d5441 1
a5441 1
        number_fuzzy(obj->value[0]), number_fuzzy(obj->value[1]), number_fuzzy(obj->value[2]), number_fuzzy(obj->value[3]) );
d5538 1
a5538 1
        affect_loc_name( paf->location ), number_fuzzy(paf->modifier) );
d5541 1
a5541 1
                sprintf(buf,", %d hours.\n\r",number_fuzzy(paf->duration));
@


1.475
log
@fixing summon dead
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.474 2003/12/07 20:42:45 boogums Exp $";
d5415 1
a5415 1
       (1 + obj->value[2]) * obj->value[1] / 2);
d5421 1
a5421 1
        ( obj->value[1] + obj->value[2] ) / 2 );
d5441 1
a5441 1
        obj->value[0], obj->value[1], obj->value[2], obj->value[3] );
d5463 1
a5463 1
         affect_loc_name( paf->location ), paf->modifier );
d5538 1
a5538 1
        affect_loc_name( paf->location ), paf->modifier );
d5541 1
a5541 1
                sprintf(buf,", %d hours.\n\r",paf->duration);
@


1.474
log
@making cp cap go higher
xp boost for clanners killing clanners
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.473 2003/12/04 03:57:00 boogums Exp $";
d7487 1
a7487 1
    victim->level = level * 3/5+1;
d7507 2
a7508 2
    victim->hitroll = victim->level + 3;
    victim->damroll = victim->level/2 + 3;
@


1.473
log
@istill more stuff
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.472 2003/12/04 03:50:57 boogums Exp $";
d7470 1
a7470 1
  if ( (ch->kit == kit_lookup("necromancer")) && (count > (ch->level/7)) && !IS_IMMORTAL(ch) )
d7485 9
a7493 1
  victim->level = level * 4/5+1;  
d7505 12
a7516 2
  victim->hitroll = victim->level;
  victim->damroll = victim->level/2;
d7526 10
a7535 1
  victim->life_timer = ch->level/5+10;
@


1.472
log
@tweaking turn undead
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.471 2003/12/04 03:45:20 boogums Exp $";
d7585 1
d7604 1
a7604 1
	  skl /= 10;
a7607 1

@


1.471
log
@stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.470 2003/12/04 03:41:33 boogums Exp $";
d7598 2
a7599 2
	skl = get_skill(gch->leader,skill_lookup("summon dead"));
	skl /= 15 ; 
d7603 1
a7603 1
	  skl /= 50;
@


1.470
log
@test
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.469 2003/12/04 03:35:55 boogums Exp $";
d7599 1
a7599 1
	skl /= 40 ; 
d7603 1
a7603 1
	  skl /= 10;
@


1.469
log
@turn undead and necor changes
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.468 2003/11/30 20:37:56 boogums Exp $";
d5214 1
a5214 1
    float num;
d7600 1
a7600 1
        if (gch->kit == kit_lookup("necromancer"))
@


1.468
log
@stil more id fun
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.467 2003/11/30 20:32:00 boogums Exp $";
d7599 1
a7599 1
	skl /= 20; 
d7603 1
a7603 1
	  skl /= 35;
@


1.467
log
@more id fun
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.466 2003/11/30 18:51:11 boogums Exp $";
d5536 1
a5536 1
#ifdef COREY_TAKEOUT_SO_OTHER_AFFECTS_SHOW
d5580 1
a5580 1
#endif
@


1.466
log
@fuckin id
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.465 2003/11/30 17:32:03 boogums Exp $";
a5436 68
#ifdef COREYCODE
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
    {
    int Alevel;
    int tspin;
    send_to_char("This armor will protect you against:\r\n",ch);

        for (tspin = 0 ;tspin < 4;tspin++)
        {
           Alevel=obj->value[tspin];
	   switch(tspin)
	   {
	   case 0:
	   /*0 is pierce*/
	   	strcpy(buf,"Piercing ");
		if(obj->value[tspin] == 0 ) strcat(buf,"not at all. ");
		if(obj->value[tspin] >= 1 && obj->value[tspin] <= 3  ) strcat(buf,"somewhat. ");
                if(obj->value[tspin] >= 4 && obj->value[tspin] <= 6  ) strcat(buf,"moderatly. ");
                if(obj->value[tspin] >= 7 && obj->value[tspin] <= 9  ) strcat(buf,"well. ");
                if(obj->value[tspin] >= 10 && obj->value[tspin] <= 13  ) strcat(buf,"very well. ");
                if(obj->value[tspin] >= 14 ) strcat(buf,"almost perfectly. ");
		send_to_char(buf,ch);

	   break;
           case 1:
	   /*1 is bash*/
                strcpy(buf,"Bashing ");
                if(obj->value[tspin] == 0 ) strcat(buf,"not at all.\r\n");
                if(obj->value[tspin] >= 1 && obj->value[tspin] <= 3  ) strcat(buf,"somewhat.\r\n");
                if(obj->value[tspin] >= 4 && obj->value[tspin] <= 6  ) strcat(buf,"moderatly.\r\n");
                if(obj->value[tspin] >= 7 && obj->value[tspin] <= 9  ) strcat(buf,"well.\r\n");
                if(obj->value[tspin] >= 10 && obj->value[tspin] <= 13  ) strcat(buf,"very well.\r\n");
                if(obj->value[tspin] >= 14 ) strcat(buf,"almost perfectly.\r\n");
                send_to_char(buf,ch);
 
           break;

	   case 2:
           /*2 is slash*/
                strcpy(buf,"Slashing ");
                if(obj->value[tspin] == 0 ) strcat(buf,"not at all.");
                if(obj->value[tspin] >= 1 && obj->value[tspin] <= 3  ) strcat(buf,"somewhat. ");
                if(obj->value[tspin] >= 4 && obj->value[tspin] <= 6  ) strcat(buf,"moderatly. ");
                if(obj->value[tspin] >= 7 && obj->value[tspin] <= 9  ) strcat(buf,"well. ");
                if(obj->value[tspin] >= 10 && obj->value[tspin] <= 13  ) strcat(buf,"very well. ");
                if(obj->value[tspin] >= 14 ) strcat(buf,"almost perfectly.\r\n");
                send_to_char(buf,ch);

           break;

           case 3:
           /*3 is magic*/
                strcpy(buf,"Magic ");
                if(obj->value[tspin] == 0 ) strcat(buf,"not at all.\r\n");
                if(obj->value[tspin] >= 1 && obj->value[tspin] <= 3  ) strcat(buf,"somewhat.\r\n");
                if(obj->value[tspin] >= 4 && obj->value[tspin] <= 6  ) strcat(buf,"moderatly.\r\n");
                if(obj->value[tspin] >= 7 && obj->value[tspin] <= 9  ) strcat(buf,"well.\r\n");
                if(obj->value[tspin] >= 10 && obj->value[tspin] <= 13  ) strcat(buf,"very well.\r\n");
                if(obj->value[tspin] >= 14 ) strcat(buf,"almost perfectly.\r\n");
                send_to_char(buf,ch);

           break;
           }


        }
    }
#endif
d5453 1
a5453 6
  if ( paf->location != APPLY_NONE && paf->modifier != 0 )
  {
/*    send_to_char("Magically enhanced.\n\r",ch);
    break;*/
#ifdef COREYCODE
      switch(paf->location)
d5455 4
a5458 209
        case APPLY_AC:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you easier to be hit.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you harder to be hit.\r\n");
                  send_to_char(buf,ch);
                }
                break;
	case APPLY_HITROLL:
		num = paf->modifier;
		if (num > 0 )
		{
		  strcpy(buf,"This item makes you hit more accurately.\r\n");
		  send_to_char(buf,ch);
		}
		else
		{
		  strcpy(buf,"This item makes you hit less accurately.\r\n");
		  send_to_char(buf,ch);
		}
		break;
        case APPLY_DAMROLL:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you hit hard like Conan! Go get em Tiger!.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you hit like a little school girl.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_SAVES:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item will cause lady luck to laugh at you.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item eminates an aura of luck.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_STR:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you stronger.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you weaker.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_DEX:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you quicker.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you slower.\r\n");
                  send_to_char(buf,ch);
                }
                break;        
//starthere
	case APPLY_INT:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you smarter.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you less intelligent.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_WIS:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you wiser.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you more foolish.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_CON:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you healthier.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you sickly.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_AGT:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you more catlike.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you a clumsy oaf.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_END:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item gives you more energy.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you become winded easily.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_SOC:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you a smooth operator.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you a social outcast.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_HIT:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item lets you be able to get hit more.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes it so you can get hit less.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_MANA:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes it so you can use more magic.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes it so you can use less magic.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_MOVE:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item lets you move farther.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item lets you move less.\r\n");
                  send_to_char(buf,ch);
                }
                break;


	default:
		strcpy(buf,"Does something magical in nature.\r\n");
		send_to_char(buf,ch);
		stop_looping = TRUE;
		break;
	}
#endif
if ( stop_looping == TRUE)
{
break;
}
d5462 7
a5468 7
      sprintf( buf, "Affects %s by %d.\n\r",
    affect_loc_name( paf->location ), paf->modifier );
      send_to_char(buf,ch);
            if (paf->bitvector)
            {
                switch(paf->where)
                {
a5530 192
      switch(paf->location)
      {
        case APPLY_AC:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you easier to be hit.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you harder to be hit.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_HITROLL:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you hit more accurately.\r\n");
                  //send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you hit less accurately.\r\n");
                  //send_to_char(buf,ch);
                }
                break;
        case APPLY_DAMROLL:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you hit hard like Conan! Go get em Tiger!.\r\n");
                 // send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you hit like a little school girl.\r\n");
                  //send_to_char(buf,ch);
                }
                break;
        case APPLY_SAVES:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item will cause lady luck to laugh at you.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item eminates an aura of luck.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_STR:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you stronger.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you weaker.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_DEX:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you quicker.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you slower.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_INT:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you smarter.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you less intelligent.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_WIS:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you wiser.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you more foolish.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_CON:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you healthier.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you sickly.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_AGT:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you more catlike.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you a clumsy oaf.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_END:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item gives you more energy.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you become winded easily.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_SOC:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes you a smooth operator.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes you a social outcast.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_MANA:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item makes it so you can use more magic.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item makes it so you can use less magic.\r\n");
                  send_to_char(buf,ch);
                }
                break;
        case APPLY_MOVE:
                num = paf->modifier;
                if (num > 0 )
                {
                  strcpy(buf,"This item lets you move farther.\r\n");
                  send_to_char(buf,ch);
                }
                else
                {
                  strcpy(buf,"This item lets you move less.\r\n");
                  send_to_char(buf,ch);
                }
                break;


        default:
                strcpy(buf,"Does something magical in nature.\r\n");
                send_to_char(buf,ch);
                stop_looping = TRUE;
                break;
        }
@


1.465
log
@tweaking id
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.464 2003/06/14 19:53:12 boogums Exp $";
d5737 2
a5738 2
//
    break;
@


1.464
log
@adding the restrain spell to the infuse ability
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.463 2003/06/07 21:25:49 boogums Exp $";
d5376 1
a5376 1
	/*
d5385 1
a5385 1
    obj->value[4]);
d5389 1
a5389 1
    */
d5408 4
a5411 2
  /*
    if( !IS_OBJ_STAT(obj,ITEM_NOIDENTIFY))
a5412 1
  if (obj->pIndexData->new_format)
d5414 5
a5418 3
    obj->value[1],obj->value[2],
    (1 + obj->value[2]) * obj->value[1] / 2);
  else
d5422 1
d5424 1
a5424 1
     */
d5432 2
a5433 2
     }
     
d5437 1
a5437 1
/*#ifdef COREYCODE*/
d5504 1
a5504 2
/*#endif*/
  /*
d5507 4
a5510 4
  sprintf( buf, 
  "Armor class is %d pierce, %d bash, %d slash, and %d vs. magic.\n\r", 
      obj->value[0], obj->value[1], obj->value[2], obj->value[3] );
  send_to_char( buf, ch );
d5512 1
a5512 1
    */
d5525 1
d5732 1
d5737 2
a5738 2

    /*break;
d5773 2
a5774 1
      }*/
@


1.463
log
@ok factoring in soc to charm and endurance to hp and move gains
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.462 2003/06/03 17:49:55 rusty Exp $";
d1943 2
a2065 5
    if (check_dispel(level-1,victim,skill_lookup("cuffs of justice")))
    {
        found = TRUE;
        act("$n is free Free FREE!.",victim,NULL,NULL,TO_ROOM,FALSE);
    }
a3408 5
    }
    if (check_dispel(level,victim,skill_lookup("cuffs of justice")))
    {
        found = TRUE;
        act("$n is free Free FREE!.",victim,NULL,NULL,TO_ROOM,FALSE);
@


1.462
log
@Fixed dam initialization before reduction
upped damage on all DOT spells.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.461 2003/05/30 02:23:05 ndagger Exp $";
d2363 18
@


1.461
log
@05/29/03 Nightdagger:  All clan skills nerfed to prepare for new ones.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.460 2003/05/25 17:41:45 boogums Exp $";
d95 2
a122 1
     dam = number_range(paf->modifier,paf->location);
@


1.460
log
@damn bit vectors
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.459 2003/05/25 14:32:22 boogums Exp $";
d1189 2
d1200 3
d8372 3
@


1.459
log
@DOH damn bitvecotrs :)
orey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.458 2003/05/25 01:34:23 boogums Exp $";
d2910 1
a2910 1
    if (IS_AFFECTED(victim,AFF_CURSE) || IS_SET(ch->mhs,MHS_CURSE))
d7337 1
a7337 1
    || ( IS_SET(ch->mhs,MHS_CURSE) && number_percent() < 75 )
d7491 1
a7491 1
  (IS_SET(ch->mhs,MHS_CURSE) && number_percent() < 85)
@


1.458
log
@ok adding MHS_CURSE
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.457 2003/04/25 15:39:43 rusty Exp $";
d2910 1
a2910 1
    if (IS_AFFECTED(victim,AFF_CURSE) || IS_AFFECTED(victim,MHS_CURSE))
d7337 1
a7337 1
    || ( IS_AFFECTED(victim,MHS_CURSE) && number_percent() < 75 )
d7491 1
a7491 1
  (IS_AFFECTED(victim,MHS_CURSE) && number_percent() < 85)
@


1.457
log
@no refilling grails
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.456 2003/04/02 04:09:46 boogums Exp $";
d2910 1
a2910 1
    if (IS_AFFECTED(victim,AFF_CURSE))
d7337 1
d7490 3
a7492 1
  (IS_AFFECTED(victim,AFF_CURSE) && number_percent() < 85) )
@


1.456
log
@putting gate back in
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.455 2003/04/01 23:25:53 ndagger Exp $";
d2628 2
a2629 1
    if ( obj->item_type != ITEM_DRINK_CON )
@


1.455
log
@04/01/03 Nightdagger:  Blah, fixing something with my april fool's joke
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.454 2003/04/01 23:20:06 ndagger Exp $";
a4689 4
    /*  April Fools! */ 
    send_to_char("You failed.\n\r",ch);
    return;
     
@


1.454
log
@04/01/03 Nightdagger:  April Fools!  Broke the gate code.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.453 2003/03/28 21:40:26 rusty Exp $";
d4690 1
a4690 1
    /*  April Fools!  
d4693 1
a4693 1
    */ 
@


1.453
log
@Ogres not smelling themselves gating into a room
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.452 2003/03/27 16:18:53 rusty Exp $";
d4689 5
@


1.452
log
@Ogres not smelling themselves as remorts when they walk around or gate.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.451 2003/03/22 17:37:30 boogums Exp $";
d4802 1
a4802 1
          if (fch->race == race_lookup("ogre")) 
@


1.451
log
@tweaking saves, gave elves another chance vs sleep
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.450 2003/02/17 21:54:51 ndagger Exp $";
d4751 1
a4751 1
	  if (fch->race == race_lookup("ogre")) 
@


1.450
log
@2/17/03 Nightdagger: basework for honor's clan skill, testing before wimpy changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.449 2002/12/14 17:13:59 boogums Exp $";
d378 1
a378 1
	save -=( get_skill(victim, gsn_berserk) / 20) ;
d389 1
a389 1
	save -= 5;
d392 1
a392 1
        save -= 5;
d394 1
a394 1
        save -= 7;
d399 1
a399 1
	save -=2;
d7048 7
@


1.449
log
@added the new 'buffy' kits but they're unavialable
made turning a bit different
let's see how it goes
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.448 2002/12/08 00:59:40 boogums Exp $";
d1935 3
@


1.448
log
@should have water breathing bug fixed
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.447 2002/11/26 09:38:38 ndagger Exp $";
d8027 2
a8028 1
	/* Commented out as it seems very HARD to turn skellies this way
d8033 5
d8039 1
a8039 1
      */
@


1.447
log
@11/26/02 Nightdagger:  Added throw to things that check pk login delay.  Added a failsafe to is_safe_spell for area affect spells and such.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.446 2002/11/26 08:58:43 ndagger Exp $";
d6721 11
@


1.446
log
@11/26/02 Nightdagger:  spells and objects that cast spells check pkill login delay
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.445 2002/11/15 02:26:53 boogums Exp $";
d1405 6
@


1.445
log
@adding the aura of cthon skill for demise
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.444 2002/11/14 19:15:04 rusty Exp $";
d899 7
d1358 6
@


1.444
log
@MOBs affected by charm are easier to teleport.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.443 2002/11/13 00:24:03 ndagger Exp $";
d1922 3
d3356 5
a3360 1

@


1.443
log
@11/12/02 Nightdagger:  added trap to the summon guard prevention check
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.442 2002/11/13 00:04:57 ndagger Exp $";
d7291 1
a7291 1
       && ( saves_spell( level - 5, victim,DAM_OTHER))))
@


1.442
log
@11/12/02 Nightdagger:  Changed summon so only guard mobs are blocked by slept/garotted/held clanners...whoops
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.441 2002/11/12 01:14:01 ndagger Exp $";
d7234 1
a7234 1
        if ( is_clan(ich) && ( IS_AFFECTED(ich, AFF_SLEEP) || is_affected(ich, skill_lookup("hold person")) || is_affected(ich, skill_lookup("garotte")) ) )
@


1.441
log
@11/11/02 Nightdagger:  can't summon to rooms with slept/held/garotted clanners anymore.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.440 2002/10/19 16:41:05 boogums Exp $";
d7241 1
a7241 1
    if (!legal)
@


1.440
log
@adding osfa to warp possibilies
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.439 2002/10/13 20:12:13 boogums Exp $";
d7190 3
d7229 18
@


1.439
log
@trying ot amke dwarves only res to oldclass mage spells
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.438 2002/10/12 22:30:16 ndagger Exp $";
d3646 4
@


1.438
log
@10/11/02 Nightdagger-  Fire segments give only +3 casting level to fire spells now, instead of +5, and stand a 50% chance of vanishing when thus used.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.437 2002/10/12 21:41:40 boogums Exp $";
d1241 7
a1247 3
     if ( target == TARGET_CHAR && victim != NULL &&
          victim != ch && victim->race == race_lookup("dwarf") )
     { /* Dwarf magical resistance */
@


1.437
log
@tweak to the dwarves, giving them a slight magic rsistance, going to add
somethign to brandish, zap, and recite to make the items not work as
well tho as a counter
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.436 2002/10/12 17:04:47 boogums Exp $";
d610 11
a620 1
	)) level += 5;
a621 1
    return level;
@


1.436
log
@making mages cast combat spells harder
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.435 2002/10/12 03:07:35 boogums Exp $";
d391 1
a391 1
    if (!IS_NPC(victim) && class_table[victim->pcdata->old_class].fMana > 1)
d393 2
d1232 13
d1251 1
a1251 1
	 magres = victim->level / 5;
d1257 1
a1257 1
         magres /= 2;
@


1.435
log
@tweaks to the amgic system
took out the shard  for kaeth buyback
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.434 2002/10/11 04:22:32 boogums Exp $";
d1442 5
d1448 3
a1450 3
       dam = dice( level, 10);
    else
       dam = dice( level, 12 );
d1686 7
a1692 1
  dam /= 2;
d2160 4
d2410 4
d2454 4
d2952 2
a2953 2
    af.level   = level;
    af.duration  = level;
d2987 2
a2988 2
    af.level     = level;
    af.duration  = level;
d3023 2
a3024 2
    af.level     = level;
    af.duration  = level;
d3059 2
a3060 2
    af.level     = level;
    af.duration  = level;
d3095 2
a3096 2
    af.level   = level;
    af.duration  = level;
d3154 4
d3189 4
d4236 4
d6121 8
d6903 4
@


1.434
log
@trying out the redueced duration thing for blind
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.433 2002/10/11 03:38:51 boogums Exp $";
d1148 1
a1148 1
                wait_beats *= .80;
d1633 2
a1634 2
   // else
    //   af.duration  = 1+level/4;
d1642 1
a1642 1
        default:
d2346 10
d2805 10
d6316 10
d7027 10
d7269 10
@


1.433
log
@doh all better now
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.432 2002/10/11 03:18:04 boogums Exp $";
d1148 1
a1148 1
                wait_beats *= .90;
d1151 1
a1151 1
                wait_beats *= .80;
d1630 1
d1633 12
a1644 2
    else
       af.duration  = 1+level/4;
@


1.432
log
@tweaking casters a bit
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.431 2002/10/07 02:36:52 boogums Exp $";
a513 3



a519 2


d1142 1
a1142 1
        switch( class_table[ch->pcdata->old_class].fMana )
@


1.431
log
@tweaking down dispel, it was a bit over the top :)
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.430 2002/10/06 21:47:45 boogums Exp $";
d519 1
a519 1
    case 0: level = ( 7 * level / 10 ); break;  /* 60% casting level */
d1144 20
d3153 1
d3172 1
@


1.430
log
@giving 1's a boost
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.429 2002/10/06 21:01:20 boogums Exp $";
d3138 1
a3138 1
		level += 4;
d3141 1
a3141 1
		level += 2;
@


1.429
log
@giving hybrids a little boost before hte hack code
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.428 2002/10/05 20:11:15 boogums Exp $";
d506 4
a509 1
        level += 2;
d511 1
d513 1
@


1.428
log
@less drastic
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.427 2002/10/05 19:32:28 boogums Exp $";
d507 2
d3128 1
a3128 10
    if
    (
       !IS_NPC(victim) &&
       (
       victim->class != class_lookup("mage")
    || victim->class != class_lookup("cleric")
    || victim->class != class_lookup("wizard")
    || victim->class != class_lookup("druid")
       )
    )
d3130 15
a3144 1
      level += 4; 
@


1.427
log
@serious revamp in compute casting level
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.426 2002/10/05 19:16:10 boogums Exp $";
d504 1
a504 1
/*
d506 2
a507 2
        level = ch->level;
*/
d512 1
a512 1
    case 0: level = ( 6 * level / 10 ); break;  /* 60% casting level */
@


1.426
log
@ok tweaked the casting levels
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.425 2002/10/05 17:25:02 boogums Exp $";
d504 2
a505 2

/*    if ( class_table[ch->pcdata->old_class].fMana == 2 )
d508 1
@


1.425
log
@silly rabbit, trix are for kids
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.424 2002/10/05 17:15:44 boogums Exp $";
d505 4
d511 1
a511 1
    case 0: level = ( 3 * level / 4 ); break;  /* 75% casting level */
d513 1
a515 2
    if ( class_table[ch->pcdata->old_class].fMana == 2 )
        level = ch->level;
d2249 1
a2249 2
    if ( !IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("mage") &&
		       ch->pcdata->old_class != class_lookup("elementalist")))
d2558 1
a2558 2
   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("cleric") &&
	 ch->pcdata->old_class!=class_lookup("elementalist")))
d3657 1
a3657 2
   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("mage") &&
	 ch->pcdata->old_class!=class_lookup("elementalist")))
d3893 1
a3893 2
   if(!IS_NPC(ch)&&( ch->pcdata->old_class != class_lookup("mage") &&
	    ch->pcdata->old_class!=class_lookup("elementalist")))
d6852 1
a6852 2
    if ( !IS_NPC(ch) && ( ch->pcdata->old_class != class_lookup("mage") &&
		       ch->pcdata->old_class != class_lookup("elementalist")))
@


1.424
log
@ID's giving a bit more info
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.423 2002/10/05 17:09:32 boogums Exp $";
d5042 2
d5603 2
d5623 1
d5626 1
d5628 1
d5649 1
a5649 1
                  send_to_char(buf,ch);
d5654 1
a5654 1
                  send_to_char(buf,ch);
d5662 1
a5662 1
                  send_to_char(buf,ch);
d5667 1
a5667 1
                  send_to_char(buf,ch);
@


1.423
log
@weapon affects besides hit and dam now show
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.422 2002/10/03 03:25:34 boogums Exp $";
d5634 26
@


1.422
log
@chaning how wimpy works and updating dispel magic a bit
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.421 2002/10/02 14:49:38 boogums Exp $";
d5426 1
d5595 1
d5622 172
a5793 1
    break;
d5837 1
@


1.421
log
@put a mummy check in do_breathe
fixed the id spelling mistake
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.420 2002/09/30 03:33:47 boogums Exp $";
d3122 15
@


1.420
log
@yahoo id changes are in, gives info but doesn't give hard numbers
adds a bit to the RP of it i think
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.419 2002/09/30 02:58:19 boogums Exp $";
d5363 1
a5363 1
                  strcpy(buf,"This item makes you hit harder.\r\n");
d5368 1
a5368 1
                  strcpy(buf,"This item akes you hit less hard.\r\n");
@


1.419
log
@ID change done
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.418 2002/09/30 02:37:19 boogums Exp $";
d5333 13
d5350 1
a5350 1
		  strcpy(buf,"Makes you hit more accurately.\r\n");
d5355 1
a5355 1
		  strcpy(buf,"Makes you hit less accurately.\r\n");
d5363 1
a5363 1
                  strcpy(buf,"Makes you hit harder.\r\n");
d5368 1
a5368 1
                  strcpy(buf,"Makes you hit less hard.\r\n");
@


1.418
log
@bingo i got it solved
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.417 2002/09/30 02:32:03 boogums Exp $";
d5026 2
d5329 2
a5330 2
    send_to_char("Magically enhanced.\n\r",ch);
/*    break;*/
d5372 145
d5518 1
a5518 1
		strcpy(buf,"Does something.\r\n");
d5520 1
d5523 5
@


1.417
log
@ahhh i gifure it out
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.416 2002/09/30 02:22:52 boogums Exp $";
d5375 1
a5375 1
    break;
d5410 1
a5410 1
      }
@


1.416
log
@more testing in ident
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.415 2002/09/29 21:11:51 boogums Exp $";
a5331 3
      sprintf( buf, "Affects %s by %d.\n\r",
    affect_loc_name( paf->location ), paf->modifier );
      send_to_char(buf,ch);
a5332 5
      sprintf( buf, "Affects %s by %d.\n\r",
    affect_loc_name( paf->location ), paf->modifier );
      send_to_char(buf,ch);


d5338 1
a5338 1
	  	if (num < 0 )	
d5344 26
@


1.415
log
@backing out my changes off to the zoo we go
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.414 2002/09/29 21:08:57 boogums Exp $";
d5328 1
a5328 1
    break;
d5335 4
a5340 2
		
		num = paf->modifier;
@


1.414
log
@lets try this
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.413 2002/09/29 20:59:25 boogums Exp $";
d5328 1
a5328 1
/*    break;*/
@


1.413
log
@i'm a dumbass
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.412 2002/09/29 20:53:15 boogums Exp $";
d5344 1
a5344 1
		else
@


1.412
log
@weird
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.411 2002/09/29 20:39:33 boogums Exp $";
d5025 1
a5025 1
    int num;
d5332 4
d5337 1
@


1.411
log
@ok going to try it this way
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.410 2002/09/29 20:29:36 boogums Exp $";
d5025 1
a5025 1

d5332 3
a5334 1
		if (paf->modifier > 0 )
@


1.410
log
@t doh
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.409 2002/09/29 20:23:48 boogums Exp $";
d5332 1
a5332 1
		if (paf->modifier < 0 )
d5334 1
a5334 1
		  strcpy(buf,"Makes you hit less accurately.\r\n");
d5339 1
a5339 1
		  strcpy(buf,"Makes you hit more accurately.\r\n");
@


1.409
log
@APPLY_HIT is not the same as APPLY_HITROLL...duh
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.408 2002/09/29 20:17:12 boogums Exp $";
d5332 1
a5332 1
		if (paf->modifier <= 0 )
d5334 1
a5334 1
		  strcpy(buf,"Makes you hit less accurately");
@


1.408
log
@testing new ID code oh and stalker code too
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.407 2002/09/21 16:45:50 boogums Exp $";
d5331 1
a5331 1
	case APPLY_HIT:
@


1.407
log
@t tweaked display
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.406 2002/09/21 16:37:18 boogums Exp $";
d5328 20
d5349 1
@


1.406
log
@DOH! must remember = != == ;)
copre
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.405 2002/09/21 16:30:40 boogums Exp $";
d5255 6
a5260 6
		if(obj->value[tspin] == 0 ) strcat(buf,"not at all.\r\n");
		if(obj->value[tspin] >= 1 && obj->value[tspin] <= 3  ) strcat(buf,"somewhat.\r\n");
                if(obj->value[tspin] >= 4 && obj->value[tspin] <= 6  ) strcat(buf,"moderatly.\r\n");
                if(obj->value[tspin] >= 7 && obj->value[tspin] <= 9  ) strcat(buf,"well.\r\n");
                if(obj->value[tspin] >= 10 && obj->value[tspin] <= 13  ) strcat(buf,"very well.\r\n");
                if(obj->value[tspin] >= 14 ) strcat(buf,"almost perfectly.\r\n");
d5280 5
a5284 5
                if(obj->value[tspin] == 0 ) strcat(buf,"not at all.\r\n");
                if(obj->value[tspin] >= 1 && obj->value[tspin] <= 3  ) strcat(buf,"somewhat.\r\n");
                if(obj->value[tspin] >= 4 && obj->value[tspin] <= 6  ) strcat(buf,"moderatly.\r\n");
                if(obj->value[tspin] >= 7 && obj->value[tspin] <= 9  ) strcat(buf,"well.\r\n");
                if(obj->value[tspin] >= 10 && obj->value[tspin] <= 13  ) strcat(buf,"very well.\r\n");
@


1.405
log
@more tweaking on id
corye
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.404 2002/09/18 03:26:25 boogums Exp $";
d5255 1
a5255 1
		if(obj->value[tspin] = 0 ) strcat(buf,"not at all.\r\n");
d5267 1
a5267 1
                if(obj->value[tspin] = 0 ) strcat(buf,"not at all.\r\n");
d5280 1
a5280 1
                if(obj->value[tspin] = 0 ) strcat(buf,"not at all.\r\n");
d5293 1
a5293 1
                if(obj->value[tspin] = 0 ) strcat(buf,"not at all.\r\n");
@


1.404
log
@stil more tweaking on ident
coryew
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.403 2002/09/15 14:39:04 boogums Exp $";
d5240 1
a5240 1
#ifdef COREYCODE
d5253 10
a5262 1
	   
d5264 10
a5273 1
           case 1;
d5277 10
a5286 1
	   case 2
d5291 9
a5301 4

           case 4:
   
           break;
d5307 1
a5307 1
#endif
@


1.403
log
@trying ot figure out why socket crashes us
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.402 2002/09/14 17:04:04 boogums Exp $";
d5227 3
d5236 1
a5236 1
     */
@


1.402
log
@made the same thing i did for scrolls, potions and pills to wands and
staves
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.401 2002/09/14 16:31:57 boogums Exp $";
d5237 36
@


1.401
log
@t rying the new id write spell
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.400 2002/09/11 18:23:27 boogums Exp $";
d5078 2
a5079 1
      send_to_char( skill_table[obj->value[2]].name, ch );
d5086 2
a5087 1
      send_to_char( skill_table[obj->value[3]].name, ch );
d5094 1
a5094 1
	    /*
a5127 1
  /*
d5130 2
a5131 2
  sprintf( buf, "Has %d charges of level %d",
      obj->value[2], obj->value[0] );
d5137 2
a5138 1
      send_to_char( skill_table[obj->value[3]].name, ch );
a5143 1
    */
@


1.400
log
@minor tweaks to identify
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.399 2002/09/10 18:30:56 boogums Exp $";
d43 1
d5070 2
a5071 1
      send_to_char( skill_table[obj->value[1]].name, ch );
d7638 65
d7704 14
@


1.399
log
@halving cost if faded on enchant armor/weapon
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.398 2002/05/28 17:25:27 rusty Exp $";
d5047 1
a5047 1
    /*
d5053 1
a5053 1
     */
d5060 30
a5118 1
    */
d5120 1
@


1.398
log
@Fixed remove curse checks
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.397 2002/05/22 18:00:41 rusty Exp $";
d3663 1
d3908 2
@


1.397
log
@All gems end up in corpses.
All items stolen within the last 10*number_fuzzy(5) ticks go into corpses.
Items taken by steal, loot, heat metal and disarm get timers
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.396 2002/05/16 19:13:02 rusty Exp $";
d6125 3
a6127 3
    if( is_safe(ch,victim) && !is_same_group(ch,victim) 
        && !is_same_clan(ch,victim) && !IS_NPC(ch) 
        && (!is_clan(ch) && IS_SET (victim->act,PLR_NOCANCEL)))
@


1.396
log
@spell_faerie_fog() wrong order for ch and vict in is_safe_spell()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.395 2002/04/17 15:27:34 poquah Exp $";
d4837 1
d4863 1
d4895 1
d4920 1
@


1.395
log
@reduce Dragon Resist and see what happens
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.394 2002/04/11 03:42:07 boogums Exp $";
d4233 1
a4233 1
      if (!is_safe_spell(ich,ch,TRUE, sn))
@


1.394
log
@cuffs of justice spell for posse is in, testing on olc now
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.393 2002/04/10 21:21:41 rusty Exp $";
d1213 3
@


1.393
log
@No casting spells on shopkeepers (well they'll alwasy save at least)
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.392 2002/03/23 18:07:33 rusty Exp $";
d1953 6
d3219 6
@


1.392
log
@Finish spell_identify() enchant info, ooops
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.391 2002/03/23 18:04:45 rusty Exp $";
d315 3
@


1.391
log
@A bit of enchant info in spell_identify()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.390 2002/03/13 16:37:16 rusty Exp $";
d5248 1
a5248 1
      else if( Nench >= 11)
d5250 1
a5250 1
      else if(ch->saving_throw < -12)
d5252 1
a5252 1
      else if(ch->saving_throw < -9)
d5254 1
a5254 1
      else if(ch->saving_throw < -6)
d5256 1
a5256 1
      else if(ch->saving_throw < -3)
a5257 2
      else
      { strcat(buf,"non existent\n\r"); }
@


1.390
log
@Questionable ?: removed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.389 2002/03/09 19:14:29 rusty Exp $";
d5241 23
a5263 1
    send_to_char("Magically enhanced.\n\r",ch);
@


1.389
log
@Hiding information and reup_affect() additions. Initial
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.388 2002/02/26 03:51:20 rusty Exp $";
d4704 1
a4704 1
	if(reup_affect(victim,sn,level/(victim==ch)?2:4,level))
@


1.388
log
@THose without enchanter don't get BLINDINGs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.387 2002/02/25 17:08:10 mud Exp $";
d257 1
d1421 19
d1448 7
a1454 5
  if (victim == ch)
    send_to_char("You are already armored.\n\r",ch);
  else
    act("$N is already armored.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
d1528 5
a1532 5
  if (victim == ch)
    send_to_char("You are already blessed.\n\r",ch);
  else
    act("$N already has divine favor.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
d1563 1
a1563 2

    if ( IS_AFFECTED(victim, AFF_BLIND) )
d1565 1
a1565 4
	if ( victim != ch )
	   act("$N is already blinded.",ch,NULL,victim,TO_CHAR,FALSE);
	else
	   send_to_char("You're already blinded!",ch);
d1569 1
a1569 1
    if ( saves_spell(level,victim,DAM_OTHER))
d1571 10
a1580 1
	send_to_char("You failed.\n\r",ch);
d2759 1
a2759 1
    if (IS_AFFECTED(victim,AFF_CURSE))
d2761 1
a2761 4
       if ( victim != ch )
          act("$N is already cursed.",ch,NULL,victim,TO_CHAR,FALSE);
       else
	  send_to_char("You're already cursed!",ch);
d2765 1
a2765 1
    if ( saves_spell(level,victim,DAM_NEGATIVE))
d2767 11
a2777 2
       send_to_char("You failed.\n\r",ch);
       return;
d2846 11
a2856 5
  if (victim == ch)
    send_to_char("You can already sense evil.\n\r",ch);
  else
    act("$N can already detect evil.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
d2858 1
d2881 11
a2891 5
        if (victim == ch)
          send_to_char("You can already sense good.\n\r",ch);
        else
          act("$N can already detect good.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
d2893 1
d2917 11
a2927 5
        if (victim == ch)
          send_to_char("You are already as alert as you can be. \n\r",ch);
        else
          act("$N can already sense hidden lifeforms.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
d2929 1
d2953 11
a2963 5
        if (victim == ch)
          send_to_char("You can already see invisible.\n\r",ch);
        else
          act("$N can already see invisible things.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
d2989 11
a2999 5
        if (victim == ch)
          send_to_char("You can already sense magical auras.\n\r",ch);
        else
          act("$N can already detect magic.",ch,NULL,victim,TO_CHAR,FALSE);
        return;
d3600 1
a3600 1
  fail -= 25;
d3602 1
a3602 1
  fail -= ( get_skill(ch, gsn_spellcraft) / 10 );
d3613 3
a3615 3
       case SECT_MAGELAB_SIMPLE: factor = 15; break;
       case SECT_MAGELAB_INTERMEDIATE: factor = 30; break;
       case SECT_MAGELAB_ADVANCED: factor = 60; break;
d3698 1
a3698 1
		number_percent() > level / 5)
d4392 11
a4402 5
  if (victim == ch)
    send_to_char("You are already airborne.\n\r",ch);
  else
    act("$N doesn't need your help to fly.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
d4645 4
a4648 5
  if (victim == ch)
    send_to_char("You are already as strong as you can get!\n\r",ch);
  else
    act("$N can't get any stronger.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
d4692 1
a4692 2
    if ( is_affected( victim, sn ) || IS_AFFECTED(victim,AFF_HASTE)
    ||   IS_SET(victim->off_flags,OFF_FAST) || is_affected(victim, skill_lookup("speed")))
d4702 17
d5022 1
d5028 1
d5035 1
d5064 1
d5069 1
d5085 1
d5089 1
d5093 1
d5108 1
d5115 1
d5125 1
d5138 1
d5157 1
d5169 1
a5169 1
        if (obj->value[4])  /* weapon flags */
d5175 1
d5179 1
d5187 1
d5198 2
d5241 2
d5304 10
a5313 4
  if (victim == ch)
    send_to_char("You can already see in the dark.\n\r",ch);
  else
    act("$N already has infravision.\n\r",ch,NULL,victim,TO_CHAR,FALSE);
d5316 1
d5367 13
a5379 1
  return;
d5614 10
a5623 5
  if (victim == ch)
    send_to_char("You are already out of phase.\n\r",ch);
  else
    act("$N is already shifted out of phase.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
a5754 9
    if (IS_AFFECTED(victim,AFF_POISON))
    {
       if ( victim != ch )
          act("$N is already poisoned.",ch,NULL,victim,TO_CHAR,FALSE);
       else
	  send_to_char("You're already poisoned!",ch);
       return;
    }

d5762 14
d5812 6
a5817 2
	if ( victim == ch )
	   send_to_char("You are already protected.\n\r",ch);
d5819 3
a5821 1
	   act("$N is already protected",ch,NULL,victim,TO_CHAR,FALSE);
d5849 10
a5858 4
        if (victim == ch)
          send_to_char("You are already protected.\n\r",ch);
        else
          act("$N is already protected.",ch,NULL,victim,TO_CHAR,FALSE);
d5885 10
a5894 4
        if (victim == ch)
          send_to_char("You are already protected.\n\r",ch);
        else
          act("$N is already protected.",ch,NULL,victim,TO_CHAR,FALSE);
d6133 10
a6142 5
  if (victim == ch)
    send_to_char("You are already in sanctuary.\n\r",ch);
  else
    act("$N is already in sanctuary.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
d6167 4
a6170 5
  if (victim == ch)
    send_to_char("You are already shielded from harm.\n\r",ch);
  else
    act("$N is already protected by a shield.",ch,NULL,victim,TO_CHAR,FALSE);
  return;
d6320 7
d6330 2
a6331 2
          act("$N can't get any slower than that.",
              ch,NULL,victim,TO_CHAR,FALSE);
d6406 1
a6406 1
    if ( is_affected( ch, sn ) || ch->race == race_lookup("rockbiter") )
d6415 8
d6587 1
a6587 1
    if ( is_affected( victim, sn ))
d6589 4
a6592 5
       if ( victim != ch )
 	 act("$N is already weakened.",ch,NULL,victim,TO_CHAR,FALSE);
       else
         send_to_char("You're already weakened!",ch);
       return;
d6658 1
a6658 1
    location = get_room_index( pc_race_table[ch->race].color ? ROOM_VNUM_TEMPLE : ROOM_VNUM_NTFOUNTAIN );
@


1.387
log
@glads can not feast or famine
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.386 2002/02/22 15:59:50 mud Exp $";
d3866 2
a3867 1
    if (result > (level/5) || IS_IMMORTAL(ch))  /* success! */
d3877 1
a3877 1
	|| (HAS_KIT(ch,"enchanter") && number_percent() < 40) )
@


1.386
log
@More enchant_weapon cleanups
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.385 2002/02/22 15:47:42 mud Exp $";
d4189 6
d4247 6
@


1.385
log
@elimitane extraneous ()'s for proper compile
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.384 2002/02/22 15:45:06 rusty Exp $";
d3692 1
a3692 1
    int hit_bonus, dam_bonus, added;
d3752 1
d3875 2
a3876 1
     if (number_percent() < level / 5 )
a3877 2
       if(HAS_KIT(ch,"enchanter") && number_percent() < 50)
       {
d3883 3
a3885 3
       }
       else
       {
a3890 1
       }
@


1.384
log
@Enchanter kit holders get things better
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.383 2002/02/11 20:17:06 poquah Exp $";
d3865 1
a3865 1
    if (result >  (level/5)) || IS_IMMORTAL(ch))  /* success! */
@


1.383
log
@poison and plague no tell you if the person is already plagued or poison
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.382 2002/02/11 18:42:18 poquah Exp $";
d3715 1
d3720 11
a3730 3
        hit_bonus = paf->modifier;
    hit_found = TRUE;
        fail += 2 * (hit_bonus * hit_bonus);
d3732 4
a3735 2

      else if (paf->location == APPLY_DAMROLL )
d3737 6
a3742 4
        dam_bonus = paf->modifier;
    dam_found = TRUE;
        fail += 2 * (dam_bonus * dam_bonus);
      }
d3744 6
a3749 12
      else  /* things get a little harder */
        fail += 25;
      }
 
    for ( paf = obj->affected; paf != NULL; paf = paf->next )
    {
  if ( paf->location == APPLY_HITROLL )
    {
      hit_bonus = paf->modifier;
      hit_found = TRUE;
      fail += 2 * (hit_bonus * hit_bonus);
  }
d3751 1
a3751 9
  else if (paf->location == APPLY_DAMROLL )
    {
      dam_bonus = paf->modifier;
      dam_found = TRUE;
      fail += 2 * (dam_bonus * dam_bonus);
  }

  else /* things get a little harder */
      fail += 25;
d3766 1
a3766 1
  fail -= 25;
d3793 1
a3793 1
		   fail += 25;
d3865 1
a3865 1
    if (result <= (100 - level/5) || IS_IMMORTAL(ch))  /* success! */
a3871 11
    
    else if (!HAS_KIT(ch,"enchanter") ||
		number_percent() > level / 5 )
    {
  act("$p glows a {Bbrilliant{x blue!",ch,obj,NULL,TO_CHAR,FALSE);
  act("$p glows a {Bbrilliant{x blue!",ch,obj,NULL,TO_ROOM,FALSE);
  SET_BIT(obj->extra_flags,ITEM_MAGIC);
  SET_BIT(obj->extra_flags,ITEM_GLOW);
  added = 2;
    }

d3874 4
d3883 10
@


1.382
log
@missing ch pass on smurf_grou_count
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.381 2002/02/11 18:34:11 poquah Exp $";
d5511 9
d5609 9
@


1.381
log
@adding some smurf abilities
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.380 2002/01/26 16:25:28 rage Exp $";
d539 2
a540 2
       if (smurf_group_count > 1)
          level += smurf_group_count;
@


1.380
log
@whole mess of bug fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.379 2002/01/18 15:21:02 mud Exp $";
d538 5
d551 1
@


1.379
log
@cleaned up highlander cast warnings
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.378 2002/01/18 15:17:35 mud Exp $";
d983 1
a983 1
      if(is_safe_spell(ch,victim,FALSE) && victim != ch)
d1320 1
a1320 1
    if (is_safe_spell(ch,victim,FALSE) && ch != victim)
d1645 1
a1645 1
      if ( vch != ch && !is_safe_spell(ch,vch,TRUE)
d2081 1
a2081 1
    if (!is_safe_spell(ch,tmp_vict,TRUE) && tmp_vict != last_vict)
d3360 1
a3360 1
      if ( vch != ch && !is_safe_spell(ch,vch,TRUE))
d4141 1
a4141 1
      if (!is_safe_spell(ich,ch,TRUE))
d4417 1
a4417 1
    ||   (!is_clan(victim) && IS_SET(victim->act,PLR_NOSUMMON) )
d4861 1
a4861 1
    if (!is_safe_spell(ch,vch,TRUE))
d4872 1
a4872 1
    if (!is_safe_spell(ch,vch,TRUE))
d6313 1
a6313 1
    || ( is_safe_spell(ch,victim,FALSE))
d6534 1
a6534 1
  if (is_safe_spell(ch,vch,TRUE) 
d6590 1
a6590 1
  if (is_safe_spell(ch,vch,TRUE)
d6645 1
a6645 1
  if (is_safe_spell(ch,vch,TRUE)
@


1.378
log
@Fixed missing )
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.377 2002/01/18 15:11:26 rusty Exp $";
d726 1
a726 1
      vo = (void *) get_char_world(ch,victim);
@


1.377
log
@spell_charm_person now only lets you control 5* your casting level of
the spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.376 2001/12/15 02:43:35 poquah Exp $";
d701 1
a701 1
         return FALSE;
d2223 1
a2223 1
    if ( is_same_group( fvict, ch ) && (IS_NPC(fvict) && fvict->master == ch)
d2227 2
a2228 1
  if ( (compute_casting_level(ch,sn)*5) < (levtot + victim->level) )
@


1.376
log
@act_wiz - remove unused buf
magic - working on quicken
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.375 2001/12/15 02:41:40 poquah Exp $";
d2171 1
d2173 1
d2215 11
a2225 3
    ||   victim->position == POS_FIGHTING 
    || ( !IS_NPC(victim) && is_affected(ch,gsn_wound_transfer) ) )
  return;
d2227 5
@


1.375
log
@attempt to fix losing racial affects on removing an item
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.374 2001/12/13 18:20:50 poquah Exp $";
d697 1
@


1.374
log
@cant gate to nonclanners who have nosum on
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.373 2001/12/08 02:11:06 poquah Exp $";
d663 1
d680 2
a681 2
   target_name = one_argument( argument, arg1 );
   one_argument( target_name, arg2 );
a687 7

   if (!strcmp(arg2,"self") || arg2[0] == '\0')
      target_name = ch->name; 

   sprintf(buf,"%s is quickening %s at %s",ch->name,arg1,target_name);
   log_string(buf);

d694 13
d715 1
a715 2
   if (target_name != '\0' && !is_name( target_name, ch->name ) &&
       (sn != skill_lookup("farsee")))
d725 1
a725 1
      vo = (void *) get_char_world(ch,target_name);
@


1.373
log
@missing )
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.372 2001/12/08 02:07:09 poquah Exp $";
d4394 1
a4394 1
    ||   (!is_clan(victim) && is_clan(ch) && IS_SET(victim->act,PLR_NOSUMMON) )
@


1.372
log
@able to gate to your own charmies
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.371 2001/12/05 18:22:08 poquah Exp $";
d4398 1
a4398 1
          (IS_SET(victim->affected_by,AFF_CHARM) && victim->leader != ch)
@


1.371
log
@can not gate to mobs who are charmed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.370 2001/11/27 16:20:40 poquah Exp $";
d4397 2
a4398 1
    ||	 (IS_NPC(victim) && IS_SET(victim->affected_by,AFF_CHARM))
@


1.370
log
@added same logic from earthquake for is_safe_spell to faerie_fog
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.369 2001/11/16 00:32:19 rage Exp $";
d4397 1
@


1.369
log
@added in water segment effects
modified water king special to flee more reliably
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.368 2001/10/29 21:17:20 rusty Exp $";
d4110 4
a4113 4
    for ( ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room )
    {
  if (ich->invis_level > 0)
      continue;
d4115 27
a4141 23
  if ( ich == ch || saves_spell( level, ich,DAM_OTHER) )
      continue;

  affect_strip ( ich, gsn_invis     );
  affect_strip ( ich, gsn_mass_invis    );
  affect_strip ( ich, gsn_sneak     );
  REMOVE_BIT   ( ich->affected_by, AFF_HIDE );
  REMOVE_BIT   ( ich->affected_by, AFF_INVISIBLE  );
  REMOVE_BIT   ( ich->affected_by, AFF_SNEAK  );
  REMOVE_BIT   ( ich->mhs, MHS_FADE ); 
  act( "$n is revealed!", ich, NULL, NULL, TO_ROOM ,FALSE);
  send_to_char( "You are revealed!\n\r", ich );

    if ( IS_AFFECTED(ich, AFF_FAERIE_FOG) )
  	continue;
    af.where     = TO_AFFECTS;
    af.type      = sn;
    af.level   = level;
    af.duration  = level/12;
    af.location  = APPLY_NONE;
    af.modifier  = 0;
    af.bitvector = AFF_FAERIE_FOG;
    affect_to_char( ich, &af );
a4142 1

@


1.368
log
@Making confusion harder to cancel
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.367 2001/10/29 21:15:44 rusty Exp $";
d318 5
@


1.367
log
@Confusion cure change.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.366 2001/10/23 03:37:19 boogums Exp $";
d1900 1
a1900 1
    if (check_dispel(level,victim,skill_lookup("confusion")))
@


1.366
log
@doh made shield of honor stackable, it's not any more
also moved it near confusion on the cancellation routine
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.365 2001/10/22 19:21:34 rusty Exp $";
a1835 6
    if (check_dispel(level,victim,skill_lookup("confusion")))
    {
        found = TRUE;
        act("$n doesn't look boggled.",victim,NULL,NULL,TO_ROOM,FALSE);
    }

d1900 6
d2531 1
a2531 2
	 !is_affected( victim, gsn_irradiate ) &&
	 !is_affected(victim, skill_lookup("confusion")))
d2557 2
a2558 1
    
d2564 1
@


1.365
log
@Made spell_call_lightning is_safe_spell() aware.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.364 2001/10/18 23:20:34 rage Exp $";
a3054 6
    if (check_dispel(level,victim,skill_lookup("honor guard")))
    {
        if(number_percent() > lower_level) level--;
        found = TRUE;
    }

d3098 6
d7291 6
@


1.364
log
@added dispel wall spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.363 2001/10/18 19:43:57 rage Exp $";
d1633 2
a1634 1
      if ( vch != ch && ( IS_NPC(ch) ? !IS_NPC(vch) : IS_NPC(vch) ) )
@


1.363
log
@added some functionality for the fire segment
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.362 2001/10/18 13:44:03 rage Exp $";
d583 3
a585 1
		sn == skill_lookup("flameseek") 
@


1.362
log
@removed spec_function from animated corpses
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.361 2001/10/17 03:35:57 boogums Exp $";
d313 1
d317 5
d489 1
a489 1
  
d572 13
@


1.361
log
@DOH had to add the cancellation and dispel checks
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.360 2001/10/17 03:02:47 boogums Exp $";
d6759 1
@


1.360
log
@adding in the honor guard honor clan spell
-Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.359 2001/10/05 18:09:38 rage Exp $";
d1763 3
d3031 6
@


1.359
log
@bug fix for annointment...if two zealots both affected, and one casts on the other, we go poof with buffer overflows
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.358 2001/09/22 17:53:01 rage Exp $";
d7253 25
@


1.358
log
@more cavalier fixes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.357 2001/09/22 17:41:47 rage Exp $";
d1540 1
a1540 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d2119 1
a2119 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d2219 1
a2219 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d2704 1
a2704 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d3257 1
a3257 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d3944 1
a3944 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d4045 1
a4045 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d4148 1
a4148 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d4201 1
a4201 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d4754 1
a4754 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d5457 1
a5457 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d5551 1
a5551 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d6041 1
a6041 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d6112 1
a6112 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d6270 1
a6270 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
d6337 1
a6337 1
    if(is_affected(victim,skill_lookup("annointment")) && victim != ch )
@


1.357
log
@forgot to uncomment the cavalier code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.356 2001/09/22 17:41:18 rage Exp $";
a48 1

@


1.356
log
@Upped level of rename command to 59
Fixed bug with cavalier
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.355 2001/09/22 00:10:49 boogums Exp $";
d379 1
a379 1
/*    if ( !IS_NPC(victim) && group_has_cavalier( victim ) &&
d384 1
a384 1
*/
@


1.355
log
@yanked cavalier kit, don't know why it's crashing when they login
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.354 2001/09/20 03:10:31 boogums Exp $";
d379 1
a379 1
/*    if ( group_has_cavalier( victim ) &&
@


1.354
log
@19SEP01
Putting the cavalier kit in going to try on OOC
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.353 2001/09/02 08:54:21 guerrand Exp $";
d379 1
a379 1
    if ( group_has_cavalier( victim ) &&
d384 1
a384 1

@


1.353
log
@in
xp gins reset
xp gains reset
bug with undead flag fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.352 2001/08/05 22:47:37 guerrand Exp $";
d378 7
@


1.352
log
@Added 5 spells for warlock/witch kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.351 2001/07/31 03:13:54 boogums Exp $";
d6807 2
a6808 2
    if ( (is_same_group( victim, ch ) && IS_SET(victim->act,ACT_UNDEAD))
      || (is_same_group(victim->master, ch) && IS_SET(victim->act,ACT_UNDEAD)) )
@


1.351
log
@t doh forogt ot make pox cancellable
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.350 2001/07/27 02:14:12 guerrand Exp $";
d1061 4
d1066 2
a1067 3
    	WAIT_STATE( ch, skill_table[sn].beats * 2 );
    else
    {
d1070 4
a1073 4
	{
		WAIT_STATE( ch, skill_table[sn].beats / 2 );
		check_improve(ch,gsn_spellcraft,TRUE,10);
	}
a1074 1
	{
d1076 8
a1083 3
    	WAIT_STATE( ch, skill_table[sn].beats );
	}
    }
@


1.350
log
@Added spirit caller kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.349 2001/07/23 04:26:28 guerrand Exp $";
d1749 3
@


1.349
log
@Fixed summon dead.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.348 2001/07/15 01:18:39 guerrand Exp $";
d1731 15
@


1.348
log
@Gargoyle CP lowed by 3, gains adjusted, bug with wound transfer fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.347 2001/07/13 00:58:58 guerrand Exp $";
d6762 6
@


1.347
log
@Added 'shield bash' skill.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.346 2001/07/04 02:29:29 guerrand Exp $";
d2111 6
@


1.346
log
@Hamstring done.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.345 2001/06/28 04:25:18 guerrand Exp $";
d1080 3
@


1.345
log
@Made phoenix harder to dispel, given the costof casting it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.344 2001/06/24 01:27:38 guerrand Exp $";
d4489 6
@


1.344
log
@Changed Shaman DOTs around, fixed MudTrader.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.343 2001/06/22 23:45:55 guerrand Exp $";
d1729 1
a1729 1
    if (check_dispel(level,victim,skill_lookup("spirit of phoenix")))
d2959 1
a2959 1
    if (check_dispel(level,victim,skill_lookup("spirit of phoenix")))
@


1.343
log
@Added adamantite skin
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.342 2001/06/19 06:27:09 guerrand Exp $";
d99 1
d101 2
a109 4

	/* Damage cut in half if caster isn't fighting victim */
	if( caster->fighting != ch )
	    dam /= 2;
a122 4
	/* Damage cut in fourth if victim isn't fighting anybody at all */
     if ( ch->fighting == NULL )
	dam /= 3;
    
@


1.342
log
@Crash bug with healdots fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.341 2001/06/19 06:07:59 guerrand Exp $";
d6091 1
a6091 1
    if ( is_affected(victim,gsn_steel_skin) || is_affected(victim,gsn_diamond_skin) )
@


1.341
log
@Fixed MAJOR bug in heal dots :)
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.340 2001/06/19 05:46:09 guerrand Exp $";
a66 1
    act("You feel better.",ch,NULL,NULL,TO_CHAR,FALSE);
d71 3
a73 3
        send_to_char(skill_table[paf->type].msg_off,ch);
        send_to_char("\n\r",ch);
        affect_remove(ch,paf,APPLY_BOTH);
@


1.340
log
@Fixed a typo inindent spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.339 2001/06/19 02:11:32 guerrand Exp $";
d68 9
@


1.339
log
@FIx for critical strikes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.338 2001/06/19 01:38:41 guerrand Exp $";
d4878 1
a4878 1
	send_to_char(buf,ch);
@


1.338
log
@Added critical strikes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.337 2001/06/17 19:20:47 guerrand Exp $";
d118 1
a118 1
	dam /= 4;
@


1.337
log
@Changed levels so it goes like this:
 25 stone skin
 35 steel skin
 45 diamond skin

They don't stack.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.336 2001/06/17 17:06:00 guerrand Exp $";
d4864 14
@


1.336
log
@Fixed the haste bug in shaman drachlan special.
Added healing DOt functionality.
Added 'shield of faith' spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.335 2001/06/17 01:47:21 guerrand Exp $";
d6068 6
@


1.335
log
@Harder to teleport now through curse.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.334 2001/06/17 00:21:26 guerrand Exp $";
d54 17
d81 6
d114 1
a114 1
     dam = number_range(paf->modifier,paf->duration);
@


1.334
log
@Fixed a typo in backstab.
Fixed a problem with faeries.
ADjusted XP down.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.333 2001/06/17 00:10:06 guerrand Exp $";
d1036 1
a1036 1
    WAIT_STATE( ch, skill_table[sn].beats * 2 );
d1039 1
a1039 1
    if ( target != TAR_CHAR_OFFENSIVE && skill_table[sn].beats >= 24 
d6155 1
a6155 1
    || ( IS_AFFECTED(victim,AFF_CURSE) && number_percent() < 50 )
@


1.333
log
@Fixed faerie casting level problem.
ADjusted DOT damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.332 2001/06/15 02:49:05 guerrand Exp $";
a486 4
    {
	if ( IS_AFFECTED(ch,AFF_DETECT_MAGIC) )
	level += 2;
	else
a487 1
    }
@


1.332
log
@eye gouge is curable with 'cure blindness'
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.331 2001/06/10 04:26:57 guerrand Exp $";
d93 1
a93 1
	/* Damage cut in half if victim isn't fighting anybody at all */
d95 1
a95 1
	dam /= 2;
a485 1
/*
a492 1
 */
@


1.331
log
@GMAN
Some changes in the damage reductions for DOTs.

1. DOT damage halved if caster not in same room as victim
2. DOT damage cut in half if caster not fighting victim
3. DOT damage cut in half if victim not fighting anybody

All are cumulative.  Damage COULd be cut by 1/8th if victim runs
away.  Given all these restrictions, the mana cost of DOTs has
been dropped somewhat.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.330 2001/06/10 03:29:32 guerrand Exp $";
d2389 1
a2389 1
    if ( !is_affected( victim, gsn_blindness ) )
d2402 1
a2402 1
    if (check_dispel(level,victim,gsn_blindness))
d2406 6
@


1.330
log
@Added some new features for surnames.
1. They show in who list but
2. you can toggle that off if you don'tlike it
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.329 2001/06/09 06:27:40 guerrand Exp $";
d69 12
d93 1
a93 1
	/* If the victim isn't in combat, it's not so bad */
d95 1
a95 1
	dam /= 4;
@


1.329
log
@
GMAN

More bug fixing.  Found some bugs with calling 'damage' from 'dot', when
'ch' and 'victim' might be in different rooms.  Addressed these with some
work arounds.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.328 2001/06/09 05:14:20 guerrand Exp $";
d85 1
a85 1
     damage(caster,ch,dam,paf->type,paf->bitvector,FALSE,FALSE);
@


1.328
log
@FIxed a MAJOR bug in determing the source of an attack with a dot.
Basically I have the source and recipient of the damgae swapped.
GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.327 2001/06/09 04:40:17 guerrand Exp $";
d86 3
@


1.327
log
@GMAN
One last adjustment to the damage reduction in DOTs if the victim is! fighting
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.326 2001/06/09 04:30:31 guerrand Exp $";
d85 1
a85 1
     damage(ch,caster,dam,paf->type,paf->bitvector,FALSE,FALSE);
@


1.326
log
@GMAN
Typo fixed.  Put in %s where I wnated \n\r
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.325 2001/06/09 04:18:23 guerrand Exp $";
d83 1
a83 1
	dam /= 2;
@


1.325
log
@Added a new spell: 'blight'.
Level 26, does damage comprable to fireball, plus DOT, but costs 75 mana.
Adjusted 'boiling blood'.
Level 36, does damage comprable to acid blast, plus DOT, but coss 75 mana also.
Both are 2-round delay spells.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.324 2001/06/09 04:01:47 guerrand Exp $";
d93 1
a93 1
	send_to_char("%s",ch);
@


1.324
log
@GMAN
And at least, fixed a potential bug with NULL caster pointer in 'dot'
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.323 2001/06/09 03:58:47 guerrand Exp $";
d74 2
a75 2
     * af.location = # dice of damage
     * af.modifier = Type of dice
d79 6
a84 1
     dam = dice(paf->modifier,paf->duration);
@


1.323
log
@GMAN
Added check for non positive ID to 'dot' in magic.c
 ----------------------------------------------------------------------
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.322 2001/06/09 03:57:00 guerrand Exp $";
d62 6
a67 1
    if ( paf->caster_id > 0 && ( caster = get_char_by_id( paf->caster_id ) ) == NULL )
@


1.322
log
@GMAN!
1. Changed 'affect' command to show duration for dots correctly.
2. Removed unused variable in mag2.c
3. Added a long field to affects called 'caster_id'
4. Added a lookup function called 'get_char_by_id' to handler.c
5. Added a call to get_char_by_id to dot in magic.c to find the caster
6. WE can now track the caster of a spell.

To do: check for a 0 ID and ignore it.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.321 2001/06/09 01:25:33 guerrand Exp $";
d62 1
a62 1
    if ( ( caster = get_char_by_id( paf->caster_id ) ) == NULL )
@


1.321
log
@Fixed two bugs in DOTs.  One was a post-decrement where we wanted a pre.
The other was a typo in an 'act'.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.320 2001/06/09 01:10:52 guerrand Exp $";
d57 2
a58 1
    
d62 3
d75 1
a75 1
     damage(ch,ch,dam,paf->type,paf->bitvector,FALSE,FALSE);
@


1.320
log
@GMAN
Added the first test DOT: boiling blood.
It will eventually go into a 'shaman' kit with some other DOT spells.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.319 2001/06/07 04:15:41 guerrand Exp $";
d76 1
a76 1
     if ( paf->duration-- < 0 )
@


1.319
log
@GMAN
I completed the code for damage over time spells.  Some testing will be
needed, first just to make sure the code, while idling, doesn't break
anything else.  Then we can write some DOT spells and see if they work
right.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.318 2001/06/03 21:40:48 guerrand Exp $";
d1680 4
a1683 1
 
d2904 6
@


1.318
log
@
*holds breath*
This change should save door reset flags in their entirety, load them
that way, and then just set the exit_info in the doors to whatever
the reset value is.  Will it work?  Who knows.

I'm about to find out.
GMAN
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.317 2001/06/03 17:38:39 guerrand Exp $";
d50 34
@


1.317
log
@GMAN
removed dex bonus for rockbitrs, ogres, and giants
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.316 2001/06/03 17:20:22 guerrand Exp $";
d423 1
a425 1
	/* Their magical acuteness is raised with detect magic */
d431 1
a431 1

@


1.316
log
@GMAN
Fixed a bug in ident.  Segmentation problem.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.315 2001/06/03 17:15:10 guerrand Exp $";
d4774 1
a4774 1
	    sprintf(buf,"This spell can be copied %d more time%s.\n\r",
@


1.315
log
@GMAN
Added some more information to lore/ident.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.314 2001/06/03 14:40:27 rusty Exp $";
d4769 1
a4769 1
	    skill_table[slot_lookup( obj->value[2] )].name );
@


1.314
log
@annointment +2 bounce back on casting level forgtten in
original implementation.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.313 2001/06/02 02:16:10 guerrand Exp $";
a4767 3
	if ( slot_lookup( obj->value[2] ) < 0 || IS_OBJ_STAT(obj,ITEM_NOIDENTIFY) )
		break;

d4770 6
@


1.313
log
@
iGMAN
typo in magic.c fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.312 2001/06/02 02:12:41 guerrand Exp $";
d1447 1
a1447 1
        spell_blindness(sn,level,victim,ch,target);
d2005 1
a2005 1
        spell_change_sex(sn,level,victim,ch,target);
d2099 1
a2099 1
        spell_charm_person(sn,level,victim,ch,target);
d2578 1
a2578 1
        spell_curse(sn,level,victim,ch,target);
d3125 1
a3125 1
        spell_dispel_magic(sn,level,victim,ch,target);
d3812 1
a3812 1
        spell_energy_drain(sn,level,victim,ch,target);
d3913 1
a3913 1
	spell_faerie_fire(sn,level,victim,ch,target);
d4016 1
a4016 1
        spell_famine(sn,level,victim,ch,target);
d4069 1
a4069 1
        spell_feast(sn,level,victim,ch,target);
d4616 1
a4616 1
        spell_heat_metal(sn,level,victim,ch,target);
d5302 1
a5302 1
        spell_plague(sn,level,victim,ch,target);
d5396 1
a5396 1
        spell_poison(sn,level,victim,ch,target);
d5886 1
a5886 1
        spell_sleep(sn,level,victim,ch,target);
d5957 1
a5957 1
        spell_slow(sn,level,victim,ch,target);
d6109 1
a6109 1
        spell_teleport(sn,level,victim,ch,target);
d6176 1
a6176 1
        spell_weaken(sn,level,victim,ch,target);
@


1.312
log
@GMAN
Added a new itemn type spell-page for future expansion.
Added new flag resist enchant for weapons.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.311 2001/06/01 04:25:14 guerrand Exp $";
d3605 1
a3605 1
	     number_percent > level ) )  /* item destroyed */
@


1.311
log
@GMAN
bug fixes.  a cosmetic fix in mistform and a missing negative sign in stone skin
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.310 2001/06/01 04:10:37 guerrand Exp $";
d3603 3
a3605 1
	|| (dam_found && dam_bonus > 15) )  /* item destroyed */
d4767 8
@


1.310
log
@GMAN
	Fixed rockbiter bonus damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.309 2001/06/01 02:37:33 guerrand Exp $";
d5974 1
a5974 1
	modifier = UMIN(-40,3*level/2);
@


1.309
log
@Added special gargoyle stoneskin stuff.
GMan
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.308 2001/05/28 17:55:34 rusty Exp $";
d1068 1
a1068 1
	 magres = victim->level / 3;
@


1.308
log
@annoinment checks not looping if victim == ch
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.307 2001/05/28 17:41:21 boogums Exp $";
d5960 1
d5971 5
d5981 1
a5981 1
    af.modifier  = -40;
@


1.307
log
@when a zealot annoints himself then casts feast on themself, crashes
the game
put a && victim !=ch check in hte annoint check
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.306 2001/05/27 22:05:34 rusty Exp $";
d1442 1
a1442 1
    if(is_affected(victim,skill_lookup("annointment")))
d2000 1
a2000 1
    if(is_affected(victim,skill_lookup("annointment")))
d2094 1
a2094 1
    if(is_affected(victim,skill_lookup("annointment")))
d2573 1
a2573 1
    if(is_affected(victim,skill_lookup("annointment")))
d3120 1
a3120 1
    if(is_affected(victim,skill_lookup("annointment")))
d3805 1
a3805 1
    if(is_affected(victim,skill_lookup("annointment")))
d3906 1
a3906 1
    if(is_affected(victim,skill_lookup("annointment")))
d4062 1
a4062 1
    if(is_affected(victim,skill_lookup("annointment")) && (victim != ch))
d4609 1
a4609 1
    if(is_affected(victim,skill_lookup("annointment")))
d5287 1
a5287 1
    if(is_affected(victim,skill_lookup("annointment")))
d5381 1
a5381 1
    if(is_affected(victim,skill_lookup("annointment")))
d5871 1
a5871 1
    if(is_affected(victim,skill_lookup("annointment")))
d5942 1
a5942 1
    if(is_affected(victim,skill_lookup("annointment")))
d6155 1
a6155 1
    if(is_affected(victim,skill_lookup("annointment")))
@


1.306
log
@annointment message to victim as well as ch (instead of double
to ch)
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.305 2001/05/27 20:04:14 mud Exp $";
d4062 1
a4062 1
    if(is_affected(victim,skill_lookup("annointment")))
@


1.305
log
@Missing )'s fixed for annointment
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.304 2001/05/27 19:56:04 rusty Exp $";
d1444 1
a1444 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d2002 1
a2002 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d2096 1
a2096 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d2575 1
a2575 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d3122 1
a3122 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d3807 1
a3807 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d3908 1
a3908 1
	send_to_char( "The Almighty rebukes your attacker.\n\r", ch );
d4011 1
a4011 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d4064 1
a4064 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d4611 1
a4611 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d5289 1
a5289 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d5383 1
a5383 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d5873 1
a5873 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d5944 1
a5944 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d6090 1
a6090 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
d6157 1
a6157 1
        send_to_char( "The Almighty rebukes your attacker.\n\r", ch ); 
@


1.304
log
@Added Zealot clan skill "annointment"
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.303 2001/05/20 21:25:44 rusty Exp $";
d1442 1
a1442 1
    if(is_affected(victim,skill_lookup("annointment"))
d2000 1
a2000 1
    if(is_affected(victim,skill_lookup("annointment"))
d2094 1
a2094 1
    if(is_affected(victim,skill_lookup("annointment"))
d2573 1
a2573 1
    if(is_affected(victim,skill_lookup("annointment"))
d3120 1
a3120 1
    if(is_affected(victim,skill_lookup("annointment"))
d3805 1
a3805 1
    if(is_affected(victim,skill_lookup("annointment"))
d3906 1
a3906 1
    if(is_affected(victim,skill_lookup("annointment"))
d4009 1
a4009 1
    if(is_affected(victim,skill_lookup("annointment") && victim != ch )
d4062 1
a4062 1
    if(is_affected(victim,skill_lookup("annointment"))
d4609 1
a4609 1
    if(is_affected(victim,skill_lookup("annointment"))
d5287 1
a5287 1
    if(is_affected(victim,skill_lookup("annointment"))
d5381 1
a5381 1
    if(is_affected(victim,skill_lookup("annointment"))
d5871 1
a5871 1
    if(is_affected(victim,skill_lookup("annointment"))
d5942 1
a5942 1
    if(is_affected(victim,skill_lookup("annointment"))
d6088 1
a6088 1
    if(is_affected(victim,skill_lookup("annointment") && victim != ch )
d6155 1
a6155 1
    if(is_affected(victim,skill_lookup("annointment"))
@


1.303
log
@No more looting while wraithed
Squashed necro bonus casting levels bug.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.302 2001/05/14 15:08:33 rusty Exp $";
d1441 9
d1999 8
d2093 9
d2572 9
d3119 2
a3120 2
    /* Gladiator Spectator Channel */ 
    if (IS_SET(ch->mhs,MHS_GLADIATOR))
d3122 9
d3133 1
a3133 1
    }
d3138 3
a3140 3
    /* Gladiator Spectator Channel */ 
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent() < 50)
    {
d3143 1
a3143 1
    }
d3805 8
d3905 8
d4009 8
d4062 8
d4608 10
d5286 9
d5380 9
d5870 9
d5941 9
d6087 8
d6154 9
@


1.302
log
@Pulling update from game machine
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.302 2001/05/04 15:30:40 mud Exp $";
d385 1
a385 1
int compute_casting_level( CHAR_DATA *ch )
a387 2
   /*line below added for necromancy check 21OCT00 - Boogums*/
   int sn;
d451 9
a459 9
	     ( sn = skill_lookup( "animate dead" ) )  ||
	     ( sn = skill_lookup( "draw life" ) )     ||
	     ( sn = skill_lookup( "enervation" ) )    ||
	     ( sn = skill_lookup( "summon dead" ) )   ||
	     ( sn = skill_lookup( "turn undead" ) )   ||
	     ( sn = skill_lookup( "wound transfer" ) )||
	     ( sn = skill_lookup( "cryogenesis" ) )   ||
	     ( sn = skill_lookup( "make bag" ) )   ||
	     ( sn = skill_lookup( "withstand death" ) ) 
d464 13
a476 15
          level=level-20;
	if ( ch->alignment <= 499 && ch->alignment >= 250 )
	  level=level-15;
	if ( ch->alignment <= 249 && ch->alignment >= 0 )
	  level=level-10;
        if ( ch->alignment <= -1 && ch->alignment >= -250 )
	  level=level-5;
	if ( ch->alignment <= -251 && ch->alignment >= -500)
	  level=level+0;
	if ( ch->alignment <= -501 && ch->alignment >= -750)
          level=level+1;
	if ( ch->alignment <= -751 && ch->alignment >= -949)
          level=level+2;
	if ( ch->alignment <= -950 && ch->alignment >= -1000)
          level=level+3;
d1043 1
a1043 1
       level = compute_casting_level( ch );
@


1.301
log
@Fixes to last_attacked_by_timer
Earthbind a bit more difficult to cancel.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.300 2001/03/10 15:36:48 mud Exp $";
d5812 7
d5820 1
a5820 1
 
@


1.300
log
@increase mana cost of make bag and give necromancers +levels like other necro spells
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.299 2001/03/03 19:14:38 mud Exp $";
a1692 3
    if (check_dispel(level,victim,skill_lookup("earthbind")))
	found = TRUE;

d1726 3
@


1.299
log
@Moved the arg for damage() to the correct place
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.298 2001/03/03 18:53:59 mud Exp $";
d460 1
@


1.298
log
@Took out all references to damage_old() and used iOld var in damage()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.297 2001/02/10 03:29:22 mud Exp $";
d1509 2
a1510 2
    damage( ch, vch, saves_spell( level,vch,DAM_LIGHTNING,TRUE) 
    ? dam / 2 : dam, sn,DAM_LIGHTNING,TRUE);
@


1.297
log
@removed unused var
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.296 2001/01/27 03:05:44 mud Exp $";
d1281 1
a1281 1
    damage_old( ch, victim, dam, sn,DAM_ACID,TRUE);
d1468 1
a1468 1
    damage_old( ch, victim, dam, sn, DAM_FIRE,TRUE);
d1509 1
a1509 1
    damage_old( ch, vch, saves_spell( level,vch,DAM_LIGHTNING) 
d1853 1
a1853 1
    damage_old( ch, victim, dam, sn,DAM_HARM,TRUE);
d1868 1
a1868 1
    damage_old( ch, victim, dam, sn,DAM_HARM,TRUE);
d1883 1
a1883 1
    damage_old( ch, victim, dam, sn,DAM_HARM,TRUE);
d1906 1
a1906 1
    damage_old(ch,victim,dam,sn,DAM_LIGHTNING,TRUE);
d1930 1
a1930 1
      damage_old(ch,tmp_vict,dam,sn,DAM_LIGHTNING,TRUE);
d1954 1
a1954 1
    damage_old(ch,ch,dam,sn,DAM_LIGHTNING,TRUE);
d2119 1
a2119 1
    damage_old( ch, victim, dam, sn, DAM_COLD,TRUE );
d2148 1
a2148 1
    damage_old( ch, victim, dam, sn, DAM_LIGHT,TRUE );
d2580 1
a2580 1
    damage_old( ch, victim, dam, sn, DAM_NEGATIVE ,TRUE);
d2776 1
a2776 1
    damage_old( ch, victim, dam, sn, DAM_HOLY ,TRUE);
d2807 1
a2807 1
    damage_old( ch, victim, dam, sn, DAM_NEGATIVE ,TRUE);
d2847 1
a2847 1
	   damage_old( ch, victim, dam, sn, DAM_NEGATIVE, FALSE);
d3125 1
a3125 1
        damage_old(ch,vch,0,sn,DAM_BASH,TRUE);
d3127 1
a3127 1
        damage_old( ch,vch,level + dice(2, 8), sn, DAM_BASH,TRUE);
d3762 1
a3762 1
    damage_old( ch, victim, dam, sn, DAM_NEGATIVE ,TRUE);
d3788 1
a3788 1
    damage_old( ch, victim, dam, sn, DAM_FIRE ,TRUE);
d3828 1
a3828 1
    damage_old( ch, victim, dam, sn, DAM_FIRE ,TRUE);
d4307 1
a4307 1
    damage_old( ch, victim, dam, sn,DAM_HARM,TRUE);
d4533 1
a4533 1
  damage_old(ch,victim,dam,sn,DAM_FIRE,TRUE);
d4573 1
a4573 1
      damage_old(ch,vch,dam,sn,DAM_ENERGY,TRUE);
d4584 1
a4584 1
      damage_old(ch,vch,dam,sn,DAM_ENERGY,TRUE);
d4986 1
a4986 1
    damage_old( ch, victim, dam, sn, DAM_LIGHTNING ,TRUE);
d5078 1
a5078 1
    damage_old( ch, victim, dam, sn, DAM_ENERGY ,TRUE);
d5426 1
a5426 1
    damage_old( ch, victim, dam, sn, DAM_HOLY ,TRUE);
d5675 1
a5675 1
    damage_old( ch, victim, dam, sn, DAM_LIGHTNING ,TRUE);
d6111 1
a6111 1
  damage_old(ch,victim,dam/2,sn,DAM_ACID,TRUE);
d6116 1
a6116 1
  damage_old(ch,victim,dam,sn,DAM_ACID,TRUE);
d6154 1
a6154 1
    damage_old(ch,vch,dam/2,sn,DAM_FIRE,TRUE);
d6159 1
a6159 1
    damage_old(ch,vch,dam,sn,DAM_FIRE,TRUE);
d6167 1
a6167 1
    damage_old(ch,vch,dam/4,sn,DAM_FIRE,TRUE);
d6172 1
a6172 1
    damage_old(ch,vch,dam/2,sn,DAM_FIRE,TRUE);
d6210 1
a6210 1
    damage_old(ch,vch,dam/2,sn,DAM_COLD,TRUE);
d6215 1
a6215 1
    damage_old(ch,vch,dam,sn,DAM_COLD,TRUE);
d6223 1
a6223 1
    damage_old(ch,vch,dam/4,sn,DAM_COLD,TRUE);
d6228 1
a6228 1
    damage_old(ch,vch,dam/2,sn,DAM_COLD,TRUE);
d6263 1
a6263 1
      damage_old(ch,vch,dam/2,sn,DAM_POISON,TRUE);
d6268 1
a6268 1
      damage_old(ch,vch,dam,sn,DAM_POISON,TRUE);
d6291 1
a6291 1
  damage_old(ch,victim,dam/2,sn,DAM_LIGHTNING,TRUE);
d6296 1
a6296 1
  damage_old(ch,victim,dam,sn,DAM_LIGHTNING,TRUE); 
d6311 1
a6311 1
    damage_old( ch, victim, dam, sn, DAM_PIERCE ,TRUE);
d6323 1
a6323 1
    damage_old( ch, victim, dam, sn, DAM_PIERCE ,TRUE);
d6800 1
a6800 1
    damage_old( ch, victim, dam, sn,DAM_MENTAL,TRUE);
d6803 1
a6803 1
    damage_old(ch,ch,dam,sn,DAM_MENTAL,TRUE);
@


1.296
log
@27JAN01
got the other indulgance things
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.295 2001/01/27 02:39:28 mud Exp $";
d551 1
a551 2
    char buf[MAX_STRING_LENGTH];
    char spell[MAX_INPUT_LENGTH];
@


1.295
log
@26JAN01
Fixed the align drop on teh two summon dead and animate dead spells
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.294 2001/01/20 00:32:12 mud Exp $";
d2566 1
a2566 1
   if ( (!is_affected(ch, skill_lookup("indulgence"))) || (ch->kit != kit_lookup("necromancer"))) 
d6755 1
a6755 1
  if( (!is_affected(ch, skill_lookup("indulgence")))  || (ch->kit != kit_lookup("necromancer")) )
@


1.294
log
@charming removes spec_guard_l and spec_guard_d
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.293 2001/01/20 00:24:41 mud Exp $";
d6459 1
a6459 1
  if( (!is_affected(ch, skill_lookup("indulgence")))  || (ch->kit != kit_lookup("necromancer")) )
d6526 1
a6526 1
  if( (!is_affected(ch, skill_lookup("indulgence") ))  || (ch->kit != kit_lookup("necromancer")) )
@


1.293
log
@charming removes spec_executioner
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.292 2001/01/12 03:38:47 mud Exp $";
d2060 3
a2062 1
       if (victim->spec_fun == spec_lookup("spec_executioner"))
@


1.292
log
@11jan01
trying to get that necro's align not to drop
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.291 2000/12/22 05:13:36 mud Exp $";
d2058 4
@


1.291
log
@21DEC00
Took the align check drop out for necromancers.  will evaluate it
later, it's screwing with indulgance
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.290 2000/12/22 04:53:57 mud Exp $";
d2560 1
a2560 1
   if ( !is_affected(ch, skill_lookup("indulgence")))
d3717 1
a3717 1
    if (victim != ch && !is_affected(ch, skill_lookup("indulgence")))
d5423 1
a5423 1
   if(!is_affected(ch, skill_lookup("indulgence")))
d6453 1
a6453 3
  if( !is_affected(ch, skill_lookup("indulgence"))
  /*don't let those necromancer's align drop -Boogums*/
  )
d6519 2
a6520 3
  
  if( (!is_affected(ch, skill_lookup("indulgence") ))
    ) 
d6560 1
a6560 3

  if(!is_affected(ch, skill_lookup("indulgence"))
    )
d6749 1
a6749 2
  if(!is_affected(ch, skill_lookup("indulgence"))
    ) 
@


1.290
log
@21DEC00
Ahhhh it's gotta be !=
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.289 2000/12/22 04:46:53 mud Exp $";
d6455 1
a6455 2
    || (ch->kit != kit_lookup("necromancer"))
    )
d6523 1
a6523 2
    || (ch->kit != kit_lookup("necromancer") )
     )
a6564 1
    || (ch->kit != kit_lookup("necromancer"))
d6755 1
a6755 2
    || (ch->kit != kit_lookup("necromancer"))
    )
@


1.289
log
@21DEC00
Hmmm, that didn't work, let's try this
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.288 2000/12/22 04:35:30 mud Exp $";
d6524 1
a6524 1
    || (ch->kit == kit_lookup("necromancer") )
@


1.288
log
@21DEC00
Yahoo, doing the align check on necro's
testing with summon dead spell
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.287 2000/12/21 05:37:39 mud Exp $";
d6523 3
a6525 3
  if(!is_affected(ch, skill_lookup("indulgence"))
    || ch->kit != kit_lookup("necromancer") 
    ) 
@


1.287
log
@20DEC00
One final tweak on it
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.286 2000/12/21 05:30:57 mud Exp $";
d6524 1
a6524 1
    || (ch->kit != kit_lookup("necromancer")) 
@


1.286
log
@20DEC00
Ok i think i got it so necro's can summon more dead
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.285 2000/12/17 05:12:28 mud Exp $";
d6483 1
a6483 1
  if ( (ch->kit == kit_lookup("necromancer")) && (count > (ch->level/6)) && !IS_IMMORTAL(ch) )
@


1.285
log
@16DEC00
Tweaked teh vamp code a bit, only took about 18 hours for a weapon
to et flagged
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.284 2000/12/15 05:19:37 mud Exp $";
d6489 1
a6489 1
  if ( ((count > (ch->level/10)) && !IS_IMMORTAL(ch))  ) 
@


1.284
log
@14DEC00
had one more little check to do, now here goes teh necromancer kit
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.283 2000/12/13 05:03:41 mud Exp $";
d6483 5
d6489 2
a6490 1
  if ((count > (ch->level/10)) && !IS_IMMORTAL(ch)) {
d6524 2
a6525 2
    || (ch->kit != kit_lookup("necromancer"))
    )
@


1.283
log
@12DEC00
Yahoo, now testing the do_kill code
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.282 2000/12/13 04:44:09 mud Exp $";
d803 1
a803 1
      if ( IS_AFFECTED(ch,skill_lookup("wraithform")) )
@


1.282
log
@12DEC00
I'll take the award for "whoops" this year.
Got it figured out...
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.281 2000/12/13 04:39:24 mud Exp $";
d751 1
a751 1
    send_to_char("They are made of mist.\r\n.",ch);
@


1.281
log
@12DEC00
Curious why is_affected(ch,skill_lookup"wraithform") freaks it out
unless by default they are *shrug* dunno how that's happening
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.280 2000/12/13 04:21:38 mud Exp $";
d748 2
a749 2
  /*Wraithform check-Boogums
  if (IS_AFFECTED(victim,skill_lookup("wraithform")))
a753 1
  */
@


1.280
log
@12DEC00
whoops, that didn't work.  taking it out now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.279 2000/12/13 04:17:30 mud Exp $";
d497 2
a498 2
    /*added for wraith form check 25NOV00 - Boogums
    if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
d502 2
a503 2
    }
  */ 
@


1.279
log
@12DEC00
Ok, am now checking to see if they are in wraithform when casting
and being cast upon
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.278 2000/12/13 04:10:22 mud Exp $";
d497 1
a497 1
    /*added for wraith form check 25NOV00 - Boogums*/
d503 1
a503 1
   
d748 1
a748 1
  /*Wraithform check-Boogums*/
d754 1
@


1.278
log
@12DEC00
Starting wraithform again, this time much slower.  Adding the spell
and going to see if it is castable.  Also looking for any weird affects
on mobs.
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.276 2000/12/07 05:46:13 mud Exp $";
d497 1
a497 1
    /*added for wraith form check 25NOV00 - Boogums
a502 1
    */
d748 1
a748 1
  /*Wraithform check-Boogums
d751 1
a751 1
    send_to_char("They are made of mist and you can not aim your spell.\r\n.",ch);
a753 1
*/
@


1.277
log
@08DEC00
DAMN this wraithform it's gone now :)
=Boogums
@
text
@d497 7
d749 7
d804 7
a810 1

@


1.276
log
@06DEC00
Ok no AFF_WRAITHFORM had to change those to skill_lookups
compiled clean testing now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.275 2000/12/06 20:42:39 mud Exp $";
a496 6
    /*added for wraith form check 25NOV00 - Boogums*/
    if( IS_AFFECTED(ch,skill_lookup("wraithform")) )
    {
      send_to_char("You cannot cast while affected by wraith form.\n\r",ch);
      return;
    }
a741 7
  /*Wraithform check-Boogums*/
  if (IS_AFFECTED(victim,skill_lookup("wraithform")))
  {
    send_to_char("They are made of mist and you can not aim your spell.\r\n.",ch);
    return FALSE;
  }

a789 6
      /*another wraithform check -Boogums*/
      if ( IS_AFFECTED(ch,skill_lookup("wraithform")) )
      {
        send_to_char("Your spell has no affect on them.\r\n",ch);
	return FALSE;
      }
@


1.275
log
@05dec00
took out feign death
-boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.274 2000/12/03 22:52:29 mud Exp $";
d498 1
a498 1
    if( IS_AFFECTED(ch,AFF_WRAITHFORM) )
d749 1
a749 1
  if (IS_AFFECTED(victim,AFF_WRAITHFORM))
d804 1
a804 1
      if ( IS_AFFECTED(ch,AFF_WRAITHFORM) )
d6456 1
a6456 1
    || (ch->kit== kit_lookup("necromancer"))
d6519 1
a6519 1
    || (ch->kit== kit_lookup("necromancer"))
d6562 1
a6562 1
    || (ch->kit== kit_lookup("necromancer"))
d6753 1
a6753 1
    || (ch->kit== kit_lookup("necromancer"))
@


1.274
log
@03dec00
let's try it here
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.273 2000/12/03 22:39:29 mud Exp $";
d6650 1
a6650 1

d6675 1
a6675 1

@


1.273
log
@03DEC00
The hunt for casting against someone in wraithform and not crashing
the game continues
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.272 2000/12/03 20:21:10 mud Exp $";
d503 1
a503 1

a722 7
  /*Ok, here goes the WRAITHFORM check -Boogums*/
      if( IS_AFFECTED(victim,AFF_WRAITHFORM) )
      {
	send_to_char( "Your spell has no affect on them.\r\n",ch);
	return FALSE;
      }

d746 7
@


1.272
log
@03DEC00
Crash bug when casting on someeone with wraithform
checking fix now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.271 2000/12/03 19:29:58 mud Exp $";
d723 1
a723 1
  /*Ok, here goes the WRAITHFORM check -Boogums
a728 1
   */
@


1.271
log
@03DEC00
DOH crash bug in do_cast, forgot to return, bad boogums bad
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.270 2000/12/03 03:24:03 mud Exp $";
d723 1
a723 1
  /*Ok, here goes the WRAITHFORM check -Boogums*/
d729 1
@


1.270
log
@2DEC00 - Ok here goes teh necromancer kit.  changes in act_info.c act_move.c
         act_obj.c const.c figt.c mag2.c magic.c magic.h merc.h update.c
	 all sorts of cool stuff
	 -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.269 2000/11/27 17:14:14 mud Exp $";
d501 1
@


1.269
log
@switch || to && on say_spell
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.268 2000/11/27 17:10:44 mud Exp $";
d474 1
a474 1
	if ( ch->alignment <= -251 && ch->alignment >= -300)
d476 1
a476 1
	if ( ch->alignment <= -301 && ch->alignment >= -450)
d478 1
a478 1
	if ( ch->alignment <= -451 && ch->alignment >= -750)
a479 4
	if ( ch->alignment <= -751 && ch->alignment >= -949)
          level=level+4;
	if ( ch->alignment <= -950 && ch->alignment >= -1000)
          level=level+5;
d497 5
a710 1

d722 7
d802 7
@


1.268
log
@fix ventriloquate maybe?
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.267 2000/11/19 19:01:56 mud Exp $";
d962 2
a963 2
    if ( !str_cmp( skill_table[sn].name, "ventriloquate" ) ||
	 !str_cmp( skill_table[sn].name, "mirror image" ) )
@


1.267
log
@19NOV00
DOH!!! Forgot to put return in that mirror image check.  my bad
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.266 2000/11/19 18:56:25 mud Exp $";
d962 2
a963 2
    if ( str_cmp( skill_table[sn].name, "ventriloquate" ) ||
	 str_cmp( skill_table[sn].name, "mirror image" ) )
@


1.266
log
@19NOV00
Added a change to mirror image spell.  Now it does a check to see if they're
mounted on a warhorse or not.  If so, it won't allow them to cast.
Also hoping the necromancer stuff i have in fight.c doesn't affect game play :)
it *shouldn't* but you never know ;)
ttfn
Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.265 2000/10/16 19:17:02 mud Exp $";
d6858 1
@


1.265
log
@ added in second avarice clan skill
 fixed bug in indulgence
 added in functionality for "sanction skill"
 -rage
 :wq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.264 2000/09/24 16:32:00 mud Exp $";
d388 2
d449 36
d1546 6
d2012 5
a2016 1

d6439 7
a6445 2
  if(!is_affected(ch, skill_lookup("indulgence")))
  ch->alignment = UMAX(-1000, ch->alignment - number_range (50,100));
d6503 6
a6508 2
  if(!is_affected(ch, skill_lookup("indulgence")))
  ch->alignment = UMAX(-1000, ch->alignment - number_range (50,70));
d6546 3
a6548 1
  if(!is_affected(ch, skill_lookup("indulgence")))
d6737 3
a6739 1
  if(!is_affected(ch, skill_lookup("indulgence")))
d6855 5
a6859 1
  
@


1.264
log
@24SEP00 -
Added the charm_animal spell.  Mods made to const.c db.c mag2.c and magic.h
aaaand magic.c
Going to compile on OLC and test
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.263 2000/09/02 03:27:37 mud Exp $";
d955 1
a955 1
       if (ch->clan == clan_lookup("warlock"))
@


1.263
log
@ng elves natural magic resistance
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.262 2000/08/20 00:11:26 mud Exp $";
d6842 1
@


1.262
log
@highlander bugs and loggins some highlander stuff
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.261 2000/08/19 23:39:02 mud Exp $";
d249 2
a264 1
    if( victim->race == race_lookup("elf") ) saving_throw -= 5;
d280 2
a281 2
  case IS_RESISTANT:  save -= 15;  break;
  case IS_VULNERABLE: save += 15;  break;
@


1.261
log
@missing some ()
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.260 2000/08/19 23:38:08 mud Exp $";
a547 3

   sprintf(buf,"past for loop %d",sn);
   log_string(buf);
@


1.260
log
@bugs in quicken
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.259 2000/08/19 23:29:02 mud Exp $";
d543 1
a543 1
   if(sn = skill_lookup(arg1) == -1)
@


1.259
log
@debugging quicken
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.258 2000/08/19 23:24:49 mud Exp $";
d543 1
a543 1
   for ( sn = 0; sn < MAX_SKILL; sn++ )
d545 2
a546 5
   sprintf(buf,"in for loop %d",sn);
   log_string(buf);
      if (LOWER(arg1[0]) == LOWER(skill_table[sn].name[0])
          &&  !str_prefix(arg1,skill_table[sn].name))
	 break;
@


1.258
log
@debugging quicken
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.257 2000/08/19 23:22:09 mud Exp $";
d545 2
@


1.257
log
@track down crash bug in highlander
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.256 2000/08/19 22:34:54 mud Exp $";
d540 1
a540 3
   spell = LOWER(arg1[0]);

   sprintf(buf,"%s is quickening %s at %s",ch->name,spell,target_name);
d545 2
a546 2
      if (spell == LOWER(skill_table[sn].name[0])
          &&  !str_prefix(spell,skill_table[sn].name))
@


1.256
log
@highlanders can not entrance or charm
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.255 2000/08/19 22:29:03 mud Exp $";
d511 1
d537 1
a537 1
   if (!strcmp(arg2,"self"))
d540 3
a542 1
   sprintf(buf,"%s is quickening %s at %s",ch->name,arg1,arg2);
d547 2
a548 2
      if (LOWER(arg1[0]) == LOWER(skill_table[sn].name[0])
          &&  !str_prefix(arg1,skill_table[sn].name))
d552 3
d563 1
a563 1
   if (arg2[0] != '\0' && !is_name( target_name, ch->name ) &&
@


1.255
log
@heat metal, rust things dont work o highaldners
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.254 2000/08/19 21:56:27 mud Exp $";
d1953 1
a1953 1
    if (IS_SET(ch->mhs,MHS_HIGHLANDER) && IS_NPC(victim))
d1955 1
a1955 1
       send_to_char("Honorable combat is one on one. Highlanders can not charm monsters.\n\r",ch);
d5619 5
@


1.254
log
@new highlander code -poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.253 2000/08/18 22:58:58 mud Exp $";
d4321 6
@


1.253
log
@missing )
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.252 2000/08/18 22:49:04 mud Exp $";
d2762 2
a2763 1
    if (IS_SET(victim->mhs,MHS_GLADIATOR) && !IS_NPC(victim)) 
d5649 6
@


1.252
log
@Highlanders Abound
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.251 2000/08/18 21:38:03 mud Exp $";
d5799 1
a5799 1
	  (is_clan(victim) || IS_SET(ch->mhs,MHS_HIGHLANDER))
@


1.251
log
@reverse the strcmp
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.250 2000/08/18 21:21:41 mud Exp $";
d5799 1
a5799 1
	  is_clan(victim))
@


1.250
log
@fix that last bug in Highlander with quicken self maybe?
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.249 2000/08/01 18:07:18 mud Exp $";
d536 1
a536 1
   if (strcmp(arg2,"self"))
@


1.249
log
@Small changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.248 2000/07/31 22:15:00 mud Exp $";
d535 3
@


1.248
log
@Exited 'remove curse' if sucessful with removing the
curse on someone without trashing their gear.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.247 2000/07/27 00:19:59 mud Exp $";
d267 1
a267 1
        save -= ( get_skill(victim,gsn_weave_resistance) / 10 );
d1029 1
a1029 1
	number_percent() < get_skill(victim,gsn_weave_resistance)/11 )
@


1.247
log
@lower dispel even more
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.246 2000/07/24 18:48:47 mud Exp $";
d5500 1
@


1.246
log
@gladiaotr blind and sleep max at 3 ticks
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.245 2000/07/22 21:20:15 mud Exp $";
d2760 1
a2760 1
       lower_level = 33;
@


1.245
log
@glads cant cast offensive spells at themselves
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.244 2000/07/22 20:31:51 mud Exp $";
d1381 4
a1384 1
    af.duration  = 1+level/4;
d5664 4
a5667 1
    af.duration  = level / 5;
@


1.244
log
@gladiators hlower dispell levels faster
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.243 2000/07/21 23:45:27 mud Exp $";
d686 1
a686 2
/*
        if ( ch == victim )
d688 1
a688 1
            send_to_char( "You can't do that to yourself.\n\r", ch );
a690 1
*/
@


1.243
log
@glads can not quaff or withstand or orb after arena starts
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.242 2000/07/18 23:00:13 mud Exp $";
d2747 1
d2758 5
d2767 1
a2767 1
	if(number_percent() > 66 ) level--;
d2779 1
a2779 1
	if(number_percent() > 66) level--;
d2790 1
a2790 1
	if(number_percent() > 66) level--;
d2802 1
a2802 1
	if(number_percent() > 66) level--;
d2842 1
a2842 1
	if(number_percent() > 66) level--;
d2848 1
a2848 1
	if(number_percent() > 66) level--;
d2854 1
a2854 1
	if(number_percent() > 66) level--;
d2860 1
a2860 1
	if(number_percent() > 66) level--;
d2866 1
a2866 1
	if(number_percent() > 66) level--;
d2888 1
a2888 1
	if(number_percent() > 66) level--;
d2895 1
a2895 1
	if(number_percent() > 66) level--;
d2905 1
a2905 1
	if(number_percent() > 66) level--;
d2912 1
a2912 1
	if(number_percent() > 66) level--;
d2918 1
a2918 1
	if(number_percent() > 66) level--;
d2925 1
a2925 1
	if(number_percent() > 66) level--;
d2935 1
a2935 1
	if(number_percent() > 66) level--;
d2941 1
a2941 1
	if(number_percent() > 66) level--;
d2948 1
a2948 1
	if(number_percent() > 66) level--;
d2954 1
a2954 1
	if(number_percent() > 66) level--;
d2960 1
a2960 1
	if(number_percent() > 66) level--;
d2968 1
a2968 1
	if(number_percent() > 66) level--;
d2985 1
a2985 1
	if(number_percent() > 66) level--;
d3001 1
a3001 1
	if(number_percent() > 66) level--;
@


1.242
log
@missing () on number_percent function
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.241 2000/07/18 22:47:05 mud Exp $";
d6624 7
@


1.241
log
@add spells for glad messages or vice versa
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.240 2000/07/18 22:45:03 mud Exp $";
d3019 1
a3019 1
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && number_percent < 50)
@


1.240
log
@adding some glad messages to spells
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.239 2000/07/18 19:08:29 mud Exp $";
d3011 1
a3011 1
       sprintf(buf,"% invokes a red aura around %, removing his protections.",ch->name,victim->name);
@


1.239
log
@comment out the gladiator in blind
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.238 2000/07/18 18:48:45 mud Exp $";
d1350 1
d1371 1
a1371 1
    /* Gladiator Spectator Channel 
d1374 1
a1374 1
       sprintf(buf,"%s %s. ",ch->name,victim->name);
a1376 1
    */
d2746 1
d3006 1
d3008 7
d3016 1
d3018 7
@


1.238
log
@splitting out gladiator plays
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.237 2000/07/17 21:00:41 mud Exp $";
d1370 1
a1370 1
    /* Gladiator Spectator Channel */
d1376 1
@


1.237
log
@Threw in some {} around nested if()'s to remove compiler warnings.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.236 2000/07/17 20:56:28 mud Exp $";
d1370 6
@


1.236
log
@Put confusion affect in spell_cancellation() and spell_dispel_magic()
in addition to it being stripable with cure_disease().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.235 2000/06/30 02:23:41 mud Exp $";
d1127 1
d1135 1
d3020 1
d3025 1
@


1.235
log
@warlocks get a mesage when they concnetrate harder
-poQ
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.234 2000/06/29 23:52:38 mud Exp $";
d1615 6
d2813 6
@


1.234
log
@heat metal eq in glads just goes into inv
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.233 2000/06/28 02:37:58 mud Exp $";
d957 2
@


1.233
log
@ Removal of restriction on using blind and confusion together
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.232 2000/06/28 01:21:11 mud Exp $";
d4298 4
a4301 1
                        obj_to_room(obj_lose, victim->in_room);
d4323 4
a4326 1
                        obj_to_room(obj_lose, victim->in_room);
d4354 4
a4357 1
      obj_to_room(obj_lose,victim->in_room);
d4378 4
a4381 1
                        obj_to_room(obj_lose, victim->in_room);
@


1.232
log
@ Added in Demise clan skill confusion
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.231 2000/06/27 04:21:41 mud Exp $";
a1364 6
    if ( is_affected (victim, gsn_confusion))
    {
      affect_strip(victim, gsn_confusion);
      act("$n appears to be less confused.\n\r", victim, NULL, NULL, TO_NOTVICT,FALSE);
      send_to_char("You feel like you can think clearly again.\n\r", victim);
    }
@


1.231
log
@ added in a littel extra functionality to indulgence
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.230 2000/06/26 04:20:30 mud Exp $";
d2269 2
a2270 1
	 !is_affected( victim, gsn_irradiate ) )
d2296 7
a2302 1
 
d2357 1
@


1.230
log
@can not faerie fog in prep room of gladiators
added withstand death message on glad spectator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.229 2000/06/21 21:37:09 mud Exp $";
d2473 2
a2474 1

d3599 1
a3599 1
    if (victim != ch)
d5287 1
d6301 2
d6360 2
d6398 3
d6582 1
@


1.229
log
@ Fixed some typoes in confusion
 Fixed bug in cure vision
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.228 2000/06/20 22:39:32 mud Exp $";
d3742 6
@


1.228
log
@message if already in withstand when you try to cast it on yourself
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.227 2000/06/18 20:48:17 mud Exp $";
d1368 2
a1369 2
      act("$n appears to be less confused", victim, NULL, NULL, TO_NOTVICT,FALSE);
      send_to_char("You feel like you can think clearly again\n\r", victim);
@


1.227
log
@declare clan_lookup
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.226 2000/06/18 20:36:06 mud Exp $";
d6551 4
a6554 1
  return;
@


1.226
log
@Warlock clan skil
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.225 2000/05/29 20:03:29 mud Exp $";
d48 1
@


1.225
log
@fix calm spell in prep room and add gladiator.h
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.224 2000/05/25 02:01:17 mud Exp $";
d585 1
d950 1
a950 1
    if ( number_percent( ) > spell_skill )
d952 25
a976 14
  send_to_char( "You lost your concentration.\n\r", ch );
  check_improve(ch,sn,FALSE,1);
  if ( number_percent() < get_skill(ch,gsn_spellcraft) )
  {
	ch->mana -= ( mana / 4 );
	if ( spell_skill > 1 )
	    check_improve(ch,gsn_spellcraft,TRUE,6);
  }
  else
  {
  	if ( spell_skill > 1 )
		check_improve(ch,gsn_spellcraft,FALSE,8);
  ch->mana -= mana / 2;
  }
d980 1
a980 1
     ch->mana -= mana;
d982 7
a988 7
     if( target == TARGET_CHAR && victim != NULL && victim != ch 
	&& is_affected(victim, skill_lookup("orb of turning")) )
     {
	send_to_char("Your spell encounters an orb of turning.\n\r",ch);
	blow_orb(victim,skill_lookup("orb of turning"));
	return TRUE;
     }
d990 19
a1008 19
     level = compute_casting_level( ch );
     if( iWyrm ) level += 2;
     if( fFocus )
     {
       int dam;
       dam = ((get_skill(ch, gsn_focus)+5) /20) - (4 - ch->level/10);
       level += dam;

       /* Curve it */
       if ( level > 53 )
	   level = ( level - 53 ) / 2 + 53;

       if ( level > 56 )
	   level = ( level - 56 ) / 2 + 56;

       dam += mana * dam;
       dam = UMAX(dam,0);
       damage(ch,ch,dam,0,DAM_MENTAL, FALSE,FALSE);
     }
@


1.224
log
@ Added in knight kit basics
 Removed vision check from blindness spell
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.223 2000/05/23 04:19:47 mud Exp $";
d32 1
d1461 2
a1462 1
    if (IS_SET(ch->mhs,MHS_GLADIATOR) && ch->in_room == ROOM_VNUM_SINGLE_GLADIATOR)
@


1.223
log
@no calm n prep room
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.222 2000/05/21 02:31:55 mud Exp $";
a1334 2
    if ( is_affected(victim,gsn_vision) )
	level /= 2;
@


1.222
log
@gladiators can not summon mobs, gate, summon elementals, charm or entrance
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.221 2000/05/21 00:28:57 mud Exp $";
d1460 7
@


1.221
log
@fix gladiator update
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.220 2000/05/19 13:44:02 mud Exp $";
d1923 5
d4009 6
d5514 5
d5709 6
d6202 6
d6287 5
@


1.220
log
@ more adjustments to alchemy, as well as removeing CODE_TES #ifdef's
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.219 2000/05/16 22:55:12 mud Exp $";
a728 1
#ifdef CODE_TEST
a737 1
#endif
@


1.219
log
@ fixed bug in haste
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.218 2000/05/16 21:26:30 mud Exp $";
d242 1
a242 1
    if (saving_throw < -16 && is_affected(victim,gsn_magic_resistance))
d244 1
a244 1
    saving_throw = ( saving_throw + 16 ) / 3 - 16;
@


1.218
log
@ Added in a conversion for ITEM_GRENADE and changed haste so you cannot be hasted and use speed potion.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.217 2000/05/16 20:33:10 mud Exp $";
d4160 1
a4160 1
    ||   IS_SET(victim->off_flags,OFF_FAST) || is_affected(victim, skill_lookup("speed"))
@


1.217
log
@Changed free_aff(paf) in enchant_armor() and enchant_weapon() to
affect_remove_obj( obj, paf ) in order to strip the affect's
bitvectors before freeing the affect.  No more super weapons using
a fade.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.216 2000/05/16 00:56:01 mud Exp $";
d4160 1
a4160 1
    ||   IS_SET(victim->off_flags,OFF_FAST))
@


1.216
log
@add in all the #ifdef CODE_TEST for gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.215 2000/05/14 00:27:54 mud Exp $";
d3194 1
a3194 1
      free_affect(paf);
d3435 1
a3435 1
      free_affect(paf);
@


1.215
log
@declare buf for use in gladiator
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.214 2000/05/13 22:37:25 mud Exp $";
d729 1
a729 1

d739 1
@


1.214
log
@cleaning up the declarations for gladiator talk
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.213 2000/05/13 21:55:15 mud Exp $";
d584 1
@


1.213
log
@Gladiator Combat - Intense!
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.212 2000/05/01 21:03:35 mud Exp $";
d735 1
a735 1
        do_gladiatortalk(buf);
@


1.212
log
@removed last of the age code, druids dont get a +1 for age, they
already get a +1 for > 25 level and +1 for greater then 50 level
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.211 2000/04/18 20:40:12 mud Exp $";
d727 10
@


1.211
log
@yippe, 2 more act() typos
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.210 2000/04/18 20:33:51 mud Exp $";
a401 1
       level += (get_age(ch) > 40 );
@


1.210
log
@fixed act ( entries
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.209 2000/04/18 19:51:03 mud Exp $";
d205 1
a205 1
	act( buf, ch, NULL, rch, TO_VICT,FALSE,FALSE);
d208 1
a208 1
      act( ch->class==rch->class ? buf : buf2, ch, NULL, rch, TO_VICT ,FALSE,FALSE);
d1872 1
a1872 1
    act("$N has already had $s(?,FALSE) sex changed.",ch,NULL,victim,TO_CHAR);
@


1.209
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.208 2000/04/17 22:00:50 mud Exp $";
d6377 1
a6377 1
  	act ("$n seems unaffected.",gch,NULL,NULL,TO_ROOM);
d6380 1
a6380 1
    	act ("$n twitches and attacks!",gch,NULL,NULL,TO_ROOM);
d6392 1
a6392 1
  act ("$n twitches violently and crumbles into dust.",gch,NULL,NULL,TO_ROOM);
@


1.208
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.207 2000/03/24 16:23:01 mud Exp $";
d205 1
a205 1
	act( buf, ch, NULL, rch, TO_VICT);
d208 1
a208 1
      act( ch->class==rch->class ? buf : buf2, ch, NULL, rch, TO_VICT );
d1217 1
a1217 1
    act("$N is already armored.",ch,NULL,victim,TO_CHAR);
d1230 1
a1230 1
  act("$N is protected by your magic.",ch,NULL,victim,TO_CHAR);
d1248 1
a1248 1
      act("$p is already blessed.",ch,obj,NULL,TO_CHAR);
d1261 1
a1261 1
    act("$p glows a pale blue.",ch,obj,NULL,TO_ALL);
d1268 1
a1268 1
        ch,obj,NULL,TO_CHAR);
d1282 1
a1282 1
  act("$p glows with a holy aura.",ch,obj,NULL,TO_ALL);
d1295 1
a1295 1
    act("$N already has divine favor.",ch,NULL,victim,TO_CHAR);
d1313 1
a1313 1
  act("You grant $N the favor of your god.",ch,NULL,victim,TO_CHAR);
d1332 1
a1332 1
	   act("$N is already blinded.",ch,NULL,victim,TO_CHAR);
d1347 1
a1347 1
      act("$n appears to be less confused", victim, NULL, NULL, TO_NOTVICT);
d1361 1
a1361 1
    act("$n appears to be {Gblinded{x.",victim,NULL,NULL,TO_ROOM);
d1417 1
a1417 1
  ch, NULL, NULL, TO_ROOM );
d1557 1
a1557 1
        act("$n is no longer blinded.",victim,NULL,NULL,TO_ROOM);
d1563 1
a1563 1
	act("$n regains a fleshy texture.",victim,NULL,NULL,TO_ROOM);
d1569 1
a1569 1
  act("$n no longer looks so peaceful...",victim,NULL,NULL,TO_ROOM);
d1575 1
a1575 1
        act("$n looks more like $mself again.",victim,NULL,NULL,TO_ROOM);
d1581 1
a1581 1
        act("$n regains $s free will.",victim,NULL,NULL,TO_ROOM);
d1587 1
a1587 1
        act("$n looks warmer.",victim,NULL,NULL,TO_ROOM);
d1596 1
a1596 1
        act("$n can be touched.",victim,NULL,NULL,TO_ROOM);
d1629 1
a1629 1
        act("$n's purple cloud fades.",victim,NULL,NULL,TO_ROOM);
d1635 1
a1635 1
        act("$n's outline fades.",victim,NULL,NULL,TO_ROOM);
d1641 1
a1641 1
        act("$n falls to the ground!",victim,NULL,NULL,TO_ROOM);
d1647 1
a1647 1
  act("$n no longer looks so wild.",victim,NULL,NULL,TO_ROOM);;
d1656 1
a1656 1
        act("$n no longer looks so mighty.",victim,NULL,NULL,TO_ROOM);
d1662 1
a1662 1
  act("$n is no longer moving so quickly.",victim,NULL,NULL,TO_ROOM);
d1671 1
a1671 1
        act("$n fades into existance.",victim,NULL,NULL,TO_ROOM);
d1680 1
a1680 1
        act("$n fades into existance.",victim,NULL,NULL,TO_ROOM);
d1699 1
a1699 1
            victim,NULL,NULL,TO_ROOM);
d1705 1
a1705 1
        act("The shield protecting $n vanishes.",victim,NULL,NULL,TO_ROOM);
d1714 1
a1714 1
        act("$n is no longer moving so slowly.",victim,NULL,NULL,TO_ROOM);
d1720 1
a1720 1
        act("$n's skin regains its normal texture.",victim,NULL,NULL,TO_ROOM);
d1726 1
a1726 1
        act("$n looks stronger.",victim,NULL,NULL,TO_ROOM);
d1732 1
a1732 1
        act("$n no longer looks more powerful than death.",victim,NULL,NULL,TO_ROOM);
d1795 1
a1795 1
        ch,NULL,victim,TO_ROOM);
d1797 1
a1797 1
  ch,NULL,victim,TO_CHAR);
d1799 1
a1799 1
  ch,NULL,victim,TO_VICT);  
d1822 2
a1823 2
      act("The bolt arcs to $n!",tmp_vict,NULL,NULL,TO_ROOM);
      act("The bolt hits you!",tmp_vict,NULL,NULL,TO_CHAR);
d1840 1
a1840 1
      act("The bolt seems to have fizzled out.",ch,NULL,NULL,TO_ROOM);
d1842 1
a1842 1
    ch,NULL,NULL,TO_CHAR);
d1847 1
a1847 1
    act("The bolt arcs to $n...whoops!",ch,NULL,NULL,TO_ROOM);
d1872 1
a1872 1
    act("$N has already had $s(?) sex changed.",ch,NULL,victim,TO_CHAR);
d1890 1
a1890 1
    act("$n doesn't look like $mself anymore...",victim,NULL,NULL,TO_ROOM);
d1959 1
a1959 1
    act( "Isn't $n just so nice?", ch, NULL, victim, TO_VICT );
d1961 1
a1961 1
  act("$N looks at you with adoring eyes.",ch,NULL,victim,TO_CHAR);
d1987 1
a1987 1
  act("$n turns blue and shivers.",victim,NULL,NULL,TO_ROOM);
d2053 1
a2053 1
      act("$p is already glowing.",ch,light,NULL,TO_CHAR);
d2058 1
a2058 1
  act("$p glows with a white light.",ch,light,NULL,TO_ALL);
d2064 2
a2065 2
    act( "$n twiddles $s thumbs and $p appears.",   ch, light, NULL, TO_ROOM );
    act( "You twiddle your thumbs and $p appears.", ch, light, NULL, TO_CHAR );
d2094 2
a2095 2
    act( "$p suddenly appears.", ch, mushroom, NULL, TO_ROOM );
    act( "$p suddenly appears.", ch, mushroom, NULL, TO_CHAR );
d2103 1
a2103 1
    act("$n has created a beautiful red rose.",ch,rose,NULL,TO_ROOM);
d2118 2
a2119 2
    act( "$p materializes before you.",ch,fount,NULL,TO_CHAR);
    act( "$p materializes before you.",ch,fount,NULL,TO_ROOM);
d2130 2
a2131 2
    act( "$p flows from the ground.", ch, spring, NULL, TO_ROOM );
    act( "$p flows from the ground.", ch, spring, NULL, TO_CHAR );
d2171 1
a2171 1
  act( "$p is filled.", ch, obj, NULL, TO_CHAR );
d2188 1
a2188 1
          act("$N doesn't appear to be blinded.",ch,NULL,victim,TO_CHAR);
d2199 1
a2199 1
        act("$n is no longer blinded.",victim,NULL,NULL,TO_ROOM);
d2240 1
a2240 1
          act("$N doesn't appear to be diseased.",ch,NULL,victim,TO_CHAR);
d2251 1
a2251 1
  act("$n looks relieved as $s sores vanish.",victim,NULL,NULL,TO_ROOM);
d2258 1
a2258 1
  act("$n appears to hvae regained $s health.",victim,NULL,NULL,TO_ROOM);
d2300 1
a2300 1
          act("$N doesn't appear to be poisoned.",ch,NULL,victim,TO_CHAR);
d2311 1
a2311 1
        act("$n looks much better.",victim,NULL,NULL,TO_ROOM);
d2352 1
a2352 1
            act("$p is already filled with evil.",ch,obj,NULL,TO_CHAR);
d2365 1
a2365 1
                act("$p glows with a red aura.",ch,obj,NULL,TO_ALL);
d2372 1
a2372 1
                    ch,obj,NULL,TO_CHAR);
d2386 1
a2386 1
        act("$p glows with a malevolent aura.",ch,obj,NULL,TO_ALL);
d2396 1
a2396 1
          act("$N is already cursed.",ch,NULL,victim,TO_CHAR);
d2423 1
a2423 1
  act("$N looks very uncomfortable.",ch,NULL,victim,TO_CHAR);
d2445 1
a2445 1
      ch,NULL,victim,TO_ROOM);
d2447 1
a2447 1
      ch,NULL,victim,TO_VICT);
d2467 1
a2467 1
    act("$N can already detect evil.",ch,NULL,victim,TO_CHAR);
d2495 1
a2495 1
          act("$N can already detect good.",ch,NULL,victim,TO_CHAR);
d2524 1
a2524 1
          act("$N can already sense hidden lifeforms.",ch,NULL,victim,TO_CHAR);
d2553 1
a2553 1
          act("$N can already see invisible things.",ch,NULL,victim,TO_CHAR);
d2583 1
a2583 1
          act("$N can already detect magic.",ch,NULL,victim,TO_CHAR);
d2634 1
a2634 1
  act( "$N is protected by $s deity.", ch, NULL, victim, TO_ROOM );
d2640 1
a2640 1
  act( "$N does not seem to be affected.", ch, NULL, victim, TO_CHAR );
d2665 1
a2665 1
        act( "$N is protected by $S evil.", ch, NULL, victim, TO_ROOM );
d2671 1
a2671 1
        act( "$N does not seem to be affected.", ch, NULL, victim, TO_CHAR );
d2709 3
a2711 3
		ch,NULL,victim,TO_VICT);
	act("$N cries out in pain!",ch,NULL,victim,TO_CHAR);
	act("$N cries out in pain!",ch,NULL,victim,TO_NOTVICT);
d2736 1
a2736 1
        act("$n is no longer blinded.",victim,NULL,NULL,TO_ROOM);
d2743 1
a2743 1
	act("$n regains a fleshy texture.",victim,NULL,NULL,TO_ROOM);
d2749 1
a2749 1
        act("$n no longer looks so peaceful...",victim,NULL,NULL,TO_ROOM);
d2755 1
a2755 1
        act("$n looks more like $mself again.",victim,NULL,NULL,TO_ROOM);
d2761 1
a2761 1
        act("$n regains $s free will.",victim,NULL,NULL,TO_ROOM);
d2767 1
a2767 1
        act("$n looks warmer.",victim,NULL,NULL,TO_ROOM);
d2808 1
a2808 1
        act("$n's purple cloud fades.",victim,NULL,NULL,TO_ROOM);
d2814 1
a2814 1
        act("$n's outline fades.",victim,NULL,NULL,TO_ROOM);
d2820 1
a2820 1
        act("$n falls to the ground!",victim,NULL,NULL,TO_ROOM);
d2827 1
a2827 1
        act("$n no longer looks so wild.",victim,NULL,NULL,TO_ROOM);;
d2837 1
a2837 1
        act("$n no longer looks so mighty.",victim,NULL,NULL,TO_ROOM);
d2844 1
a2844 1
        act("$n is no longer moving so quickly.",victim,NULL,NULL,TO_ROOM);
d2857 1
a2857 1
        act("$n fades into existance.",victim,NULL,NULL,TO_ROOM);
d2867 1
a2867 1
        act("$n fades into existance.",victim,NULL,NULL,TO_ROOM);
d2900 1
a2900 1
            victim,NULL,NULL,TO_ROOM);
d2911 1
a2911 1
            victim,NULL,NULL,TO_ROOM);
d2917 1
a2917 1
        act("The shield protecting $n vanishes.",victim,NULL,NULL,TO_ROOM);
d2927 1
a2927 1
        act("$n is no longer moving so slowly.",victim,NULL,NULL,TO_ROOM);
d2933 1
a2933 1
        act("$n's skin regains its normal texture.",victim,NULL,NULL,TO_ROOM);
d2940 1
a2940 1
        act("$n looks stronger.",victim,NULL,NULL,TO_ROOM);
d2957 1
a2957 1
    act( "$n makes the earth tremble and shiver.", ch, NULL, NULL, TO_ROOM );
d3009 2
a3010 2
	act("$p wavers... and crumbles to dust!",ch,obj,NULL,TO_CHAR);
	act("$p wavers... and crumbles to dust!",ch,obj,NULL,TO_ROOM);
d3064 2
a3065 2
    act("$n warps $p to a new size.",ch,obj,NULL,TO_ROOM);
    act("You warp $p to a new size.",ch,obj,NULL,TO_CHAR);
d3165 2
a3166 2
  act("$p flares blindingly... and evaporates!",ch,obj,NULL,TO_CHAR);
  act("$p flares blindingly... and evaporates!",ch,obj,NULL,TO_ROOM);
d3175 2
a3176 2
  act("$p glows brightly, then fades...oops.",ch,obj,NULL,TO_CHAR);
  act("$p glows brightly, then fades.",ch,obj,NULL,TO_ROOM);
d3223 2
a3224 2
  act("$p shimmers with a gold aura.",ch,obj,NULL,TO_CHAR);
  act("$p shimmers with a gold aura.",ch,obj,NULL,TO_ROOM);
d3232 2
a3233 2
  act("$p glows a {Ybrilliant{x gold!",ch,obj,NULL,TO_CHAR);
  act("$p glows a {Ybrilliant{x gold!",ch,obj,NULL,TO_ROOM);
d3241 2
a3242 2
  act("$p glows with a {YBLINDING gold{x aura!!",ch,obj,NULL,TO_CHAR);
  act("$p glows with a {YBLINDING gold{x aura!!",ch,obj,NULL,TO_ROOM);
d3406 2
a3407 2
  act("$p shivers violently and explodes!",ch,obj,NULL,TO_CHAR);
  act("$p shivers violently and explodes!",ch,obj,NULL,TO_ROOM);
d3416 2
a3417 2
  act("$p glows brightly, then fades...oops.",ch,obj,NULL,TO_CHAR);
  act("$p glows brightly, then fades.",ch,obj,NULL,TO_ROOM);
d3464 2
a3465 2
  act("$p glows blue.",ch,obj,NULL,TO_CHAR);
  act("$p glows blue.",ch,obj,NULL,TO_ROOM);
d3473 2
a3474 2
  act("$p glows a {Bbrilliant{x blue!",ch,obj,NULL,TO_CHAR);
  act("$p glows a {Bbrilliant{x blue!",ch,obj,NULL,TO_ROOM);
d3482 2
a3483 2
  act("$p glows with a {BBLINDING blue{x aura!!",ch,obj,NULL,TO_CHAR);
  act("$p glows with a {BBLINDING blue{x aura!!",ch,obj,NULL,TO_ROOM);
d3642 1
a3642 1
        act("$p is already protected from burning.",ch,obj,NULL,TO_CHAR);
d3656 2
a3657 2
    act("You protect $p from fire.",ch,obj,NULL,TO_CHAR);
    act("$p is surrounded by a protective aura.",ch,obj,NULL,TO_ROOM);
d3697 1
a3697 1
    act( "$n is surrounded by a pink outline.", victim, NULL, NULL, TO_ROOM );
d3710 1
a3710 1
    act( "$n conjures a cloud of purple smoke.", ch, NULL, NULL, TO_ROOM );
d3728 1
a3728 1
  act( "$n is revealed!", ich, NULL, NULL, TO_ROOM );
d3786 1
a3786 1
    act("$N appears to be famished!",ch,NULL,victim,TO_CHAR);
d3831 1
a3831 1
    act("$N appears to be nourished.",ch,NULL,victim,TO_CHAR);
d3843 1
a3843 1
  act("You can't remove $p.",ch,floating,NULL,TO_CHAR);
d3852 1
a3852 1
    act("$n has created a floating black disc.",ch,NULL,NULL,TO_ROOM);
d3870 1
a3870 1
    act("$N doesn't need your help to fly.",ch,NULL,victim,TO_CHAR);
d3882 1
a3882 1
    act( "$n's feet rise off the ground.", victim, NULL, NULL, TO_ROOM );
d3900 1
a3900 1
    act("$N is already in a frenzy.",ch,NULL,victim,TO_CHAR);
d3910 1
a3910 1
        ch,NULL,victim,TO_CHAR);
d3919 1
a3919 1
  act("Your god doesn't seem to like $N",ch,NULL,victim,TO_CHAR);
d3941 1
a3941 1
    act("$n gets a wild look in $s eyes!",victim,NULL,NULL,TO_ROOM);
d3995 1
a3995 1
    act("$n steps through a gate and vanishes.",ch,NULL,NULL,TO_ROOM);
d4037 1
a4037 1
    act("$n has arrived through a gate.",ch,NULL,NULL,TO_ROOM);
d4087 1
a4087 1
  act("$n steps through a gate and vanishes.",ch->pet,NULL,NULL,TO_ROOM);
d4092 1
a4092 1
  act("$n has arrived through a gate.",ch->pet,NULL,NULL,TO_ROOM);
d4109 1
a4109 1
    act("$N can't get any stronger.",ch,NULL,victim,TO_CHAR);
d4122 1
a4122 1
    act("$n's muscles surge with heightened power.",victim,NULL,NULL,TO_ROOM);
d4155 1
a4155 1
        ch,NULL,victim,TO_CHAR);
d4168 1
a4168 1
        act("$n is moving less slowly.",victim,NULL,NULL,TO_ROOM);
d4184 1
a4184 1
    act("$n is moving more quickly.",victim,NULL,NULL,TO_ROOM);
d4244 1
a4244 1
          victim,obj_lose,NULL,TO_ROOM);
d4246 1
a4246 1
          victim,obj_lose,NULL,TO_CHAR);
d4255 1
a4255 1
          victim,obj_lose,NULL,TO_CHAR);
d4266 1
a4266 1
                            victim,obj_lose,NULL,TO_ROOM);
d4268 1
a4268 1
                            victim,obj_lose,NULL,TO_CHAR);
d4277 1
a4277 1
                            victim,obj_lose,NULL,TO_CHAR);
d4293 1
a4293 1
          victim,obj_lose,NULL,TO_ROOM);
d4315 1
a4315 1
                            victim,obj_lose,NULL,TO_ROOM);
d4317 1
a4317 1
                            victim,obj_lose,NULL,TO_CHAR);
d4326 1
a4326 1
                            victim,obj_lose,NULL,TO_CHAR);
d4361 1
a4361 1
    act("$n utters a word of divine power!",ch,NULL,NULL,TO_ROOM);
d4674 1
a4674 1
    act("$N already has infravision.\n\r",ch,NULL,victim,TO_CHAR);
d4677 1
a4677 1
    act( "$n's eyes glow red.\n\r", victim, NULL, NULL, TO_ROOM );
d4706 1
a4706 1
      act("$p is already invisible.",ch,obj,NULL,TO_CHAR);
d4719 1
a4719 1
  act("$p fades out of sight.",ch,obj,NULL,TO_ALL);
d4734 1
a4734 1
    act( "$n fades out of existence.", victim, NULL, NULL, TO_ROOM );
d4766 1
a4766 1
    act( msg, ch, NULL, victim, TO_CHAR );
d4928 1
a4928 1
  act( "$n slowly fades out of existence.", gch, NULL, NULL, TO_ROOM );
d4965 1
a4965 1
    act("$N is already shifted out of phase.",ch,NULL,victim,TO_CHAR);
d4977 1
a4977 1
    act( "$n turns translucent.", victim, NULL, NULL, TO_ROOM );
d4995 1
a4995 1
    act("$N seems to be unaffected.",ch,NULL,victim,TO_CHAR);
d5013 1
a5013 1
  victim,NULL,NULL,TO_ROOM);
d5033 1
a5033 1
    act("Your spell fails to corrupt $p.",ch,obj,NULL,TO_CHAR);
d5037 1
a5037 1
      act("$p is infused with poisonous vapors.",ch,obj,NULL,TO_ALL);
d5051 1
a5051 1
    act("You can't seem to envenom $p.",ch,obj,NULL,TO_CHAR);
d5057 1
a5057 1
    act("$p is already envenomed.",ch,obj,NULL,TO_CHAR);
d5070 1
a5070 1
      act("$p is coated with deadly venom.",ch,obj,NULL,TO_ALL);
d5074 1
a5074 1
  act("You can't poison $p.",ch,obj,NULL,TO_CHAR);
d5082 1
a5082 1
  act("$n turns slightly green, but it passes.",victim,NULL,NULL,TO_ROOM);
d5098 1
a5098 1
    act("$n looks very ill.",victim,NULL,NULL,TO_ROOM);
d5117 1
a5117 1
	   act("$N is already protected",ch,NULL,victim,TO_CHAR);
d5131 1
a5131 1
    act("$N is protected from neutrality.",ch,NULL,victim,TO_CHAR);
d5148 1
a5148 1
          act("$N is already protected.",ch,NULL,victim,TO_CHAR);
d5162 1
a5162 1
        act("$N is protected from evil.",ch,NULL,victim,TO_CHAR);
d5178 1
a5178 1
          act("$N is already protected.",ch,NULL,victim,TO_CHAR);
d5192 1
a5192 1
        act("$N is protected from good.",ch,NULL,victim,TO_CHAR);
d5211 1
a5211 1
            ch,NULL,NULL,TO_ROOM);
d5219 1
a5219 1
  act("$n seems unharmed by the light.",victim,NULL,victim,TO_ROOM);
d5279 2
a5280 2
  act("$p glows softly.",ch,obj,NULL,TO_CHAR);
  act("$p glows softly.",ch,obj,NULL,TO_ROOM);
d5290 2
a5291 2
  act("$p glows softly.",ch,obj,NULL,TO_CHAR);
  act("$p glows softly.",ch,obj,NULL,TO_ROOM);
d5315 2
a5316 2
  act("$p glows brightly and explodes!",ch,obj,NULL,TO_CHAR);
  act("$p glows brightly and explodes!",ch,obj,NULL,TO_ROOM);
d5352 1
a5352 1
    act("$p glows blue.",ch,obj,NULL,TO_ALL);
d5356 1
a5356 1
      act("The curse on $p is beyond your power.",ch,obj,NULL,TO_CHAR);
d5388 1
a5388 1
  act("$n looks more relaxed.",victim,NULL,NULL,TO_ROOM);
d5401 2
a5402 2
                act("Your $p glows blue.",victim,obj,NULL,TO_CHAR);
                act("$n's $p glows blue.",victim,obj,NULL,TO_ROOM);
d5418 1
a5418 1
    act("$N is already in sanctuary.",ch,NULL,victim,TO_CHAR);
d5430 1
a5430 1
    act( "$n is surrounded by a white aura.", victim, NULL, NULL, TO_ROOM );
d5447 1
a5447 1
    act("$N is already protected by a shield.",ch,NULL,victim,TO_CHAR);
d5459 1
a5459 1
    act( "$n is surrounded by a force shield.", victim, NULL, NULL, TO_ROOM );
d5557 1
a5557 1
  act( "$n goes to sleep.", victim, NULL, NULL, TO_ROOM );
d5574 1
a5574 1
              ch,NULL,victim,TO_CHAR);
d5600 1
a5600 1
        act("$n is moving less quickly.",victim,NULL,NULL,TO_ROOM);
d5614 1
a5614 1
    act("$n starts to move in slow motion.",victim,NULL,NULL,TO_ROOM);
d5631 1
a5631 1
    act("$N is already as hard as can be.",ch,NULL,victim,TO_CHAR);
d5643 1
a5643 1
    act( "$n's skin turns to stone.", victim, NULL, NULL, TO_ROOM );
d5684 1
a5684 1
    act( "$n disappears suddenly.", victim, NULL, NULL, TO_ROOM );
d5688 2
a5689 2
    act( "$n arrives suddenly.", victim, NULL, NULL, TO_ROOM );
    act( "$n has summoned you!", ch, NULL, victim,   TO_VICT );
d5739 1
a5739 1
    act( "$n vanishes!", victim, NULL, NULL, TO_ROOM );
d5744 1
a5744 1
    act( "$n slowly fades into existence.", victim, NULL, NULL, TO_ROOM );
d5783 1
a5783 1
 	 act("$N is already weakened.",ch,NULL,victim,TO_CHAR);
d5804 1
a5804 1
    act("$n looks tired and weak.",victim,NULL,NULL,TO_ROOM);
d5867 1
a5867 1
    act("$n disappears.",victim,NULL,NULL,TO_ROOM);
d5871 1
a5871 1
    act("$n appears in the room.",victim,NULL,NULL,TO_ROOM);
d5883 3
a5885 3
    act("$n spits acid at $N.",ch,NULL,victim,TO_NOTVICT);
    act("$n spits a stream of corrosive acid at you.",ch,NULL,victim,TO_VICT);
    act("You spit acid at $N.",ch,NULL,victim,TO_CHAR);
d5914 3
a5916 3
    act("$n breathes forth a cone of fire.",ch,NULL,victim,TO_NOTVICT);
    act("$n breathes a cone of hot fire over you!",ch,NULL,victim,TO_VICT);
    act("You breath forth a cone of fire.",ch,NULL,NULL,TO_CHAR);
d5969 1
a5969 1
    act("$n breathes out a freezing cone of frost!",ch,NULL,victim,TO_NOTVICT);
d5971 2
a5972 2
  ch,NULL,victim,TO_VICT);
    act("You breath out a cone of frost.",ch,NULL,NULL,TO_CHAR);
d6026 2
a6027 2
    act("$n breathes out a cloud of poisonous gas!",ch,NULL,NULL,TO_ROOM);
    act("You breath out a cloud of poisonous gas.",ch,NULL,NULL,TO_CHAR);
d6063 3
a6065 3
    act("$n breathes a bolt of lightning at $N.",ch,NULL,victim,TO_NOTVICT);
    act("$n breathes a bolt of lightning at you!",ch,NULL,victim,TO_VICT);
    act("You breathe a bolt of lightning at $N.",ch,NULL,victim,TO_CHAR);
d6138 1
a6138 1
     act( "I see no $T on the ground here.", ch, NULL, target, TO_CHAR );
d6223 2
a6224 2
  act( "$N raises from the dead and bows before $n.",   ch, NULL, victim, TO_ROOM );
  act( "$N raises from the dead and bows before you.", ch, NULL, victim, TO_CHAR );
d6280 2
a6281 2
  act( "A dark hole opens to reveal a skeletal warrior.",ch, NULL, victim,TO_ROOM);
  act( "A dark hole opens to reveal a skeletal warrior.",ch, NULL, victim,TO_CHAR);
d6301 2
a6302 2
    act("$p looks more solid.",ch,obj,NULL,TO_CHAR);
    act("$p looks more solid.",ch,obj,NULL,TO_ROOM);
d6326 2
a6327 2
    act("You draw the last remains of energy from the corpse.",ch,NULL,NULL,TO_CHAR);
    act("As the corpse disintegrates, $n looks healthier.",ch,NULL,NULL,TO_ROOM);
d6431 2
a6432 2
    act("Your flesh rots away into the visage of the dead.",victim,NULL,NULL,TO_CHAR);
    act("$n's flesh rots away to reveal the visage of the dead.",victim,NULL,NULL,TO_ROOM);
d6500 1
a6500 1
    act( "$n looks more powerful than death.", victim, NULL, NULL, TO_ROOM );
d6564 1
a6564 1
    act("$N's body is already equipped.",ch,NULL,victim,TO_CHAR);
d6577 1
a6577 1
  act("$N's body becomes equipped for combat.",ch,NULL,victim,TO_CHAR);
d6591 1
a6591 1
   act("$N is already strong willed.",ch,NULL,victim,TO_CHAR);
d6607 1
a6607 1
  act("$N's will can not be broken.",ch,NULL,victim,TO_CHAR);
@


1.207
log
@ Your own spells will not hit your orb of turning

 -Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.206 2000/03/23 14:11:33 mud Exp $";
d4832 1
a4832 1
  if ( in_obj->carried_by != NULL && can_see(ch,in_obj->carried_by))
d4835 1
a4835 1
    PERS(in_obj->carried_by, ch) );
@


1.206
log
@ Newbies will now start with 80% in their primary weapon, so they can start
 gaining skill points right away.

 Also, added in room number in summon log line

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.205 2000/03/22 16:10:28 mud Exp $";
d960 1
a960 1
     if( target == TARGET_CHAR && victim != NULL
@


1.205
log
@allow nonclanners to have feast/famine cast on them based on nocan
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.204 2000/03/21 02:02:16 mud Exp $";
d5692 1
a5692 1
    sprintf(log_buf, "%s has summoned %s", ch->name, victim->name);
@


1.204
log
@rework remove curse
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.203 2000/03/21 01:56:47 mud Exp $";
d3761 2
a3762 1
        && !is_same_clan(ch,victim) )
d3806 2
a3807 1
        && !is_same_clan(ch,victim) )
@


1.203
log
@tweak remove curse
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.202 2000/03/19 00:04:31 mud Exp $";
d5365 2
a5366 1
        && !is_same_clan(ch,victim) && !IS_NPC(ch) && is_clan(ch))
@


1.202
log
@feast,famine and remove curse do checks like word of recall
-poquaH
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.201 2000/03/14 15:10:13 mud Exp $";
d5365 1
a5365 1
        && !is_same_clan(ch,victim) )
@


1.201
log
@ Added spell "nehter shield"
 Immortals will now never fail an enchant, and will always increase
 the hit/dam addition by one at a time.

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.200 2000/03/08 14:41:37 mud Exp $";
d3750 1
d3757 20
d3794 1
d3801 20
d5362 19
@


1.200
log
@gate to clanmates above your level +3
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.199 2000/03/08 14:25:06 mud Exp $";
d3396 2
d3462 1
a3462 1
    if (result <= (100 - level/5))  /* success! */
@


1.199
log
@is_safe_spell added to teleport
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.198 2000/03/07 13:56:06 mud Exp $";
d3930 1
a3930 1
    ||   (victim->level >= ch->level + 3 && !is_same_group(ch,victim))
@


1.198
log
@ Those with enchanter kit now only pay 80 mana for enchanting

 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.197 2000/02/29 02:02:04 mud Exp $";
d5659 1
@


1.197
log
@ harmful spell groups now have a saves vs spell
 harm reduced in damage to die 12

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.196 2000/02/27 00:45:09 mud Exp $";
d368 6
@


1.196
log
@ another bug fix for magic missile, should stop when ch->fighting == null

 bug fix for buffy, was checking remort status on the wrong person

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.195 2000/02/24 03:17:33 mud Exp $";
d1738 8
a1745 1
    damage_old( ch,(CHAR_DATA *) vo,dice(level,2), sn,DAM_HARM, TRUE );
d1753 8
a1760 1
    damage_old( ch, (CHAR_DATA *) vo, dice(level,6),sn,DAM_HARM,TRUE);
d1768 8
a1775 1
    damage_old( ch, (CHAR_DATA *) vo, dice(level,4), sn, DAM_HARM, TRUE );
d4078 8
a4085 1
    damage_old( ch,(CHAR_DATA *) vo, dice(level,18),sn,DAM_HARM,TRUE);
@


1.195
log
@ magic ...typo , fixed so it could compile...my bad
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.194 2000/02/24 03:13:00 mud Exp $";
d4811 1
a4811 1
    if ( victim == NULL || victim->position <= POS_STUNNED )
@


1.194
log
@ const.c   made elves res mental instead of charm
 magic.c   removed the level+2 < victim->level in sleep, makes no sense
	   that someone two levels under has no chance to sleep you ,
	   the level difference is taken into accoutn in saves_vs_spell

 update.c    2* gains in gain_exp until refresh
 speical.c   removed avarice as clan war winner, put in valor for now

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.193 2000/02/24 02:54:31 mud Exp $";
d2167 1
a2167 1
	heal -= ( heal / 4 );
d2219 1
a2219 1
	heal -= ( heal / 4 );
d2279 1
a2279 1
	heal -= ( heal / 4 );
@


1.193
log
@ old class modifiers, I added curative as dependant on cleric old class
 beguiling / mage, berserk / warrior

 berserk is a little better for berserkers, 13 13 instead of 10 10

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.192 2000/02/23 19:52:02 mud Exp $";
d5435 1
a5435 2
    ||   (level + 2) < victim->level
    ||   saves_spell( level-4, victim,DAM_CHARM) )
@


1.192
log
@adjust elementalist stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.191 2000/02/19 18:50:41 mud Exp $";
d1888 4
d2165 4
d2217 4
d2277 4
d5430 3
@


1.191
log
@ fight.c  changed the pen for blademasters to /5 instead of /4
	  so they have the same pen as druids

 handler.c
	changed max trainable to be similar to max attainable
	so reclasses now get +1 to both mixed reclass primaries
	instead of a +2 on a reclass primary

 magic.c
	added two more mods to saves calculations

 mag2.c
	 cahnged earthbind, 2 ticks now, lose haste NOT slow
	  and a lot less dex loss
	  more work to do with this spell, consider it a work in progress




	  MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.190 2000/02/12 16:05:46 mud Exp $";
d1188 5
a1192 1
    dam = dice( level, 12 );
@


1.190
log
@ magic.c     tweak to magic missile

 mag2.c      tweak to dust storm , hope it stops the perma blind

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.189 2000/02/08 02:58:00 mud Exp $";
d241 1
a241 1
    /* curve only once for people with res magic */
d244 1
a244 1
    saving_throw = ( saving_throw + 16 ) / 2 - 16;
d254 7
d287 1
a287 1
    save = URANGE( 10, save, 95 );
d431 2
a432 2
    if ( level > 53 )
       level = ( level - 53 ) / 2 + 53;
d434 2
a435 2
    if ( level > 56 )
	level = ( level - 56 ) /2 + 56;
d3658 2
@


1.189
log
@magic.c   typo oldclass when it should be old_class
MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.188 2000/02/08 02:15:59 mud Exp $";
d4782 1
a4782 1
    if ( victim == NULL || victim->hit <= 0 )
@


1.188
log
@magic.c
        new saves calculations. int wis factors in a little more.
	few changes to the modifiers.
	fixed a bug, if you were resistant to the type, your chances
	actually became worse to save vs the spell.
	just so you know, the LOWER the number, the better is is for
	the victim.

	Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.187 2000/02/07 23:02:36 mud Exp $";
d277 1
a277 1
    if (!IS_NPC(victim) && class_table[victim->pcdata->oldclass].fMana > 1)
@


1.187
log
@Have to be atleast awake in te room to improve your spellcraft by watching
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.186 2000/01/24 17:22:10 mud Exp $";
a227 1
    check_dispel( 2 * level / 3, victim, skill_lookup("magic resistance"));
a232 1
    check_dispel( 2 * level / 3, victim, gsn_magic_resistance );
d238 6
a243 1
    check_dispel( 2 * level / 3, victim, gsn_magic_resistance );
d247 1
a247 1
    save = 50 + ( level / 10 ) + ( 3 * saving_throw / 2 );
d249 2
a250 2
    save -= ( get_curr_stat(victim,STAT_INT) +
	      get_curr_stat(victim,STAT_WIS) ) / 8;
d252 1
a252 1
    save -= ( victim->level - level ) * 5;
d258 1
a258 1
        save -= get_skill(victim,gsn_weave_resistance) / 15;
d263 3
a265 1
        save -= victim->level/8;
d270 2
a271 2
  case IS_RESISTANT:  save += 15;  break;
  case IS_VULNERABLE: save -= 15;  break;
d277 1
a277 1
    if (!IS_NPC(victim) && class_table[victim->class].fMana > 0)
d280 1
a280 1
    save = URANGE( 5, save, 95 );
@


1.186
log
@Changed entrance to use ch->level instead of level for saving throw and
level comparison. Entrance is a vampire skill, shouldnt matter that you
are a warrior vs a mage and casting level is different.
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.185 2000/01/22 01:20:30 mud Exp $";
d201 2
a202 1
      if ( get_skill(rch,gsn_spellcraft) >= 65 )
@


1.185
log
@fight.c
	nether flags only benefits nethermancers, added a HAS_KIT(nethermance)
	to the WEAPON_NETHER check

	added a check to check_myrm function to verify that
	char weapon is the one that they are specialized in
	should not give a bonus if not weilding a specialized weapon

magic.c
	added checks on calm to prevent PC's from
	landing calm on each other if they are non-clanned or clanned
	so a clanner can't calm a non-clanner and vice versa
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.184 2000/01/21 19:56:19 mud Exp $";
d5360 1
a5360 1
    if (level < victim->level)
d5366 1
a5366 1
    if (saves_spell (level,victim,DAM_MENTAL))
@


1.184
log
@ fiexed two small bugs in new spell confusion
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.183 2000/01/21 01:21:06 mud Exp $";
d1461 13
d1494 2
@


1.183
log
@last try, pretty sure I got it fright
Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.182 2000/01/21 00:53:20 mud Exp $";
d1325 1
a1325 1
      send_to_char("You feel like you can think clearly again/n/r", victim);
@


1.182
log
@Added new spelll confusion.
Confuses victims sense of direction
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.181 1999/12/15 17:53:45 mud Exp $";
d1323 1
a1323 1
      strip_affect(victim, gsn_confusion);
@


1.181
log
@Commented out level down of save_spell() in spell_turn_undead()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.180 1999/12/02 18:34:17 mud Exp $";
d1319 7
@


1.180
log
@Had to change cast_spell for NOCOMBAT if victim == ch
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.179 1999/12/02 18:27:16 mud Exp $";
d6207 1
d6213 1
@


1.179
log
@Oddly it still lets you cast spells at yourself
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.178 1999/12/02 18:20:41 mud Exp $";
d673 1
a673 1
     send_to_char("Not on that target.\n\r",ch);
@


1.178
log
@Stop casting spells at yourself if is_safe
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.177 1999/12/01 22:13:49 mud Exp $";
d671 1
a671 1
  if (ch == victim && is_safe(ch,victim))
@


1.177
log
@kaz^}]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
wq
q
|
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.176 1999/11/30 01:32:39 mud Exp $";
d671 5
@


1.176
log
@Add chanace of Ogre smell not working
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.175 1999/11/30 01:12:56 mud Exp $";
d3995 1
a3995 1
    damage_old( ch,(CHAR_DATA *) vo, dice(level,8),sn,DAM_HARM,TRUE);
@


1.175
log
@Something fun for Ogre's, ability to smell Remorts
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.174 1999/11/26 21:49:39 mud Exp $";
d3886 9
a3894 6
	     if(IS_SET(ch->act,PLR_VAMP))
	        send_to_char("The strange odor of blood is gone.\n\r",fch);
	     if(IS_SET(ch->act,PLR_WERE))
	        send_to_char("The scent of decay is gone.\n\r",fch);
	     if(IS_SET(ch->act,PLR_MUMMY))
	        send_to_char("The smell of filthy fur is gone.\n\r",fch);
d3937 9
a3945 6
             if(IS_SET(ch->act,PLR_VAMP))
                send_to_char("The strange odor of blood makes you feel uncomfortable.\n\r",fch);
             if(IS_SET(ch->act,PLR_WERE))
                send_to_char("The scent of decay makes your head dizzy.\n\r",fch);
             if(IS_SET(ch->act,PLR_MUMMY))
                send_to_char("The smell of filthy fur fills up the air.\n\r",fch);
@


1.174
log
@Fix Nether's mana for transport spells
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.173 1999/11/26 21:42:32 mud Exp $";
d3876 20
d3921 20
@


1.173
log
@debugging
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.172 1999/11/26 21:41:23 mud Exp $";
a342 2
    char buf[MAX_STRING_LENGTH];

d354 1
a354 8
    {
    sprintf(buf,"\n\r mana = %d\n\r",mana);  
    send_to_char(buf,ch); 
    sprintf(buf,"level= %d  chlevel= %d",level,ch->level);
    send_to_char(buf,ch);

	return ( mana / 2 );
    }
@


1.172
log
@debugging nether mana
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.171 1999/11/26 21:33:51 mud Exp $";
d360 1
a360 1
    send_tod_char(buf,ch);
@


1.171
log
@debug why nethers get portal for 1 mana
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.170 1999/11/19 05:41:18 mud Exp $";
a350 3
    sprintf(buf,"\n\rmana = %d\n\r",mana);  
    send_to_char(buf,ch); 

d356 6
d363 1
@


1.170
log
@Varioety of changes.   faerie fog stuff mostly
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.169 1999/11/11 18:26:06 mud Exp $";
d343 2
d350 3
@


1.169
log
@Fixed up some stuff in blind.
-G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.168 1999/10/07 01:48:01 mud Exp $";
d354 1
a354 1
	mana /= 2;
d1195 1
a1195 1
    af.duration  = 24;
d3636 1
d4541 5
d4737 2
a4738 1
  if ( !is_same_group( gch, ch ) || IS_AFFECTED(gch, AFF_INVISIBLE) )
@


1.168
log
@Changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.167 1999/10/03 00:58:44 mud Exp $";
d1295 5
@


1.167
log
@Nothing much
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.166 1999/10/02 02:07:38 mud Exp $";
d1317 1
a1317 1
    af.duration  = 1+level;
d2319 1
a2319 1
    af.duration  = 2*level;
@


1.166
log
@Added a  (  ) around saves_Spell in entrance cause it never seems to execute
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.165 1999/09/30 00:57:47 mud Exp $";
d5275 2
a5276 3
    if ( (level < victim->level)
       || saves_spell( level, victim,DAM_MENTAL) )
	{
d5279 7
a5285 1
	}
@


1.165
log
@last try to fix summon, feeling like an idiot
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.164 1999/09/30 00:55:43 mud Exp $";
d5275 1
a5275 1
    if ( level < victim->level
@


1.164
log
@ fixed typo in summon
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.163 1999/09/30 00:48:01 mud Exp $";
d5463 2
a5464 1
    if (!IS_NPC(victim){
@


1.163
log
@Added log line to summon to track non-clanners getting summoned to aggie mobs


Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.162 1999/09/14 04:39:42 mud Exp $";
d5427 1
a5427 1
    _
@


1.162
log
@Minor changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.161 1999/08/28 21:45:51 mud Exp $";
d5426 2
a5427 1

d5463 5
@


1.161
log
@Fixed crash bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.160 1999/08/28 21:21:14 mud Exp $";
d865 1
a865 1
 	   if ( ch->pcdata->sac < mana )
d872 1
a872 1
	   ch->pcdata->sac -= mana;
@


1.160
log
@Magic.c
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.159 1999/08/28 21:17:16 mud Exp $";
d203 1
a203 1
	check_improve(rch,gsn_spellcraft,10,TRUE);
d901 1
a901 1
		check_improve(ch,gsn_spellcraft,10,TRUE);
d905 1
a905 1
	check_improve(ch,gsn_spellcraft,15,FALSE);
@


1.159
log
@Added reward 'all'
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.158 1999/08/28 16:34:28 mud Exp $";
d900 2
a901 2
	check_improve(ch,gsn_spellcraft,10,TRUE);
	WAIT_STATE( ch, skill_table[sn].beats / 2 );
@


1.158
log
@Variety of changes
-spellcraft change
-added color to hindered dropping stuff
-poison damage when moving
-chain lightning is 2 rounds
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.157 1999/08/26 19:31:24 mud Exp $";
d202 2
d205 1
d899 2
d902 1
d904 2
d907 1
@


1.157
log
@Wu jen and casting curve
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.156 1999/08/23 22:48:20 mud Exp $";
d913 2
a914 1
	check_improve(ch,gsn_spellcraft,TRUE,6);
d918 2
a919 1
  check_improve(ch,gsn_spellcraft,FALSE,8);
@


1.156
log
@Added some warnings to find crash bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.155 1999/08/23 19:46:26 mud Exp $";
d415 1
a415 1
    if ( level > 52 )
d940 8
@


1.155
log
@Debugging Quicken on OLC
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.154 1999/08/23 03:34:48 mud Exp $";
d4573 7
@


1.154
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.153 1999/08/19 04:56:50 mud Exp $";
d512 3
@


1.153
log
@Fixed stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.152 1999/08/13 19:40:14 mud Exp $";
d555 1
d899 5
a903 1
    if ( number_percent( ) > get_skill(ch,sn) )
d3849 1
a3850 1

d3881 1
d5430 1
d5479 1
d5605 1
@


1.152
log
@Fixed a bug in magelabs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.151 1999/08/13 18:48:36 mud Exp $";
d240 1
a240 1
    save = 50 + ( level / 5 ) + saving_throw;
@


1.151
log
@Basic stuff for alchemists, saves changes, magelabs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.150 1999/08/13 18:34:36 mud Exp $";
d3023 1
d3026 3
a3028 3
       case SECT_MAGELAB_SIMPLE: fail -= 10; break;
       case SECT_MAGELAB_INTERMEDIATE: fail -= 20; break;
       case SECT_MAGELAB_ADVANCED: fail -= 50; break;
d3031 2
d3258 2
d3262 3
a3264 3
   case SECT_MAGELAB_SIMPLE: fail -= 10; break;
   case SECT_MAGELAB_INTERMEDIATE: fail -= 20; break;
   case SECT_MAGELAB_ADVANCED: fail -= 50; break;
d3267 2
@


1.150
log
@Variety of changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.149 1999/08/12 01:04:00 mud Exp $";
d222 5
a226 2
    if (saving_throw < -8)
	saving_throw = ( saving_throw + 8 ) / 2 - 8;
d228 5
a232 2
    if (saving_throw < -12)
	saving_throw = ( saving_throw + 12 ) / 2 - 12;
d234 5
a238 2
    if (saving_throw < -16)
	saving_throw = ( saving_throw + 16 ) / 2 - 16;
d245 2
d3017 15
d3245 3
d3250 13
@


1.149
log
@Nethermancers are in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.148 1999/08/11 20:18:03 mud Exp $";
d220 19
a238 17
  if (victim->saving_throw < -17)
	{
	saving_throw = -17;
	}
  else
	{
	saving_throw = victim->saving_throw;
	}

   /* Shapeshifter Penalty */
   if(HAS_KIT(victim,"shapeshifter") && (saving_throw <= -11))
      saving_throw = -10;

	if( victim->race == race_lookup("elf") ) saving_throw -= 5;
    save = 3 + get_curr_stat(victim,STAT_INT) + get_curr_stat(victim,STAT_WIS)
	+ ( victim->level - level) * 5 - saving_throw * 2;
  if( number_percent() < get_skill(victim,gsn_weave_resistance) )
d240 2
a241 2
    save += get_skill(victim,gsn_weave_resistance) / 5;
    check_improve(victim,gsn_weave_resistance,TRUE,1);
d243 1
d245 1
a245 1
  save += victim->level/2;
d250 2
a251 2
  case IS_RESISTANT:  save += 5;  break;
  case IS_VULNERABLE: save -= 5;  break;
d255 1
a255 1
	save += 5;
d257 2
a258 2
    if ( group_has_crusader(victim) )
       save += 5;
a259 2
    if (!IS_NPC(victim) && class_table[victim->class].fMana >0)
  save = 9 * save / 10;
d261 1
a261 1
    return number_percent( ) < save;
@


1.148
log
@One last bug with dragon breath
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.147 1999/08/11 04:55:52 mud Exp $";
d831 13
d859 1
@


1.147
log
@Many many changes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.146 1999/08/11 03:30:19 mud Exp $";
d342 1
a342 1
	return ( mana / 2 );
@


1.146
log
@Fixed a bug in the dragon gains
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.145 1999/08/11 00:51:03 mud Exp $";
d410 1
a410 1
	level -= number_range( 2, 3 );
d2686 4
a2689 1
 
@


1.145
log
@Dragon breath weapon cost changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.144 1999/08/09 22:08:29 mud Exp $";
d307 2
a308 1
bool dragon_breath( int race, int sn )
d310 1
a310 1
   if ( race != race_lookup("dragon") )
d341 3
a343 3
    if ( dragon_breath( ch->race, sn ) )
	mana /= 2;
    
d812 1
a812 1
    if ( dragon_breath( ch->race, sn ) )
@


1.144
log
@Removed all of Rusty's cheat codes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.143 1999/07/21 01:16:30 mud Exp $";
d307 15
d340 3
d809 18
a826 1
      
@


1.143
log
@More modificaitons to shit..sleep max level reduced
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.142 1999/07/21 01:13:27 mud Exp $";
a232 1
	if(IS_SET(victim->act,PLR_OLD)) saving_throw -= 5;
d347 1
a347 1
    if ( ch->class == class_lookup("druid") || IS_SET(ch->act,PLR_OLD))
d836 1
a836 1
    if ( number_percent( ) > get_skill(ch,sn)  && !IS_SET(ch->act,PLR_OLD) )
@


1.142
log
@Fixed some stuff with fumble so everybody shuts the fuck upo
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.141 1999/07/14 18:14:00 mud Exp $";
d5165 3
a5167 1
  
@


1.141
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: magic.c,v 1.140 1999/07/06 22:34:00 mud Exp $";
d220 1
a220 1
  if (victim->saving_throw <= -16)
d222 1
a222 1
	saving_throw = -15;
@


1.140
log
@Immortals do not lag casting spells
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.139 1999/07/06 04:17:16 mud Exp $ */
@


1.139
log
@Fixing e-drain failing saving throw for movew
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.138 1999/06/28 06:34:19 mud Exp $ */
d822 3
d835 1
@


1.138
log
@Fixed skill levels
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.137 1999/06/27 20:41:41 mud Exp $ */
d3369 1
a3369 1
	victim->move = ( 3 * victim->mana ) / 4;
@


1.137
log
@Changed the gate rules
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.136 1999/06/26 09:35:31 mud Exp $ */
d85 1
a85 1
      if (ch->level >= skill_table[sn].skill_level[ch->class]
d546 1
a546 1
    || ( !IS_NPC(ch) && (ch->level < skill_table[sn].skill_level[ch->class]
d572 1
a572 1
		     skill_table[sn].skill_level[ch->class],sn);
@


1.136
log
@Typoe in energy drain that had zapping the mana again in the moves section
causing the player to lose up to 75% of their mana some times
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.135 1999/06/19 03:01:05 mud Exp $ */
d3704 1
@


1.135
log
@Stop from summon clanners into a noclan room
-poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.134 1999/06/17 15:36:12 mud Exp $ */
d3369 1
a3369 1
	victim->mana = ( 3 * victim->mana ) / 4;
@


1.134
log
@Addded NOCLAN room flag not allowing clanners in rooms
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.133 1999/06/11 23:21:56 mud Exp $ */
d5303 2
@


1.133
log
@Stuff I changed.  mostly updates of existing files and changes to seer
and flee.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.132 1999/05/28 12:05:04 mud Exp $ */
d3707 1
a3707 1
    ||   (!is_room_owner(ch,victim->in_room) && room_is_private(victim->in_room) ) 
@


1.132
log
@Highlander powers almost complete
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.131 1999/05/28 11:47:18 mud Exp $ */
d310 1
a310 1
int mana_cost (CHAR_DATA *ch, int min_mana, int level)
d312 2
d315 12
a326 2
  return 1000;
    return UMAX(min_mana,(100/(2 + ch->level - level)));
d571 4
d581 1
@


1.131
log
@Quick quick quick
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.130 1999/05/28 11:41:55 mud Exp $ */
a472 2
   sprintf(buf,"arg1= %s name= %s\n\r",arg1,skill_table[sn].name);
   send_to_char(buf,ch);
d480 1
a480 1
       sn != skill_lookup("farsight"))
d487 1
a487 1
       (sn != skill_lookup("farsight")))
a494 6
   if ( arg2[0] != '\0' && sn == skill_lookup("farsight"))
   {
      send_to_char("Who do you wish to farsee?\n\r",ch);
      return;
   }

d496 1
a496 1
   if (sn == skill_lookup("farsight"))
@


1.130
log
@Quicken debugging and fix a Highlander bug in Fight.c
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.129 1999/05/28 07:29:00 mud Exp $ */
d502 1
a506 1
   bug("Quicken: %d %d %s %s %d",sn,level,ch->name,vo->name,TARGET_CHAR);
@


1.129
log
@bug in do_quicken causing me to crash
-Poq
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.128 1999/05/28 07:15:47 mud Exp $ */
a448 2
send_to_char("no crash-2\n\r",ch);

a461 1
send_to_char("no crash-1\n\r",ch);
a469 1
send_to_char("no crash0\n\r",ch);
a479 2
send_to_char("no crash1",ch);

a487 1
send_to_char("no crash2",ch);
d497 8
a504 4
   if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
      vo = (void *) ch;
   else
      vo = (void *) target_name;
d506 1
a506 1
send_to_char("no crash3",ch);
a507 1
send_to_char("no crash4",ch);
@


1.128
log
@Debug debug
-Poq
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.127 1999/05/28 07:11:50 mud Exp $ */
d449 1
@


1.127
log
@Debuging quicken spell lookup
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.126 1999/05/28 07:08:59 mud Exp $ */
d463 1
@


1.126
log
@Problem with skill lookup
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.125 1999/05/28 07:01:29 mud Exp $ */
d445 1
d475 1
a475 1
   sprintf(buf,"arg1= %s name= %s\n\r",arg1,skill_table[sn].name)
@


1.125
log
@Debug Quicken
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.124 1999/05/28 06:33:25 mud Exp $ */
d470 1
d474 2
@


1.124
log
@Quickening
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.123 1999/05/28 06:18:14 mud Exp $ */
d478 2
d488 1
d503 1
d505 1
@


1.123
log
@Working on Highlanders Quicken
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.122 1999/05/26 03:27:35 mud Exp $ */
d446 3
d474 1
a474 1
          &&  !str_prefix(name,skill_table[sn].name))
d478 3
a480 3
   if (sn != spell_lookup("haste") &&
       sn != spell_lookup("giant strength") &&
       sn != spell_lookup("farsight"))
d487 1
a487 1
       (sn != spell_lookup("farsight")))
@


1.122
log
@Changes to add in garotte item types and add the garotte
skill to assassins.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.121 1999/05/25 06:22:24 mud Exp $ */
a439 1
/* comment out not ready yet
a499 1
*/
@


1.121
log
@Testing shapers practicing
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.120 1999/05/22 16:11:59 mud Exp $ */
d4183 1
@


1.120
log
@Comment Highlander code I'm working on
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.119 1999/05/22 16:09:33 mud Exp $ */
a468 1
   name = arg1;
d471 1
a471 1
      if (LOWER(name[0]) == LOWER(skill_table[sn].name[0])
@


1.119
log
@Stop shapeshifters from practicing for now
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.118 1999/05/19 21:02:25 mud Exp $ */
d440 1
d502 1
@


1.118
log
@Can not specify targets with Quicken, its for use on self only
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.117 1999/05/19 20:52:41 mud Exp $ */
d445 1
d464 1
a464 1
      send_to_char( "Quicken which what where?\n\r", ch );
d468 2
a469 1
   if (arg2[0] != '\0')
d471 10
a480 1
      send_to_char("You can not specify targets with the Quickening.\n\r",ch);
d484 15
@


1.117
log
@Adding Highlander Quicken Abiliies
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.116 1999/05/18 18:23:59 mud Exp $ */
d442 4
d458 2
a459 2
    target_name = one_argument( argument, arg1 );
    one_argument( target_name, arg2 );
d464 6
@


1.116
log
@Shapeshifter typo
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.115 1999/05/18 18:18:57 mud Exp $ */
d439 27
@


1.115
log
@SHapeshifter changes - Add Saves Penalty, Slow Regen of Con mod
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.114 1999/05/06 02:16:40 mud Exp $ */
d230 1
a230 1
   if(HAS_KIT(ch,"shapeshifter") && (saving_throw <= -11))
@


1.114
log
@Changed druid curve.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.113 1999/05/03 08:00:20 mud Exp $ */
d228 4
@


1.113
log
@Bank code.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.112 1999/04/26 07:54:46 mud Exp $ */
d372 2
a373 2
    if ( level > 57 )
	level = ( level - 57 ) /2 + 57;
@


1.112
log
@Added the neat echoes to the savnt stuff in update.c and fixed
a grammar error in magic.c for the noid flag -G
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.111 1999/04/23 23:43:42 mud Exp $ */
d477 5
a481 1
  
@


1.111
log
@Change all PLR_HIGHLANDER to MHS_HIGHLANDER and moved under MHS bit
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.110 1999/04/23 21:51:45 mud Exp $ */
d4239 1
a4239 4
    {
       sprintf(buf,"You're scrying is unable to attain more information.\n\r");
       send_to_char(buf,ch);
    }
@


1.110
log
@See previous comment re: NULL fch
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.109 1999/04/23 21:50:09 mud Exp $ */
d547 2
a548 2
     IS_SET(ch->act,PLR_HIGHLANDER) 
     && IS_SET(victim->act,PLR_HIGHLANDER))
d1652 1
a1652 1
    if (IS_SET(ch->act,PLR_HIGHLANDER) && IS_NPC(victim))
d3634 1
a3634 1
    if (IS_SET(ch->act,PLR_HIGHLANDER))
d3639 1
a3639 1
         if (IS_SET(fch->act,PLR_HIGHLANDER) && fch != ch)
d3653 1
a3653 1
    if (IS_SET(ch->act,PLR_HIGHLANDER) && fch != NULL)
d3663 1
a3663 1
	  if (IS_SET(fch->act,PLR_HIGHLANDER) && fch != ch)
d5773 1
a5773 1
  if (IS_SET(ch->act,PLR_HIGHLANDER))
@


1.109
log
@Removed the chance of a NULL fch in the Highlander stuff in spell_gate()
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.108 1999/04/23 21:43:37 mud Exp $ */
d3587 1
a3587 1
    CHAR_DATA *fch;
@


1.108
log
@Slight tweak to saves calc.  No biggy.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.107 1999/04/22 13:04:07 mud Exp $ */
d3653 1
a3653 1
    if (IS_SET(ch->act,PLR_HIGHLANDER))
@


1.107
log
@Add victim fighting not null for Highlander spell casting
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.106 1999/04/18 06:24:54 mud Exp $ */
d220 1
a220 1
  if (victim->saving_throw <= -13)
d222 1
a222 1
	saving_throw = -12;
@


1.106
log
@Change Highlanders is_safe, all Highlanders will be clanned (temp)
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.105 1999/04/18 04:32:27 mud Exp $ */
d546 1
a546 1
  if(victim->fighting != ch && 
@


1.105
log
@Stop Highlanders from casting spells at Clanners
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.104 1999/04/18 04:01:00 mud Exp $ */
a545 6
  if (!IS_SET(victim->act,PLR_HIGHLANDER) && is_clan(victim) && !is_clan(ch))
  {
     send_to_char("Join a Clan to battle Clanners.\n\r",ch);
     return FALSE;
  }
  
d547 1
a547 2
     (IS_SET(victim->fighting->act,PLR_HIGHLANDER) || 
     IS_SET(ch->act,PLR_HIGHLANDER)) 
d3589 1
d3641 1
d3650 3
d3655 5
d3665 7
a3671 2
	     send_to_char("Your neck tingles as you feel the presence of another Highlander.\n\r",fch);
	  }
a3673 3

    act("$n has arrived through a gate.",ch,NULL,NULL,TO_ROOM);
    do_look(ch,"auto");
@


1.104
log
@Bug with Casting spells at Highlanders in combat
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.103 1999/04/17 22:54:31 mud Exp $ */
d546 6
@


1.103
log
@Highlanders do not need to sense themselves
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.102 1999/04/17 09:36:40 mud Exp $ */
d547 3
a549 1
     IS_SET(ch->act,PLR_HIGHLANDER) && IS_SET(victim->act,PLR_HIGHLANDER))
@


1.102
log
@declare fch and fch_next in spell_gate for Highlander
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.101 1999/04/17 09:27:13 mud Exp $ */
d3637 1
a3637 1
         if (IS_SET(fch->act,PLR_HIGHLANDER))
d3652 1
a3652 1
	  if (IS_SET(fch->act,PLR_HIGHLANDER))
@


1.101
log
@Highlanders sense to other Highlanders in room
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.100 1999/04/17 07:42:54 mud Exp $ */
d3586 2
@


1.100
log
@Added notification if already affected or failed for Curse and Weaken
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.99 1999/04/17 01:56:11 mud Exp $ */
d3629 13
d3644 12
@


1.99
log
@Let Highlanders cast spells against each other in combat
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.98 1999/04/16 16:36:32 mud Exp $ */
d2119 15
a2133 2
    if (IS_AFFECTED(victim,AFF_CURSE) || saves_spell(level,victim,DAM_NEGATIVE))
  return;
d5270 14
a5283 2
    if ( is_affected( victim, sn ) || saves_spell( level, victim,DAM_OTHER) )
  return;
@


1.98
log
@typo fix from last change
-R
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.97 1999/04/16 16:34:14 mud Exp $ */
d546 1
a546 1
  if(victim->fighting != NULL &&
@


1.97
log
@ no charming DWEEBs to get around grouping restrictions
 -Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.96 1999/04/16 16:19:41 mud Exp $ */
d1660 1
a1660 1
    ||   IS_SET(victim->act, PLR_DWEEB) )  
@


1.96
log
@added missing ;
-R
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.95 1999/04/16 01:40:11 mud Exp $ */
d1660 1
@


1.95
log
@Highlanders can not charm NPC's, players are ok though
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.94 1999/04/16 01:27:33 mud Exp $ */
d1653 1
a1653 1
       send_to_char("Honorable combat is one on one. Highlanders can not charm monsters.\n\r",ch)
@


1.94
log
@Highlanders can not summon skeletons
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.93 1999/04/14 20:23:21 mud Exp $ */
d1649 6
@


1.93
log
@Highlanders can not cast spells on another Highlander already in Combat
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.92 1999/04/08 02:27:41 mud Exp $ */
d5700 6
@


1.92
log
@Change Recharge to look at value0 for spell level not value3
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.91 1999/04/08 02:03:38 mud Exp $ */
d545 7
@


1.91
log
@May have found it, change and test
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.90 1999/04/08 01:49:34 mud Exp $ */
a4751 1
    char buf  [MAX_STRING_LENGTH];
a4761 2
    sprintf(buf,"Value[3]= %d\n\r",obj->value[0]);
    send_to_char (buf,ch);
a4773 2
    sprintf(buf,"Value[3]= %d\n\r",obj->value[0]);
    send_to_char (buf,ch);
a4778 2
    sprintf(buf,"Final Chance= %d\n\r",chance);
    send_to_char (buf,ch);
@


1.90
log
@Declare buf for debug messages
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.89 1999/04/08 01:41:11 mud Exp $ */
d4760 1
a4760 1
    if (obj->value[3] >= 3 * level / 2)
d4763 1
a4763 1
    sprintf(buf,"Value[3]= %d\n\r",obj->value[3]);
d4776 2
a4777 2
    chance -= obj->value[3]; /* harder to do high-level spells */
    sprintf(buf,"Value[3]= %d\n\r",obj->value[3]);
@


1.89
log
@Change one of the send_to_char to send_to_room
Added debug messages to use on OLC to find out whats going on
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.88 1999/04/01 06:37:57 mud Exp $ */
d4752 1
@


1.88
log
@Added NOIDNET for potions Ryoga asked for April Fools quest
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.87 1999/03/29 22:07:01 mud Exp $ */
d4762 2
d4776 2
d4783 2
d4801 1
a4801 1
  act("$p glows softly.",ch,obj,NULL,TO_CHAR);
@


1.87
log
@Send message to ch that item is NOIDENTIFY
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.86 1999/03/29 18:34:28 mud Exp $ */
d3960 2
d3987 1
@


1.86
log
@Missing ; line 759
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.85 1999/03/29 05:21:49 mud Exp $ */
d4168 5
@


1.85
log
@Added more to the hidden sections for NOIDENTIFY
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.84 1999/03/29 00:07:46 mud Exp $ */
d795 1
a795 1
	send_to_char("You failed.\n\r",ch)
@


1.84
log
@Weave resistance.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.83 1999/03/28 09:42:57 mud Exp $ */
d3989 2
d4003 1
d4014 2
d4025 1
d4043 2
d4059 1
d4063 2
d4069 1
d4073 2
d4165 1
@


1.83
log
@Fixed typo in NOIDENTIFY check
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.82 1999/03/28 09:32:28 mud Exp $ */
d791 7
@


1.82
log
@Added NOIDENTIFY flag for objects
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.81 1999/03/27 03:42:44 mud Exp $ */
d3944 1
a3944 1
       sprintf( buf, "Extra Flags %s.\n\r", extra_bit_name(obj->extraflags));
@


1.81
log
@one last wyrmslayer update
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.80 1999/03/27 03:37:30 mud Exp $ */
d3921 1
a3921 1
  "Object '%s' is type %s, extra flags %s.\n\rWeight is %d.%d, value is %d, level is %d.\n\r",
a3924 1
  extra_bit_name( obj->extra_flags ),
d3940 6
@


1.80
log
@Added wyrmslayer kit
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.79 1999/03/15 14:57:08 mud Exp $ */
d764 1
@


1.79
log
@Fixed spell_knock
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.78 1999/03/13 17:43:57 mud Exp $ */
d448 1
d574 2
@


1.78
log
@Heal change
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.77 1999/01/12 21:14:31 mud Exp $ */
d442 1
d508 1
d669 1
a669 1
    case TAR_OBJ_CHAR_DEF:
@


1.77
log
@Made focus only usable by those with the kit.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.76 1999/01/12 20:51:29 mud Exp $ */
d3705 1
a3705 1
	healed -= ( healed / 4 );
@


1.76
log
@Higher damage for focus.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.75 1999/01/12 20:24:30 mud Exp $ */
d415 7
@


1.75
log
@Added stuff for wu jen kit.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.74 1999/01/05 17:39:57 mud Exp $ */
d757 1
a757 1
       dam += (mana * dam)/2;
@


1.74
log
@Took out weird check for being already blessed just
because you were in combat in spell_bless().
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.73 1999/01/03 16:54:25 mud Exp $ */
d40 1
a40 1
bool  cast_spell  args( ( CHAR_DATA *ch, char *argument, bool fChant ) );
d394 1
a394 1
     cast_spell( ch, argument, FALSE );
d402 1
a402 1
 	if ( cast_spell( ch, argument, TRUE ) )
d413 17
a429 1
bool cast_spell( CHAR_DATA *ch, char *argument, bool fChant )
d752 10
@


1.73
log
@Fixed crash bug identifying obj's with v4 set to a number outside the
range of the size table.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.72 1998/12/29 20:36:28 mud Exp $ */
d1027 1
a1027 1
    if ( victim->position == POS_FIGHTING || is_affected( victim, sn ) )
@


1.72
log
@Some idiot added a dispel check for fumble in the source directory and didn't
bother to check it in.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.71 1998/12/16 20:42:41 mud Exp $ */
d3897 1
a3897 1
	if (obj->item_type == ITEM_ARMOR)
@


1.71
log
@i
Fix bug
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.70 1998/12/15 22:17:24 mud Exp $ */
d1360 4
a1363 1
 
@


1.70
log
@Spies/Wrymslayers
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.69 1998/12/13 21:32:27 mud Exp $ */
d2778 1
a2778 1
    if (HAS_KIT(ch,"enchantor"))
@


1.69
log
@Fixed holy chant

Stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.68 1998/12/13 03:05:35 mud Exp $ */
d742 3
@


1.68
log
@Bugs!
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.67 1998/12/12 01:20:57 mud Exp $ */
d470 7
a476 1
	mana = ( (100 - (get_skill(ch,gsn_holy_chant) / 5))  * mana / 10 );
@


1.67
log
@Error checking
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.66 1998/12/08 23:23:08 mud Exp $ */
d470 1
a470 1
	mana = 3 * mana / 4;
@


1.66
log
@More stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.65 1998/12/08 23:12:10 mud Exp $ */
d40 1
d388 27
d429 1
a429 1
  return;
d437 1
a437 1
  return;
d445 1
a445 1
  return;
d450 1
a450 1
      return;
d453 1
a453 1
    if ( ch->position < skill_table[sn].minimum_position )
d456 1
a456 1
  return;
d469 3
d484 1
a484 1
  return;
d495 1
a495 1
    return;
d503 1
a503 1
    return;
d510 1
a510 1
            return;
d519 1
a519 1
        return;
d528 1
a528 1
    return; 
d537 1
a537 1
      return;
d554 1
a554 1
    return;
d566 1
a566 1
      return;
d577 1
a577 1
      return;
d583 1
a583 1
      return;
d596 1
a596 1
    return;
d611 1
a611 1
    return;
d618 1
a618 1
                return;
d634 1
a634 1
      return;
d657 1
a657 1
      return;
d670 1
a670 1
	      return;
d682 1
a682 1
       return;
d726 1
a726 1
	return;
d740 1
a740 1
	     return;
d767 1
a767 1
    return;
@


1.65
log
@A
Bugs fixed.  Prophets added
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.64 1998/12/05 21:44:06 mud Exp $ */
d342 6
a347 1
	level++;
@


1.64
log
@Kits!
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.63 1998/12/05 09:50:20 mud Exp $ */
d340 3
@


1.63
log
@Kit stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.62 1998/12/01 16:02:55 mud Exp $ */
d2729 3
a2731 1
 
d2739 1
a2739 1
    fail = URANGE(5,fail,85);
d2810 2
a2811 1
    else  /* exceptional enchant */
d2819 10
a2828 1
    
d2945 3
d2956 1
a2956 1
    fail = URANGE(5,fail,95);
d3029 2
a3030 1
    else  /* exceptional enchant */
d3037 9
@


1.62
log
@Fixed negative weight values for spell_warp()
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.61 1998/11/29 22:26:23 mud Exp $ */
d2304 14
d5727 2
d5745 1
a5745 1
	if ( gch->leader == victim )
d5749 1
a5749 1
   send_to_char("Another group member is transferring.\n\r",victim);	  
@


1.61
log
@Neat crusader stuff
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.60 1998/11/28 07:49:35 mud Exp $ */
d2645 1
a2645 1
    obj->weight =  ( ( 100 + factor ) * obj->weight ) / 100;
@


1.60
log
@favored flag
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.59 1998/11/22 10:36:38 mud Exp $ */
d249 3
@


1.59
log
@Added wizards
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.58 1998/11/22 08:14:42 mud Exp $ */
d1686 1
a1686 1
    light = create_object( get_obj_index( OBJ_VNUM_LIGHT_BALL ), 0 );
d1714 1
a1714 1
    mushroom = create_object( get_obj_index( OBJ_VNUM_MUSHROOM ), 0 );
d1726 1
a1726 1
    rose = create_object(get_obj_index(OBJ_VNUM_ROSE), 0);
d1737 1
a1737 1
    fount = create_object( get_obj_index( OBJ_VNUM_FOUNTAIN ), 0 );
d1751 1
a1751 1
    spring = create_object( get_obj_index( OBJ_VNUM_SPRING ), 0 );
d2913 3
d3317 1
a3317 1
    disc = create_object(get_obj_index(OBJ_VNUM_DISC), 0);
@


1.58
log
@I had to split up clan checks and can_see_room() checiks, added them all back into the code to make sure it's all consistant
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.57 1998/11/19 09:06:02 mud Exp $ */
d362 3
@


1.57
log
@added color
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.56 1998/11/15 09:29:36 mud Exp $ */
d3430 2
a3431 1
    ||   !can_see_room(ch,victim->in_room) 
@


1.56
log
@minor bug fix.  aeshteic thing
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.55 1998/11/14 07:15:53 mud Exp $ */
d1031 2
a1032 2
    send_to_char( "You are blinded!\n\r", victim );
    act("$n appears to be blinded.",victim,NULL,NULL,TO_ROOM);
d2790 2
a2791 2
  act("$p glows a brilliant gold!",ch,obj,NULL,TO_CHAR);
  act("$p glows a brilliant gold!",ch,obj,NULL,TO_ROOM);
d2993 2
a2994 2
  act("$p glows a brilliant blue!",ch,obj,NULL,TO_CHAR);
  act("$p glows a brilliant blue!",ch,obj,NULL,TO_ROOM);
@


1.55
log
@Finished the damn reclass changed finally.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.54 1998/11/10 19:20:50 mud Exp $ */
a2288 2
    if( level < ch->level)
      level = UMIN(ch->level, level + ch->level /5);
d4902 1
a4902 1
        return;
@


1.54
log
@Made it a bit more difficult to dispel the "good" spells off
of someone.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.53 1998/10/27 22:10:41 mud Exp $ */
d325 3
d1833 4
d1890 4
d1935 4
d2715 4
d2915 5
d3571 4
@


1.53
log
@fixed victim in magres = victim->level / 3; for dragon magic resist
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.52 1998/10/25 18:52:52 mud Exp $ */
d2286 4
a2289 1
        found = TRUE;
d2292 1
d2294 1
d2297 4
a2300 1
        found = TRUE;
d2310 1
d2343 2
d2346 1
d2349 2
d2352 1
d2355 2
d2358 1
d2361 2
d2364 1
a2364 5
 
        found = TRUE;
 
    if (check_dispel(level,victim,skill_lookup("detect hidden")))
        found = TRUE;
d2367 2
d2370 1
d2390 1
d2397 1
d2404 1
d2411 1
d2416 2
d2419 1
d2424 1
d2434 1
d2439 2
d2442 2
a2443 1
 
d2446 2
d2449 1
d2452 4
a2455 1
	found = TRUE;
d2458 2
d2461 1
d2467 1
d2484 1
d2500 1
@


1.52
log
@more of the same
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.51 1998/10/25 18:38:47 mud Exp $ */
d687 1
a687 1
	 magres = ch->level / 3;
@


1.51
log
@Removal of more hours shit
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.50 1998/10/24 22:03:03 mud Exp $ */
d687 1
a687 4
	 magres = UMAX(20,get_age(victim) / 4);

	 if ( magres > 25 )
	    magres = ( magres-25 ) /2 + 25;
@


1.50
log
@a
Fixed a little vorpal bug thig
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.49 1998/10/22 05:27:00 mud Exp $ */
d326 8
a333 1
        level += get_age(ch) / 20;
d349 1
a349 1
	level += ( (get_age(ch) > 35) + (get_age(ch) > 50) );
d354 1
a354 1
    if ( level > 53 )
d687 1
a687 1
	 magres = get_age(victim) / 4;
@


1.49
log
@Checanged curve on casting level
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.48 1998/10/21 00:36:37 mud Exp $ */
d200 1
a200 1
      if ( number_percent() < get_skill(rch,gsn_spellcraft) )
d246 3
@


1.48
log
@Fixed bug in magic missile
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.47 1998/10/19 06:15:16 mud Exp $ */
d341 1
a341 1
    if ( number_percent() < get_skill(ch,gsn_spellcraft) )
d344 5
a348 2
    if ( level > 55 )
       level = ( level - 55 ) / 2 + 55;
@


1.47
log
@Volare changes
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.46 1998/10/19 06:09:16 mud Exp $ */
d4134 1
a4134 1
    num_missiles = 1 + UMIN(ch->level / 4, 4);
d4143 1
a4143 1
    if ( victim == NULL )
@


1.46
log
@*** empty log message ***
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.45 1998/10/17 08:03:15 mud Exp $ */
d1817 3
d1870 3
d1911 3
d3489 1
d3493 1
a3493 1
	healed += 25;
a3494 1
    CHAR_DATA *victim = (CHAR_DATA *) vo;
@


1.45
log
@Yinn changed, faeirie changes
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.44 1998/10/14 17:38:01 mud Exp $ */
d3479 6
d3486 1
a3486 1
    victim->hit = UMIN( victim->hit + 100, victim->max_hit );
@


1.44
log
@Fixed typo in enchant weapon s/explodeds/explodes
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.43 1998/10/13 23:07:43 mud Exp $ */
d329 3
d333 4
d4785 2
a4786 1
    level = UMIN( level, 51 );
@


1.43
log
@Changed to rockbiter hp gains and faerie saves
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.42 1998/10/11 00:36:22 mud Exp $ */
d2837 1
a2837 1
  act("$p shivers violently and explodeds!",ch,obj,NULL,TO_ROOM);
@


1.42
log
@Fixing stupid typos
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.41 1998/10/11 00:35:37 mud Exp $ */
d229 1
a229 2
	if( victim->race == race_lookup("elf") ||
	    victim->race == race_lookup("faerie") ) saving_throw -= 5;
@


1.41
log
@*** empty log message ***
@
text
@d1 1
a1 1
/`***************************************************************************
d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.40 1998/10/11 00:31:11 mud Exp $ */
@


1.40
log
@Fixed magic missile bug
@
text
@d1 1
a1 1
***************************************************************************
d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.39 1998/10/09 20:15:18 mud Exp $ */
@


1.39
log
@charm break changes
-Rusty
@
text
@d1 1
a1 1
/***************************************************************************
d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.38 1998/10/09 19:04:04 mud Exp $ */
d4122 2
@


1.38
log
@can't cast your way out of charm
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.37 1998/10/09 18:44:31 mud Exp $ */
a366 6
  if( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL)
  {
    send_to_char("Your master didn't tell you to do that.\n\r",ch);
    return;
  }

d3331 6
d4901 6
d4996 6
@


1.37
log
@snare traps holding you with spells.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.36 1998/10/09 17:59:48 mud Exp $ */
d366 6
@


1.36
log
@and clanned too
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.35 1998/10/09 17:56:45 mud Exp $ */
d3325 6
d4889 6
d4979 6
@


1.35
log
@Can always gate to groupmates.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.34 1998/10/09 01:35:03 mud Exp $ */
d3335 1
a3335 1
    ||   (is_clan(victim) && !is_same_clan(ch,victim))
@


1.34
log
@Spellcraft bug fixed
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.33 1998/10/09 00:46:01 mud Exp $ */
d3334 1
a3334 1
    ||   victim->level >= ch->level + 3
@


1.33
log
@more spellcraft junk
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.32 1998/10/09 00:35:44 mud Exp $ */
d644 2
d648 1
@


1.32
log
@C

Fixed warp bug
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.31 1998/10/06 22:03:07 mud Exp $ */
d627 8
a634 2
    WAIT_STATE( ch, skill_table[sn].beats );
      
@


1.31
log
@C

Added no_transport to teleport and wor
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.30 1998/10/05 09:10:27 mud Exp $ */
d2544 4
a2547 2
     * Using a new variable for the sake of clarity */

d2550 1
@


1.30
log
@C

Added ability to flag an entrei area as no-transport.
Set any mob in the area to act_notrans and it's automatic from there.
Saves us the annoyance of converting area files formats.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.29 1998/10/05 06:17:41 mud Exp $ */
d4875 1
d4978 6
@


1.29
log
@C

Added spellcraft
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.28 1998/10/05 04:13:35 mud Exp $ */
d3328 3
a3330 1
    ||  victim->in_room->area->under_develop )
d4846 3
a4848 1
    ||  victim->in_room->area->under_develop )
@


1.28
log
@C

Changes to flee code and energy drain.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.27 1998/10/02 23:39:35 mud Exp $ */
d197 6
a202 1
  if ( rch != ch )
d335 3
d633 6
d2616 3
d2812 3
@


1.27
log
@Faeries adjusted, maladictions hurt more
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.26 1998/09/23 23:27:24 mud Exp $ */
d2978 4
a2981 1
  victim->mana  /= 2;
d2983 4
a2986 1
  victim->move  /= 2;
@


1.26
log
@Put damage after spell affect in demonfire and ray of truth.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.25 1998/09/20 07:46:18 mud Exp $ */
d615 4
a618 1
      
@


1.25
log
@Fixed faerie mana gains a bit.  Tested them by advancing one to 51 with a
re-imb and it had 200 hp :)  So, gave them double mana.  Added dodge size
stuff.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.24 1998/08/30 03:33:38 mud Exp $ */
d1983 1
a1984 1
    spell_curse(gsn_curse, 3 * level / 4, ch, (void *) victim,TARGET_CHAR);
a4408 1
    damage_old( ch, victim, dam, sn, DAM_HOLY ,TRUE);
d4411 1
@


1.24
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.23 1998/08/20 21:05:35 mud Exp $ */
d224 2
a225 1
	if( victim->race == race_lookup("elf") ) saving_throw -= 5;
d323 3
@


1.23
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.22 1998/08/17 20:05:02 mud Exp $ */
d5723 1
a5723 1
  if(IS_SET(ch->act,PLR_COLOR))
@


1.22
log
@Elementalists and some of their spells added.
Material table begun.

-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.21 1998/08/13 05:24:11 mud Exp $ */
d320 6
d585 21
a605 2
  send_to_char( "You don't have enough mana.\n\r", ch );
  return;
d608 2
a609 1
    if ( str_cmp( skill_table[sn].name, "ventriloquate" ) )
d958 14
a971 2
    if ( IS_AFFECTED(victim, AFF_BLIND) || saves_spell(level,victim,DAM_OTHER))
  return;
d1033 1
a1033 1
    dam = dice(level/2, 8);
d1036 1
a1036 1
		deity_table[ch->deity].pname);
d1154 4
a1157 1
 
d1278 4
a1281 1
 
d1348 1
a1348 1
    damage_old( ch, (CHAR_DATA *) vo, dice(1, 8) + level / 3, sn,DAM_HARM,TRUE);
d1356 1
a1356 1
    damage_old( ch, (CHAR_DATA *) vo, dice(3, 8) + level - 6, sn,DAM_HARM,TRUE);
d1364 1
a1364 1
    damage_old( ch, (CHAR_DATA *) vo, dice(2, 8) + level / 2, sn,DAM_HARM,TRUE);
d1793 1
d1795 2
a1796 1
    if ( !is_affected( victim, gsn_plague ) )
d1809 1
d1811 9
a1819 1
    else
d2232 4
a2235 1
 
d2345 4
a2348 1
 
d2970 1
d2972 1
d3222 3
a3224 1
    if (is_affected(victim,sn) || IS_AFFECTED(victim,AFF_BERSERK))
d3357 1
a3357 8
    CHAR_DATA *victim = (CHAR_DATA *) vo;
    int dam;

    dam = UMAX(  20, victim->hit - dice(1,4) );
    if ( saves_spell( level, victim,DAM_HARM) )
  dam = UMIN( 50, dam / 2 );
    dam = UMIN( 100, dam );
    damage_old( ch, victim, dam, sn, DAM_HARM ,TRUE);
d4052 3
d4058 3
a4061 2
    if ( saves_spell( level, victim,DAM_ENERGY) )
  dam /= 2;
d4063 2
d4731 1
a4731 1
        if (!check_dispel(level,victim,skill_lookup("haste")))
d4765 1
a4765 1
    if ( is_affected( ch, sn ) )
@


1.21
log
@* Various bug fixes, mostly
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.20 1998/08/12 08:20:20 mud Exp $ */
d318 4
a321 1
        level = UMIN(56,ch->level + (get_age(ch) / 20));
d1126 6
d1155 4
a1158 1
 
d2186 7
a2192 1
 
d2239 3
@


1.20
log
@* Finished traps
* Rockbiters added
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.19 1998/08/10 21:32:54 mud Exp $ */
d604 17
@


1.19
log
@* tail slap, and some bug fixes for it
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.18 1998/08/10 19:41:24 mud Exp $ */
d1218 3
d1425 2
a1426 1
    ||   victim->position == POS_FIGHTING )
d1608 14
d2262 3
@


1.18
log
@* Starter code for 'feign death'
* Protection neutral added
* Fixed bug with vampires
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.17 1998/08/10 05:32:16 mud Exp $ */
d305 1
a305 1

@


1.17
log
@* Added wound transfer spell
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.16 1998/08/10 00:08:25 mud Exp $ */
d4151 31
d4188 2
a4189 1
    ||   IS_AFFECTED(victim, AFF_PROTECT_GOOD))
d4218 2
a4219 1
    ||   IS_AFFECTED(victim, AFF_PROTECT_EVIL))
d5361 24
d5420 1
a5420 1
    af.duration = level/5-1;
d5459 3
@


1.16
log
@* Some new wiznet stuff, changes to warp, mundane adjustments
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.15 1998/08/07 20:20:01 mud Exp $ */
d4562 2
d5176 1
a5176 1
    send_to_char ("Your controlling as many undead as you can handle.",ch);
d5183 1
a5183 1
  victim->level = ch->level*2/3+1;
d5187 3
a5189 3
  victim->max_hit = victim->level * 8 + number_range(
          victim->level * victim->level/8,
          victim->level * victim->level);
d5193 1
a5193 1
  victim->damage[DICE_NUMBER] = victim->level/8+1;
d5206 1
a5206 1
  victim->life_timer = ch->level/5+5;
d5276 1
d5278 2
a5279 2

  for ( gch = ch->in_room->people; gch != NULL; gch = next_char ) {
d5281 3
a5283 1
    if (IS_SET((gch)->form, FORM_UNDEAD) && IS_NPC(gch)) {
d5285 24
a5308 12
      if (saves_spell (level,gch,DAM_HOLY)) {
  act ("$n seems unaffected.",gch,NULL,NULL,TO_ROOM);
  if (IS_AWAKE(gch) && gch->fighting == NULL) {
    act ("$n twitches and attacks!",gch,NULL,NULL,TO_ROOM);
    if (gch->leader == ch) {
      REMOVE_BIT(gch->affected_by,AFF_CHARM);
      gch->leader = NULL;
      gch->master = NULL;
    }
  multi_hit(gch,ch,TYPE_UNDEFINED);
  }
      } else {
d5314 1
a5314 1
  }                    /* copy the objects to the room */
d5326 46
@


1.15
log
@Room affects stuff for traps.
Bleed/vampire changes.
swim/scan start at 50% and 50%up for free for existing characters.
moved trap to after trip in interp list for grandfathered use
- Both of Us
@
text
@d2 1
a2 1
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.14 1998/08/06 04:24:53 mud Exp $ */
d2349 2
a2350 1
    if (IS_SET(obj->extra_flags,ITEM_WARPED)) 
d2352 2
a2353 2
   
    level -= ( ++obj->warps * 5 );
@


1.14
log
@Tons of stuff, mostly additions of holy flag for weapons.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.13 1998/08/05 08:46:16 mud Exp $ */
d1328 1
d1331 1
d1439 1
d4560 1
a4560 1
 
@


1.13
log
@* Few superficial changes, added decimal part of weight to ident
  spell

  -BEn
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.12 1998/08/05 08:14:35 mud Exp $ */
d302 20
d603 3
a605 12
     if (IS_NPC(ch))
	level = ch->level;
     else
	{
	  level = ((3+class_table[ch->class].fMana)*ch->level)/5;
	  if (class_table[ch->class].fMana == 1)
	    level += 2;
	  if(ch->class == class_lookup("druid") || IS_SET(ch->act,PLR_OLD)) 
	    level = UMIN(58,ch->level + (get_age(ch) / 20));
	}
            (*skill_table[sn].spell_fun) (sn, level, ch, vo,target);
        check_improve(ch,sn,TRUE,1);
d2997 2
a2998 1
    if ( ( victim != ch ) && saves_spell(level,victim,DAM_OTHER) )
d3008 2
a3011 1
    act("You are absolutely famished!",ch,NULL,victim,TO_VICT);
d3031 2
a3034 1
    act("You feel nourished.",ch,NULL,victim,TO_VICT);
@


1.12
log
@* Added changing weights for warp
* Also added a ->warps field to objects ... the more you warp
  something the greater the chances of blowing it up.
  -Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.11 1998/08/05 06:59:14 mud Exp $ */
d3488 1
a3488 1
  "Object '%s' is type %s, extra flags %s.\n\rWeight is %d, value is %d, level is %d.\n\r",
d3493 1
a3493 1
  obj->weight / 10,
@


1.11
log
@* Fire breath blind effect lowered to 0 ticks from 1
* Few minor aesthetic fixes in spells and eating code

-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.10 1998/08/05 06:31:16 mud Exp $ */
d2320 1
d2337 3
d2351 3
d2384 8
@


1.10
log
@* Fixed wiznet notes
* Added feast/famine spells
* Changed nosferatu bleed/hunger stuff
* Upped damage on bleed
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.9 1998/08/02 15:26:28 mud Exp $ */
d2971 1
a2971 1
    if (  saves_spell(level,victim,DAM_OTHER) )
d2981 1
d2992 1
a2992 1
    if ( IS_SET(victim->act,PLR_NOCANCEL) &&
d3003 1
@


1.9
log
@transport spell level adjustments
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.8 1998/08/02 14:30:36 mud Exp $ */
d2905 7
a2911 2
    if ( IS_AFFECTED(victim, AFF_FAERIE_FIRE) || saves_spell(level,victim,DAM_FIRE) )
  return;
d2963 41
@


1.8
log
@Druid dodge, parry and shield block reductions
removal of nofollow cancelling charm and spell_charm_person() tweeked
to accomodate PC charmings.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.7 1998/08/01 13:03:28 mud Exp $ */
d1424 2
a1425 2
  case IS_RESISTANT:  IS_NPC(victim)?level /= 2:level = 1;  break;
  case IS_VULNERABLE: IS_NPC(victim)?level += 4:level = 2;  break;
d3084 1
a3084 1
    ||   victim->level >= level + 3
@


1.7
log
@Piety spells level mod
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.6 1998/07/31 21:06:11 mud Exp $ */
d589 1
a589 1
	    level += class_table[ch->class].fMana*2;
d1067 2
a1068 2
    if (class_table[ch->class].fMana == 1)
      level += ch->level/5;
d1423 3
a1425 3
  case IS_IMMUNE:   level = 1;  break;
  case IS_RESISTANT:  level /= 2;  break;
  case IS_VULNERABLE: level += 4;  break;
d1429 1
a1429 1
  stop_follower( victim );
d1435 1
a1435 1
    af.duration  = number_fuzzy( level / 4 );
d2103 2
a2104 2
    if (class_table[ch->class].fMana == 1)
      level += ch->level /5;
@


1.6
log
@dispel and cancellation level change adjustment
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.5 1998/07/31 20:51:20 mud Exp $ */
d588 2
a589 1
	  level += class_table[ch->class].fMana;
@


1.5
log
@One more fMana change
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.4 1998/07/31 20:37:44 mud Exp $ */
d1066 2
d2102 2
@


1.4
log
@fMana mods
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.3 1998/07/30 15:39:38 mud Exp $ */
d588 1
@


1.3
log
@Saves add wis check mod.
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.2 1998/07/30 15:36:58 mud Exp $ */
d242 1
a242 1
    if (!IS_NPC(victim) && class_table[victim->class].fMana)
d318 1
d583 9
a591 7
     if (IS_NPC(ch) || class_table[ch->class].fMana || IS_SET(ch->act,PLR_OLD)) 
  /* class has spells */
      (*skill_table[sn].spell_fun) ( sn, (ch->class == class_lookup("druid")) ?
				    ch->level + (get_age(ch) / 20) : ch->level,
				    ch, vo, target);
        else
            (*skill_table[sn].spell_fun) (sn, 3 * ch->level/4, ch, vo,target);
@


1.2
log
@aves change
@
text
@d18 1
a18 1
/* @@(#)$Id: magic.c,v 1.1 1998/06/16 17:49:38 mud Exp $ */
d225 1
a225 1
    save = 25 + get_curr_stat(victim,STAT_INT)
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d225 2
a226 1
    save = 50 + ( victim->level - level) * 5 - saving_throw * 2;
@
