head	1.57;
access;
symbols;
locks; strict;
comment	@ * @;


1.57
date	2003.01.01.17.04.27;	author rusty;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.20.15.55.00;	author rusty;	state Exp;
branches;
next	1.55;

1.55
date	2002.04.05.03.49.16;	author rusty;	state Exp;
branches;
next	1.54;

1.54
date	2002.04.04.16.23.12;	author rusty;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.01.21.05.45;	author rusty;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.22.16.32.56;	author poquah;	state Exp;
branches;
next	1.51;

1.51
date	2000.11.27.23.25.32;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2000.11.27.23.24.47;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2000.11.27.23.15.35;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2000.11.27.23.10.57;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2000.11.27.21.52.19;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2000.09.16.12.53.19;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2000.06.18.20.36.06;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2000.05.15.19.38.41;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2000.05.05.00.22.26;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2000.05.05.00.21.36;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2000.05.05.00.16.02;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2000.05.05.00.14.07;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2000.05.05.00.11.09;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.29.07.30.07;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.29.07.28.54;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2000.02.23.00.11.46;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2000.02.20.19.36.44;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.20.19.14.30;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2000.02.20.19.12.51;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2000.02.20.19.12.02;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.20.19.06.27;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.20.19.04.30;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.20.19.01.49;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.20.18.59.36;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.20.18.57.07;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.09.21.03.16;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	99.12.19.19.47.54;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	99.10.10.15.18.50;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	99.09.01.19.57.10;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	99.09.01.16.43.51;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	99.07.14.18.14.03;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	99.06.24.22.37.24;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	99.06.24.22.29.11;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	99.05.12.21.19.31;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	99.05.12.20.53.30;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	99.04.08.22.50.17;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	99.03.28.00.56.59;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	99.03.14.16.43.23;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.12.13.03.19.47;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.12.13.03.05.36;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.11.29.05.19.26;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.11.27.07.57.07;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.10.18.16.27.56;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.30.03.33.39;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.21.14.21.11;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.20.21.05.37;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.05.06.31.18;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.04.18.03.08;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.04.17.21.38;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.07.29.05.44.13;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.40;	author mud;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Added CLAN_PAB flag and made it show in who/whois when they are not AFK
as well as letting them read "note to pab"
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/
 
static char rcsid[] = "$Id: note.c,v 1.56 2002/06/20 15:55:00 rusty Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#ifdef GAME_VERSION
#include "gc.h"
#endif
#include "merc.h"
#include "recycle.h"
#include "tables.h"
/*
 #include "imc-mercbase.h"
 */

/* globals from db.c for load_notes */
#if !defined(macintosh)
extern  int     _filbuf         args( (FILE *) );
#endif
extern FILE *                  fpArea;
extern char                    strArea[MAX_INPUT_LENGTH];

/* local procedures */
void load_thread(char *name, NOTE_DATA **list, int type, time_t free_time);
void parse_note(CHAR_DATA *ch, char *argument, int type);
bool hide_note(CHAR_DATA *ch, NOTE_DATA *pnote);

/* imported functions */
int	clan_lookup	args( (const char *name) );

NOTE_DATA *note_list;
NOTE_DATA *immortal_list;
NOTE_DATA *idea_list;
NOTE_DATA *penalty_list;
NOTE_DATA *news_list;
NOTE_DATA *changes_list;
NOTE_DATA *ooc_list;
NOTE_DATA *bug_list;
NOTE_DATA *clan_list;
NOTE_DATA *quest_list;

int count_spool(CHAR_DATA *ch, NOTE_DATA *spool)
{
    int count = 0;
    NOTE_DATA *pnote;

    for (pnote = spool; pnote != NULL; pnote = pnote->next)
  if (!hide_note(ch,pnote))
      count++;

    return count;
}

void do_spool(CHAR_DATA *ch)
{
  if(!IS_NPC(ch))
    {
    ch->pcdata->last_note = current_time;                                       
    ch->pcdata->last_idea = current_time;                                       
    ch->pcdata->last_penalty = current_time;                                    
    ch->pcdata->last_news = current_time;                                       
    ch->pcdata->last_changes = current_time;                                    
    ch->pcdata->last_ooc = current_time;  
    ch->pcdata->last_bug = current_time;  
    ch->pcdata->last_cnote = current_time;
    ch->pcdata->last_qnote = current_time;
    ch->pcdata->last_immnote = current_time;
    send_to_char("All note spools caught up.\n\r",ch);
    }

  return;
}

void do_unread(CHAR_DATA *ch)
{
    char buf[MAX_STRING_LENGTH];
    int count;
    bool found = FALSE;

    if (IS_NPC(ch))
  return; 

    if ((count = count_spool(ch,news_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"There %s %d new news article%s waiting.\n\r",
      count > 1 ? "are" : "is",count, count > 1 ? "s" : "");
  send_to_char(buf,ch);
    }
    if ((count = count_spool(ch,changes_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"There %s %d change%s waiting to be read.\n\r",
      count > 1 ? "are" : "is", count, count > 1 ? "s" : "");
        send_to_char(buf,ch);
    }
    if ((count = count_spool(ch,note_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"You have %d new IC note%s waiting.\n\r",
      count, count > 1 ? "s" : "");
  send_to_char(buf,ch);
    }
    if ((count = count_spool(ch,ooc_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"You have %d new OOC note%s waiting.\n\r",
      count, count > 1 ? "s" : "");
  send_to_char(buf,ch);
    }
    if ((count=count_spool(ch,bug_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"There have been %d bug%s reported.\n\r",
	count, count > 1 ? "s" : "");
  send_to_char(buf,ch);
    }
    if ((count = count_spool(ch,clan_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"You have %d clan note%s to read.\n\r",
      count, count > 1 ? "s" : "" );
  send_to_char(buf,ch);
    }
    if ((count = count_spool(ch,idea_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"You have %d unread idea%s to peruse.\n\r",
      count, count > 1 ? "s" : "");
  send_to_char(buf,ch);
    }
    if ((count = count_spool(ch,quest_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"You have %d quest note%s to read.\n\r",
      count, count > 1 ? "s" : "" );
  send_to_char(buf,ch);
    }
    if (IS_TRUSTED(ch,ANGEL) && (count = count_spool(ch,penalty_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"%d %s been added.\n\r",
      count, count > 1 ? "penalties have" : "penalty has");
  send_to_char(buf,ch);
    }
    if (IS_TRUSTED(ch,ANGEL) && (count = count_spool(ch,immortal_list)) > 0)
    {
  found = TRUE;
  sprintf(buf,"%d %s been added.\n\r",
      count, count > 1 ? "gnotes have" : "gnote has");
  send_to_char(buf,ch);
    }

    if (!found)
  send_to_char("You have no unread notes.\n\r",ch);
}

void do_qnotes(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_QUEST);
}

void do_cnotes(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_CLAN);
}

void do_immnote(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_IMMORTAL);
}

void do_note(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_NOTE);
}

void do_idea(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_IDEA);
}

void do_onote(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_OOC);
}

void do_bug(CHAR_DATA *ch, char *argument)
{
    parse_note(ch,argument,NOTE_BUG);
}

void do_penalty(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_PENALTY);
}

void do_news(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_NEWS);
}

void do_changes(CHAR_DATA *ch,char *argument)
{
    parse_note(ch,argument,NOTE_CHANGES);
}

void save_notes(int type)
{
    FILE *fp;
    char *name;
    NOTE_DATA *pnote;

    switch (type)
    {
  default:
      return;
  case NOTE_CLAN:
      name = CLAN_FILE;
      pnote = clan_list;
      break;
  case NOTE_IMMORTAL:
      name = IMMORTAL_FILE;
      pnote = immortal_list;
      break;
  case NOTE_NOTE:
      name = NOTE_FILE;
      pnote = note_list;
      break;
  case NOTE_IDEA:
      name = IDEA_FILE;
      pnote = idea_list;
      break;
  case NOTE_PENALTY:
      name = PENALTY_FILE;
      pnote = penalty_list;
      break;
  case NOTE_NEWS:
      name = NEWS_FILE;
      pnote = news_list;
      break;
  case NOTE_CHANGES:
      name = CHANGES_FILE;
      pnote = changes_list;
      break;
  case NOTE_OOC:
      name = OOC_FILE;
      pnote = ooc_list;
      break;
  case NOTE_BUG:
      name = BUG_FILE;
      pnote = bug_list;
      break;
  case NOTE_QUEST:
      name = QUEST_FILE;
      pnote = quest_list;
      break;
    }

    fclose( fpReserve );
    if ( ( fp = fopen( name, "w" ) ) == NULL )
    {
  perror( name );
    }
    else
    {
  for ( ; pnote != NULL; pnote = pnote->next )
  {
      fprintf( fp, "Sender  %s~\n", pnote->sender);
      fprintf( fp, "Date    %s~\n", pnote->date);
      fprintf( fp, "Stamp   %ld\n", pnote->date_stamp);
      fprintf( fp, "To      %s~\n", pnote->to_list);
      fprintf( fp, "Subject %s~\n", pnote->subject);
      fprintf( fp, "Text\n%s~\n",   pnote->text);
  }
  fclose( fp );
  fpReserve = fopen( NULL_FILE, "r" );
    return;
    }
}
void load_notes(void)
{
    load_thread(NOTE_FILE,&note_list, NOTE_NOTE, 4*24*60*60);
    load_thread(OOC_FILE,&ooc_list, NOTE_OOC, 4*24*60*60);
    load_thread(BUG_FILE,&bug_list,NOTE_BUG, 60*24*60*60);
    load_thread(IDEA_FILE,&idea_list, NOTE_IDEA, 5*24*60*60);
    load_thread(PENALTY_FILE,&penalty_list, NOTE_PENALTY, 60*24*60*60);
    load_thread(NEWS_FILE,&news_list, NOTE_NEWS, 60*24*60*60);
    load_thread(CHANGES_FILE,&changes_list,NOTE_CHANGES, 60*24*60*60);
    load_thread(CLAN_FILE,&clan_list,NOTE_CLAN, 4*24*60*60);
    load_thread(IMMORTAL_FILE,&immortal_list, NOTE_IMMORTAL, 20*24*60*60);
    load_thread(QUEST_FILE,&quest_list,NOTE_QUEST, 60*24*60*60);
}

void load_thread(char *name, NOTE_DATA **list, int type, time_t free_time)
{
    FILE *fp;
    NOTE_DATA *pnotelast;
 
    if ( ( fp = fopen( name, "r" ) ) == NULL )
  return;
   
    pnotelast = NULL;
    for ( ; ; )
    {
  NOTE_DATA *pnote;
  char letter;
   
  do
  {
      letter = getc( fp );
            if ( feof(fp) )
            {
                fclose( fp );
                return;
            }
        }
        while ( isspace(letter) );
        ungetc( letter, fp );

        pnote           = new_note();
 
        if ( str_cmp( fread_word( fp ), "sender" ) )
            break;
        pnote->sender   = fread_string( fp );

        if ( str_cmp( fread_word( fp ), "date" ) )
            break;
        pnote->date     = fread_string( fp );
 
        if ( str_cmp( fread_word( fp ), "stamp" ) )
            break;
        pnote->date_stamp = fread_number(fp);
 
        if ( str_cmp( fread_word( fp ), "to" ) )
            break;
        pnote->to_list  = fread_string( fp );
 
        if ( str_cmp( fread_word( fp ), "subject" ) )
            break;
        pnote->subject  = fread_string( fp );
 
        if ( str_cmp( fread_word( fp ), "text" ) )
            break;
        pnote->text     = fread_string( fp );
 
        if (free_time && pnote->date_stamp < current_time - free_time)
        {
      free_note(pnote);
            continue;
        }

  pnote->type = type;
 
        if (*list == NULL)
            *list           = pnote;
        else
            pnotelast->next     = pnote;
 
        pnotelast       = pnote;
    }
 
    strcpy( strArea, NOTE_FILE );
    fpArea = fp;
    bug( "Load_notes: bad key word.", 0 );
    exit( 1 );
    return;
}

void append_note(NOTE_DATA *pnote)
{
    FILE *fp;
    char *name;
    NOTE_DATA **list;
    NOTE_DATA *last;

    switch(pnote->type)
    {
  default:
      return;
  case NOTE_CLAN:
      name = CLAN_FILE;
      list = &clan_list;
      break;
  case NOTE_IMMORTAL:
      name = IMMORTAL_FILE;
      list = &immortal_list;
      break;
  case NOTE_NOTE:
      name = NOTE_FILE;
      list = &note_list;
      break;
  case NOTE_IDEA:
      name = IDEA_FILE;
      list = &idea_list;
      break;
  case NOTE_PENALTY:
      name = PENALTY_FILE;
      list = &penalty_list;
      break;
  case NOTE_NEWS:
       name = NEWS_FILE;
       list = &news_list;
       break;
  case NOTE_CHANGES:
       name = CHANGES_FILE;
       list = &changes_list;
       break;
  case NOTE_OOC:
       name = OOC_FILE;
       list = &ooc_list;
       break;
  case NOTE_BUG:
	name = BUG_FILE;
	list = &bug_list;
	break;
  case NOTE_QUEST:
	name = QUEST_FILE;
	list = &quest_list;
	break;
    }

    if (*list == NULL)
  *list = pnote;
    else
    {
  for ( last = *list; last->next != NULL; last = last->next);
  last->next = pnote;
    }

    fclose(fpReserve);
    if ( ( fp = fopen(name, "a" ) ) == NULL )
    {
        perror(name);
    }
    else
    {
        fprintf( fp, "Sender  %s~\n", pnote->sender);
        fprintf( fp, "Date    %s~\n", pnote->date);
        fprintf( fp, "Stamp   %ld\n", pnote->date_stamp);
        fprintf( fp, "To      %s~\n", pnote->to_list);
        fprintf( fp, "Subject %s~\n", pnote->subject);
        fprintf( fp, "Text\n%s~\n", pnote->text);
        fclose( fp );
    }
    fpReserve = fopen( NULL_FILE, "r" );
}

bool is_note_to( CHAR_DATA *ch, NOTE_DATA *pnote )
{   if ( ch->level == MAX_LEVEL-1)
  return TRUE;
    if ( !str_cmp( ch->name, pnote->sender ) )
  return TRUE;

    if ( is_exact_name( "all", pnote->to_list ) )
  return TRUE;

    if ( IS_IMMORTAL(ch) && is_name( "immortal", pnote->to_list ) )
  return TRUE;

    if ( IS_SET(ch->pcdata->clan_flags, CLAN_PAB) 
	&& is_exact_name("pab", pnote->to_list) )
  return TRUE;

    if ( IS_IMMORTAL(ch) && (is_exact_name("honor",pnote->to_list) 
	 || is_exact_name("posse",pnote->to_list)
	 || is_exact_name("demise",pnote->to_list)
	 || is_exact_name("warlock",pnote->to_list)
	 || is_exact_name("avarice",pnote->to_list)
	 || is_exact_name("zealot",pnote->to_list))) 
        return TRUE;

    if ( ((is_clan(ch) || IS_IMMORTAL(ch))
	   && is_exact_name("clans",pnote->to_list) ) )
	return TRUE;

    if (   (ch->clan && is_exact_name(clan_table[ch->clan].name,pnote->to_list) ) )
  	return TRUE;

    if ( is_exact_name( ch->name, pnote->to_list ) )
  return TRUE;

    if ( ch->level > CREATOR )
	return TRUE;

    return FALSE;
}



void note_attach( CHAR_DATA *ch, int type )
{
    NOTE_DATA *pnote;

    if ( ch->pnote != NULL )
  return;

    pnote = new_note();

    pnote->next   = NULL;
    pnote->sender = str_dup( ch->name );
    pnote->date   = str_dup( "" );
    pnote->to_list  = str_dup( "" );
    pnote->subject  = str_dup( "" );
    pnote->text   = str_dup( "" );
    pnote->type   = type;
    ch->pnote   = pnote;
    return;
}



void note_remove( CHAR_DATA *ch, NOTE_DATA *pnote, bool delete)
{
    char to_new[MAX_INPUT_LENGTH];
    char to_one[MAX_INPUT_LENGTH];
    NOTE_DATA *prev;
    NOTE_DATA **list;
    char *to_list;

    if (!delete)
    {
  /* make a new list */
        to_new[0] = '\0';
        to_list = pnote->to_list;
        while ( *to_list != '\0' )
        {
          to_list = one_argument( to_list, to_one );
          if ( to_one[0] != '\0' && str_cmp( ch->name, to_one ) )
      {
          strcat( to_new, " " );
          strcat( to_new, to_one );
      }
        }
        /* Just a simple recipient removal? */
       if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\0' )
       {
     free_string( pnote->to_list );
     pnote->to_list = str_dup( to_new + 1 );
     return;
       }
    }
    /* nuke the whole note */

    switch(pnote->type)
    {
  default:
      return;
  case NOTE_NOTE:
      list = &note_list;
      break;
  case NOTE_IMMORTAL:
      list = &immortal_list;
      break;
  case NOTE_CLAN:
      list = &clan_list;
      break;
  case NOTE_IDEA:
      list = &idea_list;
      break;
  case NOTE_PENALTY:
      list = &penalty_list;
      break;
  case NOTE_NEWS:
      list = &news_list;
      break;
  case NOTE_CHANGES:
      list = &changes_list;
      break;
  case NOTE_OOC:
      list = &ooc_list;
      break;
 case NOTE_BUG:
	list = &bug_list;
	break;
 case NOTE_QUEST:
	list = &quest_list;
	break;

    }

    /*
     * Remove note from linked list.
     */
    if ( pnote == *list )
    {
  *list = pnote->next;
    }
    else
    {
  for ( prev = *list; prev != NULL; prev = prev->next )
  {
      if ( prev->next == pnote )
    break;
  }

  if ( prev == NULL )
  {
      bug( "Note_remove: pnote not found.", 0 );
      return;
  }

  prev->next = pnote->next;
    }

    
    save_notes (pnote->type);
    free_note(pnote);
    return;
}

bool hide_note (CHAR_DATA *ch, NOTE_DATA *pnote)
{
    time_t last_read;

    if (IS_NPC(ch))
  return TRUE;

    switch (pnote->type)
    {
  default:
      return TRUE;
  case NOTE_NOTE:
      last_read = ch->pcdata->last_note;
      break;
  case NOTE_IMMORTAL:
      last_read = ch->pcdata->last_immnote;
      break;
  case NOTE_CLAN:
      last_read = ch->pcdata->last_cnote;
      break;
  case NOTE_IDEA:
      last_read = ch->pcdata->last_idea;
      break;
  case NOTE_PENALTY:
      last_read = ch->pcdata->last_penalty;
      break;
  case NOTE_NEWS:
      last_read = ch->pcdata->last_news;
      break;
  case NOTE_CHANGES:
      last_read = ch->pcdata->last_changes;
      break;
  case NOTE_OOC:
      last_read = ch->pcdata->last_ooc;
      break;
   case NOTE_BUG:
	last_read = ch->pcdata->last_bug;
	break;
  case NOTE_QUEST:
      last_read = ch->pcdata->last_qnote;
      break;
    }
    
    if (pnote->date_stamp <= last_read)
  return TRUE;

    if (!str_cmp(ch->name,pnote->sender))
  return TRUE;

    if ((!is_note_to(ch,pnote)) && (ch->level < CREATOR))
  return TRUE;

    return FALSE;
}

void update_read(CHAR_DATA *ch, NOTE_DATA *pnote)
{
    time_t stamp;

    if (IS_NPC(ch))
  return;

    stamp = pnote->date_stamp;

    switch (pnote->type)
    {
        default:
            return;
        case NOTE_NOTE:
      ch->pcdata->last_note = UMAX(ch->pcdata->last_note,stamp);
            break;
        case NOTE_IMMORTAL: 
      ch->pcdata->last_immnote = UMAX(ch->pcdata->last_immnote,stamp);
            break;
	case NOTE_CLAN:
      ch->pcdata->last_cnote = UMAX(ch->pcdata->last_cnote,stamp);
	    break;
        case NOTE_IDEA:
      ch->pcdata->last_idea = UMAX(ch->pcdata->last_idea,stamp);
            break;
        case NOTE_PENALTY:
      ch->pcdata->last_penalty = UMAX(ch->pcdata->last_penalty,stamp);
            break;
        case NOTE_NEWS:
      ch->pcdata->last_news = UMAX(ch->pcdata->last_news,stamp);
            break;
        case NOTE_CHANGES:
      ch->pcdata->last_changes = UMAX(ch->pcdata->last_changes,stamp);
            break;
        case NOTE_OOC:
      ch->pcdata->last_ooc = UMAX(ch->pcdata->last_ooc,stamp);
            break;
	case NOTE_BUG:
      ch->pcdata->last_bug = UMAX(ch->pcdata->last_bug,stamp);
	break;
	case NOTE_QUEST:
      ch->pcdata->last_qnote = UMAX(ch->pcdata->last_qnote,stamp);
	    break;
    }
}

void parse_note( CHAR_DATA *ch, char *argument, int type )
{
    BUFFER *buffer;
    char buf[MAX_STRING_LENGTH];
    char buf2[6*MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    char tempTo[MAX_INPUT_LENGTH];
    NOTE_DATA *pnote;
    NOTE_DATA **list;
    char *list_name;
    int vnum;
    int anum;
    char Asender[15];

    if ( IS_NPC(ch) )
  return;
    if ( IS_SET(ch->affected_by, AFF_CHARM) )
  return;

    switch(type)
    {
  default:
      return;
        case NOTE_NOTE:
            list = &note_list;
      list_name = "notes";
            break;
        case NOTE_IMMORTAL:
            list = &immortal_list;
      list_name = "gnotes";
            break;
	case NOTE_CLAN:
	    list = &clan_list;
	    list_name = "cnotes";
	    break;
        case NOTE_IDEA:
            list = &idea_list;
      list_name = "ideas";
            break;
        case NOTE_PENALTY:
            list = &penalty_list;
      list_name = "penalties";
            break;
        case NOTE_NEWS:
            list = &news_list;
      list_name = "news";
            break;
        case NOTE_CHANGES:
            list = &changes_list;
      list_name = "changes";
            break;
        case NOTE_OOC:
            list = &ooc_list;
      list_name = "onotes";
            break;
	case NOTE_BUG:
	list = &bug_list;
	list_name = "bugs";
	break;
	case NOTE_QUEST:
	    list = &quest_list;
	    list_name = "qnotes";
	    break;
    }

    argument = one_argument( argument, arg );
    smash_tilde( argument );

    if ( arg[0] == '\0' || !str_prefix( arg, "read" ) )
    {
        bool fAll;
 
        if ( !str_cmp( argument, "all" ) )
        {
            fAll = TRUE;
            anum = 0;
        }
 
        else if ( argument[0] == '\0' || !str_prefix(argument, "next"))
        /* read next unread note */
        {
            vnum = 0;
            for ( pnote = *list; pnote != NULL; pnote = pnote->next)
            {
                if (type == NOTE_CHANGES && ch->level < CREATOR)
                   strcpy(Asender,"Administration"); 
                else
                   strcpy(Asender,pnote->sender);

                if (!hide_note(ch,pnote))
                {
                    sprintf( buf, "[%3d] %s: %s\n\r%s\n\rTo: %s\n\r",
                        vnum,
                        Asender,
                        pnote->subject,
                        pnote->date,
                        pnote->to_list);
                    send_to_char( buf, ch );
                    page_to_char( pnote->text, ch );
                    update_read(ch,pnote);
                    return;
                }
                else if (is_note_to(ch,pnote))
                    vnum++;
            }
      sprintf(buf,"You have no unread %s.\n\r",list_name);
      send_to_char(buf,ch);
            return;
        }
 
        else if ( is_number( argument ) )
        {
            fAll = FALSE;
            anum = atoi( argument );
        }
        else
        {
            send_to_char( "Read which number?\n\r", ch );
            return;
        }
 
        vnum = 0;
        for ( pnote = *list; pnote != NULL; pnote = pnote->next )
        {
            if (type == NOTE_CHANGES && ch->level < CREATOR)
               strcpy(Asender,"Administration"); 
            else
               strcpy(Asender,pnote->sender);

            if ( is_note_to( ch, pnote ) && ( vnum++ == anum || fAll ) )
            {
                sprintf( buf, "[%3d] %s: %s\n\r%s\n\rTo: %s\n\r",
                    vnum - 1,
                    Asender,
                    pnote->subject,
                    pnote->date,
                    pnote->to_list
                    );
                send_to_char( buf, ch );
                page_to_char( pnote->text, ch );
    update_read(ch,pnote);
                return;
            }
        }
 
  sprintf(buf,"There aren't that many %s.\n\r",list_name);
  send_to_char(buf,ch);
        return;
    }

    if ( !str_prefix( arg, "list" ) )
    {
  vnum = 0;
  buf2[0] = '\0';
  for ( pnote = *list; pnote != NULL; pnote = pnote->next )
  {
      if (type == NOTE_CHANGES && ch->level < CREATOR)
          strcpy(Asender,"Administration"); 
      else
          strcpy(Asender,pnote->sender);

      if ( is_note_to( ch, pnote ) )
      {
	if ((is_exact_name(ch->name,pnote->to_list)
	    || ((is_clan(ch) || (ch->clan == clan_lookup("matook")))
	        &&  is_exact_name(clan_table[ch->clan].name,pnote->to_list)))
	    && IS_SET(ch->display,DISP_COLOR))  
	{
           sprintf( buf, "%s[%3d%s]%s %s: %s\n\r",
              MAGENTA,vnum, hide_note(ch,pnote) ? " " : "N",NORMAL, 
              Asender, pnote->subject );
	}
	else
	{
           sprintf( buf, "%s[%3d%s]%s %s: %s\n\r",
              "",vnum, hide_note(ch,pnote) ? " " : "N","", 
              Asender, pnote->subject );
	}

        strcat( buf2, buf );
        vnum++;
      }
  }
     page_to_char( buf2, ch );
  return;
    }

    if ( !str_prefix( arg, "remove" ) )
    {
        if ( !is_number( argument ) )
        {
            send_to_char( "Note remove which number?\n\r", ch );
            return;
        }
 
        anum = atoi( argument );
        vnum = 0;
        for ( pnote = *list; pnote != NULL; pnote = pnote->next )
        {
            if ( is_note_to( ch, pnote ) && vnum++ == anum )
            {
                note_remove( ch, pnote, FALSE );
                send_to_char( "Ok.\n\r", ch );
                return;
            }
        }
 
  sprintf(buf,"There aren't that many %s.",list_name);
  send_to_char(buf,ch);
        return;
    }
 
    if ( !str_prefix( arg, "delete" ) && get_trust(ch) >= MAX_LEVEL - 1)
    {
        if ( !is_number( argument ) )
        {
            send_to_char( "Note delete which number?\n\r", ch );
            return;
        }
 
        anum = atoi( argument );
        vnum = 0;
        for ( pnote = *list; pnote != NULL; pnote = pnote->next )
        {
            if ( is_note_to( ch, pnote ) && vnum++ == anum )
            {
                note_remove( ch, pnote,TRUE );
                send_to_char( "Ok.\n\r", ch );
                return;
            }
        }

  sprintf(buf,"There aren't that many %s.",list_name);
  send_to_char(buf,ch);
        return;
    }
    
    if (!str_prefix(arg,"catchup"))
    {
  switch(type)
  {
      case NOTE_NOTE: 
    ch->pcdata->last_note = current_time;
    break;
      case NOTE_IMMORTAL: 
    ch->pcdata->last_immnote = current_time;
    break;
      case NOTE_CLAN:
    ch->pcdata->last_cnote = current_time;
    break;
      case NOTE_IDEA:
    ch->pcdata->last_idea = current_time;
    break;
      case NOTE_PENALTY:
    ch->pcdata->last_penalty = current_time;
    break;
      case NOTE_NEWS:
    ch->pcdata->last_news = current_time;
    break;
      case NOTE_CHANGES:
    ch->pcdata->last_changes = current_time;
    break;
      case NOTE_OOC:
    ch->pcdata->last_ooc = current_time;
    break;
    case NOTE_BUG:
    ch->pcdata->last_bug = current_time;
    break;
      case NOTE_QUEST:
    ch->pcdata->last_qnote = current_time;
    break;
  }
  return;
    }

    /* below this point only certain people can edit notes */
    if ((type == NOTE_NEWS && !IS_TRUSTED(ch,ANGEL))
    ||  (type == NOTE_QUEST && !IS_TRUSTED(ch,ANGEL))
    ||  (type == NOTE_CHANGES && !IS_TRUSTED(ch,CREATOR)))
    {
  sprintf(buf,"You aren't high enough level to write %s.",list_name);
  return;
    }

    if ( !str_cmp( arg, "+" ) )
    {
  note_attach( ch,type );
  if (ch->pnote->type != type)
  {
      send_to_char(
    "You already have a different note in progress.\n\r",ch);
      return;
  }
  buffer = new_buf();

  if (strlen(ch->pnote->text)+strlen(argument) >= 4096)
  {
      send_to_char( "Note too long.\n\r", ch );
      return;
  }

  add_buf(buffer,ch->pnote->text);
  if ( strlen(argument) > 78 )
    {
     argument[79] = '\0';
     send_to_char("Line too long, truncated to:\n\r",ch);
     send_to_char(argument,ch);
     send_to_char("\n\r",ch);
    }
  add_buf(buffer,argument);
  add_buf(buffer,"\n\r");
  free_string( ch->pnote->text );
  ch->pnote->text = str_dup( buf_string(buffer) );
  free_buf(buffer);
  send_to_char( "Ok.\n\r", ch );
  return;
    }

    if (!str_cmp(arg,"-"))
    {
  int len;
  bool found = FALSE;

  note_attach(ch,type);
        if (ch->pnote->type != type)
        {
            send_to_char(
                "You already have a different note in progress.\n\r",ch);
            return;
        }

  if (ch->pnote->text == NULL || ch->pnote->text[0] == '\0')
  {
      send_to_char("No lines left to remove.\n\r",ch);
      return;
  }

  strcpy(buf,ch->pnote->text);

  for (len = strlen(buf); len > 0; len--)
  {
      if (buf[len] == '\r')
      {
    if (!found)  /* back it up */
    {
        if (len > 0)
      len--;
        found = TRUE;
    }
    else /* found the second one */
    {
        buf[len + 1] = '\0';
        free_string(ch->pnote->text);
        ch->pnote->text = str_dup(buf);
        return;
    }
      }
  }
  buf[0] = '\0';
  free_string(ch->pnote->text);
  ch->pnote->text = str_dup(buf);
  return;
    }

    if ( !str_prefix( arg, "subject" ) )
    {
  note_attach( ch,type );
        if (ch->pnote->type != type)
        {
            send_to_char(
                "You already have a different note in progress.\n\r",ch);
            return;
        }

  free_string( ch->pnote->subject );
  ch->pnote->subject = str_dup( argument );
  send_to_char( "Ok.\n\r", ch );
  return;
    }

    if ( !str_prefix( arg, "to" ) )
    {
  note_attach( ch,type );
        if (ch->pnote->type != type)
        {
            send_to_char(
                "You already have a different note in progress.\n\r",ch);
            return;
        }

       if ( ch->pnote->type == NOTE_BUG ) 
       {
	   send_to_char(
    "You do not need to fill in the TO field on bug notes.\n\r",ch);
	   return;
       }
  free_string( ch->pnote->to_list );
  ch->pnote->to_list = str_dup( argument );
  send_to_char( "Ok.\n\r", ch );
  return;
    }

    if ( !str_prefix( arg, "clear" ) )
    {
  if ( ch->pnote != NULL )
  {
      free_note(ch->pnote);
      ch->pnote = NULL;
  }

  send_to_char( "Ok.\n\r", ch );
  return;
    }

    if ( !str_prefix( arg, "show" ) )
    {
  if ( ch->pnote == NULL )
  {
      send_to_char( "You have no note in progress.\n\r", ch );
      return;
  }

  if (ch->pnote->type != type)
  {
      send_to_char("You aren't working on that kind of note.\n\r",ch);
      return;
  }

  sprintf( buf, "%s: %s\n\rTo: %s\n\r",
      ch->pnote->sender,
      ch->pnote->subject,
      ch->pnote->to_list
      );
  send_to_char( buf, ch );
  send_to_char( ch->pnote->text, ch );
  return;
    }

    if ( !str_prefix( arg, "post" ) || !str_prefix(arg, "send"))
    { 
	char *strtime;

/*
      if( ch->level <= 2)
	{
	 send_to_char("You must be level 3 to post notes.\n\r",ch);
	 return;
	}
 */
      if( IS_SET(ch->comm, COMM_NONOTES ) )
	{
	 send_to_char("The gods don't wish to hear from you.\n\r",ch);
	 return;
	}


  if ( ch->pnote == NULL )
  {
      send_to_char( "You have no note in progress.\n\r", ch );
      return;
  }

        if (ch->pnote->type != type)
        {
            send_to_char("You aren't working on that kind of note.\n\r",ch);
            return;
        }

  if ( ch->pnote->type == NOTE_BUG ) 
      {
         free_string( ch->pnote->to_list );
	 sprintf(tempTo, "%s immortal", ch->name);
         ch->pnote->to_list = str_dup( tempTo );
      }

  if (!str_cmp(ch->pnote->to_list,""))
  {
      send_to_char(
    "You need to provide a recipient (name, all, clan or immortal).\n\r",
    ch);
      return;
  }

  if ( is_exact_name( ch->pnote->to_list, "imm" ) ) 
  {
      send_to_char("Notes to 'IMM' don't go anywhere, genius.\n\r",ch);
      return;
  }

        if (strchr(ch->pnote->to_list, '@@')!=NULL && ch->level<15)
        {
          send_to_char("You need to be at least level 15 to send notes to other muds.\n\r", ch);
          return;
        }

  if (!str_cmp(ch->pnote->subject,""))
  {
      send_to_char("You need to provide a subject.\n\r",ch);
      return;
  }

  ch->pnote->next     = NULL;
  strtime       = ctime( &current_time );
  strtime[strlen(strtime)-1]  = '\0';
  ch->pnote->date     = str_dup( strtime );
  ch->pnote->date_stamp   = current_time;

       /* handle IMC notes 

       if (strchr(ch->pnote->to_list, '@@')!=NULL)
         imc_post_mail(ch, ch->pnote->sender,
                       ch->pnote->to_list,
                       ch->pnote->date,
                       ch->pnote->subject,
                       ch->pnote->text);
	*/

  append_note(ch->pnote);
  if ( is_exact_name( "all", ch->pnote->to_list ) )
  {
    pnet("New post by $N.",ch,NULL,PNET_NOTES,0,get_trust(ch));
  }
  ch->pnote = NULL;

  wiznet("New post by $N.",ch,NULL,WIZ_NOTES,0,get_trust(ch));
  send_to_char ("Thank you for contributing.\n\r",ch);
  return;
    }

    send_to_char( "You can't do that.\n\r", ch );
    return;
}

@


1.56
log
@Some bug fixes from off the net.
new_note() used for loading the note spools.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.55 2002/04/05 03:49:16 rusty Exp $";
d483 4
@


1.55
log
@Broke note memory crap
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.54 2002/04/04 16:23:12 rusty Exp $";
d345 1
a345 5
#ifdef OLC_VERSION
        pnote           = alloc_perm( sizeof(*pnote) );
#else
        pnote           = GC_MALLOC( sizeof(*pnote) );
#endif
@


1.54
log
@Pnet notes only tells when a note to all has been posted
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.53 2002/04/01 21:05:45 rusty Exp $";
a1258 1
  free_note(ch->pnote);
@


1.53
log
@Added pnet, wiznet like info for mortals
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.52 2002/02/22 16:32:56 poquah Exp $";
d1215 1
a1215 1
    "You need to provide a recipient (name, all, or immortal).\n\r",
d1255 5
a1262 1
  pnet("New post by $N.",ch,NULL,PNET_NOTES,0,get_trust(ch));
@


1.52
log
@adding new quest note spool
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.51 2000/11/27 23:25:32 mud Exp $";
d1258 1
@


1.51
log
@one typo throwing me off.. who'd a thunk it
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.50 2000/11/27 23:24:47 mud Exp $";
d64 1
d90 1
a148 1

d156 7
d182 5
d278 4
d316 1
d445 4
d600 3
d674 3
d731 3
d796 4
d1005 3
d1014 1
@


1.50
log
@adjust the code on color in notes
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.49 2000/11/27 23:15:35 mud Exp $";
d868 1
a868 1
	    && IS _SET(ch->display,DISP_COLOR))  
@


1.49
log
@color list code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.48 2000/11/27 23:10:57 mud Exp $";
d865 18
a882 16
    sprintf( buf, "%s[%3d%s]%s %s: %s\n\r",
	(
	  (is_exact_name( ch->name,pnote->to_list)
           || (
	       (is_clan(ch) || (ch->clan == clan_lookup("matook"))
	       ) 
	      &&  
	      is_exact_name(clan_table[ch->clan].name,pnote->to_list)
	      )
	  &&IS_SET(ch->display,DISP_COLOR))
	? MAGENTA : "",
        vnum, hide_note(ch,pnote) ? " " : "N", 
	IS_SET(ch->display,DISP_COLOR) ? NORMAL : "",
        Asender, pnote->subject );
    strcat( buf2, buf );
    vnum++;
@


1.48
log
@
color notes in list for clans and matook
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.47 2000/11/27 21:52:19 mud Exp $";
d52 3
d866 8
a873 3
	((is_exact_name( ch->name,pnote->to_list)
          || ((is_clan(ch) || ch->clan == clan_lookup("matook")) &&  
	      is_exact_name(clan_table[ch->clan].name,pnote->to_list))
@


1.47
log
@clan notes are colored
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.46 2000/09/16 12:53:19 mud Exp $";
d864 2
a865 1
          || is_exact_name(clan_table[ch->clan].name,pnote->to_list))
@


1.46
log
@Made the lists of notes show again for level 60's.
Was pissed that I could read the note but not see it in a list.
Who the fuck changed this anyhow?
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.45 2000/06/18 20:36:06 mud Exp $";
d863 3
a865 1
	(is_exact_name( ch->name,pnote->to_list)&&IS_SET(ch->display,DISP_COLOR))
@


1.45
log
@Warlock clan skil
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.44 2000/05/15 19:38:41 mud Exp $";
d481 3
@


1.44
log
@Changed the way "immortal" was tacked onto the ch's name for bug note
To: lists.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.43 2000/05/05 00:22:26 mud Exp $";
d453 1
a453 1
{   if ( ch->level == MAX_LEVEL)
@


1.43
log
@forgot a ;
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.42 2000/05/05 00:21:36 mud Exp $";
d706 1
d1153 2
a1154 2
         ch->pnote->to_list = str_dup( ch->name );
	 strcat(ch->pnote->to_list," immortal"); 
@


1.42
log
@making bugs to immortal work
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.41 2000/05/05 00:16:02 mud Exp $";
d1153 1
a1153 1
	 strcat(ch->pnote->to_list," immortal")
@


1.41
log
@add * to bufto declare
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.40 2000/05/05 00:14:07 mud Exp $";
a711 1
    char *bufto[30];
a1150 1
         bufto[0] = '\0';
d1152 2
a1153 3
	 bufto = str_dup( ch->name );
	 strcat(bufto," immortal");
         ch->pnote->to_list = str_dup( bufto );
@


1.40
log
@working on forcing bug notes to immortal
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.39 2000/05/05 00:11:09 mud Exp $";
d712 1
a712 1
    char bufto[30];
@


1.39
log
@make bug notes post to ch->name and immortal only
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.38 2000/02/29 07:30:07 mud Exp $";
d1152 1
@


1.38
log
@missing )
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.37 2000/02/29 07:28:54 mud Exp $";
d712 1
d1071 7
d1150 8
a1170 7

  if ( ch->pnote->type == NOTE_BUG &&
       is_exact_name(ch->pnote->to_list,"all") )
      {
      send_to_char("You can't report a bug to the entire mud.\n\r",ch);
      return;
      }
@


1.37
log
@immortals read all clan notes
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.36 2000/02/23 00:11:46 mud Exp $";
d469 1
a469 1
	 || is_exact_name("zealot",pnote->to_list))
@


1.36
log
@lower the gnote spoll to 20 from 60
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.35 2000/02/20 19:36:44 mud Exp $";
d464 10
a473 1
    if ( (is_clan(ch) && is_exact_name("clans",pnote->to_list) ) )
@


1.35
log
@59+ can still see who posted the change
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.34 2000/02/20 19:14:30 mud Exp $";
d295 1
a295 1
    load_thread(IMMORTAL_FILE,&immortal_list, NOTE_IMMORTAL, 60*24*60*60);
@


1.34
log
@change admin str_dup to strcpy
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.33 2000/02/20 19:12:51 mud Exp $";
d770 1
a770 1
                if (type == NOTE_CHANGES)
d810 1
a810 1
	    if(type == NOTE_CHANGES)
d842 1
a842 1
      if(type == NOTE_CHANGES)
@


1.33
log
@working on change notes
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.32 2000/02/20 19:12:02 mud Exp $";
d771 1
a771 1
                   Asender = str_dup("Administration"); 
d811 1
a811 1
               Asender = str_dup("Administration"); 
d843 1
a843 1
          Asender = str_dup("Administration"); 
@


1.32
log
@move defining Asender
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.31 2000/02/20 19:06:27 mud Exp $";
a834 4

       Asender = str_dup("Administration"); 
    else
       strcpy(Asender,pnote->sender);
@


1.31
log
@try strcpy instead of str_dup
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.30 2000/02/20 19:04:30 mud Exp $";
a750 5
    if (type == NOTE_CHANGES)
       Asender = str_dup("Administration"); 
    else
       strcpy(Asender,pnote->sender);

d770 5
d810 5
d836 4
d846 5
@


1.30
log
@problem in ntoe?
\-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.29 2000/02/20 19:01:49 mud Exp $";
d754 1
a754 1
       Asender = str_dup(pnote->sender);
@


1.29
log
@commit from my dir this time
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.28 2000/02/20 18:59:36 mud Exp $";
d751 1
a751 1
    if (type = NOTE_CHANGES)
@


1.28
log
@fix string assignments
-poquiah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.27 2000/02/20 18:57:07 mud Exp $";
d752 1
a752 1
       Asender = str_dup("Administration");
@


1.27
log
@Change notes display "administration"
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.26 2000/02/09 21:03:16 mud Exp $";
d488 1
a488 6

    if(type = NOTE_CHANGES)
       pnote->sender = ("Administration");
    else
       pnote->sender = str_dup( ch->name );

d754 1
a754 1
       Asender = pnote->sender;
@


1.26
log
@rename immnotes to gnotes
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.25 1999/12/19 19:47:54 mud Exp $";
d333 1
a333 1
 
d488 6
a493 1
    pnote->sender = str_dup( ch->name );
d707 1
d756 5
d784 1
a784 1
                        pnote->sender,
d819 1
a819 1
                    pnote->sender,
d849 1
a849 1
        pnote->sender, pnote->subject );
@


1.25
log
@Immortal note spool
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.24 1999/10/10 15:18:50 mud Exp $";
d163 1
a163 1
      count, count > 1 ? "immnotes have" : "immnote has");
d718 1
a718 1
      list_name = "immnotes";
@


1.24
log
@emoved or commented out all references to IMC.  This should significantly
reduce the size of our executable and basically wasn't being used for
anything as we were not connected to any IMC server.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.23 1999/09/01 19:57:10 mud Exp $";
d53 1
d86 1
d159 7
d176 5
d230 4
d295 1
d392 4
d539 3
d610 3
d664 3
d716 4
d903 3
@


1.23
log
@Fixed a crash bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.22 1999/09/01 16:43:51 mud Exp $";
d36 3
a38 1
#include "imc-mercbase.h"
d1117 1
a1117 1
       /* handle IMC notes */
d1125 1
@


1.22
log
@People rae stupid.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.21 1999/07/14 18:14:03 mud Exp $";
d1084 1
a1084 1
  if ( is_exact_name( "imm", pnote->to_list ) )
@


1.21
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: note.c,v 1.20 1999/06/24 22:37:24 mud Exp $";
d1050 1
d1056 1
a1056 1

d1081 6
@


1.20
log
@Added command to interp.c
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.19 1999/06/24 22:29:11 mud Exp $ */
@


1.19
log
@Added clan notes.
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.18 1999/05/12 21:19:31 mud Exp $ */
d160 1
a160 1
void do_cnote(CHAR_DATA *ch,char *argument)
@


1.18
log
@Shortent note input by one line
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.17 1999/05/12 20:53:30 mud Exp $ */
d57 1
d82 1
d133 8
d160 5
d210 4
d274 1
d367 4
d514 3
d582 3
d633 3
d682 4
d865 3
@


1.17
log
@Made note lines unable to be more than 79 characters wide.
Send warning with truncated text to ch.
-RUsty
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.16 1999/04/08 22:50:17 mud Exp $ */
d877 1
a877 1
  if ( strlen(argument) > 79 )
d879 1
a879 1
     argument[80] = '\0';
@


1.16
log
@bug notes caught up with spool command.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.15 1999/03/28 00:56:59 mud Exp $ */
d877 7
@


1.15
log
@Put check in hide_note lets 59+ read all notes (I think)
-Poquah
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.14 1999/03/14 16:43:23 mud Exp $ */
d80 1
@


1.14
log
@Extended the length of the bug spool.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.13 1998/12/13 03:19:47 mud Exp $ */
d580 1
a580 1
    if (!is_note_to(ch,pnote))
@


1.13
log
@Bug spool final change
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.12 1998/12/13 03:05:36 mud Exp $ */
d249 1
a249 1
    load_thread(BUG_FILE,&bug_list,NOTE_BUG, 4*24*60*60);
@


1.12
log
@Bugs!
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.11 1998/11/29 05:19:26 mud Exp $ */
d1034 7
@


1.11
log
@Fixed stuff
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.10 1998/11/27 07:57:07 mud Exp $ */
d56 1
d123 7
d164 5
d218 4
d249 1
d370 4
d504 4
d569 3
d617 3
d668 4
d842 3
@


1.10
log
@Allnotes added
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.9 1998/10/18 16:27:56 mud Exp $ */
d392 1
a392 2
    if ( (is_clan(ch) && is_exact_name("clans",pnote->to_list) ) ||
	IS_SET(ch->wiznet,WIZ_ALLNOTES) )
d395 1
a395 1
    if (   (ch->clan && is_exact_name(clan_table[ch->clan].name,pnote->to_list))	|| IS_SET(ch->wiznet,WIZ_ALLNOTES) )
@


1.9
log
@Added do_spool() to catchup all note spools in one command.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.8 1998/08/30 03:33:39 mud Exp $ */
d392 2
a393 1
    if ( (is_clan(ch) && is_exact_name("clans",pnote->to_list) ) )
d396 1
a396 1
    if (   (ch->clan && is_exact_name(clan_table[ch->clan].name,pnote->to_list)))
@


1.8
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.7 1998/08/21 14:21:11 mud Exp $ */
d67 16
@


1.7
log
@I dunno
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.6 1998/08/20 21:05:37 mud Exp $ */
d706 1
a706 1
	(is_exact_name( ch->name,pnote->to_list)&&IS_SET(ch->act,PLR_COLOR))
d709 1
a709 1
	IS_SET(ch->act,PLR_COLOR) ? NORMAL : "",
@


1.6
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.5 1998/08/05 06:31:18 mud Exp $ */
d379 1
a379 1
    if (   (ch->pcdata->clan && is_exact_name(clan_table[ch->pcdata->clan].name,pnote->to_list)))
@


1.5
log
@* Fixed wiznet notes
* Added feast/famine spells
* Changed nosferatu bleed/hunger stuff
* Upped damage on bleed
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.4 1998/08/04 18:03:08 mud Exp $ */
d379 1
a379 1
    if (   (ch->clan && is_exact_name(clan_table[ch->clan].name,pnote->to_list)))
@


1.4
log
@Added pload and punload, small mods to deny to allow for the bit to be removed.
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.3 1998/08/04 17:21:38 mud Exp $ */
d1010 1
a1010 1
  wiznet("New post by $N.",ch,NULL,WIZ_NOTES,WIZ_SECURE,get_trust(ch));
@


1.3
log
@* Changed level field to 2 spaces instead of 3
* Added nonote command
* Added a 'set hours' ability
-Ben
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.2 1998/07/29 05:44:13 mud Exp $ */
d1009 2
a1010 1
  
@


1.2
log
@Forgot to remove matookers from the 'to clans' part of note spools. -Ben
:
@
text
@d18 1
a18 1
 /* @@(#)$Id: note.c,v 1.1 1998/06/16 17:49:40 mud Exp $ */
d950 6
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
 /* @@(#)$Id$ */
d376 5
a380 3
    if (   (ch->clan && is_exact_name(clan_table[ch->clan].name,pnote->to_list))
	|| (ch->clan && is_exact_name("clans",pnote->to_list)) )
  return TRUE;
@
