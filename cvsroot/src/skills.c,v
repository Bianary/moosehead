head	1.81;
access;
symbols;
locks; strict;
comment	@ * @;


1.81
date	2003.12.07.20.56.13;	author boogums;	state Exp;
branches;
next	1.80;

1.80
date	2003.12.07.20.42.46;	author boogums;	state Exp;
branches;
next	1.79;

1.79
date	2001.12.14.21.27.13;	author poquah;	state Exp;
branches;
next	1.78;

1.78
date	2001.12.14.19.57.57;	author poquah;	state Exp;
branches;
next	1.77;

1.77
date	2001.12.14.19.56.12;	author poquah;	state Exp;
branches;
next	1.76;

1.76
date	2001.12.04.15.23.34;	author poquah;	state Exp;
branches;
next	1.75;

1.75
date	2001.12.04.15.14.43;	author poquah;	state Exp;
branches;
next	1.74;

1.74
date	2001.12.04.15.08.16;	author poquah;	state Exp;
branches;
next	1.73;

1.73
date	2001.12.04.14.56.54;	author poquah;	state Exp;
branches;
next	1.72;

1.72
date	2001.12.03.21.50.44;	author poquah;	state Exp;
branches;
next	1.71;

1.71
date	2001.12.03.21.38.15;	author poquah;	state Exp;
branches;
next	1.70;

1.70
date	2001.12.03.21.29.34;	author poquah;	state Exp;
branches;
next	1.69;

1.69
date	2001.12.03.20.28.16;	author poquah;	state Exp;
branches;
next	1.68;

1.68
date	2001.12.03.20.07.52;	author poquah;	state Exp;
branches;
next	1.67;

1.67
date	2001.12.03.19.56.39;	author poquah;	state Exp;
branches;
next	1.66;

1.66
date	2001.12.03.19.39.45;	author poquah;	state Exp;
branches;
next	1.65;

1.65
date	2001.12.03.19.38.03;	author poquah;	state Exp;
branches;
next	1.64;

1.64
date	2001.11.26.14.59.42;	author poquah;	state Exp;
branches;
next	1.63;

1.63
date	2001.11.26.14.58.30;	author poquah;	state Exp;
branches;
next	1.62;

1.62
date	2001.06.01.04.25.15;	author guerrand;	state Exp;
branches;
next	1.61;

1.61
date	2001.06.01.02.37.33;	author guerrand;	state Exp;
branches;
next	1.60;

1.60
date	2001.03.05.22.12.46;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	2001.03.05.22.11.14;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	2001.02.09.22.48.38;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	2000.08.27.23.23.08;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	2000.08.26.18.38.12;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	2000.08.24.20.11.16;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	2000.07.26.00.19.29;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	2000.07.26.00.14.17;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	2000.07.06.00.14.46;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	2000.07.06.00.10.04;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	2000.04.18.19.51.06;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	2000.04.17.22.00.53;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	2000.03.21.21.08.36;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	2000.03.15.21.40.26;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	2000.03.06.01.18.43;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	2000.03.06.01.17.05;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	2000.03.06.00.23.42;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	2000.02.26.00.06.32;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	2000.02.25.16.43.58;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	2000.02.25.00.00.50;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	2000.02.16.07.08.09;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	2000.02.16.02.23.22;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.15.20.04.25;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	2000.02.10.19.15.20;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	2000.02.10.19.11.48;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	2000.01.22.00.12.17;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	2000.01.13.07.36.11;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	2000.01.12.08.09.05;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	2000.01.12.08.07.29;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	2000.01.12.07.54.24;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.12.07.42.33;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.12.07.26.43;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.12.07.05.04;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.12.06.18.15;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.11.00.54.53;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.10.23.40.07;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.09.22.27.36;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.07.21.49.49;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.07.00.07.56;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	99.12.17.00.02.15;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	99.09.14.04.21.42;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	99.09.03.19.26.05;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	99.08.11.02.27.13;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	99.07.14.18.14.09;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	99.06.28.06.34.20;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	99.06.28.05.30.56;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	99.05.22.21.44.17;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	99.04.28.08.09.32;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	99.01.03.04.32.08;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.12.13.22.06.25;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.12.08.23.23.09;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.11.27.20.44.45;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.11.27.08.04.19;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.11.27.07.35.59;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.10.11.00.41.29;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.10.11.00.25.46;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.21.00.52.16;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.15.18.45.50;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.10.19.55.54;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.44;	author mud;	state Exp;
branches;
next	;


desc
@@


1.81
log
@tdoh bad math
corey
@
text
@/* Code specifically for the new skill system */

static char rcsid[] = "$Id: skills.c,v 1.80 2003/12/07 20:42:46 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "merc.h"
#include "magic.h"

/* command procedures needed */
DECLARE_DO_FUN(do_groups	);
DECLARE_DO_FUN(do_help		);
DECLARE_DO_FUN(do_say		);


/* used to get new skills */
void do_gain(CHAR_DATA *ch, char *argument)
{
    char buf[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    char arg1[MAX_INPUT_LENGTH];
    char *argN;
    CHAR_DATA *trainer;
    int gn = 0, sn = 0;

    if (IS_NPC(ch))
	return;

    /* find a trainer */
    for ( trainer = ch->in_room->people; 
	  trainer != NULL; 
	  trainer = trainer->next_in_room)
	if (IS_NPC(trainer) && IS_SET(trainer->act,ACT_GAIN))
	    break;

    if (trainer == NULL || !can_see(ch,trainer,FALSE))
    {
	send_to_char("You can't do that here.\n\r",ch);
	return;
    }

    argN = str_dup(argument);
    argN = one_argument(argN,arg);
    argN = one_argument(argN,arg1);

    if (arg[0] == '\0')
    {
	do_say(trainer,"Pardon me?");
	return;
    }

    if (!str_prefix(arg,"list"))
    {
	int col;
	
	col = 0;

	sprintf(buf, "%-18s %-5s %-18s %-5s %-18s %-5s\n\r",
	             "group","cost","group","cost","group","cost");
	send_to_char(buf,ch);

	for (gn = 0; gn < MAX_GROUP; gn++)
	{
	    if (group_table[gn].name == NULL)
		break;

	    if (!ch->pcdata->group_known[gn]
	    &&  group_table[gn].rating[ch->class] > 0)
	    {
	       sprintf(buf,"%-18s %-5d ",
	         group_table[gn].name,(group_table[gn].rating[ch->class]) * 10);
		send_to_char(buf,ch);
		if (++col % 3 == 0)
		    send_to_char("\n\r",ch);
	    }
	}
	if (col % 3 != 0)
	    send_to_char("\n\r",ch);
	
	send_to_char("\n\r",ch);		

	col = 0;

        sprintf(buf, "%-18s %-5s %-18s %-5s %-18s %-5s\n\r",
                     "skill","cost","skill","cost","skill","cost");
        send_to_char(buf,ch);
 
        for (sn = 0; sn < MAX_SKILL; sn++)
        {
            if (skill_table[sn].name == NULL)
                break;
 
            if (!ch->pcdata->learned[sn]
            &&  skill_table[sn].rating[ch->class] > 0
	    &&  skill_table[sn].spell_fun == spell_null)
            {
                sprintf(buf,"%-18s %-5d ",
                    skill_table[sn].name,(skill_table[sn].rating[ch->class]) * 10);
                send_to_char(buf,ch);
                if (++col % 3 == 0)
                    send_to_char("\n\r",ch);
            }
        }
        if (col % 3 != 0)
            send_to_char("\n\r",ch);

        sprintf( buf, "\n\rYou have %d practice sessions left.\n\r",
           ch->practice );
        send_to_char(buf, ch);
	return;
    }

    if (!str_prefix(arg,"apply"))
    {
	if (ch->skill_points < 10) 
	{
	    act("$N tells you 'You are not yet ready.'",
		ch,NULL,trainer,TO_CHAR,FALSE); return;
	}
        if (!strcmp(arg1,"all"))
        {
	   send_to_char("You apply all of your skill towards practicing.\n\r",ch);
	   ch->practice += ch->skill_points/10;
	   ch->skill_points -= (ch->skill_points/10) * 10;
        }
	else
        {
	   send_to_char("You apply some of your skill towards practicing.\n\r",ch);
	   ch->skill_points -= 10;
	   ch->practice += 1;
        }
	return;
    }

/* No more converting pracs to trains 
    if (!str_prefix(arg,"convert"))
    {
	if (ch->practice < 10)
	{
	    act("$N tells you 'You are not yet ready.'",
		ch,NULL,trainer,TO_CHAR,FALSE);
	    return;
	}

	act("$N helps you apply your practice to training",
		ch,NULL,trainer,TO_CHAR,FALSE);
	ch->practice -= 10;
	ch->train +=1 ;
	return;
    }
    */

/*
    if (!str_prefix(arg,"points"))
    {
	if (ch->train < 2)
	{
	    act("$N tells you 'You are not yet ready.'",
		ch,NULL,trainer,TO_CHAR,FALSE);
	    return;
	}

	if (ch->pcdata->points <= 40)
	{
	    act("$N tells you 'There would be no point in that.'",
		ch,NULL,trainer,TO_CHAR,FALSE);
	    return;
	}

	act("$N trains you, and you feel more at ease with your skills.",
	    ch,NULL,trainer,TO_CHAR,FALSE);

	ch->train -= 2;
	ch->pcdata->points -= 1;
	ch->exp = exp_per_level(ch,ch->pcdata->points) * ch->level;
	return;
    }
    */

    /* else add a group/skill */

    gn = group_lookup(argument);
    if (gn > 0)
    {
	if (ch->pcdata->group_known[gn])
	{
	    act("$N tells you 'You already know that group!'",
		ch,NULL,trainer,TO_CHAR,FALSE);
	    return;
	}

	if (group_table[gn].rating[ch->class] <= 0)
	{
	    act("$N tells you 'That group is beyond your powers.'",
		ch,NULL,trainer,TO_CHAR,FALSE);
	    return;
	}

/*
	if (ch->train < group_table[gn].rating[ch->class])
	if (ch->practice < (group_table[gn].rating[ch->class] * 10))
	*/
	if (ch->practice < (group_table[gn].rating[ch->class] * 10))
	{
	    act("$N tells you 'You are not yet ready for that group.'",
		ch,NULL,trainer,TO_CHAR,FALSE);
	    return;
	}

	/* add the group */
	gn_add(ch,gn);
	act("$N trains you in the art of $t",
	    ch,group_table[gn].name,trainer,TO_CHAR,FALSE);
	ch->practice -= (group_table[gn].rating[ch->class] * 10);
	/*
	ch->train -= group_table[gn].rating[ch->class];
	*/
	return;
    }

    sn = skill_lookup(argument);
    if (sn > -1)
    {
	if (skill_table[sn].spell_fun != spell_null)
	{
	    act("$N tells you 'You must learn the full group.'",
		ch,NULL,trainer,TO_CHAR,FALSE);
	    return;
	}
	    

        if (ch->pcdata->learned[sn])
        {
            act("$N tells you 'You already know that skill!'",
                ch,NULL,trainer,TO_CHAR,FALSE);
            return;
        }
 
        if (skill_table[sn].rating[ch->class] <= 0)
        {
            act("$N tells you 'That skill is beyond your powers.'",
                ch,NULL,trainer,TO_CHAR,FALSE);
            return;
        }
 
 /*
        if (ch->train < skill_table[sn].rating[ch->class])
	*/
        if (ch->practice < (skill_table[sn].rating[ch->class] * 10 ))
        {
            act("$N tells you 'You are not yet ready for that skill.'",
                ch,NULL,trainer,TO_CHAR,FALSE);
            return;
        }
 
        /* add the skill */
	ch->pcdata->learned[sn] = 1;
        act("$N trains you in the art of $t",
            ch,skill_table[sn].name,trainer,TO_CHAR,FALSE);
	    /*
        ch->train -= skill_table[sn].rating[ch->class];
	*/
        ch->practice -= (skill_table[sn].rating[ch->class] * 10);
        return;
    }

    act("$N tells you 'I do not understand...'",ch,NULL,trainer,TO_CHAR,FALSE);
}
    
int apply_chi(CHAR_DATA *ch, int num)
{
  if( number_percent() < get_skill(ch,gsn_chi) )
    {
     num -=  ((num / 2) * get_skill(ch,gsn_chi)) / 100 ;
     check_improve(ch,gsn_chi,TRUE,8);
    }
  else
     check_improve(ch,gsn_chi,FALSE,9);

  return num;
}

/* RT spells and skills show the players spells (or skills) */

void do_spells(CHAR_DATA *ch, char *argument)
{
    char spell_list[LEVEL_HERO][MAX_STRING_LENGTH];
    char spell_columns[LEVEL_HERO];
    int sn,lev,mana,lev0=0,levN=LEVEL_HERO;
    bool found = FALSE;
    char buf[MAX_STRING_LENGTH];
    char buf2[4*MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
		    
	if (argument[0] != '\0')    
	{
	  argument = one_argument(argument,arg);
	  lev0 = atoi(arg);
	  lev0 = URANGE(0,lev0,LEVEL_HERO);
	}
		    
	if (argument[0] != '\0')    
	{
	  argument = one_argument(argument,arg);
	  levN = atoi(arg);
	  levN = URANGE(0,levN,LEVEL_HERO);
	}

    if (IS_NPC(ch))
      return;

    /* initilize data */
    for (lev = 0; lev < LEVEL_HERO; lev++)
    {
	spell_columns[lev] = 0;
	spell_list[lev][0] = '\0';
    }
 
    for (sn = 0; sn < MAX_SKILL; sn++)
    {
      if (skill_table[sn].name == NULL)
        break;

      if (skill_level(ch,sn) < LEVEL_HERO &&
	  skill_table[sn].spell_fun != spell_null &&
          ch->pcdata->learned[sn] > 0)
      {
	found = TRUE;
	lev = skill_level(ch,sn);
	if (ch->level < lev)
	  sprintf(buf,"%-18s  n/a      ", skill_table[sn].name);
	else
	{
	     mana = mana_cost(ch,skill_table[sn].min_mana,
				  skill_level(ch,sn),sn);
	  
	  sprintf(buf,"%-18s  %3d mana  ",skill_table[sn].name,mana);
	}
	
	if (spell_list[lev][0] == '\0')
	  sprintf(spell_list[lev],"\n\rLevel %2d: %s",lev,buf);
        else /* append */
	{
	  if ( ++spell_columns[lev] % 2 == 0)
            strcat(spell_list[lev],"\n\r          ");
	  strcat(spell_list[lev],buf);
        }
      }
    }

    /* return results */
 
    if (!found)
    {
      send_to_char("You know no spells.\n\r",ch);
      return;
    }
    buf2[0] = '\0';
    for (lev = lev0; lev < UMIN(levN+1,LEVEL_HERO); lev++)
      if (spell_list[lev][0] != '\0')
       {
	strcat(buf2, spell_list[lev]);
      /*  strcat(buf2, "\n\r"); */
       }
      page_to_char(buf2, ch);
}

void do_skills(CHAR_DATA *ch, char *argument)
{
    char skill_list[LEVEL_HERO][MAX_STRING_LENGTH];
    char skill_columns[LEVEL_HERO];
    int sn,lev,lev0=0,levN=LEVEL_HERO;
    bool found = FALSE;
    char buf[MAX_STRING_LENGTH];
    char buf2[4*MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
		    
	if (argument[0] != '\0')    
	{
	  argument = one_argument(argument,arg);
	  lev0 = atoi(arg);
	  lev0 = URANGE(0,lev0,LEVEL_HERO);
	}
		    
	if (argument[0] != '\0')    
	{
	  argument = one_argument(argument,arg);
	  levN = atoi(arg);
	  levN = URANGE(0,levN,LEVEL_HERO);
	}

 
    if (IS_NPC(ch))
      return;
 
    /* initilize data */
    for (lev = 0; lev < LEVEL_HERO; lev++)
    {
        skill_columns[lev] = 0;
        skill_list[lev][0] = '\0';
    }
 
    for (sn = 0; sn < MAX_SKILL; sn++)
    {
      if (skill_table[sn].name == NULL )
        break;

 
      if ( skill_level( ch, sn ) < LEVEL_HERO &&
	  skill_table[sn].spell_fun == spell_null &&
	  ch->pcdata->learned[sn] > 0)
      {
        found = TRUE;
        lev = skill_level( ch, sn );
        if (ch->level < lev)
          sprintf(buf,"%-18s n/a      ", skill_table[sn].name);
        else
          sprintf(buf,"{%c%-18s{x %3d%%      ", 
		ch->pcdata->learned[sn] != ch->pcdata->last_learned[sn]
			? 'R' : 'x',
		skill_table[sn].name,
		ch->pcdata->learned[sn]);
	
	ch->pcdata->last_learned[sn] = ch->pcdata->learned[sn];

        if (skill_list[lev][0] == '\0')
          sprintf(skill_list[lev],"\n\rLevel %2d: %s",lev,buf);
        else /* append */
        {
          if ( ++skill_columns[lev] % 2 == 0)
            strcat(skill_list[lev],"\n\r          ");
          strcat(skill_list[lev],buf);
        }
      }
    }
     
    /* return results */
 
    if (!found)
    {
      send_to_char("You know no skills.\n\r",ch);
      return;
    }
    buf2[0] = '\0';
    for (lev = lev0; lev < UMIN(levN+1,LEVEL_HERO); lev++)
      if (skill_list[lev][0] != '\0')
       {
        strcat(buf2, skill_list[lev]);
       /* strcat(buf2,"\n\r"); */
       }

      if ( ch->pcdata->specialize )
      {
	 sprintf(buf,"\n\rSpecialization: %s\n\r",
		skill_table[ch->pcdata->specialize].name);
	 strcat(buf2,buf);
      }

      page_to_char(buf2, ch);
}


/* shows skills, groups and costs (only if not bought) */
void list_group_costs(CHAR_DATA *ch)
{
    char buf[100];
    int gn,sn,col,newLevel;

    if (IS_NPC(ch))
	return;

    col = 0;

    sprintf(buf,"%-18s %-5s %-18s %-5s %-18s %-5s\n\r","group","cp","group","cp","group","cp");
    send_to_char(buf,ch);

    for (gn = 0; gn < MAX_GROUP; gn++)
    {
	if (group_table[gn].name == NULL)
	    break;

        if (!ch->gen_data->group_chosen[gn] 
	&&  !ch->pcdata->group_known[gn]
	&&  group_table[gn].rating[ch->class] > 0)
	{
	    sprintf(buf,"%-18s %-5d ",group_table[gn].name,
				    group_table[gn].rating[ch->class]);
	    send_to_char(buf,ch);
	    if (++col % 3 == 0)
		send_to_char("\n\r",ch);
	}
    }
    if ( col % 3 != 0 )
        send_to_char( "\n\r", ch );
    send_to_char("\n\r",ch);

    col = 0;
 
    sprintf(buf,"%-18s %-5s %-18s %-5s %-18s %-5s\n\r","skill","cp","skill","cp","skill","cp");
    send_to_char(buf,ch);
 
    for (sn = 0; sn < MAX_SKILL; sn++)
    {
        if (skill_table[sn].name == NULL)
            break;
 
        if (!ch->gen_data->skill_chosen[sn] 
	&&  ch->pcdata->learned[sn] == 0
	&&  skill_table[sn].spell_fun == spell_null
	&&  skill_table[sn].rating[ch->class] > 0)
        {
            sprintf(buf,"%-18s %-5d ",skill_table[sn].name,
                                    skill_table[sn].rating[ch->class]);
            send_to_char(buf,ch);
            if (++col % 3 == 0)
                send_to_char("\n\r",ch);
        }
    }
    if ( col % 3 != 0 )
        send_to_char( "\n\r", ch );
    send_to_char("\n\r",ch);

    sprintf(buf,"Creation points: %d\n\r",ch->pcdata->points);
    send_to_char(buf,ch);
    sprintf(buf,"Experience per level: %d\n\r",
	    exp_per_level(ch,ch->gen_data->points_chosen));
    send_to_char(buf,ch);
    if(IS_SET(ch->mhs,MHS_PREFRESHED))
    {
       newLevel = ch->exp / exp_per_level(ch,ch->pcdata->points);
       newLevel -= 1;
       if( ( ch->level < 11 ) && (newLevel > ch->level ) )
          newLevel = ch->level ;
       if(   IS_SET(ch->act,PLR_VAMP) ||
          IS_SET(ch->act,PLR_WERE) ||
          IS_SET(ch->act,PLR_MUMMY) 
           )
       {
          if ( newLevel > 76 )
             newLevel = 76;
       }
       else
       {
          if(newLevel > 50 )
             newLevel =50;
       }
       sprintf(buf,"Debit levels: %d\n\r",newLevel);
       send_to_char(buf,ch);
    }
    return;
}


void list_group_chosen(CHAR_DATA *ch)
{
    char buf[100];
    int gn,sn,col;
 
    if (IS_NPC(ch))
        return;
 
    col = 0;
 
    sprintf(buf,"%-18s %-5s %-18s %-5s %-18s %-5s","group","cp","group","cp","group","cp\n\r");
    send_to_char(buf,ch);
 
    for (gn = 0; gn < MAX_GROUP; gn++)
    {
        if (group_table[gn].name == NULL)
            break;
 
        if (ch->gen_data->group_chosen[gn] 
	&&  group_table[gn].rating[ch->class] > 0)
        {
            sprintf(buf,"%-18s %-5d ",group_table[gn].name,
                                    group_table[gn].rating[ch->class]);
            send_to_char(buf,ch);
            if (++col % 3 == 0)
                send_to_char("\n\r",ch);
        }
    }
    if ( col % 3 != 0 )
        send_to_char( "\n\r", ch );
    send_to_char("\n\r",ch);
 
    col = 0;
 
    sprintf(buf,"%-18s %-5s %-18s %-5s %-18s %-5s","skill","cp","skill","cp","skill","cp\n\r");
    send_to_char(buf,ch);
 
    for (sn = 0; sn < MAX_SKILL; sn++)
    {
        if (skill_table[sn].name == NULL)
            break;
 
        if (ch->gen_data->skill_chosen[sn] 
	&&  skill_table[sn].rating[ch->class] > 0)
        {
            sprintf(buf,"%-18s %-5d ",skill_table[sn].name,
                                    skill_table[sn].rating[ch->class]);
            send_to_char(buf,ch);
            if (++col % 3 == 0)
                send_to_char("\n\r",ch);
        }
    }
    if ( col % 3 != 0 )
        send_to_char( "\n\r", ch );
    send_to_char("\n\r",ch);
 
    sprintf(buf,"Creation points: %d\n\r",ch->gen_data->points_chosen);
    send_to_char(buf,ch);
    sprintf(buf,"Experience per level: %d\n\r",
	    exp_per_level(ch,ch->gen_data->points_chosen));
    send_to_char(buf,ch);
    return;
}

int exp_per_level(CHAR_DATA *ch, int points)
{
    int expl,inc,noneg;
    int race;

    race = ( IS_SET(ch->mhs,MHS_SHAPESHIFTED) ? ch->save_race : ch->race );

    if (IS_NPC(ch))
        return 1000;

    expl = 1000;
    inc = 500;

    if (points < 40)
        return 1000 * pc_race_table[race].class_mult[ch->class]/100;

    /* processing */
    points -= 40;

    while (points > 9)
    {
        expl += inc;
        points -= 10;
        if (points > 9)
        {
            expl += inc;
            inc *= 2;
            points -= 10;
        }
    }

    expl += points * inc / 10;

    noneg = expl * pc_race_table[race].class_mult[ch->class]/100;
    if (noneg > 411000 || noneg < 0)
	return 411000;

    return expl * pc_race_table[race].class_mult[ch->class]/100;
}

/* this procedure handles the input parsing for the skill generator */
bool parse_gen_groups(CHAR_DATA *ch,char *argument)
{
    char arg[MAX_INPUT_LENGTH];
    char buf[100];
    int gn,sn,i;
 
    if (argument[0] == '\0')
	return FALSE;

    argument = one_argument(argument,arg);

    if (!str_prefix(arg,"help"))
    {
	if (argument[0] == '\0')
	{
	    do_help(ch,"group help");
	    return TRUE;
	}

        do_help(ch,argument);
	return TRUE;
    }
//CP cap IS WHERE WE NEED TO REMOVE THESE IF STATEMENTS TO REMOVE THE CAP
//COREY PAY ATTENTION
    if (!str_prefix(arg,"add"))
    {
	if (argument[0] == '\0')
	{
	    send_to_char("You must provide a skill name.\n\r",ch);
	    return TRUE;
	}

	gn = group_lookup(argument);
	if (gn != -1)
	{
//101 was the old cap
	  if(ch->gen_data->points_chosen + group_table[gn].rating[ch->class] < 151)
	  {
	    if (ch->gen_data->group_chosen[gn]
	    ||  ch->pcdata->group_known[gn])
	    {
		send_to_char("You already know that group!\n\r",ch);
		return TRUE;
	    }

	    if (group_table[gn].rating[ch->class] < 1)
	    {
	  	send_to_char("That group is not available.\n\r",ch);
	 	return TRUE;
	    }

	    sprintf(buf,"%s group added\n\r",group_table[gn].name);
	    send_to_char(buf,ch);
	    ch->gen_data->group_chosen[gn] = TRUE;
	    ch->gen_data->points_chosen += group_table[gn].rating[ch->class];
	    gn_add(ch,gn);
	    ch->pcdata->points += group_table[gn].rating[ch->class];
	    return TRUE;
	  }
	  else
	  {
	    sprintf(buf,"That group costs %d and you only have %dCP's left under the CP cap.\n\r",group_table[gn].rating[ch->class],(150 - ch->gen_data->points_chosen));
	    send_to_char(buf,ch);
	    return TRUE;
	  }
	}

	sn = skill_lookup(argument);
	if (sn != -1)
	{
	  if(ch->gen_data->points_chosen + skill_table[sn].rating[ch->class] < 151)
	  {
	    if (ch->gen_data->skill_chosen[sn]
	    ||  ch->pcdata->learned[sn] > 0)
	    {
		send_to_char("You already know that skill!\n\r",ch);
		return TRUE;
	    }

	    if (skill_table[sn].rating[ch->class] < 1
	    ||  skill_table[sn].spell_fun != spell_null)
	    {
		send_to_char("That skill is not available.\n\r",ch);
		return TRUE;
	    }
	    sprintf(buf, "%s skill added\n\r",skill_table[sn].name);
	    send_to_char(buf,ch);
	    ch->gen_data->skill_chosen[sn] = TRUE;
	    ch->gen_data->points_chosen += skill_table[sn].rating[ch->class];
	    ch->pcdata->learned[sn] = 1;
	    ch->pcdata->points += skill_table[sn].rating[ch->class];
	    return TRUE;
	  }
	  else
	  {
	    sprintf(buf,"That skill costs %d and you only have %dCP's left under the CP cap.\n\r",skill_table[sn].rating[ch->class],(150 - ch->gen_data->points_chosen));
	    send_to_char(buf,ch);
	    return TRUE;
	  }
	}

	send_to_char("No skills or groups by that name...\n\r",ch);
	return TRUE;
    }

    if (!strcmp(arg,"drop"))
    {
	if (argument[0] == '\0')
  	{
	    send_to_char("You must provide a skill to drop.\n\r",ch);
	    return TRUE;
	}

	gn = group_lookup(argument);
	if (gn != -1 && ch->gen_data->group_chosen[gn])
	{
	    send_to_char("Group dropped.\n\r",ch);
	    ch->gen_data->group_chosen[gn] = FALSE;
	    ch->gen_data->points_chosen -= group_table[gn].rating[ch->class];
	    gn_remove(ch,gn);
	    for (i = 0; i < MAX_GROUP; i++)
	    {
		if (ch->gen_data->group_chosen[gn])
		    gn_add(ch,gn);
	    }
	    ch->pcdata->points -= group_table[gn].rating[ch->class];
	    return TRUE;
	}

	sn = skill_lookup(argument);
	if (sn != -1 && ch->gen_data->skill_chosen[sn])
	{
	    send_to_char("Skill dropped.\n\r",ch);
	    ch->gen_data->skill_chosen[sn] = FALSE;
	    ch->gen_data->points_chosen -= skill_table[sn].rating[ch->class];
	    ch->pcdata->learned[sn] = 0;
	    ch->pcdata->points -= skill_table[sn].rating[ch->class];
	    return TRUE;
	}

	send_to_char("You haven't bought any such skill or group.\n\r",ch);
	return TRUE;
    }

    if (!str_prefix(arg,"premise"))
    {
	do_help(ch,"premise");
	return TRUE;
    }

    if (!str_prefix(arg,"list"))
    {
	list_group_costs(ch);
	return TRUE;
    }

    if (!str_prefix(arg,"learned"))
    {
	list_group_chosen(ch);
	return TRUE;
    }

    if (!str_prefix(arg,"info"))
    {
	do_groups(ch,argument);
	return TRUE;
    }

    return FALSE;
}
	    
	


        

/* shows all groups, or the sub-members of a group */
void do_groups(CHAR_DATA *ch, char *argument)
{
    char buf[100];
    int gn,sn,col;

    if (IS_NPC(ch))
	return;

    col = 0;

    if (argument[0] == '\0')
    {   /* show all groups */
	
	for (gn = 0; gn < MAX_GROUP; gn++)
        {
	    if (group_table[gn].name == NULL)
		break;
	    if (ch->pcdata->group_known[gn])
	    {
		sprintf(buf,"%-20s ",group_table[gn].name);
		send_to_char(buf,ch);
		if (++col % 3 == 0)
		    send_to_char("\n\r",ch);
	    }
        }
        if ( col % 3 != 0 )
            send_to_char( "\n\r", ch );
        sprintf(buf,"Creation points: %d\n\r",ch->pcdata->points);
	send_to_char(buf,ch);
	return;
     }

     if (!str_cmp(argument,"all"))    /* show all groups */
     {
        for (gn = 0; gn < MAX_GROUP; gn++)
        {
            if (group_table[gn].name == NULL)
                break;
	    sprintf(buf,"%-20s ",group_table[gn].name);
            send_to_char(buf,ch);
	    if (++col % 3 == 0)
            	send_to_char("\n\r",ch);
        }
        if ( col % 3 != 0 )
            send_to_char( "\n\r", ch );
	return;
     }
	
     
     /* show the sub-members of a group */
     gn = group_lookup(argument);
     if (gn == -1)
     {
	send_to_char("No group of that name exist.\n\r",ch);
	send_to_char(
	    "Type 'groups all' or 'info all' for a full listing.\n\r",ch);
	return;
     }

     for (sn = 0; sn < MAX_IN_GROUP; sn++)
     {
	if (group_table[gn].spells[sn] == NULL)
	    break;
	sprintf(buf,"%-20s ",group_table[gn].spells[sn]);
	send_to_char(buf,ch);
	if (++col % 3 == 0)
	    send_to_char("\n\r",ch);
     }
    if ( col % 3 != 0 )
        send_to_char( "\n\r", ch );
}

/* returns skill level */
int skill_level( CHAR_DATA *ch, int sn )
{
    int iOld_class = 0;

    /* Exceptions first - gargoyles */
    if ( sn == gsn_stone_skin && ch->race == race_lookup("gargoyle") && !IS_NPC(ch) )
    {	
	/* the break is superfluous but it's good coding style */
	switch(class_table[ch->pcdata->old_class].fMana)
	{
	case 0:	return 15; break;
	case 1: return 10; break;
	case 2: return 5; break;
	default:	break;
	}
    }

    if ( skill_table[sn].skill_level[ch->class] > 51 )
	return 53;

    if ( skill_table[sn].skill_level[ch->class] < 1 )
	return ( skill_table[sn].skill_level[ch->class] );

     /* Leave as is for normal classes */
    if ( !class_table[ch->class].reclass )
	return ( skill_table[sn].skill_level[ch->class] );

    /* if oldclass gets it, give it at that level */
    if ( skill_table[sn].skill_level[ch->pcdata->old_class] <= 51 )
	return ( skill_table[sn].skill_level[ch->pcdata->old_class] );

    /* otherwise use the Prowler Method */
    /* get other old class */
    iOld_class = ( class_table[ch->class].allowed[0] == ch->pcdata->old_class )
		 ? class_table[ch->class].allowed[1] :
		   class_table[ch->class].allowed[0];

    if ( skill_table[sn].skill_level[iOld_class] <= 51 )
	return ( ( skill_table[sn].skill_level[iOld_class] +
		   skill_table[sn].skill_level[ch->class] ) / 2 );

     /* if it's still here it's a reclass specific skill */
      /* so, just return the level */
     return ( skill_table[sn].skill_level[ch->class] );
}

/* checks for skill improvement */
void check_improve( CHAR_DATA *ch, int sn, bool success, int multiplier )
{
    int chance, blahy,blah,skillpoints;
    char buf[100];

    if (IS_NPC(ch))
	return;

    if ( HAS_KIT(ch,"prophet") )
    {
	multiplier = UMAX(1, multiplier/2 );
	success = TRUE;
    }

/*
    if ( IS_SET(ch->mhs,MHS_SAVANT) )
	multiplier = 1;
*/

    blah = abs(skill_table[sn].rating[ch->class]);

    /* Only gain skill points if your skill % is at 100 */
    if (ch->pcdata->learned[sn] >= 80 && 
	ch->position == POS_FIGHTING &&
	ch->pcdata->skill_point_tracker < 12)
    {
       blahy = number_percent();
       /*
       if ( number_percent() * number_percent() < UMAX(2,10 - blah) )
       */
       if ( blahy <= (10 - blah)/2 )
       {
       /*
          skillpoints = UMAX(1,10-blah);
	  */
	  if (skill_table[sn].spell_fun != spell_null)  
	     skillpoints = 2;
	  else
	     skillpoints = 1;

	  sprintf(buf,"Your use of {G%s{x has gained you some skill!\n\r",
                  skill_table[sn].name
                  );
	    send_to_char(buf,ch);
          ch->skill_points += skillpoints;
	  ch->pcdata->skill_point_tracker += skillpoints;

	  if (ch->pcdata->skill_point_tracker >= 12)
	     ch->pcdata->skill_point_timer = 30;

       }
    }

    if (ch->level < skill_level(ch,sn)
    ||  skill_table[sn].rating[ch->class] == 0
    ||  ch->pcdata->learned[sn] <= 1
    ||  ch->pcdata->learned[sn] == 100)
	return;  /* skill is not known or at 1% */ 

/* Removed from here, its a skill point bug Poquah 
    blah = abs(skill_table[sn].rating[ch->class]);
    if ( number_percent() * number_percent() < UMAX(2,10 - blah) )
	ch->skill_points += UMAX(1,10-blah);
	*/

    /* check to see if the character has a chance to learn */
    chance = 10 * int_app[get_curr_stat(ch,STAT_INT)].learn;
    chance /= (		multiplier * blah *	4);
    chance += ch->level;

    if (number_range(1,1000) > chance)
	return;

    /* now that the character has a CHANCE to learn, see if they really have */	

    if (success)
    {
	chance = URANGE(5,100 - ch->pcdata->learned[sn], 95);
	if (number_percent() < chance)
	{
	    ch->pcdata->learned[sn] += number_range(2,3);
	    ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn],100);
	    sprintf(buf,"You have become better at %s! ({G%d{x)\n\r",
		    skill_table[sn].name,
		    ch->pcdata->learned[sn]);
	    send_to_char(buf,ch);
	    gain_exp(ch,2 * blah);
	}
    }

    else
    {
	chance = URANGE(5,ch->pcdata->learned[sn]/2,30);
	if (number_percent() < chance)
	{
	    ch->pcdata->learned[sn]++;
	    /* Special chance to really learn a thing or two */
	    if ( number_percent() > 95 )
	    ch->pcdata->learned[sn] += number_range(3,5);
		
	    ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn],100);
	    sprintf(buf,
	"Learning from your mistakes, your %s skill improves to {G%d{x%%.\n\r",
		skill_table[sn].name,ch->pcdata->learned[sn]);
	    send_to_char(buf,ch);
	    gain_exp(ch,2 * blah);
	}
    }

}

/* returns a group index number given the name */
int group_lookup( const char *name )
{
    int gn;
 
    for ( gn = 0; gn < MAX_GROUP; gn++ )
    {
        if ( group_table[gn].name == NULL )
            break;
        if ( LOWER(name[0]) == LOWER(group_table[gn].name[0])
        &&   !str_prefix( name, group_table[gn].name ) )
            return gn;
    }
 
    return -1;
}

/* recursively adds a group given its number -- uses group_add */
void gn_add( CHAR_DATA *ch, int gn)
{
    int i;
    
    ch->pcdata->group_known[gn] = TRUE;
    for ( i = 0; i < MAX_IN_GROUP; i++)
    {
        if (group_table[gn].spells[i] == NULL)
            break;
        group_add(ch,group_table[gn].spells[i],FALSE);
    }
}

/* recusively removes a group given its number -- uses group_remove */
void gn_remove( CHAR_DATA *ch, int gn)
{
    int i;

    ch->pcdata->group_known[gn] = FALSE;

    for ( i = 0; i < MAX_IN_GROUP; i ++)
    {
	if (group_table[gn].spells[i] == NULL)
	    break;
	group_remove(ch,group_table[gn].spells[i]);
    }
}
	
/* use for processing a skill or group for addition  */
void group_add( CHAR_DATA *ch, const char *name, bool deduct)
{
    int sn,gn;

    if (IS_NPC(ch)) /* NPCs do not have skills */
	return;

    sn = skill_lookup(name);

    if (sn != -1)
    {
	if (ch->pcdata->learned[sn] == 0) /* i.e. not known */
	{
	    ch->pcdata->learned[sn] = 1;
	    if (deduct)
	   	ch->pcdata->points += skill_table[sn].rating[ch->class]; 
	}
	return;
    }
	
    /* now check groups */

    gn = group_lookup(name);

    if (gn != -1)
    {
	if (ch->pcdata->group_known[gn] == FALSE)  
	{
	    ch->pcdata->group_known[gn] = TRUE;
	    if (deduct)
		ch->pcdata->points += group_table[gn].rating[ch->class];
	}
	gn_add(ch,gn); /* make sure all skills in the group are known */
    }
}

/* used for processing a skill or group for deletion -- no points back! */

void group_remove(CHAR_DATA *ch, const char *name)
{
    int sn, gn;
    
     sn = skill_lookup(name);

    if (sn != -1)
    {
	ch->pcdata->learned[sn] = 0;
	return;
    }
 
    /* now check groups */
 
    gn = group_lookup(name);
 
    if (gn != -1 && ch->pcdata->group_known[gn] == TRUE)
    {
	ch->pcdata->group_known[gn] = FALSE;
	gn_remove(ch,gn);  /* be sure to call gn_add on all remaining groups */
    }
}
@


1.80
log
@making cp cap go higher
xp boost for clanners killing clanners
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.79 2001/12/14 21:27:13 poquah Exp $";
d727 1
a727 1
	    sprintf(buf,"That group costs %d and you only have %dCP's left under the CP cap.\n\r",group_table[gn].rating[ch->class],(100 - ch->gen_data->points_chosen));
d761 1
a761 1
	    sprintf(buf,"That skill costs %d and you only have %dCP's left under the CP cap.\n\r",skill_table[sn].rating[ch->class],(100 - ch->gen_data->points_chosen));
@


1.79
log
@remove some debugs
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.78 2001/12/14 19:57:57 poquah Exp $";
d688 2
a689 1

d701 2
a702 1
	  if(ch->gen_data->points_chosen + group_table[gn].rating[ch->class] < 101)
d736 1
a736 1
	  if(ch->gen_data->points_chosen + skill_table[sn].rating[ch->class] < 101)
@


1.78
log
@more debug
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.77 2001/12/14 19:56:12 poquah Exp $";
a628 1
    char buf[MAX_STRING_LENGTH];
a637 2
       sprintf (buf,"SMURF: %s exp_per_level 1",ch->name);
       log_string(buf); 
a656 2
       sprintf (buf,"SMURF: %s exp_per_level 2",ch->name);
       log_string(buf); 
a661 2
       sprintf (buf,"SMURF: %s exp_per_level 3",ch->name);
       log_string(buf); 
@


1.77
log
@more debug
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.76 2001/12/04 15:23:34 poquah Exp $";
d629 1
@


1.76
log
@removed debug messages
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.75 2001/12/04 15:14:43 poquah Exp $";
d638 2
d659 2
d666 2
@


1.75
log
@fix gain
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.74 2001/12/04 15:08:16 poquah Exp $";
a48 2
sprintf(buf,"argument %s\n\r",argument);
send_to_char(buf,ch);
a50 2
sprintf(buf,"argument %s arg %s argument1 %s\n\r",argument,arg,argN);
send_to_char(buf,ch);
a51 2
sprintf(buf,"argument %s arg %s arg1 %s argument1 %s\n\r",argument,arg,arg1,argN);
send_to_char(buf,ch);
@


1.74
log
@debugging gain
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.73 2001/12/04 14:56:54 poquah Exp $";
d29 1
a29 1
    char argument1[MAX_INPUT_LENGTH];
d51 3
a53 2
    argument1 = one_argument(argument,arg);
sprintf(buf,"argument %s arg %s argument1 %s\n\r",argument,arg,argument1);
d55 2
a56 2
    argument1 = one_argument(argument1,arg1);
sprintf(buf,"argument %s arg %s arg1 %s argument1 %s\n\r",argument,arg,arg1,argument1);
@


1.73
log
@debugging gain
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.72 2001/12/03 21:50:44 poquah Exp $";
d29 1
d51 2
a52 2
    argument = one_argument(argument,arg);
sprintf(buf,"argument %s arg %s\n\r",argument,arg);
d54 2
a55 2
    argument = one_argument(argument,arg1);
sprintf(buf,"argument %s arg %s arg1 %s\n\r",argument,arg,arg1);
@


1.72
log
@done gain apply all
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.71 2001/12/03 21:38:15 poquah Exp $";
d48 2
d51 2
d54 2
@


1.71
log
@maybe have it
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.70 2001/12/03 21:29:34 poquah Exp $";
a124 5
/*
        sprintf( buf, "arg %s arg1 %s argument %s\n\r",
                arg,arg1,argument); 
*/
        send_to_char(buf,ch);
@


1.70
log
@finishing up apply
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.69 2001/12/03 20:28:16 poquah Exp $";
d125 1
d128 1
d130 1
a130 1
        if (!str_prefix(arg1,"all"))
d132 2
a134 1
	   ch->practice += ch->skill_points/10;
d138 1
a141 1
	send_to_char("You apply your skill towards practicing.\n\r",ch);
@


1.69
log
@continued testing
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.68 2001/12/03 20:07:52 poquah Exp $";
d48 2
a49 1
    one_argument(argument,arg);
a124 1
        one_argument(arg,arg1);
@


1.68
log
@test gain apply all
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.67 2001/12/03 19:56:39 poquah Exp $";
d125 3
@


1.67
log
@doh what a boner
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.66 2001/12/03 19:39:45 poquah Exp $";
d124 1
a124 1
        one_argument(argument,arg1);
@


1.66
log
@fix apply all
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.65 2001/12/03 19:38:03 poquah Exp $";
d125 1
a125 1
        if (!str_prefix(arg1 == "all"))
@


1.65
log
@add all to gain apply
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.64 2001/11/26 14:59:42 poquah Exp $";
d125 1
a125 1
        if (arg1 == 'all')
@


1.64
log
@syntax error fixed
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.63 2001/11/26 14:58:30 poquah Exp $";
d28 1
d124 11
a134 1

a135 2
	ch->skill_points -= 10;
	ch->practice += 1;
@


1.63
log
@apply only 10 sp at a time for 1 prac now
-poq
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.62 2001/06/01 04:25:15 guerrand Exp $";
a117 2
        argument = one_argument(argument, arg1);

@


1.62
log
@GMAN
bug fixes.  a cosmetic fix in mistform and a missing negative sign in stone skin
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.61 2001/06/01 02:37:33 guerrand Exp $";
d29 1
a29 1
    int gn = 0, sn = 0, apply;
d118 2
d127 2
a128 3
	apply = ch->skill_points/10;
	ch->skill_points -= apply * 10;
	ch->practice += apply;
@


1.61
log
@Added special gargoyle stoneskin stuff.
GMan
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.60 2001/03/05 22:12:46 mud Exp $";
d914 2
a915 2
	case 1: return 5; break;
	case 2: return 10; break; /* This shouldn't ever be the case */
@


1.60
log
@One more skill point timer tweak
-Rusty
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.59 2001/03/05 22:11:14 mud Exp $";
d906 13
@


1.59
log
@Skill point timer changed
-Rusty
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.58 2001/02/09 22:48:38 mud Exp $";
d985 1
a985 1
	     ch->pcdata->skill_point_timer = 36;
@


1.58
log
@Skill point timer shrink and shorten
-Rusty
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.57 2000/08/27 23:23:08 mud Exp $";
d961 1
a961 1
	ch->pcdata->skill_point_tracker < 2)
d984 2
a985 2
	  if (ch->pcdata->skill_point_tracker >= 2)
	     ch->pcdata->skill_point_timer = 6;
@


1.57
log
@27-Aug-00 Making skill point tracker work in skills.c - Boogums
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.56 2000/08/26 18:38:12 mud Exp $";
d961 1
a961 1
	ch->pcdata->skill_point_tracker < 35)
d984 2
a985 2
	  if (ch->pcdata->skill_point_tracker >= 35)
	     ch->pcdata->skill_point_timer = 90;
@


1.56
log
@remove double exp day
-poq
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.55 2000/08/24 20:11:16 mud Exp $";
d961 1
a961 1
	ch->pcdata->skill_point_tracker < 100)
d984 1
a984 1
	  if (ch->pcdata->skill_point_tracker >= 100)
@


1.55
log
@double skill points for double exp day
-poq
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.54 2000/07/26 00:19:29 mud Exp $";
d973 1
a973 1
	     skillpoints = 4;
d975 1
a975 1
	     skillpoints = 2;
@


1.54
log
@remove debug code
-poq
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.53 2000/07/26 00:14:17 mud Exp $";
d961 1
a961 1
	ch->pcdata->skill_point_tracker < 35)
d973 2
a975 2
	  else
	     skillpoints = 1;
d984 1
a984 1
	  if (ch->pcdata->skill_point_tracker >= 35)
@


1.53
log
@debug lines in skill_levle to track it down
-poq
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.52 2000/07/06 00:14:46 mud Exp $";
d909 1
a909 1
send_to_char("1\n\r",ch);
a911 1
send_to_char("2\n\r",ch);
a916 1
send_to_char("3\n\r",ch);
a920 1
send_to_char("4\n\r",ch);
a929 1
send_to_char("5\n\r",ch);
@


1.52
log
@add a blank line before practices
poq
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.51 2000/07/06 00:10:04 mud Exp $";
d909 1
a909 1

d912 1
d918 1
d923 1
d933 1
@


1.51
log
@gain list displays pracs left
-poq
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.50 2000/04/18 19:51:06 mud Exp $";
d110 1
a110 1
        sprintf( buf, "You have %d practice sessions left.\n\r",
@


1.50
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.49 2000/04/17 22:00:53 mud Exp $";
d109 4
@


1.49
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.48 2000/03/21 21:08:36 mud Exp $";
d117 1
a117 1
		ch,NULL,trainer,TO_CHAR); return;
d133 1
a133 1
		ch,NULL,trainer,TO_CHAR);
d138 1
a138 1
		ch,NULL,trainer,TO_CHAR);
d151 1
a151 1
		ch,NULL,trainer,TO_CHAR);
d158 1
a158 1
		ch,NULL,trainer,TO_CHAR);
d163 1
a163 1
	    ch,NULL,trainer,TO_CHAR);
d180 1
a180 1
		ch,NULL,trainer,TO_CHAR);
d187 1
a187 1
		ch,NULL,trainer,TO_CHAR);
d198 1
a198 1
		ch,NULL,trainer,TO_CHAR);
d205 1
a205 1
	    ch,group_table[gn].name,trainer,TO_CHAR);
d219 1
a219 1
		ch,NULL,trainer,TO_CHAR);
d227 1
a227 1
                ch,NULL,trainer,TO_CHAR);
d234 1
a234 1
                ch,NULL,trainer,TO_CHAR);
d244 1
a244 1
                ch,NULL,trainer,TO_CHAR);
d251 1
a251 1
            ch,skill_table[sn].name,trainer,TO_CHAR);
d259 1
a259 1
    act("$N tells you 'I do not understand...'",ch,NULL,trainer,TO_CHAR);
@


1.48
log
@lowered skill_point_timer to 90 cause ticks seem to take longer then 30 secs
poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.47 2000/03/15 21:40:26 mud Exp $";
d41 1
a41 1
    if (trainer == NULL || !can_see(ch,trainer))
@


1.47
log
@change skill points gaining
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.46 2000/03/06 01:18:43 mud Exp $";
d981 1
a981 1
	     ch->pcdata->skill_point_timer = 120;
@


1.46
log
@skill points syntax error
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.45 2000/03/06 01:17:05 mud Exp $";
a960 4
       sprintf(buf,"blah= %d x= %d y= %d\n\r",blah,blahx);
       send_to_char(buf,ch);
       */  
       /*
d963 1
a963 1
       if ( blahy == (10 - blah)/2 )
@


1.45
log
@not printing skillpoints on display line
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.44 2000/03/06 00:23:42 mud Exp $";
d978 1
a978 1
                  skill_table[sn].name,
@


1.44
log
@Dual Wield changes, second_hitroll,second_damroll and increase skill points to 2 for spells
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.43 2000/02/26 00:06:32 mud Exp $";
d979 1
a979 1
                  skillpoints);
@


1.43
log
@gain apply applies all the skill points it can
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.42 2000/02/25 16:43:58 mud Exp $";
d972 5
a976 1
	  skillpoints = 1;
@


1.42
log
@ Updated gain list to show prices in pracs instead ogf trains

 -Rage.
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.41 2000/02/25 00:00:50 mud Exp $";
d29 1
a29 1
    int gn = 0, sn = 0;
d121 3
a123 2
	ch->skill_points -= 10;
	ch->practice += 1;
@


1.41
log
@Turn on the Pfresh
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.40 2000/02/16 07:08:09 mud Exp $";
d73 2
a74 2
		sprintf(buf,"%-18s %-5d ",
		    group_table[gn].name,group_table[gn].rating[ch->class]);
d101 1
a101 1
                    skill_table[sn].name,skill_table[sn].rating[ch->class]);
@


1.40
log
@remove pfresh beta code
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.39 2000/02/16 02:23:22 mud Exp $";
a111 1
/*
a124 1
    */
a126 1
*/
d142 1
d144 1
d169 1
d191 1
d194 1
a194 1
	if (ch->train < group_table[gn].rating[ch->class])
a204 1
	    /*
d206 2
a208 1
	ch->train -= group_table[gn].rating[ch->class];
d238 2
a240 2
	*/
        if (ch->train < skill_table[sn].rating[ch->class])
d252 2
a254 2
	*/
        ch->train -= skill_table[sn].rating[ch->class];
@


1.39
log
@fixed extra debit level displaing in customization
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.38 2000/02/15 20:04:25 mud Exp $";
d112 1
d126 1
d129 1
a144 1
    */
d191 2
a193 2
	*/
	if (ch->practice < (group_table[gn].rating[ch->class] * 10))
d205 2
a207 2
	*/
	ch->practice -= (group_table[gn].rating[ch->class] * 10);
d237 2
a239 2
	*/
        if (ch->practice < (skill_table[sn].rating[ch->class] * 10 ))
d251 2
a253 2
	*/
        ch->practice -= (skill_table[sn].rating[ch->class] * 10);
@


1.38
log
@Beta Test Time
_poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.37 2000/02/10 19:15:20 mud Exp $";
d455 1
a455 1
    int gn,sn,col,oldLevel;
d518 4
a521 3
       oldLevel = ch->exp / exp_per_level(ch,ch->pcdata->points);
       if( ( ch->level < 11 ) && (oldLevel > ch->level ) )
          oldLevel = ch->level ;
d527 2
a528 2
          if ( oldLevel > 76 )
             oldLevel = 76;
d532 2
a533 2
          if(oldLevel > 50 )
             oldLevel =50;
d535 1
a535 1
       sprintf(buf,"Debit levels: %d\n\r",oldLevel);
@


1.37
log
@devlare oldLevel for displaying debit levels
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.36 2000/02/10 19:11:48 mud Exp $";
a111 1
/*
a124 1
    */
d126 1
d142 1
d188 1
d190 2
d202 1
d204 2
d234 1
d236 2
d248 1
d250 2
@


1.36
log
@display debit levels to prfreshers
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.35 2000/01/22 00:12:17 mud Exp $";
d443 1
a443 1
    int gn,sn,col;
@


1.35
log
@Can only gain skill points while fighting and can gain 35 per hour now
-Poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.34 2000/01/13 07:36:11 mud Exp $";
d504 21
@


1.34
log
@color the skills line
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.33 2000/01/12 08:09:05 mud Exp $";
d917 3
a919 1
    if (ch->pcdata->learned[sn] >= 80 && ch->pcdata->skill_point_tracker < 10)
d942 1
a942 1
	  if (ch->pcdata->skill_point_tracker >= 10)
@


1.33
log
@skill points more tweaks
-poqah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.32 2000/01/12 08:07:29 mud Exp $";
d933 1
a933 1
	  sprintf(buf,"Your use of %s has gained you some skill!\n\r",
@


1.32
log
@skill points blah
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.31 2000/01/12 07:54:24 mud Exp $";
d927 1
a927 1
       if ( blahy = (10 - blah)/2 )
@


1.31
log
@skill lessen skill points being gained
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.30 2000/01/12 07:42:33 mud Exp $";
d927 1
a927 1
       if ( blahy > 0 && blahy <= (10 - blah)/2 )
d933 1
a933 1
	  sprintf(buf,"Your use of %s has gained you some skill! ({G%d{x)\n\r",
@


1.30
log
@skp skp skp
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.29 2000/01/12 07:26:43 mud Exp $";
d897 1
a897 1
    int chance, blahy,blahx,blah,skillpoints;
a918 1
       blahx = UMAX(2,10-blah);
d920 1
d923 1
d927 1
a927 1
       if ( blahy <= (10 - blah)/2 )
@


1.29
log
@still on skill points
-poq
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.28 2000/01/12 07:05:04 mud Exp $";
d920 1
a920 1
       blahy = number_percent() * number_percent();
@


1.28
log
@debug some more skill points
-poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.27 2000/01/12 06:18:15 mud Exp $";
d897 1
a897 1
    int chance, blahx,blah,skillpoints;
d920 2
a921 1
       sprintf(buf,"blah= %d u= %d\n\r",blah,blahx);
d926 1
a926 1
       if ( number_percent() * number_percent() <= (10 - blah)/2 )
@


1.27
log
@working on skill points
-Poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.26 2000/01/11 00:54:53 mud Exp $";
d920 1
a920 1
       sprintf(buf,"blah= %d u= %d",blah,blahx);
d922 1
d924 2
@


1.26
log
@Track skill points , cap at 10 per hour
-Poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.25 2000/01/10 23:40:07 mud Exp $";
d897 1
a897 1
    int chance, blah,skillpoints;
d919 3
d924 1
d926 2
@


1.25
log
@Add a line to the char for skill points gained
and fix the double +prime and +sec for reclasses in act_comm.c
-Poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.24 2000/01/09 22:27:36 mud Exp $";
d917 1
a917 1
    if (ch->pcdata->learned[sn] >= 80)
d927 5
@


1.24
log
@Added 100 point CP cap.
-Rusty
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.23 2000/01/07 21:49:49 mud Exp $";
d897 1
a897 1
    int chance, blah;
d917 1
a917 1
    if (ch->pcdata->learned[sn] == 100)
d920 8
a927 1
          ch->skill_points += UMAX(1,10-blah);
@


1.23
log
@Fix the skill points code and reset the skill points in pfiles
-Poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.22 2000/01/07 00:07:56 mud Exp $";
d645 1
a645 2
	if (gn != -1
	    && ch->gen_data->points_chosen + group_table[gn].rating[ch->class] < 316)
d647 2
d669 7
d679 1
a679 2
	if (sn != -1 &&
	    ch->gen_data->points_chosen + skill_table[sn].rating[ch->class] < 316)
d681 2
d703 7
@


1.22
log
@remove gain apply temp
-Poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.21 1999/12/17 00:02:15 mud Exp $";
d898 9
d913 1
d917 1
@


1.21
log
@Remove Savant and Scion stuff
-Poquah
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.20 1999/09/14 04:21:42 mud Exp $";
d112 1
d126 1
@


1.20
log
@skill points apply
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.19 1999/09/03 19:26:05 mud Exp $";
d891 1
d894 1
@


1.19
log
@Added skill points, will implement that later.
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.18 1999/08/11 02:27:13 mud Exp $";
d109 14
@


1.18
log
@Trying to fix a mysterious crash bug
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.17 1999/07/14 18:14:09 mud Exp $";
d887 2
@


1.17
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d3 1
a3 1
static char rcsid[] = "$Id: skills.c,v 1.16 1999/06/28 06:34:20 mud Exp $";
d294 3
a296 2
	  mana = UMAX(skill_table[sn].min_mana,
		      100/(2 + ch->level - lev));
@


1.16
log
@Fixed skill levels
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.15 1999/06/28 05:30:56 mud Exp $ */
@


1.15
log
@Testing new level stuff
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.14 1999/05/22 21:44:17 mud Exp $ */
d284 1
a284 1
      if (skill_table[sn].skill_level[ch->class] < LEVEL_HERO &&
d289 1
a289 1
	lev = skill_table[sn].skill_level[ch->class];
d879 1
a879 1
    if (ch->level < skill_table[sn].skill_level[ch->class]
@


1.14
log
@*Added flame shiel
*Fixed betstow holiness and flamesword
*Repaired a bug in shapaeshifter
*that's it
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.13 1999/04/28 08:09:32 mud Exp $ */
d368 1
a368 1
      if ( skill_table[sn].skill_level[ch->class] < LEVEL_HERO &&
d373 1
a373 1
        lev = skill_table[sn].skill_level[ch->class];
d825 34
@


1.13
log
@Last bit of Svant code before the big quest
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.12 1999/01/03 04:32:08 mud Exp $ */
d558 3
d569 1
a569 1
        return 1000 * pc_race_table[ch->race].class_mult[ch->class]/100;
d588 1
a588 1
    noneg = expl * pc_race_table[ch->race].class_mult[ch->class]/100;
d592 1
a592 1
    return expl * pc_race_table[ch->race].class_mult[ch->class]/100;
@


1.12
log
@Made spamming from 1% impossible.
-Rusty
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.11 1998/12/13 22:06:25 mud Exp $ */
d838 3
@


1.11
log
@SOme changed
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.10 1998/12/08 23:23:09 mud Exp $ */
d841 1
a841 1
    ||  ch->pcdata->learned[sn] == 0
d843 1
a843 1
	return;  /* skill is not known */ 
@


1.10
log
@More stuff
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.9 1998/11/27 20:44:45 mud Exp $ */
d862 5
a866 2
	    sprintf(buf,"You have become better at %s!\n\r",
		    skill_table[sn].name);
a867 2
	    ch->pcdata->learned[sn] += number_range(1,3);
	    ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn],100);
d877 6
d884 2
a885 2
		"You learn from your mistakes, and your %s skill improves.\n\r",
		skill_table[sn].name);
a886 1
	    ch->pcdata->learned[sn]++;
d890 1
@


1.9
log
@Fixed 'x' at beginning of every skill name.
-Rusty
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.8 1998/11/27 08:04:19 mud Exp $ */
d832 6
@


1.8
log
@For soe reason I got my directories switched and did a change here.
Lo siento.
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.7 1998/11/27 07:35:59 mud Exp $ */
d377 1
a377 1
          sprintf(buf,"%c%-18s{x %3d%%      ", 
@


1.7
log
@Enervation fix3d
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.6 1998/10/11 00:41:29 mud Exp $ */
d380 1
@


1.6
log
@Fixed a litte thing with carriage return
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.5 1998/10/11 00:25:46 mud Exp $ */
d377 1
a377 1
          sprintf(buf,"%s%-18s%s %3d%%      ",
d379 1
a379 2
			? RED : "",
		skill_table[sn].name, NORMAL,
@


1.5
log
@added specialize to skills
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.4 1998/08/21 00:52:16 mud Exp $ */
d413 1
a413 1
	 sprintf(buf,"Specialization: %s\n\r",
@


1.4
log
@* Added a color thing to prac and skill  .. fluff.
-Ben
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.3 1998/08/15 18:45:50 mud Exp $ */
d395 1
a395 1
 
d410 8
@


1.3
log
@skills.c changed to add level range args for 'skills' and spells' commands
-Rusty
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.2 1998/08/10 19:55:54 mud Exp $ */
d377 8
a384 3
          sprintf(buf,"%-18s %3d%%      ",skill_table[sn].name,
					 ch->pcdata->learned[sn]);
 
@


1.2
log
@* Adjusted remorts
* Fixed a bug with negative skill_rating  values
-Ben
@
text
@d3 1
a3 1
/* @@(#)$Id: skills.c,v 1.1 1998/06/16 17:49:44 mud Exp $ */
d249 1
a249 1
    int sn,lev,mana;
d253 15
d318 1
a318 1
    for (lev = 0; lev < LEVEL_HERO; lev++)
d331 1
a331 1
    int sn,lev;
d335 16
d368 1
a368 1
      if (skill_table[sn].skill_level[ch->class] < LEVEL_HERO &&
d399 1
a399 1
    for (lev = 0; lev < LEVEL_HERO; lev++)
@


1.1
log
@Initial insert of all src files.
@
text
@d3 1
a3 1
/* @@(#)$Id$ */
d795 1
a795 3
    blah = ( IS_SET(ch->act,PLR_WERE) || IS_SET(ch->act,PLR_VAMP) ) 
	   ? abs(skill_table[sn].rating[ch->class])
	   : skill_table[sn].rating[ch->class];
@
