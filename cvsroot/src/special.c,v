head	1.125;
access;
symbols;
locks; strict;
comment	@ * @;


1.125
date	2005.08.25.19.47.16;	author rusty;	state Exp;
branches;
next	1.124;

1.124
date	2005.02.17.03.57.59;	author boogums;	state Exp;
branches;
next	1.123;

1.123
date	2005.02.17.03.46.13;	author boogums;	state Exp;
branches;
next	1.122;

1.122
date	2004.09.28.01.33.20;	author boogums;	state Exp;
branches;
next	1.121;

1.121
date	2004.09.28.01.29.23;	author boogums;	state Exp;
branches;
next	1.120;

1.120
date	2004.09.28.01.18.55;	author boogums;	state Exp;
branches;
next	1.119;

1.119
date	2004.09.28.01.14.37;	author boogums;	state Exp;
branches;
next	1.118;

1.118
date	2004.09.28.01.00.46;	author boogums;	state Exp;
branches;
next	1.117;

1.117
date	2004.04.29.01.48.16;	author boogums;	state Exp;
branches;
next	1.116;

1.116
date	2004.04.26.02.25.10;	author boogums;	state Exp;
branches;
next	1.115;

1.115
date	2004.04.25.00.32.05;	author boogums;	state Exp;
branches;
next	1.114;

1.114
date	2003.09.28.18.45.37;	author ndagger;	state Exp;
branches;
next	1.113;

1.113
date	2003.09.28.03.54.06;	author ndagger;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.28.03.39.11;	author ndagger;	state Exp;
branches;
next	1.111;

1.111
date	2003.09.28.03.26.20;	author ndagger;	state Exp;
branches;
next	1.110;

1.110
date	2002.10.12.01.44.00;	author ndagger;	state Exp;
branches;
next	1.109;

1.109
date	2002.09.03.16.55.48;	author rusty;	state Exp;
branches;
next	1.108;

1.108
date	2002.04.24.02.38.09;	author boogums;	state Exp;
branches;
next	1.107;

1.107
date	2002.04.06.02.57.50;	author boogums;	state Exp;
branches;
next	1.106;

1.106
date	2002.04.05.15.24.28;	author boogums;	state Exp;
branches;
next	1.105;

1.105
date	2002.03.22.08.42.45;	author poquah;	state Exp;
branches;
next	1.104;

1.104
date	2001.11.24.15.09.58;	author rage;	state Exp;
branches;
next	1.103;

1.103
date	2001.11.16.00.32.19;	author rage;	state Exp;
branches;
next	1.102;

1.102
date	2001.11.11.23.48.17;	author rage;	state Exp;
branches;
next	1.101;

1.101
date	2001.11.11.17.29.12;	author rage;	state Exp;
branches;
next	1.100;

1.100
date	2001.11.10.19.13.43;	author rage;	state Exp;
branches;
next	1.99;

1.99
date	2001.11.10.18.38.25;	author rage;	state Exp;
branches;
next	1.98;

1.98
date	2001.10.14.04.33.49;	author rage;	state Exp;
branches;
next	1.97;

1.97
date	2001.10.13.02.11.59;	author rage;	state Exp;
branches;
next	1.96;

1.96
date	2001.10.12.17.37.26;	author rage;	state Exp;
branches;
next	1.95;

1.95
date	2001.10.11.16.42.11;	author rage;	state Exp;
branches;
next	1.94;

1.94
date	2001.10.05.18.09.38;	author rage;	state Exp;
branches;
next	1.93;

1.93
date	2001.10.05.17.33.45;	author rage;	state Exp;
branches;
next	1.92;

1.92
date	2001.09.23.21.08.06;	author rage;	state Exp;
branches;
next	1.91;

1.91
date	2001.09.23.20.25.05;	author rage;	state Exp;
branches;
next	1.90;

1.90
date	2001.08.14.19.59.11;	author rusty;	state Exp;
branches;
next	1.89;

1.89
date	2001.07.25.18.27.44;	author rage;	state Exp;
branches;
next	1.88;

1.88
date	2001.07.20.16.14.04;	author rage;	state Exp;
branches;
next	1.87;

1.87
date	2001.07.20.01.04.12;	author rage;	state Exp;
branches;
next	1.86;

1.86
date	2001.07.20.00.23.02;	author rage;	state Exp;
branches;
next	1.85;

1.85
date	2001.07.19.02.13.58;	author rage;	state Exp;
branches;
next	1.84;

1.84
date	2001.07.19.02.01.50;	author rage;	state Exp;
branches;
next	1.83;

1.83
date	2001.07.19.01.41.25;	author rage;	state Exp;
branches;
next	1.82;

1.82
date	2001.07.15.19.09.45;	author rusty;	state Exp;
branches;
next	1.81;

1.81
date	2001.07.10.23.39.13;	author rage;	state Exp;
branches;
next	1.80;

1.80
date	2001.07.10.12.13.34;	author rusty;	state Exp;
branches;
next	1.79;

1.79
date	2001.07.09.22.08.17;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	2001.07.09.21.50.14;	author rusty;	state Exp;
branches;
next	1.77;

1.77
date	2001.07.09.21.40.43;	author rusty;	state Exp;
branches;
next	1.76;

1.76
date	2001.07.09.21.13.52;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	2001.07.09.21.07.49;	author rusty;	state Exp;
branches;
next	1.74;

1.74
date	2001.07.09.19.52.49;	author rusty;	state Exp;
branches;
next	1.73;

1.73
date	2001.07.09.19.41.53;	author rusty;	state Exp;
branches;
next	1.72;

1.72
date	2001.07.09.18.15.39;	author rusty;	state Exp;
branches;
next	1.71;

1.71
date	2001.07.05.23.35.00;	author rage;	state Exp;
branches;
next	1.70;

1.70
date	2001.07.05.23.16.32;	author rage;	state Exp;
branches;
next	1.69;

1.69
date	2001.07.02.21.48.25;	author rage;	state Exp;
branches;
next	1.68;

1.68
date	2001.07.02.21.36.08;	author rage;	state Exp;
branches;
next	1.67;

1.67
date	2001.07.02.16.16.38;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	2001.07.02.15.55.01;	author rusty;	state Exp;
branches;
next	1.65;

1.65
date	2001.07.01.17.15.25;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	2001.07.01.17.13.35;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	2001.07.01.17.09.46;	author rusty;	state Exp;
branches;
next	1.62;

1.62
date	2001.07.01.15.19.55;	author rusty;	state Exp;
branches;
next	1.61;

1.61
date	2001.06.25.22.26.44;	author rusty;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.25.22.24.19;	author rusty;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.19.19.42.56;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.19.19.32.11;	author rusty;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.19.19.30.02;	author rusty;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.19.18.41.35;	author rusty;	state Exp;
branches;
next	1.55;

1.55
date	2001.06.18.04.07.38;	author guerrand;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.18.01.02.33;	author guerrand;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.18.00.49.51;	author guerrand;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.18.00.39.30;	author guerrand;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.17.17.06.01;	author guerrand;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.17.05.18.03;	author guerrand;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.17.02.44.20;	author guerrand;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.17.01.47.21;	author guerrand;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.15.03.50.35;	author guerrand;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.15.03.08.11;	author guerrand;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.15.01.27.51;	author guerrand;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.14.03.59.52;	author guerrand;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.14.03.48.08;	author guerrand;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.14.02.51.52;	author guerrand;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.14.02.48.51;	author guerrand;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.14.02.46.58;	author guerrand;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.14.02.38.40;	author guerrand;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.14.02.33.49;	author guerrand;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.14.00.41.21;	author guerrand;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.13.03.47.56;	author guerrand;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.03.19.17.15;	author guerrand;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.02.17.43.00;	author guerrand;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.02.17.30.06;	author guerrand;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.25.01.44.24;	author guerrand;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.25.01.35.14;	author guerrand;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.09.01.30.26;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.10.03.31.30;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.20.01.28.10;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.20.00.45.37;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.18.19.51.07;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.17.22.00.54;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.24.03.13.01;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.23.23.21.25;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.20.23.33.35;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	99.12.08.21.53.41;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	99.12.08.21.41.38;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	99.12.08.21.37.51;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	99.12.08.21.35.46;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	99.12.08.21.07.47;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	99.08.10.23.00.56;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	99.07.14.18.14.10;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	99.05.23.06.20.12;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	99.04.15.01.38.40;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	99.04.01.07.49.02;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	99.03.27.04.05.17;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	99.03.27.03.45.35;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	99.03.27.03.36.18;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	99.03.27.03.33.24;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	99.03.04.20.16.05;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.10.19.05.50.12;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.10.10.03.53.36;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.10.10.02.38.36;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.10.10.02.26.09;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.08.10.05.32.18;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.45;	author mud;	state Exp;
branches;
next	;


desc
@@


1.125
log
@Summoned elementals now always rescue the king instead of the
first MOB with the same name as their summoner.
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: special.c,v 1.124 2005/02/17 03:57:59 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "merc.h"
#include "magic.h"
#include "lookup.h"

void	check_equip	args( (CHAR_DATA *ch) );
bool	check_wear	args( (CHAR_DATA *ch, OBJ_DATA *obj) );
void	one_hit		args( ( CHAR_DATA *ch, CHAR_DATA *victim, int dt ) );
int     count_fight_size args( (CHAR_DATA *ch) );
 
/* command procedures needed */
DECLARE_DO_FUN(do_order	);
DECLARE_DO_FUN( do_wear	);
DECLARE_DO_FUN(do_rescue);
DECLARE_DO_FUN(do_yell		);
DECLARE_DO_FUN(do_bash		);
DECLARE_DO_FUN(do_open		);
DECLARE_DO_FUN(do_close		);
DECLARE_DO_FUN(do_say	);
DECLARE_DO_FUN(do_backstab);
DECLARE_DO_FUN(do_flee);
DECLARE_DO_FUN(do_murder);
DECLARE_DO_FUN(do_wake);
DECLARE_DO_FUN(do_stand);
void say_spell( CHAR_DATA *ch, int sn );

/*
 * The following special functions are available for mobiles.
 */
DECLARE_SPEC_FUN(	spec_breath_any		);
DECLARE_SPEC_FUN(	spec_breath_acid	);
DECLARE_SPEC_FUN(	spec_breath_fire	);
DECLARE_SPEC_FUN(	spec_breath_frost	);
DECLARE_SPEC_FUN(	spec_breath_gas		);
DECLARE_SPEC_FUN(	spec_breath_lightning	);
DECLARE_SPEC_FUN(	spec_cast_adept		);
DECLARE_SPEC_FUN(	spec_cast_cleric	);
DECLARE_SPEC_FUN(	spec_cast_judge		);
DECLARE_SPEC_FUN(	spec_cast_mage		);
DECLARE_SPEC_FUN(	spec_cast_undead	);
DECLARE_SPEC_FUN(	spec_executioner	);
DECLARE_SPEC_FUN(	spec_fido		);
DECLARE_SPEC_FUN(	spec_guard_l		);
DECLARE_SPEC_FUN(	spec_guard_d		);
DECLARE_SPEC_FUN(	spec_janitor		);
DECLARE_SPEC_FUN(	spec_mayor		);
DECLARE_SPEC_FUN(	spec_poison		);
DECLARE_SPEC_FUN(	spec_thief		);
DECLARE_SPEC_FUN(	spec_puff		);
DECLARE_SPEC_FUN(	spec_phoenix		);
DECLARE_SPEC_FUN(	spec_nasty		);
DECLARE_SPEC_FUN(	spec_troll_member	);
DECLARE_SPEC_FUN(	spec_ogre_member	);
DECLARE_SPEC_FUN(	spec_patrolman		);
DECLARE_SPEC_FUN(	spec_rabbit		);
DECLARE_SPEC_FUN(	spec_cast_dispel	);
DECLARE_SPEC_FUN(	spec_monk		);
DECLARE_SPEC_FUN(	spec_altirin_undead	);
DECLARE_SPEC_FUN(	spec_vhan		);
DECLARE_SPEC_FUN(	spec_drachlan_melee	);
DECLARE_SPEC_FUN(	spec_drachlan_medic	);
DECLARE_SPEC_FUN(	spec_average		);
DECLARE_SPEC_FUN(	spec_salesman		);
DECLARE_SPEC_FUN(	spec_elemental_fire	);
DECLARE_SPEC_FUN(	spec_elemental_king	);
DECLARE_SPEC_FUN(	spec_elemental_water	);
DECLARE_SPEC_FUN(	spec_elemental_water_king	);
DECLARE_SPEC_FUN(       spec_honor_guard        );
DECLARE_SPEC_FUN(       spec_demise_guard       );
DECLARE_SPEC_FUN(       spec_posse_guard        );
DECLARE_SPEC_FUN(       spec_zealot_guard       );
DECLARE_SPEC_FUN(       spec_warlock_guard      );
DECLARE_SPEC_FUN(       spec_jabber             );

/* the function table */
const   struct  spec_type    spec_table[] =
{
    {	"spec_breath_any",		spec_breath_any		},
    {	"spec_breath_acid",		spec_breath_acid	},
    {	"spec_breath_fire",		spec_breath_fire	},
    {	"spec_breath_frost",		spec_breath_frost	},
    {	"spec_breath_gas",		spec_breath_gas		},
    {	"spec_breath_lightning",	spec_breath_lightning	},	
    {	"spec_cast_adept",		spec_cast_adept		},
    {	"spec_cast_cleric",		spec_cast_cleric	},
    {	"spec_cast_judge",		spec_cast_judge		},
    {	"spec_cast_mage",		spec_cast_mage		},
    {	"spec_cast_undead",		spec_cast_undead	},
    {	"spec_executioner",		spec_executioner	},
    {	"spec_fido",			spec_fido		},
    {	"spec_guard_l",			spec_guard_l		},
    {	"spec_guard_d",			spec_guard_d		},
    {   "spec_honor_guard",             spec_honor_guard        },
    {   "spec_demise_guard",            spec_demise_guard       },
    {   "spec_posse_guard",             spec_posse_guard        },
    {   "spec_zealot_guard",            spec_zealot_guard       },
    {   "spec_warlock_guard",           spec_warlock_guard      },
    {	"spec_janitor",			spec_janitor		},
    {	"spec_mayor",			spec_mayor		},
    {	"spec_poison",			spec_poison		},
    {	"spec_thief",			spec_thief		},
    {	"spec_puff",			spec_puff		},
    {   "spec_phoenix",			spec_phoenix		},
    {	"spec_nasty",			spec_nasty		},
    {	"spec_troll_member",		spec_troll_member	},
    {	"spec_ogre_member",		spec_ogre_member	},
    {	"spec_patrolman",		spec_patrolman		},
    {	"spec_rabbit",			spec_rabbit		},
    {	"spec_cast_dispel",		spec_cast_dispel	},
    {	"spec_monk",			spec_monk		},
    {   "spec_altirin_undead",		spec_altirin_undead	},
    {	"spec_vhan",			spec_vhan		},
    {   "spec_drachlan_melee",		spec_drachlan_melee	},
    {   "spec_drachlan_medic",		spec_drachlan_medic	},
    {   "spec_average",			spec_average		},
    {   "spec_salesman",		spec_salesman		},
    {   "spec_elemental_king",		spec_elemental_king	},
    {   "spec_elemental_fire",		spec_elemental_fire	},
    {   "spec_elemental_water",		spec_elemental_water	},
    {   "spec_elemental_water_king",		spec_elemental_water_king	},
    {   "spec_jabber",                  spec_jabber             },
    {	NULL,				NULL			}
};

/*
 * Given a name, return the appropriate spec fun.
 */
SPEC_FUN *spec_lookup( const char *name )
{
   int i;
 
   for ( i = 0; spec_table[i].name != NULL; i++)
   {
        if (LOWER(name[0]) == LOWER(spec_table[i].name[0])
        &&  !str_prefix( name,spec_table[i].name))
            return spec_table[i].function;
   }
 
    return 0;
}

char *spec_name( SPEC_FUN *function)
{
    int i;

    for (i = 0; spec_table[i].function != NULL; i++)
    {
	if (function == spec_table[i].function)
	    return spec_table[i].name;
    }

    return NULL;
}

/*  Guards for clans have their specs here. for easy removal if necessary */
bool spec_honor_guard( CHAR_DATA *ch)
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    CHAR_DATA *clanmate;
    DESCRIPTOR_DATA *d;

    if ( !IS_AWAKE(ch) )
	do_stand(ch,""); 

    if ( !IS_AWAKE(ch) || ch->fighting != NULL)
        return FALSE;

    for (victim = ch->in_room->people;  victim != NULL; victim = v_next)
    {
        v_next = victim->next_in_room;
        if (ch == victim) continue;
        if (IS_NPC(victim)) continue;
        if ( !is_clan(victim) ) return FALSE;
/*  The next line is the meat and potatoes.  Change the clan as appropriate */
        if ( 
             ( IS_SET(victim->mhs, MHS_BANISH) 
             || victim->clan != clan_lookup("honor")
             )
              && !IS_IMMORTAL(victim) 
           )
            break;

    }

    if (ch->position < POS_STANDING)
        do_stand(ch,"");

    if (victim != NULL && is_clan(victim))
    {
        sprintf( buf, "What are you doing here, %s?!  Halt, knave!",
            victim->name );
        REMOVE_BIT(ch->comm, COMM_NOSHOUT);
        do_yell(ch, buf);
        multi_hit( ch, victim, TYPE_UNDEFINED);

/*  Here's where the guard "clans" for help.  Wheee! */


        for (d = descriptor_list; d != NULL; d = d->next )
        {
            clanmate = d->original ? d->original : d->character;

            if (d->connected != CON_PLAYING) continue;

            if ( (d->connected == CON_PLAYING) && (!IS_SET(d->character->comm, COMM_NOCLAN)) &&
                (!IS_SET(d->character->comm, COMM_QUIET)) )
            {
                if ( IS_IMMORTAL(clanmate) && IS_SET(clanmate->mhs, MHS_LISTEN) )
                  send_to_char("[{CHonor{x] A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);

                if ( clanmate->clan == clan_lookup("honor") && !IS_IMMORTAL(clanmate) ) 
                  send_to_char("A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);   
            }
        }
        return TRUE;
    }
    else
        return FALSE;
}


bool spec_demise_guard( CHAR_DATA *ch)
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    CHAR_DATA *clanmate;
    DESCRIPTOR_DATA *d;

    if ( !IS_AWAKE(ch) )
        do_stand(ch,"");

    if ( !IS_AWAKE(ch) || ch->fighting != NULL)
        return FALSE;

    for (victim = ch->in_room->people;  victim != NULL; victim = v_next)
    {
        v_next = victim->next_in_room;
        if (ch == victim) continue;
        if (IS_NPC(victim)) continue;
        if ( !is_clan(victim) ) return FALSE;

/*  The next line is the meat and potatoes.  Change the clan as appropriate */
        //if ( victim->clan != clan_lookup("demise") && !IS_IMMORTAL(victim) )
        if (
             ( IS_SET(victim->mhs, MHS_BANISH)
             || victim->clan != clan_lookup("demise")
             )
              && !IS_IMMORTAL(victim)
           )
            break;
    }

    if (ch->position < POS_STANDING)
        do_stand(ch,"");

    if (victim != NULL  )
    {
        sprintf( buf, "What are you doing here, %s?!  Halt, knave!",
            victim->name );
        REMOVE_BIT(ch->comm, COMM_NOSHOUT);
        do_yell(ch, buf);
        multi_hit( ch, victim, TYPE_UNDEFINED);

/*  Here's where the guard "clans" for help.  Wheee! */


        for (d = descriptor_list; d != NULL; d = d->next )
        {
            clanmate = d->original ? d->original : d->character;

            if (d->connected != CON_PLAYING) continue;

            if ( (d->connected == CON_PLAYING) && (!IS_SET(d->character->comm, COMM_NOCLAN)) &&
                (!IS_SET(d->character->comm, COMM_QUIET)) )
            {
                if ( IS_IMMORTAL(clanmate) && IS_SET(clanmate->mhs, MHS_LISTEN) )
                  send_to_char("[{RDemise{x] A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);

                if ( clanmate->clan == clan_lookup("demise") && !IS_IMMORTAL(clanmate) ) 
                  send_to_char("A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);   
            }
        }
        return TRUE;
    }
    else
        return FALSE;
}


bool spec_posse_guard( CHAR_DATA *ch)
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    CHAR_DATA *clanmate;
    DESCRIPTOR_DATA *d;

    if ( !IS_AWAKE(ch) )
        do_stand(ch,"");

    if ( !IS_AWAKE(ch) || ch->fighting != NULL)
        return FALSE;

    for (victim = ch->in_room->people;  victim != NULL; victim = v_next)
    {
        v_next = victim->next_in_room;
        if (ch == victim) continue;
        if (IS_NPC(victim)) continue;
        if ( !is_clan(victim) ) return FALSE;
/*  The next line is the meat and potatoes.  Change the clan as appropriate */
    //    if ( victim->clan != clan_lookup("posse") && !IS_IMMORTAL(victim) )
      //      break;
        if (
             ( IS_SET(victim->mhs, MHS_BANISH)
             || victim->clan != clan_lookup("posse")
             )
              && !IS_IMMORTAL(victim)
           )
            break;


    }

    if (ch->position < POS_STANDING)
        do_stand(ch,"");

    if (victim != NULL && is_clan(victim))
    {
        sprintf( buf, "What are you doing here, %s?!  Halt, knave!",
            victim->name );
        REMOVE_BIT(ch->comm, COMM_NOSHOUT);
        do_yell(ch, buf);
        multi_hit( ch, victim, TYPE_UNDEFINED);

/*  Here's where the guard "clans" for help.  Wheee! */


        for (d = descriptor_list; d != NULL; d = d->next )
        {
            clanmate = d->original ? d->original : d->character;

            if (d->connected != CON_PLAYING) continue;

            if ( (d->connected == CON_PLAYING) && (!IS_SET(d->character->comm, COMM_NOCLAN)) &&
                (!IS_SET(d->character->comm, COMM_QUIET)) )
            {
                if ( IS_IMMORTAL(clanmate) && IS_SET(clanmate->mhs, MHS_LISTEN) )
                  send_to_char("[{MPosse{x] A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);

                if ( clanmate->clan == clan_lookup("posse") && !IS_IMMORTAL(clanmate) ) 
                  send_to_char("A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);   
            }
        }
        return TRUE;
    }
    else
        return FALSE;
}


bool spec_zealot_guard( CHAR_DATA *ch)
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    CHAR_DATA *clanmate;
    DESCRIPTOR_DATA *d;

    if ( !IS_AWAKE(ch) )
        do_stand(ch,"");

    if ( !IS_AWAKE(ch) || ch->fighting != NULL)
        return FALSE;
    for (victim = ch->in_room->people;  victim != NULL; victim = v_next)
    {
        v_next = victim->next_in_room;
        if (ch == victim) continue;
        if (IS_NPC(victim)) continue;
        if ( !is_clan(victim) ) return FALSE;
/*  The next line is the meat and potatoes.  Change the clan as appropriate */
        if (
             ( IS_SET(victim->mhs, MHS_BANISH)
             || victim->clan != clan_lookup("zealot")
             )
              && !IS_IMMORTAL(victim)
           )
            break;

    }



    if (ch->position < POS_STANDING)
        do_stand(ch,"");

    if (victim != NULL  && is_clan(victim))
    {
        sprintf( buf, "What are you doing here, %s?!  Halt, knave!",
            victim->name );
        REMOVE_BIT(ch->comm, COMM_NOSHOUT);
        do_yell(ch, buf);
        multi_hit( ch, victim, TYPE_UNDEFINED);

/*  Here's where the guard "clans" for help.  Wheee! */


        for (d = descriptor_list; d != NULL; d = d->next )
        {
            clanmate = d->original ? d->original : d->character;

            if (d->connected != CON_PLAYING) continue;

            if ( (d->connected == CON_PLAYING) && (!IS_SET(d->character->comm, COMM_NOCLAN)) &&
                (!IS_SET(d->character->comm, COMM_QUIET)) )
            {
                if ( IS_IMMORTAL(clanmate) && IS_SET(clanmate->mhs, MHS_LISTEN) )
                  send_to_char("[{YZealot{x] A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);

                if ( clanmate->clan == clan_lookup("zealot") && !IS_IMMORTAL(clanmate) ) 
                  send_to_char("A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);   
            }
        }
        return TRUE;
    }
    else
        return FALSE;
}


bool spec_warlock_guard( CHAR_DATA *ch)
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    CHAR_DATA *clanmate;
    DESCRIPTOR_DATA *d;

    if ( !IS_AWAKE(ch) )
        do_stand(ch,"");

    if ( !IS_AWAKE(ch) || ch->fighting != NULL)
        return FALSE;

    for (victim = ch->in_room->people;  victim != NULL; victim = v_next)
    {
        v_next = victim->next_in_room;
        if (ch == victim) continue;
        if (IS_NPC(victim)) continue;
        if ( !is_clan(victim) ) return FALSE;
/*  The next line is the meat and potatoes.  Change the clan as appropriate */
        //if ( victim->clan != clan_lookup("warlock") && !IS_IMMORTAL(victim) )
        //    break;
           if (
             ( IS_SET(victim->mhs, MHS_BANISH)
             || victim->clan != clan_lookup("warlock")
             )
              && !IS_IMMORTAL(victim)
           )
            break;

    }

    if (ch->position < POS_STANDING)
        do_stand(ch,"");

    if (victim != NULL  && is_clan(victim))
    {
        sprintf( buf, "What are you doing here, %s?!  Halt, knave!",
            victim->name );
        REMOVE_BIT(ch->comm, COMM_NOSHOUT);
        do_yell(ch, buf);
        multi_hit( ch, victim, TYPE_UNDEFINED);

/*  Here's where the guard "clans" for help.  Wheee! */


        for (d = descriptor_list; d != NULL; d = d->next )
        {
            clanmate = d->original ? d->original : d->character;

            if (d->connected != CON_PLAYING) continue;

            if ( (d->connected == CON_PLAYING) && (!IS_SET(d->character->comm, COMM_NOCLAN)) &&
                (!IS_SET(d->character->comm, COMM_QUIET)) )
            {
                if ( IS_IMMORTAL(clanmate) && IS_SET(clanmate->mhs, MHS_LISTEN) )
                 send_to_char("[{gWarlock{x] A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);

                if ( clanmate->clan == clan_lookup("warlock") && !IS_IMMORTAL(clanmate) ) 
                  send_to_char("A guard {Gclans{x 'Help!  We are under attack!'\n\r"
                    ,clanmate);   
            }
        }
        return TRUE;
    }
    else
        return FALSE;
}




bool spec_rabbit( CHAR_DATA *ch)
{
	CHAR_DATA *vch;
	char buf[MAX_STRING_LENGTH];
	char social[MAX_STRING_LENGTH];
	int cmd;
    
    if (!IS_AWAKE(ch) || ch->in_room == NULL ||  IS_AFFECTED(ch,AFF_CHARM) 
        || ch->fighting != NULL)
        return FALSE;

    /* Find someone asleep to annoy */
    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
    {
	if (ch == vch )
	continue;

	if ( vch != NULL && IS_AWAKE(vch) )
	continue;
    
	/* wake 'em, slap 'em and talk to 'em */

	do_wake( ch, vch->name );
	send_to_char( "\n\r", vch);

	for ( cmd = 0; social_table[cmd].name[0] != '\0'; cmd++ )
	{
	 strcpy(social,"slap");
	 if ( social[0]  == social_table[cmd].name[0]
	     && !str_prefix( social, social_table[cmd].name ) )
	 break;
	}

	act( social_table[cmd].others_found, ch, NULL, vch, TO_NOTVICT ,FALSE);
	act( social_table[cmd].char_found, ch, NULL, vch, TO_CHAR ,FALSE);
	act( social_table[cmd].vict_found, ch, NULL, vch, TO_VICT ,FALSE);

	send_to_char( "\n\r", vch);

	sprintf( buf, "Hey funny bunny!");
	do_say ( ch, buf);
    }
	return TRUE;
}

bool spec_troll_member( CHAR_DATA *ch)
{
    CHAR_DATA *vch, *victim = NULL;
    int count = 0;
    char *message;

    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL 
    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
	return FALSE;
 
    /* find an ogre to beat up */
    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
    {
	if (!IS_NPC(vch) || ch == vch)
	    continue;

	if (vch->pIndexData->vnum == MOB_VNUM_PATROLMAN)
	    return FALSE;

	if (vch->pIndexData->group == GROUP_VNUM_OGRES
	&&  ch->level > vch->level - 2 && !is_safe(ch,vch))
	{
	    if (number_range(0,count) == 0)
		victim = vch;

	    count++;
	}
    }

    if (victim == NULL)
	return FALSE;

    /* say something, then raise hell */
    switch (number_range(0,6))
    {
	default:  message = NULL; 	break;
	case 0:	message = "$n yells 'I've been looking for you, punk!'";
		break;
	case 1: message = "With a scream of rage, $n attacks $N.";
		break;
	case 2: message = 
		"$n says 'What's slimy Ogre trash like you doing around here?'";
		break;
	case 3: message = "$n cracks his knuckles and says 'Do ya feel lucky?'";
		break;
	case 4: message = "$n says 'There's no cops to save you this time!'";
		break;	
	case 5: message = "$n says 'Time to join your brother, spud.'";
		break;
	case 6: message = "$n says 'Let's rock.'";
		break;
    }

    if (message != NULL)
    	act(message,ch,NULL,victim,TO_ALL,FALSE);
    multi_hit( ch, victim, TYPE_UNDEFINED );
    return TRUE;
}

bool spec_ogre_member( CHAR_DATA *ch)
{
    CHAR_DATA *vch, *victim = NULL;
    int count = 0;
    char *message;
 
    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL
    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
        return FALSE;

    /* find an troll to beat up */
    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
    {
        if (!IS_NPC(vch) || ch == vch)
            continue;
 
        if (vch->pIndexData->vnum == MOB_VNUM_PATROLMAN)
            return FALSE;
 
        if (vch->pIndexData->group == GROUP_VNUM_TROLLS
        &&  ch->level > vch->level - 2 && !is_safe(ch,vch))
        {
            if (number_range(0,count) == 0)
                victim = vch;
 
            count++;
        }
    }
 
    if (victim == NULL)
        return FALSE;
 
    /* say something, then raise hell */
    switch (number_range(0,6))
    {
	default: message = NULL;	break;
        case 0: message = "$n yells 'I've been looking for you, punk!'";
                break;
        case 1: message = "With a scream of rage, $n attacks $N.'";
                break;
        case 2: message =
                "$n says 'What's Troll filth like you doing around here?'";
                break;
        case 3: message = "$n cracks his knuckles and says 'Do ya feel lucky?'";
                break;
        case 4: message = "$n says 'There's no cops to save you this time!'";
                break;
        case 5: message = "$n says 'Time to join your brother, spud.'";
                break;
        case 6: message = "$n says 'Let's rock.'";
                break;
    }
 
    if (message != NULL)
    	act(message,ch,NULL,victim,TO_ALL,FALSE);
    multi_hit( ch, victim, TYPE_UNDEFINED );
    return TRUE;
}

bool spec_patrolman(CHAR_DATA *ch)
{
    CHAR_DATA *vch,*victim = NULL;
    OBJ_DATA *obj;
    char *message;
    int count = 0;

    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL
    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
        return FALSE;

    /* look for a fight in the room */
    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
    {
	if (vch == ch)
	    continue;

	if (vch->fighting != NULL)  /* break it up! */
	{
	    if (number_range(0,count) == 0)
	        victim = (vch->level > vch->fighting->level) 
		    ? vch : vch->fighting;
	    count++;
	}
    }

    if (victim == NULL || (IS_NPC(victim) && victim->spec_fun == ch->spec_fun))
	return FALSE;

    if (((obj = get_eq_char(ch,WEAR_NECK_1)) != NULL 
    &&   obj->pIndexData->vnum == OBJ_VNUM_WHISTLE)
    ||  ((obj = get_eq_char(ch,WEAR_NECK_2)) != NULL
    &&   obj->pIndexData->vnum == OBJ_VNUM_WHISTLE))
    {
	act("You blow down hard on $p.",ch,obj,NULL,TO_CHAR,FALSE);
	act("$n blows on $p, ***WHEEEEEEEEEEEET***",ch,obj,NULL,TO_ROOM,FALSE);

    	for ( vch = char_list; vch != NULL; vch = vch->next )
    	{
            if ( vch->in_room == NULL )
            	continue;

            if (vch->in_room != ch->in_room 
	    &&  vch->in_room->area == ch->in_room->area)
            	send_to_char( "You hear a shrill whistling sound.\n\r", vch );
    	}
    }

    switch (number_range(0,6))
    {
	default:	message = NULL;		break;
	case 0:	message = "$n yells 'All roit! All roit! break it up!'";
		break;
	case 1: message = 
		"$n says 'Society's to blame, but what's a bloke to do?'";
		break;
	case 2: message = 
		"$n mumbles 'bloody kids will be the death of us all.'";
		break;
	case 3: message = "$n shouts 'Stop that! Stop that!' and attacks.";
		break;
	case 4: message = "$n pulls out his billy and goes to work.";
		break;
	case 5: message = 
		"$n sighs in resignation and proceeds to break up the fight.";
		break;
	case 6: message = "$n says 'Settle down, you hooligans!'";
		break;
    }

    if (message != NULL)
	act(message,ch,NULL,NULL,TO_ALL,FALSE);

    multi_hit(ch,victim,TYPE_UNDEFINED);

    return TRUE;
}
	

bool spec_nasty( CHAR_DATA *ch )
{
    CHAR_DATA *victim, *v_next;
    long gold;
 
    if (!IS_AWAKE(ch)) {
       return FALSE;
    }
 
    if (ch->position != POS_FIGHTING) {
       for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
       {
          v_next = victim->next_in_room;
          if (!IS_NPC(victim)
             && (victim->level > ch->level)
             && (victim->level < ch->level + 10))
          {
	     do_backstab(ch,victim->name);
             if (ch->position != POS_FIGHTING)
                 do_murder(ch,victim->name);
             /* should steal some coins right away? :) */
             return TRUE;
          }
       }
       return FALSE;    /*  No one to attack */
    }
 
    /* okay, we must be fighting.... steal some coins and flee */
    if ( (victim = ch->fighting) == NULL)
        return FALSE;   /* let's be paranoid.... */
 
    switch ( number_bits(2) )
    {
        case 0:  act( "$n rips apart your coin purse, spilling your gold!",
                     ch, NULL, victim, TO_VICT,FALSE);
                 act( "You slash apart $N's coin purse and gather his gold.",
                     ch, NULL, victim, TO_CHAR,FALSE);
                 act( "$N's coin purse is ripped apart!",
                     ch, NULL, victim, TO_NOTVICT,FALSE);
                 gold = victim->gold / 10;  /* steal 10% of his gold */
                 victim->gold -= gold;
                 ch->gold     += gold;
                 return TRUE;
 
        case 1:  do_flee( ch, "");
                 return TRUE;
 
        default: return FALSE;
    }
}

/*
 * Core procedure for dragons.
 */
bool dragon( CHAR_DATA *ch, char *spell_name )
{
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    int sn;

    if ( ch->position != POS_FIGHTING 
	|| (ch->daze > 0 && number_percent() > (ch->level*3)/2))
	return FALSE;

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;
	if ( victim->fighting == ch && number_bits( 3 ) == 0 )
	    break;
    }

    if ( victim == NULL )
	return FALSE;

    if ( ( sn = skill_lookup( spell_name ) ) < 0 )
	return FALSE;
    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TARGET_CHAR);
    return TRUE;
}



/*
 * Special procedures for mobiles.
 */
bool spec_breath_any( CHAR_DATA *ch )
{
    if ( ch->position != POS_FIGHTING )
	return FALSE;

    switch ( number_bits( 3 ) )
    {
    case 0: return spec_breath_fire		( ch );
    case 1:
    case 2: return spec_breath_lightning	( ch );
    case 3: return spec_breath_gas		( ch );
    case 4: return spec_breath_acid		( ch );
    case 5:
    case 6:
    case 7: return spec_breath_frost		( ch );
    }

    return FALSE;
}



bool spec_breath_acid( CHAR_DATA *ch )
{
    return dragon( ch, "acid breath" );
}



bool spec_breath_fire( CHAR_DATA *ch )
{
    return dragon( ch, "fire breath" );
}



bool spec_breath_frost( CHAR_DATA *ch )
{
    return dragon( ch, "frost breath" );
}



bool spec_breath_gas( CHAR_DATA *ch )
{
    int sn;

    if ( ch->position != POS_FIGHTING )
	return FALSE;

    if ( ( sn = skill_lookup( "gas breath" ) ) < 0 )
	return FALSE;
    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, NULL,TARGET_CHAR);
    return TRUE;
}



bool spec_breath_lightning( CHAR_DATA *ch )
{
    return dragon( ch, "lightning breath" );
}



bool spec_cast_adept( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    CHAR_DATA *v_next;

    if ( !IS_AWAKE(ch) )
	return FALSE;

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;
	if ( victim != ch && can_see( ch, victim, FALSE ) 
	     && number_bits( 1 ) == 0 
	     && !IS_NPC(victim) && victim->level < 11)
	    break;
    }

    if ( victim == NULL )
	return FALSE;

    switch ( number_bits( 4 ) )
    {
    case 0:
	act( "$n utters the word 'abrazak'.", ch, NULL, NULL, TO_ROOM ,FALSE);
	spell_armor( skill_lookup( "armor" ), ch->level,ch,victim,TARGET_CHAR);
	return TRUE;

    case 1:
	act( "$n utters the word 'fido'.", ch, NULL, NULL, TO_ROOM ,FALSE);
	spell_bless( skill_lookup( "bless" ), ch->level,ch,victim,TARGET_CHAR);
	return TRUE;

    case 2:
	act("$n utters the words 'judicandus noselacri'.",ch,NULL,NULL,TO_ROOM,FALSE);
	spell_cure_blindness( skill_lookup( "cure blindness" ),
	    ch->level, ch, victim,TARGET_CHAR);
	return TRUE;

    case 3:
	act("$n utters the words 'judicandus dies'.", ch,NULL, NULL, TO_ROOM ,FALSE);
	spell_cure_light( skill_lookup( "cure light" ),
	    ch->level, ch, victim,TARGET_CHAR);
	return TRUE;

    case 4:
	act( "$n utters the words 'judicandus sausabru'.",ch,NULL,NULL,TO_ROOM,FALSE);
	spell_cure_poison( skill_lookup( "cure poison" ),
	    ch->level, ch, victim,TARGET_CHAR);
	return TRUE;

    case 5:
	act("$n utters the word 'candusima'.", ch, NULL, NULL, TO_ROOM ,FALSE);
	spell_refresh( skill_lookup("refresh"),ch->level,ch,victim,TARGET_CHAR);
	return TRUE;

    case 6:
	act("$n utters the words 'judicandus eugzagz'.",ch,NULL,NULL,TO_ROOM,FALSE);
	spell_cure_disease(skill_lookup("cure disease"),
	    ch->level,ch,victim,TARGET_CHAR);
	return TRUE;

    case 7:
	act("$n utters the words 'yummy tummy'.",ch,NULL,NULL,TO_ROOM,FALSE);
	spell_feast(skill_lookup("feast"),
		ch->level,ch,victim,TARGET_CHAR);
	return TRUE;
    }

    return FALSE;
}



bool spec_cast_cleric( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    char *spell;
    int sn;

    if ( ch->position != POS_FIGHTING 
	|| (ch->daze > 0 && number_percent() > (ch->level*3)/2))
	return FALSE;

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;
	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
	    break;
    }

    if ( victim == NULL )
	return FALSE;

    for ( ;; )
    {
	int min_level;

	switch ( number_bits( 4 ) )
	{
	case  0: min_level =  0; spell = "blindness";      break;
	case  1: min_level =  3; spell = "cause serious";  break;
	case  2: min_level =  7; spell = "earthquake";     break;
	case  3: min_level =  9; spell = "cause critical"; break;
	case  4: min_level = 10; spell = "dispel evil";    break;
	case  5: min_level = 12; spell = "curse";          break;
	case  6: min_level = 12; spell = "change sex";     break;
	case  7: min_level = 13; spell = "flamestrike";    break;
	case  8: min_level = 14; spell = "turn undead";    break;
	case  9:
	case 10: min_level = 15; spell = "harm";           break;
	case 11: min_level = 15; spell = "plague";	   break;
	default: min_level = 16; spell = "dispel magic";   break;
	}

	if ( ch->level >= min_level )
	    break;
    }

    if ( ( sn = skill_lookup( spell ) ) < 0 )
	return FALSE;
    if (is_affected(victim, skill_lookup("orb of turning"))) 
    {
        send_to_char("Your spell encounters an orb of turning.\n\r",ch);
        blow_orb(victim,skill_lookup("orb of turning"));
        return FALSE;
    }
    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);

    return TRUE;
    
}

bool spec_cast_judge( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    char *spell;
    int sn;
 
    if ( ch->position != POS_FIGHTING 
	|| (ch->daze > 0 && number_percent() > (ch->level*3)/2))
        return FALSE;
 
    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
        v_next = victim->next_in_room;
        if ( victim->fighting == ch && number_bits( 2 ) == 0 )
            break;
    }
 
    if ( victim == NULL )
        return FALSE;
 
    spell = "high explosive";
    if ( ( sn = skill_lookup( spell ) ) < 0 )
        return FALSE;
    if (is_affected(victim, skill_lookup("orb of turning"))) 
    {
        send_to_char("Your spell encounters an orb of turning.\n\r",ch);
        blow_orb(victim,skill_lookup("orb of turning"));
        return FALSE;
    }
    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
    return TRUE;
}

bool spec_cast_dispel( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    int sn;

    if ( ch->position != POS_FIGHTING 
	|| (ch->daze > 0 && number_percent() > (ch->level*3)/2))
        return FALSE;

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
        v_next = victim->next_in_room;
        if ( victim->fighting == ch && number_bits( 2 ) == 0 )
            break;
    }

    if ( victim == NULL )
        return FALSE;

    if ( ( sn = skill_lookup( "dispel magic" ) ) < 0 )
        return FALSE;
    if (is_affected(victim, skill_lookup("orb of turning"))) 
    {
        send_to_char("Your spell encounters an orb of turning.\n\r",ch);
        blow_orb(victim,skill_lookup("orb of turning"));
        return FALSE;
    }
    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
    return TRUE;
}

/* Special for night mobs in Altirin */
bool spec_altirin_undead( CHAR_DATA *ch )
{
    CHAR_DATA *rch;

    if ( ch->fighting != NULL )
    	return FALSE;

    
    /* always make sure they stay wizi unless somebody is in the room */

   /* They are only active at night, so only run this loop if its night time */
   if ( time_info.hour < 6 || time_info.hour > 19 )
    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
    {
	if ( IS_NPC(rch) || rch == ch || IS_IMMORTAL(rch) )
		continue;

	if ( ch->invis_level )
	{
	   ch->invis_level = 0;
	   act("The air before you shimmers as $n fades into existance.",
		ch, NULL, NULL, TO_ROOM,FALSE);
	   return TRUE;
	}
	else
	{ /* undead already went vis, which means somebody is here attack! */
	    act("$n shifts and phases briefly.",ch,NULL,NULL,TO_ROOM,FALSE);
	    multi_hit( ch, rch, 0 );
	    return TRUE;
	}
    }

    /* Out here?  Means we didn't see anybody.  Go invis */
    if ( ch->invis_level )
	return FALSE;

 act("The air shimmers, and then $n fades away.",ch, NULL, NULL, TO_ROOM,FALSE);
    ch->invis_level = 53;
    return TRUE;
}

/* Follow a player around and try to sell them stuff */
bool spec_salesman( CHAR_DATA *ch )
{
  CHAR_DATA *vch;
 
  /* see if we're already following someone and they're in the room */
  if ( ch->master != NULL && (vch = get_char_room(ch,ch->master->name))!=NULL )
  {
    OBJ_DATA *obj,*sobj;

    /* anything to sell? */
    if( (sobj = ch->carrying) == NULL)
    {
      stop_follower(ch);
      return FALSE;
    }

    /* Can't have them sleeping through our sales pitch. */
    if(!IS_AWAKE(vch))
    {
      do_wake( ch, vch->name );
      do_say(ch,"Now's no time to sleep!");
      send_to_char( "\n\r", vch);
    }

    /* anything better to sell? */
    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
    {
      if( obj->cost > sobj->cost )
	sobj = obj;
    }

    switch( dice(1,30) )
    {
      case 3: act("$N inquires, 'Would you like to buy $p?'",vch,sobj,ch,
		TO_CHAR ,FALSE);
      act("$N inquires of $n, 'Would you like to buy $p?'",vch,sobj,ch,
	  TO_ROOM ,FALSE);
	      break;
      case 9: do_say(ch,ch->pIndexData->spec_words[1]); break;
      case 21: act("$n's face wells up with tears.\n\rShaking $s head from side to side and staring at $p in disbelief...",ch,sobj,NULL,TO_ROOM,FALSE);
      do_say(ch,"It's such a great deal, why won't they buy it?"); break;
      case 14: do_say(ch,ch->pIndexData->spec_words[2]); break;
      case 15: do_say(ch,"Come on, I got a wife and kids to feed."); break;
      case 26: act("$N points to $p.\n\r$N says, 'This is the finest $p in Boinga.  I'll give you a fabulous deal on it.'",vch,sobj,ch,TO_CHAR,FALSE);
      act("$n points to $p.",ch,sobj,vch,TO_NOTVICT,FALSE);
	      break;
      default: break;
    }
    
    return TRUE;
  }
    
  /* find a new victim */
  if( ch->carrying != NULL )
  {
    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
    {
        if (!IS_NPC(vch))
        {
	  stop_follower(ch);
  	  add_follower(ch, vch);
	  do_say(ch,ch->pIndexData->spec_words[0]);
	  return TRUE;
        }
     } 
  }

  return FALSE;
}

bool spec_average( CHAR_DATA *ch )
{
    CHAR_DATA *victim;

    if (!IS_AWAKE(ch))
	return FALSE;
    check_equip( ch );

    switch(dice(1,50))
    {
      case 2: do_say(ch,ch->pIndexData->spec_words[2]); return TRUE;
      case 14: do_say(ch,ch->pIndexData->spec_words[0]); return TRUE;
      case 36: do_say(ch,ch->pIndexData->spec_words[1]); return TRUE;
      default: break;
    }

    if ( ( victim = ch->fighting ) == NULL )
    {
      /* lets see if someone who just attacked us is in the room */
      if( ch->lAb != NULL  && ch->hit > ch->max_hit/4 )
      {
	if((victim=get_char_room(ch,ch->lAb->name)) != NULL )
	{
	  do_say(ch,"Hey!  I know you!");
	  one_hit(ch,victim,TYPE_UNDEFINED );
	  return TRUE;
	}
      }
    }
    else
    {
      if(!IS_NPC(victim))
      {
	ch->lAb = victim;
	return TRUE;
      }
      else
      {
	if(victim->master != NULL && !IS_NPC(victim->master))
	{
	  ch->lAb = victim->master;
	  return TRUE;
	}
      }
    }

    return FALSE;
}

bool spec_jabber( CHAR_DATA *ch )
{
    CHAR_DATA *victim;

    if (!IS_AWAKE(ch))
        return FALSE;

    switch(dice(1,20))
    {
      case 2: do_say(ch,ch->pIndexData->spec_words[2]); return TRUE;
      case 10: do_say(ch,ch->pIndexData->spec_words[0]); return TRUE;
      case 18: do_say(ch,ch->pIndexData->spec_words[1]); return TRUE;
      default: break;
    }

    if ( ( victim = ch->fighting ) == NULL )
    {
      /* lets see if someone who just attacked us is in the room */
      if( ch->lAb != NULL  && ch->hit > ch->max_hit/4 )
      {
        if((victim=get_char_room(ch,ch->lAb->name)) != NULL )
        {
          do_say(ch,"Big meanie, go pick on someone your own size!");
          one_hit(ch,victim,TYPE_UNDEFINED );
          return TRUE;
        }
      }
    }
    else
    {
      if(!IS_NPC(victim))
      {
        ch->lAb = victim;
        return TRUE;
      }
      else
      {
        if(victim->master != NULL && !IS_NPC(victim->master))
        {
          ch->lAb = victim->master;
          return TRUE;
        }
      }
    }

    return FALSE;
}


bool spec_monk( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    char *spell="";
    int sn;
    int target = 0;
  
    check_equip( ch );
 
    /* It just got harder! Monk has supa regen */
    /* ch->hit = UMIN(ch->hit+200,ch->max_hit);
     * Lets try about 1/4 of that.  No one has been able to kill him
     * when he regens 800HP a round.
     */
    ch->hit = UMIN(ch->hit+50,ch->max_hit);

    if ( ( victim = ch->fighting ) == NULL )
	return FALSE;

    /* don't bother re-sanc'ing or re-haste'ing if our HP are low */
    if ( ch->hit < ( ch->max_hit / 4 ) )
    {
        spell = "heal";
        target = 1; /* True, mob is casting on itself */
    }
    else
    /* Always restore sanc first.  Ditto haste */
    if ( !IS_AFFECTED(ch,AFF_SANCTUARY) )
    {
	spell = "sanctuary";
	target = 1;
    }
    else
    if ( !IS_AFFECTED(ch,AFF_HASTE) )
    {
	spell = "haste";
	target = 1;
    }

    if ( target )
      {
        sn = skill_lookup(spell);
        (*skill_table[sn].spell_fun) ( sn, ch->level, ch, ch, TARGET_CHAR);
        return TRUE;
      }

    /* Ok we've taken care of ourselves, lets pound them */
    if ( is_affected(victim,gsn_sanctuary) )
        spell = "dispel magic";
    else
    if ( victim->hit > victim->max_hit / 2 )
    {
	do_backstab(ch,"");
	return TRUE;
    }
    else /* Just for our remorts */
    if ( IS_SET(victim->act,PLR_VAMP) && !IS_NPC(victim) &&
	 victim->pcdata->condition[COND_FULL] < 46 )
	spell = "feast";
    else
    if ( victim->mana > ( victim->max_mana / 8 ) &&
	!IS_NPC(victim) && class_table[victim->class].fMana )
	spell = "energy drain";
    else
    if ( IS_NPC(victim) && victim->pIndexData->vnum == MOB_VNUM_SKEL_WAR )
      {
	spell = "turn undead";
        do_say(ch,ch->pIndexData->spec_words[0]);
      }
    else
    {  /* Maladictions! */
	switch ( dice(2,6) )
	{
	case 2 :  spell = "turn undead";	break;
	case 3 :  spell = "slow";		break;
	case 4 :  spell = "poison";		break;
	case 5 :  spell = "blindness";		break;
	case 6 :  spell = "weaken";		break;
	case 7 :  spell = "curse";      	break;
	case 8 :  spell = "plague";     	break;
	case 9 :  spell = "irradiate";		break;
	case 10 :  spell = "chain lightning";	break;
	case 11:  spell = "enervation";		break;
	case 12:  spell = "irradiate";		break;
 	default :	return FALSE;
	};
    }

    if ( ( sn = skill_lookup(spell) ) < 0 )
	sn = skill_lookup("ice storm");

    if ( !target && is_affected(victim,sn) )
	sn = skill_lookup("acid blast");

    if ( sn < 0 ) /* last minute sanity check */
    {
	do_bash(ch,"");
	return TRUE;
    }

    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TARGET_CHAR);
    return TRUE;
}


bool spec_cast_mage( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    char *spell;
    int sn;

    if ( ch->position != POS_FIGHTING 
	|| (ch->daze > 0 && number_percent() > (ch->level*3)/2))
	return FALSE;

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;
	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
	    break;
    }

    if ( victim == NULL )
	return FALSE;

    for ( ;; )
    {
	int min_level;

	switch ( number_bits( 4 ) )
	{
	case  0: min_level =  0; spell = "blindness";      break;
	case  1: min_level =  3; spell = "chill touch";    break;
	case  2: min_level =  7; spell = "weaken";         break;
	case  3: min_level =  8; spell = "teleport";       break;
	case  4: min_level = 11; spell = "colour spray";   break;
	case  5: min_level = 12; spell = "change sex";     break;
	case  6: min_level = 13; spell = "energy drain";   break;
	case  7:
	case  8:
	case  9: min_level = 15; spell = "fireball";       break;
	case 10: min_level = 20; spell = "plague";	   break;
	default: min_level = 20; spell = "acid blast";     break;
	}

	if ( ch->level >= min_level )
	    break;
    }

    if ( ( sn = skill_lookup( spell ) ) < 0 )
	return FALSE;
    if (is_affected(victim, skill_lookup("orb of turning"))) 
    {
        send_to_char("Your spell encounters an orb of turning.\n\r",ch);
        blow_orb(victim,skill_lookup("orb of turning"));
        return FALSE;
    }
    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
    return TRUE;
}



bool spec_cast_undead( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    char *spell;
    int sn;

    if ( ch->position != POS_FIGHTING 
	|| (ch->daze > 0 && number_percent() > (ch->level*3)/2))
	return FALSE;

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;
	if ( victim->fighting == ch && number_bits( 2 ) == 0 )
	    break;
    }

    if ( victim == NULL )
	return FALSE;

    for ( ;; )
    {
	int min_level;

	switch ( number_bits( 4 ) )
	{
	case  0: min_level =  0; spell = "curse";          break;
	case  1: min_level =  3; spell = "weaken";         break;
	case  2: min_level =  6; spell = "chill touch";    break;
	case  3: min_level =  9; spell = "blindness";      break;
	case  4: min_level = 12; spell = "poison";         break;
	case  5: min_level = 15; spell = "energy drain";   break;
	case  6: min_level = 18; spell = "harm";           break;
	case  7: min_level = 21; spell = "teleport";       break;
	case  8: min_level = 20; spell = "plague";	   break;
	default: min_level = 18; spell = "harm";           break;
	}

	if ( ch->level >= min_level )
	    break;
    }

    if ( ( sn = skill_lookup( spell ) ) < 0 )
	return FALSE;
    if (is_affected(victim, skill_lookup("orb of turning"))) 
    {
        send_to_char("Your spell encounters an orb of turning.\n\r",ch);
        blow_orb(victim,skill_lookup("orb of turning"));
        return FALSE;
    }
    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
    return TRUE;
}

/* returns true if this person is part of the
clan which won the war    */
bool clanwar_winner( CHAR_DATA *ch)
{
    
    int clanwinner; /* clan war winner */

    /* every clan war set this name to the winning clan
       set it to an unused clan name if not running clan wars */

    clanwinner = clan_lookup("valor");

    if (ch->clan == clanwinner)
    {
      return TRUE;
    }

    return FALSE;

}


bool spec_executioner( CHAR_DATA *ch )
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    char *crime;

    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
	return FALSE;

    crime = "";
    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;

	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) && !clanwar_winner(victim) )
	    { crime = "KILLER"; break; }

	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) && !clanwar_winner(victim) )
	    { crime = "THIEF"; break; }
   
	if ( !IS_NPC(victim) && IS_SET(victim->wiznet, PLR_RUFFIAN) && number_percent() < 10 )
	    { do_say( ch, "SETTLE DOWN!" ); return TRUE; }
    }

    if ( victim == NULL )
	return FALSE;

    if (ch->position < POS_STANDING)
       do_stand(ch,"");

    sprintf( buf, "%s is a %s!  PROTECT THE INNOCENT!  MORE BLOOOOD!!!",
	victim->name, crime );
    REMOVE_BIT(ch->comm,COMM_NOSHOUT);
    do_yell( ch, buf );
    multi_hit( ch, victim, TYPE_UNDEFINED );
    return TRUE;
}

bool spec_phoenix( CHAR_DATA *ch )
{
    if ( ch->fighting != NULL ) 
	return TRUE;

    if ( number_percent() < 25 )
    {
	int sn;

	/* Teleport */
	if ( ( sn = skill_lookup( "teleport" ) ) < 0 )
                return FALSE;
    
        (*skill_table[sn].spell_fun) ( sn, 50, ch, ch, TARGET_CHAR );
    }
    else
    if ( number_percent() * number_percent() <= 5 )
    {
	/* Despawn */
	act("$n fades away to the outer planes.",ch,NULL,NULL,TO_ROOM,FALSE);
        extract_char(ch,TRUE);
    }

	return TRUE;
}

/* A procedure for Puff the Fractal Dragon--> it gives her an attitude.
	Note that though this procedure may make Puff look busy, she in
	fact does nothing quite more often than she did in Merc 1.0;
	due to null victim traps, my own do-nothing options, and various ways
	to return without doing much, Puff is... well, not as BAD of a gadfly
	as she may look, I assure you.  But I think she's fun this way ;)

	(btw--- should you ever want to test out your socials, just tweak
	the percentage table ('silliness') to make her do lots of socials,
	and then go to a quiet room and load up about thirty Puffs... ;) 
			
		written by Seth of Rivers of Mud         */

/* important constant :) */

#define MAXPUFF 15
bool spec_puff( CHAR_DATA *ch )
{
   char buf[MAX_STRING_LENGTH];
   int rnd_social, sn, silliness;
   int count = 0;
   CHAR_DATA *victim = NULL;
   CHAR_DATA *vch;
   CHAR_DATA *v_next;
   extern int social_count;
 
   if ( ch->position == POS_FIGHTING)
   {
   for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
      v_next = victim->next_in_room;
      if ( victim->fighting == ch && number_bits( 2 ) == 0 )
           break;
    }
 
    if ( victim == NULL )
                return FALSE;
 
    if ( ( sn = skill_lookup( "teleport" ) ) < 0 )
                return FALSE;
    (*skill_table[sn].spell_fun) ( sn, 50, ch, victim, TARGET_CHAR );
        return TRUE;
 
    }
 
   if (number_percent() <= 50)     /* Easy way to change Puff's hyperness. */
      return TRUE;
 
   rnd_social = (number_range (0, ( social_count - 1)) );
 
   /* Choose some manner of silliness to perpetrate.  */
 
   silliness = number_range(1, 100);
 
   if ( silliness <= 17)
      {
      act( social_table[rnd_social].others_auto, ch, NULL, ch, TO_ROOM ,FALSE);
      act( social_table[rnd_social].char_auto,   ch, NULL, ch, TO_CHAR ,FALSE);
      }
   else if ( silliness <= 23)
      {
      sprintf( buf, "Tongue-tied and twisted, just an earthbound misfit, ...");
      do_say ( ch, buf);
      }
      else if ( silliness <= 30)
      {
       sprintf( buf, "The colors, the colors!");
      do_say ( ch, buf);
      }
      else if ( silliness <= 40)
      {
      sprintf( buf, "Did you know that I'm written in C?");
      do_say ( ch, buf);
      }
      else if ( silliness <= 55)
      {
   act( social_table[rnd_social].others_no_arg, ch, NULL, NULL, TO_ROOM ,FALSE);
   act( social_table[rnd_social].char_no_arg, ch, NULL, NULL, TO_CHAR ,FALSE);
      }
      else if ( silliness <= 88)
      {
 
      /*
        *  Grab a random person in the room with Puff.
       */
 
      for ( vch = ch->in_room->people; vch != NULL; vch = v_next )
         {
         v_next = vch->next_in_room;
 
         if ( number_range( 0, count ) == 0 )
         victim = vch;
         count++;
         }
 
         if ( victim == NULL
          ||   victim == ch)
         return FALSE;
 
         act( social_table[rnd_social].others_found, ch,
                  NULL, victim, TO_NOTVICT ,FALSE);
         act( social_table[rnd_social].char_found, ch,
                  NULL, victim, TO_CHAR    ,FALSE);
         act( social_table[rnd_social].vict_found, ch,
                  NULL, victim, TO_VICT    ,FALSE);
         }
 
        else if ( silliness <= 93)
            {
            act( "For a moment, $n flickers and phases.", ch,
                        NULL, NULL, TO_ROOM ,FALSE);
            act( "For a moment, you flicker and phase.", ch,
                        NULL, NULL, TO_CHAR ,FALSE);
            }
        else if ( silliness <= 94)
            {
            if (ch->pIndexData->count < 2)
            return FALSE;
 
                act( "The Operator kills $n's job!", ch,
                NULL, NULL, TO_ROOM,FALSE);
                act( "  $n howls in anguish, and unravels!", ch,
                NULL, NULL, TO_ROOM,FALSE);
                act( "The Operator kills your job!  You unravel!", ch,
                NULL, NULL, TO_CHAR,FALSE);
                extract_char( ch, TRUE);
                }
        else if ( silliness <= 95)
        {
        if (ch->pIndexData->count >= MAXPUFF)
                return FALSE;
 
        act( "$n pushes $s stack frame, and clones $mself!", ch,
                NULL, NULL, TO_ROOM,FALSE);
        act( "You clone yourself!", ch, NULL, NULL, TO_CHAR,FALSE);
        char_to_room( create_mobile(ch->pIndexData), ch->in_room );
        }
 
/* The Fractal Dragon sometimes teleports herself around, to check out
 * new and stranger things. If you're playing Puff and
 * you want to talk with someone, just rest or sit!
 */
 
        else
              {
              if (ch->position < POS_STANDING)
              {
         act( "For a moment, $n seems lucid...", ch,
                NULL, NULL, TO_ROOM ,FALSE);
        act( "   ...but then $e returns to $s contemplations once again.", ch,
                NULL, NULL, TO_ROOM ,FALSE);
        act( "For a moment, the world's mathematical beauty is lost to you!",
                ch, NULL, NULL, TO_CHAR ,FALSE);
        act( "   ...but joy! yet another novel phenomenon seizes your
                attention.", ch, NULL, NULL, TO_CHAR,FALSE);
	return TRUE;
              }
 
              if ( ( sn = skill_lookup( "teleport" ) ) < 0 )
                return FALSE;
              (*skill_table[sn].spell_fun) (sn,ch->level,ch,ch,TARGET_CHAR);
 
        }
 
        return TRUE;
}
			

bool spec_fido( CHAR_DATA *ch )
{
    OBJ_DATA *corpse;
    OBJ_DATA *c_next;
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;

    if ( !IS_AWAKE(ch) )
	return FALSE;

    for ( corpse = ch->in_room->contents; corpse != NULL; corpse = c_next )
    {
	c_next = corpse->next_content;
	if ( corpse->item_type != ITEM_CORPSE_NPC )
	    continue;

	act( "$n savagely devours a corpse.", ch, NULL, NULL, TO_ROOM ,FALSE);
	for ( obj = corpse->contains; obj; obj = obj_next )
	{
	    obj_next = obj->next_content;
	    obj_from_obj( obj );
	    obj_to_room( obj, ch->in_room );
	}
	extract_obj( corpse );
	return TRUE;
    }

    return FALSE;
}



bool spec_guard_d( CHAR_DATA *ch )
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    CHAR_DATA *ech;
    char *crime;
    int max_evil;
    int connive_check;
    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
	return FALSE;

    max_evil = 300;
    ech      = NULL;
    crime    = "";

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;

	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) && !clanwar_winner(victim) && !IS_SET(victim->mhs,MHS_HIGHLANDER) )
	    { crime = "KILLER"; break; }

	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) && !clanwar_winner(victim)  && !IS_SET(victim->mhs,MHS_HIGHLANDER))
	    { crime = "THIEF"; break; }

	if ( victim->fighting != NULL
	&&   victim->fighting != ch
	&&   victim->alignment < max_evil )
	{
	    max_evil = victim->alignment;
	    ech      = victim;
	}
    }


    if ( victim != NULL )
    {
    if (victim->kit== kit_lookup("fence"))
    {
        connive_check = number_percent();
        if(!IS_NPC(victim) && connive_check < get_curr_stat(victim,STAT_SOC)*2)
        {
                sprintf(buf, "%s you are tooo cool.",victim->name);
                do_say(ch,buf);
                return FALSE;
        }
    }

        if (ch->position < POS_STANDING)
           do_stand(ch,"");

	sprintf( buf, "%s is a %s!  PROTECT THE INNOCENT!!  BANZAI!!",
	    victim->name, crime );
 	REMOVE_BIT(ch->comm,COMM_NOSHOUT);
	do_yell( ch, buf );
	multi_hit( ch, victim, TYPE_UNDEFINED );
	return TRUE;
    }

    if ( ech != NULL )
    {
        if (ch->position < POS_STANDING)
           do_stand(ch,"");

	act( "$n screams 'PROTECT THE INNOCENT!!  BANZAI!!",
	    ch, NULL, NULL, TO_ROOM ,FALSE);
	multi_hit( ch, ech, TYPE_UNDEFINED );
	return TRUE;
    }

    return FALSE;
}


bool spec_guard_l( CHAR_DATA *ch )
{
    char buf[MAX_STRING_LENGTH];
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    CHAR_DATA *ech;
    char *crime;
    int max_evil;

    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
	return FALSE;

    max_evil = 300;
    ech      = NULL;
    crime    = "";

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;

	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) && !clanwar_winner(victim) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
	    { crime = "KILLER"; break; }

	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) && !clanwar_winner(victim) && !IS_SET(victim->mhs,MHS_HIGHLANDER))
	    { crime = "THIEF"; break; }

	if ( victim->fighting != NULL
	&&   victim->fighting != ch
	&&   victim->alignment < max_evil )
	{
	    max_evil = victim->alignment;
	    ech      = victim;
	}
    }

    if ( victim != NULL )
    {
        if (ch->position < POS_STANDING)
           do_stand(ch,"");

	sprintf( buf, "%s is a %s!  PROTECT THE INNOCENT!!  BANZAI!!",
	    victim->name, crime );
 	REMOVE_BIT(ch->comm,COMM_NOSHOUT);
	do_yell( ch, buf );
	multi_hit( ch, victim, TYPE_UNDEFINED );
	return TRUE;
    }

    if ( ech != NULL )
    {
        if (ch->position < POS_STANDING)
           do_stand(ch,"");

	act( "$n screams 'PROTECT THE INNOCENT!!  BANZAI!!",
	    ch, NULL, NULL, TO_ROOM ,FALSE);
	multi_hit( ch, ech, TYPE_UNDEFINED );
	return TRUE;
    }

    return FALSE;
}

bool spec_janitor( CHAR_DATA *ch )
{
    OBJ_DATA *trash;
    OBJ_DATA *trash_next;

    if ( !IS_AWAKE(ch) )
	return FALSE;

    for ( trash = ch->in_room->contents; trash != NULL; trash = trash_next )
    {
	trash_next = trash->next_content;
	if ( !IS_SET(trash->wear_flags,ITEM_TAKE) || !can_loot(ch,trash,TRUE))
	    continue;
	if ( trash->item_type == ITEM_DRINK_CON
	||   trash->item_type == ITEM_TRASH
	||   trash->cost < 10 )
	{
	    act( "$n picks up some trash.", ch, NULL, NULL, TO_ROOM ,FALSE);
	    obj_from_room( trash );
	    obj_to_char( trash, ch );
	    return TRUE;
	}
    }

    return FALSE;
}



bool spec_mayor( CHAR_DATA *ch )
{
    static const char open_path[] =
	"W3a3003b33000c111d0d111Oe333333Oe22c222112212111a1S.";

    static const char close_path[] =
	"W3a3003b33000c111d0d111CE333333CE22c222112212111a1S.";

    static const char *path;
    static int pos;
    static bool move;

    if ( !move )
    {
	if ( time_info.hour ==  6 )
	{
	    path = open_path;
	    move = TRUE;
	    pos  = 0;
	}

	if ( time_info.hour == 20 )
	{
	    path = close_path;
	    move = TRUE;
	    pos  = 0;
	}
    }

    if ( ch->fighting != NULL )
	return spec_cast_mage( ch );
    if ( !move || ch->position < POS_SLEEPING )
	return FALSE;

    switch ( path[pos] )
    {
    case '0':
    case '1':
    case '2':
    case '3':
	move_char( ch, path[pos] - '0', FALSE );
	break;

    case 'W':
	ch->position = POS_STANDING;
	act( "$n awakens and groans loudly.", ch, NULL, NULL, TO_ROOM ,FALSE);
	break;

    case 'S':
	ch->position = POS_SLEEPING;
	act( "$n lies down and falls asleep.", ch, NULL, NULL, TO_ROOM ,FALSE);
	break;

    case 'a':
	act( "$n says 'Hello Honey!'", ch, NULL, NULL, TO_ROOM ,FALSE);
	break;

    case 'b':
	act( "$n says 'What a view!  I must do something about that dump!'",
	    ch, NULL, NULL, TO_ROOM ,FALSE);
	break;

    case 'c':
	act( "$n says 'Vandals!  Youngsters have no respect for anything!'",
	    ch, NULL, NULL, TO_ROOM ,FALSE);
	break;

    case 'd':
	act( "$n says 'Good day, citizens! Re-Elect me for Mayor!'", ch, NULL, NULL, TO_ROOM ,FALSE);
	break;

    case 'e':
/*	act( "$n says 'I hereby declare the city of Midgaard open!'",
	    ch, NULL, NULL, TO_ROOM ,FALSE);
	    */
	act("$n says 'I'm glad I left the city gates open, one less thing to do!'",ch,NULL,NULL,TO_ROOM,FALSE);
	break;

    case 'E':
/*	act( "$n says 'I hereby declare the city of Midgaard closed!'",
	    ch, NULL, NULL, TO_ROOM ,FALSE);
	    */
	act("$n says 'I hereby declare the city ... bah I'm too tired to close the gates!'",ch,NULL,NULL,TO_ROOM,FALSE);
	break;

    case 'O':
/*	do_unlock( ch, "gate" ); */
/*	do_open( ch, "gate" ); */
	break;

    case 'C':
/*	do_close( ch, "gate" ); */
/*	do_lock( ch, "gate" ); */
	break;

    case '.' :
	move = FALSE;
	break;
    }

    pos++;
    return FALSE;
}



bool spec_poison( CHAR_DATA *ch )
{
    CHAR_DATA *victim;

    if ( ch->position != POS_FIGHTING
    || ( victim = ch->fighting ) == NULL
    ||   number_percent( ) > 2 * ch->level )
	return FALSE;

    act( "You bite $N!",  ch, NULL, victim, TO_CHAR    ,FALSE);
    act( "$n bites $N!",  ch, NULL, victim, TO_NOTVICT ,FALSE);
    act( "$n bites you!", ch, NULL, victim, TO_VICT    ,FALSE);
    spell_poison( gsn_poison, ch->level, ch, victim,TARGET_CHAR);
    return TRUE;
}



bool spec_thief( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    CHAR_DATA *v_next;
    long gold,silver;

    if ( ch->position != POS_STANDING )
	return FALSE;

    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
    {
	v_next = victim->next_in_room;

	if ( IS_NPC(victim)
	||   victim->level >= LEVEL_IMMORTAL
	||   number_bits( 5 ) != 0 
	||   !can_see(ch,victim,FALSE))
	    continue;

	if ( IS_AWAKE(victim) && number_range( 0, ch->level ) == 0 )
	{
	    act( "You discover $n's hands in your wallet!",
		ch, NULL, victim, TO_VICT ,FALSE);
	    act( "$N discovers $n's hands in $S wallet!",
		ch, NULL, victim, TO_NOTVICT ,FALSE);
	    return TRUE;
	}
	else
	{
	    gold = victim->gold * UMIN(number_range(1,20),ch->level / 2) / 100;
	    gold = UMIN(gold, ch->level * ch->level * 10 );
	    ch->gold     += gold;
	    victim->gold -= gold;
	    silver = victim->silver * UMIN(number_range(1,20),ch->level/2)/100;
	    silver = UMIN(silver,ch->level*ch->level * 25);
	    ch->silver	+= silver;
	    victim->silver -= silver;
	    return TRUE;
	}
    }

    return FALSE;
}

/* Vhan is a bad-ass acid serpent in the Drachlan Canyon.
 * He guards some whack lewtz and is considered to be immortal.
 * He regens silly amounts of hit points, can kill with 1 hit
 * against NPCs, and being undead himself, can take control of
 * skeletal warriors.
 *
 *  Vhan has two special attacks.  One is a fatal coil attack,
 * and the other is his lethal venom.
 *
 * He doesn't dispel or re-sanc like the monk, but his massive regen
 * capacity makes him formidable anyway.
 */
bool spec_vhan( CHAR_DATA *vhan )
{
    CHAR_DATA *victim;

    /* First, add 250 hp */
    vhan->hit = UMIN(vhan->hit + 250, vhan->max_hit );

    victim = vhan->fighting;
    /* Next, see who we're fighting.  If it's an NPC, kill them */
    if ( victim != NULL && IS_NPC(victim) &&
	 victim->pIndexData->vnum != MOB_VNUM_SKEL_WAR )
    {
	act("$n wraps $s coils around $N and constricts!",vhan,NULL,victim,TO_NOTVICT,FALSE);
	act("$n wraps $s coils around you and constricts!",vhan,NULL,victim,TO_VICT,FALSE);
	act("You wrap your coils around $N and constrict!",vhan,NULL,victim,TO_CHAR,FALSE);
	victim->hit = UMIN(victim->hit,1);
	act("You begin to die.",vhan,NULL,victim,TO_VICT,FALSE);
	return TRUE;
    }
    else if ( victim != NULL )
    {
    /* Ok.  Now!  If we DIDN'T do that, inject them with venom */
	AFFECT_DATA af;
  	int resist_chance, sn;

 	af.where = DAMAGE_OVER_TIME;
	af.type  = sn = skill_lookup("venom of vhan");
	af.level = vhan->level;
 	af.location =	vhan->level * 2;
	af.modifier =	vhan->level * 5;
	af.duration = 18;
	af.bitvector = DAM_POISON;

	resist_chance = victim->level + (get_curr_stat(victim,STAT_CON)*2);
	if ( IS_SET(victim->res_flags,RES_POISON) )
	    resist_chance = 3 * resist_chance / 2;

	if ( IS_SET(victim->imm_flags,IMM_POISON) )
	    resist_chance *= 2;

 	if ( number_percent( ) * 2 > resist_chance && !is_affected(victim,sn) ) /* GOT EM! */
	{
	    affect_to_char(victim,&af);
		act("$n sinks $s teeth into you, injecting deadly venom.",vhan,NULL,victim,TO_VICT,FALSE);
		act("You sink your teeth into $N, injecting deadly venom.",vhan,NULL,victim,TO_CHAR,FALSE);
		act("$n sinks $s teeth into $N, injecting deadly venom.",vhan,NULL,victim,TO_NOTVICT,FALSE);
	    return TRUE;
 	}
    }

    /* Now check for skellies and steal them! */
    for ( victim = vhan->in_room->people ; victim != NULL ; victim = victim->next_in_room )
 	if ( IS_NPC(victim) && victim->pIndexData->vnum == MOB_VNUM_SKEL_WAR &&
		!is_same_group(victim,vhan) )
  	{
	    switch( number_range(1,10) )
	    {
		case 1:
	    do_say(vhan,"Kash'tak vhan.  Your restless soul belongs to me now."); break;
		case 2:
	    do_say(vhan,"The dead walk with Vhan."); break;
		case 3:
	    do_say(vhan,"Turn from the heathen and bow before the Lord of the Dead."); break;
		case 4:
	    do_say(vhan,"Turn your lifeless eyes upon the visage of the Master."); break;
		case 5:
	    do_say(vhan,"From listless sleep you rise and only to follow me."); break;
		case 6:
	    do_say(vhan,"Vhanta neis.  Arise and step into the shadow of Vhan."); break;
		case 7:
	    do_say(vhan,"Turn upon your captors, and fight for your true Master."); break;
		case 8:
	    do_say(vhan,"Slay now those you captured you."); break;
	    	case 9:
	    do_say(vhan,"Your will belongs to me."); break;
		case 10:
	    do_say(vhan,"Dae'tayana.  Vhas'ka braen kalidus."); break;
	    }

	   act("$n shudders and then bows before $N.",victim,NULL,vhan,TO_NOTVICT,FALSE);
	   act("You now follow $N.",victim,NULL,vhan,TO_CHAR,FALSE);
	   act("$n now follows you.",victim,NULL,vhan,TO_VICT,FALSE);

      	   stop_follower( victim );
    	   add_follower( victim, vhan );
    	   victim->leader = vhan;
	   SET_BIT(victim->affected_by,AFF_CHARM);
	
	   if( victim->fighting != NULL )
	       stop_fighting( victim, TRUE );

	   if ( vhan->fighting != NULL )
	       do_rescue(victim,"vhan");

	   return TRUE;
	}

    /* Out here?  Nothing to do at all? */
    if ( vhan->fighting != NULL )
    	do_order(vhan,"all rescue vhan");
    return FALSE;
}

bool spec_drachlan_melee( CHAR_DATA *ch )
{
    CHAR_DATA *victim;
    EXIT_DATA *pExit;
    int i;

    check_equip(ch );
    /* Drachlan regen */
    ch->hit = UMIN(ch->hit+100,ch->max_hit);

    victim = ch->fighting;

    /* First, check for an NPC and drop 'em */
    if ( victim != NULL && IS_NPC(victim) )
    {
	AFFECT_DATA af;

	af.where	= TO_AFFECTS;
	af.type		= skill_lookup("sleep");
   	af.modifier	= 0;
	af.location	= 0;
	af.level	= 0;
	af.duration	= -1;
	af.bitvector	= AFF_SLEEP;
	
	affect_to_char(victim,&af);
	stop_fighting(victim, TRUE);
	victim->position = POS_SLEEPING;
	do_say(ch,"Like your ancestors, you will have eternal sleep.");
	return TRUE;
    }
    else
    if ( victim != NULL ) /* PC */
    {
	int sn;
	int chance;
	AFFECT_DATA af;

	chance = (ch->level * 2) - (get_curr_stat(victim,STAT_DEX)*3);
	sn = skill_lookup("eye gouge");

	if ( !is_affected(victim,sn) && number_percent( ) < chance )
	{
	    af.where 	= TO_AFFECTS;
	    af.level	= ch->level;
	    af.type	= sn;
	    af.duration = -1;
	    af.modifier = -4;
	    af.location = APPLY_HITROLL;
	    af.bitvector = AFF_BLIND;

	    act("$n rakes $s claws across your face and gouges your eyes!",
		ch,NULL,victim,TO_VICT,FALSE);
	    act("You rake your claws across $N's face and gouge $S eyes!",
		ch,NULL,victim,TO_CHAR,FALSE);
	    act("$n takes $s claws across $N's face and gouges $S eyes!",
		ch,NULL,victim,TO_NOTVICT,FALSE);

	    affect_to_char(victim,&af);
	    return TRUE;
	}
	act("$n snarls and claws at your face!",ch,NULL,victim,TO_VICT,FALSE);
	act("You snarl and claw at $N's face!",ch,NULL,victim,TO_CHAR,FALSE);
	act("$n snarls and claws at $N's face!",ch,NULL,victim,TO_NOTVICT,FALSE);
	return FALSE;
    }

    /* Ok, we're not fighting anybody.  Check adjacent rooms for other drachlans
     * who are fighting, and move to help.
     */
    for ( i = 0 ; i < 6 ; i++ )
    {
	pExit = ch->in_room->exit[i];

	if ( pExit == NULL )
	    continue;
	else
	{
	    CHAR_DATA *vch;

	    for ( vch = pExit->u1.to_room->people ; vch != NULL ; vch = vch->next_in_room )
		if ( IS_NPC(vch) && vch->fighting != NULL &&
		     (vch->spec_fun == spec_drachlan_melee || 
		      vch->spec_fun == spec_drachlan_medic ) )
		{ /* If a drachlan NPC is fighting in this room, move in! */
		    move_char( ch, i, FALSE );
		    return TRUE;
		}
	}
    }

    /* check adjucent rooms for PC's to kill */
    for ( i = 0 ; i < 6 ; i++ )
    {
        pExit = ch->in_room->exit[i];

        if ( pExit == NULL )
            continue;
        else
        {
            CHAR_DATA *vch;

            for ( vch = pExit->u1.to_room->people ; vch != NULL ; vch = vch->next_in_room )
                if ( !IS_NPC(vch) && !is_affected(vch,skill_lookup("wraithform")) && can_see(ch,vch,FALSE) )
                { /* A player?  KILL! */
                    move_char( ch, i, FALSE );
                    return TRUE;
                }
        }
    }
    return FALSE ;
}

bool spec_drachlan_medic( CHAR_DATA *ch )
{
    CHAR_DATA *vch;
    int i;
    EXIT_DATA *pExit;


    check_equip(ch);
    /* Drachlan regen */
    ch->hit = UMIN(ch->hit+50,ch->max_hit);

    /* Medics will DOT their attackers and flee */
    if ( ch->fighting != NULL )
    {
	CHAR_DATA *victim = ch->fighting;
	int sn_cold;
	int sn_hot;
	int sn_elec;
 	int use_sn = -1;
	
	sn_cold = skill_lookup("frostbite");
	sn_hot = skill_lookup("blistering skin");
	sn_elec = skill_lookup("electrocution");

	if ( victim->race == race_lookup("dragon") && !is_affected(victim,sn_cold) )
		use_sn = sn_cold;
	else
	if ( victim->race == race_lookup("yinn") && !is_affected(victim,sn_hot) )
		use_sn = sn_hot;
	else
	if ( !is_affected(victim,sn_elec) )
	        use_sn = sn_elec;

	if ( use_sn < 0 ) /* Didn't meet any of these conditions.  Flee! */
 	{
	    do_flee(ch,"");
	    return TRUE;
	}

	if ( use_sn < 0 )
	    return FALSE;

	say_spell(ch,use_sn);
	(*skill_table[use_sn].spell_fun) ( use_sn, ch->level, ch, victim, TARGET_CHAR);
	return TRUE;
    }

    /* First, if any melee drachlans are here and fighting, heal them */
    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
	if ( IS_NPC(vch) && vch->fighting != NULL && vch->spec_fun == spec_drachlan_melee 
	      && vch->hit < (75*vch->max_hit/100) )
	{
	    int sn = skill_lookup("heal");

	    say_spell(ch,sn);
	    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);
	    return TRUE;
	}		
    }

    /* Nobody?  Check for the same thing, only not fighting, heal to 100% */
    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
	if ( IS_NPC(vch) && 
	(vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic) &&
	 vch->hit < vch->max_hit )
	{
	    act("$n's hands glow with a blue aura; $N appears to feel better.",
		ch,NULL,vch,TO_NOTVICT,FALSE);
	    act("Your hands glow with a blue aura; $N appears to feel better.",
		ch,NULL,vch,TO_CHAR,FALSE);
	    act("$n's hands glow with a blue aura; you feel better.",
		ch,NULL,vch,TO_VICT,FALSE);
	    
	    vch->hit = UMIN(vch->hit+100,vch->max_hit);
	    return TRUE;
	}		
    }

    /* Look in adjacent rooms, see if friends need help! */
    for ( i = 0 ; i < 6 ; i++ )
    {
        pExit = ch->in_room->exit[i];

        if ( pExit == NULL )
            continue;
        else
        {
            CHAR_DATA *vch;

            for ( vch = pExit->u1.to_room->people ; vch != NULL ; vch = vch->next_in_room )
                if ( IS_NPC(vch) && vch->fighting != NULL &&
                     (vch->spec_fun == spec_drachlan_melee ||
                      vch->spec_fun == spec_drachlan_medic ) )
                { /* If a drachlan NPC is fighting in this room, move in! */
                    move_char( ch, i, FALSE );
                    return TRUE;
                }
        }
    }

    /* Nobody?  Cure poison/disease/blind */
    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
        if ( IS_NPC(vch) &&
        (vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic)
         && is_affected(vch,gsn_blindness) )
        {
            int sn;

            sn = skill_lookup("cure blindness");

	    say_spell(ch,sn);
            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);
            return TRUE;
        }
    }

    /* Nobody?  Cure poison/disease/blind */
    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
	if ( IS_NPC(vch) && 
	(vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic) 
	 && is_affected(vch,gsn_poison) )
	{
	    int sn;

	    sn = skill_lookup("cure poison"); 
	   
	    say_spell(ch,sn); 
            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);	    
	    return TRUE;
	}		
    }

    /* Nobody?  Cure poison/disease/blind */
    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
	if ( IS_NPC(vch) && 
	(vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic) 
	 && is_affected(vch,gsn_plague) )
	{
	    int sn;

	    sn = skill_lookup("cure disease"); 
	   
	    say_spell(ch,sn); 
            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);	    
	    return TRUE;
	}		
    }

    /* Nobody? Start spelling up! */
    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
	if ( IS_NPC(vch) && 
	(vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic) 
	 && !IS_AFFECTED(vch,AFF_SANCTUARY) )
	{
	    say_spell(ch,gsn_sanctuary);
            (*skill_table[gsn_sanctuary].spell_fun) ( gsn_sanctuary, ch->level, ch, vch, TARGET_CHAR);	    
	    return TRUE;
	}		
    }


     for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
        if ( IS_NPC(vch) &&
        (vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic)
         && !IS_AFFECTED(vch,AFF_HASTE) && !IS_SET(vch->off_flags,OFF_FAST) )
        {
	    int sn = skill_lookup("haste");

            say_spell(ch,sn);
            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);
            return TRUE;
        }
    }

  for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
        if ( IS_NPC(vch) &&
        (vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic)
         && !is_affected(vch,skill_lookup("armor")) )
        {
	    int sn = skill_lookup("armor");

            say_spell(ch,sn);
            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);
            return TRUE;
        }
    }

     for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
        if ( IS_NPC(vch) &&
        (vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic)
         && !is_affected(vch,skill_lookup("shield")) )
        {
	     int sn = skill_lookup("shield");

            say_spell(ch,sn);
            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);
            return TRUE;
        }
    }

    /* VISION! */
     for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
        if ( IS_NPC(vch) &&
        (vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic)
         && !is_affected(vch,skill_lookup("vision")) )
        {
             int sn = skill_lookup("vision");

            say_spell(ch,sn);
            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);
            return TRUE;

	}
    }

    /* STILL nothing?  Relax */
    return FALSE;
}

void check_equip( CHAR_DATA *ch )
{
    OBJ_DATA *obj;
    CHAR_DATA *vch;
    bool foundPC = FALSE;

    /* don't bother swapping EQ with no PCs in the room */
    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
    {   
        if (!IS_NPC(vch))
	   {
	    foundPC = TRUE;
            break;
	   }
    }

    /* Alright, a player is here.  Let's bother checking if we should swap. */
    if (foundPC)
    {
      for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
	if ( obj->wear_loc == WEAR_NONE &&  check_wear( ch, obj ) )
	    do_wear(ch,obj->name);
    }
}

bool check_wear( CHAR_DATA *ch, OBJ_DATA *obj1 )
{
    AFFECT_DATA *paf;
    OBJ_DATA *obj2;
    int pafC1=0,pafC2=0,sum1=0,sum2=0;

   for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content)
   {
       if (obj2->wear_loc != WEAR_NONE
       &&  obj1->item_type == obj2->item_type
       &&  (obj1->wear_flags & obj2->wear_flags & ~ITEM_TAKE) != 0 )
     break;
   }

    /* not wearing anything in that slot and most anything
	is better than nothing at all.
     */
   if (obj2 == NULL)
   {
    return TRUE;
   }
   else
   {
	/* sum up the values that matter for comparison */
       switch ( obj1->item_type )
     {
     default:
       break;

     case ITEM_ARMOR:
	/* give the item points for AC values, half for magic */
       sum1 = obj1->value[0] +obj1->value[1] +obj1->value[2] +obj1->value[3]/2;
       sum2 = obj2->value[0] +obj2->value[1] +obj2->value[2] +obj1->value[3]/2;

	/* give some value to enchantments */
        for ( paf = obj1->affected; paf != NULL; paf = paf->next)
  	{
	  if ( paf->location == APPLY_AC)
	  sum1 -= paf->modifier/2;
	}

        for ( paf = obj2->affected; paf != NULL; paf = paf->next)
  	{
	  if ( paf->location == APPLY_AC)
	  sum2 -= paf->modifier/2;
	}
       break;

     case ITEM_WEAPON:
         if (obj1->pIndexData->new_format)
       sum1 = (1 + obj1->value[2]) * obj1->value[1];
         else
       sum1 = obj1->value[1] + obj1->value[2];

         if (obj2->pIndexData->new_format)
       sum2 = (1 + obj2->value[2]) * obj2->value[1];
         else
       sum2 = obj2->value[1] + obj2->value[2];

	/* increment the PAF counter if it has a weapon flag */
	 if(IS_WEAPON_STAT(obj1,WEAPON_FLAMING)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_FROST)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_VAMPIRIC)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_SHARP)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_VORPAL)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_TWO_HANDS)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_SHOCKING)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_POISON)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_STUN)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_HOLY)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_FAVORED)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_NETHER)) pafC1++;
	 if(IS_WEAPON_STAT(obj1,WEAPON_SCION)) pafC1++;
	 if(obj1->enchanted) pafC1++;

	 if(IS_WEAPON_STAT(obj2,WEAPON_FLAMING)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_FROST)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_VAMPIRIC)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_SHARP)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_VORPAL)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_TWO_HANDS)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_SHOCKING)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_POISON)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_STUN)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_HOLY)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_FAVORED)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_NETHER)) pafC2++;
	 if(IS_WEAPON_STAT(obj2,WEAPON_SCION)) pafC2++;
	 if(obj2->enchanted) pafC2++;

         break;
     }

	/* increment the PAF counter if it has a worth PAF */
     for ( paf = obj1->pIndexData->affected; paf != NULL; paf = paf->next )
        if ( paf->location == APPLY_NONE && paf->modifier >= 0 )
            pafC1++;

     for ( paf = obj2->pIndexData->affected; paf != NULL; paf = paf->next )
        if ( paf->location == APPLY_NONE && paf->modifier >= 0 )
            pafC2++;

	/* totally equal objects, why bother switching? */
     if ( sum1 == sum2 && pafC1 == pafC2 && obj1->level == obj2->level )
	return FALSE;

	/* switch if attribs are equal but one has more PAF's
	   or if attribs are better and we're not losing PAF's
	   or if attribs are worse but we gain PAF's and don't lose levels
	 */
     if ( (sum1 == sum2 && pafC1 > pafC2)
	||(sum1 > sum2 && pafC1 >= pafC2)
	|| (sum1 <= sum2 && pafC1 > pafC2 && obj1->level > obj2->level) )
	return TRUE;
    }
  return FALSE;
}

bool spec_elemental_king (CHAR_DATA *king)
{
	CHAR_DATA *victim,*summ;
        int summon, cost = 1000;
	int use_sn = -1, sn1, sn2, sn3, sn4, sn5;
        int percent;
        OBJ_DATA *segment;
	
	if ( (victim = king->fighting) == NULL )
		return FALSE;

	switch (king->pIndexData->vnum)
	{
		case MOB_VNUM_KING_FIRE:
			summon = MOB_VNUM_FIRE_1;
			sn1    = skill_lookup("flameseek");
			sn2    = skill_lookup("blistering skin");
			sn3    = skill_lookup("incinerate");
			sn4    = skill_lookup("fire breath");
			sn5    = skill_lookup("wall of fire");
             		break;
		default:
		  return FALSE;
        }	

	if ( king->hit <= king->max_hit * 3/4 )
	{
        
        percent = number_percent();

        if (percent <= 40 )
	{
	   if (king->mana > cost  )
	   {
		king->mana -= cost;
		summ = create_mobile(get_mob_index(summon));
		char_to_room(summ, king->in_room);
		send_to_room("A shining globe appears and help arrives!\n\r",king->in_room);
		do_say(king,"Show the mortals the true power of the elements.");
		do_rescue(summ, "king");
                multi_hit( king, victim, TYPE_UNDEFINED );
		return TRUE;
 	   }	
        }
	else if ( percent <= 50 && !is_affected(victim, sn1))
		use_sn = sn1;
 	else if ( percent <= 60 && !is_affected(victim, sn2) )
		use_sn = sn2;
	else if ( percent <= 70 && !is_room_affected(king->in_room, sn5) )
		use_sn = sn5;
	else if ( percent <= 80 ) 
		use_sn = sn4;
	else if ( percent <= 90)
		use_sn = sn3;
        else
		return FALSE;
	
	}

	if ( use_sn > 0 )
	{
          say_spell(king,use_sn);
          (*skill_table[use_sn].spell_fun) ( use_sn, king->level, king, victim, TARGET_CHAR);
 	  return TRUE;
	}
        
        if ( king->hit < king->max_hit /4 )
        {
          do_say(king, "Follow me mortal, to the realm of the Spirit King.  If you dare.");
	  segment = create_object(get_obj_index(VNUM_FIRE_SEGMENT), 0, FALSE);
	  send_to_room("A small piece of gold falls from the King's grasp as he suddenly disappears!\n\r", king->in_room);
	  obj_to_room(segment, king->in_room);
          stop_fighting(king, FALSE);
          char_from_room(king);
          char_to_room(king, get_room_index(22500));
          return TRUE;
        }
	return FALSE;

}

bool spec_elemental_fire(CHAR_DATA *ch)
{
	int summon;
	int cost = 1000;
        CHAR_DATA *vch, *summ, *victim;

	/* first, if we're not fighting anyone, check to see if there's a king here
	   If there is, attach whoever he's fighting, if anyone. */
	if ( (victim = ch->fighting) == NULL )
	{
		for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room)
			if ( IS_NPC(vch) && (vch->pIndexData->vnum == MOB_VNUM_KING_FIRE ||
                                             vch->spec_fun == spec_elemental_fire ||
					     vch->spec_fun == spec_breath_fire ) )
				if ( (victim = vch->fighting) != NULL && (
					victim->spec_fun != spec_elemental_fire &&
					victim->spec_fun != spec_breath_fire ))
					{
					do_say(ch, ch->pIndexData->spec_words[2]);
					multi_hit(ch, victim, TYPE_UNDEFINED);
					return TRUE;
					}
				else
					return FALSE;
	}
	else
	{

	/* If we made it here, we're either fighting someone ourselves, or fighting whoever
	   the king is fighting, so we're safe to proceed */
	switch(ch->pIndexData->vnum)
	{
	case MOB_VNUM_FIRE_1:
		summon = MOB_VNUM_FIRE_2;
		break;
	case MOB_VNUM_FIRE_2:
		summon = MOB_VNUM_FIRE_3;
		break;
	case MOB_VNUM_FIRE_3:
		summon = MOB_VNUM_FIRE_SALAMANDER;
		break;
	default:
		summon = MOB_VNUM_MAGMAN;
		break;
	}

	
	if ( (ch->hit <= ch->max_hit * 3/4) && number_percent() < 30 )
	{
		if (ch->mana > cost )
		{
			ch->mana -= cost;
			summ = create_mobile(get_mob_index(summon));
			char_to_room(summ, ch->in_room);
			send_to_room("A shining globe appears and help arrives!\n\r",ch->in_room);
			do_say(ch,ch->pIndexData->spec_words[0]);
			/* Always rescue the king to prevent animated corpses
			   from getting rescued and having summoned attack king
			 */
			//do_rescue(summ, ch->pIndexData->player_name);
			do_rescue(summ, "king");
                	multi_hit( ch, victim, TYPE_UNDEFINED );
			return TRUE;
		}

	}
	else if ( number_percent() < 5 )
	{
	do_say(ch, ch->pIndexData->spec_words[1]);
	return FALSE;
	}
	}
	return FALSE;

}

bool spec_elemental_water(CHAR_DATA *ch)
{

   int summon, use_sn = -1;
   CHAR_DATA *summ, *victim, *vch;
   int cost = 1000;

   
	if ((victim = ch->fighting) == NULL)
		return FALSE;

        if (count_fight_size(ch) < 1)
		return FALSE;
	else if ( count_fight_size(ch) > 1)
		use_sn = skill_lookup("tsunami");
	else
	   {
	   /* if we're here, we should be fighting just one person or mob */
           switch(ch->pIndexData->vnum)
	   {
		case MOB_VNUM_WATER_1:
		  summon = MOB_VNUM_WATER_2;
  		  break;
		case MOB_VNUM_WATER_2:
		  summon = MOB_VNUM_WATER_3;
		  break;
                case MOB_VNUM_WATER_3:
		  summon = MOB_VNUM_WATER_WIERD;
		  break;
		case MOB_VNUM_WATER_WIERD:
		  summon = MOB_VNUM_ICE_DRAKE;
		  break;
	   }
	    if ( (ch->hit <= ch->max_hit * 3/4) && number_percent() < 30 )
            {
                if (ch->mana > cost )
                {
                        ch->mana -= cost;
                        summ = create_mobile(get_mob_index(summon));
                        char_to_room(summ, ch->in_room);
                        send_to_room("A shining globe appears and help arrives!\n\r",ch->in_room);
                        do_say(ch,ch->pIndexData->spec_words[0]);
			/* Always rescue the king to prevent animated corpses
			   from getting rescued and having summoned attack king
			 */
                        //do_rescue(summ, ch->pIndexData->player_name);
                        do_rescue(summ, "king");
                        multi_hit( ch, victim, TYPE_UNDEFINED );
                        return TRUE;
                }

            }
	    else if ( number_percent() < 5 )
        	{
        	do_say(ch, ch->pIndexData->spec_words[1]);
	        return FALSE;
	        }

 
           }
		
	if ( use_sn > 0 )
	{
          say_spell(ch,use_sn);
          (*skill_table[use_sn].spell_fun) ( use_sn, ch->level, ch, victim, TARGET_CHAR);
 	  return TRUE;
	}
	   return FALSE;
}

bool spec_elemental_water_king(CHAR_DATA *king)
{
	
   CHAR_DATA *victim,*summ;
   int summon, cost = 1000;
   int sn1, sn2, sn3, sn4, sn5,sn6;
   int percent,count;
   OBJ_DATA *segment;

   
        if ( king->hit < king->max_hit /4 )
        {
          do_say(king, "Follow me mortal, to the realm of the Spirit King.  If you dare.");
          segment = create_object(get_obj_index(VNUM_WATER_SEGMENT), 0, FALSE);
          send_to_room("A small piece of gold falls from the King's grasp as he suddenly disappears!\n\r", king->in_room);
          obj_to_room(segment, king->in_room);
          char_from_room(king);
          char_to_room(king, get_room_index(22500));
          return TRUE;
        }

   count = count_fight_size(king);

   if(count < 1 || (victim = king->fighting) == NULL)
	return FALSE;
   else if (count > 1)
       {
	sn6 = skill_lookup("tsunami");
        say_spell(king, sn6);
        (*skill_table[sn6].spell_fun) ( sn6, king->level, king, victim, TARGET_CHAR);
        return TRUE;
       }
   else
      {

      summon = MOB_VNUM_WATER_1;
      sn1    = skill_lookup("hydrophilia");
      sn2    = skill_lookup("frostbite");
      sn3    = skill_lookup("ice storm");
      sn4    = skill_lookup("frost breath");
      sn5    = skill_lookup("wall of ice");

      if (!is_room_affected(king->in_room, gsn_wall_ice))
      {
        say_spell(king, sn5);
        (*skill_table[sn5].spell_fun) ( sn5, king->level, king, victim, TARGET_CHAR);
        return TRUE;
      }
      
      if(!is_affected(victim, gsn_hydrophilia))
      {
        say_spell(king, sn1);
        (*skill_table[sn1].spell_fun) ( sn1, king->level, king, victim, TARGET_CHAR);
        return TRUE;
      }

      if ( king->hit <= king->max_hit * 3/4 && king->hit > king->max_hit /4)
      {

      percent = number_percent();

      if (percent <= 40 )
      {
           if (king->mana > cost  )
           {
                king->mana -= cost;
                summ = create_mobile(get_mob_index(summon));
                char_to_room(summ, king->in_room);
                send_to_room("A shining globe appears and help arrives!\n\r",king->in_room);
                do_say(king,"Show the mortals the true power of the elements.");
                do_rescue(summ, "king");
                multi_hit( king, victim, TYPE_UNDEFINED );
                return TRUE;
           }
        }
        else if ( percent <= 60 && !is_affected(victim, sn2) )
         {
          say_spell(king, sn4);
          (*skill_table[sn4].spell_fun) ( sn4, king->level, king, victim, TARGET_CHAR);
          return TRUE;
         }
        else if ( percent <= 80 )
         {
          say_spell(king, sn3);
          (*skill_table[sn3].spell_fun) ( sn3, king->level, king, victim, TARGET_CHAR);
          return TRUE;
         }
        else if ( percent <= 90)
         {
          say_spell(king, sn2);
          (*skill_table[sn2].spell_fun) ( sn2, king->level, king, victim, TARGET_CHAR);
          return TRUE;
         }
        else
                return FALSE;
        }

        return FALSE;
    }
}
 
@


1.124
log
@all guards will wake up if they're asleep
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.123 2005/02/17 03:46:13 boogums Exp $";
d2921 5
a2925 1
			do_rescue(summ, ch->pIndexData->player_name);
d2983 5
a2987 1
                        do_rescue(summ, ch->pIndexData->player_name);
@


1.123
log
@testing waking guards up
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.122 2004/09/28 01:33:20 boogums Exp $";
d261 3
d332 3
d405 3
d475 3
@


1.122
log
@ok testing all of the other guards
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.121 2004/09/28 01:29:23 boogums Exp $";
d190 3
@


1.121
log
@ok this should get it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.120 2004/09/28 01:18:55 boogums Exp $";
d199 1
a199 1

d334 1
a334 1

d403 1
a403 1

d472 1
a472 1

@


1.120
log
@tstup
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.119 2004/09/28 01:14:37 boogums Exp $";
d266 1
d288 1
a288 4
        if ( is_clan(victim) )
        {
          multi_hit( ch, victim, TYPE_UNDEFINED);
        }
@


1.119
log
@thwoops
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.118 2004/09/28 01:00:46 boogums Exp $";
d281 1
a281 1
    if (victim != NULL  && is_clan(victim))
d287 4
a290 1
        multi_hit( ch, victim, TYPE_UNDEFINED);
@


1.118
log
@making it so you cannot drag mobs
added a !clan check to the guard mob specs
did somethign in update.c but can't remember, oh yeah i thin i remember
now somethign with outcasts...
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.117 2004/04/29 01:48:16 boogums Exp $";
a198 1
        if ( !is_clan(victim) ) continue;
d214 1
a214 1
    if (victim != NULL)
a265 1
        if ( !is_clan(victim) ) continue;
d281 1
a281 1
    if (victim != NULL)
a332 1
        if ( !is_clan(victim) ) continue;
d351 1
a351 1
    if (victim != NULL)
a401 1
        if ( !is_clan(victim) ) continue;
d419 1
a419 1
    if (victim != NULL)
a470 1
        if ( !is_clan(victim) ) continue;
d488 1
a488 1
    if (victim != NULL)
@


1.117
log
@tfizing leaot
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.116 2004/04/26 02:25:10 boogums Exp $";
d199 1
d267 1
d335 1
d405 1
d475 1
@


1.116
log
@stuff and things
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.115 2004/04/25 00:32:05 boogums Exp $";
a396 1

d400 1
a400 1
        if (victim == victim) continue;
a403 2
//        if ( victim->clan != clan_lookup("zealot") && !IS_IMMORTAL(victim) )
//            break;
d405 1
a405 1
             ( IS_SET(ch->mhs, MHS_BANISH)
d412 2
a414 1
    }
@


1.115
log
@banishment will cause a clanners guard to attack them
snatch added to the game
boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.114 2003/09/28 18:45:37 ndagger Exp $";
d479 1
a479 1
             || victim->clan != clan_lookup("honor")
@


1.114
log
@09/28/03 Nightdagger:  Added spec_clan_guard functions for demise, posse, zealot, warlock
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.113 2003/09/28 03:54:06 ndagger Exp $";
d201 6
a206 1
        if ( victim->clan != clan_lookup("honor") && !IS_IMMORTAL(victim) )
d268 7
a274 1
        if ( victim->clan != clan_lookup("demise") && !IS_IMMORTAL(victim) )
a275 1

d335 8
a342 1
        if ( victim->clan != clan_lookup("posse") && !IS_IMMORTAL(victim) )
d345 1
d401 1
a401 1
        if (ch == victim) continue;
d405 8
a412 1
        if ( victim->clan != clan_lookup("zealot") && !IS_IMMORTAL(victim) )
d415 1
d475 8
a482 1
        if ( victim->clan != clan_lookup("warlock") && !IS_IMMORTAL(victim) )
@


1.113
log
@09/27/03 Nightdagger:  formatting mistake in spec_honor_guard corrected
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.112 2003/09/28 03:39:11 ndagger Exp $";
d96 4
d121 4
d230 1
a230 1
                  send_to_char("[{cHonor{x] A guard {Gclans{x 'Help!  We are under attack!'\n\r"
d234 248
@


1.112
log
@09/27/03 Nightdagger:  Bug fix to spec_honor_guard
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.111 2003/09/28 03:26:20 ndagger Exp $";
d222 1
a222 1
                  send_to_char("[{cHonor{x] A guard {Gclans{x 'Help!  We are under attack!'/n/r"
d226 1
a226 1
                  send_to_char("A guard {Gclans{x 'Help!  We are under attack!'/n/r"
@


1.111
log
@09/27/03 Nightdagger:  added spec_honor_guard for sattelite halls
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.110 2002/10/12 01:44:00 ndagger Exp $";
d189 2
@


1.110
log
@10/11/02 Nightdagger-  Added a stop_fighting call to spec_elemental_king for when he goes poofda from the room.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.109 2002/09/03 16:55:48 rusty Exp $";
d95 1
d116 1
d173 63
@


1.109
log
@Added turn undead to spec_cast_cleric
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.108 2002/04/24 02:38:09 boogums Exp $";
d2486 1
@


1.108
log
@adding spec_jabber
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.107 2002/04/06 02:57:50 boogums Exp $";
d672 1
a672 1
	case  8:
@


1.107
log
@doh fixing a crash bug
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.106 2002/04/05 15:24:28 boogums Exp $";
d95 1
d138 1
a881 1

d924 49
@


1.106
log
@5apr02
putting in the fence kit.  changes to do_sell in act_obj.c
the kit info in merc.h db.c and const.c
and a special.c change in spec_guard.  it checks to see
if the guard turns the other way cuz they're sooo cool
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.105 2002/03/22 08:42:45 poquah Exp $";
d1465 3
d1470 7
a1476 8
	connive_check = number_percent();
/*COREY START HERE */
	if(!IS_NPC(victim) && connive_check < get_curr_stat(victim,STAT_SOC)*2)
	{
		sprintf(buf, "%s you are tooo cool.",victim->name);
		do_say(ch,buf);
		return FALSE;	
	}
a1478 3

    if ( victim != NULL )
    {
@


1.105
log
@Put back the real Mayor of Midgaard
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.104 2001/11/24 15:09:58 rage Exp $";
d1438 1
a1438 1

d1464 13
@


1.104
log
@fix bug with newbie flag
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.103 2001/11/16 00:32:19 rage Exp $";
d1652 1
a1652 1
	act( "$n says 'Good day, citizens! Re-Elect Muggerud for Mayor!'", ch, NULL, NULL, TO_ROOM ,FALSE);
@


1.103
log
@added in water segment effects
modified water king special to flee more reliably
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.102 2001/11/11 23:48:17 rage Exp $";
d2648 1
a2648 1
          (*skill_table[sn1].spell_fun) ( sn1, king->level, king, victim, TARGET_CHAR);
d2654 1
a2654 1
          (*skill_table[sn1].spell_fun) ( sn1, king->level, king, victim, TARGET_CHAR);
d2660 1
a2660 1
          (*skill_table[sn1].spell_fun) ( sn1, king->level, king, victim, TARGET_CHAR);
@


1.102
log
@first try at spec_water_king
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.101 2001/11/11 17:29:12 rage Exp $";
d2580 11
a2666 10
        if ( king->hit < king->max_hit /4 )
        {
          do_say(king, "Follow me mortal, to the realm of the Spirit King.  If you dare.");
          segment = create_object(get_obj_index(VNUM_WATER_SEGMENT), 0, FALSE);
          send_to_room("A small piece of gold falls from the King's grasp as he suddenly disappears!\n\r", king->in_room);
          obj_to_room(segment, king->in_room);
          char_from_room(king);
          char_to_room(king, get_room_index(22500));
          return TRUE;
        }
@


1.101
log
@made some changes to wall of ice, spec_elemental_water, hydrophilia
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.100 2001/11/10 19:13:43 rage Exp $";
d94 1
d136 1
d2375 1
a2375 1
	}	
d2569 101
@


1.100
log
@bug fixes for spec_elemental_water
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.99 2001/11/10 18:38:25 rage Exp $";
d2529 3
a2532 3
		  break;
		case MOB_VNUM_ICE_DRAKE:
		  summon = MOB_VNUM_WATER_WIERD;
@


1.99
log
@initial insertion of spec_water
added in healing for drinking from holy grail
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.98 2001/10/14 04:33:49 rage Exp $";
d134 1
a134 1
    {   "spec_elemental_fire",		spec_elemental_water	},
d2505 1
a2505 1
   int summon, use_sn;
@


1.98
log
@bug fix to spec_element_fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.97 2001/10/13 02:11:59 rage Exp $";
d36 2
a37 1

d93 1
a93 1

d134 1
d2500 66
@


1.97
log
@Bug fixes as follow

can no longer drag furniture that's being used
steal/slice kr only increments on players
IMMs now immune to sector damage
die command should work now
spec_average now has an IS_AWAKE check
Cavalier attack is now given to groupmates
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.96 2001/10/12 17:37:26 rage Exp $";
d2438 1
a2438 1
		for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next)
d2442 3
a2444 1
				if ( (victim = vch->fighting) != NULL )
@


1.96
log
@bug fix for symbol/aid put back in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.95 2001/10/11 16:42:11 rage Exp $";
d873 3
@


1.95
log
@changed spell level of flameseek
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.94 2001/10/05 18:09:38 rage Exp $";
d2435 1
a2435 1
		for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room )
@


1.94
log
@bug fix for annointment...if two zealots both affected, and one casts on the other, we go poof with buffer overflows
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.93 2001/10/05 17:33:45 rage Exp $";
d2435 1
a2435 1
		for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
@


1.93
log
@few updates to fire elemental specials
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.92 2001/09/23 21:08:06 rage Exp $";
d2388 1
d2401 1
a2401 1
	}
@


1.92
log
@more changes to spec_elemental fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.91 2001/09/23 20:25:05 rage Exp $";
d2350 2
d2372 2
d2375 1
a2375 1
	if (king->mana > cost  )
d2377 2
d2387 2
a2388 15
 	}	

	/* If we made it here, the king already has 6 helpers,
	 * so if he's hurt enough, he needs to bugger off, or
	 * if he's still OK, help out his cronies a bit 
	 */

	if ( king->hit < king->max_hit /4 )
	{
	  do_say(king, "Follow me mortal, to the realm of the Spirit King.  If you dare.");
	  char_from_room(king);
	  char_to_room(king, get_room_index(22500));
	  return TRUE;
	}
	else if ( !is_affected(victim, sn1) )
d2390 1
a2390 1
 	else if ( !is_affected(victim, sn2) )
d2392 1
a2392 1
	else if ( !is_room_affected(king->in_room, sn5) )
d2394 1
a2394 1
	else if ( victim->hit > victim->max_hit * 3 / 4 )
d2396 1
a2396 1
	else
d2398 4
d2409 11
a2419 1
	} 	  	  
d2421 1
@


1.91
log
@some changes to spec_elemental stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.90 2001/08/14 19:59:11 rusty Exp $";
d2428 2
a2429 1
                                             vch->spec_fun == spec_elemental_fire) )
d2476 1
a2476 1
	else if ( number_percent() < 25 )
@


1.90
log
@Eliminate repeato swapping
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.89 2001/07/25 18:27:44 rage Exp $";
d2427 2
a2428 1
			if ( IS_NPC(vch) && vch->pIndexData->vnum == MOB_VNUM_KING_FIRE )
d2431 1
d2460 1
a2460 1
	if ( ch->hit <= ch->max_hit * 3/4 )
d2474 5
@


1.89
log
@fixed bug in double xp
more changes to spec_king functionality
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.88 2001/07/20 16:14:04 rage Exp $";
d2339 1
a2339 1
	|| (sum1 <= sum2 && pafC1 > pafC2 && obj1->level >= obj2->level) )
@


1.88
log
@more bug fixes to specs
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.87 2001/07/20 01:04:12 rage Exp $";
d2347 2
a2348 2
	CHAR_DATA *victim,*vch,*summ;
        int summon, count = 0;
a2369 3
		for ( vch = king->in_room->people ; vch != NULL ; vch = vch->next )
			if ( IS_NPC(vch) && vch->pIndexData->vnum == summon )
				count++;
d2371 1
a2371 1
	if ( count <= 5 )
d2373 1
d2418 3
a2420 2
	int count = 0, summon,max_count;
	CHAR_DATA *vch, *summ, *victim;
a2444 1
		max_count = 7;
a2447 1
		max_count = 8;
a2450 1
		max_count = 9;
a2453 1
		max_count = 10;
d2460 1
a2460 5
		for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
			if ( IS_NPC(vch) && vch->pIndexData->vnum == summon )
				count++;

		if ( count <= max_count )
d2462 1
@


1.87
log
@More fixes/upgrades to spec_king and spec_elem_fire
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.86 2001/07/20 00:23:02 rage Exp $";
d2434 2
a2438 2
		return FALSE;
	}
d2480 1
@


1.86
log
@ Additions and bug fixes to spec_king and specz_fire_ele
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.85 2001/07/19 02:13:58 rage Exp $";
d2359 3
a2361 3
			sn2    = skill_lookup("incinerate");
			sn3    = skill_lookup("fireball");
			sn4    = skill_lookup("blistering skin");
d2395 1
d2397 8
d2406 1
a2406 20
	{
	  switch(number_range(1,5))
	  {
		case 1:
		default:
		  use_sn = sn1;
		  break;
		case 2:
		  use_sn = sn2;
		  break;
		case 3:
		  use_sn = sn3;
		  break;
		case 4:
		  use_sn = sn4;
		  break;
		case 5:
		  use_sn = sn5;
		  break;
	  }
a2414 1
        }	
d2423 2
d2426 11
d2438 1
d2440 2
d2469 10
a2478 10
	if ( count <= max_count )
	{
		summ = create_mobile(get_mob_index(summon));
		char_to_room(summ, ch->in_room);
		send_to_room("A shining globe appears and help arrives!\n\r",ch->in_room);
		do_say(ch,"Show the mortals the true power of the elements.");
		do_rescue(summ, ch->pIndexData->player_name);
                multi_hit( ch, victim, TYPE_UNDEFINED );
		return TRUE;
	}
@


1.85
log
@bug fix in spec_king
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.84 2001/07/19 02:01:50 rage Exp $";
d2349 1
a2349 1
	int use_sn, sn1, sn2, sn3, sn4, sn5;
d2360 1
a2360 1
//			sn3    = skill_lookup("flamewind");
d2418 2
d2423 1
d2431 1
a2431 1
	int count, summon,max_count;
@


1.84
log
@missed a break in a switch *sigh*
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.83 2001/07/19 01:41:25 rage Exp $";
d2360 1
a2360 1
			sn3    = skill_lookup("flamewind");
@


1.83
log
@first attempt at spec_elemental_fire
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.82 2001/07/15 19:09:45 rusty Exp $";
d2403 1
d2406 1
d2409 1
d2412 1
d2415 1
d2437 1
a2437 1
		summon = MOB_VNUM_FIRE_1;
d2439 1
d2441 1
a2441 1
		summon = MOB_VNUM_FIRE_2;
d2443 1
d2447 1
d2451 1
@


1.82
log
@Make Manney stop_follower() so the add_follower() can work
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.81 2001/07/10 23:39:13 rage Exp $";
d90 1
d132 1
d2413 1
d2421 46
@


1.81
log
@fixed some display stuff in ostat to list recipes better
added a bit more stuff to spec_king
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.80 2001/07/10 12:13:34 rusty Exp $";
d857 1
@


1.80
log
@Took out debug messages in spec_average
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.79 2001/07/09 22:08:17 mud Exp $";
d2378 1
@


1.79
log
@spread out the says for spec_average()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.78 2001/07/09 21:50:14 rusty Exp $";
a882 1
do_say(ch,"{RDEBUG{x Not fighting anyone");
a885 1
do_say(ch,"{RDEBUG{x I have an lAb and enough HP");
@


1.78
log
@Another stab at finding an lAb in spec_average
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.77 2001/07/09 21:40:43 rusty Exp $";
d873 1
a873 1
    switch(dice(2,5))
d876 2
a877 4
      case 3:
      case 4: do_say(ch,ch->pIndexData->spec_words[0]); return TRUE;
      case 5:
      case 6: do_say(ch,ch->pIndexData->spec_words[1]); return TRUE;
@


1.77
log
@changes to spec_average to use a CHAR_DATA lAb
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.76 2001/07/09 21:13:52 mud Exp $";
d885 1
d889 2
a890 1
	if((victim=get_char_room(ch,ch->lAb->name)) == NULL )
@


1.76
log
@declaring one_hit() to clear warnings
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.75 2001/07/09 21:07:49 rusty Exp $";
d888 5
a892 8
      for(victim=ch->in_room->people; victim!=NULL; victim=victim->next_in_room)
        {
	  if(is_name(victim->name,ch->lAb) && can_see(ch,victim,FALSE))
	  {
	    do_say(ch,"Hey!  I know you!");
	    one_hit(ch,victim,TYPE_UNDEFINED );
	    return TRUE;
	  }
d900 1
a900 1
	strcpy(ch->lAb,victim->name);
d907 1
a907 1
	  strcpy(ch->lAb,victim->master->name);
@


1.75
log
@Made spec_average() do something
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.74 2001/07/09 19:52:49 rusty Exp $";
d33 3
a35 2
void	check_equip	( CHAR_DATA *);
bool	check_wear	(CHAR_DATA*,OBJ_DATA*);
@


1.74
log
@Last fix to spec_salesman act()'s
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.73 2001/07/09 19:41:53 rusty Exp $";
d883 31
a913 1
	return FALSE;
@


1.73
log
@act() screwup fixes in spec_salesman()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.72 2001/07/09 18:15:39 rusty Exp $";
d841 1
a841 1
      act("$n points to $p.",ch,sobj,vch,TO_ROOM,FALSE);
@


1.72
log
@spec_salesman won't let them sleep and says a few more things
including old stuff to the room now too.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.71 2001/07/05 23:35:00 rage Exp $";
d830 1
a830 1
      case 2: act("$N inquires, 'Would you like to buy $p?'",vch,sobj,ch,
d835 2
a836 2
      case 3: do_say(ch,ch->pIndexData->spec_words[1]); break;
      case 6: act("$N's face wells up with tears.\n\rShaking $S head from side to side and staring at $p in disbelief...",NULL,sobj,ch,TO_ROOM,FALSE);
d841 1
a841 1
      act("$N points to $p.",vch,sobj,ch,TO_ROOM,FALSE);
@


1.71
log
@bug fix in spec_king
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.70 2001/07/05 23:16:32 rage Exp $";
d813 8
d828 1
a828 1
    switch( dice(1,20) )
d832 2
d836 6
a841 3
      case 4: do_say(ch,ch->pIndexData->spec_words[2]); break;
      case 5: do_say(ch,"Come on, I got a wife and kids to feed."); break;
      case 6: act("$N points to $p.\n\r$N says, 'This is the finest $p in Boinga.  I'll give you a fabulous deal on it.'",vch,sobj,ch,TO_CHAR,FALSE);
d2355 4
a2358 2
	/* If we made it here, hte king already has 6 helpers, so if he's hurt enough,
	   he needs to bugger off, or if he's still OK, help out his cronies a bit */
@


1.70
log
@more stuff added to spec_king
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.69 2001/07/02 21:48:25 rage Exp $";
d2336 1
a2336 1
		send_to_room(king->in_room, "A shining globe appears and help arrives!\n\r");
@


1.69
log
@first bug fix with spec_elemental_king...there will be more I'm sure
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.68 2001/07/02 21:36:08 rage Exp $";
d2336 2
d2347 1
a2348 1
	  // stick some blather about buggering off in here;
d2368 2
a2369 2
        (*skill_table[use_sn].spell_fun) ( use_sn, king->level, king, victim, TARGET_CHAR);
 	return TRUE;
d2371 1
a2371 1
}	
@


1.68
log
@initial attempt ant elemtal king special
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.67 2001/07/02 16:16:38 mud Exp $";
d2328 1
a2328 1
		for ( vch = king->in_room->people ; vch != NULL ; vch = vch->next );
@


1.67
log
@Make spec_salesman a bit less annoying.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.66 2001/07/02 15:55:01 rusty Exp $";
d89 1
d129 1
d2301 70
@


1.66
log
@Fixes for spec_salesman
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.65 2001/07/01 17:15:25 mud Exp $";
d818 1
a818 1
    switch( dice(2,5) )
a827 4
      case 7:
      case 8:
      case 9:
      case 10:
@


1.65
log
@initializing 'spell' var in spec_monk JIK
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.64 2001/07/01 17:13:35 mud Exp $";
d823 3
a825 3
      case 3: do_say(ch,ch->pIndexData->spec_words[1]);
      case 4: do_say(ch,ch->pIndexData->spec_words[2]);
      case 5: do_say(ch,"Come on, I got a wife and kids to feed.");
d839 1
a839 1
  for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
d841 9
a849 6
    if (!IS_NPC(vch))
     {
	add_follower(ch, vch);
	do_say(ch,ch->pIndexData->spec_words[0]);
	return TRUE;
     }
@


1.64
log
@incompat ptr type fix in spec_salesman
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.63 2001/07/01 17:09:46 rusty Exp $";
d877 1
a877 1
    char *spell;
@


1.63
log
@Added spec_salesman
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.62 2001/07/01 15:19:55 rusty Exp $";
d800 1
a800 1
  if ( ch->master != NULL && (vch = get_char_room( ch, ch->master )) != NULL )
@


1.62
log
@Updated spec_average
A bit nastier logic in spec_monk
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.61 2001/06/25 22:26:44 rusty Exp $";
d88 1
d127 1
d794 58
d860 1
a860 1
      case 2: do_say(ch,ch->pIndexData->spec_words[3]); return TRUE;
d939 1
d941 2
@


1.61
log
@Declared the spec_average()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.60 2001/06/25 22:24:19 rusty Exp $";
d800 1
a800 1
      case 2:
d833 7
d852 9
a860 6
    if ( ch->hit < ( ch->max_hit / 4 ) )
    {
        spell = "heal";
        target = 1; /* True, mob is casting on itself */
    }
    else
d911 1
a911 4
    if ( target )
       (*skill_table[sn].spell_fun) ( sn, ch->level, ch, ch, TARGET_CHAR);
    else
       (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TARGET_CHAR);
@


1.60
log
@added spec_average()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.59 2001/06/19 19:42:56 mud Exp $";
d87 1
d125 1
@


1.59
log
@+= swamped into -= when AC apply added in (cuz GOOD AC is - DUH!)
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.58 2001/06/19 19:32:11 rusty Exp $";
d790 22
d1646 2
a1647 2
    /* First, add 1000 hp */
    vhan->hit = UMIN(vhan->hit + 1000, vhan->max_hit );
@


1.58
log
@Gotta count index PAF's.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.57 2001/06/19 19:30:02 rusty Exp $";
d2128 1
a2128 1
	  sum1 += paf->modifier/2;
d2134 1
a2134 1
	  sum2 += paf->modifier/2;
@


1.57
log
@Made equipment switch logic account for enchantments.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.56 2001/06/19 18:41:35 rusty Exp $";
d2184 1
a2184 1
     for ( paf = obj1->affected; paf != NULL; paf = paf->next )
d2188 1
a2188 1
     for ( paf = obj2->affected; paf != NULL; paf = paf->next )
@


1.56
log
@New check_equip() and check_wear() logic to make Monks smarter in choosing
EQ to swap out.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.55 2001/06/18 04:07:38 guerrand Exp $";
d2120 16
a2135 2
       sum1 = obj1->value[0] + obj1->value[1] + obj1->value[2];
       sum2 = obj2->value[0] + obj2->value[1] + obj2->value[2];
d2163 1
d2178 2
d2184 1
a2184 1
     for ( paf = obj1->pIndexData->affected; paf != NULL; paf = paf->next )
d2188 1
a2188 1
     for ( paf = obj2->pIndexData->affected; paf != NULL; paf = paf->next )
@


1.55
log
@More work on item selection for NPCs
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.54 2001/06/18 01:02:33 guerrand Exp $";
d800 5
a804 1
    ch->hit = UMIN(ch->hit+200,ch->max_hit);
d2068 2
d2071 14
a2084 1
    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
d2087 1
d2090 1
a2090 1
bool check_wear( CHAR_DATA *ch, OBJ_DATA *obj )
d2093 2
d2096 7
a2102 3
    for ( paf = obj->pIndexData->affected; paf != NULL; paf = paf->next )
        if ( paf->location != APPLY_NONE && paf->modifier < 0 )
            return FALSE;
d2104 5
d2110 79
@


1.54
log
@Added some smarts to what the monk and drachlan willand won't wear.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.53 2001/06/18 00:49:51 guerrand Exp $";
d2074 2
a2075 2
    for ( paf = obj->affected ; paf != NULL ; paf = paf->next )
        if ( paf->modifier < 1 && paf->location != APPLY_AC ) 
@


1.53
log
@Added vision ot shamans, removed bug where melees would follow wraith'd
people around.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.52 2001/06/18 00:39:30 guerrand Exp $";
d33 3
d796 3
a798 4
   
    if ( get_eq_char(ch,WEAR_WIELD) == NULL ) 
        do_wear(ch,"flail");

d1725 1
a1725 2
    do_wear(ch,"all");

a1837 1
    do_wear(ch,"all");
d1839 1
d2060 21
@


1.52
log
@Another update to drachlan shaman logic.  Removed stone skin.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.51 2001/06/17 17:06:01 guerrand Exp $";
d1821 1
a1821 1
                if ( !IS_NPC(vch) )
d2040 15
@


1.51
log
@Fixed the haste bug in shaman drachlan special.
Added healing DOt functionality.
Added 'shield of faith' spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.50 2001/06/17 05:18:03 guerrand Exp $";
a2039 13
     for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next )
    {
        if ( IS_NPC(vch) &&
        (vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic)
         && !is_affected(vch,skill_lookup("stone skin")) )
        {
         	int sn = skill_lookup("stone skin");

            say_spell(ch,sn);
            (*skill_table[sn].spell_fun) ( sn, ch->level, ch, vch, TARGET_CHAR);
            return TRUE;
        }
    }
@


1.50
log
@Ritual command is in.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.49 2001/06/17 02:44:20 guerrand Exp $";
d2002 1
a2002 1
         && !IS_AFFECTED(vch,AFF_HASTE) )
@


1.49
log
@Improvements to drachlan SHaman AI.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.48 2001/06/17 01:47:21 guerrand Exp $";
d798 1
a798 1
    ch->hit = UMIN(ch->hit+250,ch->max_hit);
a1745 1
	update_pos( victim );
@


1.48
log
@Harder to teleport now through curse.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.47 2001/06/15 03:50:35 guerrand Exp $";
d793 3
a796 1
    do_wear(ch,"all");
d1990 1
a1990 1
	 && !is_affected(vch,gsn_sanctuary) )
d2003 1
a2003 1
         && !is_affected(vch,skill_lookup("haste")) )
@


1.47
log
@More functionality for drachlan medics.  Improved AI, more spellups.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.46 2001/06/15 03:08:11 guerrand Exp $";
d1742 1
d1744 1
a1744 1
	stop_fighting(ch, TRUE);
@


1.46
log
@More improvements to drachlans
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.45 2001/06/15 01:27:51 guerrand Exp $";
d35 1
d47 1
a47 1

d794 1
d1721 2
d1835 2
d1871 1
a1871 2
	act("$n utters some arcane words of magic.",ch,NULL,NULL,TO_ROOM,FALSE);
	act("You utter some arcane words of magic.",ch,NULL,NULL,TO_CHAR,FALSE);
d1882 4
a1885 8
	    act("$n's hands glow with a blue aura; $N appears to feel better.",
		ch,NULL,vch,TO_NOTVICT,FALSE);
	    act("Your hands glow with a blue aura; $N appears to feel better.",
		ch,NULL,vch,TO_CHAR,FALSE);
	    act("$n's hands glow with a blue aura; you feel better.",
		ch,NULL,vch,TO_VICT,FALSE);
	    
	    vch->hit = UMIN(vch->hit+100,vch->max_hit);
d1942 1
a1942 2
            act("You utter the words, 'cure blindness.'",ch,NULL,NULL,TO_CHAR,FALSE);
            act("$n utters the words, 'cure blindness.'",ch,NULL,NULL,TO_ROOM,FALSE);
d1958 2
a1959 3
	    
	    act("You utter the words, 'cure poison.'",ch,NULL,NULL,TO_CHAR,FALSE);
	    act("$n utters the words, 'cure poison.'",ch,NULL,NULL,TO_ROOM,FALSE);
d1975 2
a1976 3
	    
	    act("You utter the words, 'cure disease.'",ch,NULL,NULL,TO_CHAR,FALSE);
	    act("$n utters the words, 'cure disease.'",ch,NULL,NULL,TO_ROOM,FALSE);
d1989 1
a1989 2
    	    act("You summon a white aura around $N.",ch,NULL,vch,TO_CHAR,FALSE);
	    act("$n weaves into being a white aura!",ch,NULL,vch,TO_ROOM,FALSE);
d1993 57
@


1.45
log
@Added tyhree new NPC spells, one fire, one frist, one elcetrocution.
Used by drachlans.  Improved Drachlan AI somewhat for shamans.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.44 2001/06/14 03:59:52 guerrand Exp $";
d1927 18
@


1.44
log
@GMAN
Added one more bit of logic to search for players and kill them.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.43 2001/06/14 03:48:08 guerrand Exp $";
d1832 38
a1869 1
    ch->hit = UMIN(ch->hit+100,ch->max_hit);
@


1.43
log
@GMAN
Fixed a logical error in the drachlan_medic special
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.42 2001/06/14 02:51:52 guerrand Exp $";
d1803 20
a1822 1
    return FALSE;
@


1.42
log
@Added regen to the monk
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.41 2001/06/14 02:48:51 guerrand Exp $";
d1837 2
a1838 1
	(vch->spec_fun == spec_drachlan_melee || vch->spec_fun == spec_drachlan_medic) )
@


1.41
log
@TEypo in an act, I fixed it.  Was telling players they were doing what the mob was doing
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.40 2001/06/14 02:46:58 guerrand Exp $";
d792 3
@


1.40
log
@GMAN
Another fix for Vhan.  Wasn't ordering properly.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.39 2001/06/14 02:38:40 guerrand Exp $";
d1619 1
a1619 1
	act("$n wraps $s coils around $N and constricts!",vhan,NULL,victim,TO_ROOM,FALSE);
d1621 1
a1621 1
	act("You wrap your coils around $N and constrict!",vhan,NULL,victim,TO_NOTVICT,FALSE);
@


1.39
log
@GMAN - some improvements to Vhan - this guy is gonna be awesome
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.38 2001/06/14 02:33:49 guerrand Exp $";
d1693 1
@


1.38
log
@Specials are done for the drachlans.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.37 2001/06/14 00:41:21 guerrand Exp $";
d34 2
d1693 7
d1704 2
@


1.37
log
@Updated Vhan's special.  He's mean!
Fixed mummy out of element damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.36 2001/06/13 03:47:56 guerrand Exp $";
d79 3
d116 2
d1657 2
a1658 1
 	if ( IS_NPC(victim) && victim->pIndexData->vnum == MOB_VNUM_SKEL_WAR )
d1695 214
@


1.36
log
@VHAN special for Altirin.
Including new venom of vhan spell!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.35 2001/06/03 19:17:15 guerrand Exp $";
d1646 1
a1647 1
	return TRUE;
@


1.35
log
@Adjusrtments to the affects of DEX< all fairly minor.
DEX to 2/3 DEX, that kind of thing.
Adjustment o despawn frequency for the phoenix
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.34 2001/06/02 17:43:00 guerrand Exp $";
d78 1
d112 1
d1588 103
@


1.34
log
@GMAN Fixed another typo
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.33 2001/06/02 17:30:06 guerrand Exp $";
d1054 1
a1054 1
    if ( number_percent() < 5 )
@


1.33
log
@GMAN

Some neat stuff.
1. New spell: spirit of phoenix.  It's a long sanc/withstand death combo for 250 mana.
2. But the point of the spell isn't the affect, it's the side affect -
	a. the component will sometimes turn to ashes, which are a key you need to
	   get into the palace in Altirin.
	b. if the spell is cast in a superior magelab at midnight, the caster gets
	   an 'Amulet of the Phoenix', which is a really nice item.
3. New special: phoenix, for a phoenix mob that moves around like puff.  It has on
it the material component for the phoenix spell.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.32 2001/05/25 01:44:24 guerrand Exp $";
a1050 1
	act("$n shimmers and fades ... and vanishes.",ch,NULL,NULL,TO_ROOM,FALSE);
@


1.32
log
@(G)
Fixed a superfluous warning from the last build.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.31 2001/05/25 01:35:14 guerrand Exp $";
d69 1
d102 1
d1036 27
@


1.31
log
@Guerrand:
* Added a new magelab type.
* Made it so immortals can give things while wizi
* Imprroved AI for the Yinn monk
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.30 2001/04/09 01:30:26 mud Exp $";
d35 1
d850 1
a850 1
	return;
@


1.30
log
@Made looting of non-treasure items limited to 4 from a corpse.
Also made group mates and stuff able to loot all from your corpse
to save your ass.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.29 2001/02/10 03:31:30 mud Exp $";
d784 1
a784 7
    /* VICIOUS!  mob heals itself */
    if ( ch->hit < ( ch->max_hit / 4 ) && ( ch->mana-- >= -10 ) )
    {
	spell = "heal";
	target = 1; /* True, mob is casting on itself */
    }
    else /* And spells itself up, in combat, even */
d796 5
d811 2
a812 2
    if ( IS_SET(victim->act,PLR_VAMP) && !IS_NPC(victim)
	 && number_percent() < 35 )
d823 1
a823 1
	switch ( dice(1,10) )
d825 11
a835 9
	case 1 :  spell = "blindness";		break;
	case 2 :  spell = "slow";		break;
	case 3 :  spell = "curse";		break;
	case 4 :  spell = "plague";		break;
	case 5 :  spell = "weaken";		break;
	case 6 :  spell = "faerie fire";	break;
	case 7 :  spell = "turn undead";	break;
	case 8 :  spell = "acid blast";		break;
	case 9 :  spell = "chain lightning";	break;
d841 1
a841 1
	return FALSE;
d844 7
a850 1
	spell = "acid blast";
@


1.29
log
@Proper definition of a var
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.28 2000/08/20 01:28:10 mud Exp $";
d1364 1
a1364 1
	if ( !IS_SET( trash->wear_flags, ITEM_TAKE ) || !can_loot(ch,trash))
@


1.28
log
@gaurds dont go off on highlanders
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.27 2000/08/20 00:45:37 mud Exp $";
d1052 1
a1052 1
   extern social_count;
@


1.27
log
@Highlanders not screamed at by guards
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.26 2000/04/18 19:51:07 mud Exp $";
d1311 1
a1311 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) && !clanwar_winner(victim) )
d1314 1
a1314 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) && !clanwar_winner(victim) )
@


1.26
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.25 2000/04/17 22:00:54 mud Exp $";
d1248 1
a1248 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) && !clanwar_winner(victim) )
d1251 1
a1251 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) && !clanwar_winner(victim) )
@


1.25
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.24 2000/02/24 03:13:01 mud Exp $";
d174 3
a176 3
	act( social_table[cmd].others_found, ch, NULL, vch, TO_NOTVICT );
	act( social_table[cmd].char_found, ch, NULL, vch, TO_CHAR );
	act( social_table[cmd].vict_found, ch, NULL, vch, TO_VICT );
d240 1
a240 1
    	act(message,ch,NULL,victim,TO_ALL);
d299 1
a299 1
    	act(message,ch,NULL,victim,TO_ALL);
d338 2
a339 2
	act("You blow down hard on $p.",ch,obj,NULL,TO_CHAR);
	act("$n blows on $p, ***WHEEEEEEEEEEEET***",ch,obj,NULL,TO_ROOM);
d375 1
a375 1
	act(message,ch,NULL,NULL,TO_ALL);
d417 1
a417 1
                     ch, NULL, victim, TO_VICT);
d419 1
a419 1
                     ch, NULL, victim, TO_CHAR);
d421 1
a421 1
                     ch, NULL, victim, TO_NOTVICT);
d556 1
a556 1
	act( "$n utters the word 'abrazak'.", ch, NULL, NULL, TO_ROOM );
d561 1
a561 1
	act( "$n utters the word 'fido'.", ch, NULL, NULL, TO_ROOM );
d566 1
a566 1
	act("$n utters the words 'judicandus noselacri'.",ch,NULL,NULL,TO_ROOM);
d572 1
a572 1
	act("$n utters the words 'judicandus dies'.", ch,NULL, NULL, TO_ROOM );
d578 1
a578 1
	act( "$n utters the words 'judicandus sausabru'.",ch,NULL,NULL,TO_ROOM);
d584 1
a584 1
	act("$n utters the word 'candusima'.", ch, NULL, NULL, TO_ROOM );
d589 1
a589 1
	act("$n utters the words 'judicandus eugzagz'.",ch,NULL,NULL,TO_ROOM);
d595 1
a595 1
	act("$n utters the words 'yummy tummy'.",ch,NULL,NULL,TO_ROOM);
d754 1
a754 1
		ch, NULL, NULL, TO_ROOM);
d759 1
a759 1
	    act("$n shifts and phases briefly.",ch,NULL,NULL,TO_ROOM);
d769 1
a769 1
    act("The air shimmers, and then $n fades away.",ch, NULL, NULL, TO_ROOM);
d1084 2
a1085 2
      act( social_table[rnd_social].others_auto,   ch, NULL, ch, TO_ROOM );
      act( social_table[rnd_social].char_auto,     ch, NULL, ch, TO_CHAR );
d1104 2
a1105 2
      act( social_table[rnd_social].others_no_arg, ch, NULL, NULL, TO_ROOM );
      act( social_table[rnd_social].char_no_arg, ch, NULL, NULL, TO_CHAR );
d1128 1
a1128 1
                  NULL, victim, TO_NOTVICT );
d1130 1
a1130 1
                  NULL, victim, TO_CHAR    );
d1132 1
a1132 1
                  NULL, victim, TO_VICT    );
d1138 1
a1138 1
                        NULL, NULL, TO_ROOM );
d1140 1
a1140 1
                        NULL, NULL, TO_CHAR );
d1148 1
a1148 1
                NULL, NULL, TO_ROOM);
d1150 1
a1150 1
                NULL, NULL, TO_ROOM);
d1152 1
a1152 1
                NULL, NULL, TO_CHAR);
d1161 2
a1162 2
                NULL, NULL, TO_ROOM);
        act( "You clone yourself!", ch, NULL, NULL, TO_CHAR);
d1176 1
a1176 1
                NULL, NULL, TO_ROOM );
d1178 1
a1178 1
                NULL, NULL, TO_ROOM );
d1180 1
a1180 1
                ch, NULL, NULL, TO_CHAR );
d1182 1
a1182 1
                attention.", ch, NULL, NULL, TO_CHAR);
d1212 1
a1212 1
	act( "$n savagely devours a corpse.", ch, NULL, NULL, TO_ROOM );
d1282 1
a1282 1
	    ch, NULL, NULL, TO_ROOM );
d1345 1
a1345 1
	    ch, NULL, NULL, TO_ROOM );
d1370 1
a1370 1
	    act( "$n picks up some trash.", ch, NULL, NULL, TO_ROOM );
d1427 1
a1427 1
	act( "$n awakens and groans loudly.", ch, NULL, NULL, TO_ROOM );
d1432 1
a1432 1
	act( "$n lies down and falls asleep.", ch, NULL, NULL, TO_ROOM );
d1436 1
a1436 1
	act( "$n says 'Hello Honey!'", ch, NULL, NULL, TO_ROOM );
d1441 1
a1441 1
	    ch, NULL, NULL, TO_ROOM );
d1446 1
a1446 1
	    ch, NULL, NULL, TO_ROOM );
d1450 1
a1450 1
	act( "$n says 'Good day, citizens! Re-Elect Muggerud for Mayor!'", ch, NULL, NULL, TO_ROOM );
d1455 1
a1455 1
	    ch, NULL, NULL, TO_ROOM );
d1457 1
a1457 1
	act("$n says 'I'm glad I left the city gates open, one less thing to do!'",ch,NULL,NULL,TO_ROOM);
d1462 1
a1462 1
	    ch, NULL, NULL, TO_ROOM );
d1464 1
a1464 1
	act("$n says 'I hereby declare the city ... bah I'm too tired to close the gates!'",ch,NULL,NULL,TO_ROOM);
d1497 3
a1499 3
    act( "You bite $N!",  ch, NULL, victim, TO_CHAR    );
    act( "$n bites $N!",  ch, NULL, victim, TO_NOTVICT );
    act( "$n bites you!", ch, NULL, victim, TO_VICT    );
d1528 1
a1528 1
		ch, NULL, victim, TO_VICT );
d1530 1
a1530 1
		ch, NULL, victim, TO_NOTVICT );
@


1.24
log
@ const.c   made elves res mental instead of charm
 magic.c   removed the level+2 < victim->level in sleep, makes no sense
	   that someone two levels under has no chance to sleep you ,
	   the level difference is taken into accoutn in saves_vs_spell

 update.c    2* gains in gain_exp until refresh
 speical.c   removed avarice as clan war winner, put in valor for now

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.23 2000/01/23 23:21:25 mud Exp $";
d544 2
a545 1
	if ( victim != ch && can_see( ch, victim ) && number_bits( 1 ) == 0 
d1522 1
a1522 1
	||   !can_see(ch,victim))
@


1.23
log
@i spec.c    changed name of clan winner
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.22 2000/01/20 23:33:35 mud Exp $";
d976 1
a976 1
    clanwinner = clan_lookup("avarice");
@


1.22
log
@second post attempt

update.c
	advance_level: added real_size variable
			hp gains based on size of actual race and not infalted
			size created by stature

fight.c
	changed code to actually reflect what help file says about myrmidon

	in defensive skills (parry, dodge, shieldblock)
	chance is the chance of a victim to dodge an attack
	so the myrm_pen should be chance += myrm_pen instead of
	the chance-= myrm_pen., I swithced it to +=

	same principal for attacks(2nd, 3rd) check_myrm should imporve
	chance to land but this function always returned a negative.
	return from check_myrm is now positive
	return = blan - skill instead of the previous
	return = skill- blah

special.c
	add include lookup.h for the new function clanwar_winner that uses
	clan_lookup.

	clanwar_winner returns true if the char is from that clan
	name of the winning clan has to be set every month, shitty way but
	i didn't want to set it in a structure for now.

	clanwar_winner was added to spec_exec , spec_guard_l & d

comm.c
	mod to stat customization, every increase in stat is now equal between races
	You want to increase str 3 times, you pay the same if dragon or faerie.

	added function calc_stat_cost
	calculates the cost to increase a stat for that race.

	added this function where needed to calculate cost of an increase

	primary and secondary bonuses are based on OLDCLASS now.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.21 1999/12/08 21:53:41 mud Exp $";
d976 1
a976 1
    clanwinner = clan_lookup("valor");
@


1.21
log
@ Guards and Executioners will stand before attacking
 -Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.20 1999/12/08 21:41:38 mud Exp $";
d31 1
d966 21
d1003 1
a1003 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) )
d1006 1
a1006 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) )
d1247 1
a1247 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) )
d1250 1
a1250 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) )
d1310 1
a1310 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) )
d1313 1
a1313 1
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) )
@


1.20
log
@Back out changes
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.16 1999/08/10 23:00:56 mud Exp $";
d41 1
d994 3
d1242 3
d1255 3
d1305 3
d1318 3
@


1.19
log
@declare do_stand
-Poquah
----------------------------------------------------------------------
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.18 1999/12/08 21:35:46 mud Exp $";
a40 1
DECLARE_DO_FUN(do_stand);
a992 3
    if (ch->position < POS_STANDING)                                                                           
	do_stand(ch,"");   

a1237 3
        if (ch->position < POS_STANDING)                                                             
           do_stand(ch,"");   

a1247 3
        if (ch->position < POS_STANDING)                                                             
           do_stand(ch,"");   

a1294 3
        if (ch->position < POS_STANDING)                                                             
           do_stand(ch,"");   

a1304 3
        if (ch->position < POS_STANDING)                                                             
           do_stand(ch,"");   

@


1.18
log
@Add stand to spec_gaurds too
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.17 1999/12/08 21:07:47 mud Exp $";
d41 1
@


1.17
log
@Hassan can stand back up after Hold Person wears off
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.16 1999/08/10 23:00:56 mud Exp $";
d1241 3
d1254 3
d1304 3
d1317 3
@


1.16
log
@Added a bit to hassan's special
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.15 1999/07/14 18:14:10 mud Exp $";
d992 3
@


1.15
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: special.c,v 1.14 1999/05/23 06:20:12 mud Exp $";
d985 3
@


1.14
log
@Made the yinnish monk meaner for my own amusement
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.13 1999/04/15 01:38:40 mud Exp $ */
@


1.13
log
@Removed Mayor closing gates
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.12 1999/04/01 07:49:02 mud Exp $ */
d782 1
a782 1
    if ( ch->hit < ( ch->max_hit / 4 ) && ( ch->mana - 50 >= 0 ) )
a784 1
	ch->mana -= 50; /* Actually going to use mob mana */
d813 2
a814 1
    if ( victim->mana > ( victim->max_mana / 8 ) )
d817 3
d838 3
@


1.12
log
@April Fools Mayor change
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.11 1999/03/27 04:05:17 mud Exp $ */
d1406 1
a1406 1
	act( "$n says 'I hereby declare the city of Midgaard open!'",
d1408 2
d1413 1
a1413 1
	act( "$n says 'I hereby declare the city of Midgaard closed!'",
d1415 2
d1421 1
a1421 1
	do_open( ch, "gate" );
d1425 1
a1425 1
	do_close( ch, "gate" );
@


1.11
log
@Orb of turning on other spec_cast_*
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.10 1999/03/27 03:45:35 mud Exp $ */
d1402 1
a1402 1
	act( "$n says 'Good day, citizens!'", ch, NULL, NULL, TO_ROOM );
@


1.10
log
@Moved orb check before spell cast
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.9 1999/03/27 03:36:18 mud Exp $ */
d687 6
d719 6
d891 6
d948 6
@


1.9
log
@yntax error in spec_cast_cleric
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.8 1999/03/27 03:33:24 mud Exp $ */
a650 2
    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);

d655 1
a655 1
        return TRUE;
d657 2
@


1.8
log
@Added Orb of Turning Check to spec_cast_cleric to test
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.7 1999/03/04 20:16:05 mud Exp $ */
d653 1
a653 1
    if is_affected(victim, skill_lookup("orb of turning")) 
@


1.7
log
@Took out old race wars skin color bigotry for spec_guard()
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.6 1998/10/19 05:50:12 mud Exp $ */
d652 7
d660 1
@


1.6
log
@Feast thing
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.5 1998/10/10 03:53:36 mud Exp $ */
d1180 1
a1180 2
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) 
		&& pc_race_table[victim->race].color != RACE_DARK )
d1183 1
a1183 2
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) 
		&& pc_race_table[victim->race].color != RACE_DARK )
d1237 1
a1237 2
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_KILLER) 
		&& pc_race_table[victim->race].color != RACE_LIGHT )
d1240 1
a1240 2
	if ( !IS_NPC(victim) && IS_SET(victim->act, PLR_THIEF) 
		&& pc_race_table[victim->race].color != RACE_LIGHT )
@


1.5
log
@Finished implementatino of altirin undead special
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.4 1998/10/10 02:38:36 mud Exp $ */
d589 7
@


1.4
log
@Silly bug fixed
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.3 1998/10/10 02:26:09 mud Exp $ */
d710 1
d713 2
d739 1
a739 1
    act("The air radiates heat as it swallows $n.", ch, NULL, NULL, TO_ROOM);
@


1.3
log
@added apsecial for 51 obstacle course
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.2 1998/08/10 05:32:18 mud Exp $ */
d733 3
@


1.2
log
@* Added wound transfer spell
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: special.c,v 1.1 1998/06/16 17:49:45 mud Exp $ */
d73 1
d105 1
d702 35
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d72 1
d103 1
d191 1
a191 1

d700 72
@
