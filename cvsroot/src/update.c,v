head	1.313;
access;
symbols;
locks; strict;
comment	@ * @;


1.313
date	2004.09.28.01.23.39;	author boogums;	state Exp;
branches;
next	1.312;

1.312
date	2004.09.28.01.06.25;	author boogums;	state Exp;
branches;
next	1.311;

1.311
date	2004.09.28.01.00.46;	author boogums;	state Exp;
branches;
next	1.310;

1.310
date	2004.06.21.20.06.55;	author boogums;	state Exp;
branches;
next	1.309;

1.309
date	2004.04.03.18.05.23;	author boogums;	state Exp;
branches;
next	1.308;

1.308
date	2004.04.03.17.52.02;	author boogums;	state Exp;
branches;
next	1.307;

1.307
date	2004.04.03.06.03.23;	author boogums;	state Exp;
branches;
next	1.306;

1.306
date	2004.04.03.05.58.42;	author boogums;	state Exp;
branches;
next	1.305;

1.305
date	2004.04.03.05.47.25;	author boogums;	state Exp;
branches;
next	1.304;

1.304
date	2004.04.03.05.43.08;	author boogums;	state Exp;
branches;
next	1.303;

1.303
date	2004.04.03.05.35.11;	author boogums;	state Exp;
branches;
next	1.302;

1.302
date	2004.04.03.05.23.24;	author boogums;	state Exp;
branches;
next	1.301;

1.301
date	2004.04.03.05.18.59;	author boogums;	state Exp;
branches;
next	1.300;

1.300
date	2004.04.03.05.13.01;	author boogums;	state Exp;
branches;
next	1.299;

1.299
date	2004.04.03.05.08.55;	author boogums;	state Exp;
branches;
next	1.298;

1.298
date	2003.12.10.03.04.56;	author boogums;	state Exp;
branches;
next	1.297;

1.297
date	2003.12.07.23.29.40;	author boogums;	state Exp;
branches;
next	1.296;

1.296
date	2003.12.06.23.09.55;	author boogums;	state Exp;
branches;
next	1.295;

1.295
date	2003.12.06.22.41.00;	author boogums;	state Exp;
branches;
next	1.294;

1.294
date	2003.12.06.22.33.48;	author boogums;	state Exp;
branches;
next	1.293;

1.293
date	2003.12.06.22.14.33;	author boogums;	state Exp;
branches;
next	1.292;

1.292
date	2003.12.04.03.35.55;	author boogums;	state Exp;
branches;
next	1.291;

1.291
date	2003.11.22.15.29.41;	author boogums;	state Exp;
branches;
next	1.290;

1.290
date	2003.11.22.15.08.33;	author boogums;	state Exp;
branches;
next	1.289;

1.289
date	2003.09.20.18.34.20;	author boogums;	state Exp;
branches;
next	1.288;

1.288
date	2003.09.15.17.25.12;	author mud;	state Exp;
branches;
next	1.287;

1.287
date	2003.07.16.20.20.15;	author ndagger;	state Exp;
branches;
next	1.286;

1.286
date	2003.07.16.20.08.22;	author ndagger;	state Exp;
branches;
next	1.285;

1.285
date	2003.07.16.19.57.38;	author ndagger;	state Exp;
branches;
next	1.284;

1.284
date	2003.06.29.03.44.56;	author boogums;	state Exp;
branches;
next	1.283;

1.283
date	2003.06.07.21.25.50;	author boogums;	state Exp;
branches;
next	1.282;

1.282
date	2003.04.14.05.54.08;	author ndagger;	state Exp;
branches;
next	1.281;

1.281
date	2003.04.14.04.36.14;	author ndagger;	state Exp;
branches;
next	1.280;

1.280
date	2003.03.11.03.01.15;	author boogums;	state Exp;
branches;
next	1.279;

1.279
date	2003.03.08.21.42.47;	author boogums;	state Exp;
branches;
next	1.278;

1.278
date	2003.01.24.04.47.11;	author boogums;	state Exp;
branches;
next	1.277;

1.277
date	2003.01.24.03.24.13;	author boogums;	state Exp;
branches;
next	1.276;

1.276
date	2003.01.24.03.21.19;	author boogums;	state Exp;
branches;
next	1.275;

1.275
date	2002.12.09.18.47.36;	author boogums;	state Exp;
branches;
next	1.274;

1.274
date	2002.12.09.03.01.07;	author boogums;	state Exp;
branches;
next	1.273;

1.273
date	2002.12.08.00.59.40;	author boogums;	state Exp;
branches;
next	1.272;

1.272
date	2002.12.05.05.16.57;	author boogums;	state Exp;
branches;
next	1.271;

1.271
date	2002.11.26.06.07.38;	author boogums;	state Exp;
branches;
next	1.270;

1.270
date	2002.11.26.05.57.31;	author boogums;	state Exp;
branches;
next	1.269;

1.269
date	2002.11.26.05.35.27;	author boogums;	state Exp;
branches;
next	1.268;

1.268
date	2002.11.11.18.20.52;	author rusty;	state Exp;
branches;
next	1.267;

1.267
date	2002.10.25.15.39.31;	author rusty;	state Exp;
branches;
next	1.266;

1.266
date	2002.05.23.18.27.02;	author rusty;	state Exp;
branches;
next	1.265;

1.265
date	2002.05.23.18.18.40;	author rusty;	state Exp;
branches;
next	1.264;

1.264
date	2002.05.22.21.30.20;	author rusty;	state Exp;
branches;
next	1.263;

1.263
date	2002.05.22.18.00.42;	author rusty;	state Exp;
branches;
next	1.262;

1.262
date	2002.05.21.20.20.59;	author rage;	state Exp;
branches;
next	1.261;

1.261
date	2002.04.17.15.06.14;	author poquah;	state Exp;
branches;
next	1.260;

1.260
date	2002.04.01.21.47.30;	author rusty;	state Exp;
branches;
next	1.259;

1.259
date	2002.03.13.03.02.26;	author rusty;	state Exp;
branches;
next	1.258;

1.258
date	2002.03.12.15.55.24;	author rusty;	state Exp;
branches;
next	1.257;

1.257
date	2002.03.12.03.01.08;	author rusty;	state Exp;
branches;
next	1.256;

1.256
date	2002.03.09.19.14.30;	author rusty;	state Exp;
branches;
next	1.255;

1.255
date	2002.02.28.18.32.36;	author rusty;	state Exp;
branches;
next	1.254;

1.254
date	2002.02.11.18.34.11;	author poquah;	state Exp;
branches;
next	1.253;

1.253
date	2002.01.22.20.33.29;	author rage;	state Exp;
branches;
next	1.252;

1.252
date	2002.01.20.21.09.09;	author rage;	state Exp;
branches;
next	1.251;

1.251
date	2001.12.01.23.16.58;	author poquah;	state Exp;
branches;
next	1.250;

1.250
date	2001.11.25.01.35.56;	author mud;	state Exp;
branches;
next	1.249;

1.249
date	2001.11.25.01.26.39;	author rusty;	state Exp;
branches;
next	1.248;

1.248
date	2001.11.23.16.25.29;	author poquah;	state Exp;
branches;
next	1.247;

1.247
date	2001.11.23.16.17.16;	author poquah;	state Exp;
branches;
next	1.246;

1.246
date	2001.11.06.23.39.18;	author rage;	state Exp;
branches;
next	1.245;

1.245
date	2001.10.22.18.09.18;	author rusty;	state Exp;
branches;
next	1.244;

1.244
date	2001.10.21.20.35.44;	author rage;	state Exp;
branches;
next	1.243;

1.243
date	2001.10.14.04.08.44;	author rage;	state Exp;
branches;
next	1.242;

1.242
date	2001.10.13.02.11.59;	author rage;	state Exp;
branches;
next	1.241;

1.241
date	2001.09.27.22.07.42;	author rage;	state Exp;
branches;
next	1.240;

1.240
date	2001.09.20.02.21.42;	author rage;	state Exp;
branches;
next	1.239;

1.239
date	2001.09.17.23.26.22;	author rage;	state Exp;
branches;
next	1.238;

1.238
date	2001.08.24.00.42.19;	author guerrand;	state Exp;
branches;
next	1.237;

1.237
date	2001.08.09.14.25.38;	author rusty;	state Exp;
branches;
next	1.236;

1.236
date	2001.08.05.22.47.37;	author guerrand;	state Exp;
branches;
next	1.235;

1.235
date	2001.07.27.02.14.12;	author guerrand;	state Exp;
branches;
next	1.234;

1.234
date	2001.07.23.03.51.41;	author guerrand;	state Exp;
branches;
next	1.233;

1.233
date	2001.07.19.03.03.15;	author mud;	state Exp;
branches;
next	1.232;

1.232
date	2001.07.19.03.00.26;	author rusty;	state Exp;
branches;
next	1.231;

1.231
date	2001.07.15.19.57.21;	author rage;	state Exp;
branches;
next	1.230;

1.230
date	2001.07.15.02.19.33;	author guerrand;	state Exp;
branches;
next	1.229;

1.229
date	2001.07.15.01.18.40;	author guerrand;	state Exp;
branches;
next	1.228;

1.228
date	2001.07.11.17.16.21;	author rusty;	state Exp;
branches;
next	1.227;

1.227
date	2001.07.05.22.15.06;	author guerrand;	state Exp;
branches;
next	1.226;

1.226
date	2001.07.02.16.09.27;	author mud;	state Exp;
branches;
next	1.225;

1.225
date	2001.06.25.16.28.04;	author rusty;	state Exp;
branches;
next	1.224;

1.224
date	2001.06.16.15.24.15;	author rage;	state Exp;
branches;
next	1.223;

1.223
date	2001.06.15.02.27.52;	author guerrand;	state Exp;
branches;
next	1.222;

1.222
date	2001.06.14.00.41.22;	author guerrand;	state Exp;
branches;
next	1.221;

1.221
date	2001.06.11.00.04.04;	author rage;	state Exp;
branches;
next	1.220;

1.220
date	2001.06.07.04.15.42;	author guerrand;	state Exp;
branches;
next	1.219;

1.219
date	2001.05.31.00.05.11;	author guerrand;	state Exp;
branches;
next	1.218;

1.218
date	2001.05.30.03.09.09;	author guerrand;	state Exp;
branches;
next	1.217;

1.217
date	2001.05.30.02.17.00;	author guerrand;	state Exp;
branches;
next	1.216;

1.216
date	2001.05.30.01.54.00;	author guerrand;	state Exp;
branches;
next	1.215;

1.215
date	2001.04.09.18.30.39;	author mud;	state Exp;
branches;
next	1.214;

1.214
date	2001.04.09.01.30.27;	author mud;	state Exp;
branches;
next	1.213;

1.213
date	2001.03.20.17.44.34;	author mud;	state Exp;
branches;
next	1.212;

1.212
date	2001.03.05.22.11.14;	author mud;	state Exp;
branches;
next	1.211;

1.211
date	2001.03.03.18.57.15;	author mud;	state Exp;
branches;
next	1.210;

1.210
date	2001.03.03.18.53.59;	author mud;	state Exp;
branches;
next	1.209;

1.209
date	2001.02.10.03.57.10;	author mud;	state Exp;
branches;
next	1.208;

1.208
date	2001.02.10.03.42.42;	author mud;	state Exp;
branches;
next	1.207;

1.207
date	2001.02.10.03.23.42;	author mud;	state Exp;
branches;
next	1.206;

1.206
date	2001.02.10.03.10.11;	author mud;	state Exp;
branches;
next	1.205;

1.205
date	2001.02.09.22.48.39;	author mud;	state Exp;
branches;
next	1.204;

1.204
date	2001.02.09.22.18.55;	author mud;	state Exp;
branches;
next	1.203;

1.203
date	2001.02.09.22.15.32;	author mud;	state Exp;
branches;
next	1.202;

1.202
date	2000.12.25.21.51.20;	author mud;	state Exp;
branches;
next	1.201;

1.201
date	2000.12.17.05.12.30;	author mud;	state Exp;
branches;
next	1.200;

1.200
date	2000.12.15.20.01.14;	author mud;	state Exp;
branches;
next	1.199;

1.199
date	2000.12.15.04.47.18;	author mud;	state Exp;
branches;
next	1.198;

1.198
date	2000.12.15.04.32.08;	author mud;	state Exp;
branches;
next	1.197;

1.197
date	2000.12.15.04.24.59;	author mud;	state Exp;
branches;
next	1.196;

1.196
date	2000.12.15.03.56.50;	author mud;	state Exp;
branches;
next	1.195;

1.195
date	2000.12.09.07.05.51;	author mud;	state Exp;
branches;
next	1.194;

1.194
date	2000.12.07.06.12.12;	author mud;	state Exp;
branches;
next	1.193;

1.193
date	2000.12.07.05.46.14;	author mud;	state Exp;
branches;
next	1.192;

1.192
date	2000.12.06.20.32.03;	author mud;	state Exp;
branches;
next	1.191;

1.191
date	2000.12.06.05.13.25;	author mud;	state Exp;
branches;
next	1.190;

1.190
date	2000.12.03.03.24.05;	author mud;	state Exp;
branches;
next	1.189;

1.189
date	2000.10.16.23.05.31;	author mud;	state Exp;
branches;
next	1.188;

1.188
date	2000.09.02.22.55.58;	author mud;	state Exp;
branches;
next	1.187;

1.187
date	2000.08.29.03.51.57;	author mud;	state Exp;
branches;
next	1.186;

1.186
date	2000.08.26.18.38.13;	author mud;	state Exp;
branches;
next	1.185;

1.185
date	2000.08.24.20.11.17;	author mud;	state Exp;
branches;
next	1.184;

1.184
date	2000.08.20.00.57.43;	author mud;	state Exp;
branches;
next	1.183;

1.183
date	2000.08.20.00.34.58;	author mud;	state Exp;
branches;
next	1.182;

1.182
date	2000.08.20.00.11.26;	author mud;	state Exp;
branches;
next	1.181;

1.181
date	2000.08.17.15.41.18;	author mud;	state Exp;
branches;
next	1.180;

1.180
date	2000.08.12.18.26.03;	author mud;	state Exp;
branches;
next	1.179;

1.179
date	2000.07.25.20.13.17;	author mud;	state Exp;
branches;
next	1.178;

1.178
date	2000.07.25.20.06.38;	author mud;	state Exp;
branches;
next	1.177;

1.177
date	2000.07.18.00.56.55;	author mud;	state Exp;
branches;
next	1.176;

1.176
date	2000.07.04.00.14.00;	author mud;	state Exp;
branches;
next	1.175;

1.175
date	2000.07.04.00.07.13;	author mud;	state Exp;
branches;
next	1.174;

1.174
date	2000.07.04.00.05.14;	author mud;	state Exp;
branches;
next	1.173;

1.173
date	2000.06.28.20.46.05;	author mud;	state Exp;
branches;
next	1.172;

1.172
date	2000.06.14.01.01.11;	author mud;	state Exp;
branches;
next	1.171;

1.171
date	2000.05.29.19.37.07;	author mud;	state Exp;
branches;
next	1.170;

1.170
date	2000.05.27.02.44.13;	author mud;	state Exp;
branches;
next	1.169;

1.169
date	2000.05.26.01.46.31;	author mud;	state Exp;
branches;
next	1.168;

1.168
date	2000.05.25.03.26.25;	author mud;	state Exp;
branches;
next	1.167;

1.167
date	2000.05.25.03.06.08;	author mud;	state Exp;
branches;
next	1.166;

1.166
date	2000.05.24.02.36.46;	author mud;	state Exp;
branches;
next	1.165;

1.165
date	2000.05.24.00.25.13;	author mud;	state Exp;
branches;
next	1.164;

1.164
date	2000.05.21.04.47.47;	author mud;	state Exp;
branches;
next	1.163;

1.163
date	2000.05.21.01.17.15;	author mud;	state Exp;
branches;
next	1.162;

1.162
date	2000.05.21.01.11.05;	author mud;	state Exp;
branches;
next	1.161;

1.161
date	2000.05.21.01.10.01;	author mud;	state Exp;
branches;
next	1.160;

1.160
date	2000.05.21.01.09.05;	author mud;	state Exp;
branches;
next	1.159;

1.159
date	2000.05.21.00.28.58;	author mud;	state Exp;
branches;
next	1.158;

1.158
date	2000.05.20.23.48.00;	author mud;	state Exp;
branches;
next	1.157;

1.157
date	2000.05.20.02.38.37;	author mud;	state Exp;
branches;
next	1.156;

1.156
date	2000.05.20.02.36.16;	author mud;	state Exp;
branches;
next	1.155;

1.155
date	2000.05.16.00.56.02;	author mud;	state Exp;
branches;
next	1.154;

1.154
date	2000.05.14.00.41.30;	author mud;	state Exp;
branches;
next	1.153;

1.153
date	2000.05.14.00.37.51;	author mud;	state Exp;
branches;
next	1.152;

1.152
date	2000.05.13.22.44.53;	author mud;	state Exp;
branches;
next	1.151;

1.151
date	2000.05.13.22.37.27;	author mud;	state Exp;
branches;
next	1.150;

1.150
date	2000.05.13.21.55.19;	author mud;	state Exp;
branches;
next	1.149;

1.149
date	2000.04.22.14.18.02;	author mud;	state Exp;
branches;
next	1.148;

1.148
date	2000.04.22.06.18.29;	author mud;	state Exp;
branches;
next	1.147;

1.147
date	2000.04.22.06.12.22;	author mud;	state Exp;
branches;
next	1.146;

1.146
date	2000.04.22.05.56.20;	author mud;	state Exp;
branches;
next	1.145;

1.145
date	2000.04.22.05.30.48;	author mud;	state Exp;
branches;
next	1.144;

1.144
date	2000.04.22.04.57.11;	author mud;	state Exp;
branches;
next	1.143;

1.143
date	2000.04.22.04.54.26;	author mud;	state Exp;
branches;
next	1.142;

1.142
date	2000.04.18.20.33.52;	author mud;	state Exp;
branches;
next	1.141;

1.141
date	2000.04.18.19.51.08;	author mud;	state Exp;
branches;
next	1.140;

1.140
date	2000.04.18.05.07.26;	author mud;	state Exp;
branches;
next	1.139;

1.139
date	2000.04.18.05.03.33;	author mud;	state Exp;
branches;
next	1.138;

1.138
date	2000.04.18.04.58.41;	author mud;	state Exp;
branches;
next	1.137;

1.137
date	2000.04.17.22.00.54;	author mud;	state Exp;
branches;
next	1.136;

1.136
date	2000.03.31.16.33.44;	author mud;	state Exp;
branches;
next	1.135;

1.135
date	2000.03.06.16.50.25;	author mud;	state Exp;
branches;
next	1.134;

1.134
date	2000.03.06.15.59.24;	author mud;	state Exp;
branches;
next	1.133;

1.133
date	2000.03.03.23.17.57;	author mud;	state Exp;
branches;
next	1.132;

1.132
date	2000.02.25.00.56.48;	author mud;	state Exp;
branches;
next	1.131;

1.131
date	2000.02.24.03.13.02;	author mud;	state Exp;
branches;
next	1.130;

1.130
date	2000.02.24.01.00.30;	author mud;	state Exp;
branches;
next	1.129;

1.129
date	2000.02.23.21.40.13;	author mud;	state Exp;
branches;
next	1.128;

1.128
date	2000.02.23.17.59.33;	author mud;	state Exp;
branches;
next	1.127;

1.127
date	2000.02.23.17.37.39;	author mud;	state Exp;
branches;
next	1.126;

1.126
date	2000.02.18.19.10.24;	author mud;	state Exp;
branches;
next	1.125;

1.125
date	2000.02.10.03.36.00;	author mud;	state Exp;
branches;
next	1.124;

1.124
date	2000.02.10.03.07.04;	author mud;	state Exp;
branches;
next	1.123;

1.123
date	2000.02.10.03.05.12;	author mud;	state Exp;
branches;
next	1.122;

1.122
date	2000.02.10.02.40.05;	author mud;	state Exp;
branches;
next	1.121;

1.121
date	2000.02.09.21.29.45;	author mud;	state Exp;
branches;
next	1.120;

1.120
date	2000.02.01.20.32.38;	author mud;	state Exp;
branches;
next	1.119;

1.119
date	2000.01.27.01.57.47;	author mud;	state Exp;
branches;
next	1.118;

1.118
date	2000.01.22.00.12.18;	author mud;	state Exp;
branches;
next	1.117;

1.117
date	2000.01.20.23.33.36;	author mud;	state Exp;
branches;
next	1.116;

1.116
date	2000.01.11.17.53.53;	author mud;	state Exp;
branches;
next	1.115;

1.115
date	2000.01.11.01.35.34;	author mud;	state Exp;
branches;
next	1.114;

1.114
date	2000.01.11.00.54.54;	author mud;	state Exp;
branches;
next	1.113;

1.113
date	2000.01.08.22.07.12;	author mud;	state Exp;
branches;
next	1.112;

1.112
date	2000.01.08.21.57.55;	author mud;	state Exp;
branches;
next	1.111;

1.111
date	2000.01.08.07.27.56;	author mud;	state Exp;
branches;
next	1.110;

1.110
date	99.12.17.00.02.16;	author mud;	state Exp;
branches;
next	1.109;

1.109
date	99.12.08.22.00.03;	author mud;	state Exp;
branches;
next	1.108;

1.108
date	99.12.01.21.21.05;	author mud;	state Exp;
branches;
next	1.107;

1.107
date	99.11.26.20.24.41;	author mud;	state Exp;
branches;
next	1.106;

1.106
date	99.11.19.19.26.21;	author mud;	state Exp;
branches;
next	1.105;

1.105
date	99.11.08.18.44.32;	author mud;	state Exp;
branches;
next	1.104;

1.104
date	99.11.07.01.15.02;	author mud;	state Exp;
branches;
next	1.103;

1.103
date	99.11.07.01.07.58;	author mud;	state Exp;
branches;
next	1.102;

1.102
date	99.11.07.00.56.05;	author mud;	state Exp;
branches;
next	1.101;

1.101
date	99.11.05.21.14.55;	author mud;	state Exp;
branches;
next	1.100;

1.100
date	99.11.04.17.58.39;	author mud;	state Exp;
branches;
next	1.99;

1.99
date	99.11.03.02.43.34;	author mud;	state Exp;
branches;
next	1.98;

1.98
date	99.11.03.02.20.35;	author mud;	state Exp;
branches;
next	1.97;

1.97
date	99.11.02.22.08.27;	author mud;	state Exp;
branches;
next	1.96;

1.96
date	99.10.31.03.06.00;	author mud;	state Exp;
branches;
next	1.95;

1.95
date	99.10.31.03.04.51;	author mud;	state Exp;
branches;
next	1.94;

1.94
date	99.10.20.21.45.31;	author mud;	state Exp;
branches;
next	1.93;

1.93
date	99.10.08.20.43.43;	author mud;	state Exp;
branches;
next	1.92;

1.92
date	99.10.08.20.36.27;	author mud;	state Exp;
branches;
next	1.91;

1.91
date	99.10.08.20.16.11;	author mud;	state Exp;
branches;
next	1.90;

1.90
date	99.10.02.00.09.11;	author mud;	state Exp;
branches;
next	1.89;

1.89
date	99.09.16.03.47.12;	author mud;	state Exp;
branches;
next	1.88;

1.88
date	99.09.16.02.41.10;	author mud;	state Exp;
branches;
next	1.87;

1.87
date	99.09.06.03.37.32;	author mud;	state Exp;
branches;
next	1.86;

1.86
date	99.09.03.19.26.06;	author mud;	state Exp;
branches;
next	1.85;

1.85
date	99.08.26.16.37.55;	author mud;	state Exp;
branches;
next	1.84;

1.84
date	99.08.23.03.34.52;	author mud;	state Exp;
branches;
next	1.83;

1.83
date	99.08.21.21.22.47;	author mud;	state Exp;
branches;
next	1.82;

1.82
date	99.08.19.16.30.39;	author mud;	state Exp;
branches;
next	1.81;

1.81
date	99.08.12.01.04.02;	author mud;	state Exp;
branches;
next	1.80;

1.80
date	99.08.11.20.38.37;	author mud;	state Exp;
branches;
next	1.79;

1.79
date	99.08.09.22.08.32;	author mud;	state Exp;
branches;
next	1.78;

1.78
date	99.07.23.20.01.14;	author mud;	state Exp;
branches;
next	1.77;

1.77
date	99.07.23.02.57.42;	author mud;	state Exp;
branches;
next	1.76;

1.76
date	99.07.22.01.07.30;	author mud;	state Exp;
branches;
next	1.75;

1.75
date	99.07.14.19.00.21;	author mud;	state Exp;
branches;
next	1.74;

1.74
date	99.07.14.18.48.27;	author mud;	state Exp;
branches;
next	1.73;

1.73
date	99.07.14.18.14.13;	author mud;	state Exp;
branches;
next	1.72;

1.72
date	99.07.10.00.11.39;	author mud;	state Exp;
branches;
next	1.71;

1.71
date	99.07.05.21.58.24;	author mud;	state Exp;
branches;
next	1.70;

1.70
date	99.07.05.21.54.38;	author mud;	state Exp;
branches;
next	1.69;

1.69
date	99.06.20.20.29.25;	author mud;	state Exp;
branches;
next	1.68;

1.68
date	99.06.11.23.40.43;	author mud;	state Exp;
branches;
next	1.67;

1.67
date	99.06.11.23.21.59;	author mud;	state Exp;
branches;
next	1.66;

1.66
date	99.05.19.05.29.27;	author mud;	state Exp;
branches;
next	1.65;

1.65
date	99.05.19.04.50.38;	author mud;	state Exp;
branches;
next	1.64;

1.64
date	99.05.19.04.48.09;	author mud;	state Exp;
branches;
next	1.63;

1.63
date	99.05.19.04.33.51;	author mud;	state Exp;
branches;
next	1.62;

1.62
date	99.05.19.00.05.15;	author mud;	state Exp;
branches;
next	1.61;

1.61
date	99.05.18.19.04.33;	author mud;	state Exp;
branches;
next	1.60;

1.60
date	99.05.18.19.01.30;	author mud;	state Exp;
branches;
next	1.59;

1.59
date	99.05.18.18.58.09;	author mud;	state Exp;
branches;
next	1.58;

1.58
date	99.05.18.18.33.10;	author mud;	state Exp;
branches;
next	1.57;

1.57
date	99.05.18.18.19.01;	author mud;	state Exp;
branches;
next	1.56;

1.56
date	99.05.17.05.52.51;	author mud;	state Exp;
branches;
next	1.55;

1.55
date	99.05.17.05.49.10;	author mud;	state Exp;
branches;
next	1.54;

1.54
date	99.05.15.16.39.06;	author mud;	state Exp;
branches;
next	1.53;

1.53
date	99.05.05.21.54.16;	author mud;	state Exp;
branches;
next	1.52;

1.52
date	99.05.04.10.43.23;	author mud;	state Exp;
branches;
next	1.51;

1.51
date	99.05.04.01.08.33;	author mud;	state Exp;
branches;
next	1.50;

1.50
date	99.05.04.01.04.17;	author mud;	state Exp;
branches;
next	1.49;

1.49
date	99.05.04.00.43.33;	author mud;	state Exp;
branches;
next	1.48;

1.48
date	99.05.03.08.00.23;	author mud;	state Exp;
branches;
next	1.47;

1.47
date	99.04.28.08.09.32;	author mud;	state Exp;
branches;
next	1.46;

1.46
date	99.04.26.07.54.47;	author mud;	state Exp;
branches;
next	1.45;

1.45
date	99.04.26.05.30.59;	author mud;	state Exp;
branches;
next	1.44;

1.44
date	99.04.24.13.32.18;	author mud;	state Exp;
branches;
next	1.43;

1.43
date	99.04.24.03.08.08;	author mud;	state Exp;
branches;
next	1.42;

1.42
date	99.04.24.02.04.52;	author mud;	state Exp;
branches;
next	1.41;

1.41
date	99.04.23.01.59.31;	author mud;	state Exp;
branches;
next	1.40;

1.40
date	99.04.23.00.09.41;	author mud;	state Exp;
branches;
next	1.39;

1.39
date	99.03.30.16.54.05;	author mud;	state Exp;
branches;
next	1.38;

1.38
date	99.03.30.16.51.05;	author mud;	state Exp;
branches;
next	1.37;

1.37
date	99.03.30.15.23.48;	author mud;	state Exp;
branches;
next	1.36;

1.36
date	99.03.29.19.12.14;	author mud;	state Exp;
branches;
next	1.35;

1.35
date	99.01.12.17.45.06;	author mud;	state Exp;
branches;
next	1.34;

1.34
date	99.01.06.20.07.07;	author mud;	state Exp;
branches;
next	1.33;

1.33
date	98.12.13.22.51.49;	author mud;	state Exp;
branches;
next	1.32;

1.32
date	98.12.12.01.20.58;	author mud;	state Exp;
branches;
next	1.31;

1.31
date	98.12.08.22.38.14;	author mud;	state Exp;
branches;
next	1.30;

1.30
date	98.12.08.01.54.15;	author mud;	state Exp;
branches;
next	1.29;

1.29
date	98.11.14.07.15.56;	author mud;	state Exp;
branches;
next	1.28;

1.28
date	98.10.30.15.27.18;	author mud;	state Exp;
branches;
next	1.27;

1.27
date	98.10.20.00.42.33;	author mud;	state Exp;
branches;
next	1.26;

1.26
date	98.10.13.23.07.45;	author mud;	state Exp;
branches;
next	1.25;

1.25
date	98.10.11.06.56.20;	author mud;	state Exp;
branches;
next	1.24;

1.24
date	98.10.11.00.26.38;	author mud;	state Exp;
branches;
next	1.23;

1.23
date	98.10.11.00.25.46;	author mud;	state Exp;
branches;
next	1.22;

1.22
date	98.10.08.14.47.27;	author mud;	state Exp;
branches;
next	1.21;

1.21
date	98.10.08.14.46.25;	author mud;	state Exp;
branches;
next	1.20;

1.20
date	98.10.08.14.14.26;	author mud;	state Exp;
branches;
next	1.19;

1.19
date	98.10.02.23.39.35;	author mud;	state Exp;
branches;
next	1.18;

1.18
date	98.09.20.07.46.20;	author mud;	state Exp;
branches;
next	1.17;

1.17
date	98.09.20.03.46.49;	author mud;	state Exp;
branches;
next	1.16;

1.16
date	98.08.30.03.33.41;	author mud;	state Exp;
branches;
next	1.15;

1.15
date	98.08.20.21.05.40;	author mud;	state Exp;
branches;
next	1.14;

1.14
date	98.08.13.16.22.26;	author mud;	state Exp;
branches;
next	1.13;

1.13
date	98.08.13.14.38.42;	author mud;	state Exp;
branches;
next	1.12;

1.12
date	98.08.13.05.24.14;	author mud;	state Exp;
branches;
next	1.11;

1.11
date	98.08.12.08.20.24;	author mud;	state Exp;
branches;
next	1.10;

1.10
date	98.08.10.19.41.26;	author mud;	state Exp;
branches;
next	1.9;

1.9
date	98.08.07.20.20.03;	author mud;	state Exp;
branches;
next	1.8;

1.8
date	98.08.05.10.25.33;	author mud;	state Exp;
branches;
next	1.7;

1.7
date	98.08.05.09.14.34;	author mud;	state Exp;
branches;
next	1.6;

1.6
date	98.08.05.06.59.15;	author mud;	state Exp;
branches;
next	1.5;

1.5
date	98.08.05.06.31.19;	author mud;	state Exp;
branches;
next	1.4;

1.4
date	98.08.05.04.44.58;	author mud;	state Exp;
branches;
next	1.3;

1.3
date	98.08.04.16.34.42;	author mud;	state Exp;
branches;
next	1.2;

1.2
date	98.07.31.20.37.46;	author mud;	state Exp;
branches;
next	1.1;

1.1
date	98.06.16.17.49.47;	author mud;	state Exp;
branches;
next	;


desc
@@


1.313
log
@whoops
corey
@
text
@/***************************************************************************
 *  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        *
 *  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   *
 *                                                                         *
 *  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          *
 *  Chastain, Michael Quan, and Mitchell Tse.                              *
 *                                                                         *
 *  In order to use any part of this Merc Diku Mud, you must comply with   *
 *  both the original Diku license in 'license.doc' as well the Merc       *
 *  license in 'license.txt'.  In particular, you may not remove either of *
 *  these copyright notices.                                               *
 *                                                                         *
 *  Much time and thought has gone into this software and you are          *
 *  benefitting.  We hope that you share your changes too.  What goes      *
 *  around, comes around.                                                  *
 ***************************************************************************/

static char rcsid[] = "$Id: update.c,v 1.312 2004/09/28 01:06:25 boogums Exp $";
#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "merc.h"
#include "lookup.h"
#include "music.h"
#include "tables.h"
#include "gladiator.h"

/* command procedures needed */
DECLARE_DO_FUN(do_quit    );
DECLARE_DO_FUN( do_help	);
DECLARE_DO_FUN( do_stand);
DECLARE_DO_FUN( do_look);

/*
 * Local functions.
 */
int hit_gain  args( ( CHAR_DATA *ch ) );
int mana_gain args( ( CHAR_DATA *ch ) );
int move_gain args( ( CHAR_DATA *ch ) );
void  dot_update	args( ( void ) );
void  mobile_update args( ( void ) );
void  weather_update  args( ( void ) );
void  char_update args( ( void ) );
void  obj_update  args( ( void ) );
void  room_update args( ( void ) );
void  aggr_update args( ( void ) );
void  shapeshift_remove args ((CHAR_DATA *ch));   
bool  ch_in_wraithform = FALSE;
void sector_damage args ((CHAR_DATA *ch));
/* Externals */
void remove_highlander args((CHAR_DATA *ch, CHAR_DATA *victim));

/* used for saving */

int save_number = 0;

void check_shapeshifted( CHAR_DATA *ch )
{
   if(IS_SET(ch->mhs,MHS_SHAPESHIFTED) || IS_SET(ch->mhs,MHS_SHAPEMORPHED))
   {
      if ((ch->race != ch->save_race) || IS_SET(ch->mhs,MHS_SHAPEMORPHED))
      {
         if ( number_percent() <= 20 )
	 {
	    ch->mod_stat[STAT_CON] -= 1;
	    ch->save_con_mod -= 1;
	 }
      }
      else
      {
	 if ( number_percent() <= 40)
	 {
	    ch->mod_stat[STAT_CON] += 1;
	    ch->save_con_mod += 1;
	 }

	 if (ch->save_con_mod == 0)
	 {
	    REMOVE_BIT(ch->mhs,MHS_SHAPESHIFTED);
	    REMOVE_BIT(ch->mhs,MHS_SHAPEMORPHED);
	 }
      }

      /* If a Shapeshifter hits 3 Con Kill them */
      if (get_curr_stat(ch,STAT_CON) <= 3)
      {
	 ch->save_con_mod = 0;
	 if (IS_SET(ch->mhs,MHS_SHAPESHIFTED))
	    shapeshift_remove(ch);
	 REMOVE_BIT(ch->mhs,MHS_SHAPESHIFTED);
	 REMOVE_BIT(ch->mhs,MHS_SHAPEMORPHED);
	 if (!IS_IMMORTAL(ch))
   	    raw_kill(ch,ch);
      }
   }

   return;
}

void check_savant( CHAR_DATA *ch )
{
   if ( IS_NPC(ch) )
	return;

   if ( IS_SET(ch->mhs,MHS_SAVANT) )
   {
	int dam;
       switch( number_percent() * number_percent() )
       {
       case 1: 
	   act("The wind picks up and whips your cloak about violently.",
		ch,NULL,NULL,TO_CHAR,FALSE);
	   ch->pcdata->savant += 10;
	   break;
       case 2:
	    act("Your arms feel cold and stiff suddenly.",
		ch,NULL,NULL,TO_CHAR,FALSE);
	    ch->pcdata->savant += 3;
	    break;
       case 3:
	    act("You double over in pain as a high scream pierces your head.",
		ch,NULL,NULL,TO_CHAR,FALSE);
		ch->pcdata->savant += 2;
	    break;
       case 4:
	    act("You hear voices babbling on the edges of the wind.",
		ch,NULL,NULL,TO_CHAR,FALSE);
		ch->pcdata->savant += 4;
	    break;
       case 5:
	    act("Your vision blurs momentarily.",
		ch,NULL,NULL,TO_CHAR,FALSE);
		ch->pcdata->savant += 9;
	    break;
       case 6:
	    act("Your soul cries out in agony.",
		ch,NULL,NULL,TO_CHAR,FALSE);
            dam = number_range(ch->level,ch->level*2);
	    ch->hit = UMAX(1, ch->hit - dam );
	    ch->pcdata->savant += ( dam / 5 );
	    break;
       case 7:
       case 8:
       case 9:
       case 10:
	    ch->pcdata->perm_hit++;
	    ch->max_hit++;
	    send_to_char("You have been blessed.\n\r", ch);
	    break;
       case 11:
       case 12:
       case 13:
       case 14:
       case 15:
       case 16:
       case 17:
       case 18:
       case 19:
       case 20:
       case 21:
       case 22:
       case 23:
       case 24:
       case 25:
	    if ( number_percent() * number_percent() < ch->pcdata->savant ) 
	    {
	    REMOVE_BIT(ch->mhs,MHS_SAVANT);
	    ch->pcdata->savant = 0;
	    send_to_char("Walk no more with the storm.\n\r",ch);
	    break;
	    }
       default:
	    break;
       };
   }
   
   if ( !IS_IMMORTAL(ch) && 
	number_percent() * number_percent() < 10 &&
	number_percent() * number_percent() < 10 &&
	number_percent() < ch->level &&
	number_percent() < get_curr_stat(ch,STAT_INT)
	&& !IS_SET(ch->mhs,MHS_SAVANT) )
   {
	ch->hit /= 2;
	ch->hit++;
	send_to_char("A sudden shooting pain runs through your forearms.\n\r",ch);
	SET_BIT(ch->mhs,MHS_SAVANT);
	act("$n cringes in sudden pain.",ch,NULL,NULL,TO_ROOM,FALSE);
	return;
    }
    
    return;
}

void check_nethermancer( CHAR_DATA *ch )
{
    OBJ_DATA *weapon;

   if ( !HAS_KIT(ch,"nethermancer") || IS_SET(ch->comm,COMM_AFK) )
	return;

//    changed the line below to be > 15 instead of <12
   if ( number_percent() * number_percent() < 20 &&
	((weapon = get_eq_char(ch,WEAR_WIELD)) != NULL) &&
// changed the line below to 4:2 instead of 5:2
	number_percent() < ch->level / (weapon->enchanted?5:2) &&
	(!IS_SET(weapon->value[4],WEAPON_VAMPIRIC))  &&
        (!IS_SET(weapon->value[4],WEAPON_FAVORED)) )
   {
        wiznet("{YNether Weapon made by:  $N.{x",ch,NULL,WIZ_NOTES,WIZ_SECURE,get_trust(ch));
	SET_BIT(weapon->value[4],WEAPON_NETHER);
	act("$p glows with a black aura.",ch,weapon,NULL,TO_CHAR,FALSE);
	act("$p glows with a black aura.",ch,weapon,NULL,TO_ROOM,FALSE);
   }
}

/*Here goes the vampiric touch check -Boogums*/
void check_vampirictouch( CHAR_DATA *ch)
{
  OBJ_DATA *weapon;

 // if( !HAS_KIT(ch,"necromancer") || ch->position != POS_FIGHTING )
 //   return;
  if ( !HAS_KIT(ch,"necromancer") || IS_SET(ch->comm,COMM_AFK) )
  {
    return;
  }
  if( 
      //number_percent() * number_percent() < 25       &&
      number_percent() * number_percent() < 50       &&
      ((weapon = get_eq_char(ch,WEAR_WIELD)) != NULL) &&
      number_percent() < ch->level / (weapon->enchanted?5:2)  &&
      (!IS_SET(weapon->value[4],WEAPON_VAMPIRIC))  &&
      (!IS_SET(weapon->value[4],WEAPON_FAVORED)) 
    )
    {
      wiznet("{YVampiric Weapon made by:  $N.{x",ch,NULL,WIZ_NOTES,WIZ_SECURE,get_trust(ch));
      SET_BIT(weapon->value[4],WEAPON_VAMPIRIC);
      act("$p suddenly looks a bit more {Dwicked{x.",ch,weapon,NULL,TO_CHAR,FALSE);
      act("$p suddenly looks a bit more {Dwicked{x.",ch,weapon,NULL,TO_ROOM,FALSE);
    }
}  


void check_mutate( CHAR_DATA *ch )
{
   if ( IS_NPC(ch) || !IS_SET(ch->mhs,MHS_MUTANT) )
	return;

   if ( (--ch->pcdata->mutant_timer)/2 < number_percent() )
   {
	int i;
	int new_race = race_lookup("mutant");

	ch->pcdata->mutant_timer = 100 + dice(30,30); /* up to 1000 ticks */

	new_race = number_range( 1, MAX_PC_RACE - 1 );

	/* strip all magic */

	 ch->affected_by = race_table[new_race].aff;
	 ch->imm_flags   = race_table[new_race].imm;
	 ch->res_flags   = race_table[new_race].res;
	 ch->vuln_flags  = race_table[new_race].vuln;
	 ch->form        = race_table[new_race].form;
         ch->parts       = race_table[new_race].parts;
		       
		      
	 for (i = 0; i < 5; i++)
         {
              if (pc_race_table[new_race].skills[i] == NULL)
   	   	break;
    	 	group_add(ch,pc_race_table[new_race].skills[i],FALSE);
        }
		
	ch->size = pc_race_table[new_race].size;
	ch->race = new_race;
	send_to_char("Your body shimmers and shakes.\n\r",ch);
	act("$n's body shimmers and shakes.",ch,NULL,NULL,TO_ROOM,FALSE);
   }

   return;
}

/*
 * Advancement stuff.
 */
void advance_level( CHAR_DATA *ch )
{
    char buf[MAX_STRING_LENGTH];
    int add_hp;
    int add_mana;
    int add_move;
    float mana,fInt,fWis,fP1,fP2,fP3;
    int add_prac;
    int old_class;
    /* get real size of char, prevent inflating hp gain with stature */
    int real_size;

if( ch != NULL )
 {
    old_class = !IS_NPC(ch) ? ch->pcdata->old_class : 3;

    ch->pcdata->last_level = 
  ( ch->played + (int) (current_time - ch->logon) ) / 3600;

    add_hp  = 3*(con_app[get_curr_stat(ch,STAT_CON)].hitp + number_range(
        class_table[old_class].hp_min,
        class_table[old_class].hp_max ))/3;
    add_hp  = 3*(con_app[get_curr_stat(ch,STAT_END)].hitp + number_range(
        class_table[old_class].hp_min,
        class_table[old_class].hp_max ))/4;
    add_hp  = add_hp + ((con_app[get_curr_stat(ch,STAT_STR)].hitp + number_range(
        class_table[old_class].hp_min,
        class_table[old_class].hp_max ))/5);

    real_size = pc_race_table[ch->race].size;
   /*  add_hp += ( ch->size - 2 ); */
    add_hp += ( real_size - 2 );

    /* Here we go.  Trying new mana syustem  ***
    add_mana  = number_range(3,
	(2*(get_curr_stat(ch,STAT_INT) + get_curr_stat(ch,STAT_WIS)))/5);
    if ( add_mana <= 4 )
    {
    add_mana += number_range(3,(2*get_curr_stat(ch,STAT_INT)
                 + get_curr_stat(ch,STAT_WIS))/5);
    add_mana /= 2;
    }
    ***/

/* This code provided by Marc Labelle (Ghor) */
    fInt = get_curr_stat(ch,STAT_INT) * 1.0;
    fWis = get_curr_stat(ch,STAT_WIS) * 1.0;
    fP1 = number_percent() * 1.0 / 100;
    fP2 = number_percent() * 1.0 / 100;
    fP3 = number_percent() * 1.0 / 100;

    mana = (fInt * .2 * ( 1 + fP1 + fP2 ) );
    mana += ( fWis * .1 * ( 1 + fP3 ) );
  
    if ( ch->race == race_lookup("elf") || ch->race == race_lookup("half-elf"))
	mana *= 1.1;

    if ( ch->race == race_lookup("faerie") )
        mana *= 1.25;

    if ( HAS_KIT(ch,"bishop") )
        mana *= 1.1;

    /* if (class_table[ch->class].fMana == 0)
    */
    if (class_table[old_class].fMana == 0)
  	mana *= .5;

    /*if ( class_table[ch->class].fMana == 1 )
    */
    if ( class_table[old_class].fMana == 1 )
  	mana *= .75;

/* changing move gains
    add_move  = number_range( 1, (get_curr_stat(ch,STAT_CON)
          + get_curr_stat(ch,STAT_DEX))/6 );
	  */
    add_prac  = wis_app[get_curr_stat(ch,STAT_WIS)].practice;

     /* Kits */
    if (HAS_KIT(ch,"prophet"))
	add_prac += 1;

    add_mana = (int) mana;
    add_hp  = UMAX(  2, add_hp   );
    add_mana = UMAX( 2, add_mana );
    /*
    add_move  = UMAX(  6, add_move );
    */

    add_move = 3;
    if (get_curr_stat(ch,STAT_DEX) > 24)
       add_move += 1;
    if (get_curr_stat(ch,STAT_DEX) > 23)
       add_move += 1;
    if (get_curr_stat(ch,STAT_DEX) > 21)
       add_move += 1;
    if (get_curr_stat(ch,STAT_DEX) > 19)
       add_move += 1;
    if (get_curr_stat(ch,STAT_DEX) > 17)
       add_move += 1;
    if (get_curr_stat(ch,STAT_END) > 24)
       add_move += 1;
    if (get_curr_stat(ch,STAT_END) > 23)
       add_move += 1;
    if (get_curr_stat(ch,STAT_END) > 22)
       add_move += 1;
    if (get_curr_stat(ch,STAT_END) > 21)
       add_move += 1;
    if (get_curr_stat(ch,STAT_END) > 20)
       add_move += 1;
    if (get_curr_stat(ch,STAT_END) > 19)
       add_move += 1;
    if (get_curr_stat(ch,STAT_END) > 18)
       add_move += 1;
    if (get_curr_stat(ch,STAT_END) > 17)
       add_move += 1;


    if ( ch->race == race_lookup("rockbiter") )
       add_move -= 1;

    if (IS_SET(ch->act,PLR_MUMMY) || ch->race == race_lookup("gargoyle") )
       add_move /= 2;

    if ( HAS_KIT(ch,"ranger") )
	add_move += 3;

    if ( is_affected(ch,gsn_spirit_of_boar) )
	add_hp++;

    if ( is_affected(ch,gsn_spirit_of_owl) )
	add_mana++;

    ch->max_hit   += add_hp;
    ch->max_mana  += add_mana;
    ch->max_move  += add_move;
    ch->pcdata->perm_hit  += add_hp;
    ch->pcdata->perm_mana += add_mana;
    ch->pcdata->perm_move += add_move;

    ch->practice  += add_prac;
    ch->train   += 1;

    /* Clear last attacked by on level */
    ch->pcdata->last_attacked_by = str_dup("no one");
    ch->pcdata->last_attacked_by_timer = 0;

  if ( ch->desc != NULL && ch->desc->connected == CON_PLAYING )
   {
     sprintf( buf, "You gain hp, mana, moves and %d/%d prac.\n\r",
	      add_prac, ch->practice );
    send_to_char( buf, ch );

    if ( ch->level == 9 )
	do_help(ch,"levelnine");
    else
    if ( ch->level == 10 )
	do_help(ch,"levelten");
    else
    if ( ch->level == 11 )
	do_help(ch,"leveleleven");
    else
    if ( ch->level == 20 )
	do_help(ch,"leveltwenty");

   }
  }
    return;
}   

void do_level( CHAR_DATA *ch, char *argument )
{
    char buf[MAX_STRING_LENGTH];

    if ( IS_NPC(ch) ) return;

    if ( ch->exp < exp_per_level(ch,ch->pcdata->points) * (ch->level+1) &&
         ch->pcdata->debit_level <= 0 ) {
	send_to_char("You have no debit levels available.\n\r",ch);
	return;
    }

    if ( ch->level >= 51 ) {
	send_to_char("You cannot level past 51.\n\r",ch);
	return;
    }

    if (IS_SET(ch->mhs, MHS_GLADIATOR))
    {
       send_to_char("You cannot level inside the Gladiator arena.\n\r", ch);
       return;
    }


    if (IS_SET(ch->mhs,MHS_SHAPESHIFTED) || IS_SET(ch->mhs,MHS_SHAPEMORPHED))
    {
  sprintf( buf, "You are not allowed to train while shapeshifted.\n\r");
  send_to_char( buf,ch);
  return;
    }

    if (ch->fighting != NULL)
    {
       send_to_char("You can not level while fighting.\n\r",ch);
       return;
    }
	if( ch->pcdata->debit_level > 0 ) 
    {
    	ch->pcdata->debit_level--;
	ch->exp += exp_per_level(ch,ch->pcdata->points);
	sprintf(buf,"%s is using a debit level (%d remaining)",
		ch->name, ch->pcdata->debit_level );
	wiznet(buf,ch,NULL,WIZ_LEVELS,0,0);

	/* Give Pfresh Chars 10 skill points up to 500 max
	   ie. not a remort */
        if (!IS_SET(ch->act,PLR_VAMP) &&
	    !IS_SET(ch->act,PLR_WERE) &&
	    !IS_SET(ch->act,PLR_MUMMY))
	   ch->skill_points += 10;
    }
/*
    if ( ch->exp < exp_per_level(ch,ch->pcdata->points) * (ch->level+1) ) {
    	ch->pcdata->debit_level--;
	sprintf(buf,"%s is using a debit level (%d remaining)",
		ch->name, ch->pcdata->debit_level );
	wiznet(buf,ch,NULL,WIZ_LEVELS,0,0);
    }
*/
    ch->level++;
    advance_level(ch);
    save_char_obj(ch);
		 
    sprintf(buf,"%s has attained level %d",ch->name,ch->level);
    log_string(buf);
    sprintf(buf,"$N has attained level %d!",ch->level);
    wiznet(buf,ch,NULL,WIZ_LEVELS,0,0);
    pnet(buf,ch,NULL,PNET_LEVELS,0,0);
    return;
}

void gain_exp( CHAR_DATA *ch, long gain )
{
    char buf[MAX_STRING_LENGTH];
    int count = 1;

    if ( IS_NPC(ch) || ch->level >= LEVEL_HERO )
  return;

    /* Do not gain or lose any exp if you have debit levels */
    if (ch->pcdata->debit_level > 0)
       gain = 0;



    ch->exp = UMAX( exp_per_level(ch,ch->pcdata->points), ch->exp + gain );
    while ( ch->level < LEVEL_HERO && ch->exp >= 
  exp_per_level(ch,ch->pcdata->points) * (ch->level+count ) )
    {
   sprintf(buf,"You qualify for level %d!!\n\r", ch->level + count );
   send_to_char(buf,ch);
   if (ch->level == 20)
	do_help(ch, "twentywarning");
   /*
       sprintf(buf,"%s qualifies for level %d",ch->name,ch->level+count);
        log_string(buf);
        sprintf(buf,"$N qualifies for level %d!",ch->level+count);
        wiznet(buf,ch,NULL,WIZ_LEVELS,0,0);
	*/
  /*advance_level( ch );*/
  save_char_obj(ch);
   count++;
    }

    return;
}



/*
 * Regeneration stuff.
 */
int hit_gain( CHAR_DATA *ch )
{
    int val;
    int gain;
    int number;

    if (ch->in_room == NULL)
  return 0;

    if ( IS_NPC(ch) )
    {
  gain =  5 + ch->level;
  if (IS_AFFECTED(ch,AFF_REGENERATION))
      gain *= 2;

  switch(ch->position)
  {
      default :     gain /= 2;      break;
      case POS_SLEEPING:  gain = 3 * gain/2;    break;
      case POS_RESTING:           break;
      case POS_FIGHTING:  gain /= 3;      break;
  }

  
    }
    else
    {
  gain = UMAX(3,get_curr_stat(ch,STAT_CON) - 3 + ch->level/2); 
  gain += class_table[ch->class].hp_max - 10;
  number = number_percent();
  if (number < get_skill(ch,gsn_fast_healing))
  {
      gain += number * gain / 100;
      if (ch->hit < ch->max_hit)
    check_improve(ch,gsn_fast_healing,TRUE,8);
  }

       if(IS_SET(ch->act,PLR_MUMMY) && !IS_NPC(ch))
       {
          number = number_percent();
          gain += number * gain / 100;
       }

  switch ( ch->position )
  {
      default:      gain /= 4;      break;
      case POS_SLEEPING:          break;
      case POS_RESTING:   gain /= 2;      break;
      case POS_FIGHTING:  gain /= 6;      break;
  }

  if ( ch->pcdata->condition[COND_HUNGER]   == 0 )
      gain /= 2;

  if ( ch->pcdata->condition[COND_THIRST] == 0 )
      gain /= 2;

  if ( ch->pcdata->condition[COND_DRUNK] > 10 )
      gain = (gain + 1)*3 / 2;
    }

    if(!IS_NPC(ch) && !( ch->in_room->clan && IS_SET(ch->pcdata->clan_flags, CLAN_NO_REGEN)) )
    {
    gain = gain * ch->in_room->heal_rate / 100;
    }

    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
  gain = gain * ch->on->value[3] / 100;

    if ( IS_AFFECTED(ch, AFF_POISON) )
  gain /= 4;

    if (IS_AFFECTED(ch, AFF_PLAGUE))
  gain /= 8;

    if(!IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_NPC(ch))
    {
       if (IS_AFFECTED(ch,AFF_HASTE) || IS_AFFECTED(ch,AFF_SLOW))
          gain /=2 ;
    }
    if(IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       if(IS_SET(ch->in_room->room_flags,ROOM_HOLY_GROUND))
          gain = 0;
       else
	  gain *= 3;
    }

    if ( ch->race == race_lookup("rockbiter") )
	gain = (4*gain)/5;


    if ( ch->race == race_lookup("gargoyle") )
    {
	if ( out_of_element(ch) )
		gain = gain *2/3;
	else
		gain = gain * 3/2;
    }

    if (ch->race == race_lookup("smurf"))
       gain *= 2;

    if ( (val = room_has_medium( ch ) ) )
        gain = ( gain * ( 100 + val ) / 100 );

    return UMIN(gain, ch->max_hit - ch->hit);
}



int mana_gain( CHAR_DATA *ch )
{
    int val;
    int gain;
    int number;

    if (ch->in_room == NULL)
  return 0;

    if ( IS_NPC(ch) )
    {
  gain = 5 + ch->level;
  switch (ch->position)
  {
      default:    gain /= 2;    break;
      case POS_SLEEPING:  gain = 3 * gain/2;  break;
        case POS_RESTING:       break;
      case POS_FIGHTING:  gain /= 3;    break;
      }
    }
    else
    {
  gain = (get_curr_stat(ch,STAT_WIS) 
        + get_curr_stat(ch,STAT_INT) + ch->level) / 2;
  number = number_percent();
  if (number < get_skill(ch,gsn_meditation))
  {
      gain += number * gain / 100;
      if (ch->mana < ch->max_mana)
          check_improve(ch,gsn_meditation,TRUE,8);
  }


       if(IS_SET(ch->act,PLR_MUMMY) && !IS_NPC(ch))
       {
          number = number_percent();
          gain += number * gain / 100;
       }

  if (class_table[ch->class].fMana == 0)
      gain /= 2;

  switch ( ch->position )
  {
      default:    gain /= 4;      break;
      case POS_SLEEPING:          break;
      case POS_RESTING: gain /= 2;      break;
      case POS_FIGHTING:  gain /= 6;      break;
  }

  if ( ch->pcdata->condition[COND_HUNGER]   == 0 )
      gain /= 2;

  if ( ch->pcdata->condition[COND_THIRST] == 0 )
      gain /= 2;

  if ( ch->pcdata->condition[COND_DRUNK] > 10 )  
      gain = (gain + 1)*3 / 2;

    }

    if(!IS_NPC(ch) && !( ch->in_room->clan && IS_SET(ch->pcdata->clan_flags, CLAN_NO_REGEN)) )
    {
    gain = gain * ch->in_room->mana_rate / 100;
    }

    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
  gain = gain * ch->on->value[4] / 100;

    if ( IS_AFFECTED( ch, AFF_POISON ) )
  gain /= 4;

    if (IS_AFFECTED(ch, AFF_PLAGUE))
        gain /= 8;

    if(!IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_NPC(ch))
    {
       if (IS_AFFECTED(ch,AFF_HASTE) || IS_AFFECTED(ch,AFF_SLOW))
          gain /=2 ;
    }

    if(IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       if(IS_SET(ch->in_room->room_flags,ROOM_HOLY_GROUND))
          gain = 0;
       else
	  gain *= 3;
    }

    if ( ch->race == race_lookup("rockbiter") )
	gain = (4*gain)/5;

    if ( ch->race == race_lookup("gargoyle") )
    {
	if ( out_of_element(ch) )
	    gain = gain *2/3;
	else
	    gain  = gain * 3/2;
    }

    if (ch->race == race_lookup("smurf"))
       gain *= 2;
  
    if( is_affected(ch,gsn_clarity) )
	gain = ( 100 + (ch->level/2) ) * gain / 100;

    if ( (val = room_has_medium( ch ) ) )
	gain = ( gain * ( 100 + val ) / 100 );

    return UMIN(gain, ch->max_mana - ch->mana);
}



int move_gain( CHAR_DATA *ch )
{
    int val;
    int gain;

    if (ch->in_room == NULL)
  return 0;

    if ( IS_NPC(ch) )
    {
  gain = ch->level;
    }
    else
    {

  gain = UMAX( 15, ch->level );

  switch ( ch->position )
  {
  case POS_SLEEPING: gain += get_curr_stat(ch,STAT_DEX);    break;
  case POS_RESTING:  gain += get_curr_stat(ch,STAT_DEX) / 2;  break;
  }

  if ( ch->pcdata->condition[COND_HUNGER]   == 0 )
      gain /= 2;

  if ( ch->pcdata->condition[COND_THIRST] == 0 )
      gain /= 2;
    }

    gain = gain * ch->in_room->heal_rate/100;

    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
  gain = gain * ch->on->value[3] / 100;

    if ( IS_AFFECTED(ch, AFF_POISON) )
  gain /= 4;

    if (IS_AFFECTED(ch, AFF_PLAGUE))
        gain /= 8;

    if(!IS_SET(ch->mhs,MHS_HIGHLANDER) && !IS_NPC(ch))
    {
       if (IS_AFFECTED(ch,AFF_HASTE) || IS_AFFECTED(ch,AFF_SLOW))
          gain /=2 ;
    }

    if(IS_SET(ch->mhs,MHS_HIGHLANDER))
    {
       if(IS_SET(ch->in_room->room_flags,ROOM_HOLY_GROUND))
          gain = 0;
       else
	  gain *= 3;
    }

    if ( ch->race == race_lookup("rockbiter") )
	gain = (4*gain)/5;

    if ( out_of_element(ch) && ch->race == race_lookup("gargoyle") )
	gain /= 2;

    if (ch->race == race_lookup("smurf"))
       gain *= 2;

    if ( (val = room_has_medium( ch ) ) )
        gain = ( gain * ( 100 + val ) / 100 );

    return UMIN(gain, ch->max_move - ch->move);
}



void gain_condition( CHAR_DATA *ch, int iCond, int value )
{
    int condition;

    if ( value == 0 || IS_NPC(ch) || ch->level >= LEVEL_IMMORTAL)
  return;

    if ( ch->race == race_lookup("rockbiter") )
	value /= 2;

    condition       = ch->pcdata->condition[iCond];
    if (condition == -1)
        return;
    ch->pcdata->condition[iCond]  = URANGE( 0, condition + value, 48 );

   if ( IS_SET(ch->comm, COMM_SILENCE) )
	return;

    if ( ch->pcdata->condition[iCond] == 0 )
    {

  switch ( iCond )
  {
  case COND_HUNGER:
      if ( IS_SET( ch->act,PLR_VAMP) )
	  send_to_char("Your throat aches for blood.\n\r",ch);
      else
          send_to_char( "You are hungry.\n\r",  ch );
      break;

  case COND_THIRST:
      if ( IS_SET( ch->act, PLR_VAMP) )
	  send_to_char("Your throat aches for blood.\n\r",ch);
      else
          send_to_char( "You are thirsty.\n\r", ch );
      break;

  case COND_DRUNK:
      if ( condition != 0 )
    send_to_char( "You are sober.\n\r", ch );
      break;
  }
    }

    return;
}



/*
 * Mob autonomous action.
 * This function takes 25% to 35% of ALL Merc cpu time.
 * -- Furey
 */
void mobile_update( void )
{
    CHAR_DATA *ch;
    CHAR_DATA *ch_next;
    EXIT_DATA *pexit;
    int door;

    /* Examine all mobs. */
    for ( ch = char_list; ch != NULL; ch = ch_next )
    {
  ch_next = ch->next;

  if ( !IS_NPC(ch) || ch->in_room == NULL 
	|| (IS_AFFECTED(ch,AFF_CHARM) && !IS_SET(ch->mhs, MHS_ELEMENTAL)) )
      continue;

  if (ch->in_room->area->empty && !IS_SET(ch->act,ACT_UPDATE_ALWAYS))
      continue;

  /* Examine call for special procedure */
  if ( ch->spec_fun != 0 )
  {
      if ( (*ch->spec_fun) ( ch ) )
    continue;
  }

  if (ch->pIndexData->pShop != NULL) /* give him some gold */
      if ((ch->gold * 100 + ch->silver) < ch->pIndexData->wealth)
      {
    ch->gold += ch->pIndexData->wealth * number_range(1,20)/5000000;
    ch->silver += ch->pIndexData->wealth * number_range(1,20)/50000;
      }
   

  /* That's all for sleeping / busy monster, and empty zones */
  if ( ch->position != POS_STANDING )
      continue;

  /* Scavenge */
  if ( IS_SET(ch->act, ACT_SCAVENGER)
  &&   ch->in_room->contents != NULL
  &&   number_bits( 6 ) == 0 && !ch->in_room->area->freeze)
  {
      OBJ_DATA *obj;
      OBJ_DATA *obj_best;
      int max;

      max         = 1;
      obj_best    = 0;
      for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
      {
    if ( CAN_WEAR(obj, ITEM_TAKE) && can_loot(ch, obj, TRUE)
         && obj->cost > max  && obj->cost > 0 && count_users(obj) == 0 )
    {
        obj_best    = obj;
        max         = obj->cost;
    }
      }

      if ( obj_best )
      {
    obj_from_room( obj_best );
    obj_to_char( obj_best, ch );
    act( "$n gets $p.", ch, obj_best, NULL, TO_ROOM ,FALSE);
      }
  }

  /* Wander */
  if ( !ch->in_room->area->freeze
  && !IS_SET(ch->act, ACT_SENTINEL) 
  && number_bits(3) == 0
  && ( door = number_bits( 5 ) ) <= 5
  && ( pexit = ch->in_room->exit[door] ) != NULL
  &&   pexit->u1.to_room != NULL
  &&   !IS_SET(pexit->exit_info, EX_CLOSED)
  &&   !IS_SET(pexit->u1.to_room->room_flags, ROOM_NO_MOB)
  && ( !IS_SET(ch->act, ACT_STAY_AREA)
  ||   pexit->u1.to_room->area == ch->in_room->area ) 
  && ( !IS_SET(ch->act, ACT_OUTDOORS)
  ||   !IS_SET(pexit->u1.to_room->room_flags,ROOM_INDOORS)) 
  && ( !IS_SET(ch->act, ACT_INDOORS)
  ||   IS_SET(pexit->u1.to_room->room_flags,ROOM_INDOORS)))
  {
      move_char( ch, door, FALSE );
  }                     
    }

    return;
}



/*
 * Update the weather.
 */
void weather_update( void )
{
    char buf[MAX_STRING_LENGTH];
    DESCRIPTOR_DATA *d;
    int diff;

    buf[0] = '\0';

    switch ( ++time_info.hour )
    {
    case  5:
  weather_info.sunlight = SUN_LIGHT;
  strcat( buf, "The day has begun.\n\r" );
  break;

    case  6:
  weather_info.sunlight = SUN_RISE;
  strcat( buf, "The sun rises in the east.\n\r" );
  break;

    case 19:
  weather_info.sunlight = SUN_SET;
  strcat( buf, "The sun slowly disappears in the west.\n\r" );
  break;

    case 20:
  weather_info.sunlight = SUN_DARK;
  strcat( buf, "The night has begun.\n\r" );
  break;

    case 24:
  time_info.hour = 0;
  time_info.day++;
  break;
    }

    if ( time_info.day   >= 35 )
    {
  time_info.day = 0;
  time_info.month++;
    }

    if ( time_info.month >= 17 )
    {
  time_info.month = 0;
  time_info.year++;
    }

    /*
     * Weather change.
     */
    if ( time_info.month >= 9 && time_info.month <= 16 )
  diff = weather_info.mmhg >  985 ? -2 : 2;
    else
  diff = weather_info.mmhg > 1015 ? -2 : 2;

    weather_info.change   += diff * dice(1, 4) + dice(2, 6) - dice(2, 6);
    weather_info.change    = UMAX(weather_info.change, -12);
    weather_info.change    = UMIN(weather_info.change,  12);

    weather_info.mmhg += weather_info.change;
    weather_info.mmhg  = UMAX(weather_info.mmhg,  960);
    weather_info.mmhg  = UMIN(weather_info.mmhg, 1040);

    switch ( weather_info.sky )
    {
    default: 
  bug( "Weather_update: bad sky %d.", weather_info.sky );
  weather_info.sky = SKY_CLOUDLESS;
  break;

    case SKY_CLOUDLESS:
  if ( weather_info.mmhg <  990
  || ( weather_info.mmhg < 1010 && number_bits( 2 ) == 0 ) )
  {
      strcat( buf, "The sky is getting cloudy.\n\r" );
      weather_info.sky = SKY_CLOUDY;
  }
  break;

    case SKY_CLOUDY:
  if ( weather_info.mmhg <  970
  || ( weather_info.mmhg <  990 && number_bits( 2 ) == 0 ) )
  {
      strcat( buf, "It starts to rain.\n\r" );
      weather_info.sky = SKY_RAINING;
  }

  if ( weather_info.mmhg > 1030 && number_bits( 2 ) == 0 )
  {
      strcat( buf, "The clouds disappear.\n\r" );
      weather_info.sky = SKY_CLOUDLESS;
  }
  break;

    case SKY_RAINING:
  if ( weather_info.mmhg <  970 && number_bits( 2 ) == 0 )
  {
      strcat( buf, "Lightning flashes in the sky.\n\r" );
      weather_info.sky = SKY_LIGHTNING;
  }

  if ( weather_info.mmhg > 1030
  || ( weather_info.mmhg > 1010 && number_bits( 2 ) == 0 ) )
  {
      strcat( buf, "The rain stopped.\n\r" );
      weather_info.sky = SKY_CLOUDY;
  }
  break;

    case SKY_LIGHTNING:
  if ( weather_info.mmhg > 1010
  || ( weather_info.mmhg >  990 && number_bits( 2 ) == 0 ) )
  {
      strcat( buf, "The lightning has stopped.\n\r" );
      weather_info.sky = SKY_RAINING;
      break;
  }
  break;
    }

    if ( buf[0] != '\0' )
    {
  for ( d = descriptor_list; d != NULL; d = d->next )
  {
      if ( d->connected == CON_PLAYING
      &&   IS_OUTSIDE(d->character)
      &&   IS_AWAKE(d->character)
      &&  !IS_SET(d->character->comm, COMM_SILENCE) )
    send_to_char( buf, d->character );
  }
    }

    return;
}



/*
 * Update all chars, including mobs.
*/
void char_update( void )
{   
    CHAR_DATA *ch;
    CHAR_DATA *ch_next;
    CHAR_DATA *ch_quit;    
    char buf[MAX_STRING_LENGTH];

    ch_quit = NULL;

    /* update save counter */
    save_number++;

    if (save_number > 14)
  save_number = 0;

    for ( ch = char_list; ch != NULL; ch = ch_next )
    {
  AFFECT_DATA *paf;
  AFFECT_DATA *paf_next;

  ch_next = ch->next;

	check_mutate( ch );
	/*
	check_savant( ch );
	*/
        if ( IS_SET(ch->mhs,MHS_SAVANT) )
	    REMOVE_BIT(ch->mhs,MHS_SAVANT);
	check_shapeshifted( ch );
	check_nethermancer( ch );
	check_vampirictouch( ch );

	if ( !IS_NPC(ch) && ch->class == class_lookup("paladin") )
	    {
		if (ch->pcdata->abolish_timer-- < 0 )
			ch->pcdata->abolish_timer = 0;
	    }
       
  if ( !IS_NPC(ch) )
            {
                if (ch->clan == clan_lookup("newbie") &&
                    get_age(ch) > 20)
                {
                    send_to_char("Your newbie flag has been removed.",ch);
                    ch->clan = 0;
                }
                if (ch->clan != clan_lookup("zealot") && ch->pcdata->deity == deity_lookup("almighty") )
                {
                    send_to_char("The Almighty has lost faith in you, and you turn to Mojo.\n\r",ch);
                    ch->pcdata->deity = deity_lookup("mojo");
                }

                if (ch->pcdata->trap_timer-- < 0 )
                        ch->pcdata->trap_timer = 0;
               
/* REMOVED by Nightdagger on 04/13/03
                if (ch->pcdata->deity_timer-- < 0 && ch->pcdata->deity != ch->pcdata->new_deity )
		        {
		        sprintf(buf, "You now worship %s.", deity_table[ch->pcdata->new_deity].pname);
		        ch->pcdata->deity = ch->pcdata->new_deity;
		        }
*/

            }
 
	if ( IS_SET(ch->mhs, MHS_BANISH))
	  {
	  REMOVE_BIT(ch->mhs, MHS_BANISH);
	  send_to_char("The force blocking the entrance to your clan hall is gone.\n\r", ch);
	  }

        /* skill point tracker set not gaining skill points */
	if (!IS_NPC(ch) && !IS_SET(ch->comm,COMM_AFK) )
	{
           if (ch->pcdata->skill_point_tracker >= 12)
	   {
        /* If the skill point timer is down to 0 then they
           are allowed to gain skill points again, reset
           the tracker so it will start gaining */

	      ch->pcdata->skill_point_timer =
	      	UMAX(0,ch->pcdata->skill_point_timer -1);

	      if ((ch->pcdata->skill_point_timer) ==  0) 
	         ch->pcdata->skill_point_tracker = 0;
	   }

	   if(ch->pcdata->last_attacked_by_timer == 0)
   	      ch->pcdata->last_attacked_by = str_dup("no one");
	   if (ch->pcdata->last_attacked_by_timer > 0)
	      ch->pcdata->last_attacked_by_timer--;
	   if (ch->pcdata->last_death_timer > 0)
	      ch->pcdata->last_death_timer--;
	}

        if ( ch->timer > 30 )
            ch_quit = ch;
            
  if (ch->position == POS_SLEEPING && !IS_NPC(ch)) {
     if ( IS_SET(ch->display, DISP_PROMPT)    && (ch->desc))
        send_to_char ("",ch);
  }             

  if ( ch->position >= POS_STUNNED )
  {
    
            /* check to see if we need to go home */
      if (IS_NPC(ch) && ch->zone != NULL 
	  && ch->zone != ch->in_room->area
          && ch->desc == NULL &&  ch->fighting == NULL 
          && !IS_AFFECTED(ch,AFF_CHARM) 
	  && ( number_percent() < 5 
		|| (!str_prefix("spec_guard",spec_name(ch->spec_fun))
		    && number_percent() < 33) ) 
	  && !ch->in_room->area->freeze
	  && ch->in_room != get_room_index(ROOM_VNUM_LIMBO)
          && ch->passenger == NULL
	  && ch->pIndexData->pShop == NULL) 
	   {
              act("$n wanders on home.",ch,NULL,NULL,TO_ROOM,FALSE);
              extract_char(ch,TRUE);
              continue;
            }


	 /* check to see if we get moved from air/water currents,
	    move players only who are in a standing position  */

	 if ( !IS_NPC(ch)
	     && ( ch->position >= POS_STANDING ) 
	     && ( ch->in_room != NULL )
	     && (    ch->in_room->sector_type == SECT_AIR
		 || ch->in_room->sector_type == SECT_WATER_NOSWIM 
		 || ch->in_room->sector_type == SECT_WATER_SWIM          
	        )
	     && ( number_percent() > get_skill(ch, gsn_swim ) )
	    )
         {

		 EXIT_DATA *pexit;
		 int original_type, new_type;
		 int door = number_door();
		 pexit = ch->in_room->exit[door];
		 if (    ( pexit  == 0 )
			    ||   pexit->u1.to_room == NULL
			   ||   pexit->u1.to_room->clan
			  ||   IS_SET(pexit->exit_info, EX_CLOSED)
		   )
		 {
		   /* do nothign, room does not exists or can't move in
		    that direction */
		 }
		 else
		 {
			 new_type = pexit->u1.to_room->sector_type;
			 original_type = ch->in_room->sector_type;
			 if( /* can't from air to water */
			     (       original_type == SECT_AIR 
				&&  (    new_type == SECT_WATER_NOSWIM
				       || new_type == SECT_WATER_SWIM
				     )
			     )
			   || /* or from water to air */
			     (       new_type == SECT_AIR 
				&&  (    original_type == SECT_WATER_NOSWIM
				     || original_type == SECT_WATER_SWIM
				    )
			     )
			   )
			   {
			   /* do nothing to player, wrong sector types */
			   }
			 else
			 {
			   /* move the player to the next room */
			    move_char(ch, door, FALSE);
			 }
		
                  } /* end else, for no room */
             } /* end on the NPC check */

   if( !out_of_element(ch))
     {
	/* Gargoyles */
	if ( ch->race == race_lookup("gargoyle") )
	{
	    REMOVE_BIT(ch->vuln_flags,VULN_WEAPON);
	    SET_BIT(ch->res_flags,RES_WEAPON);
	    SET_BIT(ch->imm_flags,IMM_CHARM);
	}

      if ( ch->hit  < ch->max_hit)
    ch->hit  += hit_gain(ch);
      else
    ch->hit = ch->max_hit;
     }
    else if(ch->desc != NULL 
	    && ch->in_room != get_room_index(ROOM_VNUM_LIMBO))
     {
   	/* Handle gargoyles first */
	if ( ch->race == race_lookup("gargoyle") )
	{
	 SET_BIT(ch->vuln_flags,VULN_WEAPON);
	 REMOVE_BIT(ch->res_flags,RES_WEAPON);
	 REMOVE_BIT(ch->imm_flags,IMM_CHARM);
	}

	/* ok, now remorts AND gargoyles */
	if ( IS_SET(ch->act,PLR_WERE) || IS_SET(ch->act,PLR_VAMP) || IS_SET(ch->act,PLR_MUMMY) )
	{

	if ( ch->hit  <= ch->max_hit)
	 {
	  if(IS_SET(ch->act,PLR_MUMMY))
	     send_to_char("Your rags are {Rb{yu{rr{Yn{ri{yn{rg{x up!\n\r",ch);
	  else
	     send_to_char("Your {rb{Rl{ro{Ro{rd{x torments you.\n\r",ch);
          if ( IS_AFFECTED(ch, AFF_SLEEP) )
          {
            REMOVE_BIT(ch->affected_by, AFF_SLEEP);
          }

	  damage( ch, ch, ch->level/3, gsn_plague,DAM_DISEASE,FALSE,TRUE);
	 }
	else
	 {
	  if(IS_SET(ch->act,PLR_MUMMY))
	     send_to_char("Your rags are {Rb{yu{rr{Yn{ri{yn{rg{x up!\n\r",ch);
	  else
	     send_to_char("Your {rb{Rl{ro{Ro{rd{x torments you.\n\r",ch);
	  ch->hit = ch->max_hit;
	 }

	} /* Brace matches IS_SET's above */
     }

      if ( ch->mana < ch->max_mana )
    ch->mana += mana_gain(ch);
      else
    ch->mana = ch->max_mana;

      if ( ch->move < ch->max_move )
    ch->move += move_gain(ch);
      else
    ch->move = ch->max_move;
  }

  else if ( ch->position == POS_INCAP && number_range(0,1) == 0)
  {
      damage( ch, ch, 1, TYPE_UNDEFINED, DAM_NONE,FALSE,FALSE);
  }
  else if ( ch->position == POS_MORTAL )
  {
      damage( ch, ch, 1, TYPE_UNDEFINED, DAM_NONE,FALSE,FALSE);
  }     

  if ( ch->position == POS_STUNNED )
      update_pos( ch );
      
  if ( ch->position == POS_SLEEPING )
    send_to_char ("\n\r",ch);

  if (!IS_NPC(ch) && ch->pcdata && ch->pcdata->outcT > 0)
      --ch->pcdata->outcT;

  if (!IS_NPC(ch) && ch->pcdata && ch->pcdata->ruffT > 0
	&& ch->pcdata->quit_time == 0 )
      --ch->pcdata->ruffT;

  if (!IS_NPC(ch) && ch->clan == clan_lookup("matook"))
  {
     if (ch->pcdata->matookT < 12001)
        ch->pcdata->matookT += 1;
     if (ch->pcdata->matookT == 12000)
	send_to_char("You have gained the wisdom to guild into Matook. Use it wisely.\n\r",ch);
  }


  if (!IS_NPC(ch) && ch->pcdata && ch->pcdata->ruffT == 0
	&& IS_SET(ch->wiznet,PLR_RUFFIAN) && ch->fighting == NULL
	&& ch->pcdata->quit_time == 0 )
  {
    REMOVE_BIT(ch->wiznet,PLR_RUFFIAN);
    send_to_char("Your ruffian reputation has been forgotten.\n\r",ch);
  }

  if ( !IS_NPC(ch) && ch->level < LEVEL_IMMORTAL )
  {
      OBJ_DATA *obj;

      if ( ( obj = get_eq_char( ch, WEAR_LIGHT ) ) != NULL
      &&   obj->item_type == ITEM_LIGHT
      &&   obj->value[2] > 0 )
      {
    if ( --obj->value[2] == 0 && ch->in_room != NULL )
    {
        --ch->in_room->light;
        act( "$p goes out.", ch, obj, NULL, TO_ROOM ,FALSE);
        act( "$p flickers and goes out.", ch, obj, NULL, TO_CHAR ,FALSE);
        extract_obj( obj );
    }
    else if ( obj->value[2] <= 5 && ch->in_room != NULL)
        act("$p flickers.",ch,obj,NULL,TO_CHAR,FALSE);
      }

      if (IS_IMMORTAL(ch))
    ch->timer = 0;

      if (ch->pcdata && ch->pcdata->start_time > 0)
	  ch->pcdata->start_time -= 1;
    
      if (ch->pcdata && ch->pcdata->quit_time > 0)
          --ch->pcdata->quit_time;

      if ( ++ch->timer >= 12 )
      {
    if ( ch->was_in_room == NULL && ch->in_room != NULL )
    {
        ch->was_in_room = ch->in_room;
        if ( ch->fighting != NULL )
      stop_fighting( ch, TRUE );
        act( "$n disappears into the void.",
      ch, NULL, NULL, TO_ROOM ,FALSE);
        send_to_char( "You disappear into the void.\n\r", ch );
	if (IS_SET(ch->mhs,MHS_HIGHLANDER))
	{
           remove_highlander(ch,ch);
	}
	if (IS_SET(ch->mhs,MHS_GLADIATOR))
	{
	   REMOVE_BIT(ch->mhs,MHS_GLADIATOR);
           sprintf(buf, "%s has left the arena for the void.", ch->name);
           gladiator_talk(buf); 
	   send_to_char("You drifted into the void and were removed from the Arena.\n\r",ch);
	   gladiator_left_arena(ch,FALSE);
	}

        if (ch->level > 1)
            save_char_obj( ch );
        char_from_room( ch );
	if ( is_mounted(ch) && IS_NPC(ch->riding) )
	{
	    char_from_room( ch->riding );
	    char_to_room(ch->riding,get_room_index( ROOM_VNUM_LIMBO ));
	}
	else
	if ( is_mounted(ch) && !IS_NPC(ch->riding) )
		clear_mount( ch );
        if ( ch->passenger != NULL )
	    clear_mount( ch ); 
	char_to_room( ch, get_room_index( ROOM_VNUM_LIMBO ) );
    }
      }

	gain_condition( ch, COND_DRUNK, ch->size > SIZE_LARGE ? -2 :  -1 );
	if ( !IS_SET(ch->act,PLR_VAMP) ||
	 ( IS_SET(ch->act,PLR_VAMP) && 
	   ( time_info.hour < 5 || time_info.hour > 20 ) ) )
	{
	gain_condition( ch, COND_FULL, ch->size > SIZE_MEDIUM ? -4 : -2 );
	gain_condition( ch, COND_THIRST, -1 );
	gain_condition( ch, COND_HUNGER, ch->size > SIZE_MEDIUM ? -2 : -1);
	}
  }

  for ( paf = ch->affected; paf != NULL; paf = paf_next )
  {
      paf_next  = paf->next;

	/* DOTs have their own handler */
      if ( paf->where == DAMAGE_OVER_TIME )
	continue;

      if( is_affected(ch, skill_lookup("wraithform")) )
      {
	ch_in_wraithform = TRUE;
      }

      if ( paf->duration > 0 )
      {
	 if ( paf->type == gsn_rage && ch->fighting != NULL )
	 {
	    check_improve(ch,paf->type,TRUE,5);
	    paf->duration += 2;
 	 }
	 /*Gladiators Do not lose spell duration/level during wait */
	 if (IS_SET(ch->mhs,MHS_GLADIATOR) && !IS_NPC(ch))
	 {
	     if (gladiator_info.time_left < 1 
                 && gladiator_info.bet_counter < 1)
	     {
                paf->duration--;
                if (number_range(0,4) == 0 && paf->level > 0)
                   paf->level--;  /* spell strength fades with time */
	     }
	 }
	 else
	 {
            paf->duration--;
            if (number_range(0,4) == 0 && paf->level > 0)
               paf->level--;  /* spell strength fades with time */
	 }
      }
      else if ( paf->duration < 0 )
    ;
      else
      {
    if ( paf_next == NULL
    ||   paf_next->type != paf->type
    ||   paf_next->duration > 0 )
    {
        if ( paf->type > 0 && skill_table[paf->type].msg_off )
        {
      send_to_char( skill_table[paf->type].msg_off, ch );
      send_to_char( "\n\r", ch );
        }
    }

    /*Kill em if they're still in wraithform and haven't un wraithed*/
    if ( ch_in_wraithform == TRUE 
         && is_affected(ch, skill_lookup("wraithform")) 
         && paf->type == skill_lookup("wraithform") 
       ) 
    {
      if (!IS_IMMORTAL(ch) )
      {
        send_to_char("OH NO! You've stayed in wraithform to long!  {YACK!{x\r\n",ch);
        raw_kill(ch,ch);
      }
    }
    affect_remove( ch, paf,APPLY_BOTH );

      }
  if (   !IS_AFFECTED(ch, AFF_CHARM) 
      && IS_NPC(ch) 
      && !IS_SET(ch->act,ACT_PET) 
      && ch->master != NULL 
      && ch->fighting == NULL )
     die_follower( ch );
  }

  /*
   * Careful with the damages here,
   *   MUST NOT refer to ch after damage taken,
   *   as it may be lethal damage (on NPC).
   */

	if (is_affected(ch, gsn_asphyxiate) && ch != NULL )
	{
	    int dam;

	    if ( dice(3,10) > get_curr_stat(ch,STAT_CON) )
 	    {
		act("$n gasps in pain as $e struggles to breathe.",
			ch,NULL,NULL,TO_ROOM,FALSE);
		act("You gasp in pain as you struggle to breathe.",
			ch,NULL,NULL,TO_CHAR,FALSE);
		dam = dice(10,8);
	    }
	    else
	    {
		act("$n breathes laboriously, gasping.",
		    ch,NULL,NULL,TO_ROOM,FALSE);
		act("You breathe laboriously, gasping.",
		    ch,NULL,NULL,TO_CHAR,FALSE);
		dam = dice(5,8); 
	    }

	    damage(ch,ch,dam,gsn_asphyxiate,DAM_OTHER,FALSE,TRUE);
	}

	if (is_affected(ch, gsn_irradiate) && ch != NULL )
	{
	    int dam = 10;
	    AFFECT_DATA *paf;
	    int duration = 0, i;

	    if (ch->in_room == NULL)
		return;

 	    act("$n is wracked with painful nervous spasms.",
		ch,NULL,NULL,TO_ROOM,FALSE);
	    act("Your body is wracked by painful nervous spasms.",
		ch,NULL,NULL,TO_CHAR,FALSE);

	    for ( paf = ch->affected ;    paf != NULL ; paf = paf->next )
	       if ( paf->type == gsn_irradiate )
	       {
	   	   duration = paf->bitvector+1;
		   break;
	       }

	    for ( i = 0 ; i < duration ; i++ ) 
	       dam *= 2; /* dmage increases each round you have it */

	    damage(ch,ch,dam,gsn_irradiate,DAM_ENERGY,FALSE,TRUE);
	}


        if (is_affected(ch, gsn_plague) && ch != NULL)
        {
            //AFFECT_DATA *af;
	    ///* to go with comment out of contagion affect
            AFFECT_DATA *af, plague;
            CHAR_DATA *vch;
	    //*/
            int dam;

      if (ch->in_room == NULL)
    continue;
            
      act("$n writhes in agony as plague sores erupt from $s skin.",
    ch,NULL,NULL,TO_ROOM,FALSE);
      send_to_char("You writhe in agony from the plague.\n\r",ch);
            for ( af = ch->affected; af != NULL; af = af->next )
            {
              if (af->type == gsn_plague)
                    break;
            }
        
            if (af == NULL)
            {
              REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
              continue;
            }

            if (af->level == 1)
              continue;

//  /* Removed contagion effect ****
      plague.where    = TO_AFFECTS;
            plague.type     = gsn_plague;
            plague.level    = af->level - 1; 
            plague.duration   = number_range(1,2 * plague.level);
            plague.location   = APPLY_STR;
            plague.modifier   = -5;
            plague.bitvector  = AFF_PLAGUE;
        
            for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
            {
              if (!saves_spell(plague.level - 2,vch,DAM_DISEASE) 
              && vch->level > 10 
              && !IS_IMMORTAL(vch)
              && !IS_AFFECTED(vch,AFF_PLAGUE) && number_bits(4) == 0)
              {
                  send_to_char("You feel hot and feverish.\n\r",vch);
                  act("$n shivers and looks very ill.",vch,NULL,NULL,TO_ROOM,FALSE);
                  affect_join(vch,&plague);
              }
            }

 //****/
      dam = UMIN(ch->level,af->level/5+1);
      ch->mana -= dam;
      ch->move -= apply_chi(ch,dam);
      damage( ch, ch, dam, gsn_plague,DAM_DISEASE,FALSE,TRUE);
        }
  else if ( IS_AFFECTED(ch, AFF_POISON) && ch != NULL
       &&   !IS_AFFECTED(ch,AFF_SLOW))

  {
      AFFECT_DATA *poison;

      poison = affect_find(ch->affected,gsn_poison);

      if (poison != NULL)
      {
          act( "$n shivers and suffers.", ch, NULL, NULL, TO_ROOM ,FALSE);
          send_to_char( "You shiver and suffer.\n\r", ch );
          damage(ch,ch,poison->level/10 + 1,gsn_poison,DAM_POISON,FALSE,TRUE);
//COREY DO THE REM AFF SLEEP HERE
          if ( IS_AFFECTED(ch, AFF_SLEEP) )
          {
            affect_strip( ch, gsn_sleep );
            REMOVE_BIT(ch->affected_by, AFF_SLEEP);
          }
      }
  }

  /* Reset MOB s daze state if they aren't fighting */
  if(IS_NPC(ch) && ch->fighting == NULL)
	ch->daze = 0;

  /* Kris */
  if ((ch->life_timer > 0) && IS_NPC(ch)) {
    if (ch->life_timer == 1) { /* sorry, guy.. your dead */
      OBJ_DATA *obj,*obj_next;
      switch (ch->pIndexData->vnum) {
  case MOB_VNUM_SKEL_WAR:
     act("$n reenters the realm of the dead.",ch,NULL,NULL,TO_ROOM,FALSE);
     break;

/* Added 28-AUG-00 By Boogums for warhorses to go poof */
  case MOB_VNUM_WARHORSE:
     nuke_pets(ch);
     act("$n returns to the OK Corral.\r\n",ch,NULL,NULL,TO_ROOM,FALSE);
     break;

  case MOB_VNUM_CORPSE:
  default:
    act("$n decays into dust.",ch,NULL,NULL,TO_ROOM,FALSE);
      }
      stop_fighting( ch, TRUE );
      for ( obj = ch->carrying; obj != NULL; obj = obj_next )
      {
  obj_next = obj->next_content;
  obj_from_char( obj );
  REMOVE_BIT(obj->extra_flags,ITEM_VIS_DEATH);
  REMOVE_BIT(obj->extra_flags,ITEM_ROT_DEATH);
  if ( IS_SET( obj->extra_flags, ITEM_INVENTORY ) )
      extract_obj( obj );
  else
    obj_to_room( obj, ch->in_room );
      }

  ch->pIndexData->killed++;
  kill_table[URANGE(0, ch->level, MAX_LEVEL-1)].killed++;
  extract_char( ch, TRUE );
    } else {
      ch->life_timer--;        /* you still got some time left */
    }
  }         
    
    }
    /*
     * Autosave and autoquit.
     * Check that these chars still exist.
     */
    for ( ch = char_list; ch != NULL; ch = ch_next )
    {
      if (!IS_VALID(ch)) {
          bug("update_char: Trying to work with an invalidated character.\n",0);
          break;
      }

        ch_next = ch->next;

  if (ch->desc != NULL && ch->desc->descriptor % 15 == save_number)
      save_char_obj(ch);

        if ( ch == ch_quit )
            do_quit( ch, "" );
    }

    return;
}



/*
 * Update all room affects
 * This one's a bitch
 */
void room_update( void )
{
    AFFECT_DATA *raf, *raf_next;
    ROOM_INDEX_DATA *pRoom;
    int i;

    for ( i = 1 ; i < 40000 ; i++ )
    {
       if ( ( pRoom = get_room_index(i) ) == NULL )
	   continue;

       if ( pRoom->affected == NULL )
	   continue;

       for ( raf = pRoom->affected ; raf != NULL ; raf = raf_next )
       {
	  raf_next = raf->next;
	  if ( raf->duration > 0 )
	  {
	      raf->duration--;
	  }
	  else
    	  if ( raf->duration < 0 )
		;
	  else
	  {   
	     if ( raf_next == NULL ||
		  raf_next->type != raf->type ||
		  raf_next->duration > 0 )
	     {
		 if ( raf->type > 0 && skill_table[raf->type].msg_off )
		 {
		    send_to_room(skill_table[raf->type].msg_off,pRoom);
		 }
	     }

	     raffect_remove(pRoom,raf);
       	  }
    }
    }
    return;
} 

/*
 * Update all objs.
 * This function is performance sensitive.
 */
void obj_update( void )
{   
    OBJ_DATA *obj;
    OBJ_DATA *obj_next;
    AFFECT_DATA *paf, *paf_next;
    ROOM_INDEX_DATA *to_room; 

    for ( obj = object_list; obj != NULL; obj = obj_next )
    {
  CHAR_DATA *rch;
  char *message;

  obj_next = obj->next;

  if (obj->item_type == ITEM_PORTAL 
      && obj->value[2] > 0 
      && obj->carried_by == NULL 
      && IS_SET(obj->value[2], GATE_RANDOM_ROOM))
  {
    obj->value[4] -= 1;
    if (obj->value[4] < 0 )
    {
    obj->value[4] = number_range(1,10);
    to_room = get_random_room_obj();
    obj_from_room(obj);
    obj_to_room(obj, to_room);
    }
  }

  /* Decriment the stolen timer */
  if(obj->stolen_timer > 0)
  { obj->stolen_timer--;}
  if(obj->stolen_timer < 0)
  { obj->stolen_timer = 0; }

  /* go through affects and decrement */
        for ( paf = obj->affected; paf != NULL; paf = paf_next )
        {
            paf_next    = paf->next;
            if ( paf->duration > 0 )
            {
                paf->duration--;
                if (number_range(0,4) == 0 && paf->level > 0)
                  paf->level--;  /* spell strength fades with time */
            }
            else if ( paf->duration < 0 )
                ;
            else
            {
                if ( paf_next == NULL
                ||   paf_next->type != paf->type
                ||   paf_next->duration > 0 )
                {
                    if ( paf->type > 0 && skill_table[paf->type].msg_obj )
                    {
      if (obj->carried_by != NULL)
      {
          rch = obj->carried_by;
          act(skill_table[paf->type].msg_obj,
        rch,obj,NULL,TO_CHAR,FALSE);
      }
      if (obj->in_room != NULL 
      && obj->in_room->people != NULL)
      {
          rch = obj->in_room->people;
          act(skill_table[paf->type].msg_obj,
        rch,obj,NULL,TO_ALL,FALSE);
      }
                    }
                }

                affect_remove_obj( obj, paf );
            }
        }

  /* If the Object has a Wear_timer and the Obj is being worn */
  /* If the carried_by is NULL it could be in a container, but its not being worn */
  /*
  if (obj->carried_by != NULL)
  {
     if (IS_SET(obj->extra_flags,ITEM_WEAR_TIMER)
         && obj == get_eq_char( obj->carried_by, obj->wear_loc ) )
     {
        if (obj->wear_timer <= 0 || --obj->wear_timer > 0)
           continue;
     }
  }
  else
  {
  */
     if ( obj->timer <= 0 || --obj->timer > 0 )
     {
       /*  Added by Nightdagger, 07/16/03   */
       if ( (obj->carried_by != NULL) && (obj->timer > 0 && obj->timer < 5) && (obj->pIndexData->vnum == OBJ_VNUM_DISC) )
          send_to_char("Your floating disc shimmers and begins to fade\n\r",obj->carried_by);

       /* if the object is in a room, is takeable, and is in air or water */
        if (     obj->in_room != NULL 
	     && IS_SET( obj->wear_flags , ITEM_TAKE ) 
	     && ( obj->item_type != ITEM_FURNITURE ) 
	     && (    obj->in_room->sector_type == SECT_AIR
		 || obj->in_room->sector_type == SECT_WATER_NOSWIM 
		 || obj->in_room->sector_type == SECT_WATER_SWIM          
	        )
	   )
	{ 
/* pick a direction, similar to tsumani code, can't move
   if no door in that direction, no room in that direction,
   room is a clan hall, door is closed,  go from air to
   water or water to air , I split it up in different
   if statements to simplify it for the reader */ 

         EXIT_DATA *pexit;
         int original_type, new_type;
	 int door = number_door();
	 if (    ( pexit = obj->in_room->exit[door] ) == 0
		    ||   pexit->u1.to_room == NULL
		   ||   pexit->u1.to_room->clan
		  ||   IS_SET(pexit->exit_info, EX_CLOSED)
    	   )
	  continue;


         new_type = pexit->u1.to_room->sector_type;
	 original_type = obj->in_room->sector_type;
         if( /* can't from air to water */
             (       original_type == SECT_AIR 
		&&  (    new_type == SECT_WATER_NOSWIM
		       || new_type == SECT_WATER_SWIM
		     )
	     )
	   || /* or from water to air */
	     (       new_type == SECT_AIR 
	        &&  (    original_type == SECT_WATER_NOSWIM
	       	     || original_type == SECT_WATER_SWIM
	            )
 	     )
	   )
	   continue;

/* send a message to people in the original room with the object */  
          if (( rch = obj->in_room->people ) != NULL )
	  {
	     if ( original_type == SECT_AIR )
	     {
	       act( "$p is blown away.", rch, obj, NULL, TO_ROOM ,FALSE);
	       act( "$p is blown away.", rch, obj, NULL, TO_CHAR ,FALSE);
	     }
	     else
	     {
	       act( "$p floats away.", rch, obj, NULL, TO_ROOM ,FALSE);
	       act( "$p floats away.", rch, obj, NULL, TO_CHAR ,FALSE);
             }
	  }
	   /* move the object to the next room */
         obj_from_room(obj);
	 obj_to_room(obj,pexit->u1.to_room);

/* send a message to people in the new room with the object */  
          if (( rch = obj->in_room->people ) != NULL )
	  {
	     if ( original_type == SECT_AIR )
	     {
	       act( "$p is blown in.", rch, obj, NULL, TO_ROOM ,FALSE);
	       act( "$p is blown in.", rch, obj, NULL, TO_CHAR ,FALSE);
	     }
	     else
	     {
	       act( "$p floats in.", rch, obj, NULL, TO_ROOM ,FALSE);
	       act( "$p floats in.", rch, obj, NULL, TO_CHAR ,FALSE);
             }
          }
        
      }
     continue;
     }
  /*}
  */

  switch ( obj->item_type )
  {
  default:              message = "$p crumbles into dust.";  break;
  case ITEM_FOUNTAIN:   message = "$p dries up.";         break;
  case ITEM_CORPSE_NPC: message = "$p decays into dust."; break;
  case ITEM_CORPSE_PC:  message = "$p decays into dust."; break;
  case ITEM_FOOD:       message = "$p decomposes."; break;
  case ITEM_POTION:     message = "$p has evaporated from disuse."; 
                break;
  case ITEM_PORTAL:     message = "$p fades out of existence."; break;
  case ITEM_CONTAINER: 
      if (CAN_WEAR(obj,ITEM_WEAR_FLOAT))
    if (obj->contains)
        message = 
    "$p flickers and vanishes, spilling its contents on the floor.";
    else
        message = "$p flickers and vanishes.";
      else
    message = "$p crumbles into dust.";
      break;
  }

  if ( obj->carried_by != NULL )
  {
      if (IS_NPC(obj->carried_by) 
      &&  obj->carried_by->pIndexData->pShop != NULL)
    obj->carried_by->silver += obj->cost/5;
      else
      {
        act( message, obj->carried_by, obj, NULL, TO_CHAR ,FALSE);
    if ( obj->wear_loc == WEAR_FLOAT)
        act(message,obj->carried_by,obj,NULL,TO_ROOM,FALSE);
      }
  }
  else if ( obj->in_room != NULL
  &&      ( rch = obj->in_room->people ) != NULL )
  {
      if (! (obj->in_obj && obj->in_obj->pIndexData->vnum == OBJ_VNUM_PIT
             && !CAN_WEAR(obj->in_obj,ITEM_TAKE)))
      {
        act( message, rch, obj, NULL, TO_ROOM ,FALSE);
        act( message, rch, obj, NULL, TO_CHAR ,FALSE);
      }
  }

        if ((obj->item_type == ITEM_CORPSE_PC || obj->wear_loc == WEAR_FLOAT)
  &&  obj->contains)
  {   /* save the contents */
          OBJ_DATA *t_obj, *next_obj;

      for (t_obj = obj->contains; t_obj != NULL; t_obj = next_obj)
      {
    next_obj = t_obj->next_content;
    obj_from_obj(t_obj);

    if (obj->in_obj) /* in another object */
        obj_to_obj(t_obj,obj->in_obj);

    else if (obj->carried_by)  /* carried */
        if (obj->wear_loc == WEAR_FLOAT)
      if (obj->carried_by->in_room == NULL)
          extract_obj(t_obj);
      else
          obj_to_room(t_obj,obj->carried_by->in_room);
        else
          obj_to_char(t_obj,obj->carried_by);

    else if (obj->in_room == NULL)  /* destroy it */
        extract_obj(t_obj);

    else /* to a room */
        obj_to_room(t_obj,obj->in_room);
      }
  }

  extract_obj( obj );
    }

    return;
}



/*
 * Aggress.
 *
 * for each mortal PC
 *     for each mob in room
 *         aggress on some random PC
 *
 * This function takes 25% to 35% of ALL Merc cpu time.
 * Unfortunately, checking on each PC move is too tricky,
 *   because we don't the mob to just attack the first PC
 *   who leads the party into the room.
 *
 * -- Furey
 */
void aggr_update( void )
{
    CHAR_DATA *wch;
    CHAR_DATA *wch_next;
    CHAR_DATA *ch;
    CHAR_DATA *ch_next;
    CHAR_DATA *vch;
    CHAR_DATA *vch_next;
    CHAR_DATA *victim;

    for ( wch = char_list; wch != NULL; wch = wch_next )
    {
  wch_next = wch->next;
  if ( IS_NPC(wch)
  ||   wch->level >= LEVEL_IMMORTAL
  ||   wch->in_room == NULL 
  ||   wch->in_room->area->empty)
      continue;

  for ( ch = wch->in_room->people; ch != NULL; ch = ch_next )
  {
      int count;

      ch_next = ch->next_in_room;
      if ( (wch->pcdata->outcT > 0 && wch->clan == clan_lookup("outcast"))
      &&   IS_NPC(ch)
      && IS_AWAKE(ch)
      && !IS_AFFECTED(ch,AFF_CALM)
      && !IS_AFFECTED(ch,AFF_CHARM)
      && ch->fighting == NULL
      && can_see( ch, wch, FALSE ) 
      && !IS_IMMORTAL(wch) 
      && number_bits(1) != 0 
      && ch->pIndexData->pShop == NULL
      && !IS_SET(ch->act,ACT_TRAIN)
      && !IS_SET(ch->act,ACT_PRACTICE)
      && !IS_SET(ch->act,ACT_IS_HEALER)
      && !IS_SET(ch->act,ACT_IS_CHANGER)
      && ch->pIndexData->vnum != 3011
           )
      {
         multi_hit( ch, wch, TYPE_UNDEFINED ); 
         continue;
      } 

      if ( !IS_NPC(ch)
      ||   !IS_SET(ch->act, ACT_AGGRESSIVE)
      ||   IS_SET(ch->in_room->room_flags,ROOM_SAFE)
      ||   IS_AFFECTED(ch,AFF_CALM)
      ||   ch->fighting != NULL
      ||   IS_AFFECTED(ch, AFF_CHARM)
      ||   !IS_AWAKE(ch)
      ||   ( IS_SET(ch->act, ACT_WIMPY) && IS_AWAKE(wch) )
      ||   !can_see( ch, wch, FALSE ) 
      ||   number_bits(1) == 0)
    continue;

      /*
       * Ok we have a 'wch' player character and a 'ch' npc aggressor.
       * Now make the aggressor fight a RANDOM pc victim in the room,
       *   giving each 'vch' an equal chance of selection.
       */
      count = 0;
      victim  = NULL;
      for ( vch = wch->in_room->people; vch != NULL; vch = vch_next )
      {
    vch_next = vch->next_in_room;

    if ( !IS_NPC(vch)
    &&   vch->level < LEVEL_IMMORTAL
    &&  vch->position > POS_INCAP
    &&   ch->level >= vch->level - 5 
    &&   get_curr_stat(vch,STAT_SOC) <= number_range(16,23) 
    &&   ( !IS_SET(ch->act, ACT_WIMPY) || !IS_AWAKE(vch) )
    &&   can_see( ch, vch, FALSE ) )
    {
        if ( number_range( 0, count ) == 0 )
      victim = vch;
        count++;
    }
      }

      if ( victim == NULL )
    continue;

      if (ch->position < POS_STANDING)
	 do_stand(ch,"");

      multi_hit( ch, victim, TYPE_UNDEFINED );
  }
    }

    return;
}



/*
 * Handle all kinds of updates.
 * Called once per pulse from game loop.
 * Random times to defeat tick-timing clients and players.
 */

void update_handler( void )
{
    static  int     pulse_area;
    static  int     pulse_mobile;
    static  int     pulse_violence;
    static  int     pulse_point;
    static  int     pulse_music;
    static  int		pulse_dot;
    char buf[MAX_STRING_LENGTH];

    if ( --pulse_area     <= 0 )
    {
  pulse_area  = PULSE_AREA;
  /* number_range( PULSE_AREA / 2, 3 * PULSE_AREA / 2 ); */
  area_update ( );
    }

    if ( --pulse_music    <= 0 )
    {
  pulse_music = PULSE_MUSIC;
  /* song_update(); */
    }

    if ( --pulse_mobile   <= 0 )
    {
  pulse_mobile  = PULSE_MOBILE;
  mobile_update ( );
    }

     /* Do this before combat */
    if ( --pulse_dot <= 0 )
    {
  pulse_dot	= PULSE_DOT;
  dot_update( );
     }

    if ( --pulse_violence <= 0 )
    {
  pulse_violence  = PULSE_VIOLENCE;
  violence_update ( );
    }

    if ( --pulse_point    <= 0 )
    {
  pulse_point     = number_range( 3 * PULSE_TICK / 4, 5 * PULSE_TICK / 4 );
  sprintf(buf,"TICK at %s{G-->{x Next tick lasts %d seconds",
	(char *) ctime( &current_time ), (pulse_point/5)+2 );
  wiznet(buf,NULL,NULL,WIZ_TICKS,0,0);
  weather_update  ( );
  char_update ( );
  obj_update  ( );
  room_update ( );
  gladiator_update ( );
    }

    aggr_update( );
    tail_chain( );
    return;
}

void dot_update( void )
{
    CHAR_DATA *ch, *ch_next;
    AFFECT_DATA *paf, *paf_next;

    for ( ch = char_list ; ch != NULL ; ch = ch_next )
    {
	ch_next = ch->next;
	
	sector_damage(ch);

	if ( ch->affected == NULL )
	    continue;

	for ( paf = ch->affected ; paf != NULL ; paf = paf_next )
  	{
 	    paf_next = paf->next;

	    if ( paf->where == DAMAGE_OVER_TIME )
		{
		  dot( ch, paf );
		  if (ch->pcdata && ch->pcdata->quit_time == 1)
		  ++ch->pcdata->quit_time;
		}
	}
    }
    return;
}

void sector_damage(CHAR_DATA *ch)
{
	bool char_safe = FALSE;
	if (is_affected(ch,skill_lookup("wraithform")) )
		char_safe = TRUE;
        if (is_affected(ch,skill_lookup("water breathing")) )
                char_safe = TRUE;

	if(ch->in_room != NULL)
	{
	switch(ch->in_room->sector_type)
 	{
	default:
	break;
	case SECT_FIRE_PLANE:
	  if (number_percent() < 15 && !IS_SET(ch->imm_flags,IMM_FIRE) && !IS_IMMORTAL(ch) &&
	      !is_affected(ch,skill_lookup("wraithform")) )
	  {
		act("You are scorched by a jet of flame from the ground!", ch, NULL, NULL, TO_CHAR, FALSE);
		act("$n is scorched by a jet of flame from the ground!", ch, NULL, NULL, TO_ROOM, FALSE);
		damage(ch,ch,ch->level/2,0,DAM_FIRE,FALSE,FALSE);
	  }
          break;
        case SECT_WATER_PLANE:
	  if ( number_percent() < 40 && !IS_SET(ch->imm_flags, IMM_DROWNING) && !IS_IMMORTAL(ch) && char_safe == FALSE ) 
/*       ( (!is_affected(ch, skill_lookup("water breathing"))) || (!is_affected(ch,skill_lookup("wraithform"))) )
*/
          {
		act("Your lungs scream with the need for air!", ch, NULL, NULL, TO_CHAR, FALSE);
		act("$n gasps for air and gulps down some water!", ch, NULL, NULL, TO_ROOM, FALSE);
		damage(ch,ch,ch->level*3/2,0,DAM_DROWNING,FALSE,FALSE);
	  }
	  break;
	}
	}
	return;
}	
@


1.312
log
@ok took out the update thingie
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.311 2004/09/28 01:00:46 boogums Exp $";
d2163 1
a2163 1
      if ( (ch->pcdata->outcT > 0 && wch->clan == clan_lookup("outcast"))
@


1.311
log
@making it so you cannot drag mobs
added a !clan check to the guard mob specs
did somethign in update.c but can't remember, oh yeah i thin i remember
now somethign with outcasts...
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.310 2004/06/21 20:06:55 boogums Exp $";
a2179 6
      /*  if ( wch->clan == clan_lookup("outcast")  )
        {
          sprintf( buf, "%s is a %s!  PROTECT THE INNOCENT!!  BANZAI!!",
            victim->name, crime );
        }
       */
@


1.310
log
@ok tweaking with vampiric touch and vorpaling sharpen fails
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.309 2004/04/03 18:05:23 boogums Exp $";
d2163 1
a2163 1
      if ( wch->clan == clan_lookup("outcast")
d2180 6
@


1.309
log
@making hassan not wack outcasts
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.308 2004/04/03 17:52:02 boogums Exp $";
d234 2
a235 1
      number_percent() * number_percent() < 25       &&
d244 2
a245 2
      act("$p suddenly looks a bit more wicked.",ch,weapon,NULL,TO_CHAR,FALSE);
      act("$p suddenly looks a bit more wicked.",ch,weapon,NULL,TO_ROOM,FALSE);
@


1.308
log
@trying out something
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.307 2004/04/03 06:03:23 boogums Exp $";
d2176 1
@


1.307
log
@ok taking it down
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.306 2004/04/03 05:58:42 boogums Exp $";
d2162 1
a2162 2
      
      /*if ( wch->clan == clan_lookup("outcast")
d2170 7
a2176 1
      && number_bits(1) != 0 )
a2180 1
      */
@


1.306
log
@damn shop keepers
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.305 2004/04/03 05:47:25 boogums Exp $";
d2163 1
a2163 1
      if ( wch->clan == clan_lookup("outcast")
d2176 1
@


1.305
log
@ok this thous get it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.304 2004/04/03 05:43:08 boogums Exp $";
d2170 2
a2171 1
      && !IS_IMMORTAL(wch) )
@


1.304
log
@ok it works
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.303 2004/04/03 05:35:11 boogums Exp $";
d2169 1
a2169 1
      && can_see( ch, wch, TRUE ) 
@


1.303
log
@lets try this
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.302 2004/04/03 05:23:24 boogums Exp $";
d2168 3
a2170 1
      && can_see( ch, wch, TRUE ) )
@


1.302
log
@took it out
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.301 2004/04/03 05:18:59 boogums Exp $";
d2162 11
@


1.301
log
@let's try this
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.300 2004/04/03 05:13:01 boogums Exp $";
a2184 7
    if ( !IS_NPC(vch) 
         && vch->clan == clan_lookup("outcast")
         && IS_NPC(ch)
       )
    {
      multi_hit(ch, vch, TYPE_UNDEFINED );
    }
@


1.300
log
@damn didn't work
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.299 2004/04/03 05:08:55 boogums Exp $";
d2185 8
@


1.299
log
@checking making npcs attack outcasts
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.298 2003/12/10 03:04:56 boogums Exp $";
a2184 6
        //outcast check?
        if ( vch->clan==clan_lookup("outcast") && IS_NPC(ch) )
        {
          multi_hit( ch, vch, TYPE_UNDEFINED );
        }

@


1.298
log
@fixing summon dead
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.297 2003/12/07 23:29:40 boogums Exp $";
d2185 5
@


1.297
log
@forgot about remort damage
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.296 2003/12/06 23:09:55 boogums Exp $";
d1378 1
a1378 1
	     send_to_char("Your blood torments you.\n\r",ch);
d1391 1
a1391 1
	     send_to_char("Your blood torments you.\n\r",ch);
@


1.296
log
@bug fixes
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.295 2003/12/06 22:41:00 boogums Exp $";
d1376 1
a1376 1
	     send_to_char("Your rags are burning up!\n\r",ch);
d1379 5
d1389 1
a1389 1
	     send_to_char("Your rags are burning up!\n\r",ch);
@


1.295
log
@t ok got it now and making plague contagous again
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.294 2003/12/06 22:33:48 boogums Exp $";
d1697 4
a1700 3
                if (!saves_spell(plague.level - 2,vch,DAM_DISEASE) 
    &&  !IS_IMMORTAL(vch)
              &&  !IS_AFFECTED(vch,AFF_PLAGUE) && number_bits(4) == 0)
@


1.294
log
@make yourself immune sleep bug fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.293 2003/12/06 22:14:33 boogums Exp $";
d1658 2
a1659 2
            AFFECT_DATA *af;
	    /* to go with comment out of contagion affect
d1662 1
a1662 1
	    */
d1686 1
a1686 1
/* Removed contagion effect ****
d1707 1
a1707 1
****/
@


1.293
log
@poison bug fix i think
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.292 2003/12/04 03:35:55 boogums Exp $";
d1730 1
@


1.292
log
@turn undead and necor changes
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.291 2003/11/22 15:29:41 boogums Exp $";
d1726 5
@


1.291
log
@t tweaking vamp/nether
also makde scribed scrolls harder to recite
bogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.290 2003/11/22 15:08:33 boogums Exp $";
d234 1
a234 1
      number_percent() * number_percent() < 15       &&
@


1.290
log
@moving check vampiric back into update.c with new parameters
also tweaked nethered weapon
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.289 2003/09/20 18:34:20 boogums Exp $";
d207 2
a208 2
//    changed the line below to be > 18 instead of <12
   if ( number_percent() * number_percent() < 18 &&
d211 1
a211 1
	number_percent() < ch->level / (weapon->enchanted?4:2) &&
d215 1
d234 1
a234 1
      number_percent() * number_percent() < 30       &&
d236 1
a236 1
      number_percent() < ch->level / (weapon->enchanted?3:2)  &&
d241 1
@


1.289
log
@fixed trade with self bug and aggy check
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.288 2003/09/15 17:25:12 mud Exp $";
d207 2
a208 1
   if ( number_percent() * number_percent() < 12 &&
d210 2
a211 1
	number_percent() < ch->level / (weapon->enchanted?5:2) &&
a221 1
#ifdef COREYTEST
d226 4
a229 1
  if( !HAS_KIT(ch,"necromancer") || ch->position != POS_FIGHTING )
d231 1
a231 1

d233 1
a233 1
      number_percent() * number_percent() < 10       &&
d235 1
a235 1
      number_percent() < ch->level + 5 / (weapon->enchanted?3:2)  &&
a244 1
#endif
d1190 1
a1190 1
	//check_vampirictouch( ch );
@


1.288
log
@Adjuct tick timer notice on wiznet ticks
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.287 2003/07/16 20:20:15 ndagger Exp $";
d2173 1
a2173 1
    &&   get_curr_stat(vch,STAT_SOC) <= number_range(13,18) 
@


1.287
log
@07/16/03 Nightdagger:  Floating Disc, take 3...hopefully the last
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.286 2003/07/16 20:08:22 ndagger Exp $";
d2250 1
a2250 1
	(char *) ctime( &current_time ), (pulse_point/4)+2 );
@


1.286
log
@07/16/03 Nightdagger:  Floating disc, take two
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.285 2003/07/16 19:57:38 ndagger Exp $";
d1937 3
a2022 8
/*  Added by Nightdagger, Jul 16 2003 */

  if ( (obj->timer >0 && obj->timer <5) && (obj->pIndexData->vnum == OBJ_VNUM_DISC) )
    {
        message = "$p begins to shimmer and fade away.";
        act( message, obj->carried_by, obj, NULL, TO_CHAR, FALSE);
    }

@


1.285
log
@07/16/03 Nightdagger:  Added early warning to floating discs fading.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.284 2003/06/29 03:44:56 boogums Exp $";
d2023 4
a2026 2
      send_to_char("Your floating disc shimmers and begins to fade\n\r",obj->carried_by);

@


1.284
log
@social check
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.283 2003/06/07 21:25:50 boogums Exp $";
d2020 6
@


1.283
log
@ok factoring in soc to charm and endurance to hp and move gains
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.282 2003/04/14 05:54:08 ndagger Exp $";
d2170 1
a2170 1
    &&   get_curr_stat(vch,STAT_SOC) >= number_range(13,18) 
@


1.282
log
@04/13/03 Nightdagger:  Last (I hope) of the autoswitching stuff for deities.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.281 2003/04/14 04:36:14 ndagger Exp $";
d308 3
d312 1
a312 2

 add_hp  = add_hp + ((con_app[get_curr_stat(ch,STAT_STR)].hitp + number_range(
d314 1
a314 1
        class_table[old_class].hp_max ))/4);
d388 4
d394 11
d2170 1
@


1.281
log
@04/13/03 Nightdagger:  First part of clan system change:  removed ability to pledge to the Almighty directly, and removed deity switch timer, pledge now switches immediately.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.280 2003/03/11 03:01:15 boogums Exp $";
d1185 5
@


1.280
log
@ok vamping is now harder
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.279 2003/03/08 21:42:47 boogums Exp $";
d1190 1
d1196 2
@


1.279
log
@moved the necromancer vampiric touch check to bool damage in fight.c
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.278 2003/01/24 04:47:11 boogums Exp $";
d220 1
d241 2
@


1.278
log
@fucking ands and ors
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.277 2003/01/24 03:24:13 boogums Exp $";
d1167 1
a1167 1
	check_vampirictouch( ch );
@


1.277
log
@ok making vamping harder
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.276 2003/01/24 03:21:19 boogums Exp $";
d224 1
a224 2
  if( (!HAS_KIT(ch,"necromancer") || IS_SET(ch->comm,COMM_AFK)) 
    && ch->position != POS_FIGHTING  )
d228 1
a228 1
      number_percent() * number_percent() < 20        &&
@


1.276
log
@making vamping a weapon a bit harder
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.275 2002/12/09 18:47:36 boogums Exp $";
d224 2
a225 2
  if( !HAS_KIT(ch,"necromancer") || IS_SET(ch->comm,COMM_AFK) 
    || ch->position == POS_FIGHTING  )
@


1.275
log
@damn waterbreathing bug
damn boolean logic
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.274 2002/12/09 03:01:07 boogums Exp $";
d224 2
a225 1
  if( !HAS_KIT(ch,"necromancer") || IS_SET(ch->comm,COMM_AFK) )
d229 1
a229 1
      number_percent() * number_percent() < 8        &&
d231 1
a231 1
      number_percent() < ch->level / (weapon->enchanted?5:2)  &&
@


1.274
log
@damn or statements, i THINK this one will catch it ;)
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.273 2002/12/08 00:59:40 boogums Exp $";
d2263 6
d2285 3
a2287 4
	  if ( (number_percent() < 40 && !IS_SET(ch->imm_flags, IMM_DROWNING) && !IS_IMMORTAL(ch)) 
          &&
       ( (!is_affected(ch, skill_lookup("water breathing"))) || (!is_affected(ch,skill_lookup("wraithform"))) )
             )
@


1.273
log
@should have water breathing bug fixed
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.272 2002/12/05 05:16:57 boogums Exp $";
d2281 1
a2281 1
       ( !is_affected(ch, skill_lookup("water breathing")) || !is_affected(ch,skill_lookup("wraithform")) )
@


1.272
log
@ok here goes the wand maker kit
and removing damage from pof while in wraith
*gulp* i hate messing with merc.h
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.271 2002/11/26 06:07:38 boogums Exp $";
d2279 4
a2282 2
	  if (number_percent() < 40 && !IS_SET(ch->imm_flags, IMM_DROWNING) && !IS_IMMORTAL(ch) &&
              (!is_affected(ch, skill_lookup("water breathing")) || !is_affected(ch,skill_lookup("wraithform")) ) )
@


1.271
log
@damn it
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.270 2002/11/26 05:57:31 boogums Exp $";
d2270 2
a2271 1
	  if (number_percent() < 15 && !IS_SET(ch->imm_flags,IMM_FIRE) && !IS_IMMORTAL(ch))
d2280 1
a2280 1
              !is_affected(ch, skill_lookup("water breathing")) )
@


1.270
log
@doh
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.269 2002/11/26 05:35:27 boogums Exp $";
d1433 1
a1433 1
	  --ch->pcdata->start_time;
@


1.269
log
@adding a start pfight timer to combat IM scouters
corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.268 2002/11/11 18:20:52 rusty Exp $";
d1432 1
a1432 1
      if (ch->pcdata && ch->pcdata->start_time >0)
@


1.268
log
@If they have a DOT and their quit timer is about to expire
bump it up one tick so they can't quit until the DOT is gone.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.267 2002/10/25 15:39:31 rusty Exp $";
d1431 3
@


1.267
log
@Poosible fix to irradiate perma-blind with dust storm
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.266 2002/05/23 18:27:02 rusty Exp $";
d2248 5
a2252 1
		dot( ch, paf );
@


1.266
log
@Never gank a teleporting portal from someone's inventory
CVS  ----------------------------------------------------------------------
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.265 2002/05/23 18:18:40 rusty Exp $";
d1609 1
a1609 1
	   	   duration = paf->bitvector++;
@


1.265
log
@Don't let portals with v2 0 or -1 get freaky
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.264 2002/05/22 21:30:20 rusty Exp $";
d1829 2
a1830 1
      && obj->value[2] > 0
@


1.264
log
@stolen_timer not decrimenting below 0
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.263 2002/05/22 18:00:42 rusty Exp $";
d1828 3
a1830 1
  if (obj->item_type == ITEM_PORTAL && IS_SET(obj->value[2], GATE_RANDOM_ROOM))
@


1.263
log
@All gems end up in corpses.
All items stolen within the last 10*number_fuzzy(5) ticks go into corpses.
Items taken by steal, loot, heat metal and disarm get timers
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.262 2002/05/21 20:20:59 rage Exp $";
d1841 4
a1844 1
  obj->stolen_timer--;
@


1.262
log
@dropped potion costs for alchemy
added randomly teleporting portal for Slodhain area
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.261 2002/04/17 15:06:14 poquah Exp $";
d1839 3
@


1.261
log
@lowered newbie flag removal to age 20 from age 24
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.260 2002/04/01 21:47:30 rusty Exp $";
d1819 1
d1827 12
@


1.260
log
@PNET_LEVELS
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.259 2002/03/13 03:02:26 rusty Exp $";
d1178 1
a1178 1
                    get_age(ch) > 24)
d1400 1
@


1.259
log
@Took HMV gain numbers out of level
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.258 2002/03/12 15:55:24 rusty Exp $";
d505 1
@


1.258
log
@Send level update buf
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.257 2002/03/12 03:01:08 rusty Exp $";
d417 2
a418 8
    sprintf( buf,
  "Your gain is: %d/%d hp, %d/%d m, %d/%d mv %d/%d prac.\n\r",
  add_hp,   ch->max_hit,
  add_mana, ch->max_mana,
  add_move, ch->max_move,
  add_prac, ch->practice
  );
//    send_to_char( "You feel wiser and more adept.\n\r", ch );
@


1.257
log
@Yanked starting HMV as fixed values and put back in gains
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.256 2002/03/09 19:14:30 rusty Exp $";
d425 1
@


1.256
log
@Hiding information and reup_affect() additions. Initial
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.255 2002/02/28 18:32:36 rusty Exp $";
d383 2
a400 1
    /*
a406 1
    */
a416 1
    /*
d424 1
a424 2
    */
    send_to_char( "You feel wiser and more adept.\n\r", ch );
@


1.255
log
@Elementals will use their special attacks while still following.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.254 2002/02/11 18:34:11 poquah Exp $";
d399 1
a402 3
    ch->practice  += add_prac;
    ch->train   += 1;

d406 4
d417 1
d425 2
a426 1
    send_to_char( buf, ch );
@


1.254
log
@adding some smurf abilities
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.253 2002/01/22 20:33:29 rage Exp $";
d915 2
a916 1
  if ( !IS_NPC(ch) || ch->in_room == NULL || IS_AFFECTED(ch,AFF_CHARM))
@


1.253
log
@Fixed bug causing everyone's deity to be set to Mojo on the tick
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.252 2002/01/20 21:09:09 rage Exp $";
d652 3
d762 3
d837 3
@


1.252
log
@changed sequence of events for switching deities
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.251 2001/12/01 23:16:58 poquah Exp $";
a1182 1
			ch->pcdata->new_deity = 0;
@


1.251
log
@working on death code bugs and new tracking fields
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.250 2001/11/25 01:35:56 mud Exp $";
d1178 7
@


1.250
log
@var # mismatch on bug() call
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.249 2001/11/25 01:26:39 rusty Exp $";
a1204 1
	   {
d1206 2
a1207 1
	   }
@


1.249
log
@Webpage crash/bug fixes applied
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.248 2001/11/23 16:25:29 poquah Exp $";
d1730 1
a1730 1
          bug('update_char: Trying to work with an invalidated character.\n'); 
@


1.248
log
@removed extra }
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.247 2001/11/23 16:17:16 poquah Exp $";
d1729 5
@


1.247
log
@Newbie flag and code
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.246 2001/11/06 23:39:18 rage Exp $";
d1170 1
a1170 1
                    get_age(ch) > 24))
@


1.246
log
@added in "iron" and "steel" vuln to elves
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.245 2001/10/22 18:09:18 rusty Exp $";
d1169 7
@


1.245
log
@Made spec_guard_* mobs wander home more often
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.244 2001/10/21 20:35:44 rage Exp $";
d531 2
@


1.244
log
@bug fix in assemble..if the part had no values, we kaboomed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.243 2001/10/14 04:08:44 rage Exp $";
d1216 4
a1219 1
          && !IS_AFFECTED(ch,AFF_CHARM) && (number_percent() < 5) 
@


1.243
log
@added some stuff for water elemental stuff
small change to wall of fire
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.242 2001/10/13 02:11:59 rage Exp $";
d2217 2
a2218 1
	  if (number_percent() < 40 && !IS_SET(ch->imm_flags, IMM_DROWNING) && !IS_IMMORTAL(ch))
d2222 1
a2222 1
		damage(ch,ch,ch->level,0,DAM_DROWNING,FALSE,FALSE);
@


1.242
log
@Bug fixes as follow

can no longer drag furniture that's being used
steal/slice kr only increments on players
IMMs now immune to sector damage
die command should work now
spec_average now has an IS_AWAKE check
Cavalier attack is now given to groupmates
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.241 2001/09/27 22:07:42 rage Exp $";
d2216 8
@


1.241
log
@change to resolve crash bug in sector_damage()
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.240 2001/09/20 02:21:42 rage Exp $";
d2209 1
a2209 1
	  if (number_percent() < 10 && !IS_SET(ch->imm_flags,IMM_FIRE))
@


1.240
log
@added new sector type into OLC
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.239 2001/09/17 23:26:22 rage Exp $";
d2202 2
d2216 1
@


1.239
log
@first attempt and sector type damage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.238 2001/08/24 00:42:19 guerrand Exp $";
d2207 1
a2207 1
	  if (number_percent() < 10)
d2211 1
a2211 1
		damage(ch,ch,10,0,DAM_FIRE,FALSE,FALSE);
@


1.238
log
@Medium kit coded.  Adjusted skill point cost for spirit caller.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.237 2001/08/09 14:25:38 rusty Exp $";
d54 1
a54 1

d2183 2
d2199 18
@


1.237
log
@Chance of nethering upped a bit
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.236 2001/08/05 22:47:37 guerrand Exp $";
d552 1
d650 3
d660 1
d761 3
d771 1
d829 3
@


1.236
log
@Added 5 spells for warlock/witch kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.235 2001/07/27 02:14:12 guerrand Exp $";
d207 2
a208 2
   if ( number_percent() * number_percent() < 10 &&
	(weapon = get_eq_char(ch,WEAR_WIELD)) != NULL &&
d218 1
d240 1
@


1.235
log
@Added spirit caller kit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.234 2001/07/23 03:51:41 guerrand Exp $";
d750 4
@


1.234
log
@
Adjustments for traps.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.233 2001/07/19 03:03:15 mud Exp $";
d390 6
@


1.233
log
@forgot the pIndexData in wander home
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.232 2001/07/19 03:00:26 rusty Exp $";
d1140 7
a1146 1
        
@


1.232
log
@Made shopkeepers (ie Manney) not wander home
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.231 2001/07/15 19:57:21 rage Exp $";
d1190 1
a1190 1
	  && ch->pShop == NULL) 
@


1.231
log
@fix to room_update
-rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.230 2001/07/15 02:19:33 guerrand Exp $";
d1189 2
a1190 1
          && ch->passenger == NULL) 
@


1.230
log
@fixed shapeshifter level bug
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.229 2001/07/15 01:18:40 guerrand Exp $";
d1699 1
d1718 1
a1718 1
       for ( raf = pRoom->affected ; raf == NULL ; raf = raf_next )
a1745 1
/* missing } added because upadte.c needed to compile */
@


1.229
log
@Gargoyle CP lowed by 3, gains adjusted, bug with wound transfer fixed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.228 2001/07/11 17:16:21 rusty Exp $";
d456 7
@


1.228
log
@Made it harder to vamp or nether enchanted weapons
and impossible to vamp or nether favored weapons.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.227 2001/07/05 22:15:06 guerrand Exp $";
d629 1
a629 1
		gain /= 2;
d631 1
a631 1
		gain *= 2;
d733 1
a733 1
	    gain /= 2;
d735 1
a735 1
	    gain *= 2;
a755 3
  if ( out_of_element(ch) && ch->race == race_lookup("gargoyle") )
	return 0;

d798 3
@


1.227
log
@Made killing rage a mite easier to improve.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.226 2001/07/02 16:09:27 mud Exp $";
d208 4
a211 2
	number_percent() < ch->level / 2 &&
	(weapon = get_eq_char(ch,WEAR_WIELD)) != NULL)
a227 1
      number_percent() < ch->level / 2                &&
d229 3
a231 1
      (!IS_SET(weapon->value[4],WEAPON_VAMPIRIC)) 
@


1.226
log
@Adjusting the tick timer for faster CPU
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.225 2001/06/25 16:28:04 rusty Exp $";
d1434 2
d1437 1
@


1.225
log
@Scavengers will not pick up furniture that anyone is on.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.224 2001/06/16 15:24:15 rage Exp $";
d2117 1
a2117 1
	(char *) ctime( &current_time ), (pulse_point/4)+4 );
@


1.224
log
@added spell betrayal - causes skellies etc to betray their master and fight forh the other side
-Rage
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.223 2001/06/15 02:27:52 guerrand Exp $";
d909 1
a909 1
         && obj->cost > max  && obj->cost > 0)
@


1.223
log
@PAladin abolish disease ability.  Neat!
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.222 2001/06/14 00:41:22 guerrand Exp $";
d1709 1
a1709 1
	      --raf->duration;
@


1.222
log
@Updated Vhan's special.  He's mean!
Fixed mummy out of element damage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.221 2001/06/11 00:04:04 rage Exp $";
d1125 5
@


1.221
log
@continuation of wall of fire spell
added function bool is_room_affected to check room effects
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.220 2001/06/07 04:15:42 guerrand Exp $";
d1265 1
a1265 1
	if ( IS_SET(ch->act,PLR_WERE) || IS_SET(ch->act,PLR_VAMP) )
@


1.220
log
@GMAN
I completed the code for damage over time spells.  Some testing will be
needed, first just to make sure the code, while idling, doesn't break
anything else.  Then we can write some DOT spells and see if they work
right.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.219 2001/05/31 00:05:11 guerrand Exp $";
d1724 1
a1724 1

a1727 1
}
@


1.219
log
@GMAN
Made some changes to gargoyles to make them playable.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.218 2001/05/30 03:09:09 guerrand Exp $";
d45 1
d1416 5
d2074 1
d2096 7
d2127 22
@


1.218
log
@FIxed a few things in gargoyles.
1. Fixed starting stats
2. Changed regen a bit.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.217 2001/05/30 02:17:00 guerrand Exp $";
d381 1
a381 1
    if (IS_SET(ch->act,PLR_MUMMY))
d627 1
a627 1
		gain = 3 * gain / 2;
d731 1
a731 1
	    gain = 3 * gain /2 ;
d1262 1
a1262 1
	
d1264 3
d1283 2
@


1.217
log
@Completed Gargoyles.
-Guerrand
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.216 2001/05/30 01:54:00 guerrand Exp $";
d622 8
d726 7
d751 4
d1244 1
d1260 1
@


1.216
log
@GMAN
While AFK, VAMP and NETHER checks are ignored.  So are skill point timers.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.215 2001/04/09 18:30:39 mud Exp $";
d1220 7
d1235 8
@


1.215
log
@Applied rom 2.4 b5 and b6 patches as necessary.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.214 2001/04/09 01:30:27 mud Exp $";
d203 1
a203 1
   if ( !HAS_KIT(ch,"nethermancer"))
d220 1
a220 1
  if( !HAS_KIT(ch,"necromancer"))
d1113 1
a1113 1
	if (!IS_NPC(ch))
@


1.214
log
@Made looting of non-treasure items limited to 4 from a corpse.
Also made group mates and stuff able to loot all from your corpse
to save your ass.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.213 2001/03/20 17:44:34 mud Exp $";
d1507 1
a1507 1
    return;
@


1.213
log
@Fixes to last_attacked_by_timer
Earthbind a bit more difficult to cancel.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.212 2001/03/05 22:11:14 mud Exp $";
d888 1
a888 1
    if ( CAN_WEAR(obj, ITEM_TAKE) && can_loot(ch, obj)
@


1.212
log
@Skill point timer changed
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.211 2001/03/03 18:57:15 mud Exp $";
d1128 2
a1133 2
	   if(ch->pcdata->last_attacked_by_timer == 0)
   	      ch->pcdata->last_attacked_by = str_dup("no one");
@


1.211
log
@Took out bramage() too
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.210 2001/03/03 18:53:59 mud Exp $";
d1115 1
a1115 1
           if (ch->pcdata->skill_point_tracker >= 2)
@


1.210
log
@Took out all references to damage_old() and used iOld var in damage()
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.209 2001/02/10 03:57:10 mud Exp $";
d1259 1
a1259 1
      bramage( ch, ch, 1, TYPE_UNDEFINED, DAM_NONE,FALSE);
d1263 1
a1263 1
      bramage( ch, ch, 1, TYPE_UNDEFINED, DAM_NONE,FALSE);
@


1.209
log
@Faking out slow CPU timing
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.208 2001/02/10 03:42:42 mud Exp $";
d1234 1
a1234 1
	  damage_old( ch, ch, ch->level/3, gsn_plague,DAM_DISEASE,FALSE);
d1466 1
a1466 1
	    damage_old(ch,ch,dam,gsn_asphyxiate,DAM_OTHER,FALSE);
d1493 1
a1493 1
	    damage_old(ch,ch,dam,gsn_irradiate,DAM_ENERGY,FALSE);
d1552 1
a1552 1
      damage_old( ch, ch, dam, gsn_plague,DAM_DISEASE,FALSE);
d1566 1
a1566 2
          damage_old(ch,ch,poison->level/10 + 1,gsn_poison,
        DAM_POISON,FALSE);
@


1.208
log
@Fix wiznet TICK formatting as well as artificial GREEN input
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.207 2001/02/10 03:23:42 mud Exp $";
d2059 1
a2059 1
	(char *) ctime( &current_time ), (pulse_point/4)-1 );
@


1.207
log
@Final TICK changes
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.206 2001/02/10 03:10:11 mud Exp $";
d2058 1
a2058 1
  sprintf(buf,"TICK at %s }G-->{x Next tick lasts %d seconds",
@


1.206
log
@More info about TICK times in wiznet tick
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.205 2001/02/09 22:48:39 mud Exp $";
d2058 2
a2059 2
  sprintf(buf,"TICK at %s next tick lasts %d seconds",
	(char *) ctime( &current_time ), pulse_point/4 );
@


1.205
log
@Skill point timer shrink and shorten
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.204 2001/02/09 22:18:55 mud Exp $";
d2028 1
d2057 4
a2060 3
  wiznet("TICK!",NULL,NULL,WIZ_TICKS,0,0);
  pulse_point     = PULSE_TICK;
  number_range( 3 * PULSE_TICK / 4, 5 * PULSE_TICK / 4 );
@


1.204
log
@Fixed last attacked by never being set to no one.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.203 2001/02/09 22:15:32 mud Exp $";
d1115 1
a1115 1
           if (ch->pcdata->skill_point_tracker >= 35)
a1130 2
	      if(ch->pcdata->last_attacked_by_timer == 0)
   	        ch->pcdata->last_attacked_by = str_dup("no one");
d1132 2
@


1.203
log
@Random tick lengths again
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.202 2000/12/25 21:51:20 mud Exp $";
d1131 1
a1131 1
	      if(ch->pcdata->last_attacked_by_timer = 0)
@


1.202
log
@25dec00
more necromancer tweaking
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.201 2000/12/17 05:12:30 mud Exp $";
d2058 1
a2058 1
/* number_range( PULSE_TICK / 2, 3 * PULSE_TICK / 2 ); */
@


1.201
log
@16DEC00
Tweaked teh vamp code a bit, only took about 18 hours for a weapon
to et flagged
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.200 2000/12/15 20:01:14 mud Exp $";
d224 2
a225 2
      number_percent() * number_percent() < 5        &&
      number_percent() < ch->level / 6                &&
@


1.200
log
@15DEC00
Forgot to do an paf check in the kill function, my bad
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.199 2000/12/15 04:47:18 mud Exp $";
d225 1
a225 1
      number_percent() < ch->level / 4                &&
@


1.199
log
@14DEC00
the hunt to kill em continues
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.198 2000/12/15 04:32:08 mud Exp $";
d1417 4
a1420 1
    if ( ch_in_wraithform == TRUE && is_affected(ch, skill_lookup("wraithform")) )
@


1.198
log
@14DEC00
Hmmm, they weren't dying.  trying this now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.197 2000/12/15 04:24:59 mud Exp $";
a1414 1
    affect_remove( ch, paf,APPLY_BOTH );
d1419 1
a1419 1
      if (!IS_IMMORTAL(ch) && !IS_NPC(ch) )
d1425 1
@


1.197
log
@14DEC00
DOH put the check in teh wrong place
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.196 2000/12/15 03:56:50 mud Exp $";
d1420 1
a1420 1
      if (!IS_IMMORTAL(ch) && !IS_NPC(ch) && ch->desc != NULL)
@


1.196
log
@14DEC00
Okies, the check in the update is in.  Temporary short duration to check
the kill
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.195 2000/12/09 07:05:51 mud Exp $";
d1415 2
a1425 1
    affect_remove( ch, paf,APPLY_BOTH );
@


1.195
log
@08DEC00
DAMN this wraithform it's gone now :)
=Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.194 2000/12/07 06:12:12 mud Exp $";
d52 1
d1374 5
d1415 9
d1425 1
@


1.194
log
@took the update.c section out so we don't have ppl dying
wondering why the skill lookup isn't working
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.193 2000/12/07 05:46:14 mud Exp $";
a51 2
/*added for wraithform check*/
bool  ch_in_wraithform = FALSE;
a1372 6
      /*28NOV00 Check to see if they're affected by wraithform*/
      if(IS_AFFECTED(ch,skill_lookup("wraithform")) )
      {
	ch_in_wraithform = TRUE;
      }

a1409 9
    /*Here goes the check to see if they're still wraithformed.  many thanks
      to Rusty for his help on this. -Boogums
    if (ch_in_wraithform == TRUE && !IS_AFFECTED(ch,skill_lookup("wraithform")) )
    {
      if (!IS_IMMORTAL(ch) && !IS_NPC(ch) && ch->desc != NULL)
        raw_kill(ch,ch);

    }
    */
@


1.193
log
@06DEC00
Ok no AFF_WRAITHFORM had to change those to skill_lookups
compiled clean testing now
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.192 2000/12/06 20:32:03 mud Exp $";
d1419 1
a1419 1
      to Rusty for his help on this. -Boogums*/
d1426 1
@


1.192
log
@06dec00
noidea but ppl are dying
~corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.191 2000/12/06 05:13:25 mud Exp $";
d1375 2
a1376 2
      /*28NOV00 Check to see if they're affected by wraithform
      if(IS_AFFECTED(ch,AFF_WRAITHFORM) )
a1379 1
      */
d1419 2
a1420 2
      to Rusty for his help on this. -Boogums
    if (ch_in_wraithform == TRUE && !IS_AFFECTED(ch,AFF_WRAITHFORM) )
a1425 1
     */
@


1.191
log
@05DEC00
Now ppl who are linkdead will not be killed, thanks to Kuno for thinking
of that
-Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.190 2000/12/03 03:24:05 mud Exp $";
d1375 1
a1375 1
      /*28NOV00 Check to see if they're affected by wraithform*/
d1380 1
d1420 1
a1420 1
      to Rusty for his help on this. -Boogums*/
a1422 1
      /*put kill command here */
d1427 1
a1427 1

@


1.190
log
@2DEC00 - Ok here goes teh necromancer kit.  changes in act_info.c act_move.c
         act_obj.c const.c figt.c mag2.c magic.c magic.h merc.h update.c
	 all sorts of cool stuff
	 -Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.189 2000/10/16 23:05:31 mud Exp $";
d225 2
a226 2
      number_percent() * number_percent() < 10        &&
      number_percent() < ch->level / 2                &&
d1423 1
a1423 1
      if (!IS_IMMORTAL(ch))
@


1.189
log
@last attacked by timer giving highbies a two tick chance to kill the lowbie
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.188 2000/09/02 22:55:58 mud Exp $";
d52 2
d216 7
d224 12
a235 1
  
d1104 2
d1375 6
d1418 10
@


1.188
log
@02SEP00 - Added nuke_pets to update.c to get rid of the warhorses
          when the life timer expires - Corey
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.187 2000/08/29 03:51:57 mud Exp $";
d380 1
d1105 7
@


1.187
log
@28AUG00 - Adde section to update.c for warhorses, we can't ahve a boring
"goes to dust" message now can we? :) Also tweaked mag2.c call_mount for
hte life timer, now twice the casters level - Boogums
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.186 2000/08/26 18:38:13 mud Exp $";
d1538 1
@


1.186
log
@remove double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.185 2000/08/24 20:11:17 mud Exp $";
d1535 6
@


1.185
log
@double skill points for double exp day
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.184 2000/08/20 00:57:43 mud Exp $";
d1093 1
a1093 1
           if (ch->pcdata->skill_point_tracker >= 100)
@


1.184
log
@highlanders regen 0 in holy ground and X3 in other
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.183 2000/08/20 00:34:58 mud Exp $";
d1093 1
a1093 1
           if (ch->pcdata->skill_point_tracker >= 35)
@


1.183
log
@highlanders are not slowed regen by slow or haste
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.182 2000/08/20 00:11:26 mud Exp $";
d590 7
d601 1
d681 13
a693 2
    if (IS_AFFECTED(ch,AFF_HASTE) || IS_AFFECTED(ch,AFF_SLOW))
        gain /=2 ;
d742 13
a754 2
    if (IS_AFFECTED(ch,AFF_HASTE) || IS_AFFECTED(ch,AFF_SLOW))
        gain /=2 ;
@


1.182
log
@highlander bugs and loggins some highlander stuff
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.181 2000/08/17 15:41:18 mud Exp $";
d585 5
a589 2
    if (IS_AFFECTED(ch,AFF_HASTE) || IS_AFFECTED(ch,AFF_SLOW))
  gain /=2 ;
@


1.181
log
@ more implementation of sanction command
 finished all but no_clan_skill
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.180 2000/08/12 18:26:03 mud Exp $";
d53 3
d1268 4
@


1.180
log
@ added second deity gift for almighty, "banishment"
 -Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.179 2000/07/25 20:13:17 mud Exp $";
d568 2
d571 2
a572 1
    
d653 2
d656 1
@


1.179
log
@missing ending )
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.178 2000/07/25 20:06:38 mud Exp $";
d1041 6
@


1.178
log
@fix matookT from rolling over and give message when you reach 12000 matook ticks
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.177 2000/07/18 00:56:55 mud Exp $";
d1202 1
a1202 1
  if (!IS_NPC(ch) && ch->clan == clan_lookup("matook")
@


1.177
log
@ when a gladiator quits, bets on him are removed
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.176 2000/07/04 00:14:00 mud Exp $";
d1202 7
a1208 2
  if (!IS_NPC(ch) && ch->clan == clan_lookup("matook"))
     ch->pcdata->matookT += 1;
@


1.176
log
@clean up syntax error
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.173 2000/06/28 20:46:05 mud Exp $";
d422 7
@


1.175
log
@opps extra )
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.174 2000/07/04 00:05:14 mud Exp $";
a1284 1

a1294 1
	 }
@


1.174
log
@gladiators fdo not lose spell duration/level during wait periods
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.173 2000/06/28 20:46:05 mud Exp $";
d1289 1
a1289 1
	     if (gladiator_info.time_left < 1 )
@


1.173
log
@small glad changes
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.172 2000/06/14 01:01:11 mud Exp $";
d1285 20
a1304 4
    paf->duration--;
    if (number_range(0,4) == 0 && paf->level > 0)
      paf->level--;  /* spell strength fades with time */
            }
@


1.172
log
@stop fighting if incap or mortal wounded and stop aggies from reattacking
this adds more use to Matooker's ability to see wounded.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.171 2000/05/29 19:37:07 mud Exp $";
d1246 1
@


1.171
log
@adding new gladiator files and tteam gladiator code with gladitor code moved
out of old files.
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.170 2000/05/27 02:44:13 mud Exp $";
d1855 1
@


1.170
log
@Kit Changing: REmove sepcial effects ( ennemy, spec)
Float: swim skill helps you vs floating away
Hold: casting level capped similar to sleep
Position for zap, brandish, quaff, recite set to Fighting
Check on eating pills for position at least of fighting
Snare: duration similar to hold

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.169 2000/05/26 01:46:31 mud Exp $";
d31 1
a51 2
void  gladiator_update args( ( void ) );
void  remove_gladiator args ((CHAR_DATA *ch));   
d1246 1
a1246 23
	   ch->clan = ch->pcdata->save_clan;
	   ch->pcdata->save_clan = 0;
	   ch->was_in_room = get_room_index(clan_table[ch->clan].hall);
	   /* Check if the gladiator has started and if so if the 
	      removal of this player leaves only 1 person */
	   if((gladiator_info.playing == 1) && gladiator_info.time_left == 0)
	   {
	      DESCRIPTOR_DATA *d;

              for(d = descriptor_list; d != NULL; d = d->next)
              {
		 if (d->character != NULL)
		 {
                 if (IS_SET(d->character->mhs, MHS_GLADIATOR))
                 {
                    sprintf(buf, "%s is victorious in the arena!", d->character->name);
                    gladiator_talk(buf); 
		    gladiator_winner(d->character);
                 }
		 }
              }
           }
	   gladiator_info.playing--;
a1933 188
}

void gladiator_update(void)
{
   char buf[MAX_STRING_LENGTH];
   DESCRIPTOR_DATA *d;
   ROOM_INDEX_DATA *random;
   sh_int time;
   sh_int team_select;

   if (gladiator_info.time_left > 0)
   {
      time = gladiator_info.time_left - 1;
      if (time > 0)
      {
         sprintf(buf, "%d tick%s left to join the Gladiator Combat. Read 'help gladiator' for more info.", time, time == 1 ? "" : "s");
         for ( d = descriptor_list; d; d = d->next )
         {
            if ( d->connected == CON_PLAYING )
            {
                 send_to_char( buf, d->character );
                 send_to_char( "\n\r",   d->character );
            }
         }

         sprintf(buf, "%d %s %s signed up to fight in the Arena so far.", gladiator_info.playing, gladiator_info.playing == 1 ? "Gladiator" : "Gladiators", gladiator_info.playing == 1 ? "is" : "are");
         gladiator_talk(buf);

         if (gladiator_info.type == 1)
         {
            sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Single Combat.", gladiator_info.min_level, gladiator_info.max_level);
         }
         if (gladiator_info.type == 2)
         {
            sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Single Combat.", gladiator_info.min_level, gladiator_info.max_level);
         }
         if (gladiator_info.type == 3)
         {
            sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Team Combat.", gladiator_info.min_level, gladiator_info.max_level);
         }
         if (gladiator_info.type == 4)
         {
            sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Team Combat.", gladiator_info.min_level, gladiator_info.max_level);
         }
         gladiator_talk(buf);
      }
      else
      {  
         if (gladiator_info.playing < 2)
         {
            sprintf(buf, "Not enough people for the Event.  Gladiator Combat ended.");
            gladiator_talk(buf);

            gladiator_info.started = FALSE;
            gladiator_info.time_left = 0;
            gladiator_info.min_level = 0;
            gladiator_info.max_level = 0;
            gladiator_info.type = 0;
            gladiator_info.playing = 0;

            for(d = descriptor_list; d != NULL; d = d->next)
            {
	       if (d->character != NULL)
	       {
               if (IS_SET(d->character->mhs, MHS_GLADIATOR))
               {
                  char_from_room(d->character);
                  char_to_room(d->character, get_room_index(clan_table[d->character->clan].hall));
                  d->character->clan = d->character->pcdata->save_clan;
                  d->character->pcdata->save_clan = 0;
                  REMOVE_BIT(d->character->mhs,MHS_GLADIATOR);
                  do_look(d->character, "auto");
               }
	       }
            }
	    return;
         }
         else
         {
            sprintf(buf, "The battle begins! %d Gladiators are fighting!", gladiator_info.playing);
            gladiator_talk(buf);

            team_select = 1;
            for(d = descriptor_list; d != NULL; d = d->next)
            {
	       if (d->character != NULL)
	       {
               if (IS_SET(d->character->mhs, MHS_GLADIATOR))
               {
                  d->character->hit  = d->character->max_hit;
                  d->character->mana = d->character->max_mana;
                  d->character->move = d->character->max_move;
		  d->character->pcdata->gladiator_attack_timer = 5;
                  update_pos(d->character);

		  if (gladiator_info.type == 1 || gladiator_info.type == 2)
                     random = get_room_index(number_range(10800,10819));

		  if (gladiator_info.type == 3 || gladiator_info.type == 4)
		  {
		     d->character->pcdata->gladiator_team = team_select;
		     if(team_select == 1)
		        team_select = 2; 
		     else
			team_select = 1;

		     if(d->character->pcdata->gladiator_team == 1)
			random = get_room_index(ROOM_VNUM_TEAM_GLADIATOR);
		     else
			random = get_room_index(ROOM_VNUM_TEAM_BARBARIAN);
		  }

                  char_from_room(d->character);
                  char_to_room(d->character, random);
                  do_look(d->character, "auto");
               }
	       }
	    }
         }
      }
      gladiator_info.time_left--;
   }
   else
   {
      if (gladiator_info.started == TRUE)
      {
	 if(gladiator_info.type == 1 || gladiator_info.type == 2)
	 {
            sprintf(buf, "The battle rages on with %d Gladiators still remaining.", gladiator_info.playing);
            gladiator_talk(buf);

            for(d = descriptor_list; d != NULL; d = d->next)
            {
               if (d->character != NULL)
               {
                  if (IS_SET(d->character->mhs, MHS_GLADIATOR))
                  {
                     d->character->pcdata->gladiator_attack_timer--;
                     if(d->character->pcdata->gladiator_attack_timer == 0)
		     {
		        if (is_affected(d->character,gsn_blindness) ||
			    d->character->pcdata->quit_time != 0)
                           d->character->pcdata->gladiator_attack_timer = 5;
                        else
                        {
                           sprintf(buf, "%s slips into a pit full of tigers, next time %s will be more active.", d->character->name,d->character->name);
                           gladiator_talk(buf);
                           remove_gladiator(d->character);
                        }
                     }
                  }
               }
            } /* for loop through players */ 
	 } /* if type 1 or 2 */

	 if (gladiator_info.type == 3 || gladiator_info.type == 4)
	 {
            sprintf(buf, "The current score is: Gladiators %d - Barbarians %d.\n\r",gladiator_info.gladiator_score,gladiator_info.barbarian_score);  
            gladiator_talk(buf);

	    gladiator_info.team_counter--;

	    if(gladiator_info.team_counter == 0)
	    {
	       if(gladiator_info.gladiator_score > gladiator_info.barbarian_score)
		  team_select = 1;
	       else
		  team_select = 2;

               for(d = descriptor_list; d != NULL; d = d->next)
               {
                  if (d->character != NULL)
                  {
                     if (IS_SET(d->character->mhs, MHS_GLADIATOR))
                     {
                        if(d->character->pcdata->gladiator_team == team_select)
			{
			   gladiator_winner(d->character);
			   d = NULL;
			}
		     }
		  }
               }
	    }
	 }
      } /* if event started */
   }
   return;
@


1.169
log
@team gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.168 2000/05/25 03:26:25 mud Exp $";
d1089 1
@


1.168
log
@declare team_select
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.167 2000/05/25 03:06:08 mud Exp $";
d2063 1
a2063 1
			random = get_room_index(10821);
d2065 1
a2065 1
			random = get_room_index(10824);
d2116 24
@


1.167
log
@working on team gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.166 2000/05/24 02:36:46 mud Exp $";
d1964 1
d2056 1
a2056 1
		     d->character->gladiator_team = team_select;
@


1.166
log
@dont disqualify if blind
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.165 2000/05/24 00:25:13 mud Exp $";
d2037 1
d2047 1
d2049 18
a2066 1
                  random = get_room_index(number_range(10800,10819));
a2069 1
		  d->character->pcdata->gladiator_attack_timer = 5;
d2081 6
a2086 5
         sprintf(buf, "The battle rages on with %d Gladiators still remaining.", gladiator_info.playing);
         gladiator_talk(buf);
         for(d = descriptor_list; d != NULL; d = d->next)
         {
            if (d->character != NULL)
d2088 1
a2088 1
               if (IS_SET(d->character->mhs, MHS_GLADIATOR))
d2090 4
a2093 6
		  d->character->pcdata->gladiator_attack_timer--;
		  if(d->character->pcdata->gladiator_attack_timer == 0)
		  {
		     if (is_affected(d->character,gsn_blindness))
			d->character->pcdata->gladiator_attack_timer = 5;
		     else
d2095 11
a2105 5
                        sprintf(buf, "%s slips into a pit full of tigers, next time %s will be more active.", d->character->name,d->character->name);
                        gladiator_talk(buf);
		        remove_gladiator(d->character);
		     }
		  }
d2107 10
a2116 3
            }
         }
      }
@


1.165
log
@force gladiators to attack eveyr 5 ticks or be disqualified
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.164 2000/05/21 04:47:47 mud Exp $";
d2074 8
a2081 4
                     sprintf(buf, "%s slips into a pit full of tigers, next time %s will be more active.", d->character->name,d->character->name);
                     gladiator_talk(buf);

		     remove_gladiator(d->character);
@


1.164
log
@add d->character != NULL checks on gladiator codes
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.163 2000/05/21 01:17:15 mud Exp $";
d52 1
d2051 1
d2065 17
@


1.163
log
@cleanup to gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.162 2000/05/21 01:11:05 mud Exp $";
d1256 2
d1264 1
d2016 2
d2027 1
d2038 2
d2051 1
@


1.162
log
@missing closing }
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.161 2000/05/21 01:10:01 mud Exp $";
d2050 5
a2054 2
      sprintf(buf, "The battle rages on with %d Gladiators still remaining.", gladiator_info.playing);
      gladiator_talk(buf);
@


1.161
log
@oopps typo
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.160 2000/05/21 01:09:05 mud Exp $";
d2047 1
@


1.160
log
@play with update function for gladiator
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.159 2000/05/21 00:28:58 mud Exp $";
d2046 1
a2046 1
      gladitor_info.time_left--;
@


1.159
log
@fix gladiator update
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.158 2000/05/20 23:48:00 mud Exp $";
d1959 1
d1963 2
a1964 2
      sprintf(buf, "%d tick%s left to join the Gladiator Combat. Read 'help gladiator' for more info.", gladiator_info.time_left, gladiator_info.time_left == 1 ? "" : "s");
      for ( d = descriptor_list; d; d = d->next )
d1966 2
a1967 1
         if ( d->connected == CON_PLAYING )
d1969 5
a1973 2
               send_to_char( buf, d->character );
               send_to_char( "\n\r",   d->character );
a1974 1
      }
d1976 2
a1977 2
      sprintf(buf, "%d %s %s signed up to fight in the Arena so far.", gladiator_info.playing, gladiator_info.playing == 1 ? "Gladiator" : "Gladiators", gladiator_info.playing == 1 ? "is" : "are");
      gladiator_talk(buf);
d1979 17
a1995 3
      if (gladiator_info.type == 1)
      {
      sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Single Combat.", gladiator_info.min_level, gladiator_info.max_level);
d1997 6
a2002 16
      if (gladiator_info.type == 2)
      {
      sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Single Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      if (gladiator_info.type == 3)
      {
      sprintf(buf, "Type of Event: Levels %d - %d, Clanner Only, Team Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      if (gladiator_info.type == 4)
      {
      sprintf(buf, "Type of Event: Levels %d - %d, Clanner and Nonclanner, Team Combat.", gladiator_info.min_level, gladiator_info.max_level);
      }
      gladiator_talk(buf);

      gladiator_info.time_left--;
   }
d2004 6
a2009 7
   if (gladiator_info.time_left == 1 && gladiator_info.started == TRUE )
   {  
      gladiator_info.time_left--;
      if (gladiator_info.playing < 2)
      {
         sprintf(buf, "Not enough people for the Event.  Gladiator Combat ended.");
         gladiator_talk(buf);
d2011 1
a2011 10
         gladiator_info.started = FALSE;
         gladiator_info.time_left = 0;
         gladiator_info.min_level = 0;
         gladiator_info.max_level = 0;
         gladiator_info.type = 0;
	 gladiator_info.playing = 0;

         for(d = descriptor_list; d != NULL; d = d->next)
         {
            if (IS_SET(d->character->mhs, MHS_GLADIATOR))
d2013 9
a2021 6
               char_from_room(d->character);
               char_to_room(d->character, get_room_index(clan_table[d->character->clan].hall));
               d->character->clan = d->character->pcdata->save_clan;
	       d->character->pcdata->save_clan = 0;
	       REMOVE_BIT(d->character->mhs,MHS_GLADIATOR);
               do_look(d->character, "auto");
d2023 1
d2025 4
a2028 5
      }
      else
      {
         sprintf(buf, "The battle begins! %d Gladiators are fighting!", gladiator_info.playing);
         gladiator_talk(buf);
d2030 1
a2030 3
         for(d = descriptor_list; d != NULL; d = d->next)
         {
            if (IS_SET(d->character->mhs, MHS_GLADIATOR))
d2032 11
a2042 8
               d->character->hit  = d->character->max_hit;
               d->character->mana = d->character->max_mana;
               d->character->move = d->character->max_move;
               update_pos(d->character);
               random = get_room_index(number_range(10800,10819));
	       char_from_room(d->character);
               char_to_room(d->character, random);
               do_look(d->character, "auto");
d2044 1
a2044 1
	 }
d2046 5
@


1.158
log
@clean up some gladiator stuff
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.157 2000/05/20 02:38:37 mud Exp $";
a1239 1
 #ifdef CODE_TEST
a1265 1
#endif
a1993 1
      return;
a1998 2
         sprintf(buf, "playing %d.",gladiator_info.playing);
         gladiator_talk(buf);
@


1.157
log
@declare glad_upate
-poq
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.156 2000/05/20 02:36:16 mud Exp $";
d1974 1
a1974 1
      sprintf(buf, "%d %s %s fighting in the Event, so far.", gladiator_info.playing, gladiator_info.playing == 1 ? "Gladiator" : "Gladiators", gladiator_info.playing == 1 ? "is" : "are");
d1977 16
a1992 1
      sprintf(buf, "Type of Event: %d - %d, %s Combat.", gladiator_info.min_level, gladiator_info.max_level, gladiator_info.type == 1 ? "Single" : "Team");
d2001 3
a2030 2
         gladiator_info.time_left--;

d2038 5
a2042 1
               random = get_room_index(number_range(700,729));
@


1.156
log
@add gladiator into update ticks
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.155 2000/05/16 00:56:02 mud Exp $";
d51 1
@


1.155
log
@add in all the #ifdef CODE_TEST for gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.154 2000/05/14 00:41:30 mud Exp $";
d1947 1
d1963 1
a1963 1
      sprintf(buf, "%d tick%s left to join the Gladiator Combat. Turn on the Gladiator channel for more info.", gladiator_info.time_left, gladiator_info.time_left == 1 ? "" : "s");
d1976 1
a1976 1
      sprintf(buf, "Type of Event: &Y%d &R- &Y%d&R, &C%s Combat&R.&w", gladiator_info.min_level, gladiator_info.max_level, gladiator_info.type == 1 ? "Single" : "Team");
@


1.154
log
@more gladiator syntax errors
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.153 2000/05/14 00:37:51 mud Exp $";
d1239 1
d1266 1
@


1.153
log
@gladiator syntax errors
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.152 2000/05/13 22:44:53 mud Exp $";
d1246 1
a1246 1
	   ch->was_in_room = clan_table[ch->clan].hall;
d1999 1
a1999 1
               char_to_room(d->character, get_room_index(clan_table[d->character->clan].hall);
@


1.152
log
@clean up couple more syntax erros in gladiator code
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.151 2000/05/13 22:37:27 mud Exp $";
d30 1
d36 1
d1008 1
a1954 1
   CHAR_DATA *ch;
@


1.151
log
@cleaning up the declarations for gladiator talk
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.150 2000/05/13 21:55:19 mud Exp $";
d1246 1
a1246 1
	   if((gladiator_info.playing -1) == 1 && gladiator_info.time_left = 0)
@


1.150
log
@Gladiator Combat - Intense!
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.149 2000/04/22 14:18:02 mud Exp $";
a32 1
DECLARE_DO_FUN(do_gladiator_winner );
d1240 1
a1240 1
           do_gladiatortalk(buf); 
d1255 2
a1256 2
                    do_gladiatortalk(buf); 
		    do_gladiator_winner(d->character);
d1969 1
a1969 1
      do_gladiatortalk(buf);
d1972 1
a1972 1
      do_gladiatortalk(buf);
d1983 1
a1983 1
         do_gladiatortalk(buf);
d2010 1
a2010 1
         do_gladiatortalk(buf);
@


1.149
log
@Took the autosave at crash out and cut the
time between autosaves in half.  Should prevent
us from going into some of the CPU loops we
do.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.148 2000/04/22 06:18:29 mud Exp $";
d33 1
d1237 27
d1949 79
@


1.148
log
@ more moving char fixes
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.147 2000/04/22 06:12:22 mud Exp $";
d1012 1
a1012 1
    if (save_number > 29)
d1477 1
a1477 1
  if (ch->desc != NULL && ch->desc->descriptor % 30 == save_number)
@


1.147
log
@ Moving chars fix, once again...problems with act...sigh
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.146 2000/04/22 05:56:20 mud Exp $";
d1003 1
a1003 1
    CHAR_DATA *ch, *rch;
d1087 41
a1127 42
         EXIT_DATA *pexit;
         int original_type, new_type;
	 int door = number_door();
	 pexit = ch->in_room->exit[door];
	 if (    ( pexit  == 0 )
		    ||   pexit->u1.to_room == NULL
		   ||   pexit->u1.to_room->clan
		  ||   IS_SET(pexit->exit_info, EX_CLOSED)
           )
	   {
	   /* do nothign, room does not exists or can't move in
	    that direction */
	   }
	 else
	 {
         new_type = pexit->u1.to_room->sector_type;
	 original_type = ch->in_room->sector_type;
         if( /* can't from air to water */
             (       original_type == SECT_AIR 
		&&  (    new_type == SECT_WATER_NOSWIM
		       || new_type == SECT_WATER_SWIM
		     )
	     )
	   || /* or from water to air */
	     (       new_type == SECT_AIR 
	        &&  (    original_type == SECT_WATER_NOSWIM
	       	     || original_type == SECT_WATER_SWIM
	            )
 	     )
	   )
	   {
	   /* do nothing to player, wrong sector types */
	   }
         else
	 {
	   /* move the player to the next room */
	    move_char(ch, door, FALSE);
         }
        
        }/* end else, for wrong sector types */
      } /* end else, for no room */
    } /* end on the NPC check */
@


1.146
log
@ More act tweaking for float code and players
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.145 2000/04/22 05:30:48 mud Exp $";
a1121 14
/* send a message to people in the original room  */  
         if (( rch = ch->in_room->people ) != NULL )
	  {
	     if ( original_type == SECT_AIR )
	     {
	       act( "$p is blown away1.", ch, NULL, NULL, TO_ROOM ,FALSE);
	       act( "$p is blown away2.", ch, NULL, rch, TO_VICT ,FALSE);
	     }
	     else
	     {
	       act( "$p is blown away.", ch, NULL, NULL, TO_ROOM ,FALSE);
	       act( "$p is blown away.", ch, NULL, rch, TO_VICT ,FALSE);
             }
	  } 
d1123 2
a1124 17
	 char_from_room(ch);
	 char_to_room(ch,pexit->u1.to_room); 

/* send a message to people in the new room with the object */  
         if (( rch = ch->in_room->people ) != NULL )
	  {
	     if ( original_type == SECT_AIR )
	     {
	       act( "$p is blown in3.", ch, NULL, NULL, TO_ROOM ,FALSE);
	       act( "$p is blown in4.", ch, NULL, rch, TO_VICT ,FALSE);
	     }
	     else
	     {
	       act( "$p floats in.", rch, ch, NULL, TO_ROOM ,FALSE);
	       act( "$p floats in.", rch, ch, NULL, TO_CHAR ,FALSE);
             }
          }
@


1.145
log
@ Moving chars for float code, bug with act messages
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.144 2000/04/22 04:57:11 mud Exp $";
d1123 1
a1123 1
          if (( rch = ch->in_room->people ) != NULL )
d1127 2
a1128 2
	       act( "$p is blown away.", rch, NULL, ch, TO_ROOM ,FALSE);
	       act( "$p is blown away.", rch, ch, NULL, TO_CHAR ,FALSE);
d1132 2
a1133 2
	       act( "$p floats away.", rch, ch, NULL, TO_ROOM ,FALSE);
	       act( "$p floats away.", rch, ch, NULL, TO_CHAR ,FALSE);
d1135 1
a1135 1
	  }
d1137 2
a1138 2
         char_from_room(ch);
	 char_to_room(ch,pexit->u1.to_room);
d1141 1
a1141 1
          if (( rch = ch->in_room->people ) != NULL )
d1145 2
a1146 2
	       act( "$p is blown in.", rch, ch, NULL, TO_ROOM ,FALSE);
	       act( "$p is blown in.", rch, ch, NULL, TO_CHAR ,FALSE);
@


1.144
log
@ typo fix used | instead of ! for not....slap self
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.143 2000/04/22 04:54:26 mud Exp $";
d1127 1
a1127 1
	       act( "$p is blown away.", rch, ch, NULL, TO_ROOM ,FALSE);
@


1.143
log
@Fixed the sleeping bag issue and float code
Added moving players in air / sea zones
Added the weaponsmith code
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.142 2000/04/18 20:33:52 mud Exp $";
d1079 1
a1079 1
	     && ( ch->in_room |= NULL )
d1643 1
a1643 1
        if (     obj->in_room |= NULL 
@


1.142
log
@fixed act ( entries
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.141 2000/04/18 19:51:08 mud Exp $";
d1003 1
a1003 1
    CHAR_DATA *ch;
d1071 88
a1158 1
            } 
d1643 1
a1643 1
        if (     obj->in_room 
d1645 1
@


1.141
log
@added a BOOL ooc as an extra arg to act() and act_new() to have it
deal properly with the BOOL in can_see() and PERS().
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.140 2000/04/18 05:07:26 mud Exp $";
d1384 1
a1384 1
     act ("$n reenters the realm of the dead.",ch,NULL,NULL,TO_ROOM);
d1388 1
a1388 1
    act ("$n decays into dust.",ch,NULL,NULL,TO_ROOM);
@


1.140
log
@ Another brace missing , which we had color enabled in the vi sessions :)
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.139 2000/04/18 05:03:33 mud Exp $";
d109 1
a109 1
		ch,NULL,NULL,TO_CHAR);
d114 1
a114 1
		ch,NULL,NULL,TO_CHAR);
d119 1
a119 1
		ch,NULL,NULL,TO_CHAR);
d124 1
a124 1
		ch,NULL,NULL,TO_CHAR);
d129 1
a129 1
		ch,NULL,NULL,TO_CHAR);
d134 1
a134 1
		ch,NULL,NULL,TO_CHAR);
d185 1
a185 1
	act("$n cringes in sudden pain.",ch,NULL,NULL,TO_ROOM);
d204 2
a205 2
	act("$p glows with a black aura.",ch,weapon,NULL,TO_CHAR);
	act("$p glows with a black aura.",ch,weapon,NULL,TO_ROOM);
d244 1
a244 1
	act("$n's body shimmers and shakes.",ch,NULL,NULL,TO_ROOM);
d828 1
a828 1
    act( "$n gets $p.", ch, obj_best, NULL, TO_ROOM );
d1068 1
a1068 1
              act("$n wanders on home.",ch,NULL,NULL,TO_ROOM);
d1155 2
a1156 2
        act( "$p goes out.", ch, obj, NULL, TO_ROOM );
        act( "$p flickers and goes out.", ch, obj, NULL, TO_CHAR );
d1160 1
a1160 1
        act("$p flickers.",ch,obj,NULL,TO_CHAR);
d1177 1
a1177 1
      ch, NULL, NULL, TO_ROOM );
d1255 1
a1255 1
			ch,NULL,NULL,TO_ROOM);
d1257 1
a1257 1
			ch,NULL,NULL,TO_CHAR);
d1263 1
a1263 1
		    ch,NULL,NULL,TO_ROOM);
d1265 1
a1265 1
		    ch,NULL,NULL,TO_CHAR);
d1282 1
a1282 1
		ch,NULL,NULL,TO_ROOM);
d1284 1
a1284 1
		ch,NULL,NULL,TO_CHAR);
d1313 1
a1313 1
    ch,NULL,NULL,TO_ROOM);
d1346 1
a1346 1
                  act("$n shivers and looks very ill.",vch,NULL,NULL,TO_ROOM);
d1367 1
a1367 1
          act( "$n shivers and suffers.", ch, NULL, NULL, TO_ROOM );
d1521 1
a1521 1
        rch,obj,NULL,TO_CHAR);
d1528 1
a1528 1
        rch,obj,NULL,TO_ALL);
d1603 2
a1604 2
	       act( "$p is blown away.", rch, obj, NULL, TO_ROOM );
	       act( "$p is blown away.", rch, obj, NULL, TO_CHAR );
d1608 2
a1609 2
	       act( "$p floats away.", rch, obj, NULL, TO_ROOM );
	       act( "$p floats away.", rch, obj, NULL, TO_CHAR );
d1621 2
a1622 2
	       act( "$p is blown in.", rch, obj, NULL, TO_ROOM );
	       act( "$p is blown in.", rch, obj, NULL, TO_CHAR );
d1626 2
a1627 2
	       act( "$p floats in.", rch, obj, NULL, TO_ROOM );
	       act( "$p floats in.", rch, obj, NULL, TO_CHAR );
d1666 1
a1666 1
        act( message, obj->carried_by, obj, NULL, TO_CHAR );
d1668 1
a1668 1
        act(message,obj->carried_by,obj,NULL,TO_ROOM);
d1677 2
a1678 2
        act( message, rch, obj, NULL, TO_ROOM );
        act( message, rch, obj, NULL, TO_CHAR );
@


1.139
log
@Missed a closing brace in obj_update
Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.138 2000/04/18 04:58:41 mud Exp $";
d1631 1
a1631 1

@


1.138
log
@ First try at doing the floating code
 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.137 2000/04/17 22:00:54 mud Exp $";
d1629 5
a1633 3
    continue;
    }
        continue;
@


1.137
log
@Added an OOC bool to can_see() and PERS() in order to
differentiate seeing them for IC and OOC stuff.
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.136 2000/03/31 16:33:44 mud Exp $";
d1553 78
@


1.136
log
@Made sure skill_point_timer never got below 0
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.135 2000/03/06 16:50:25 mud Exp $";
d1687 1
a1687 1
      ||   !can_see( ch, wch ) 
d1706 1
a1706 1
    &&   can_see( ch, vch ) )
@


1.135
log
@apply types and change affects to use them for scondary etc
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.134 2000/03/06 15:59:24 mud Exp $";
d1040 2
a1041 1
	      ch->pcdata->skill_point_timer -=  1;
@


1.134
log
@adjust affects
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.133 2000/03/03 23:17:57 mud Exp $";
d1231 1
a1231 1
    affect_remove( ch, paf,TRUE );
@


1.133
log
@ minor tweak in skill points (cosmetic only )
 instead of (--ch->skill_timer) ==0
 i did ch->skill_timer  -= 1;, then checked if == 0

Just makes it easier to read for my stupid little brain

Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.132 2000/02/25 00:56:48 mud Exp $";
d1231 1
a1231 1
    affect_remove( ch, paf );
@


1.132
log
@ removed double exp in update.c


 gain_exp function


 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.131 2000/02/24 03:13:02 mud Exp $";
d1040 3
a1042 1
	      if ((--ch->pcdata->skill_point_timer) ==  0) 
@


1.131
log
@ const.c   made elves res mental instead of charm
 magic.c   removed the level+2 < victim->level in sleep, makes no sense
	   that someone two levels under has no chance to sleep you ,
	   the level difference is taken into accoutn in saves_vs_spell

 update.c    2* gains in gain_exp until refresh
 speical.c   removed avarice as clan war winner, put in valor for now

 Minister
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.130 2000/02/24 01:00:30 mud Exp $";
a470 1
       gain *= 2; // temp bonus until refresh
@


1.130
log
@remove debug line in irradaite update
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.129 2000/02/23 21:40:13 mud Exp $";
d470 3
@


1.129
log
@add size code to start od dam mods
clear last attacked by on level
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.128 2000/02/23 17:59:33 mud Exp $";
a1003 1
    char buf[MAX_STRING_LENGTH];
a1289 3

            sprintf(buf,"d=%d dam=%d\n\r",duration,dam);
	    send_to_char(buf,ch);
@


1.128
log
@tweak irradiate
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.127 2000/02/23 17:37:39 mud Exp $";
d371 3
@


1.127
log
@looking at irradiate round dam
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.126 2000/02/18 19:10:24 mud Exp $";
d1267 1
a1267 1
	    int dam = 1;
@


1.126
log
@give 10 skill points per debit level not including remorts
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.125 2000/02/10 03:36:00 mud Exp $";
d1001 1
d1288 3
@


1.125
log
@debit levle check in gain_exp
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.124 2000/02/10 03:07:04 mud Exp $";
d429 7
@


1.124
log
@update.c  typo fix in do_level
MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.123 2000/02/10 03:05:12 mud Exp $";
d456 4
@


1.123
log
@ comm.c update.c  refresh xp calculations tweaks
 MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.122 2000/02/10 02:40:05 mud Exp $";
d425 1
a425 1
	ch->exp += exp_per_level(ch,ch->pcdata-points);
@


1.122
log
@ update.c   bug fix with do_level

	    MINISTER
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.121 2000/02/09 21:29:45 mud Exp $";
d422 1
a422 2
    if( ( ch->exp < exp_per_level(ch,ch->pcdata->points) * (ch->level+1) ) ||
	( ch->pcdata->debit_level > 0 ) )
d425 1
@


1.121
log
@removing all the qualifing and level logs getting spammy
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.120 2000/02/01 20:32:38 mud Exp $";
d422 9
a430 1

d437 1
a437 1

@


1.120
log
@Warn about clan level 20 change at level 20
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.119 2000/01/27 01:57:47 mud Exp $";
d455 1
d460 1
@


1.119
log
@Can not do_level while fighting
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.118 2000/01/22 00:12:18 mud Exp $";
d391 3
@


1.118
log
@Can only gain skill points while fighting and can gain 35 per hour now
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.117 2000/01/20 23:33:36 mud Exp $";
d412 6
@


1.117
log
@second post attempt

update.c
	advance_level: added real_size variable
			hp gains based on size of actual race and not infalted
			size created by stature

fight.c
	changed code to actually reflect what help file says about myrmidon

	in defensive skills (parry, dodge, shieldblock)
	chance is the chance of a victim to dodge an attack
	so the myrm_pen should be chance += myrm_pen instead of
	the chance-= myrm_pen., I swithced it to +=

	same principal for attacks(2nd, 3rd) check_myrm should imporve
	chance to land but this function always returned a negative.
	return from check_myrm is now positive
	return = blan - skill instead of the previous
	return = skill- blah

special.c
	add include lookup.h for the new function clanwar_winner that uses
	clan_lookup.

	clanwar_winner returns true if the char is from that clan
	name of the winning clan has to be set every month, shitty way but
	i didn't want to set it in a structure for now.

	clanwar_winner was added to spec_exec , spec_guard_l & d

comm.c
	mod to stat customization, every increase in stat is now equal between races
	You want to increase str 3 times, you pay the same if dragon or faerie.

	added function calc_stat_cost
	calculates the cost to increase a stat for that race.

	added this function where needed to calculate cost of an increase

	primary and secondary bonuses are based on OLDCLASS now.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.116 2000/01/11 17:53:53 mud Exp $";
d999 1
a999 1
           if (ch->pcdata->skill_point_tracker >= 10)
@


1.116
log
@Null point null pointer do doh
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.115 2000/01/11 01:35:34 mud Exp $";
d262 2
d279 4
a282 2
	
    add_hp += ( ch->size - 2 );
@


1.115
log
@Added the new skill point trackers to save in the pfile and show in stat
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.114 2000/01/11 00:54:54 mud Exp $";
d993 1
a993 1
        if (ch->pcdata->skill_point_tracker >= 10)
d995 2
d1001 3
a1003 2
	   if ((--ch->pcdata->skill_point_timer) ==  0) 
	      ch->pcdata->skill_point_tracker = 0;
@


1.114
log
@Track skill points , cap at 10 per hour
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.113 2000/01/08 22:07:12 mud Exp $";
d999 1
a999 1
	   if (--ch->pcdata->skill_point_timer =  0) 
@


1.113
log
@missing )
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.112 2000/01/08 21:57:55 mud Exp $";
d991 11
@


1.112
log
@Changes str/con gain code and moves
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.111 2000/01/08 07:27:56 mud Exp $";
d270 1
a270 1
    add_hp  = con_app[get_curr_stat(ch,STAT_CON)].hitp + number_range(
d272 1
a272 1
        class_table[old_class].hp_max );
d274 1
a274 1
    add_hp  = ((3*add_hp)/4) + ((con_app[get_curr_stat(ch,STAT_STR)].hitp + number_range(
d276 1
a276 1
        class_table[old_class].hp_max )/4);
@


1.111
log
@new hp and mana gains
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.110 1999/12/17 00:02:16 mud Exp $";
d274 1
a274 1
    add_hp  = (add_hp + con_app[get_curr_stat(ch,STAT_STR)].hitp + number_range(
d276 1
a276 1
        class_table[old_class].hp_max ))/2;
d278 2
a309 2
    add_hp += ( ch->size - 2 );

d349 2
a350 2
    if ( HAS_KIT(ch,"ranger") )
	add_move += 3;
d353 1
a353 1
       add_move -= 1;
d355 2
a356 2
    if ( ch->race == race_lookup("rockbiter") )
       add_move -= 1;
@


1.110
log
@Remove Savant and Scion stuff
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.109 1999/12/08 22:00:03 mud Exp $";
d273 5
d320 1
d323 1
d333 1
d335 13
d353 3
@


1.109
log
@Aggressive monsters will stand if they can before attacking
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.108 1999/12/01 21:21:05 mud Exp $";
d960 1
d962 3
@


1.108
log
@ changed mounts to only wander home whn no one is on them, instead of never
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.107 1999/11/26 20:24:41 mud Exp $";
d34 1
d1632 3
@


1.107
log
@ Mounts will no longer "wander on home"

 Rage.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.106 1999/11/19 19:26:21 mud Exp $";
d981 2
a982 2
	  && !IS_SET(ch->act, ACT_MOUNT))
            {
@


1.106
log
@New savant code
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.105 1999/11/08 18:44:32 mud Exp $";
d980 2
a981 1
	  && ch->in_room != get_room_index(ROOM_VNUM_LIMBO))
@


1.105
log
@Remove the ITEM_WEAR_TIMER to recompile code for game port
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.104 1999/11/07 01:15:02 mud Exp $";
d161 1
a161 2
	    if ( number_percent() * number_percent() < ch->pcdata->savant 
	     &&  number_percent() * number_percent() < ch->pcdata->savant )
a165 2
	    ch->pcdata->perm_hit += 5;
	    ch->max_hit += 5;
d175 1
d181 1
@


1.104
log
@Rewrite the WEAR TImer code to check if obj->carried_by is NULL
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.103 1999/11/07 01:07:58 mud Exp $";
d1454 1
d1466 1
d1469 2
a1470 1
  }
@


1.103
log
@remove 'ch' from Wear timer check, instead use obj->carried_by
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.102 1999/11/07 00:56:05 mud Exp $";
d1453 2
a1454 2
  if (IS_SET(obj->extra_flags,ITEM_WEAR_TIMER)
      && obj == get_eq_char( obj->carried_by, obj->wear_loc ) )
d1456 6
a1461 2
     if (obj->wear_timer <= 0 || --obj->wear_timer > 0)
	continue;
@


1.102
log
@Wear Timer for Objects
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.101 1999/11/05 21:14:55 mud Exp $";
d1454 1
a1454 1
      && obj == get_eq_char( ch, obj->wear_loc ) )
@


1.101
log
@Mummy gains -1 move on level
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.100 1999/11/04 17:58:39 mud Exp $";
d1452 12
a1463 3

  if ( obj->timer <= 0 || --obj->timer > 0 )
      continue;
@


1.100
log
@Fix the cosmetic qualifies for count bug, moves the count++ to the
end of the while loop, since count starts at 1
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.99 1999/11/03 02:43:34 mud Exp $";
d330 3
@


1.99
log
@is_set to IS_SET.. geez picky!
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.98 1999/11/03 02:20:35 mud Exp $";
a412 1
   count++;
d421 1
@


1.98
log
@Mummy's rages burn up not blood torment
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.97 1999/11/02 22:08:27 mud Exp $";
d996 1
a996 1
	  if(is_set(ch->act,PLR_MUMMY))
d1004 1
a1004 1
	  if(is_set(ch->act,PLR_MUMMY))
@


1.97
log
@Just added some GSN's (fade and vision) and made some minor adjustments to the vision potion effect.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.96 1999/10/31 03:06:00 mud Exp $";
d996 4
a999 1
	  send_to_char("Your blood torments you.\n\r",ch);
d1004 4
a1007 1
	  send_to_char("Your blood torments you.\n\r",ch);
@


1.96
log
@Doh should be ch->act, not ch->plr for PLR_MUMMY regen
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.95 1999/10/31 03:04:51 mud Exp $";
d372 2
a373 1
    if ( ch->pcdata->debit_level <= 0 ) {
d383 7
a389 1
    ch->pcdata->debit_level--;
d404 1
d411 1
a411 1
  exp_per_level(ch,ch->pcdata->points) * (ch->level+1+ch->pcdata->debit_level) )
d413 2
a414 2
   ch->pcdata->debit_level++;
   sprintf(buf,"You qualify for level %d!!\n\r", ch->level + ch->pcdata->debit_level );
d416 1
a416 1
       sprintf(buf,"%s qualifies for level %d",ch->name,ch->level+ch->pcdata->debit_level );
d418 1
a418 1
        sprintf(buf,"$N qualifies for level %d!",ch->level+ch->pcdata->debit_level );
@


1.95
log
@Mummy regeneration
-poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.94 1999/10/20 21:45:31 mud Exp $";
d460 1
a460 1
       if(IS_SET(ch->plr,PLR_MUMMY) && !IS_NPC(ch))
d538 1
a538 1
       if(IS_SET(ch->plr,PLR_MUMMY) && !IS_NPC(ch))
@


1.94
log
@Put an IS_IMMORTAL check before Killing a shapeshifter.. Dont want to
kill Immortals.
-POquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.93 1999/10/08 20:43:43 mud Exp $";
d460 6
d536 8
@


1.93
log
@Final commit on debit levels.  Going to add it to score on the next one.
G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.92 1999/10/08 20:36:27 mud Exp $";
d88 2
a89 1
	 raw_kill(ch,ch);
@


1.92
log
@Working on a bug fix in do_level and exp_gain
G
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.91 1999/10/08 20:16:11 mud Exp $";
d405 1
a405 1
   sprintf(buf,"You qualify for level %d!!\n\r", ch->level + 1 );
d407 1
a407 1
       sprintf(buf,"%s qualifies for level %d",ch->name,ch->level+1);
d409 1
a409 1
        sprintf(buf,"$N qualifies for level %d!",ch->level+1);
@


1.91
log
@Fight.c -> changed xp_compute
interp.c, interph -> added a command 'level'
merc.h -> added structure for debit_levels and define for PREFRESH
save .h -> save debit levels
update.c -> change advancement, contains do_olevel function

Coded by Ben
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.90 1999/10/02 00:09:11 mud Exp $";
d402 1
a402 1
  exp_per_level(ch,ch->pcdata->points) * (ch->level+1) )
@


1.90
log
@New Shapeshifter Power - Shapemorph
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.89 1999/09/16 03:47:12 mud Exp $";
a263 1

d365 15
d381 11
d404 4
a407 3
  send_to_char( "You raise a level!!  ", ch );
  ch->level += 1;
       sprintf(buf,"%s gained level %d",ch->name,ch->level);
d409 1
a409 1
        sprintf(buf,"$N has attained level %d!",ch->level);
d411 1
a411 1
  advance_level( ch );
@


1.89
log
@*** empty log message ***
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.88 1999/09/16 02:41:10 mud Exp $";
d55 1
a55 1
   if(IS_SET(ch->mhs,MHS_SHAPESHIFTED))
d57 1
a57 1
      if (ch->race != ch->save_race)
d74 1
d76 2
d84 2
a85 1
	 shapeshift_remove(ch);
d87 1
@


1.88
log
@Updating CVS
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.87 1999/09/06 03:37:32 mud Exp $";
d278 2
a292 1
    {
a293 2
	add_hp -= number_range(3,5);    
    }
d298 1
a298 8
    if ( ch->race == race_lookup("giant") )
	add_hp += number_range(3,4);
   
    if ( ch->race == race_lookup("ogre") )
	add_hp += number_range(2,3);

    if ( ch->race == race_lookup("rockbiter") )
	add_hp += con_app[get_curr_stat(ch,STAT_CON)].hitp;
a317 4
    /* hp curve for rockbiter */
    if ( add_hp >= 25 )
	add_hp = ( add_hp - 25 ) / 2 + 25;

a325 3
    if ( add_hp > 26 )
	add_hp = ( add_hp - 26 ) /2 + 26;

a330 12

    if ( IS_SET(ch->mhs,MHS_SAVANT) &&
	 ch->level % 10 == 0 )
    {
	send_to_char("The Savant has blessed you.\n\r",ch);
	 ch->train++;
    }

    /* 10 extra trains for capped characters */
    if ( IS_CAPPED(ch) )
	ch->train += ( ch->level % 5 == 0 );

@


1.87
log
@Savant stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.86 1999/09/03 19:26:06 mud Exp $";
d253 1
d268 1
d277 10
d288 1
a288 1
	add_mana += number_range(2,5);
d292 1
a292 1
        add_mana = 6 * add_mana / 3;
a295 3
    if ( ch->class == class_lookup("druid") )
	add_mana += number_range(2,3);

d297 1
a297 1
    	add_mana += get_curr_stat(ch,STAT_WIS) / 8;
d311 1
a311 1
  add_mana /= 2;
d316 1
a316 1
  add_mana = 3 * add_mana / 4;
d330 1
d332 1
a332 6
    /*if ( class_table[ch->class].fMana )
    */
    if ( class_table[old_class].fMana )
      add_mana  = UMAX((get_curr_stat(ch,STAT_INT)+get_curr_stat(ch,STAT_WIS))/10, add_mana );
    else
      add_mana = UMAX( 2, add_mana );
@


1.86
log
@Added skill points, will implement that later.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.85 1999/08/26 16:37:55 mud Exp $";
d97 2
a98 1
       switch( number_range( 1, 500 ) )
d103 1
a103 1
	   ch->pcdata->savant += 5;
d126 1
a126 1
	    act("Your soul cries out in agony for its sins.",
d128 7
a134 2
	    ch->hit = UMAX(1, ch->hit - 20 );
	    break;
d136 18
a153 6
	    if ( number_percent() > 5 )
		break;
	    ch->pcdata->perm_hit += 10;
	    ch->max_hit += 10;
	    send_to_char("You have been blessed by the Savant.\n\r",ch);
	    break;
d155 3
a157 12
       case 26:
       case 27:
       case 28:
       case 29:
       case 30:
       case 31:
       case 32:
       case 33:
       case 34:
       case 35:
	    if ( number_percent() > 5 )
		return;
d161 2
a162 2
	    ch->pcdata->perm_hit += 25;
	    ch->max_hit += 25;
d164 1
d170 2
a171 1
   if ( !IS_IMMORTAL(ch) && number_percent() * number_percent() < 10 &&
d173 1
a173 1
	dice(3,6) < get_curr_stat(ch,STAT_INT)
@


1.85
log
@Changes
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.84 1999/08/23 03:34:52 mud Exp $";
d137 10
d150 1
@


1.84
log
@Son of a bitch pain in my ass fucking mount code.
Just look at that list of files.  Keeeeerist.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.83 1999/08/21 21:22:47 mud Exp $";
d174 1
d176 3
@


1.83
log
@Savant stuff
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.82 1999/08/19 16:30:39 mud Exp $";
d1030 11
a1040 1
        char_to_room( ch, get_room_index( ROOM_VNUM_LIMBO ) );
@


1.82
log
@Increase and decrease the possible chance for adjustment onm shapeshifting Con
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.81 1999/08/12 01:04:02 mud Exp $";
d96 1
a96 1

d147 1
a147 1

d149 1
a149 2
   if ( number_percent() <= 1 && !IS_IMMORTAL(ch) )
   if ( number_percent() * number_percent() < 10 &&
d151 2
a152 1
	dice(3,6) < get_curr_stat(ch,STAT_INT))
@


1.81
log
@Nethermancers are in
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.80 1999/08/11 20:38:37 mud Exp $";
d59 1
a59 1
         if ( number_percent() <= 30 )
d67 1
a67 1
	 if ( number_percent() <= 30)
@


1.80
log
@Changes to bishop and vindicator
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.79 1999/08/09 22:08:32 mud Exp $";
d164 6
d171 7
d901 1
@


1.79
log
@Removed all of Rusty's cheat codes.
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.78 1999/07/23 20:01:14 mud Exp $";
d249 1
a249 1
    	add_mana += get_curr_stat(ch,STAT_WIS) / 5;
@


1.78
log
@Removing Approval Code
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.77 1999/07/23 02:57:42 mud Exp $";
a277 5
    /* if(IS_SET(ch->act,PLR_OLD)) add_hp += 4;
       if(IS_SET(ch->act,PLR_OLD)) add_mana += 4;
       if(IS_SET(ch->act,PLR_OLD)) add_prac += 2;
     */

a352 1
	if(IS_SET(ch->act,PLR_OLD)) gain *= 2;
@


1.77
log
@Add a new Notice Helpfile when level==4 and name not approved
-Poquah
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.76 1999/07/22 01:07:30 mud Exp $";
a219 12
    if ( IS_SET(ch->mhs,MHS_UNAPPROVED) )
    { 
	if ( ch->level < 5 ) 
	    wiznet("$N needs name approval.",ch,NULL,WIZ_LEVELS,0,0);
         else
	 {
	    wiznet("{R$N stalled pending name approval.{x",
			ch,NULL,WIZ_LEVELS,0,0);
	    return;
	 }
    }
   
a333 6

    if ( IS_SET(ch->mhs,MHS_UNAPPROVED) )
    {
       if (ch->level == 4)
	  do_help(ch,"levelfour");
    }
@


1.76
log
@Ommented out some shit
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.75 1999/07/14 19:00:21 mud Exp $";
d346 6
@


1.75
log
@Had to put lookup.h after merc.h so args() would be defined first
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.74 1999/07/14 18:48:27 mud Exp $";
d290 4
a293 3
    if(IS_SET(ch->act,PLR_OLD)) add_hp += 4;
    if(IS_SET(ch->act,PLR_OLD)) add_mana += 4;
    if(IS_SET(ch->act,PLR_OLD)) add_prac += 2;
@


1.74
log
@Cleaned up warning for clan_lookup by adding lookup.h #include
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.73 1999/07/14 18:14:13 mud Exp $";
d27 1
a28 1
#include "merc.h"
@


1.73
log
@Changed the /**/ RCS Id to a static char rcsid[] = "Id";
-Rusty
@
text
@d18 1
a18 1
static char rcsid[] = "$Id: update.c,v 1.72 1999/07/10 00:11:39 mud Exp $";
d27 1
@


1.72
log
@Name approval
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.71 1999/07/05 21:58:24 mud Exp $ */
@


1.71
log
@Changing Mana gains to look at fMana of old_class
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.70 1999/07/05 21:54:38 mud Exp $ */
d219 12
@


1.70
log
@Changing ch->class to ch->old_class for mana gains
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.69 1999/06/20 20:29:25 mud Exp $ */
d261 1
a261 1
    if (class_table[ch->old_class].fMana == 0)
d266 1
a266 1
    if ( class_table[ch->old_class].fMana == 1 )
d288 1
a288 1
    if ( class_table[ch->old_class].fMana )
@


1.69
log
@Bladesinger
Battlerager
Done
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.68 1999/06/11 23:40:43 mud Exp $ */
d259 3
a261 1
    if (class_table[ch->class].fMana == 0)
d264 3
a266 1
    if ( class_table[ch->class].fMana == 1 )
d286 3
a288 1
    if ( class_table[ch->class].fMana )
@


1.68
log
@Added some savant stuff abck in, I wnat to give it a sedcond run
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.67 1999/06/11 23:21:59 mud Exp $ */
d1034 2
@


1.67
log
@Stuff I changed.  mostly updates of existing files and changes to seer
and flee.
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.66 1999/05/19 05:29:27 mud Exp $ */
d94 1
a94 2
/**
   if ( IS_SET(ch->mhs,MHS_SAVANT)
d116 1
a116 1
		ch->pcdata->savant == 4;
d121 1
d136 3
a146 2
       return;
   }
d149 2
a150 1
   if ( number_percent() < ch->level &&
d159 1
a159 1
 */
@


1.66
log
@Fix killing shapeshift, con never hits 0, have to kill them at 3
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.65 1999/05/19 04:50:38 mud Exp $ */
d94 2
a95 2
   if ( IS_SET(ch->mhs,MHS_SAVANT) )
	REMOVE_BIT(ch->mhs,MHS_SAVANT);
d97 1
a97 2
/**
       switch( number_range( 1, 50 ) )
d102 1
d107 1
d110 1
a110 1
	    act("You double in pain as a high scream pierces your head.",
d112 1
d117 1
@


1.65
log
@Poquah you are on dope man dont forget to declare the debug variable!
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.64 1999/05/19 04:48:09 mud Exp $ */
a53 3
   sh_int tmp = 0;
    char buf[MAX_STRING_LENGTH];

d58 1
a58 4
         tmp = number_percent();
	 sprintf(buf,"num = %d",tmp);
	 send_to_char(buf,ch);
         if ( tmp <= 15 )
d66 3
a68 4
         tmp = number_percent();
	 sprintf(buf,"num = %d",tmp);
	 send_to_char(buf,ch);
	 if ( tmp <= 20)
d70 1
d76 2
a77 2
      /* If a Shapeshifter hits 0 Con Kill them */
      if (get_curr_stat(ch,STAT_CON) <= 0)
@


1.64
log
@debug code for shapeshifting
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.63 1999/05/19 04:33:51 mud Exp $ */
d54 3
@


1.63
log
@Up % for shapeshift, didnt seem to adjust
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.62 1999/05/19 00:05:15 mud Exp $ */
d58 4
a61 1
         if ( number_percent() <= 15 )
d69 4
a72 1
	 if ( number_percent() <= 20)
@


1.62
log
@use get_curr_stat for comparison of CON for shapeshifter death
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.61 1999/05/18 19:04:33 mud Exp $ */
d58 1
a58 1
         if ( number_percent() <= 5 )
d66 1
a66 1
	 if ( number_percent() <= 10)
@


1.61
log
@Declare shapeshift_remove just to be clean
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.60 1999/05/18 19:01:30 mud Exp $ */
d74 1
a74 1
      if (ch->mod_stat[STAT_CON] <= 0)
@


1.60
log
@Typoed REMOVE_BUT = REMOVE_BIT
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.59 1999/05/18 18:58:09 mud Exp $ */
d46 1
@


1.59
log
@If shapeshifter goes to 0 CON kill them
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.58 1999/05/18 18:33:10 mud Exp $ */
d77 1
a77 1
	 REMOVE_BUT(ch->mhs,MHS_SHAPESHIFTED);
@


1.58
log
@Missing end of line ;
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.57 1999/05/18 18:19:01 mud Exp $ */
d70 9
@


1.57
log
@SHapeshifter changes - Add Saves Penalty, Slow Regen of Con mod
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.56 1999/05/17 05:52:51 mud Exp $ */
d69 1
a69 1
	    REMOVE_BIT(ch->mhs,MHS_SHAPESHIFTED)
@


1.56
log
@Shapeshifts can lose 1 con at a %5 chance, not 3, I typoed
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.55 1999/05/17 05:49:10 mud Exp $ */
d55 16
a70 2
      if ( number_percent() <= 5 )
	 ch->mod_stat[STAT_CON] -= 1;
@


1.55
log
@Shapeshifters have a %5 chance of losing another 1 con
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.54 1999/05/15 16:39:06 mud Exp $ */
d56 1
a56 1
	 ch->mod_stat[STAT_CON] -= 3;
@


1.54
log
@Rangers.
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.53 1999/05/05 21:54:16 mud Exp $ */
d51 11
d853 1
@


1.53
log
@Fixed crash bug with do_mstat() and matook timer pcdata.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.52 1999/05/04 10:43:23 mud Exp $ */
d244 3
@


1.52
log
@Yanked savant code, minor adjustment todbite
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.51 1999/05/04 01:08:33 mud Exp $ */
a56 1
   {
d59 1
d105 1
a105 2

/*
@


1.51
log
@Removed Matook COunter Debug message
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.50 1999/05/04 01:04:17 mud Exp $ */
d32 1
a32 1

a57 1
       if ( IS_IMMORTAL(ch) )
a89 1
	    REMOVE_BIT(ch->mhs,MHS_SAVANT);
d94 5
a103 4

   /* Add when the quest is over 
   REMOVE_BIT(ch->mhs,MHS_SAVANT);
   return;  **/
d106 1
d117 2
@


1.50
log
@Debugging Matook Timer
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.49 1999/05/04 00:43:33 mud Exp $ */
a917 2
  {
     send_to_char("Updating matook timer\n\r",ch);
a918 1
  }
@


1.49
log
@Matooker Timer and only Matookers with 100 hours can Guild
-Poquah
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.48 1999/05/03 08:00:23 mud Exp $ */
d918 2
d921 1
@


1.48
log
@Bank code.
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.47 1999/04/28 08:09:32 mud Exp $ */
d916 3
@


1.47
log
@Last bit of Svant code before the big quest
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.46 1999/04/26 07:54:47 mud Exp $ */
d279 10
@


1.46
log
@Added the neat echoes to the savnt stuff in update.c and fixed
a grammar error in magic.c for the noid flag -G
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.45 1999/04/26 05:30:59 mud Exp $ */
d58 3
d78 1
d83 13
d107 1
a107 1
   if ( number_percent() <= 1 )
d252 7
@


1.45
log
@Stuff for the Savant quest
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.44 1999/04/24 13:32:18 mud Exp $ */
d53 1
a53 1
   if ( IS_NPC(ch) || IS_SET(ch->mhs,MHS_SAVANT) )
d56 30
a85 1
/* When the quest is over  yank bits to reuse later
d87 2
a88 2
   return
 */
d90 2
a91 2
   if ( number_percent() < 5 &&
	number_percent() < ch->level &&
@


1.44
log
@Make Mutants have a chance to mutate more often than evey 15 levels.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.43 1999/04/24 03:08:08 mud Exp $ */
d51 22
d774 1
@


1.43
log
@do_mutate could assign a race greater than the # of available races.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.42 1999/04/24 02:04:52 mud Exp $ */
d57 1
a57 1
   if ( --ch->pcdata->mutant_timer < number_percent() )
@


1.42
log
@Added the mutant's timer to the mstat command
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.41 1999/04/23 01:59:31 mud Exp $ */
d64 1
a64 1
	new_race = number_range( 1, MAX_PC_RACE );
@


1.41
log
@Fixed a miscalculation in the mutant code.
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.40 1999/04/23 00:09:41 mud Exp $ */
a67 3
	ch->pcdata->points = UMAX(0,ch->pcdata->points -
				   pc_race_table[ch->race].points);

d83 1
a83 2
	ch->pcdata->points += pc_race_table[new_race].points;
	ch->pcdata->points = pc_race_table[new_race].size;
@


1.40
log
@Mutants are done!
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.39 1999/03/30 16:54:05 mud Exp $ */
d68 2
a69 1
	ch->pcdata->points -= pc_race_table[ch->race].points;
@


1.39
log
@Ruffian timer only clicks down when ch->pcdata->quit_time == 0
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.38 1999/03/30 16:51:05 mud Exp $ */
d52 42
d753 2
@


1.38
log
@Ruffian timer will not tick off while in mid-combat.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.37 1999/03/30 15:23:48 mud Exp $ */
d786 2
a787 1
  if (!IS_NPC(ch) && ch->pcdata && ch->pcdata->ruffT > 0)
d791 2
a792 1
	&& IS_SET(ch->wiznet,PLR_RUFFIAN) && ch->fighting == NULL )
@


1.37
log
@Added a RUFFIAN flag timer so they eventually wear off.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.36 1999/03/29 19:12:14 mud Exp $ */
d790 1
a790 1
	&& IS_SET(ch->wiznet,PLR_RUFFIAN) )
@


1.36
log
@Changes to kender, lashers and half-elves.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.35 1999/01/12 17:45:06 mud Exp $ */
d785 10
@


1.35
log
@Faerie mana adjustment
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.34 1999/01/06 20:07:07 mud Exp $ */
d84 1
a84 1
    if ( ch->race == race_lookup("elf") )
@


1.34
log
@COmmented out some unused plague var's for contagion affect.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.33 1998/12/13 22:51:49 mud Exp $ */
d89 1
a89 1
        add_mana = 5 * add_mana / 3;
@


1.33
log
@plague conatgion affect removed
:wq
;
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.32 1998/12/12 01:20:58 mud Exp $ */
d932 2
d936 1
@


1.32
log
@Error checking
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.31 1998/12/08 22:38:14 mud Exp $ */
d957 1
d978 1
@


1.31
log
@Fixed some bugs
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.30 1998/12/08 01:54:15 mud Exp $ */
d95 3
@


1.30
log
@barbarians are done
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.29 1998/11/14 07:15:56 mud Exp $ */
d114 4
@


1.29
log
@Finished the damn reclass changed finally.
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.28 1998/10/30 15:27:18 mud Exp $ */
a854 1
    
@


1.28
log
@committing Guerrand mods.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.27 1998/10/20 00:42:33 mud Exp $ */
d63 2
d67 3
d74 2
a75 2
        class_table[ch->class].hp_min,
        class_table[ch->class].hp_max );
d107 4
d119 4
d138 5
@


1.27
log
@Races
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.26 1998/10/13 23:07:45 mud Exp $ */
d116 3
@


1.26
log
@Changed to rockbiter hp gains and faerie saves
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.25 1998/10/11 06:56:20 mud Exp $ */
d91 4
a94 2
    if ( ch->race == race_lookup("giant") ||
	 ch->race == race_lookup("ogre") )
@


1.25
log
@Sliht improvemens to elves
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.24 1998/10/11 00:26:38 mud Exp $ */
d96 1
a96 1
	add_hp += ( number_range(2,4) + get_age(ch) / 10 );
@


1.24
log
@fixed a bug
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.23 1998/10/11 00:25:46 mud Exp $ */
d80 1
a80 1
	add_mana += number_range(2,3);
d84 1
a84 1
        add_mana *= 2;
@


1.23
log
@added specialize to skills
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.22 1998/10/08 14:47:27 mud Exp $ */
d96 1
a96 1
	add_hp + ( number_range(2,4) + get_age(ch) / 10 );
@


1.22
log
@... and added an !IS_NPC() check
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.21 1998/10/08 14:46:25 mud Exp $ */
d96 1
a96 1
	add_hp += get_age(ch) / 10;
@


1.21
log
@Moved outcast timer out of restricting if()
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.20 1998/10/08 14:14:26 mud Exp $ */
d753 1
a753 1
  if (ch->pcdata && ch->pcdata->outcT > 0)
@


1.20
log
@Added timers to being an Outcast.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.19 1998/10/02 23:39:35 mud Exp $ */
d753 3
a779 3

      if (ch->pcdata && ch->pcdata->outcT > 0)
          --ch->pcdata->outcT;
@


1.19
log
@Faeries adjusted, maladictions hurt more
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.18 1998/09/20 07:46:20 mud Exp $ */
d777 3
@


1.18
log
@Fixed faerie mana gains a bit.  Tested them by advancing one to 51 with a
re-imb and it had 200 hp :)  So, gave them double mana.  Added dodge size
stuff.
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.17 1998/09/20 03:46:49 mud Exp $ */
d85 1
a85 1
	add_hp -= number_range(2,3);    
@


1.17
log
@Added faeries, changed race display in login
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.16 1998/08/30 03:33:41 mud Exp $ */
d84 1
a84 1
        add_mana = ( 3 * add_mana ) / 2;
@


1.16
log
@MOved a buttload of bits around, added a converter to save.c.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.15 1998/08/20 21:05:40 mud Exp $ */
d81 6
@


1.15
log
@Moved trumps sac rank clan deity and switched from
char_data to pc_data.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.14 1998/08/13 16:22:26 mud Exp $ */
d680 1
a680 1
     if ( IS_SET(ch->comm, COMM_PROMPT) && (ch->desc))
@


1.14
log
@Combined damage() and damage_old() into damage() adding
a boll at the end 'iOld' for "is old" and appropriate if()'s
for the differences.  Added FALSE bool to damage() calls in fight.c
and replaced calls with calls to bramage() in other locations.
Made damage_old() call damage() with TRUE for iOld instead of
duplicating mass amounts of code.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.13 1998/08/13 14:38:42 mud Exp $ */
d839 52
@


1.13
log
@Modified rockbiter 1/2 tick gains (too slow) and
changed the drunk condition check to have them recover
from their drunken state.
-Rusty
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.12 1998/08/13 05:24:14 mud Exp $ */
d734 1
a734 1
      damage( ch, ch, 1, TYPE_UNDEFINED, DAM_NONE,FALSE);
d738 1
a738 1
      damage( ch, ch, 1, TYPE_UNDEFINED, DAM_NONE,FALSE);
@


1.12
log
@* Various bug fixes, mostly
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.11 1998/08/12 08:20:24 mud Exp $ */
a67 4
  /*  sprintf( buf, "the %s",
  title_table [ch->class] [ch->level] [ch->sex == SEX_FEMALE ? 1 : 0] );
    set_title( ch, buf ); */

d235 1
a235 1
	gain /= 2;
d309 1
a309 1
	gain /= 2;
d359 1
a359 1
	gain /= 2;
d789 1
a789 1
	gain_condition( ch, COND_DRUNK,  -1 );
@


1.11
log
@* Finished traps
* Rockbiters added
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.10 1998/08/10 19:41:26 mud Exp $ */
d238 3
d312 3
d362 3
a993 1
	      --raf->level;
@


1.10
log
@* Starter code for 'feign death'
* Protection neutral added
* Fixed bug with vampires
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.9 1998/08/07 20:20:03 mud Exp $ */
d93 3
d367 3
@


1.9
log
@Room affects stuff for traps.
Bleed/vampire changes.
swim/scan start at 50% and 50%up for free for existing characters.
moved trap to after trip in interp list for grandfathered use
- Both of Us
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.8 1998/08/05 10:25:33 mud Exp $ */
d781 1
a781 1
	   ( time_info.hour < 5 && time_info.hour > 20 ) ) )
@


1.8
log
@* minor bug fixes
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.7 1998/08/05 09:14:34 mud Exp $ */
d44 1
d781 1
a781 1
	   ( weather_info.sunlight < 5 && weather_info.sunlight > 20 ) ) )
d955 40
d996 8
d1282 1
@


1.7
log
@* Removes shout, added a 'silence' command to stiffle game spam
* Added saves to score
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.6 1998/08/05 06:59:15 mud Exp $ */
a373 5
    if ( IS_SET(ch->act,PLR_VAMP) )
    {
	send_to_char("Your throat aches for blood.\n\r",ch);
	return;
    }
d378 4
a381 1
      send_to_char( "You are hungry.\n\r",  ch );
d385 4
a388 1
      send_to_char( "You are thirsty.\n\r", ch );
@


1.6
log
@* Fire breath blind effect lowered to 0 ticks from 1
* Few minor aesthetic fixes in spells and eating code

-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.5 1998/08/05 06:31:19 mud Exp $ */
d369 3
d628 2
a629 1
      &&   IS_AWAKE(d->character) )
@


1.5
log
@* Fixed wiznet notes
* Added feast/famine spells
* Changed nosferatu bleed/hunger stuff
* Upped damage on bleed
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.4 1998/08/05 04:44:58 mud Exp $ */
d371 6
@


1.4
log
@* Changed mana gain formula slightly:
Minimum mana gain is now ( int + wis ) / 10.  So if you max out int and wis, the least mana youi'll get is 5.  2 for warriors/thieves.
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.3 1998/08/04 16:34:42 mud Exp $ */
d103 4
a106 1
    add_mana  = UMAX((get_curr_stat(ch,STAT_INT)+get_curr_stat(ch,STAT_WIS))/10, add_mana );
d767 4
d774 1
@


1.3
log
@* Gave berserk to all dwarves
* Minor tweaks of other races (+con for ogres/giants)
* Changes volare CP
* Gave ogres/giants increased hit point gains a la elf mana
-Ben
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.2 1998/07/31 20:37:46 mud Exp $ */
d103 1
a103 1
    add_mana  = UMAX(  2, add_mana );
@


1.2
log
@fMana mods
@
text
@d18 1
a18 1
/* @@(#)$Id: update.c,v 1.1 1998/06/16 17:49:47 mud Exp $ */
d87 4
@


1.1
log
@Initial insert of all src files.
@
text
@d18 1
a18 1
/* @@(#)$Id$ */
d83 1
a83 1
	add_mana += number_range(1,2);
d88 1
a88 1
    if (!class_table[ch->class].fMana)
d262 1
a262 1
  if (!class_table[ch->class].fMana)
@
